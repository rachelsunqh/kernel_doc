

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Userland interfaces &mdash; The Linux Kernel 4.15.0-rc7 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel 4.15.0-rc7 documentation" href="../index.html"/>
        <link rel="up" title="Linux GPU Driver Developer’s Guide" href="index.html"/>
        <link rel="next" title="drm/i915 Intel GFX Driver" href="i915.html"/>
        <link rel="prev" title="Mode Setting Helper Functions" href="drm-kms-helpers.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.15.0-rc9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer&#8217;s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms.html">Kernel Mode Setting (KMS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms-helpers.html">Mode Setting Helper Functions</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Userland interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#libdrm-device-lookup">libdrm Device Lookup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#primary-nodes-drm-master-and-authentication">Primary Nodes, DRM Master and Authentication</a></li>
<li class="toctree-l3"><a class="reference internal" href="#open-source-userspace-requirements">Open-Source Userspace Requirements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#render-nodes">Render nodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ioctl-support-on-device-nodes">IOCTL Support on Device Nodes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#recommended-ioctl-return-values">Recommended IOCTL Return Values</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#testing-and-validation">Testing and validation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#validating-changes-with-igt">Validating changes with IGT</a></li>
<li class="toctree-l4"><a class="reference internal" href="#display-crc-support">Display CRC Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#debugfs-support">Debugfs Support</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#sysfs-support">Sysfs Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vblank-event-handling">VBlank event handling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="i915.html">drm/i915 Intel GFX Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="meson.html">drm/meson AmLogic Meson Video Processing Unit</a></li>
<li class="toctree-l2"><a class="reference internal" href="pl111.html">drm/pl111 ARM PrimeCell PL111 CLCD Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tegra.html">drm/tegra NVIDIA Tegra GPU and display driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tinydrm.html">drm/tinydrm Driver library</a></li>
<li class="toctree-l2"><a class="reference internal" href="tve200.html">drm/tve200 Faraday TV Encoder 200</a></li>
<li class="toctree-l2"><a class="reference internal" href="vc4.html">drm/vc4 Broadcom VC4 Graphics Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="bridge/dw-hdmi.html">drm/bridge/dw-hdmi Synopsys DesignWare HDMI Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="todo.html">TODO list</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Linux GPU Driver Developer&#8217;s Guide</a> &raquo;</li>
      
    <li>Userland interfaces</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/gpu/drm-uapi.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="userland-interfaces">
<h1>Userland interfaces<a class="headerlink" href="#userland-interfaces" title="Permalink to this headline">¶</a></h1>
<p>The DRM core exports several interfaces to applications, generally
intended to be used through corresponding libdrm wrapper functions. In
addition, drivers export device-specific interfaces for use by userspace
drivers &amp; device-aware applications through ioctls and sysfs files.</p>
<p>External interfaces include: memory mapping, context management, DMA
operations, AGP management, vblank control, fence management, memory
management, and output management.</p>
<p>Cover generic ioctls and sysfs layout here. We only need high-level
info, since man pages should cover the rest.</p>
<div class="section" id="libdrm-device-lookup">
<h2>libdrm Device Lookup<a class="headerlink" href="#libdrm-device-lookup" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="primary-nodes-drm-master-and-authentication">
<span id="drm-primary-node"></span><h2>Primary Nodes, DRM Master and Authentication<a class="headerlink" href="#primary-nodes-drm-master-and-authentication" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<dl class="type">
<dt id="c.drm_master">
struct <code class="descname">drm_master</code><a class="headerlink" href="#c.drm_master" title="Permalink to this definition">¶</a></dt>
<dd><p>drm master structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_master {
  struct kref refcount;
  struct drm_device * dev;
  char * unique;
  int unique_len;
  struct idr magic_map;
  struct drm_lock_data lock;
  void * driver_priv;
  struct drm_master * lessor;
  int lessee_id;
  struct list_head lessee_list;
  struct list_head lessees;
  struct idr leases;
  struct idr lessee_idr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd>Refcount for this master object.</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>Link back to the DRM device</dd>
<dt><code class="docutils literal"><span class="pre">unique</span></code></dt>
<dd>Unique identifier: e.g. busid. Protected by
<code class="xref c c-type docutils literal"><span class="pre">drm_device.master_mutex</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">unique_len</span></code></dt>
<dd>Length of unique field. Protected by
<code class="xref c c-type docutils literal"><span class="pre">drm_device.master_mutex</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">magic_map</span></code></dt>
<dd>Map of used authentication tokens. Protected by
<code class="xref c c-type docutils literal"><span class="pre">drm_device.master_mutex</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>DRI1 lock information.</dd>
<dt><code class="docutils literal"><span class="pre">driver_priv</span></code></dt>
<dd>Pointer to driver-private information.</dd>
<dt><code class="docutils literal"><span class="pre">lessor</span></code></dt>
<dd>Lease holder</dd>
<dt><code class="docutils literal"><span class="pre">lessee_id</span></code></dt>
<dd>id for lessees. Owners always have id 0</dd>
<dt><code class="docutils literal"><span class="pre">lessee_list</span></code></dt>
<dd>other lessees of the same master</dd>
<dt><code class="docutils literal"><span class="pre">lessees</span></code></dt>
<dd>drm_masters leasing from this one</dd>
<dt><code class="docutils literal"><span class="pre">leases</span></code></dt>
<dd>Objects leased to this drm_master.</dd>
<dt><code class="docutils literal"><span class="pre">lessee_idr</span></code></dt>
<dd>All lessees under this owner (only used where lessor == NULL)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that master structures are only relevant for the legacy/primary device
nodes, hence there can only be one per device, not one per drm_minor.</p>
</div>
<div class="section" id="open-source-userspace-requirements">
<h2>Open-Source Userspace Requirements<a class="headerlink" href="#open-source-userspace-requirements" title="Permalink to this headline">¶</a></h2>
<p>The DRM subsystem has stricter requirements than most other kernel subsystems on
what the userspace side for new uAPI needs to look like. This section here
explains what exactly those requirements are, and why they exist.</p>
<p>The short summary is that any addition of DRM uAPI requires corresponding
open-sourced userspace patches, and those patches must be reviewed and ready for
merging into a suitable and canonical upstream project.</p>
<p>GFX devices (both display and render/GPU side) are really complex bits of
hardware, with userspace and kernel by necessity having to work together really
closely.  The interfaces, for rendering and modesetting, must be extremely wide
and flexible, and therefore it is almost always impossible to precisely define
them for every possible corner case. This in turn makes it really practically
infeasible to differentiate between behaviour that&#8217;s required by userspace, and
which must not be changed to avoid regressions, and behaviour which is only an
accidental artifact of the current implementation.</p>
<p>Without access to the full source code of all userspace users that means it
becomes impossible to change the implementation details, since userspace could
depend upon the accidental behaviour of the current implementation in minute
details. And debugging such regressions without access to source code is pretty
much impossible. As a consequence this means:</p>
<ul class="simple">
<li>The Linux kernel&#8217;s &#8220;no regression&#8221; policy holds in practice only for
open-source userspace of the DRM subsystem. DRM developers are perfectly fine
if closed-source blob drivers in userspace use the same uAPI as the open
drivers, but they must do so in the exact same way as the open drivers.
Creative (ab)use of the interfaces will, and in the past routinely has, lead
to breakage.</li>
<li>Any new userspace interface must have an open-source implementation as
demonstration vehicle.</li>
</ul>
<p>The other reason for requiring open-source userspace is uAPI review. Since the
kernel and userspace parts of a GFX stack must work together so closely, code
review can only assess whether a new interface achieves its goals by looking at
both sides. Making sure that the interface indeed covers the use-case fully
leads to a few additional requirements:</p>
<ul class="simple">
<li>The open-source userspace must not be a toy/test application, but the real
thing. Specifically it needs to handle all the usual error and corner cases.
These are often the places where new uAPI falls apart and hence essential to
assess the fitness of a proposed interface.</li>
<li>The userspace side must be fully reviewed and tested to the standards of that
userspace project. For e.g. mesa this means piglit testcases and review on the
mailing list. This is again to ensure that the new interface actually gets the
job done.</li>
<li>The userspace patches must be against the canonical upstream, not some vendor
fork. This is to make sure that no one cheats on the review and testing
requirements by doing a quick fork.</li>
<li>The kernel patch can only be merged after all the above requirements are met,
but it <strong>must</strong> be merged <strong>before</strong> the userspace patches land. uAPI always flows
from the kernel, doing things the other way round risks divergence of the uAPI
definitions and header files.</li>
</ul>
<p>These are fairly steep requirements, but have grown out from years of shared
pain and experience with uAPI added hastily, and almost always regretted about
just as fast. GFX devices change really fast, requiring a paradigm shift and
entire new set of uAPI interfaces every few years at least. Together with the
Linux kernel&#8217;s guarantee to keep existing userspace running for 10+ years this
is already rather painful for the DRM subsystem, with multiple different uAPIs
for the same thing co-existing. If we add a few more complete mistakes into the
mix every year it would be entirely unmanageable.</p>
</div>
<div class="section" id="render-nodes">
<span id="drm-render-node"></span><h2>Render nodes<a class="headerlink" href="#render-nodes" title="Permalink to this headline">¶</a></h2>
<p>DRM core provides multiple character-devices for user-space to use.
Depending on which device is opened, user-space can perform a different
set of operations (mainly ioctls). The primary node is always created
and called card&lt;num&gt;. Additionally, a currently unused control node,
called controlD&lt;num&gt; is also created. The primary node provides all
legacy operations and historically was the only interface used by
userspace. With KMS, the control node was introduced. However, the
planned KMS control interface has never been written and so the control
node stays unused to date.</p>
<p>With the increased use of offscreen renderers and GPGPU applications,
clients no longer require running compositors or graphics servers to
make use of a GPU. But the DRM API required unprivileged clients to
authenticate to a DRM-Master prior to getting GPU access. To avoid this
step and to grant clients GPU access without authenticating, render
nodes were introduced. Render nodes solely serve render clients, that
is, no modesetting or privileged ioctls can be issued on render nodes.
Only non-global rendering commands are allowed. If a driver supports
render nodes, it must advertise it via the DRIVER_RENDER DRM driver
capability. If not supported, the primary node must be used for render
clients together with the legacy drmAuth authentication procedure.</p>
<p>If a driver advertises render node support, DRM core will create a
separate render node called renderD&lt;num&gt;. There will be one render node
per device. No ioctls except PRIME-related ioctls will be allowed on
this node. Especially GEM_OPEN will be explicitly prohibited. Render
nodes are designed to avoid the buffer-leaks, which occur if clients
guess the flink names or mmap offsets on the legacy interface.
Additionally to this basic interface, drivers must mark their
driver-dependent render-only ioctls as DRM_RENDER_ALLOW so render
clients can use them. Driver authors must be careful not to allow any
privileged ioctls on render nodes.</p>
<p>With render nodes, user-space can now control access to the render node
via basic file-system access-modes. A running graphics server which
authenticates clients on the privileged primary/legacy node is no longer
required. Instead, a client can open the render node and is immediately
granted GPU access. Communication between clients (or servers) is done
via PRIME. FLINK from render node to legacy node is not supported. New
clients must not use the insecure FLINK interface.</p>
<p>Besides dropping all modeset/global ioctls, render nodes also drop the
DRM-Master concept. There is no reason to associate render clients with
a DRM-Master as they are independent of any graphics server. Besides,
they must work without any running master, anyway. Drivers must be able
to run without a master object if they support render nodes. If, on the
other hand, a driver requires shared state between clients which is
visible to user-space and accessible beyond open-file boundaries, they
cannot support render nodes.</p>
</div>
<div class="section" id="ioctl-support-on-device-nodes">
<span id="drm-driver-ioctl"></span><h2>IOCTL Support on Device Nodes<a class="headerlink" href="#ioctl-support-on-device-nodes" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="section" id="recommended-ioctl-return-values">
<h3>Recommended IOCTL Return Values<a class="headerlink" href="#recommended-ioctl-return-values" title="Permalink to this headline">¶</a></h3>
<p>In theory a driver&#8217;s IOCTL callback is only allowed to return very few error
codes. In practice it&#8217;s good to abuse a few more. This section documents common
practice within the DRM subsystem:</p>
<dl class="docutils">
<dt>ENOENT:</dt>
<dd>Strictly this should only be used when a file doesn&#8217;t exist e.g. when
calling the open() syscall. We reuse that to signal any kind of object
lookup failure, e.g. for unknown GEM buffer object handles, unknown KMS
object handles and similar cases.</dd>
<dt>ENOSPC:</dt>
<dd><p class="first">Some drivers use this to differentiate &#8220;out of kernel memory&#8221; from &#8220;out
of VRAM&#8221;. Sometimes also applies to other limited gpu resources used for
rendering (e.g. when you have a special limited compression buffer).
Sometimes resource allocation/reservation issues in command submission
IOCTLs are also signalled through EDEADLK.</p>
<p class="last">Simply running out of kernel/system memory is signalled through ENOMEM.</p>
</dd>
<dt>EPERM/EACCESS:</dt>
<dd>Returned for an operation that is valid, but needs more privileges.
E.g. root-only or much more common, DRM master-only operations return
this when when called by unpriviledged clients. There&#8217;s no clear
difference between EACCESS and EPERM.</dd>
<dt>ENODEV:</dt>
<dd>Feature (like PRIME, modesetting, GEM) is not supported by the driver.</dd>
<dt>ENXIO:</dt>
<dd>Remote failure, either a hardware transaction (like i2c), but also used
when the exporting driver of a shared dma-buf or fence doesn&#8217;t support a
feature needed.</dd>
<dt>EINTR:</dt>
<dd>DRM drivers assume that userspace restarts all IOCTLs. Any DRM IOCTL can
return EINTR and in such a case should be restarted with the IOCTL
parameters left unchanged.</dd>
<dt>EIO:</dt>
<dd>The GPU died and couldn&#8217;t be resurrected through a reset. Modesetting
hardware failures are signalled through the &#8220;link status&#8221; connector
property.</dd>
<dt>EINVAL:</dt>
<dd>Catch-all for anything that is an invalid argument combination which
cannot work.</dd>
</dl>
<p>IOCTL also use other error codes like ETIME, EFAULT, EBUSY, ENOTTY but their
usage is in line with the common meanings. The above list tries to just document
DRM specific patterns. Note that ENOTTY has the slightly unintuitive meaning of
&#8220;this IOCTL does not exist&#8221;, and is used exactly as such in DRM.</p>
<dl class="function">
<dt id="c.drm_ioctl_t">
typedef int <code class="descname">drm_ioctl_t</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, void *<em>&nbsp;data</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_ioctl_t" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM ioctl function type.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device inode</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>private pointer of the ioctl call</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>DRM file this ioctl was made on</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the DRM ioctl typedef. Note that <code class="xref c c-func docutils literal"><span class="pre">drm_ioctl()</span></code> has alrady copied <strong>data</strong>
into kernel-space, and will also copy it back, depending upon the read/write
settings in the ioctl command code.</p>
<dl class="function">
<dt id="c.drm_ioctl_compat_t">
typedef int <code class="descname">drm_ioctl_compat_t</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, unsigned int<em>&nbsp;cmd</em>, unsigned long<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_ioctl_compat_t" title="Permalink to this definition">¶</a></dt>
<dd><p>compatibility DRM ioctl function type.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>file pointer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd>ioctl command code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt>
<dd>DRM file this ioctl was made on</dd>
</dl>
<p><strong>Description</strong></p>
<p>Just a typedef to make declaring an array of compatibility handlers easier.
New drivers shouldn&#8217;t screw up the structure layout for their ioctl
structures and hence never need this.</p>
<dl class="type">
<dt id="c.drm_ioctl_flags">
enum <code class="descname">drm_ioctl_flags</code><a class="headerlink" href="#c.drm_ioctl_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM ioctl flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DRM_AUTH</span></code></dt>
<dd>This is for ioctl which are used for rendering, and require that the
file descriptor is either for a render node, or if it&#8217;s a
legacy/primary node, then it must be authenticated.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_MASTER</span></code></dt>
<dd><p class="first">This must be set for any ioctl which can change the modeset or
display state. Userspace must call the ioctl through a primary node,
while it is the active master.</p>
<p class="last">Note that read-only modeset ioctl can also be called by
unauthenticated clients, or when a master is not the currently active
one.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">DRM_ROOT_ONLY</span></code></dt>
<dd><p class="first">Anything that could potentially wreak a master file descriptor needs
to have this flag set. Current that&#8217;s only for the SETMASTER and
DROPMASTER ioctl, which e.g. logind can call to force a non-behaving
master (display compositor) into compliance.</p>
<p class="last">This is equivalent to callers with the SYSADMIN capability.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">DRM_CONTROL_ALLOW</span></code></dt>
<dd>Deprecated, do not use. Control nodes are in the process of getting
removed.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_UNLOCKED</span></code></dt>
<dd>Whether <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal"><span class="pre">drm_ioctl_desc.func</span></code></a> should be called with the DRM BKL held
or not. Enforced as the default for all modern drivers, hence there
should never be a need to set this flag.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_RENDER_ALLOW</span></code></dt>
<dd>This is used for all ioctl needed for rendering only, for drivers
which support render nodes. This should be all new render drivers,
and hence it should be always set for any ioctl with DRM_AUTH set.
Note though that read-only query ioctl might have this set, but have
not set DRM_AUTH because they do not require authentication.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Various flags that can be set in <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal"><span class="pre">drm_ioctl_desc.flags</span></code></a> to control how
userspace can use a given ioctl.</p>
<dl class="type">
<dt id="c.drm_ioctl_desc">
struct <code class="descname">drm_ioctl_desc</code><a class="headerlink" href="#c.drm_ioctl_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM driver ioctl entry</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_ioctl_desc {
  unsigned int cmd;
  enum drm_ioctl_flags flags;
  drm_ioctl_t * func;
  const char * name;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">cmd</span></code></dt>
<dd>ioctl command number, without flags</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>a bitmask of <a class="reference internal" href="#c.drm_ioctl_flags" title="drm_ioctl_flags"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">drm_ioctl_flags</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">func</span></code></dt>
<dd>handler for this ioctl</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>user-readable name for debug output</dd>
</dl>
<p><strong>Description</strong></p>
<p>For convenience it&#8217;s easier to create these using the <a class="reference internal" href="#c.DRM_IOCTL_DEF_DRV" title="DRM_IOCTL_DEF_DRV"><code class="xref c c-func docutils literal"><span class="pre">DRM_IOCTL_DEF_DRV()</span></code></a>
macro.</p>
<dl class="function">
<dt id="c.DRM_IOCTL_DEF_DRV">
<code class="descname">DRM_IOCTL_DEF_DRV</code><span class="sig-paren">(</span><em>ioctl</em>, <em>_func</em>, <em>_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_IOCTL_DEF_DRV" title="Permalink to this definition">¶</a></dt>
<dd><p>helper macro to fill out a <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_ioctl_desc</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ioctl</span></code></dt>
<dd>ioctl command suffix</dd>
<dt><code class="docutils literal"><span class="pre">_func</span></code></dt>
<dd>handler for the ioctl</dd>
<dt><code class="docutils literal"><span class="pre">_flags</span></code></dt>
<dd>a bitmask of <a class="reference internal" href="#c.drm_ioctl_flags" title="drm_ioctl_flags"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">drm_ioctl_flags</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>Small helper macro to create a <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_ioctl_desc</span></code></a> entry. The ioctl
command number is constructed by prepending <code class="docutils literal"><span class="pre">DRM_IOCTL\_</span></code> and passing that
to <code class="xref c c-func docutils literal"><span class="pre">DRM_IOCTL_NR()</span></code>.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
</div>
<div class="section" id="testing-and-validation">
<h2>Testing and validation<a class="headerlink" href="#testing-and-validation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="validating-changes-with-igt">
<h3>Validating changes with IGT<a class="headerlink" href="#validating-changes-with-igt" title="Permalink to this headline">¶</a></h3>
<p>There&#8217;s a collection of tests that aims to cover the whole functionality of
DRM drivers and that can be used to check that changes to DRM drivers or the
core don&#8217;t regress existing functionality. This test suite is called IGT and
its code can be found in <a class="reference external" href="https://cgit.freedesktop.org/drm/igt-gpu-tools/">https://cgit.freedesktop.org/drm/igt-gpu-tools/</a>.</p>
<p>To build IGT, start by installing its build dependencies. In Debian-based
systems:</p>
<div class="highlight-none"><div class="highlight"><pre># apt-get build-dep intel-gpu-tools
</pre></div>
</div>
<p>And in Fedora-based systems:</p>
<div class="highlight-none"><div class="highlight"><pre># dnf builddep intel-gpu-tools
</pre></div>
</div>
<p>Then clone the repository:</p>
<div class="highlight-none"><div class="highlight"><pre>$ git clone git://anongit.freedesktop.org/drm/igt-gpu-tools
</pre></div>
</div>
<p>Configure the build system and start the build:</p>
<div class="highlight-none"><div class="highlight"><pre>$ cd igt-gpu-tools &amp;&amp; ./autogen.sh &amp;&amp; make -j6
</pre></div>
</div>
<p>Download the piglit dependency:</p>
<div class="highlight-none"><div class="highlight"><pre>$ ./scripts/run-tests.sh -d
</pre></div>
</div>
<p>And run the tests:</p>
<div class="highlight-none"><div class="highlight"><pre>$ ./scripts/run-tests.sh -t kms -t core -s
</pre></div>
</div>
<p>run-tests.sh is a wrapper around piglit that will execute the tests matching
the -t options. A report in HTML format will be available in
./results/html/index.html. Results can be compared with piglit.</p>
</div>
<div class="section" id="display-crc-support">
<h3>Display CRC Support<a class="headerlink" href="#display-crc-support" title="Permalink to this headline">¶</a></h3>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="debugfs-support">
<h3>Debugfs Support<a class="headerlink" href="#debugfs-support" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_info_list">
struct <code class="descname">drm_info_list</code><a class="headerlink" href="#c.drm_info_list" title="Permalink to this definition">¶</a></dt>
<dd><p>debugfs info list entry</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_info_list {
  const char * name;
  int (* show) (struct seq_file*, void*);
  u32 driver_features;
  void * data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>file name</dd>
<dt><code class="docutils literal"><span class="pre">show</span></code></dt>
<dd>Show callback. <code class="xref c c-type docutils literal"><span class="pre">seq_file-&gt;private</span></code> will be set to the <a class="reference internal" href="#c.drm_info_node" title="drm_info_node"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_info_node</span></code></a> corresponding to the instance of this info on a given
<a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_minor</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">driver_features</span></code></dt>
<dd>Required driver features for this entry</dd>
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>Driver-private data, should not be device-specific.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents a debugfs file to be created by the drm
core.</p>
<dl class="type">
<dt id="c.drm_info_node">
struct <code class="descname">drm_info_node</code><a class="headerlink" href="#c.drm_info_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Per-minor debugfs node structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_info_node {
  struct drm_minor * minor;
  const struct drm_info_list * info_ent;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">minor</span></code></dt>
<dd><a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_minor</span></code></a> for this node.</dd>
<dt><code class="docutils literal"><span class="pre">info_ent</span></code></dt>
<dd>template for this node.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents a debugfs file, as an instantiation of a <a class="reference internal" href="#c.drm_info_list" title="drm_info_list"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_info_list</span></code></a> on a <a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_minor</span></code></a>.</p>
<p>FIXME:</p>
<p>No it doesn&#8217;t make a hole lot of sense that we duplicate debugfs entries for
both the render and the primary nodes, but that&#8217;s how this has organically
grown. It should probably be fixed, with a compatibility link, if needed.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
</div>
<div class="section" id="sysfs-support">
<h2>Sysfs Support<a class="headerlink" href="#sysfs-support" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="vblank-event-handling">
<h2>VBlank event handling<a class="headerlink" href="#vblank-event-handling" title="Permalink to this headline">¶</a></h2>
<p>The DRM core exposes two vertical blank related ioctls:</p>
<dl class="docutils">
<dt>DRM_IOCTL_WAIT_VBLANK</dt>
<dd>This takes a struct drm_wait_vblank structure as its argument, and
it is used to block or request a signal when a specified vblank
event occurs.</dd>
<dt>DRM_IOCTL_MODESET_CTL</dt>
<dd>This was only used for user-mode-settind drivers around modesetting
changes to allow the kernel to update the vblank interrupt after
mode setting, since on many devices the vertical blank counter is
reset to 0 at some point during modeset. Modern drivers should not
call this any more since with kernel mode setting it is a no-op.</dd>
</dl>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="i915.html" class="btn btn-neutral float-right" title="drm/i915 Intel GFX Driver" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drm-kms-helpers.html" class="btn btn-neutral" title="Mode Setting Helper Functions" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.15.0-rc7',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>