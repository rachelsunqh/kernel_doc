

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Kernel Mode Setting (KMS) &mdash; The Linux Kernel 4.15.0-rc7 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel 4.15.0-rc7 documentation" href="../index.html"/>
        <link rel="up" title="Linux GPU Driver Developer’s Guide" href="index.html"/>
        <link rel="next" title="Mode Setting Helper Functions" href="drm-kms-helpers.html"/>
        <link rel="prev" title="DRM Memory Management" href="drm-mm.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.15.0-rc9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer&#8217;s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Kernel Mode Setting (KMS)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kms-core-structures-and-functions">KMS Core Structures and Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modeset-base-object-abstraction">Modeset Base Object Abstraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#atomic-mode-setting">Atomic Mode Setting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#atomic-mode-setting-function-reference">Atomic Mode Setting Function Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#crtc-abstraction">CRTC Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#crtc-functions-reference">CRTC Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#frame-buffer-abstraction">Frame Buffer Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frame-buffer-functions-reference">Frame Buffer Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#drm-format-handling">DRM Format Handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dumb-buffer-objects">Dumb Buffer Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plane-abstraction">Plane Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#plane-functions-reference">Plane Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#display-modes-function-reference">Display Modes Function Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#connector-abstraction">Connector Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#connector-functions-reference">Connector Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#encoder-abstraction">Encoder Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#encoder-functions-reference">Encoder Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kms-initialization-and-cleanup">KMS Initialization and Cleanup</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#crtcs-struct-drm-crtc">CRTCs (<code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cleanup">Cleanup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#output-discovery-and-initialization-example">Output discovery and initialization example</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kms-locking">KMS Locking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kms-properties">KMS Properties</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#property-types-and-blob-property-support">Property Types and Blob Property Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#standard-connector-properties">Standard Connector Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#plane-composition-properties">Plane Composition Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#color-management-properties">Color Management Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tile-group-property">Tile Group Property</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-fencing-properties">Explicit Fencing Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#existing-kms-properties">Existing KMS Properties</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#vertical-blanking">Vertical Blanking</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#vertical-blanking-and-interrupt-handling-functions-reference">Vertical Blanking and Interrupt Handling Functions Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms-helpers.html">Mode Setting Helper Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-uapi.html">Userland interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="i915.html">drm/i915 Intel GFX Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="meson.html">drm/meson AmLogic Meson Video Processing Unit</a></li>
<li class="toctree-l2"><a class="reference internal" href="pl111.html">drm/pl111 ARM PrimeCell PL111 CLCD Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tegra.html">drm/tegra NVIDIA Tegra GPU and display driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tinydrm.html">drm/tinydrm Driver library</a></li>
<li class="toctree-l2"><a class="reference internal" href="tve200.html">drm/tve200 Faraday TV Encoder 200</a></li>
<li class="toctree-l2"><a class="reference internal" href="vc4.html">drm/vc4 Broadcom VC4 Graphics Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="bridge/dw-hdmi.html">drm/bridge/dw-hdmi Synopsys DesignWare HDMI Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="todo.html">TODO list</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Linux GPU Driver Developer&#8217;s Guide</a> &raquo;</li>
      
    <li>Kernel Mode Setting (KMS)</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/gpu/drm-kms.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="kernel-mode-setting-kms">
<h1>Kernel Mode Setting (KMS)<a class="headerlink" href="#kernel-mode-setting-kms" title="Permalink to this headline">¶</a></h1>
<p>Drivers must initialize the mode setting core by calling
<code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_init()</span></code> on the DRM device. The function
initializes the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span></code>
mode_config field and never fails. Once done, mode configuration must
be setup by initializing the following fields.</p>
<ul class="simple">
<li>int min_width, min_height; int max_width, max_height;
Minimum and maximum width and height of the frame buffers in pixel
units.</li>
<li>struct drm_mode_config_funcs *funcs;
Mode setting functions.</li>
</ul>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<div class="figure" id="id1">
<img alt="KMS Display Pipeline" src="../_images/DOT-dade12aa9127c64406e41cdf8d7f80694c134db2.svg" /><p class="caption"><span class="caption-text">KMS Display Pipeline Overview</span></p>
</div>
<p>The basic object structure KMS presents to userspace is fairly simple.
Framebuffers (represented by <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span></code></a>,
see <a class="reference internal" href="#frame-buffer-abstraction">Frame Buffer Abstraction</a>) feed into planes. One or more (or even no)
planes feed their pixel data into a CRTC (represented by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_crtc</span></code></a>, see <a class="reference internal" href="#crtc-abstraction">CRTC Abstraction</a>) for blending. The precise
blending step is explained in more detail in <a class="reference internal" href="#plane-composition-properties">Plane Composition Properties</a> and
related chapters.</p>
<p>For the output routing the first step is encoders (represented by
<a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span></code></a>, see <a class="reference internal" href="#encoder-abstraction">Encoder Abstraction</a>). Those
are really just internal artifacts of the helper libraries used to implement KMS
drivers. Besides that they make it unecessarily more complicated for userspace
to figure out which connections between a CRTC and a connector are possible, and
what kind of cloning is supported, they serve no purpose in the userspace API.
Unfortunately encoders have been exposed to userspace, hence can&#8217;t remove them
at this point.  Futhermore the exposed restrictions are often wrongly set by
drivers, and in many cases not powerful enough to express the real restrictions.
A CRTC can be connected to multiple encoders, and for an active CRTC there must
be at least one encoder.</p>
<p>The final, and real, endpoint in the display chain is the connector (represented
by <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>, see <a class="reference internal" href="#connector-abstraction">Connector
Abstraction</a>). Connectors can have different possible encoders, but the kernel
driver selects which encoder to use for each connector. The use case is DVI,
which could switch between an analog and a digital encoder. Encoders can also
drive multiple different connectors. There is exactly one active connector for
every active encoder.</p>
<p>Internally the output pipeline is a bit more complex and matches today&#8217;s
hardware more closely:</p>
<div class="figure" id="id2">
<img alt="KMS Output Pipeline" src="../_images/DOT-6445c75fc4859992454fd377127d4d309e82f09a.svg" /><p class="caption"><span class="caption-text">KMS Output Pipeline</span></p>
</div>
<p>Internally two additional helper objects come into play. First, to be able to
share code for encoders (sometimes on the same SoC, sometimes off-chip) one or
more <a class="reference internal" href="drm-kms-helpers.html#drm-bridges"><span>Bridges</span></a> (represented by <a class="reference internal" href="drm-kms-helpers.html#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_bridge</span></code></a>) can be linked to an encoder. This link is static and cannot be
changed, which means the cross-bar (if there is any) needs to be mapped between
the CRTC and any encoders. Often for drivers with bridges there&#8217;s no code left
at the encoder level. Atomic drivers can leave out all the encoder callbacks to
essentially only leave a dummy routing object behind, which is needed for
backwards compatibility since encoders are exposed to userspace.</p>
<p>The second object is for panels, represented by <a class="reference internal" href="drm-kms-helpers.html#c.drm_panel" title="drm_panel"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span></code></a>, see <a class="reference internal" href="drm-kms-helpers.html#drm-panel-helper"><span>Panel Helper Reference</span></a>. Panels do not have a fixed binding
point, but are generally linked to the driver private structure that embeds
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>.</p>
<p>Note that currently the bridge chaining and interactions with connectors and
panels are still in-flux and not really fully sorted out yet.</p>
</div>
<div class="section" id="kms-core-structures-and-functions">
<h2>KMS Core Structures and Functions<a class="headerlink" href="#kms-core-structures-and-functions" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.drm_mode_config_funcs">
struct <code class="descname">drm_mode_config_funcs</code><a class="headerlink" href="#c.drm_mode_config_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>basic driver provided mode setting functions</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_mode_config_funcs {
  struct drm_framebuffer *(* fb_create) (struct drm_device *dev,struct drm_file *file_priv, const struct drm_mode_fb_cmd2 *mode_cmd);
  const struct drm_format_info *(* get_format_info) (const struct drm_mode_fb_cmd2 *mode_cmd);
  void (* output_poll_changed) (struct drm_device *dev);
  int (* atomic_check) (struct drm_device *dev, struct drm_atomic_state *state);
  int (* atomic_commit) (struct drm_device *dev,struct drm_atomic_state *state, bool nonblock);
  struct drm_atomic_state *(* atomic_state_alloc) (struct drm_device *dev);
  void (* atomic_state_clear) (struct drm_atomic_state *state);
  void (* atomic_state_free) (struct drm_atomic_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fb_create</span></code></dt>
<dd><p class="first">Create a new framebuffer object. The core does basic checks on the
requested metadata, but most of that is left to the driver. See
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span></code> for details.</p>
<p>If the parameters are deemed valid and the backing storage objects in
the underlying memory manager all exist, then the driver allocates
a new <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a> structure, subclassed to contain
driver-specific information (like the internal native buffer object
references). It also needs to fill out all relevant metadata, which
should be done by calling <code class="xref c c-func docutils literal"><span class="pre">drm_helper_mode_fill_fb_struct()</span></code>.</p>
<p>The initialization is finalized by calling <code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_init()</span></code>,
which registers the framebuffer and makes it accessible to other
threads.</p>
<p>RETURNS:</p>
<p class="last">A new framebuffer with an initial reference count of 1 or a negative
error code encoded with <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">get_format_info</span></code></dt>
<dd><p class="first">Allows a driver to return custom format information for special
fb layouts (eg. ones with auxiliary compression control planes).</p>
<p>RETURNS:</p>
<p class="last">The format information specific to the given fb metadata, or
NULL if none is found.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">output_poll_changed</span></code></dt>
<dd><p class="first">Callback used by helpers to inform the driver of output configuration
changes.</p>
<p>Drivers implementing fbdev emulation with the helpers can call
drm_fb_helper_hotplug_changed from this hook to inform the fbdev
helper of output changes.</p>
<p>FIXME:</p>
<p class="last">Except that there&#8217;s no vtable for device-level helper callbacks
there&#8217;s no reason this is a core function.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_check</span></code></dt>
<dd><p class="first">This is the only hook to validate an atomic modeset update. This
function must reject any modeset and state changes which the hardware
or driver doesn&#8217;t support. This includes but is of course not limited
to:</p>
<blockquote>
<div><ul class="simple">
<li>Checking that the modes, framebuffers, scaling and placement
requirements and so on are within the limits of the hardware.</li>
<li>Checking that any hidden shared resources are not oversubscribed.
This can be shared PLLs, shared lanes, overall memory bandwidth,
display fifo space (where shared between planes or maybe even
CRTCs).</li>
<li>Checking that virtualized resources exported to userspace are not
oversubscribed. For various reasons it can make sense to expose
more planes, crtcs or encoders than which are physically there. One
example is dual-pipe operations (which generally should be hidden
from userspace if when lockstepped in hardware, exposed otherwise),
where a plane might need 1 hardware plane (if it&#8217;s just on one
pipe), 2 hardware planes (when it spans both pipes) or maybe even
shared a hardware plane with a 2nd plane (if there&#8217;s a compatible
plane requested on the area handled by the other pipe).</li>
<li>Check that any transitional state is possible and that if
requested, the update can indeed be done in the vblank period
without temporarily disabling some functions.</li>
<li>Check any other constraints the driver or hardware might have.</li>
<li>This callback also needs to correctly fill out the <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state</span></code></a>
in this update to make sure that <a class="reference internal" href="#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a>
reflects the nature of the possible update and returns true if and
only if the update cannot be applied without tearing within one
vblank on that CRTC. The core uses that information to reject
updates which require a full modeset (i.e. blanking the screen, or
at least pausing updates for a substantial amount of time) if
userspace has disallowed that in its request.</li>
<li>The driver also does not need to repeat basic input validation
like done for the corresponding legacy entry points. The core does
that before calling this hook.</li>
</ul>
</div></blockquote>
<p>See the documentation of <strong>atomic_commit</strong> for an exhaustive list of
error conditions which don&#8217;t have to be checked at the in this
callback.</p>
<p>See the documentation for <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> for how exactly
an atomic modeset update is described.</p>
<p>Drivers using the atomic helpers can implement this hook using
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check()</span></code>, or one of the exported sub-functions of
it.</p>
<p>RETURNS:</p>
<p>0 on success or one of the below negative error codes:</p>
<blockquote class="last">
<div><ul class="simple">
<li>-EINVAL, if any of the above constraints are violated.</li>
<li>-EDEADLK, when returned from an attempt to acquire an additional
<a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a> through <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock()</span></code></a>.</li>
<li>-ENOMEM, if allocating additional state sub-structures failed due
to lack of memory.</li>
<li>-EINTR, -EAGAIN or -ERESTARTSYS, if the IOCTL should be restarted.
This can either be due to a pending signal, or because the driver
needs to completely bail out to recover from an exceptional
situation like a GPU hang. From a userspace point all errors are
treated equally.</li>
</ul>
</div></blockquote>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_commit</span></code></dt>
<dd><p class="first">This is the only hook to commit an atomic modeset update. The core
guarantees that <strong>atomic_check</strong> has been called successfully before
calling this function, and that nothing has been changed in the
interim.</p>
<p>See the documentation for <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> for how exactly
an atomic modeset update is described.</p>
<p>Drivers using the atomic helpers can implement this hook using
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit()</span></code>, or one of the exported sub-functions of
it.</p>
<p>Nonblocking commits (as indicated with the nonblock parameter) must
do any preparatory work which might result in an unsuccessful commit
in the context of this callback. The only exceptions are hardware
errors resulting in -EIO. But even in that case the driver must
ensure that the display pipe is at least running, to avoid
compositors crashing when pageflips don&#8217;t work. Anything else,
specifically committing the update to the hardware, should be done
without blocking the caller. For updates which do not require a
modeset this must be guaranteed.</p>
<p>The driver must wait for any pending rendering to the new
framebuffers to complete before executing the flip. It should also
wait for any pending rendering from other drivers if the underlying
buffer is a shared dma-buf. Nonblocking commits must not wait for
rendering in the context of this callback.</p>
<p>An application can request to be notified when the atomic commit has
completed. These events are per-CRTC and can be distinguished by the
CRTC index supplied in <code class="xref c c-type docutils literal"><span class="pre">drm_event</span></code> to userspace.</p>
<p>The drm core will supply a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_event</span></code> in each CRTC&#8217;s
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.event</span></code></a>. See the documentation for
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.event</span></code></a> for more details about the precise semantics of
this event.</p>
<p>NOTE:</p>
<p>Drivers are not allowed to shut down any display pipe successfully
enabled through an atomic commit on their own. Doing so can result in
compositors crashing if a page flip is suddenly rejected because the
pipe is off.</p>
<p>RETURNS:</p>
<p>0 on success or one of the below negative error codes:</p>
<blockquote>
<div><ul class="simple">
<li>-EBUSY, if a nonblocking updated is requested and there is
an earlier updated pending. Drivers are allowed to support a queue
of outstanding updates, but currently no driver supports that.
Note that drivers must wait for preceding updates to complete if a
synchronous update is requested, they are not allowed to fail the
commit in that case.</li>
<li>-ENOMEM, if the driver failed to allocate memory. Specifically
this can happen when trying to pin framebuffers, which must only
be done when committing the state.</li>
<li>-ENOSPC, as a refinement of the more generic -ENOMEM to indicate
that the driver has run out of vram, iommu space or similar GPU
address space needed for framebuffer.</li>
<li>-EIO, if the hardware completely died.</li>
<li>-EINTR, -EAGAIN or -ERESTARTSYS, if the IOCTL should be restarted.
This can either be due to a pending signal, or because the driver
needs to completely bail out to recover from an exceptional
situation like a GPU hang. From a userspace point of view all errors are
treated equally.</li>
</ul>
</div></blockquote>
<p class="last">This list is exhaustive. Specifically this hook is not allowed to
return -EINVAL (any invalid requests should be caught in
<strong>atomic_check</strong>) or -EDEADLK (this function must not acquire
additional modeset locks).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_state_alloc</span></code></dt>
<dd><p class="first">This optional hook can be used by drivers that want to subclass struct
<a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a> to be able to track their own driver-private global
state easily. If this hook is implemented, drivers must also
implement <strong>atomic_state_clear</strong> and <strong>atomic_state_free</strong>.</p>
<p>RETURNS:</p>
<p class="last">A new <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a> on success or NULL on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_state_clear</span></code></dt>
<dd><p class="first">This hook must clear any driver private state duplicated into the
passed-in <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>. This hook is called when the caller
encountered a <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a> deadlock and needs to drop all
already acquired locks as part of the deadlock avoidance dance
implemented in <code class="xref c c-func docutils literal"><span class="pre">drm_modeset_backoff()</span></code>.</p>
<p>Any duplicated state must be invalidated since a concurrent atomic
update might change it, and the drm atomic interfaces always apply
updates as relative changes to the current state.</p>
<p class="last">Drivers that implement this must call <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_state_default_clear()</span></code>
to clear common state.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_state_free</span></code></dt>
<dd><p class="first">This hook needs driver private resources and the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>
itself. Note that the core first calls <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_state_clear()</span></code> to
avoid code duplicate between the clear and free hooks.</p>
<p class="last">Drivers that implement this must call
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_state_default_release()</span></code> to release common resources.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some global (i.e. not per-CRTC, connector, etc) mode setting functions that
involve drivers.</p>
<dl class="type">
<dt id="c.drm_mode_config">
struct <code class="descname">drm_mode_config</code><a class="headerlink" href="#c.drm_mode_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Mode configuration control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_mode_config {
  struct mutex mutex;
  struct drm_modeset_lock connection_mutex;
  struct drm_modeset_acquire_ctx * acquire_ctx;
  struct mutex idr_mutex;
  struct idr crtc_idr;
  struct idr tile_idr;
  struct mutex fb_lock;
  int num_fb;
  struct list_head fb_list;
  spinlock_t connector_list_lock;
  int num_connector;
  struct ida connector_ida;
  struct list_head connector_list;
  struct llist_head connector_free_list;
  struct work_struct connector_free_work;
  int num_encoder;
  struct list_head encoder_list;
  int num_total_plane;
  struct list_head plane_list;
  int num_crtc;
  struct list_head crtc_list;
  struct list_head property_list;
  int min_width;
  int min_height;
  int max_width;
  int max_height;
  const struct drm_mode_config_funcs * funcs;
  resource_size_t fb_base;
  bool poll_enabled;
  bool poll_running;
  bool delayed_event;
  struct delayed_work output_poll_work;
  struct mutex blob_lock;
  struct list_head property_blob_list;
  struct drm_property * edid_property;
  struct drm_property * dpms_property;
  struct drm_property * path_property;
  struct drm_property * tile_property;
  struct drm_property * link_status_property;
  struct drm_property * plane_type_property;
  struct drm_property * prop_src_x;
  struct drm_property * prop_src_y;
  struct drm_property * prop_src_w;
  struct drm_property * prop_src_h;
  struct drm_property * prop_crtc_x;
  struct drm_property * prop_crtc_y;
  struct drm_property * prop_crtc_w;
  struct drm_property * prop_crtc_h;
  struct drm_property * prop_fb_id;
  struct drm_property * prop_in_fence_fd;
  struct drm_property * prop_out_fence_ptr;
  struct drm_property * prop_crtc_id;
  struct drm_property * prop_active;
  struct drm_property * prop_mode_id;
  struct drm_property * dvi_i_subconnector_property;
  struct drm_property * dvi_i_select_subconnector_property;
  struct drm_property * tv_subconnector_property;
  struct drm_property * tv_select_subconnector_property;
  struct drm_property * tv_mode_property;
  struct drm_property * tv_left_margin_property;
  struct drm_property * tv_right_margin_property;
  struct drm_property * tv_top_margin_property;
  struct drm_property * tv_bottom_margin_property;
  struct drm_property * tv_brightness_property;
  struct drm_property * tv_contrast_property;
  struct drm_property * tv_flicker_reduction_property;
  struct drm_property * tv_overscan_property;
  struct drm_property * tv_saturation_property;
  struct drm_property * tv_hue_property;
  struct drm_property * scaling_mode_property;
  struct drm_property * aspect_ratio_property;
  struct drm_property * degamma_lut_property;
  struct drm_property * degamma_lut_size_property;
  struct drm_property * ctm_property;
  struct drm_property * gamma_lut_property;
  struct drm_property * gamma_lut_size_property;
  struct drm_property * suggested_x_property;
  struct drm_property * suggested_y_property;
  struct drm_property * non_desktop_property;
  uint32_t preferred_depth;
  uint32_t prefer_shadow;
  bool async_page_flip;
  bool allow_fb_modifiers;
  uint32_t cursor_width;
  uint32_t cursor_height;
  const struct drm_mode_config_helper_funcs * helper_private;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd><p class="first">This is the big scary modeset BKL which protects everything that
isn&#8217;t protect otherwise. Scope is unclear and fuzzy, try to remove
anything from under it&#8217;s protection and move it into more well-scoped
locks.</p>
<p class="last">The one important thing this protects is the use of <strong>acquire_ctx</strong>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">connection_mutex</span></code></dt>
<dd><p class="first">This protects connector state and the connector to encoder to CRTC
routing chain.</p>
<p class="last">For atomic drivers specifically this protects <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.state</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">acquire_ctx</span></code></dt>
<dd>Global implicit acquire context used by atomic drivers for legacy
IOCTLs. Deprecated, since implicit locking contexts make it
impossible to use driver-private <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span></code></a>. Users of
this must hold <strong>mutex</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">idr_mutex</span></code></dt>
<dd>Mutex for KMS ID allocation and management. Protects both <strong>crtc_idr</strong>
and <strong>tile_idr</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">crtc_idr</span></code></dt>
<dd>Main KMS ID tracking object. Use this idr for all IDs, fb, crtc,
connector, modes - just makes life easier to have only one.</dd>
<dt><code class="docutils literal"><span class="pre">tile_idr</span></code></dt>
<dd>Use this idr for allocating new IDs for tiled sinks like use in some
high-res DP MST screens.</dd>
<dt><code class="docutils literal"><span class="pre">fb_lock</span></code></dt>
<dd>Mutex to protect fb the global <strong>fb_list</strong> and <strong>num_fb</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">num_fb</span></code></dt>
<dd>Number of entries on <strong>fb_list</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">fb_list</span></code></dt>
<dd>List of all <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">connector_list_lock</span></code></dt>
<dd>Protects <strong>num_connector</strong> and
<strong>connector_list</strong> and <strong>connector_free_list</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">num_connector</span></code></dt>
<dd>Number of connectors on this device. Protected by
<strong>connector_list_lock</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">connector_ida</span></code></dt>
<dd>ID allocator for connector indices.</dd>
<dt><code class="docutils literal"><span class="pre">connector_list</span></code></dt>
<dd>List of connector objects linked with <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.head</span></code></a>. Protected
by <strong>connector_list_lock</strong>. Only use <a class="reference internal" href="#c.drm_for_each_connector_iter" title="drm_for_each_connector_iter"><code class="xref c c-func docutils literal"><span class="pre">drm_for_each_connector_iter()</span></code></a> and
<a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span></code></a> to walk this list.</dd>
<dt><code class="docutils literal"><span class="pre">connector_free_list</span></code></dt>
<dd>List of connector objects linked with <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.free_head</span></code></a>.
Protected by <strong>connector_list_lock</strong>. Used by
<a class="reference internal" href="#c.drm_for_each_connector_iter" title="drm_for_each_connector_iter"><code class="xref c c-func docutils literal"><span class="pre">drm_for_each_connector_iter()</span></code></a> and
<a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span></code></a> to savely free connectors using
<strong>connector_free_work</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">connector_free_work</span></code></dt>
<dd>Work to clean up <strong>connector_free_list</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">num_encoder</span></code></dt>
<dd>Number of encoders on this device. This is invariant over the
lifetime of a device and hence doesn&#8217;t need any locks.</dd>
<dt><code class="docutils literal"><span class="pre">encoder_list</span></code></dt>
<dd>List of encoder objects linked with <a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder.head</span></code></a>. This is
invariant over the lifetime of a device and hence doesn&#8217;t need any
locks.</dd>
<dt><code class="docutils literal"><span class="pre">num_total_plane</span></code></dt>
<dd>Number of universal (i.e. with primary/curso) planes on this device.
This is invariant over the lifetime of a device and hence doesn&#8217;t
need any locks.</dd>
<dt><code class="docutils literal"><span class="pre">plane_list</span></code></dt>
<dd>List of plane objects linked with <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane.head</span></code></a>. This is invariant
over the lifetime of a device and hence doesn&#8217;t need any locks.</dd>
<dt><code class="docutils literal"><span class="pre">num_crtc</span></code></dt>
<dd>Number of CRTCs on this device linked with <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.head</span></code></a>. This is invariant over the lifetime
of a device and hence doesn&#8217;t need any locks.</dd>
<dt><code class="docutils literal"><span class="pre">crtc_list</span></code></dt>
<dd>List of CRTC objects linked with <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.head</span></code></a>. This is invariant
over the lifetime of a device and hence doesn&#8217;t need any locks.</dd>
<dt><code class="docutils literal"><span class="pre">property_list</span></code></dt>
<dd>List of property type objects linked with <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property.head</span></code></a>. This is
invariant over the lifetime of a device and hence doesn&#8217;t need any
locks.</dd>
<dt><code class="docutils literal"><span class="pre">min_width</span></code></dt>
<dd>minimum pixel width on this device</dd>
<dt><code class="docutils literal"><span class="pre">min_height</span></code></dt>
<dd>minimum pixel height on this device</dd>
<dt><code class="docutils literal"><span class="pre">max_width</span></code></dt>
<dd>maximum pixel width on this device</dd>
<dt><code class="docutils literal"><span class="pre">max_height</span></code></dt>
<dd>maximum pixel height on this device</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>core driver provided mode setting functions</dd>
<dt><code class="docutils literal"><span class="pre">fb_base</span></code></dt>
<dd>base address of the framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">poll_enabled</span></code></dt>
<dd>track polling support for this device</dd>
<dt><code class="docutils literal"><span class="pre">poll_running</span></code></dt>
<dd>track polling status for this device</dd>
<dt><code class="docutils literal"><span class="pre">delayed_event</span></code></dt>
<dd>track delayed poll uevent deliver for this device</dd>
<dt><code class="docutils literal"><span class="pre">output_poll_work</span></code></dt>
<dd>delayed work for polling in process context</dd>
<dt><code class="docutils literal"><span class="pre">blob_lock</span></code></dt>
<dd>Mutex for blob property allocation and management, protects
<strong>property_blob_list</strong> and <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.blobs</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">property_blob_list</span></code></dt>
<dd>List of all the blob property objects linked with
<a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob"><code class="xref c c-type docutils literal"><span class="pre">drm_property_blob.head</span></code></a>. Protected by <strong>blob_lock</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">edid_property</span></code></dt>
<dd>Default connector property to hold the EDID of the
currently connected sink, if any.</dd>
<dt><code class="docutils literal"><span class="pre">dpms_property</span></code></dt>
<dd>Default connector property to control the
connector&#8217;s DPMS state.</dd>
<dt><code class="docutils literal"><span class="pre">path_property</span></code></dt>
<dd>Default connector property to hold the DP MST path
for the port.</dd>
<dt><code class="docutils literal"><span class="pre">tile_property</span></code></dt>
<dd>Default connector property to store the tile
position of a tiled screen, for sinks which need to be driven with
multiple CRTCs.</dd>
<dt><code class="docutils literal"><span class="pre">link_status_property</span></code></dt>
<dd>Default connector property for link status
of a connector</dd>
<dt><code class="docutils literal"><span class="pre">plane_type_property</span></code></dt>
<dd>Default plane property to differentiate
CURSOR, PRIMARY and OVERLAY legacy uses of planes.</dd>
<dt><code class="docutils literal"><span class="pre">prop_src_x</span></code></dt>
<dd>Default atomic plane property for the plane source
position in the connected <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_src_y</span></code></dt>
<dd>Default atomic plane property for the plane source
position in the connected <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_src_w</span></code></dt>
<dd>Default atomic plane property for the plane source
position in the connected <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_src_h</span></code></dt>
<dd>Default atomic plane property for the plane source
position in the connected <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_crtc_x</span></code></dt>
<dd>Default atomic plane property for the plane destination
position in the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> is is being shown on.</dd>
<dt><code class="docutils literal"><span class="pre">prop_crtc_y</span></code></dt>
<dd>Default atomic plane property for the plane destination
position in the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> is is being shown on.</dd>
<dt><code class="docutils literal"><span class="pre">prop_crtc_w</span></code></dt>
<dd>Default atomic plane property for the plane destination
position in the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> is is being shown on.</dd>
<dt><code class="docutils literal"><span class="pre">prop_crtc_h</span></code></dt>
<dd>Default atomic plane property for the plane destination
position in the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> is is being shown on.</dd>
<dt><code class="docutils literal"><span class="pre">prop_fb_id</span></code></dt>
<dd>Default atomic plane property to specify the
<a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_in_fence_fd</span></code></dt>
<dd>Sync File fd representing the incoming fences
for a Plane.</dd>
<dt><code class="docutils literal"><span class="pre">prop_out_fence_ptr</span></code></dt>
<dd>Sync File fd pointer representing the
outgoing fences for a CRTC. Userspace should provide a pointer to a
value of type s32, and then cast that pointer to u64.</dd>
<dt><code class="docutils literal"><span class="pre">prop_crtc_id</span></code></dt>
<dd>Default atomic plane property to specify the
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_active</span></code></dt>
<dd>Default atomic CRTC property to control the active
state, which is the simplified implementation for DPMS in atomic
drivers.</dd>
<dt><code class="docutils literal"><span class="pre">prop_mode_id</span></code></dt>
<dd>Default atomic CRTC property to set the mode for a
CRTC. A 0 mode implies that the CRTC is entirely disabled - all
connectors must be of and active must be set to disabled, too.</dd>
<dt><code class="docutils literal"><span class="pre">dvi_i_subconnector_property</span></code></dt>
<dd>Optional DVI-I property to
differentiate between analog or digital mode.</dd>
<dt><code class="docutils literal"><span class="pre">dvi_i_select_subconnector_property</span></code></dt>
<dd>Optional DVI-I property to
select between analog or digital mode.</dd>
<dt><code class="docutils literal"><span class="pre">tv_subconnector_property</span></code></dt>
<dd>Optional TV property to differentiate
between different TV connector types.</dd>
<dt><code class="docutils literal"><span class="pre">tv_select_subconnector_property</span></code></dt>
<dd>Optional TV property to select
between different TV connector types.</dd>
<dt><code class="docutils literal"><span class="pre">tv_mode_property</span></code></dt>
<dd>Optional TV property to select
the output TV mode.</dd>
<dt><code class="docutils literal"><span class="pre">tv_left_margin_property</span></code></dt>
<dd>Optional TV property to set the left
margin.</dd>
<dt><code class="docutils literal"><span class="pre">tv_right_margin_property</span></code></dt>
<dd>Optional TV property to set the right
margin.</dd>
<dt><code class="docutils literal"><span class="pre">tv_top_margin_property</span></code></dt>
<dd>Optional TV property to set the right
margin.</dd>
<dt><code class="docutils literal"><span class="pre">tv_bottom_margin_property</span></code></dt>
<dd>Optional TV property to set the right
margin.</dd>
<dt><code class="docutils literal"><span class="pre">tv_brightness_property</span></code></dt>
<dd>Optional TV property to set the
brightness.</dd>
<dt><code class="docutils literal"><span class="pre">tv_contrast_property</span></code></dt>
<dd>Optional TV property to set the
contrast.</dd>
<dt><code class="docutils literal"><span class="pre">tv_flicker_reduction_property</span></code></dt>
<dd>Optional TV property to control the
flicker reduction mode.</dd>
<dt><code class="docutils literal"><span class="pre">tv_overscan_property</span></code></dt>
<dd>Optional TV property to control the overscan
setting.</dd>
<dt><code class="docutils literal"><span class="pre">tv_saturation_property</span></code></dt>
<dd>Optional TV property to set the
saturation.</dd>
<dt><code class="docutils literal"><span class="pre">tv_hue_property</span></code></dt>
<dd>Optional TV property to set the hue.</dd>
<dt><code class="docutils literal"><span class="pre">scaling_mode_property</span></code></dt>
<dd>Optional connector property to control the
upscaling, mostly used for built-in panels.</dd>
<dt><code class="docutils literal"><span class="pre">aspect_ratio_property</span></code></dt>
<dd>Optional connector property to control the
HDMI infoframe aspect ratio setting.</dd>
<dt><code class="docutils literal"><span class="pre">degamma_lut_property</span></code></dt>
<dd>Optional CRTC property to set the LUT used to
convert the framebuffer&#8217;s colors to linear gamma.</dd>
<dt><code class="docutils literal"><span class="pre">degamma_lut_size_property</span></code></dt>
<dd>Optional CRTC property for the size of
the degamma LUT as supported by the driver (read-only).</dd>
<dt><code class="docutils literal"><span class="pre">ctm_property</span></code></dt>
<dd>Optional CRTC property to set the
matrix used to convert colors after the lookup in the
degamma LUT.</dd>
<dt><code class="docutils literal"><span class="pre">gamma_lut_property</span></code></dt>
<dd>Optional CRTC property to set the LUT used to
convert the colors, after the CTM matrix, to the gamma space of the
connected screen.</dd>
<dt><code class="docutils literal"><span class="pre">gamma_lut_size_property</span></code></dt>
<dd>Optional CRTC property for the size of the
gamma LUT as supported by the driver (read-only).</dd>
<dt><code class="docutils literal"><span class="pre">suggested_x_property</span></code></dt>
<dd>Optional connector property with a hint for
the position of the output on the host&#8217;s screen.</dd>
<dt><code class="docutils literal"><span class="pre">suggested_y_property</span></code></dt>
<dd>Optional connector property with a hint for
the position of the output on the host&#8217;s screen.</dd>
<dt><code class="docutils literal"><span class="pre">non_desktop_property</span></code></dt>
<dd>Optional connector property with a hint
that device isn&#8217;t a standard display, and the console/desktop,
should not be displayed on it.</dd>
<dt><code class="docutils literal"><span class="pre">preferred_depth</span></code></dt>
<dd>preferred RBG pixel depth, used by fb helpers</dd>
<dt><code class="docutils literal"><span class="pre">prefer_shadow</span></code></dt>
<dd>hint to userspace to prefer shadow-fb rendering</dd>
<dt><code class="docutils literal"><span class="pre">async_page_flip</span></code></dt>
<dd>Does this device support async flips on the primary
plane?</dd>
<dt><code class="docutils literal"><span class="pre">allow_fb_modifiers</span></code></dt>
<dd>Whether the driver supports fb modifiers in the ADDFB2.1 ioctl call.</dd>
<dt><code class="docutils literal"><span class="pre">cursor_width</span></code></dt>
<dd>hint to userspace for max cursor width</dd>
<dt><code class="docutils literal"><span class="pre">cursor_height</span></code></dt>
<dd>hint to userspace for max cursor height</dd>
<dt><code class="docutils literal"><span class="pre">helper_private</span></code></dt>
<dd>mid-layer private data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Core mode resource tracking structure.  All CRTC, encoders, and connectors
enumerated by the driver are added here, as are global properties.  Some
global restrictions are also here, e.g. dimension restrictions.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="modeset-base-object-abstraction">
<h2>Modeset Base Object Abstraction<a class="headerlink" href="#modeset-base-object-abstraction" title="Permalink to this headline">¶</a></h2>
<div class="figure" id="id3">
<img alt="Mode Objects and Properties" src="../_images/DOT-1eee3f74bb2de20b2b68c4aa6c9c1cabe5078857.svg" /><p class="caption"><span class="caption-text">Mode Objects and Properties</span></p>
</div>
<p>The base structure for all KMS objects is <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span></code></a>. One of the base services it provides is tracking properties,
which are especially important for the atomic IOCTL (see <a class="reference internal" href="#atomic-mode-setting">Atomic Mode
Setting</a>). The somewhat surprising part here is that properties are not
directly instantiated on each object, but free-standing mode objects themselves,
represented by <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span></code></a>, which only specify
the type and value range of a property. Any given property can be attached
multiple times to different objects using <code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code>.</p>
<dl class="type">
<dt id="c.drm_mode_object">
struct <code class="descname">drm_mode_object</code><a class="headerlink" href="#c.drm_mode_object" title="Permalink to this definition">¶</a></dt>
<dd><p>base structure for modeset objects</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_mode_object {
  uint32_t id;
  uint32_t type;
  struct drm_object_properties * properties;
  struct kref refcount;
  void (* free_cb) (struct kref *kref);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>userspace visible identifier</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of the object, one of DRM_MODE_OBJECT_*</dd>
<dt><code class="docutils literal"><span class="pre">properties</span></code></dt>
<dd>properties attached to this object, including values</dd>
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd>reference count for objects which with dynamic lifetime</dd>
<dt><code class="docutils literal"><span class="pre">free_cb</span></code></dt>
<dd>free function callback, only set for objects with dynamic lifetime</dd>
</dl>
<p><strong>Description</strong></p>
<p>Base structure for modeset objects visible to userspace. Objects can be
looked up using <code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_find()</span></code>. Besides basic uapi interface
properties like <strong>id</strong> and <strong>type</strong> it provides two services:</p>
<ul class="simple">
<li>It tracks attached properties and their values. This is used by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>,
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a> and <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a>. Properties are attached by calling
<code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code> before the object is visible to userspace.</li>
<li>For objects with dynamic lifetimes (as indicated by a non-NULL <strong>free_cb</strong>) it
provides reference counting through <code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_get()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_put()</span></code>. This is used by <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>, <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a>
and <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob"><code class="xref c c-type docutils literal"><span class="pre">drm_property_blob</span></code></a>. These objects provide specialized reference
counting wrappers.</li>
</ul>
<dl class="type">
<dt id="c.drm_object_properties">
struct <code class="descname">drm_object_properties</code><a class="headerlink" href="#c.drm_object_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>property tracking for <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_object</span></code></a></p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_object_properties {
  int count;
  struct drm_property * properties;
  uint64_t values;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">count</span></code></dt>
<dd>number of valid properties, must be less than or equal to
DRM_OBJECT_MAX_PROPERTY.</dd>
<dt><code class="docutils literal"><span class="pre">properties</span></code></dt>
<dd><p class="first">Array of pointers to <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property</span></code></a>.</p>
<p class="last">NOTE: if we ever start dynamically destroying properties (ie.
not at <code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code> time), then we&#8217;d have to do
a better job of detaching property from mode objects to avoid
dangling property pointers:</p>
</dd>
<dt><code class="docutils literal"><span class="pre">values</span></code></dt>
<dd><p class="first">Array to store the property values, matching <strong>properties</strong>. Do
not read/write values directly, but use
<code class="xref c c-func docutils literal"><span class="pre">drm_object_property_get_value()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">drm_object_property_set_value()</span></code>.</p>
<p>Note that atomic drivers do not store mutable properties in this
array, but only the decoded values in the corresponding state
structure. The decoding is done using the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.atomic_get_property</span></code></a> and
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.atomic_set_property</span></code></a> hooks for <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>. For
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> the hooks are <a class="reference internal" href="#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_funcs.atomic_get_property</span></code></a> and
<a class="reference internal" href="#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_funcs.atomic_set_property</span></code></a>. And for <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>
the hooks are <a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.atomic_get_property</span></code></a> and
<a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.atomic_set_property</span></code></a> .</p>
<p class="last">Hence atomic drivers should not use <code class="xref c c-func docutils literal"><span class="pre">drm_object_property_set_value()</span></code>
and <code class="xref c c-func docutils literal"><span class="pre">drm_object_property_get_value()</span></code> on mutable objects, i.e. those
without the DRM_MODE_PROP_IMMUTABLE flag set.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_mode_object_reference">
void <code class="descname">drm_mode_object_reference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_object_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a mode object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>DRM mode object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_get()</span></code> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_mode_object_unreference">
void <code class="descname">drm_mode_object_unreference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_object_unreference" title="Permalink to this definition">¶</a></dt>
<dd><p>release a mode object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>DRM mode object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_put()</span></code> and should not be
used by new code.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="atomic-mode-setting">
<h2>Atomic Mode Setting<a class="headerlink" href="#atomic-mode-setting" title="Permalink to this headline">¶</a></h2>
<div class="figure" id="id4">
<img alt="Mode Objects and Properties" src="../_images/DOT-69c6997054dbfdfb0892fa0cab076cfd8074c7ed.svg" /><p class="caption"><span class="caption-text">Mode Objects and Properties</span></p>
</div>
<p>Atomic provides transactional modeset (including planes) updates, but a
bit differently from the usual transactional approach of try-commit and
rollback:</p>
<ul class="simple">
<li>Firstly, no hardware changes are allowed when the commit would fail. This
allows us to implement the DRM_MODE_ATOMIC_TEST_ONLY mode, which allows
userspace to explore whether certain configurations would work or not.</li>
<li>This would still allow setting and rollback of just the software state,
simplifying conversion of existing drivers. But auditing drivers for
correctness of the atomic_check code becomes really hard with that: Rolling
back changes in data structures all over the place is hard to get right.</li>
<li>Lastly, for backwards compatibility and to support all use-cases, atomic
updates need to be incremental and be able to execute in parallel. Hardware
doesn&#8217;t always allow it, but where possible plane updates on different CRTCs
should not interfere, and not get stalled due to output routing changing on
different CRTCs.</li>
</ul>
<p>Taken all together there&#8217;s two consequences for the atomic design:</p>
<ul class="simple">
<li>The overall state is split up into per-object state structures:
<a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> for planes, <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_crtc_state</span></code></a> for CRTCs and <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_connector_state</span></code></a> for connectors. These are the only
objects with userspace-visible and settable state. For internal state drivers
can subclass these structures through embeddeding, or add entirely new state
structures for their globally shared hardware functions.</li>
<li>An atomic update is assembled and validated as an entirely free-standing pile
of structures within the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>
container. Again drivers can subclass that container for their own state
structure tracking needs. Only when a state is committed is it applied to the
driver and modeset objects. This way rolling back an update boils down to
releasing memory and unreferencing objects like framebuffers.</li>
</ul>
<p>Read on in this chapter, and also in <a class="reference internal" href="drm-kms-helpers.html#drm-atomic-helper"><span>Atomic Modeset Helper Functions Reference</span></a> for more detailed
coverage of specific topics.</p>
<div class="section" id="atomic-mode-setting-function-reference">
<h3>Atomic Mode Setting Function Reference<a class="headerlink" href="#atomic-mode-setting-function-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_crtc_commit">
struct <code class="descname">drm_crtc_commit</code><a class="headerlink" href="#c.drm_crtc_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>track modeset commits on a CRTC</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_crtc_commit {
  struct drm_crtc * crtc;
  struct kref ref;
  struct completion flip_done;
  struct completion hw_done;
  struct completion cleanup_done;
  struct list_head commit_entry;
  struct drm_pending_vblank_event * event;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>DRM CRTC for this commit.</dd>
<dt><code class="docutils literal"><span class="pre">ref</span></code></dt>
<dd>Reference count for this structure. Needed to allow blocking on
completions without the risk of the completion disappearing
meanwhile.</dd>
<dt><code class="docutils literal"><span class="pre">flip_done</span></code></dt>
<dd>Will be signaled when the hardware has flipped to the new set of
buffers. Signals at the same time as when the drm event for this
commit is sent to userspace, or when an out-fence is singalled. Note
that for most hardware, in most cases this happens after <strong>hw_done</strong> is
signalled.</dd>
<dt><code class="docutils literal"><span class="pre">hw_done</span></code></dt>
<dd><p class="first">Will be signalled when all hw register changes for this commit have
been written out. Especially when disabling a pipe this can be much
later than than <strong>flip_done</strong>, since that can signal already when the
screen goes black, whereas to fully shut down a pipe more register
I/O is required.</p>
<p class="last">Note that this does not need to include separately reference-counted
resources like backing storage buffer pinning, or runtime pm
management.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cleanup_done</span></code></dt>
<dd>Will be signalled after old buffers have been cleaned up by calling
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code>. Since this can only happen after
a vblank wait completed it might be a bit later. This completion is
useful to throttle updates and avoid hardware updates getting ahead
of the buffer cleanup too much.</dd>
<dt><code class="docutils literal"><span class="pre">commit_entry</span></code></dt>
<dd>Entry on the per-CRTC <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.commit_list</span></code></a>. Protected by
$drm_crtc.commit_lock.</dd>
<dt><code class="docutils literal"><span class="pre">event</span></code></dt>
<dd><a class="reference internal" href="#c.drm_pending_vblank_event" title="drm_pending_vblank_event"><code class="xref c c-type docutils literal"><span class="pre">drm_pending_vblank_event</span></code></a> pointer to clean up private events.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure is used to track pending modeset changes and atomic commit on
a per-CRTC basis. Since updating the list should never block this structure
is reference counted to allow waiters to safely wait on an event to complete,
without holding any locks.</p>
<p>It has 3 different events in total to allow a fine-grained synchronization
between outstanding updates:</p>
<div class="highlight-none"><div class="highlight"><pre>atomic commit thread                    hardware

write new state into hardware   ----&gt;   ...
signal hw_done
                                        switch to new state on next
...                                     v/hblank

wait for buffers to show up             ...

...                                     send completion irq
                                        irq handler signals flip_done
cleanup old buffers

signal cleanup_done

wait for flip_done              &lt;----
clean up atomic state
</pre></div>
</div>
<p>The important bit to know is that cleanup_done is the terminal event, but the
ordering between flip_done and hw_done is entirely up to the specific driver
and modeset state change.</p>
<p>For an implementation of how to use this look at
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_setup_commit()</span></code> from the atomic helper library.</p>
<dl class="type">
<dt id="c.drm_private_state_funcs">
struct <code class="descname">drm_private_state_funcs</code><a class="headerlink" href="#c.drm_private_state_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>atomic state functions for private objects</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_private_state_funcs {
  struct drm_private_state *(* atomic_duplicate_state) (struct drm_private_obj *obj);
  void (* atomic_destroy_state) (struct drm_private_obj *obj, struct drm_private_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">atomic_duplicate_state</span></code></dt>
<dd><p class="first">Duplicate the current state of the private object and return it. It
is an error to call this before obj-&gt;state has been initialized.</p>
<p>RETURNS:</p>
<p class="last">Duplicated atomic state or NULL when obj-&gt;state is not
initialized or allocation failed.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_destroy_state</span></code></dt>
<dd>Frees the private object state created with <strong>atomic_duplicate_state</strong>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>These hooks are used by atomic helpers to create, swap and destroy states of
private objects. The structure itself is used as a vtable to identify the
associated private object type. Each private object type that needs to be
added to the atomic states is expected to have an implementation of these
hooks and pass a pointer to it&#8217;s drm_private_state_funcs struct to
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_get_private_obj_state()</span></code>.</p>
<dl class="type">
<dt id="c.drm_atomic_state">
struct <code class="descname">drm_atomic_state</code><a class="headerlink" href="#c.drm_atomic_state" title="Permalink to this definition">¶</a></dt>
<dd><p>the global state object for atomic updates</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_atomic_state {
  struct kref ref;
  struct drm_device * dev;
  bool allow_modeset:1;
  bool legacy_cursor_update:1;
  bool async_update:1;
  struct __drm_planes_state * planes;
  struct __drm_crtcs_state * crtcs;
  int num_connector;
  struct __drm_connnectors_state * connectors;
  int num_private_objs;
  struct __drm_private_objs_state * private_objs;
  struct drm_modeset_acquire_ctx * acquire_ctx;
  struct drm_crtc_commit * fake_commit;
  struct work_struct commit_work;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ref</span></code></dt>
<dd>count of all references to this state (will not be freed until zero)</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>parent DRM device</dd>
<dt><code class="docutils literal"><span class="pre">allow_modeset</span></code></dt>
<dd>allow full modeset</dd>
<dt><code class="docutils literal"><span class="pre">legacy_cursor_update</span></code></dt>
<dd>hint to enforce legacy cursor IOCTL semantics</dd>
<dt><code class="docutils literal"><span class="pre">async_update</span></code></dt>
<dd>hint for asynchronous plane update</dd>
<dt><code class="docutils literal"><span class="pre">planes</span></code></dt>
<dd>pointer to array of structures with per-plane data</dd>
<dt><code class="docutils literal"><span class="pre">crtcs</span></code></dt>
<dd>pointer to array of CRTC pointers</dd>
<dt><code class="docutils literal"><span class="pre">num_connector</span></code></dt>
<dd>size of the <strong>connectors</strong> and <strong>connector_states</strong> arrays</dd>
<dt><code class="docutils literal"><span class="pre">connectors</span></code></dt>
<dd>pointer to array of structures with per-connector data</dd>
<dt><code class="docutils literal"><span class="pre">num_private_objs</span></code></dt>
<dd>size of the <strong>private_objs</strong> array</dd>
<dt><code class="docutils literal"><span class="pre">private_objs</span></code></dt>
<dd>pointer to array of private object pointers</dd>
<dt><code class="docutils literal"><span class="pre">acquire_ctx</span></code></dt>
<dd>acquire context for this atomic modeset state update</dd>
<dt><code class="docutils literal"><span class="pre">fake_commit</span></code></dt>
<dd><p class="first">Used for signaling unbound planes/connectors.
When a connector or plane is not bound to any CRTC, it&#8217;s still important
to preserve linearity to prevent the atomic states from being freed to early.</p>
<p class="last">This commit (if set) is not bound to any crtc, but will be completed when
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_hw_done()</span></code> is called.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">commit_work</span></code></dt>
<dd>Work item which can be used by the driver or helpers to execute the
commit without blocking.</dd>
</dl>
<dl class="function">
<dt id="c.drm_crtc_commit_get">
struct <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit">drm_crtc_commit</a> * <code class="descname">drm_crtc_commit_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit">drm_crtc_commit</a> *<em>&nbsp;commit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_commit_get" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a reference to the CRTC commit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span> <span class="pre">*</span> <span class="pre">commit</span></code></dt>
<dd>CRTC commit</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increases the reference of <strong>commit</strong>.</p>
<p><strong>Return</strong></p>
<p>The pointer to <strong>commit</strong>, with reference increased.</p>
<dl class="function">
<dt id="c.drm_crtc_commit_put">
void <code class="descname">drm_crtc_commit_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit">drm_crtc_commit</a> *<em>&nbsp;commit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_commit_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference to the CRTC commmit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span> <span class="pre">*</span> <span class="pre">commit</span></code></dt>
<dd>CRTC commit</dd>
</dl>
<p><strong>Description</strong></p>
<p>This releases a reference to <strong>commit</strong> which is freed after removing the
final reference. No locking required and callable from any context.</p>
<dl class="function">
<dt id="c.drm_atomic_state_get">
struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> * <code class="descname">drm_atomic_state_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_get" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a reference to the atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>The atomic state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a new reference to the <strong>state</strong></p>
<dl class="function">
<dt id="c.drm_atomic_state_put">
void <code class="descname">drm_atomic_state_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference to the atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>The atomic state</dd>
</dl>
<p><strong>Description</strong></p>
<p>This releases a reference to <strong>state</strong> which is freed after removing the
final reference. No locking required and callable from any context.</p>
<dl class="function">
<dt id="c.drm_atomic_get_existing_crtc_state">
struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> * <code class="descname">drm_atomic_get_existing_crtc_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_existing_crtc_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get crtc state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the crtc state for the given crtc, or NULL
if the crtc is not part of the global atomic state.</p>
<p>This function is deprecated, <strong>drm_atomic_get_old_crtc_state</strong> or
<strong>drm_atomic_get_new_crtc_state</strong> should be used instead.</p>
<dl class="function">
<dt id="c.drm_atomic_get_old_crtc_state">
struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> * <code class="descname">drm_atomic_get_old_crtc_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_old_crtc_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get old crtc state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the old crtc state for the given crtc, or
NULL if the crtc is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_get_new_crtc_state">
struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> * <code class="descname">drm_atomic_get_new_crtc_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_new_crtc_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get new crtc state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the new crtc state for the given crtc, or
NULL if the crtc is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_get_existing_plane_state">
struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="descname">drm_atomic_get_existing_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_existing_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get plane state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the plane state for the given plane, or NULL
if the plane is not part of the global atomic state.</p>
<p>This function is deprecated, <strong>drm_atomic_get_old_plane_state</strong> or
<strong>drm_atomic_get_new_plane_state</strong> should be used instead.</p>
<dl class="function">
<dt id="c.drm_atomic_get_old_plane_state">
struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="descname">drm_atomic_get_old_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_old_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get plane state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the old plane state for the given plane, or
NULL if the plane is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_get_new_plane_state">
struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="descname">drm_atomic_get_new_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_new_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get plane state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the new plane state for the given plane, or
NULL if the plane is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_get_existing_connector_state">
struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> * <code class="descname">drm_atomic_get_existing_connector_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_existing_connector_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get connector state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the connector state for the given connector,
or NULL if the connector is not part of the global atomic state.</p>
<p>This function is deprecated, <strong>drm_atomic_get_old_connector_state</strong> or
<strong>drm_atomic_get_new_connector_state</strong> should be used instead.</p>
<dl class="function">
<dt id="c.drm_atomic_get_old_connector_state">
struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> * <code class="descname">drm_atomic_get_old_connector_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_old_connector_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get connector state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the old connector state for the given connector,
or NULL if the connector is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_get_new_connector_state">
struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> * <code class="descname">drm_atomic_get_new_connector_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_new_connector_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get connector state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the new connector state for the given connector,
or NULL if the connector is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.__drm_atomic_get_current_plane_state">
const struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="descname">__drm_atomic_get_current_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_get_current_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get current plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the plane state for the given plane, either from
<strong>state</strong>, or if the plane isn&#8217;t part of the atomic state update, from <strong>plane</strong>.
This is useful in atomic check callbacks, when drivers need to peek at, but
not change, state of other planes, since it avoids threading an error code
back up the call chain.</p>
<p>WARNING:</p>
<p>Note that this function is in general unsafe since it doesn&#8217;t check for the
required locking for access state structures. Drivers must ensure that it is
safe to access the returned state structure through other means. One common
example is when planes are fixed to a single CRTC, and the driver knows that
the CRTC lock is held already. In that case holding the CRTC lock gives a
read-lock on all planes connected to that CRTC. But if planes can be
reassigned things get more tricky. In that case it&#8217;s better to use
drm_atomic_get_plane_state and wire up full error handling.</p>
<p><strong>Return</strong></p>
<p>Read-only pointer to the current plane state.</p>
<dl class="function">
<dt id="c.for_each_oldnew_connector_in_state">
<code class="descname">for_each_oldnew_connector_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>connector</em>, <em>old_connector_state</em>, <em>new_connector_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_oldnew_connector_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all connectors in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_connector_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> iteration cursor for the
old state</dd>
<dt><code class="docutils literal"><span class="pre">new_connector_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> iteration cursor for the
new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all connectors in an atomic update, tracking both old and
new state. This is useful in places where the state delta needs to be
considered, for example in atomic check functions.</p>
<dl class="function">
<dt id="c.for_each_old_connector_in_state">
<code class="descname">for_each_old_connector_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>connector</em>, <em>old_connector_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_old_connector_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all connectors in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_connector_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> iteration cursor for the
old state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all connectors in an atomic update, tracking only the old
state. This is useful in disable functions, where we need the old state the
hardware is still in.</p>
<dl class="function">
<dt id="c.for_each_new_connector_in_state">
<code class="descname">for_each_new_connector_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>connector</em>, <em>new_connector_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_new_connector_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all connectors in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">new_connector_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> iteration cursor for the
new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all connectors in an atomic update, tracking only the new
state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.</p>
<dl class="function">
<dt id="c.for_each_oldnew_crtc_in_state">
<code class="descname">for_each_oldnew_crtc_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>crtc</em>, <em>old_crtc_state</em>, <em>new_crtc_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_oldnew_crtc_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all CRTCs in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_crtc_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> iteration cursor for the old state</dd>
<dt><code class="docutils literal"><span class="pre">new_crtc_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> iteration cursor for the new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all CRTCs in an atomic update, tracking both old and
new state. This is useful in places where the state delta needs to be
considered, for example in atomic check functions.</p>
<dl class="function">
<dt id="c.for_each_old_crtc_in_state">
<code class="descname">for_each_old_crtc_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>crtc</em>, <em>old_crtc_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_old_crtc_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all CRTCs in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_crtc_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> iteration cursor for the old state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all CRTCs in an atomic update, tracking only the old
state. This is useful in disable functions, where we need the old state the
hardware is still in.</p>
<dl class="function">
<dt id="c.for_each_new_crtc_in_state">
<code class="descname">for_each_new_crtc_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>crtc</em>, <em>new_crtc_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_new_crtc_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all CRTCs in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">new_crtc_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> iteration cursor for the new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all CRTCs in an atomic update, tracking only the new
state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.</p>
<dl class="function">
<dt id="c.for_each_oldnew_plane_in_state">
<code class="descname">for_each_oldnew_plane_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>plane</em>, <em>old_plane_state</em>, <em>new_plane_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_oldnew_plane_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all planes in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_plane_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the old state</dd>
<dt><code class="docutils literal"><span class="pre">new_plane_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all planes in an atomic update, tracking both old and
new state. This is useful in places where the state delta needs to be
considered, for example in atomic check functions.</p>
<dl class="function">
<dt id="c.for_each_old_plane_in_state">
<code class="descname">for_each_old_plane_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>plane</em>, <em>old_plane_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_old_plane_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all planes in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_plane_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the old state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all planes in an atomic update, tracking only the old
state. This is useful in disable functions, where we need the old state the
hardware is still in.</p>
<dl class="function">
<dt id="c.for_each_new_plane_in_state">
<code class="descname">for_each_new_plane_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>plane</em>, <em>new_plane_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_new_plane_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all planes in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">new_plane_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all planes in an atomic update, tracking only the new
state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.</p>
<dl class="function">
<dt id="c.for_each_oldnew_private_obj_in_state">
<code class="descname">for_each_oldnew_private_obj_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>obj</em>, <em>old_obj_state</em>, <em>new_obj_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_oldnew_private_obj_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all private objects in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">obj</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_obj</span></code> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_obj_state</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_state</span></code> iteration cursor for the old state</dd>
<dt><code class="docutils literal"><span class="pre">new_obj_state</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_state</span></code> iteration cursor for the new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all private objects in an atomic update, tracking both
old and new state. This is useful in places where the state delta needs
to be considered, for example in atomic check functions.</p>
<dl class="function">
<dt id="c.for_each_old_private_obj_in_state">
<code class="descname">for_each_old_private_obj_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>obj</em>, <em>old_obj_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_old_private_obj_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all private objects in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">obj</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_obj</span></code> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_obj_state</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_state</span></code> iteration cursor for the old state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all private objects in an atomic update, tracking only
the old state. This is useful in disable functions, where we need the old
state the hardware is still in.</p>
<dl class="function">
<dt id="c.for_each_new_private_obj_in_state">
<code class="descname">for_each_new_private_obj_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>obj</em>, <em>new_obj_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_new_private_obj_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all private objects in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">obj</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_obj</span></code> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">new_obj_state</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_state</span></code> iteration cursor for the new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all private objects in an atomic update, tracking only
the new state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.</p>
<dl class="function">
<dt id="c.drm_atomic_crtc_needs_modeset">
bool <code class="descname">drm_atomic_crtc_needs_modeset</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_needs_modeset" title="Permalink to this definition">¶</a></dt>
<dd><p>compute combined modeset need</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state</span></code></a> for the CRTC</dd>
</dl>
<p><strong>Description</strong></p>
<p>To give drivers flexibility <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> has 3 booleans to track
whether the state CRTC changed enough to need a full modeset cycle:
mode_changed, active_changed and connectors_changed. This helper simply
combines these three to compute the overall need for a modeset for <strong>state</strong>.</p>
<p>The atomic helper code sets these booleans, but drivers can and should
change them appropriately to accurately represent whether a modeset is
really needed. In general, drivers should avoid full modesets whenever
possible.</p>
<p>For example if the CRTC mode has changed, and the hardware is able to enact
the requested mode change without going through a full modeset, the driver
should clear mode_changed in its <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a>
implementation.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
</div>
<div class="section" id="crtc-abstraction">
<h2>CRTC Abstraction<a class="headerlink" href="#crtc-abstraction" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="section" id="crtc-functions-reference">
<h3>CRTC Functions Reference<a class="headerlink" href="#crtc-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_crtc_state">
struct <code class="descname">drm_crtc_state</code><a class="headerlink" href="#c.drm_crtc_state" title="Permalink to this definition">¶</a></dt>
<dd><p>mutable CRTC state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_crtc_state {
  struct drm_crtc * crtc;
  bool enable;
  bool active;
  bool planes_changed:1;
  bool mode_changed:1;
  bool active_changed:1;
  bool connectors_changed:1;
  bool zpos_changed:1;
  bool color_mgmt_changed:1;
  u32 plane_mask;
  u32 connector_mask;
  u32 encoder_mask;
  struct drm_display_mode adjusted_mode;
  struct drm_display_mode mode;
  struct drm_property_blob * mode_blob;
  struct drm_property_blob * degamma_lut;
  struct drm_property_blob * ctm;
  struct drm_property_blob * gamma_lut;
  u32 target_vblank;
  u32 pageflip_flags;
  struct drm_pending_vblank_event * event;
  struct drm_crtc_commit * commit;
  struct drm_atomic_state * state;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>backpointer to the CRTC</dd>
<dt><code class="docutils literal"><span class="pre">enable</span></code></dt>
<dd>whether the CRTC should be enabled, gates all other state</dd>
<dt><code class="docutils literal"><span class="pre">active</span></code></dt>
<dd>whether the CRTC is actively displaying (used for DPMS)</dd>
<dt><code class="docutils literal"><span class="pre">planes_changed</span></code></dt>
<dd>planes on this crtc are updated</dd>
<dt><code class="docutils literal"><span class="pre">mode_changed</span></code></dt>
<dd><strong>mode</strong> or <strong>enable</strong> has been changed</dd>
<dt><code class="docutils literal"><span class="pre">active_changed</span></code></dt>
<dd><strong>active</strong> has been toggled.</dd>
<dt><code class="docutils literal"><span class="pre">connectors_changed</span></code></dt>
<dd>connectors to this crtc have been updated</dd>
<dt><code class="docutils literal"><span class="pre">zpos_changed</span></code></dt>
<dd>zpos values of planes on this crtc have been updated</dd>
<dt><code class="docutils literal"><span class="pre">color_mgmt_changed</span></code></dt>
<dd>color management properties have changed (degamma or
gamma LUT or CSC matrix)</dd>
<dt><code class="docutils literal"><span class="pre">plane_mask</span></code></dt>
<dd>bitmask of (1 &lt;&lt; drm_plane_index(plane)) of attached planes</dd>
<dt><code class="docutils literal"><span class="pre">connector_mask</span></code></dt>
<dd>bitmask of (1 &lt;&lt; drm_connector_index(connector)) of attached connectors</dd>
<dt><code class="docutils literal"><span class="pre">encoder_mask</span></code></dt>
<dd>bitmask of (1 &lt;&lt; drm_encoder_index(encoder)) of attached encoders</dd>
<dt><code class="docutils literal"><span class="pre">adjusted_mode</span></code></dt>
<dd>Internal display timings which can be used by the driver to handle
differences between the mode requested by userspace in <strong>mode</strong> and what
is actually programmed into the hardware. It is purely driver
implementation defined what exactly this adjusted mode means. Usually
it is used to store the hardware display timings used between the
CRTC and encoder blocks.</dd>
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd><p class="first">Display timings requested by userspace. The driver should try to
match the refresh rate as close as possible (but note that it&#8217;s
undefined what exactly is close enough, e.g. some of the HDMI modes
only differ in less than 1% of the refresh rate). The active width
and height as observed by userspace for positioning planes must match
exactly.</p>
<p class="last">For external connectors where the sink isn&#8217;t fixed (like with a
built-in panel), this mode here should match the physical mode on the
wire to the last details (i.e. including sync polarities and
everything).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_blob</span></code></dt>
<dd><a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob"><code class="xref c c-type docutils literal"><span class="pre">drm_property_blob</span></code></a> for <strong>mode</strong></dd>
<dt><code class="docutils literal"><span class="pre">degamma_lut</span></code></dt>
<dd>Lookup table for converting framebuffer pixel data before apply the
color conversion matrix <strong>ctm</strong>. See <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_enable_color_mgmt()</span></code>. The
blob (if not NULL) is an array of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_color_lut</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">ctm</span></code></dt>
<dd>Color transformation matrix. See <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_enable_color_mgmt()</span></code>. The
blob (if not NULL) is a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_color_ctm</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">gamma_lut</span></code></dt>
<dd>Lookup table for converting pixel data after the color conversion
matrix <strong>ctm</strong>.  See <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_enable_color_mgmt()</span></code>. The blob (if not
NULL) is an array of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_color_lut</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">target_vblank</span></code></dt>
<dd>Target vertical blank period when a page flip
should take effect.</dd>
<dt><code class="docutils literal"><span class="pre">pageflip_flags</span></code></dt>
<dd>DRM_MODE_PAGE_FLIP_* flags, as passed to the page flip ioctl.
Zero in any other case.</dd>
<dt><code class="docutils literal"><span class="pre">event</span></code></dt>
<dd><p class="first">Optional pointer to a DRM event to signal upon completion of the
state update. The driver must send out the event when the atomic
commit operation completes. There are two cases:</p>
<blockquote>
<div><ul class="simple">
<li>The event is for a CRTC which is being disabled through this
atomic commit. In that case the event can be send out any time
after the hardware has stopped scanning out the current
framebuffers. It should contain the timestamp and counter for the
last vblank before the display pipeline was shut off. The simplest
way to achieve that is calling <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_send_vblank_event()</span></code>
somewhen after <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code> has been called.</li>
<li>For a CRTC which is enabled at the end of the commit (even when it
undergoes an full modeset) the vblank timestamp and counter must
be for the vblank right before the first frame that scans out the
new set of buffers. Again the event can only be sent out after the
hardware has stopped scanning out the old buffers.</li>
<li>Events for disabled CRTCs are not allowed, and drivers can ignore
that case.</li>
</ul>
</div></blockquote>
<p>This can be handled by the <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_send_vblank_event()</span></code> function,
which the driver should call on the provided event upon completion of
the atomic commit. Note that if the driver supports vblank signalling
and timestamping the vblank counters and timestamps must agree with
the ones returned from page flip events. With the current vblank
helper infrastructure this can be achieved by holding a vblank
reference while the page flip is pending, acquired through
<code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_get()</span></code> and released with <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_put()</span></code>.
Drivers are free to implement their own vblank counter and timestamp
tracking though, e.g. if they have accurate timestamp registers in
hardware.</p>
<p>For hardware which supports some means to synchronize vblank
interrupt delivery with committing display state there&#8217;s also
<code class="xref c c-func docutils literal"><span class="pre">drm_crtc_arm_vblank_event()</span></code>. See the documentation of that function
for a detailed discussion of the constraints it needs to be used
safely.</p>
<p class="last">If the device can&#8217;t notify of flip completion in a race-free way
at all, then the event should be armed just after the page flip is
committed. In the worst case the driver will send the event to
userspace one frame too late. This doesn&#8217;t allow for a real atomic
update, but it should avoid tearing.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">commit</span></code></dt>
<dd>This tracks how the commit for this update proceeds through the
various phases. This is never cleared, except when we destroy the
state, so that subsequent commits can synchronize with previous ones.</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>backpointer to global drm_atomic_state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the distinction between <strong>enable</strong> and <strong>active</strong> is rather subtile:
Flipping <strong>active</strong> while <strong>enable</strong> is set without changing anything else may
never return in a failure from the <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a>
callback. Userspace assumes that a DPMS On will always succeed. In other
words: <strong>enable</strong> controls resource assignment, <strong>active</strong> controls the actual
hardware state.</p>
<p>The three booleans active_changed, connectors_changed and mode_changed are
intended to indicate whether a full modeset is needed, rather than strictly
describing what has changed in a commit.
See also: <a class="reference internal" href="#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a></p>
<dl class="type">
<dt id="c.drm_crtc_funcs">
struct <code class="descname">drm_crtc_funcs</code><a class="headerlink" href="#c.drm_crtc_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>control CRTCs for a given device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_crtc_funcs {
  void (* reset) (struct drm_crtc *crtc);
  int (* cursor_set) (struct drm_crtc *crtc, struct drm_file *file_priv, uint32_t handle, uint32_t width, uint32_t height);
  int (* cursor_set2) (struct drm_crtc *crtc, struct drm_file *file_priv,uint32_t handle, uint32_t width, uint32_t height, int32_t hot_x, int32_t hot_y);
  int (* cursor_move) (struct drm_crtc *crtc, int x, int y);
  int (* gamma_set) (struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,uint32_t size, struct drm_modeset_acquire_ctx *ctx);
  void (* destroy) (struct drm_crtc *crtc);
  int (* set_config) (struct drm_mode_set *set, struct drm_modeset_acquire_ctx *ctx);
  int (* page_flip) (struct drm_crtc *crtc,struct drm_framebuffer *fb,struct drm_pending_vblank_event *event,uint32_t flags, struct drm_modeset_acquire_ctx *ctx);
  int (* page_flip_target) (struct drm_crtc *crtc,struct drm_framebuffer *fb,struct drm_pending_vblank_event *event,uint32_t flags, uint32_t target, struct drm_modeset_acquire_ctx *ctx);
  int (* set_property) (struct drm_crtc *crtc, struct drm_property *property, uint64_t val);
  struct drm_crtc_state *(* atomic_duplicate_state) (struct drm_crtc *crtc);
  void (* atomic_destroy_state) (struct drm_crtc *crtc, struct drm_crtc_state *state);
  int (* atomic_set_property) (struct drm_crtc *crtc,struct drm_crtc_state *state,struct drm_property *property, uint64_t val);
  int (* atomic_get_property) (struct drm_crtc *crtc,const struct drm_crtc_state *state,struct drm_property *property, uint64_t *val);
  int (* late_register) (struct drm_crtc *crtc);
  void (* early_unregister) (struct drm_crtc *crtc);
  int (* set_crc_source) (struct drm_crtc *crtc, const char *source, size_t *values_cnt);
  void (* atomic_print_state) (struct drm_printer *p, const struct drm_crtc_state *state);
  u32 (* get_vblank_counter) (struct drm_crtc *crtc);
  int (* enable_vblank) (struct drm_crtc *crtc);
  void (* disable_vblank) (struct drm_crtc *crtc);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">reset</span></code></dt>
<dd><p class="first">Reset CRTC hardware and software state to off. This function isn&#8217;t
called by the core directly, only through <code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_reset()</span></code>.
It&#8217;s not a helper hook only for historical reasons.</p>
<p class="last">Atomic drivers can use <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_crtc_reset()</span></code> to reset
atomic state using this hook.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cursor_set</span></code></dt>
<dd><p class="first">Update the cursor image. The cursor position is relative to the CRTC
and can be partially or fully outside of the visible area.</p>
<p>Note that contrary to all other KMS functions the legacy cursor entry
points don&#8217;t take a framebuffer object, but instead take directly a
raw buffer object id from the driver&#8217;s buffer manager (which is
either GEM or TTM for current drivers).</p>
<p>This entry point is deprecated, drivers should instead implement
universal plane support and register a proper cursor plane using
<code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init_with_planes()</span></code>.</p>
<p>This callback is optional</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cursor_set2</span></code></dt>
<dd><p class="first">Update the cursor image, including hotspot information. The hotspot
must not affect the cursor position in CRTC coordinates, but is only
meant as a hint for virtualized display hardware to coordinate the
guests and hosts cursor position. The cursor hotspot is relative to
the cursor image. Otherwise this works exactly like <strong>cursor_set</strong>.</p>
<p>This entry point is deprecated, drivers should instead implement
universal plane support and register a proper cursor plane using
<code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init_with_planes()</span></code>.</p>
<p>This callback is optional.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cursor_move</span></code></dt>
<dd><p class="first">Update the cursor position. The cursor does not need to be visible
when this hook is called.</p>
<p>This entry point is deprecated, drivers should instead implement
universal plane support and register a proper cursor plane using
<code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init_with_planes()</span></code>.</p>
<p>This callback is optional.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">gamma_set</span></code></dt>
<dd><p class="first">Set gamma on the CRTC.</p>
<p>This callback is optional.</p>
<p class="last">Atomic drivers who want to support gamma tables should implement the
atomic color management support, enabled by calling
<code class="xref c c-func docutils literal"><span class="pre">drm_crtc_enable_color_mgmt()</span></code>, which then supports the legacy gamma
interface through the <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_legacy_gamma_set()</span></code>
compatibility implementation.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">destroy</span></code></dt>
<dd>Clean up plane resources. This is only called at driver unload time
through <code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code> since a CRTC cannot be hotplugged
in DRM.</dd>
<dt><code class="docutils literal"><span class="pre">set_config</span></code></dt>
<dd><p class="first">This is the main legacy entry point to change the modeset state on a
CRTC. All the details of the desired configuration are passed in a
<a class="reference internal" href="#c.drm_mode_set" title="drm_mode_set"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_set</span></code></a> - see there for details.</p>
<p>Drivers implementing atomic modeset should use
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_set_config()</span></code> to implement this hook.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">page_flip</span></code></dt>
<dd><p class="first">Legacy entry point to schedule a flip to the given framebuffer.</p>
<p>Page flipping is a synchronization mechanism that replaces the frame
buffer being scanned out by the CRTC with a new frame buffer during
vertical blanking, avoiding tearing (except when requested otherwise
through the DRM_MODE_PAGE_FLIP_ASYNC flag). When an application
requests a page flip the DRM core verifies that the new frame buffer
is large enough to be scanned out by the CRTC in the currently
configured mode and then calls this hook with a pointer to the new
frame buffer.</p>
<p>The driver must wait for any pending rendering to the new framebuffer
to complete before executing the flip. It should also wait for any
pending rendering from other drivers if the underlying buffer is a
shared dma-buf.</p>
<p>An application can request to be notified when the page flip has
completed. The drm core will supply a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_event</span></code> in the event
parameter in this case. This can be handled by the
<code class="xref c c-func docutils literal"><span class="pre">drm_crtc_send_vblank_event()</span></code> function, which the driver should call on
the provided event upon completion of the flip. Note that if
the driver supports vblank signalling and timestamping the vblank
counters and timestamps must agree with the ones returned from page
flip events. With the current vblank helper infrastructure this can
be achieved by holding a vblank reference while the page flip is
pending, acquired through <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_get()</span></code> and released with
<code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_put()</span></code>. Drivers are free to implement their own vblank
counter and timestamp tracking though, e.g. if they have accurate
timestamp registers in hardware.</p>
<p>This callback is optional.</p>
<p>NOTE:</p>
<p>Very early versions of the KMS ABI mandated that the driver must
block (but not reject) any rendering to the old framebuffer until the
flip operation has completed and the old framebuffer is no longer
visible. This requirement has been lifted, and userspace is instead
expected to request delivery of an event and wait with recycling old
buffers until such has been received.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure. Note that if a
page flip operation is already pending the callback should return
-EBUSY. Pageflips on a disabled CRTC (either by setting a NULL mode
or just runtime disabled through DPMS respectively the new atomic
&#8220;ACTIVE&#8221; state) should result in an -EINVAL error code. Note that
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_page_flip()</span></code> checks this already for atomic drivers.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">page_flip_target</span></code></dt>
<dd><p class="first">Same as <strong>page_flip</strong> but with an additional parameter specifying the
absolute target vertical blank period (as reported by
<code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_count()</span></code>) when the flip should take effect.</p>
<p class="last">Note that the core code calls drm_crtc_vblank_get before this entry
point, and will call drm_crtc_vblank_put if this entry point returns
any non-0 error code. It&#8217;s the driver&#8217;s responsibility to call
drm_crtc_vblank_put after this entry point returns 0, typically when
the flip completes.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">set_property</span></code></dt>
<dd><p class="first">This is the legacy entry point to update a property attached to the
CRTC.</p>
<p>This callback is optional if the driver does not support any legacy
driver-private properties. For atomic drivers it is not used because
property handling is done entirely in the DRM core.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_duplicate_state</span></code></dt>
<dd><p class="first">Duplicate the current atomic state for this CRTC and return it.
The core and helpers guarantee that any atomic state duplicated with
this hook and still owned by the caller (i.e. not transferred to the
driver by calling <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a>) will be
cleaned up by calling the <strong>atomic_destroy_state</strong> hook in this
structure.</p>
<p>Atomic drivers which don&#8217;t subclass <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> should use
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_crtc_duplicate_state()</span></code>. Drivers that subclass the
state structure to extend it with driver-private state should use
<code class="xref c c-func docutils literal"><span class="pre">__drm_atomic_helper_crtc_duplicate_state()</span></code> to make sure shared state is
duplicated in a consistent fashion across drivers.</p>
<p>It is an error to call this hook before <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.state</span></code></a> has been
initialized correctly.</p>
<p>NOTE:</p>
<p>If the duplicate state references refcounted resources this hook must
acquire a reference for each of them. The driver must release these
references again in <strong>atomic_destroy_state</strong>.</p>
<p>RETURNS:</p>
<p class="last">Duplicated atomic state or NULL when the allocation failed.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_destroy_state</span></code></dt>
<dd>Destroy a state duplicated with <strong>atomic_duplicate_state</strong> and release
or unreference all resources it references</dd>
<dt><code class="docutils literal"><span class="pre">atomic_set_property</span></code></dt>
<dd><p class="first">Decode a driver-private property value and store the decoded value
into the passed-in state structure. Since the atomic core decodes all
standardized properties (even for extensions beyond the core set of
properties which might not be implemented by all drivers) this
requires drivers to subclass the state structure.</p>
<p>Such driver-private properties should really only be implemented for
truly hardware/vendor specific state. Instead it is preferred to
standardize atomic extension and decode the properties used to expose
such an extension in the core.</p>
<p>Do not call this function directly, use
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_set_property()</span></code> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>NOTE:</p>
<p>This function is called in the state assembly phase of atomic
modesets, which can be aborted for any reason (including on
userspace&#8217;s request to just check whether a configuration would be
possible). Drivers MUST NOT touch any persistent state (hardware or
software) or data structures except the passed in <strong>state</strong> parameter.</p>
<p>Also since userspace controls in which order properties are set this
function must not do any input validation (since the state update is
incomplete and hence likely inconsistent). Instead any such input
validation must be done in the various atomic_check callbacks.</p>
<p>RETURNS:</p>
<p class="last">0 if the property has been found, -EINVAL if the property isn&#8217;t
implemented by the driver (which should never happen, the core only
asks for properties attached to this CRTC). No other validation is
allowed by the driver. The core already checks that the property
value is within the range (integer, valid enum value, ...) the driver
set when registering the property.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_get_property</span></code></dt>
<dd><p class="first">Reads out the decoded driver-private property. This is used to
implement the GETCRTC IOCTL.</p>
<p>Do not call this function directly, use
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_get_property()</span></code> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the property isn&#8217;t implemented by the
driver (which should never happen, the core only asks for
properties attached to this CRTC).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">late_register</span></code></dt>
<dd><p class="first">This optional hook can be used to register additional userspace
interfaces attached to the crtc like debugfs interfaces.
It is called late in the driver load sequence from <code class="xref c c-func docutils literal"><span class="pre">drm_dev_register()</span></code>.
Everything added from this callback should be unregistered in
the early_unregister callback.</p>
<p>Returns:</p>
<p class="last">0 on success, or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">early_unregister</span></code></dt>
<dd>This optional hook should be used to unregister the additional
userspace interfaces attached to the crtc from
<strong>late_register</strong>. It is called from <code class="xref c c-func docutils literal"><span class="pre">drm_dev_unregister()</span></code>,
early in the driver unload sequence to disable userspace access
before data structures are torndown.</dd>
<dt><code class="docutils literal"><span class="pre">set_crc_source</span></code></dt>
<dd><p class="first">Changes the source of CRC checksums of frames at the request of
userspace, typically for testing purposes. The sources available are
specific of each driver and a <code class="docutils literal"><span class="pre">NULL</span></code> value indicates that CRC
generation is to be switched off.</p>
<p>When CRC generation is enabled, the driver should call
<code class="xref c c-func docutils literal"><span class="pre">drm_crtc_add_crc_entry()</span></code> at each frame, providing any information
that characterizes the frame contents in the crcN arguments, as
provided from the configured source. Drivers must accept an &#8220;auto&#8221;
source name that will select a default source for this CRTC.</p>
<p>Note that &#8220;auto&#8221; can depend upon the current modeset configuration,
e.g. it could pick an encoder or output specific CRC sampling point.</p>
<p>This callback is optional if the driver does not support any CRC
generation functionality.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_print_state</span></code></dt>
<dd><p class="first">If driver subclasses <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a>, it should implement
this optional hook for printing additional driver specific state.</p>
<p class="last">Do not call this directly, use <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_print_state()</span></code>
instead.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">get_vblank_counter</span></code></dt>
<dd><p class="first">Driver callback for fetching a raw hardware vblank counter for the
CRTC. It&#8217;s meant to be used by new drivers as the replacement of
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.get_vblank_counter</span></code></a> hook.</p>
<p>This callback is optional. If a device doesn&#8217;t have a hardware
counter, the driver can simply leave the hook as NULL. The DRM core
will account for missed vblank events while interrupts where disabled
based on system timestamps.</p>
<p>Wraparound handling and loss of events due to modesetting is dealt
with in the DRM core code, as long as drivers call
<code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_on()</span></code> when disabling or
enabling a CRTC.</p>
<p>See also <code class="xref c c-type docutils literal"><span class="pre">drm_device.vblank_disable_immediate</span></code> and
<code class="xref c c-type docutils literal"><span class="pre">drm_device.max_vblank_count</span></code>.</p>
<p>Returns:</p>
<p class="last">Raw vblank counter value.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">enable_vblank</span></code></dt>
<dd><p class="first">Enable vblank interrupts for the CRTC. It&#8217;s meant to be used by
new drivers as the replacement of <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.enable_vblank</span></code></a> hook.</p>
<p>Returns:</p>
<p class="last">Zero on success, appropriate errno if the vblank interrupt cannot
be enabled.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">disable_vblank</span></code></dt>
<dd>Disable vblank interrupts for the CRTC. It&#8217;s meant to be used by
new drivers as the replacement of <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.disable_vblank</span></code></a> hook.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The drm_crtc_funcs structure is the central CRTC management structure
in the DRM.  Each CRTC controls one or more connectors (note that the name
CRTC is simply historical, a CRTC may control LVDS, VGA, DVI, TV out, etc.
connectors, not just CRTs).</p>
<p>Each driver is responsible for filling out this structure at startup time,
in addition to providing other modesetting features, like i2c and DDC
bus accessors.</p>
<dl class="type">
<dt id="c.drm_crtc">
struct <code class="descname">drm_crtc</code><a class="headerlink" href="#c.drm_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>central CRTC control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_crtc {
  struct drm_device * dev;
  struct device_node * port;
  struct list_head head;
  char * name;
  struct drm_modeset_lock mutex;
  struct drm_mode_object base;
  struct drm_plane * primary;
  struct drm_plane * cursor;
  unsigned index;
  int cursor_x;
  int cursor_y;
  bool enabled;
  struct drm_display_mode mode;
  struct drm_display_mode hwmode;
  int x;
  int y;
  const struct drm_crtc_funcs * funcs;
  uint32_t gamma_size;
  uint16_t * gamma_store;
  const struct drm_crtc_helper_funcs * helper_private;
  struct drm_object_properties properties;
  struct drm_crtc_state * state;
  struct list_head commit_list;
  spinlock_t commit_lock;
#ifdef CONFIG_DEBUG_FS
  struct dentry * debugfs_entry;
#endif
  struct drm_crtc_crc crc;
  unsigned int fence_context;
  spinlock_t fence_lock;
  unsigned long fence_seqno;
  char timeline_name;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>parent DRM device</dd>
<dt><code class="docutils literal"><span class="pre">port</span></code></dt>
<dd>OF node used by <code class="xref c c-func docutils literal"><span class="pre">drm_of_find_possible_crtcs()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>list management</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>human readable name, can be overwritten by the driver</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd><p class="first">This provides a read lock for the overall CRTC state (mode, dpms
state, ...) and a write lock for everything which can be update
without a full modeset (fb, cursor data, CRTC properties ...). A full
modeset also need to grab <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connection_mutex</span></code></a>.</p>
<p class="last">For atomic drivers specifically this protects <strong>state</strong>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base KMS object for ID tracking etc.</dd>
<dt><code class="docutils literal"><span class="pre">primary</span></code></dt>
<dd>primary plane for this CRTC</dd>
<dt><code class="docutils literal"><span class="pre">cursor</span></code></dt>
<dd>cursor plane for this CRTC</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>Position inside the mode_config.list, can be used as an array
index. It is invariant over the lifetime of the CRTC.</dd>
<dt><code class="docutils literal"><span class="pre">cursor_x</span></code></dt>
<dd>current x position of the cursor, used for universal cursor planes</dd>
<dt><code class="docutils literal"><span class="pre">cursor_y</span></code></dt>
<dd>current y position of the cursor, used for universal cursor planes</dd>
<dt><code class="docutils literal"><span class="pre">enabled</span></code></dt>
<dd>is this CRTC enabled?</dd>
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd>current mode timings</dd>
<dt><code class="docutils literal"><span class="pre">hwmode</span></code></dt>
<dd>mode timings as programmed to hw regs</dd>
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>x position on screen</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>y position on screen</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>CRTC control functions</dd>
<dt><code class="docutils literal"><span class="pre">gamma_size</span></code></dt>
<dd>size of gamma ramp</dd>
<dt><code class="docutils literal"><span class="pre">gamma_store</span></code></dt>
<dd>gamma ramp values</dd>
<dt><code class="docutils literal"><span class="pre">helper_private</span></code></dt>
<dd>mid-layer private data</dd>
<dt><code class="docutils literal"><span class="pre">properties</span></code></dt>
<dd>property tracking for this CRTC</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd><p class="first">Current atomic state for this CRTC.</p>
<p class="last">This is protected by <strong>mutex</strong>. Note that nonblocking atomic commits
access the current CRTC state without taking locks. Either by going
through the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointers, see
<a class="reference internal" href="#c.for_each_oldnew_crtc_in_state" title="for_each_oldnew_crtc_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_oldnew_crtc_in_state()</span></code></a>, <a class="reference internal" href="#c.for_each_old_crtc_in_state" title="for_each_old_crtc_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_old_crtc_in_state()</span></code></a> and
<a class="reference internal" href="#c.for_each_new_crtc_in_state" title="for_each_new_crtc_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_new_crtc_in_state()</span></code></a>. Or through careful ordering of atomic
commit operations as implemented in the atomic helpers, see
<a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">commit_list</span></code></dt>
<dd><p class="first">List of <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_commit</span></code></a> structures tracking pending commits.
Protected by <strong>commit_lock</strong>. This list holds its own full reference,
as does the ongoing commit.</p>
<p class="last">&#8220;Note that the commit for a state change is also tracked in
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.commit</span></code></a>. For accessing the immediately preceding
commit in an atomic update it is recommended to just use that
pointer in the old CRTC state, since accessing that doesn&#8217;t need
any locking or list-walking. <strong>commit_list</strong> should only be used to
stall for framebuffer cleanup that&#8217;s signalled through
<a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_commit.cleanup_done</span></code></a>.&#8221;</p>
</dd>
<dt><code class="docutils literal"><span class="pre">commit_lock</span></code></dt>
<dd>Spinlock to protect <strong>commit_list</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">debugfs_entry</span></code></dt>
<dd>Debugfs directory for this CRTC.</dd>
<dt><code class="docutils literal"><span class="pre">crc</span></code></dt>
<dd>Configuration settings of CRC capture.</dd>
<dt><code class="docutils literal"><span class="pre">fence_context</span></code></dt>
<dd>timeline context used for fence operations.</dd>
<dt><code class="docutils literal"><span class="pre">fence_lock</span></code></dt>
<dd>spinlock to protect the fences in the fence_context.</dd>
<dt><code class="docutils literal"><span class="pre">fence_seqno</span></code></dt>
<dd>Seqno variable used as monotonic counter for the fences
created on the CRTC&#8217;s timeline.</dd>
<dt><code class="docutils literal"><span class="pre">timeline_name</span></code></dt>
<dd>The name of the CRTC&#8217;s fence timeline.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each CRTC may have one or more connectors associated with it.  This structure
allows the CRTC to be controlled.</p>
<dl class="type">
<dt id="c.drm_mode_set">
struct <code class="descname">drm_mode_set</code><a class="headerlink" href="#c.drm_mode_set" title="Permalink to this definition">¶</a></dt>
<dd><p>new values for a CRTC config change</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_mode_set {
  struct drm_framebuffer * fb;
  struct drm_crtc * crtc;
  struct drm_display_mode * mode;
  uint32_t x;
  uint32_t y;
  struct drm_connector ** connectors;
  size_t num_connectors;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fb</span></code></dt>
<dd>framebuffer to use for new config</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>CRTC whose configuration we&#8217;re about to change</dd>
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd>mode timings to use</dd>
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>position of this CRTC relative to <strong>fb</strong></dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>position of this CRTC relative to <strong>fb</strong></dd>
<dt><code class="docutils literal"><span class="pre">connectors</span></code></dt>
<dd>array of connectors to drive with this CRTC if possible</dd>
<dt><code class="docutils literal"><span class="pre">num_connectors</span></code></dt>
<dd>size of <strong>connectors</strong> array</dd>
</dl>
<p><strong>Description</strong></p>
<p>This represents a modeset configuration for the legacy SETCRTC ioctl and is
also used internally. Atomic drivers instead use <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_crtc_index">
unsigned int <code class="descname">drm_crtc_index</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find the index of a registered CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC to find index for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered CRTC, return the index of that CRTC within a DRM
device&#8217;s list of CRTCs.</p>
<dl class="function">
<dt id="c.drm_crtc_mask">
uint32_t <code class="descname">drm_crtc_mask</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>find the mask of a registered CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC to find mask for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered CRTC, return the mask bit of that CRTC for an
encoder&#8217;s possible_crtcs field.</p>
<dl class="function">
<dt id="c.drm_crtc_find">
struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> * <code class="descname">drm_crtc_find</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_find" title="Permalink to this definition">¶</a></dt>
<dd><p>look up a CRTC object from its ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>drm file to check for lease against.</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd><a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_object</span></code></a> ID</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be used to look up a CRTC from its userspace ID. Only used by
drivers for legacy IOCTLs and interface, nowadays extensions to the KMS
userspace interface should be done using <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_for_each_crtc">
<code class="descname">drm_for_each_crtc</code><span class="sig-paren">(</span><em>crtc</em>, <em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all CRTCs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>a <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> as the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all CRTCs of <strong>dev</strong>.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
</div>
<div class="section" id="frame-buffer-abstraction">
<h2>Frame Buffer Abstraction<a class="headerlink" href="#frame-buffer-abstraction" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="section" id="frame-buffer-functions-reference">
<h3>Frame Buffer Functions Reference<a class="headerlink" href="#frame-buffer-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_framebuffer_funcs">
struct <code class="descname">drm_framebuffer_funcs</code><a class="headerlink" href="#c.drm_framebuffer_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>framebuffer hooks</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_framebuffer_funcs {
  void (* destroy) (struct drm_framebuffer *framebuffer);
  int (* create_handle) (struct drm_framebuffer *fb,struct drm_file *file_priv, unsigned int *handle);
  int (* dirty) (struct drm_framebuffer *framebuffer,struct drm_file *file_priv, unsigned flags,unsigned color, struct drm_clip_rect *clips, unsigned num_clips);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">destroy</span></code></dt>
<dd>Clean up framebuffer resources, specifically also unreference the
backing storage. The core guarantees to call this function for every
framebuffer successfully created by calling
<a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a>. Drivers must also call
<code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_cleanup()</span></code> to release DRM core resources for this
framebuffer.</dd>
<dt><code class="docutils literal"><span class="pre">create_handle</span></code></dt>
<dd><p class="first">Create a buffer handle in the driver-specific buffer manager (either
GEM or TTM) valid for the passed-in <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span></code></a>. This is used by
the core to implement the GETFB IOCTL, which returns (for
sufficiently priviledged user) also a native buffer handle. This can
be used for seamless transitions between modesetting clients by
copying the current screen contents to a private buffer and blending
between that and the new contents.</p>
<p>GEM based drivers should call <code class="xref c c-func docutils literal"><span class="pre">drm_gem_handle_create()</span></code> to create the
handle.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">dirty</span></code></dt>
<dd><p class="first">Optional callback for the dirty fb IOCTL.</p>
<p>Userspace can notify the driver via this callback that an area of the
framebuffer has changed and should be flushed to the display
hardware. This can also be used internally, e.g. by the fbdev
emulation, though that&#8217;s not the case currently.</p>
<p>See documentation in drm_mode.h for the struct drm_mode_fb_dirty_cmd
for more information as all the semantics and arguments have a one to
one mapping on this function.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_framebuffer">
struct <code class="descname">drm_framebuffer</code><a class="headerlink" href="#c.drm_framebuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>frame buffer object</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_framebuffer {
  struct drm_device * dev;
  struct list_head head;
  struct drm_mode_object base;
  const struct drm_format_info * format;
  const struct drm_framebuffer_funcs * funcs;
  unsigned int pitches;
  unsigned int offsets;
  uint64_t modifier;
  unsigned int width;
  unsigned int height;
  int flags;
  int hot_x;
  int hot_y;
  struct list_head filp_head;
  struct drm_gem_object * obj;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device this framebuffer belongs to</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>Place on the <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.fb_list</span></code></a>, access protected by
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.fb_lock</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base modeset object structure, contains the reference count.</dd>
<dt><code class="docutils literal"><span class="pre">format</span></code></dt>
<dd>framebuffer format information</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>framebuffer vfunc table</dd>
<dt><code class="docutils literal"><span class="pre">pitches</span></code></dt>
<dd>Line stride per buffer. For userspace created object this
is copied from drm_mode_fb_cmd2.</dd>
<dt><code class="docutils literal"><span class="pre">offsets</span></code></dt>
<dd><p class="first">Offset from buffer start to the actual pixel data in bytes,
per buffer. For userspace created object this is copied from
drm_mode_fb_cmd2.</p>
<p>Note that this is a linear offset and does not take into account
tiling or buffer laytou per <strong>modifier</strong>. It meant to be used when the
actual pixel data for this framebuffer plane starts at an offset,
e.g.  when multiple planes are allocated within the same backing
storage buffer object. For tiled layouts this generally means it
<strong>offsets</strong> must at least be tile-size aligned, but hardware often has
stricter requirements.</p>
<p class="last">This should not be used to specifiy x/y pixel offsets into the buffer
data (even for linear buffers). Specifying an x/y pixel offset is
instead done through the source rectangle in <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">modifier</span></code></dt>
<dd>Data layout modifier. This is used to describe
tiling, or also special layouts (like compression) of auxiliary
buffers. For userspace created object this is copied from
drm_mode_fb_cmd2.</dd>
<dt><code class="docutils literal"><span class="pre">width</span></code></dt>
<dd>Logical width of the visible area of the framebuffer, in
pixels.</dd>
<dt><code class="docutils literal"><span class="pre">height</span></code></dt>
<dd>Logical height of the visible area of the framebuffer, in
pixels.</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>Framebuffer flags like DRM_MODE_FB_INTERLACED or
DRM_MODE_FB_MODIFIERS.</dd>
<dt><code class="docutils literal"><span class="pre">hot_x</span></code></dt>
<dd>X coordinate of the cursor hotspot. Used by the legacy cursor
IOCTL when the driver supports cursor through a DRM_PLANE_TYPE_CURSOR
universal plane.</dd>
<dt><code class="docutils literal"><span class="pre">hot_y</span></code></dt>
<dd>Y coordinate of the cursor hotspot. Used by the legacy cursor
IOCTL when the driver supports cursor through a DRM_PLANE_TYPE_CURSOR
universal plane.</dd>
<dt><code class="docutils literal"><span class="pre">filp_head</span></code></dt>
<dd>Placed on <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.fbs</span></code></a>, protected by <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.fbs_lock</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">obj</span></code></dt>
<dd><p class="first">GEM objects backing the framebuffer, one per plane (optional).</p>
<p class="last">This is used by the GEM framebuffer helpers, see e.g.
<code class="xref c c-func docutils literal"><span class="pre">drm_gem_fb_create()</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the fb is refcounted for the benefit of driver internals,
for example some hw, disabling a CRTC/plane is asynchronous, and
scanout does not actually complete until the next vblank.  So some
cleanup (like releasing the reference(s) on the backing GEM bo(s))
should be deferred.  In cases like this, the driver would like to
hold a ref to the fb even though it has already been removed from
userspace perspective. See <a class="reference internal" href="#c.drm_framebuffer_get" title="drm_framebuffer_get"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_get()</span></code></a> and
<a class="reference internal" href="#c.drm_framebuffer_put" title="drm_framebuffer_put"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_put()</span></code></a>.</p>
<p>The refcount is stored inside the mode object <strong>base</strong>.</p>
<dl class="function">
<dt id="c.drm_framebuffer_get">
void <code class="descname">drm_framebuffer_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_get" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a framebuffer reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>DRM framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function increments the framebuffer&#8217;s reference count.</p>
<dl class="function">
<dt id="c.drm_framebuffer_put">
void <code class="descname">drm_framebuffer_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a framebuffer reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>DRM framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function decrements the framebuffer&#8217;s reference count and frees the
framebuffer if the reference count drops to zero.</p>
<dl class="function">
<dt id="c.drm_framebuffer_reference">
void <code class="descname">drm_framebuffer_reference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a framebuffer reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>DRM framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_framebuffer_get" title="drm_framebuffer_get"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_get()</span></code></a> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_framebuffer_unreference">
void <code class="descname">drm_framebuffer_unreference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_unreference" title="Permalink to this definition">¶</a></dt>
<dd><p>release a framebuffer reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>DRM framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_framebuffer_put" title="drm_framebuffer_put"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_put()</span></code></a> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_framebuffer_read_refcount">
uint32_t <code class="descname">drm_framebuffer_read_refcount</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_read_refcount" title="Permalink to this definition">¶</a></dt>
<dd><p>read the framebuffer reference count.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions returns the framebuffer&#8217;s reference count.</p>
<dl class="function">
<dt id="c.drm_framebuffer_assign">
void <code class="descname">drm_framebuffer_assign</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> **<em>&nbsp;p</em>, struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>store a reference to the fb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">**</span> <span class="pre">p</span></code></dt>
<dd>location to store framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>new framebuffer (maybe NULL)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions sets the location to store a reference to the framebuffer,
unreferencing the framebuffer that was previously stored in that location.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
</div>
<div class="section" id="drm-format-handling">
<h2>DRM Format Handling<a class="headerlink" href="#drm-format-handling" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.drm_format_info">
struct <code class="descname">drm_format_info</code><a class="headerlink" href="#c.drm_format_info" title="Permalink to this definition">¶</a></dt>
<dd><p>information about a DRM format</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_format_info {
  u32 format;
  u8 depth;
  u8 num_planes;
  u8 cpp;
  u8 hsub;
  u8 vsub;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">format</span></code></dt>
<dd>4CC format identifier (DRM_FORMAT_*)</dd>
<dt><code class="docutils literal"><span class="pre">depth</span></code></dt>
<dd>Color depth (number of bits per pixel excluding padding bits),
valid for a subset of RGB formats only. This is a legacy field, do not
use in new code and set to 0 for new formats.</dd>
<dt><code class="docutils literal"><span class="pre">num_planes</span></code></dt>
<dd>Number of color planes (1 to 3)</dd>
<dt><code class="docutils literal"><span class="pre">cpp</span></code></dt>
<dd>Number of bytes per pixel (per plane)</dd>
<dt><code class="docutils literal"><span class="pre">hsub</span></code></dt>
<dd>Horizontal chroma subsampling factor</dd>
<dt><code class="docutils literal"><span class="pre">vsub</span></code></dt>
<dd>Vertical chroma subsampling factor</dd>
</dl>
<dl class="type">
<dt id="c.drm_format_name_buf">
struct <code class="descname">drm_format_name_buf</code><a class="headerlink" href="#c.drm_format_name_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>name of a DRM format</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_format_name_buf {
  char str;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">str</span></code></dt>
<dd>string buffer containing the format name</dd>
</dl>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="dumb-buffer-objects">
<h2>Dumb Buffer Objects<a class="headerlink" href="#dumb-buffer-objects" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="plane-abstraction">
<h2>Plane Abstraction<a class="headerlink" href="#plane-abstraction" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="section" id="plane-functions-reference">
<h3>Plane Functions Reference<a class="headerlink" href="#plane-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_plane_state">
struct <code class="descname">drm_plane_state</code><a class="headerlink" href="#c.drm_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>mutable plane state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_plane_state {
  struct drm_plane * plane;
  struct drm_crtc * crtc;
  struct drm_framebuffer * fb;
  struct dma_fence * fence;
  int32_t crtc_x;
  int32_t crtc_y;
  uint32_t crtc_w;
  uint32_t crtc_h;
  uint32_t src_x;
  uint32_t src_y;
  uint32_t src_h;
  uint32_t src_w;
  unsigned int rotation;
  unsigned int zpos;
  unsigned int normalized_zpos;
  struct drm_rect src;
  struct drm_rect dst;
  bool visible;
  struct drm_crtc_commit * commit;
  struct drm_atomic_state * state;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>backpointer to the plane</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>Currently bound CRTC, NULL if disabled. Do not this write directly,
use <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_set_crtc_for_plane()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">fb</span></code></dt>
<dd>Currently bound framebuffer. Do not write this directly, use
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_set_fb_for_plane()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">fence</span></code></dt>
<dd>Optional fence to wait for before scanning out <strong>fb</strong>. Do not write this
directly, use <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_set_fence_for_plane()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">crtc_x</span></code></dt>
<dd>Left position of visible portion of plane on crtc, signed dest
location allows it to be partially off screen.</dd>
<dt><code class="docutils literal"><span class="pre">crtc_y</span></code></dt>
<dd>Upper position of visible portion of plane on crtc, signed dest
location allows it to be partially off screen.</dd>
<dt><code class="docutils literal"><span class="pre">crtc_w</span></code></dt>
<dd>width of visible portion of plane on crtc</dd>
<dt><code class="docutils literal"><span class="pre">crtc_h</span></code></dt>
<dd>height of visible portion of plane on crtc</dd>
<dt><code class="docutils literal"><span class="pre">src_x</span></code></dt>
<dd>left position of visible portion of plane within
plane (in 16.16)</dd>
<dt><code class="docutils literal"><span class="pre">src_y</span></code></dt>
<dd>upper position of visible portion of plane within
plane (in 16.16)</dd>
<dt><code class="docutils literal"><span class="pre">src_h</span></code></dt>
<dd>height of visible portion of plane (in 16.16)</dd>
<dt><code class="docutils literal"><span class="pre">src_w</span></code></dt>
<dd>width of visible portion of plane (in 16.16)</dd>
<dt><code class="docutils literal"><span class="pre">rotation</span></code></dt>
<dd>rotation of the plane</dd>
<dt><code class="docutils literal"><span class="pre">zpos</span></code></dt>
<dd>priority of the given plane on crtc (optional)
Note that multiple active planes on the same crtc can have an identical
zpos value. The rule to solving the conflict is to compare the plane
object IDs; the plane with a higher ID must be stacked on top of a
plane with a lower ID.</dd>
<dt><code class="docutils literal"><span class="pre">normalized_zpos</span></code></dt>
<dd>normalized value of zpos: unique, range from 0 to N-1
where N is the number of active planes for given crtc. Note that
the driver must call <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_normalize_zpos()</span></code> to update this before
it can be trusted.</dd>
<dt><code class="docutils literal"><span class="pre">src</span></code></dt>
<dd>clipped source coordinates of the plane (in 16.16)</dd>
<dt><code class="docutils literal"><span class="pre">dst</span></code></dt>
<dd>clipped destination coordinates of the plane</dd>
<dt><code class="docutils literal"><span class="pre">visible</span></code></dt>
<dd>Visibility of the plane. This can be false even if fb!=NULL and
crtc!=NULL, due to clipping.</dd>
<dt><code class="docutils literal"><span class="pre">commit</span></code></dt>
<dd><p class="first">Tracks the pending commit to prevent use-after-free conditions,
and for async plane updates.</p>
<p class="last">May be NULL.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>backpointer to global drm_atomic_state</dd>
</dl>
<dl class="type">
<dt id="c.drm_plane_funcs">
struct <code class="descname">drm_plane_funcs</code><a class="headerlink" href="#c.drm_plane_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>driver plane control functions</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_plane_funcs {
  int (* update_plane) (struct drm_plane *plane,struct drm_crtc *crtc, struct drm_framebuffer *fb,int crtc_x, int crtc_y,unsigned int crtc_w, unsigned int crtc_h,uint32_t src_x, uint32_t src_y,uint32_t src_w, uint32_t src_h, struct drm_modeset_acquire_ctx *ctx);
  int (* disable_plane) (struct drm_plane *plane, struct drm_modeset_acquire_ctx *ctx);
  void (* destroy) (struct drm_plane *plane);
  void (* reset) (struct drm_plane *plane);
  int (* set_property) (struct drm_plane *plane, struct drm_property *property, uint64_t val);
  struct drm_plane_state *(* atomic_duplicate_state) (struct drm_plane *plane);
  void (* atomic_destroy_state) (struct drm_plane *plane, struct drm_plane_state *state);
  int (* atomic_set_property) (struct drm_plane *plane,struct drm_plane_state *state,struct drm_property *property, uint64_t val);
  int (* atomic_get_property) (struct drm_plane *plane,const struct drm_plane_state *state,struct drm_property *property, uint64_t *val);
  int (* late_register) (struct drm_plane *plane);
  void (* early_unregister) (struct drm_plane *plane);
  void (* atomic_print_state) (struct drm_printer *p, const struct drm_plane_state *state);
  bool (* format_mod_supported) (struct drm_plane *plane, uint32_t format, uint64_t modifier);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">update_plane</span></code></dt>
<dd><p class="first">This is the legacy entry point to enable and configure the plane for
the given CRTC and framebuffer. It is never called to disable the
plane, i.e. the passed-in crtc and fb paramters are never NULL.</p>
<p>The source rectangle in frame buffer memory coordinates is given by
the src_x, src_y, src_w and src_h parameters (as 16.16 fixed point
values). Devices that don&#8217;t support subpixel plane coordinates can
ignore the fractional part.</p>
<p>The destination rectangle in CRTC coordinates is given by the
crtc_x, crtc_y, crtc_w and crtc_h parameters (as integer values).
Devices scale the source rectangle to the destination rectangle. If
scaling is not supported, and the source rectangle size doesn&#8217;t match
the destination rectangle size, the driver must return a
-&lt;errorname&gt;EINVAL&lt;/errorname&gt; error.</p>
<p>Drivers implementing atomic modeset should use
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_update_plane()</span></code> to implement this hook.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">disable_plane</span></code></dt>
<dd><p class="first">This is the legacy entry point to disable the plane. The DRM core
calls this method in response to a DRM_IOCTL_MODE_SETPLANE IOCTL call
with the frame buffer ID set to 0.  Disabled planes must not be
processed by the CRTC.</p>
<p>Drivers implementing atomic modeset should use
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_disable_plane()</span></code> to implement this hook.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">destroy</span></code></dt>
<dd>Clean up plane resources. This is only called at driver unload time
through <code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code> since a plane cannot be hotplugged
in DRM.</dd>
<dt><code class="docutils literal"><span class="pre">reset</span></code></dt>
<dd><p class="first">Reset plane hardware and software state to off. This function isn&#8217;t
called by the core directly, only through <code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_reset()</span></code>.
It&#8217;s not a helper hook only for historical reasons.</p>
<p class="last">Atomic drivers can use <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_plane_reset()</span></code> to reset
atomic state using this hook.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">set_property</span></code></dt>
<dd><p class="first">This is the legacy entry point to update a property attached to the
plane.</p>
<p>This callback is optional if the driver does not support any legacy
driver-private properties. For atomic drivers it is not used because
property handling is done entirely in the DRM core.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_duplicate_state</span></code></dt>
<dd><p class="first">Duplicate the current atomic state for this plane and return it.
The core and helpers guarantee that any atomic state duplicated with
this hook and still owned by the caller (i.e. not transferred to the
driver by calling <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a>) will be
cleaned up by calling the <strong>atomic_destroy_state</strong> hook in this
structure.</p>
<p>Atomic drivers which don&#8217;t subclass <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> should use
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_plane_duplicate_state()</span></code>. Drivers that subclass the
state structure to extend it with driver-private state should use
<code class="xref c c-func docutils literal"><span class="pre">__drm_atomic_helper_plane_duplicate_state()</span></code> to make sure shared state is
duplicated in a consistent fashion across drivers.</p>
<p>It is an error to call this hook before <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane.state</span></code></a> has been
initialized correctly.</p>
<p>NOTE:</p>
<p>If the duplicate state references refcounted resources this hook must
acquire a reference for each of them. The driver must release these
references again in <strong>atomic_destroy_state</strong>.</p>
<p>RETURNS:</p>
<p class="last">Duplicated atomic state or NULL when the allocation failed.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_destroy_state</span></code></dt>
<dd>Destroy a state duplicated with <strong>atomic_duplicate_state</strong> and release
or unreference all resources it references</dd>
<dt><code class="docutils literal"><span class="pre">atomic_set_property</span></code></dt>
<dd><p class="first">Decode a driver-private property value and store the decoded value
into the passed-in state structure. Since the atomic core decodes all
standardized properties (even for extensions beyond the core set of
properties which might not be implemented by all drivers) this
requires drivers to subclass the state structure.</p>
<p>Such driver-private properties should really only be implemented for
truly hardware/vendor specific state. Instead it is preferred to
standardize atomic extension and decode the properties used to expose
such an extension in the core.</p>
<p>Do not call this function directly, use
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_plane_set_property()</span></code> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>NOTE:</p>
<p>This function is called in the state assembly phase of atomic
modesets, which can be aborted for any reason (including on
userspace&#8217;s request to just check whether a configuration would be
possible). Drivers MUST NOT touch any persistent state (hardware or
software) or data structures except the passed in <strong>state</strong> parameter.</p>
<p>Also since userspace controls in which order properties are set this
function must not do any input validation (since the state update is
incomplete and hence likely inconsistent). Instead any such input
validation must be done in the various atomic_check callbacks.</p>
<p>RETURNS:</p>
<p class="last">0 if the property has been found, -EINVAL if the property isn&#8217;t
implemented by the driver (which shouldn&#8217;t ever happen, the core only
asks for properties attached to this plane). No other validation is
allowed by the driver. The core already checks that the property
value is within the range (integer, valid enum value, ...) the driver
set when registering the property.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_get_property</span></code></dt>
<dd><p class="first">Reads out the decoded driver-private property. This is used to
implement the GETPLANE IOCTL.</p>
<p>Do not call this function directly, use
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_plane_get_property()</span></code> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the property isn&#8217;t implemented by the
driver (which should never happen, the core only asks for
properties attached to this plane).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">late_register</span></code></dt>
<dd><p class="first">This optional hook can be used to register additional userspace
interfaces attached to the plane like debugfs interfaces.
It is called late in the driver load sequence from <code class="xref c c-func docutils literal"><span class="pre">drm_dev_register()</span></code>.
Everything added from this callback should be unregistered in
the early_unregister callback.</p>
<p>Returns:</p>
<p class="last">0 on success, or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">early_unregister</span></code></dt>
<dd>This optional hook should be used to unregister the additional
userspace interfaces attached to the plane from
<strong>late_register</strong>. It is called from <code class="xref c c-func docutils literal"><span class="pre">drm_dev_unregister()</span></code>,
early in the driver unload sequence to disable userspace access
before data structures are torndown.</dd>
<dt><code class="docutils literal"><span class="pre">atomic_print_state</span></code></dt>
<dd><p class="first">If driver subclasses <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a>, it should implement
this optional hook for printing additional driver specific state.</p>
<p class="last">Do not call this directly, use <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_plane_print_state()</span></code>
instead.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">format_mod_supported</span></code></dt>
<dd><p class="first">This optional hook is used for the DRM to determine if the given
format/modifier combination is valid for the plane. This allows the
DRM to generate the correct format bitmask (which formats apply to
which modifier).</p>
<p>Returns:</p>
<p class="last">True if the given modifier is valid for that format on the plane.
False otherwise.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_plane_type">
enum <code class="descname">drm_plane_type</code><a class="headerlink" href="#c.drm_plane_type" title="Permalink to this definition">¶</a></dt>
<dd><p>uapi plane type enumeration</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DRM_PLANE_TYPE_OVERLAY</span></code></dt>
<dd>Overlay planes represent all non-primary, non-cursor planes. Some
drivers refer to these types of planes as &#8220;sprites&#8221; internally.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_PLANE_TYPE_PRIMARY</span></code></dt>
<dd>Primary planes represent a &#8220;main&#8221; plane for a CRTC.  Primary planes
are the planes operated upon by CRTC modesetting and flipping
operations described in the <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.page_flip</span></code></a> and
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.set_config</span></code></a> hooks.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_PLANE_TYPE_CURSOR</span></code></dt>
<dd>Cursor planes represent a &#8220;cursor&#8221; plane for a CRTC.  Cursor planes
are the planes operated upon by the DRM_IOCTL_MODE_CURSOR and
DRM_IOCTL_MODE_CURSOR2 IOCTLs.</dd>
</dl>
<p><strong>Description</strong></p>
<p>For historical reasons not all planes are made the same. This enumeration is
used to tell the different types of planes apart to implement the different
uapi semantics for them. For userspace which is universal plane aware and
which is using that atomic IOCTL there&#8217;s no difference between these planes
(beyong what the driver and hardware can support of course).</p>
<p>For compatibility with legacy userspace, only overlay planes are made
available to userspace by default. Userspace clients may set the
DRM_CLIENT_CAP_UNIVERSAL_PLANES client capability bit to indicate that they
wish to receive a universal plane list containing all plane types. See also
<a class="reference internal" href="#c.drm_for_each_legacy_plane" title="drm_for_each_legacy_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_for_each_legacy_plane()</span></code></a>.</p>
<p>WARNING: The values of this enum is UABI since they&#8217;re exposed in the &#8220;type&#8221;
property.</p>
<dl class="type">
<dt id="c.drm_plane">
struct <code class="descname">drm_plane</code><a class="headerlink" href="#c.drm_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>central DRM plane control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_plane {
  struct drm_device * dev;
  struct list_head head;
  char * name;
  struct drm_modeset_lock mutex;
  struct drm_mode_object base;
  uint32_t possible_crtcs;
  uint32_t * format_types;
  unsigned int format_count;
  bool format_default;
  struct drm_crtc * crtc;
  struct drm_framebuffer * fb;
  struct drm_framebuffer * old_fb;
  const struct drm_plane_funcs * funcs;
  struct drm_object_properties properties;
  enum drm_plane_type type;
  unsigned index;
  const struct drm_plane_helper_funcs * helper_private;
  struct drm_plane_state * state;
  struct drm_property * zpos_property;
  struct drm_property * rotation_property;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device this plane belongs to</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>for list management</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>human readable name, can be overwritten by the driver</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd><p class="first">Protects modeset plane state, together with the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.mutex</span></code></a> of
CRTC this plane is linked to (when active, getting activated or
getting disabled).</p>
<p class="last">For atomic drivers specifically this protects <strong>state</strong>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base mode object</dd>
<dt><code class="docutils literal"><span class="pre">possible_crtcs</span></code></dt>
<dd>pipes this plane can be bound to</dd>
<dt><code class="docutils literal"><span class="pre">format_types</span></code></dt>
<dd>array of formats supported by this plane</dd>
<dt><code class="docutils literal"><span class="pre">format_count</span></code></dt>
<dd>number of formats supported</dd>
<dt><code class="docutils literal"><span class="pre">format_default</span></code></dt>
<dd>driver hasn&#8217;t supplied supported formats for the plane</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>currently bound CRTC</dd>
<dt><code class="docutils literal"><span class="pre">fb</span></code></dt>
<dd>currently bound fb</dd>
<dt><code class="docutils literal"><span class="pre">old_fb</span></code></dt>
<dd>Temporary tracking of the old fb while a modeset is ongoing. Used by
<code class="xref c c-func docutils literal"><span class="pre">drm_mode_set_config_internal()</span></code> to implement correct refcounting.</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>helper functions</dd>
<dt><code class="docutils literal"><span class="pre">properties</span></code></dt>
<dd>property tracking for this plane</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of plane (overlay, primary, cursor)</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>Position inside the mode_config.list, can be used as an array
index. It is invariant over the lifetime of the plane.</dd>
<dt><code class="docutils literal"><span class="pre">helper_private</span></code></dt>
<dd>mid-layer private data</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd><p class="first">Current atomic state for this plane.</p>
<p class="last">This is protected by <strong>mutex</strong>. Note that nonblocking atomic commits
access the current plane state without taking locks. Either by going
through the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointers, see
<a class="reference internal" href="#c.for_each_oldnew_plane_in_state" title="for_each_oldnew_plane_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_oldnew_plane_in_state()</span></code></a>, <a class="reference internal" href="#c.for_each_old_plane_in_state" title="for_each_old_plane_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_old_plane_in_state()</span></code></a> and
<a class="reference internal" href="#c.for_each_new_plane_in_state" title="for_each_new_plane_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_new_plane_in_state()</span></code></a>. Or through careful ordering of atomic
commit operations as implemented in the atomic helpers, see
<a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">zpos_property</span></code></dt>
<dd>zpos property for this plane</dd>
<dt><code class="docutils literal"><span class="pre">rotation_property</span></code></dt>
<dd>rotation property for this plane</dd>
</dl>
<dl class="function">
<dt id="c.drm_plane_index">
unsigned int <code class="descname">drm_plane_index</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find the index of a registered plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to find index for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered plane, return the index of that plane within a DRM
device&#8217;s list of planes.</p>
<dl class="function">
<dt id="c.drm_plane_find">
struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> * <code class="descname">drm_plane_find</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_find" title="Permalink to this definition">¶</a></dt>
<dd><p>find a <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>drm file to check for lease against.</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>plane id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the plane with <strong>id</strong>, NULL if it doesn&#8217;t exist. Simple wrapper around
<code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_find()</span></code>.</p>
<dl class="function">
<dt id="c.drm_for_each_plane_mask">
<code class="descname">drm_for_each_plane_mask</code><span class="sig-paren">(</span><em>plane</em>, <em>dev</em>, <em>plane_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_plane_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over planes specified by bitmask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the DRM device</dd>
<dt><code class="docutils literal"><span class="pre">plane_mask</span></code></dt>
<dd>bitmask of plane indices</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all planes specified by bitmask.</p>
<dl class="function">
<dt id="c.drm_for_each_legacy_plane">
<code class="descname">drm_for_each_legacy_plane</code><span class="sig-paren">(</span><em>plane</em>, <em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_legacy_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all planes for legacy userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all legacy planes of <strong>dev</strong>, excluding primary and cursor planes.
This is useful for implementing userspace apis when userspace is not
universal plane aware. See also <a class="reference internal" href="#c.drm_plane_type" title="drm_plane_type"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">drm_plane_type</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_for_each_plane">
<code class="descname">drm_for_each_plane</code><span class="sig-paren">(</span><em>plane</em>, <em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all planes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all planes of <strong>dev</strong>, include primary and cursor planes.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
</div>
<div class="section" id="display-modes-function-reference">
<h2>Display Modes Function Reference<a class="headerlink" href="#display-modes-function-reference" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.drm_mode_status">
enum <code class="descname">drm_mode_status</code><a class="headerlink" href="#c.drm_mode_status" title="Permalink to this definition">¶</a></dt>
<dd><p>hardware support status of a mode</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">MODE_OK</span></code></dt>
<dd>Mode OK</dd>
<dt><code class="docutils literal"><span class="pre">MODE_HSYNC</span></code></dt>
<dd>hsync out of range</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VSYNC</span></code></dt>
<dd>vsync out of range</dd>
<dt><code class="docutils literal"><span class="pre">MODE_H_ILLEGAL</span></code></dt>
<dd>mode has illegal horizontal timings</dd>
<dt><code class="docutils literal"><span class="pre">MODE_V_ILLEGAL</span></code></dt>
<dd>mode has illegal horizontal timings</dd>
<dt><code class="docutils literal"><span class="pre">MODE_BAD_WIDTH</span></code></dt>
<dd>requires an unsupported linepitch</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NOMODE</span></code></dt>
<dd>no mode with a matching name</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NO_INTERLACE</span></code></dt>
<dd>interlaced mode not supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NO_DBLESCAN</span></code></dt>
<dd>doublescan mode not supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NO_VSCAN</span></code></dt>
<dd>multiscan mode not supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_MEM</span></code></dt>
<dd>insufficient video memory</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VIRTUAL_X</span></code></dt>
<dd>mode width too large for specified virtual size</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VIRTUAL_Y</span></code></dt>
<dd>mode height too large for specified virtual size</dd>
<dt><code class="docutils literal"><span class="pre">MODE_MEM_VIRT</span></code></dt>
<dd>insufficient video memory given virtual size</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NOCLOCK</span></code></dt>
<dd>no fixed clock available</dd>
<dt><code class="docutils literal"><span class="pre">MODE_CLOCK_HIGH</span></code></dt>
<dd>clock required is too high</dd>
<dt><code class="docutils literal"><span class="pre">MODE_CLOCK_LOW</span></code></dt>
<dd>clock required is too low</dd>
<dt><code class="docutils literal"><span class="pre">MODE_CLOCK_RANGE</span></code></dt>
<dd>clock/mode isn&#8217;t in a ClockRange</dd>
<dt><code class="docutils literal"><span class="pre">MODE_BAD_HVALUE</span></code></dt>
<dd>horizontal timing was out of range</dd>
<dt><code class="docutils literal"><span class="pre">MODE_BAD_VVALUE</span></code></dt>
<dd>vertical timing was out of range</dd>
<dt><code class="docutils literal"><span class="pre">MODE_BAD_VSCAN</span></code></dt>
<dd>VScan value out of range</dd>
<dt><code class="docutils literal"><span class="pre">MODE_HSYNC_NARROW</span></code></dt>
<dd>horizontal sync too narrow</dd>
<dt><code class="docutils literal"><span class="pre">MODE_HSYNC_WIDE</span></code></dt>
<dd>horizontal sync too wide</dd>
<dt><code class="docutils literal"><span class="pre">MODE_HBLANK_NARROW</span></code></dt>
<dd>horizontal blanking too narrow</dd>
<dt><code class="docutils literal"><span class="pre">MODE_HBLANK_WIDE</span></code></dt>
<dd>horizontal blanking too wide</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VSYNC_NARROW</span></code></dt>
<dd>vertical sync too narrow</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VSYNC_WIDE</span></code></dt>
<dd>vertical sync too wide</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VBLANK_NARROW</span></code></dt>
<dd>vertical blanking too narrow</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VBLANK_WIDE</span></code></dt>
<dd>vertical blanking too wide</dd>
<dt><code class="docutils literal"><span class="pre">MODE_PANEL</span></code></dt>
<dd>exceeds panel dimensions</dd>
<dt><code class="docutils literal"><span class="pre">MODE_INTERLACE_WIDTH</span></code></dt>
<dd>width too large for interlaced mode</dd>
<dt><code class="docutils literal"><span class="pre">MODE_ONE_WIDTH</span></code></dt>
<dd>only one width is supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_ONE_HEIGHT</span></code></dt>
<dd>only one height is supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_ONE_SIZE</span></code></dt>
<dd>only one resolution is supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NO_REDUCED</span></code></dt>
<dd>monitor doesn&#8217;t accept reduced blanking</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NO_STEREO</span></code></dt>
<dd>stereo modes not supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NO_420</span></code></dt>
<dd>ycbcr 420 modes not supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_STALE</span></code></dt>
<dd>mode has become stale</dd>
<dt><code class="docutils literal"><span class="pre">MODE_BAD</span></code></dt>
<dd>unspecified reason</dd>
<dt><code class="docutils literal"><span class="pre">MODE_ERROR</span></code></dt>
<dd>error condition</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum is used to filter out modes not supported by the driver/hardware
combination.</p>
<dl class="type">
<dt id="c.drm_display_mode">
struct <code class="descname">drm_display_mode</code><a class="headerlink" href="#c.drm_display_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM kernel-internal display mode structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_display_mode {
  struct list_head head;
  struct drm_mode_object base;
  char name;
  enum drm_mode_status status;
  unsigned int type;
  int clock;
  int hdisplay;
  int hsync_start;
  int hsync_end;
  int htotal;
  int hskew;
  int vdisplay;
  int vsync_start;
  int vsync_end;
  int vtotal;
  int vscan;
  unsigned int flags;
  int width_mm;
  int height_mm;
  int crtc_clock;
  int crtc_hdisplay;
  int crtc_hblank_start;
  int crtc_hblank_end;
  int crtc_hsync_start;
  int crtc_hsync_end;
  int crtc_htotal;
  int crtc_hskew;
  int crtc_vdisplay;
  int crtc_vblank_start;
  int crtc_vblank_end;
  int crtc_vsync_start;
  int crtc_vsync_end;
  int crtc_vtotal;
  int * private;
  int private_flags;
  int vrefresh;
  int hsync;
  enum hdmi_picture_aspect picture_aspect_ratio;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>struct list_head for mode lists.</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd><p class="first">A display mode is a normal modeset object, possibly including public
userspace id.</p>
<p>FIXME:</p>
<p class="last">This can probably be removed since the entire concept of userspace
managing modes explicitly has never landed in upstream kernel mode
setting support.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Human-readable name of the mode, filled out with <code class="xref c c-func docutils literal"><span class="pre">drm_mode_set_name()</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">status</span></code></dt>
<dd>Status of the mode, used to filter out modes not supported by the
hardware. See enum <a class="reference internal" href="#c.drm_mode_status" title="drm_mode_status"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_status</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd><p class="first">A bitmask of flags, mostly about the source of a mode. Possible flags
are:</p>
<blockquote>
<div><ul class="simple">
<li>DRM_MODE_TYPE_BUILTIN: Meant for hard-coded modes, effectively
unused.</li>
<li>DRM_MODE_TYPE_PREFERRED: Preferred mode, usually the native
resolution of an LCD panel. There should only be one preferred
mode per connector at any given time.</li>
<li>DRM_MODE_TYPE_DRIVER: Mode created by the driver, which is all of
them really. Drivers must set this bit for all modes they create
and expose to userspace.</li>
</ul>
</div></blockquote>
<p>Plus a big list of flags which shouldn&#8217;t be used at all, but are
still around since these flags are also used in the userspace ABI:</p>
<blockquote class="last">
<div><ul class="simple">
<li>DRM_MODE_TYPE_DEFAULT: Again a leftover, use
DRM_MODE_TYPE_PREFERRED instead.</li>
<li>DRM_MODE_TYPE_CLOCK_C and DRM_MODE_TYPE_CRTC_C: Define leftovers
which are stuck around for hysterical raisins only. No one has an
idea what they were meant for. Don&#8217;t use.</li>
<li>DRM_MODE_TYPE_USERDEF: Mode defined by userspace, again a vestige
from older kms designs where userspace had to first add a custom
mode to the kernel&#8217;s mode list before it could use it. Don&#8217;t use.</li>
</ul>
</div></blockquote>
</dd>
<dt><code class="docutils literal"><span class="pre">clock</span></code></dt>
<dd>Pixel clock in kHz.</dd>
<dt><code class="docutils literal"><span class="pre">hdisplay</span></code></dt>
<dd>horizontal display size</dd>
<dt><code class="docutils literal"><span class="pre">hsync_start</span></code></dt>
<dd>horizontal sync start</dd>
<dt><code class="docutils literal"><span class="pre">hsync_end</span></code></dt>
<dd>horizontal sync end</dd>
<dt><code class="docutils literal"><span class="pre">htotal</span></code></dt>
<dd>horizontal total size</dd>
<dt><code class="docutils literal"><span class="pre">hskew</span></code></dt>
<dd>horizontal skew?!</dd>
<dt><code class="docutils literal"><span class="pre">vdisplay</span></code></dt>
<dd>vertical display size</dd>
<dt><code class="docutils literal"><span class="pre">vsync_start</span></code></dt>
<dd>vertical sync start</dd>
<dt><code class="docutils literal"><span class="pre">vsync_end</span></code></dt>
<dd>vertical sync end</dd>
<dt><code class="docutils literal"><span class="pre">vtotal</span></code></dt>
<dd>vertical total size</dd>
<dt><code class="docutils literal"><span class="pre">vscan</span></code></dt>
<dd>vertical scan?!</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd><p class="first">Sync and timing flags:</p>
<blockquote>
<div><ul class="simple">
<li>DRM_MODE_FLAG_PHSYNC: horizontal sync is active high.</li>
<li>DRM_MODE_FLAG_NHSYNC: horizontal sync is active low.</li>
<li>DRM_MODE_FLAG_PVSYNC: vertical sync is active high.</li>
<li>DRM_MODE_FLAG_NVSYNC: vertical sync is active low.</li>
<li>DRM_MODE_FLAG_INTERLACE: mode is interlaced.</li>
<li>DRM_MODE_FLAG_DBLSCAN: mode uses doublescan.</li>
<li>DRM_MODE_FLAG_CSYNC: mode uses composite sync.</li>
<li>DRM_MODE_FLAG_PCSYNC: composite sync is active high.</li>
<li>DRM_MODE_FLAG_NCSYNC: composite sync is active low.</li>
<li>DRM_MODE_FLAG_HSKEW: hskew provided (not used?).</li>
<li>DRM_MODE_FLAG_BCAST: not used?</li>
<li>DRM_MODE_FLAG_PIXMUX: not used?</li>
<li>DRM_MODE_FLAG_DBLCLK: double-clocked mode.</li>
<li>DRM_MODE_FLAG_CLKDIV2: half-clocked mode.</li>
</ul>
</div></blockquote>
<p>Additionally there&#8217;s flags to specify how 3D modes are packed:</p>
<blockquote class="last">
<div><ul class="simple">
<li>DRM_MODE_FLAG_3D_NONE: normal, non-3D mode.</li>
<li>DRM_MODE_FLAG_3D_FRAME_PACKING: 2 full frames for left and right.</li>
<li>DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE: interleaved like fields.</li>
<li>DRM_MODE_FLAG_3D_LINE_ALTERNATIVE: interleaved lines.</li>
<li>DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL: side-by-side full frames.</li>
<li>DRM_MODE_FLAG_3D_L_DEPTH: ?</li>
<li>DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH: ?</li>
<li>DRM_MODE_FLAG_3D_TOP_AND_BOTTOM: frame split into top and bottom
parts.</li>
<li>DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF: frame split into left and
right parts.</li>
</ul>
</div></blockquote>
</dd>
<dt><code class="docutils literal"><span class="pre">width_mm</span></code></dt>
<dd>Addressable size of the output in mm, projectors should set this to
0.</dd>
<dt><code class="docutils literal"><span class="pre">height_mm</span></code></dt>
<dd>Addressable size of the output in mm, projectors should set this to
0.</dd>
<dt><code class="docutils literal"><span class="pre">crtc_clock</span></code></dt>
<dd><p class="first">Actual pixel or dot clock in the hardware. This differs from the
logical <strong>clock</strong> when e.g. using interlacing, double-clocking, stereo
modes or other fancy stuff that changes the timings and signals
actually sent over the wire.</p>
<p>This is again in kHz.</p>
<p class="last">Note that with digital outputs like HDMI or DP there&#8217;s usually a
massive confusion between the dot clock and the signal clock at the
bit encoding level. Especially when a 8b/10b encoding is used and the
difference is exactly a factor of 10.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hdisplay</span></code></dt>
<dd>hardware mode horizontal display size</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hblank_start</span></code></dt>
<dd>hardware mode horizontal blank start</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hblank_end</span></code></dt>
<dd>hardware mode horizontal blank end</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hsync_start</span></code></dt>
<dd>hardware mode horizontal sync start</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hsync_end</span></code></dt>
<dd>hardware mode horizontal sync end</dd>
<dt><code class="docutils literal"><span class="pre">crtc_htotal</span></code></dt>
<dd>hardware mode horizontal total size</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hskew</span></code></dt>
<dd>hardware mode horizontal skew?!</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vdisplay</span></code></dt>
<dd>hardware mode vertical display size</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vblank_start</span></code></dt>
<dd>hardware mode vertical blank start</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vblank_end</span></code></dt>
<dd>hardware mode vertical blank end</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vsync_start</span></code></dt>
<dd>hardware mode vertical sync start</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vsync_end</span></code></dt>
<dd>hardware mode vertical sync end</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vtotal</span></code></dt>
<dd>hardware mode vertical total size</dd>
<dt><code class="docutils literal"><span class="pre">private</span></code></dt>
<dd>Pointer for driver private data. This can only be used for mode
objects passed to drivers in modeset operations. It shouldn&#8217;t be used
by atomic drivers since they can store any additional data by
subclassing state structures.</dd>
<dt><code class="docutils literal"><span class="pre">private_flags</span></code></dt>
<dd>Similar to <strong>private</strong>, but just an integer.</dd>
<dt><code class="docutils literal"><span class="pre">vrefresh</span></code></dt>
<dd><p class="first">Vertical refresh rate, for debug output in human readable form. Not
used in a functional way.</p>
<p class="last">This value is in Hz.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">hsync</span></code></dt>
<dd><p class="first">Horizontal refresh rate, for debug output in human readable form. Not
used in a functional way.</p>
<p class="last">This value is in kHz.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">picture_aspect_ratio</span></code></dt>
<dd>Field for setting the HDMI picture aspect ratio of a mode.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The horizontal and vertical timings are defined per the following diagram.</p>
<div class="highlight-none"><div class="highlight"><pre>          Active                 Front           Sync           Back
         Region                 Porch                          Porch
&lt;-----------------------&gt;&lt;----------------&gt;&lt;-------------&gt;&lt;--------------&gt;
  //////////////////////|
 ////////////////////// |
//////////////////////  |..................               ................
                                           _______________
&lt;----- [hv]display -----&gt;
&lt;------------- [hv]sync_start ------------&gt;
&lt;--------------------- [hv]sync_end ---------------------&gt;
&lt;-------------------------------- [hv]total -----------------------------&gt;*
</pre></div>
</div>
<p>This structure contains two copies of timings. First are the plain timings,
which specify the logical mode, as it would be for a progressive 1:1 scanout
at the refresh rate userspace can observe through vblank timestamps. Then
there&#8217;s the hardware timings, which are corrected for interlacing,
double-clocking and similar things. They are provided as a convenience, and
can be appropriately computed using <code class="xref c c-func docutils literal"><span class="pre">drm_mode_set_crtcinfo()</span></code>.</p>
<p>For printing you can use <code class="docutils literal"><span class="pre">DRM_MODE_FMT</span></code> and <a class="reference internal" href="#c.DRM_MODE_ARG" title="DRM_MODE_ARG"><code class="xref c c-func docutils literal"><span class="pre">DRM_MODE_ARG()</span></code></a>.</p>
<dl class="function">
<dt id="c.DRM_MODE_FMT">
<code class="descname">DRM_MODE_FMT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_MODE_FMT" title="Permalink to this definition">¶</a></dt>
<dd><p>printf string for <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="function">
<dt id="c.DRM_MODE_ARG">
<code class="descname">DRM_MODE_ARG</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_MODE_ARG" title="Permalink to this definition">¶</a></dt>
<dd><p>printf arguments for <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">m</span></code></dt>
<dd>display mode</dd>
</dl>
<dl class="function">
<dt id="c.drm_mode_is_stereo">
bool <code class="descname">drm_mode_is_stereo</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_is_stereo" title="Permalink to this definition">¶</a></dt>
<dd><p>check for stereo mode flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>drm_display_mode to check</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if the mode is one of the stereo modes (like side-by-side), false if
not.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="connector-abstraction">
<h2>Connector Abstraction<a class="headerlink" href="#connector-abstraction" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="section" id="connector-functions-reference">
<h3>Connector Functions Reference<a class="headerlink" href="#connector-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_connector_status">
enum <code class="descname">drm_connector_status</code><a class="headerlink" href="#c.drm_connector_status" title="Permalink to this definition">¶</a></dt>
<dd><p>status for a <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a></p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">connector_status_connected</span></code></dt>
<dd>The connector is definitely connected to
a sink device, and can be enabled.</dd>
<dt><code class="docutils literal"><span class="pre">connector_status_disconnected</span></code></dt>
<dd>The connector isn&#8217;t connected to a
sink device which can be autodetect. For digital outputs like DP or
HDMI (which can be realiable probed) this means there&#8217;s really
nothing there. It is driver-dependent whether a connector with this
status can be lit up or not.</dd>
<dt><code class="docutils literal"><span class="pre">connector_status_unknown</span></code></dt>
<dd>The connector&#8217;s status could not be
reliably detected. This happens when probing would either cause
flicker (like load-detection when the connector is in use), or when a
hardware resource isn&#8217;t available (like when load-detection needs a
free CRTC). It should be possible to light up the connector with one
of the listed fallback modes. For default configuration userspace
should only try to light up connectors with unknown status when
there&#8217;s not connector with <strong>connector_status_connected</strong>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum is used to track the connector status. There are no separate
#defines for the uapi!</p>
<dl class="type">
<dt id="c.drm_scrambling">
struct <code class="descname">drm_scrambling</code><a class="headerlink" href="#c.drm_scrambling" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_scrambling {
  bool supported;
  bool low_rates;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">supported</span></code></dt>
<dd>scrambling supported for rates &gt; 340 Mhz.</dd>
<dt><code class="docutils literal"><span class="pre">low_rates</span></code></dt>
<dd>scrambling supported for rates &lt;= 340 Mhz.</dd>
</dl>
<dl class="type">
<dt id="c.drm_hdmi_info">
struct <code class="descname">drm_hdmi_info</code><a class="headerlink" href="#c.drm_hdmi_info" title="Permalink to this definition">¶</a></dt>
<dd><p>runtime information about the connected HDMI sink</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_hdmi_info {
  struct drm_scdc scdc;
  unsigned long y420_vdb_modes;
  unsigned long y420_cmdb_modes;
  u64 y420_cmdb_map;
  u8 y420_dc_modes;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">scdc</span></code></dt>
<dd>sink&#8217;s scdc support and capabilities</dd>
<dt><code class="docutils literal"><span class="pre">y420_vdb_modes</span></code></dt>
<dd>bitmap of modes which can support ycbcr420
output only (not normal RGB/YCBCR444/422 outputs). There are total
107 VICs defined by CEA-861-F spec, so the size is 128 bits to map
upto 128 VICs;</dd>
<dt><code class="docutils literal"><span class="pre">y420_cmdb_modes</span></code></dt>
<dd>bitmap of modes which can support ycbcr420
output also, along with normal HDMI outputs. There are total 107
VICs defined by CEA-861-F spec, so the size is 128 bits to map upto
128 VICs;</dd>
<dt><code class="docutils literal"><span class="pre">y420_cmdb_map</span></code></dt>
<dd>bitmap of SVD index, to extraxt vcb modes</dd>
<dt><code class="docutils literal"><span class="pre">y420_dc_modes</span></code></dt>
<dd>bitmap of deep color support index</dd>
</dl>
<p><strong>Description</strong></p>
<p>Describes if a given display supports advanced HDMI 2.0 features.
This information is available in CEA-861-F extension blocks (like HF-VSDB).</p>
<dl class="type">
<dt id="c.drm_link_status">
enum <code class="descname">drm_link_status</code><a class="headerlink" href="#c.drm_link_status" title="Permalink to this definition">¶</a></dt>
<dd><p>connector&#8217;s link_status property value</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DRM_LINK_STATUS_GOOD</span></code></dt>
<dd>DP Link is Good as a result of successful
link training</dd>
<dt><code class="docutils literal"><span class="pre">DRM_LINK_STATUS_BAD</span></code></dt>
<dd>DP Link is BAD as a result of link training
failure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum is used as the connector&#8217;s link status property value.
It is set to the values defined in uapi.</p>
<dl class="type">
<dt id="c.drm_display_info">
struct <code class="descname">drm_display_info</code><a class="headerlink" href="#c.drm_display_info" title="Permalink to this definition">¶</a></dt>
<dd><p>runtime data about the connected sink</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_display_info {
  char name;
  unsigned int width_mm;
  unsigned int height_mm;
  unsigned int pixel_clock;
  unsigned int bpc;
  enum subpixel_order subpixel_order;
#define DRM_COLOR_FORMAT_RGB444               (1\\\lt;\\\lt;0
#define DRM_COLOR_FORMAT_YCRCB444     (1\\\lt;\\\lt;1
#define DRM_COLOR_FORMAT_YCRCB422     (1\\\lt;\\\lt;2
#define DRM_COLOR_FORMAT_YCRCB420     (1\\\lt;\\\lt;3
  u32 color_formats;
  const u32 * bus_formats;
  unsigned int num_bus_formats;
#define DRM_BUS_FLAG_DE_LOW           (1\\\lt;\\\lt;0
#define DRM_BUS_FLAG_DE_HIGH          (1\\\lt;\\\lt;1
#define DRM_BUS_FLAG_PIXDATA_POSEDGE  (1\\\lt;\\\lt;2
#define DRM_BUS_FLAG_PIXDATA_NEGEDGE  (1\\\lt;\\\lt;3
#define DRM_BUS_FLAG_DATA_MSB_TO_LSB  (1\\\lt;\\\lt;4
#define DRM_BUS_FLAG_DATA_LSB_TO_MSB  (1\\\lt;\\\lt;5
  u32 bus_flags;
  int max_tmds_clock;
  bool dvi_dual;
  u8 edid_hdmi_dc_modes;
  u8 cea_rev;
  struct drm_hdmi_info hdmi;
  bool non_desktop;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Name of the display.</dd>
<dt><code class="docutils literal"><span class="pre">width_mm</span></code></dt>
<dd>Physical width in mm.</dd>
<dt><code class="docutils literal"><span class="pre">height_mm</span></code></dt>
<dd>Physical height in mm.</dd>
<dt><code class="docutils literal"><span class="pre">pixel_clock</span></code></dt>
<dd>Maximum pixel clock supported by the sink, in units of
100Hz. This mismatches the clock in <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal"><span class="pre">drm_display_mode</span></code></a> (which is in
kHZ), because that&#8217;s what the EDID uses as base unit.</dd>
<dt><code class="docutils literal"><span class="pre">bpc</span></code></dt>
<dd>Maximum bits per color channel. Used by HDMI and DP outputs.</dd>
<dt><code class="docutils literal"><span class="pre">subpixel_order</span></code></dt>
<dd>Subpixel order of LCD panels.</dd>
<dt><code class="docutils literal"><span class="pre">color_formats</span></code></dt>
<dd>HDMI Color formats, selects between RGB and YCrCb
modes. Used DRM_COLOR_FORMAT_ defines, which are _not_ the same ones
as used to describe the pixel format in framebuffers, and also don&#8217;t
match the formats in <strong>bus_formats</strong> which are shared with v4l.</dd>
<dt><code class="docutils literal"><span class="pre">bus_formats</span></code></dt>
<dd>Pixel data format on the wire, somewhat redundant with
<strong>color_formats</strong>. Array of size <strong>num_bus_formats</strong> encoded using
MEDIA_BUS_FMT_ defines shared with v4l and media drivers.</dd>
<dt><code class="docutils literal"><span class="pre">num_bus_formats</span></code></dt>
<dd>Size of <strong>bus_formats</strong> array.</dd>
<dt><code class="docutils literal"><span class="pre">bus_flags</span></code></dt>
<dd>Additional information (like pixel signal polarity) for
the pixel data on the bus, using DRM_BUS_FLAGS_ defines.</dd>
<dt><code class="docutils literal"><span class="pre">max_tmds_clock</span></code></dt>
<dd>Maximum TMDS clock rate supported by the
sink in kHz. 0 means undefined.</dd>
<dt><code class="docutils literal"><span class="pre">dvi_dual</span></code></dt>
<dd>Dual-link DVI sink?</dd>
<dt><code class="docutils literal"><span class="pre">edid_hdmi_dc_modes</span></code></dt>
<dd>Mask of supported hdmi deep color modes. Even
more stuff redundant with <strong>bus_formats</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">cea_rev</span></code></dt>
<dd>CEA revision of the HDMI sink.</dd>
<dt><code class="docutils literal"><span class="pre">hdmi</span></code></dt>
<dd>advance features of a HDMI sink.</dd>
<dt><code class="docutils literal"><span class="pre">non_desktop</span></code></dt>
<dd>Non desktop display (HMD).</dd>
</dl>
<p><strong>Description</strong></p>
<p>Describes a given display (e.g. CRT or flat panel) and its limitations. For
fixed display sinks like built-in panels there&#8217;s not much difference between
this and <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>. But for sinks with a real cable this
structure is meant to describe all the things at the other end of the cable.</p>
<p>For sinks which provide an EDID this can be filled out by calling
<code class="xref c c-func docutils literal"><span class="pre">drm_add_edid_modes()</span></code>.</p>
<dl class="type">
<dt id="c.drm_tv_connector_state">
struct <code class="descname">drm_tv_connector_state</code><a class="headerlink" href="#c.drm_tv_connector_state" title="Permalink to this definition">¶</a></dt>
<dd><p>TV connector related states</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_tv_connector_state {
  enum drm_mode_subconnector subconnector;
  struct margins;
  unsigned int mode;
  unsigned int brightness;
  unsigned int contrast;
  unsigned int flicker_reduction;
  unsigned int overscan;
  unsigned int saturation;
  unsigned int hue;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">subconnector</span></code></dt>
<dd>selected subconnector</dd>
<dt><code class="docutils literal"><span class="pre">margins</span></code></dt>
<dd>left/right/top/bottom margins</dd>
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd>TV mode</dd>
<dt><code class="docutils literal"><span class="pre">brightness</span></code></dt>
<dd>brightness in percent</dd>
<dt><code class="docutils literal"><span class="pre">contrast</span></code></dt>
<dd>contrast in percent</dd>
<dt><code class="docutils literal"><span class="pre">flicker_reduction</span></code></dt>
<dd>flicker reduction in percent</dd>
<dt><code class="docutils literal"><span class="pre">overscan</span></code></dt>
<dd>overscan in percent</dd>
<dt><code class="docutils literal"><span class="pre">saturation</span></code></dt>
<dd>saturation in percent</dd>
<dt><code class="docutils literal"><span class="pre">hue</span></code></dt>
<dd>hue in percent</dd>
</dl>
<dl class="type">
<dt id="c.drm_connector_state">
struct <code class="descname">drm_connector_state</code><a class="headerlink" href="#c.drm_connector_state" title="Permalink to this definition">¶</a></dt>
<dd><p>mutable connector state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_connector_state {
  struct drm_connector * connector;
  struct drm_crtc * crtc;
  struct drm_encoder * best_encoder;
  enum drm_link_status link_status;
  struct drm_atomic_state * state;
  struct drm_crtc_commit * commit;
  struct drm_tv_connector_state tv;
  enum hdmi_picture_aspect picture_aspect_ratio;
  unsigned int scaling_mode;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd>backpointer to the connector</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd><p class="first">CRTC to connect connector to, NULL if disabled.</p>
<p class="last">Do not change this directly, use <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_set_crtc_for_connector()</span></code>
instead.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">best_encoder</span></code></dt>
<dd>can be used by helpers and drivers to select the encoder</dd>
<dt><code class="docutils literal"><span class="pre">link_status</span></code></dt>
<dd>Connector link_status to keep track of whether link is
GOOD or BAD to notify userspace if retraining is necessary.</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>backpointer to global drm_atomic_state</dd>
<dt><code class="docutils literal"><span class="pre">commit</span></code></dt>
<dd><p class="first">Tracks the pending commit to prevent use-after-free conditions.</p>
<p class="last">Is only set when <strong>crtc</strong> is NULL.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">tv</span></code></dt>
<dd>TV connector state</dd>
<dt><code class="docutils literal"><span class="pre">picture_aspect_ratio</span></code></dt>
<dd><p class="first">Connector property to control the
HDMI infoframe aspect ratio setting.</p>
<p class="last">The <code class="docutils literal"><span class="pre">DRM_MODE_PICTURE_ASPECT_</span></code>* values much match the
values for <code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">hdmi_picture_aspect</span></code></p>
</dd>
<dt><code class="docutils literal"><span class="pre">scaling_mode</span></code></dt>
<dd>Connector property to control the
upscaling, mostly used for built-in panels.</dd>
</dl>
<dl class="type">
<dt id="c.drm_connector_funcs">
struct <code class="descname">drm_connector_funcs</code><a class="headerlink" href="#c.drm_connector_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>control connectors on a given device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_connector_funcs {
  int (* dpms) (struct drm_connector *connector, int mode);
  void (* reset) (struct drm_connector *connector);
  enum drm_connector_status (* detect) (struct drm_connector *connector, bool force);
  void (* force) (struct drm_connector *connector);
  int (* fill_modes) (struct drm_connector *connector, uint32_t max_width, uint32_t max_height);
  int (* set_property) (struct drm_connector *connector, struct drm_property *property, uint64_t val);
  int (* late_register) (struct drm_connector *connector);
  void (* early_unregister) (struct drm_connector *connector);
  void (* destroy) (struct drm_connector *connector);
  struct drm_connector_state *(* atomic_duplicate_state) (struct drm_connector *connector);
  void (* atomic_destroy_state) (struct drm_connector *connector, struct drm_connector_state *state);
  int (* atomic_set_property) (struct drm_connector *connector,struct drm_connector_state *state,struct drm_property *property, uint64_t val);
  int (* atomic_get_property) (struct drm_connector *connector,const struct drm_connector_state *state,struct drm_property *property, uint64_t *val);
  void (* atomic_print_state) (struct drm_printer *p, const struct drm_connector_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dpms</span></code></dt>
<dd><p class="first">Legacy entry point to set the per-connector DPMS state. Legacy DPMS
is exposed as a standard property on the connector, but diverted to
this callback in the drm core. Note that atomic drivers don&#8217;t
implement the 4 level DPMS support on the connector any more, but
instead only have an on/off &#8220;ACTIVE&#8221; property on the CRTC object.</p>
<p>This hook is not used by atomic drivers, remapping of the legacy DPMS
property is entirely handled in the DRM core.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">reset</span></code></dt>
<dd><p class="first">Reset connector hardware and software state to off. This function isn&#8217;t
called by the core directly, only through <code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_reset()</span></code>.
It&#8217;s not a helper hook only for historical reasons.</p>
<p class="last">Atomic drivers can use <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_connector_reset()</span></code> to reset
atomic state using this hook.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">detect</span></code></dt>
<dd><p class="first">Check to see if anything is attached to the connector. The parameter
force is set to false whilst polling, true when checking the
connector due to a user request. force can be used by the driver to
avoid expensive, destructive operations during automated probing.</p>
<p>This callback is optional, if not implemented the connector will be
considered as always being attached.</p>
<p>FIXME:</p>
<p>Note that this hook is only called by the probe helper. It&#8217;s not in
the helper library vtable purely for historical reasons. The only DRM
core  entry point to probe connector state is <strong>fill_modes</strong>.</p>
<p>Note that the helper library will already hold
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connection_mutex</span></code></a>. Drivers which need to grab additional
locks to avoid races with concurrent modeset changes need to use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_helper_funcs.detect_ctx</span></code></a> instead.</p>
<p>RETURNS:</p>
<p class="last">drm_connector_status indicating the connector&#8217;s status.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">force</span></code></dt>
<dd><p class="first">This function is called to update internal encoder state when the
connector is forced to a certain state by userspace, either through
the sysfs interfaces or on the kernel cmdline. In that case the
<strong>detect</strong> callback isn&#8217;t called.</p>
<p>FIXME:</p>
<p class="last">Note that this hook is only called by the probe helper. It&#8217;s not in
the helper library vtable purely for historical reasons. The only DRM
core  entry point to probe connector state is <strong>fill_modes</strong>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">fill_modes</span></code></dt>
<dd><p class="first">Entry point for output detection and basic mode validation. The
driver should reprobe the output if needed (e.g. when hotplug
handling is unreliable), add all detected modes to <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>
and filter out any the device can&#8217;t support in any configuration. It
also needs to filter out any modes wider or higher than the
parameters max_width and max_height indicate.</p>
<p>The drivers must also prune any modes no longer valid from
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>. Furthermore it must update
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.status</span></code></a> and <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.edid</span></code></a>.  If no EDID has been
received for this output connector-&gt;edid must be NULL.</p>
<p>Drivers using the probe helpers should use
<code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes()</span></code> or
<code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes_nomerge()</span></code> to implement this
function.</p>
<p>RETURNS:</p>
<p class="last">The number of modes detected and filled into <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">set_property</span></code></dt>
<dd><p class="first">This is the legacy entry point to update a property attached to the
connector.</p>
<p>This callback is optional if the driver does not support any legacy
driver-private properties. For atomic drivers it is not used because
property handling is done entirely in the DRM core.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">late_register</span></code></dt>
<dd><p class="first">This optional hook can be used to register additional userspace
interfaces attached to the connector, light backlight control, i2c,
DP aux or similar interfaces. It is called late in the driver load
sequence from <code class="xref c c-func docutils literal"><span class="pre">drm_connector_register()</span></code> when registering all the
core drm connector interfaces. Everything added from this callback
should be unregistered in the early_unregister callback.</p>
<p>This is called while holding <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.mutex</span></code></a>.</p>
<p>Returns:</p>
<p class="last">0 on success, or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">early_unregister</span></code></dt>
<dd><p class="first">This optional hook should be used to unregister the additional
userspace interfaces attached to the connector from
<code class="xref c c-func docutils literal"><span class="pre">late_register()</span></code>. It is called from <code class="xref c c-func docutils literal"><span class="pre">drm_connector_unregister()</span></code>,
early in the driver unload sequence to disable userspace access
before data structures are torndown.</p>
<p class="last">This is called while holding <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">destroy</span></code></dt>
<dd>Clean up connector resources. This is called at driver unload time
through <code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code>. It can also be called at runtime
when a connector is being hot-unplugged for drivers that support
connector hotplugging (e.g. DisplayPort MST).</dd>
<dt><code class="docutils literal"><span class="pre">atomic_duplicate_state</span></code></dt>
<dd><p class="first">Duplicate the current atomic state for this connector and return it.
The core and helpers guarantee that any atomic state duplicated with
this hook and still owned by the caller (i.e. not transferred to the
driver by calling <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a>) will be
cleaned up by calling the <strong>atomic_destroy_state</strong> hook in this
structure.</p>
<p>Atomic drivers which don&#8217;t subclass <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> should use
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_connector_duplicate_state()</span></code>. Drivers that subclass the
state structure to extend it with driver-private state should use
<code class="xref c c-func docutils literal"><span class="pre">__drm_atomic_helper_connector_duplicate_state()</span></code> to make sure shared state is
duplicated in a consistent fashion across drivers.</p>
<p>It is an error to call this hook before <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.state</span></code></a> has been
initialized correctly.</p>
<p>NOTE:</p>
<p>If the duplicate state references refcounted resources this hook must
acquire a reference for each of them. The driver must release these
references again in <strong>atomic_destroy_state</strong>.</p>
<p>RETURNS:</p>
<p class="last">Duplicated atomic state or NULL when the allocation failed.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_destroy_state</span></code></dt>
<dd>Destroy a state duplicated with <strong>atomic_duplicate_state</strong> and release
or unreference all resources it references</dd>
<dt><code class="docutils literal"><span class="pre">atomic_set_property</span></code></dt>
<dd><p class="first">Decode a driver-private property value and store the decoded value
into the passed-in state structure. Since the atomic core decodes all
standardized properties (even for extensions beyond the core set of
properties which might not be implemented by all drivers) this
requires drivers to subclass the state structure.</p>
<p>Such driver-private properties should really only be implemented for
truly hardware/vendor specific state. Instead it is preferred to
standardize atomic extension and decode the properties used to expose
such an extension in the core.</p>
<p>Do not call this function directly, use
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_connector_set_property()</span></code> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>NOTE:</p>
<p>This function is called in the state assembly phase of atomic
modesets, which can be aborted for any reason (including on
userspace&#8217;s request to just check whether a configuration would be
possible). Drivers MUST NOT touch any persistent state (hardware or
software) or data structures except the passed in <strong>state</strong> parameter.</p>
<p>Also since userspace controls in which order properties are set this
function must not do any input validation (since the state update is
incomplete and hence likely inconsistent). Instead any such input
validation must be done in the various atomic_check callbacks.</p>
<p>RETURNS:</p>
<p class="last">0 if the property has been found, -EINVAL if the property isn&#8217;t
implemented by the driver (which shouldn&#8217;t ever happen, the core only
asks for properties attached to this connector). No other validation
is allowed by the driver. The core already checks that the property
value is within the range (integer, valid enum value, ...) the driver
set when registering the property.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_get_property</span></code></dt>
<dd><p class="first">Reads out the decoded driver-private property. This is used to
implement the GETCONNECTOR IOCTL.</p>
<p>Do not call this function directly, use
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_connector_get_property()</span></code> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the property isn&#8217;t implemented by the
driver (which shouldn&#8217;t ever happen, the core only asks for
properties attached to this connector).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_print_state</span></code></dt>
<dd><p class="first">If driver subclasses <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a>, it should implement
this optional hook for printing additional driver specific state.</p>
<p class="last">Do not call this directly, use <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_connector_print_state()</span></code>
instead.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each CRTC may have one or more connectors attached to it.  The functions
below allow the core DRM code to control connectors, enumerate available modes,
etc.</p>
<dl class="type">
<dt id="c.drm_connector">
struct <code class="descname">drm_connector</code><a class="headerlink" href="#c.drm_connector" title="Permalink to this definition">¶</a></dt>
<dd><p>central DRM connector control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_connector {
  struct drm_device * dev;
  struct device * kdev;
  struct device_attribute * attr;
  struct list_head head;
  struct drm_mode_object base;
  char * name;
  struct mutex mutex;
  unsigned index;
  int connector_type;
  int connector_type_id;
  bool interlace_allowed;
  bool doublescan_allowed;
  bool stereo_allowed;
  bool ycbcr_420_allowed;
  bool registered;
  struct list_head modes;
  enum drm_connector_status status;
  struct list_head probed_modes;
  struct drm_display_info display_info;
  const struct drm_connector_funcs * funcs;
  struct drm_property_blob * edid_blob_ptr;
  struct drm_object_properties properties;
  struct drm_property * scaling_mode_property;
  struct drm_property_blob * path_blob_ptr;
  struct drm_property_blob * tile_blob_ptr;
#define DRM_CONNECTOR_POLL_HPD (1 \\\lt;\\\lt; 0
#define DRM_CONNECTOR_POLL_CONNECT (1 \\\lt;\\\lt; 1
#define DRM_CONNECTOR_POLL_DISCONNECT (1 \\\lt;\\\lt; 2
  uint8_t polled;
  int dpms;
  const struct drm_connector_helper_funcs * helper_private;
  struct drm_cmdline_mode cmdline_mode;
  enum drm_connector_force force;
  bool override_edid;
#define DRM_CONNECTOR_MAX_ENCODER 3
  uint32_t encoder_ids;
  struct drm_encoder * encoder;
#define MAX_ELD_BYTES 128
  uint8_t eld;
  bool latency_present;
  int video_latency;
  int audio_latency;
  int null_edid_counter;
  unsigned bad_edid_counter;
  bool edid_corrupt;
  struct dentry * debugfs_entry;
  struct drm_connector_state * state;
  bool has_tile;
  struct drm_tile_group * tile_group;
  bool tile_is_single_monitor;
  uint8_t num_h_tile;
  uint8_t num_v_tile;
  uint8_t tile_h_loc;
  uint8_t tile_v_loc;
  uint16_t tile_h_size;
  uint16_t tile_v_size;
  struct llist_node free_node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>parent DRM device</dd>
<dt><code class="docutils literal"><span class="pre">kdev</span></code></dt>
<dd>kernel device for sysfs attributes</dd>
<dt><code class="docutils literal"><span class="pre">attr</span></code></dt>
<dd>sysfs attributes</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>list management</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base KMS object</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>human readable name, can be overwritten by the driver</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd>Lock for general connector state, but currently only protects
<strong>registered</strong>. Most of the connector state is still protected by
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>Compacted connector index, which matches the position inside
the mode_config.list for drivers not supporting hot-add/removing. Can
be used as an array index. It is invariant over the lifetime of the
connector.</dd>
<dt><code class="docutils literal"><span class="pre">connector_type</span></code></dt>
<dd>one of the DRM_MODE_CONNECTOR_&lt;foo&gt; types from drm_mode.h</dd>
<dt><code class="docutils literal"><span class="pre">connector_type_id</span></code></dt>
<dd>index into connector type enum</dd>
<dt><code class="docutils literal"><span class="pre">interlace_allowed</span></code></dt>
<dd>can this connector handle interlaced modes?</dd>
<dt><code class="docutils literal"><span class="pre">doublescan_allowed</span></code></dt>
<dd>can this connector handle doublescan?</dd>
<dt><code class="docutils literal"><span class="pre">stereo_allowed</span></code></dt>
<dd>can this connector handle stereo modes?</dd>
<dt><code class="docutils literal"><span class="pre">ycbcr_420_allowed</span></code></dt>
<dd>This bool indicates if this connector is
capable of handling YCBCR 420 output. While parsing the EDID
blocks, its very helpful to know, if the source is capable of
handling YCBCR 420 outputs.</dd>
<dt><code class="docutils literal"><span class="pre">registered</span></code></dt>
<dd>Is this connector exposed (registered) with userspace?
Protected by <strong>mutex</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">modes</span></code></dt>
<dd>Modes available on this connector (from <code class="xref c c-func docutils literal"><span class="pre">fill_modes()</span></code> + user).
Protected by <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">status</span></code></dt>
<dd>One of the drm_connector_status enums (connected, not, or unknown).
Protected by <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">probed_modes</span></code></dt>
<dd>These are modes added by probing with DDC or the BIOS, before
filtering is applied. Used by the probe helpers. Protected by
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">display_info</span></code></dt>
<dd><p class="first">Display information is filled from EDID information
when a display is detected. For non hot-pluggable displays such as
flat panels in embedded systems, the driver should initialize the
<a class="reference internal" href="#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal"><span class="pre">drm_display_info.width_mm</span></code></a> and <a class="reference internal" href="#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal"><span class="pre">drm_display_info.height_mm</span></code></a> fields
with the physical size of the display.</p>
<p class="last">Protected by <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>connector control functions</dd>
<dt><code class="docutils literal"><span class="pre">edid_blob_ptr</span></code></dt>
<dd>DRM property containing EDID if present</dd>
<dt><code class="docutils literal"><span class="pre">properties</span></code></dt>
<dd>property tracking for this connector</dd>
<dt><code class="docutils literal"><span class="pre">scaling_mode_property</span></code></dt>
<dd>Optional atomic property to control the upscaling.</dd>
<dt><code class="docutils literal"><span class="pre">path_blob_ptr</span></code></dt>
<dd>DRM blob property data for the DP MST path property.</dd>
<dt><code class="docutils literal"><span class="pre">tile_blob_ptr</span></code></dt>
<dd>DRM blob property data for the tile property (used mostly by DP MST).
This is meant for screens which are driven through separate display
pipelines represented by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>, which might not be running with
genlocked clocks. For tiled panels which are genlocked, like
dual-link LVDS or dual-link DSI, the driver should try to not expose
the tiling and virtualize both <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a> if needed.</dd>
<dt><code class="docutils literal"><span class="pre">polled</span></code></dt>
<dd><p class="first">Connector polling mode, a combination of</p>
<dl class="docutils">
<dt>DRM_CONNECTOR_POLL_HPD</dt>
<dd>The connector generates hotplug events and doesn&#8217;t need to be
periodically polled. The CONNECT and DISCONNECT flags must not
be set together with the HPD flag.</dd>
<dt>DRM_CONNECTOR_POLL_CONNECT</dt>
<dd>Periodically poll the connector for connection.</dd>
<dt>DRM_CONNECTOR_POLL_DISCONNECT</dt>
<dd>Periodically poll the connector for disconnection.</dd>
</dl>
<p class="last">Set to 0 for connectors that don&#8217;t support connection status
discovery.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">dpms</span></code></dt>
<dd>current dpms state</dd>
<dt><code class="docutils literal"><span class="pre">helper_private</span></code></dt>
<dd>mid-layer private data</dd>
<dt><code class="docutils literal"><span class="pre">cmdline_mode</span></code></dt>
<dd>mode line parsed from the kernel cmdline for this connector</dd>
<dt><code class="docutils literal"><span class="pre">force</span></code></dt>
<dd>a DRM_FORCE_&lt;foo&gt; state for forced mode sets</dd>
<dt><code class="docutils literal"><span class="pre">override_edid</span></code></dt>
<dd>has the EDID been overwritten through debugfs for testing?</dd>
<dt><code class="docutils literal"><span class="pre">encoder_ids</span></code></dt>
<dd>valid encoders for this connector</dd>
<dt><code class="docutils literal"><span class="pre">encoder</span></code></dt>
<dd>encoder driving this connector, if any</dd>
<dt><code class="docutils literal"><span class="pre">eld</span></code></dt>
<dd>EDID-like data, if present</dd>
<dt><code class="docutils literal"><span class="pre">latency_present</span></code></dt>
<dd>AV delay info from ELD, if found</dd>
<dt><code class="docutils literal"><span class="pre">video_latency</span></code></dt>
<dd>video latency info from ELD, if found</dd>
<dt><code class="docutils literal"><span class="pre">audio_latency</span></code></dt>
<dd>audio latency info from ELD, if found</dd>
<dt><code class="docutils literal"><span class="pre">null_edid_counter</span></code></dt>
<dd>track sinks that give us all zeros for the EDID</dd>
<dt><code class="docutils literal"><span class="pre">bad_edid_counter</span></code></dt>
<dd>track sinks that give us an EDID with invalid checksum</dd>
<dt><code class="docutils literal"><span class="pre">edid_corrupt</span></code></dt>
<dd>indicates whether the last read EDID was corrupt</dd>
<dt><code class="docutils literal"><span class="pre">debugfs_entry</span></code></dt>
<dd>debugfs directory for this connector</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd><p class="first">Current atomic state for this connector.</p>
<p class="last">This is protected by <strong>drm_mode_config</strong>.connection_mutex. Note that
nonblocking atomic commits access the current connector state without
taking locks. Either by going through the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a>
pointers, see <a class="reference internal" href="#c.for_each_oldnew_connector_in_state" title="for_each_oldnew_connector_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_oldnew_connector_in_state()</span></code></a>,
<a class="reference internal" href="#c.for_each_old_connector_in_state" title="for_each_old_connector_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_old_connector_in_state()</span></code></a> and
<a class="reference internal" href="#c.for_each_new_connector_in_state" title="for_each_new_connector_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_new_connector_in_state()</span></code></a>. Or through careful ordering of
atomic commit operations as implemented in the atomic helpers, see
<a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">has_tile</span></code></dt>
<dd>is this connector connected to a tiled monitor</dd>
<dt><code class="docutils literal"><span class="pre">tile_group</span></code></dt>
<dd>tile group for the connected monitor</dd>
<dt><code class="docutils literal"><span class="pre">tile_is_single_monitor</span></code></dt>
<dd>whether the tile is one monitor housing</dd>
<dt><code class="docutils literal"><span class="pre">num_h_tile</span></code></dt>
<dd>number of horizontal tiles in the tile group</dd>
<dt><code class="docutils literal"><span class="pre">num_v_tile</span></code></dt>
<dd>number of vertical tiles in the tile group</dd>
<dt><code class="docutils literal"><span class="pre">tile_h_loc</span></code></dt>
<dd>horizontal location of this tile</dd>
<dt><code class="docutils literal"><span class="pre">tile_v_loc</span></code></dt>
<dd>vertical location of this tile</dd>
<dt><code class="docutils literal"><span class="pre">tile_h_size</span></code></dt>
<dd>horizontal size of this tile.</dd>
<dt><code class="docutils literal"><span class="pre">tile_v_size</span></code></dt>
<dd>vertical size of this tile.</dd>
<dt><code class="docutils literal"><span class="pre">free_node</span></code></dt>
<dd>List used only by <code class="xref c c-type docutils literal"><span class="pre">drm_connector_iter</span></code> to be able to clean up a
connector from any context, in conjunction with
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connector_free_work</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each connector may be connected to one or more CRTCs, or may be clonable by
another connector if they can share a CRTC.  Each connector also has a specific
position in the broader display (referred to as a &#8216;screen&#8217; though it could
span multiple monitors).</p>
<dl class="function">
<dt id="c.drm_connector_lookup">
struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> * <code class="descname">drm_connector_lookup</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup connector object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>drm file to check for lease against.</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>connector object id</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function looks up the connector object specified by id
add takes a reference to it.</p>
<dl class="function">
<dt id="c.drm_connector_get">
void <code class="descname">drm_connector_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_get" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a connector reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>DRM connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function increments the connector&#8217;s refcount.</p>
<dl class="function">
<dt id="c.drm_connector_put">
void <code class="descname">drm_connector_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a connector reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>DRM connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function decrements the connector&#8217;s reference count and frees the
object if the reference count drops to zero.</p>
<dl class="function">
<dt id="c.drm_connector_reference">
void <code class="descname">drm_connector_reference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a connector reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>DRM connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_connector_get" title="drm_connector_get"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_get()</span></code></a> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_connector_unreference">
void <code class="descname">drm_connector_unreference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_unreference" title="Permalink to this definition">¶</a></dt>
<dd><p>release a connector reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>DRM connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_connector_put" title="drm_connector_put"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_put()</span></code></a> and should not be
used by new code.</p>
<dl class="type">
<dt id="c.drm_tile_group">
struct <code class="descname">drm_tile_group</code><a class="headerlink" href="#c.drm_tile_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Tile group metadata</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_tile_group {
  struct kref refcount;
  struct drm_device * dev;
  int id;
  u8 group_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd>reference count</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>tile group id exposed to userspace</dd>
<dt><code class="docutils literal"><span class="pre">group_data</span></code></dt>
<dd>Sink-private data identifying this group</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>group_data</strong> corresponds to displayid vend/prod/serial for external screens
with an EDID.</p>
<dl class="type">
<dt id="c.drm_connector_list_iter">
struct <code class="descname">drm_connector_list_iter</code><a class="headerlink" href="#c.drm_connector_list_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>connector_list iterator</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_connector_list_iter {
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<p><strong>Description</strong></p>
<p>This iterator tracks state needed to be able to walk the connector_list
within struct drm_mode_config. Only use together with
<code class="xref c c-func docutils literal"><span class="pre">drm_connector_list_iter_begin()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">drm_connector_list_iter_end()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">drm_connector_list_iter_next()</span></code> respectively the convenience macro
<a class="reference internal" href="#c.drm_for_each_connector_iter" title="drm_for_each_connector_iter"><code class="xref c c-func docutils literal"><span class="pre">drm_for_each_connector_iter()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_for_each_connector_iter">
<code class="descname">drm_for_each_connector_iter</code><span class="sig-paren">(</span><em>connector</em>, <em>iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_connector_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>connector_list iterator macro</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> pointer used as cursor</dd>
<dt><code class="docutils literal"><span class="pre">iter</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that <strong>connector</strong> is only valid within the list body, if you want to use
<strong>connector</strong> after calling <code class="xref c c-func docutils literal"><span class="pre">drm_connector_list_iter_end()</span></code> then you need to grab
your own reference first using <a class="reference internal" href="#c.drm_connector_get" title="drm_connector_get"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_get()</span></code></a>.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
</div>
<div class="section" id="encoder-abstraction">
<h2>Encoder Abstraction<a class="headerlink" href="#encoder-abstraction" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="section" id="encoder-functions-reference">
<h3>Encoder Functions Reference<a class="headerlink" href="#encoder-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_encoder_funcs">
struct <code class="descname">drm_encoder_funcs</code><a class="headerlink" href="#c.drm_encoder_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>encoder controls</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_encoder_funcs {
  void (* reset) (struct drm_encoder *encoder);
  void (* destroy) (struct drm_encoder *encoder);
  int (* late_register) (struct drm_encoder *encoder);
  void (* early_unregister) (struct drm_encoder *encoder);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">reset</span></code></dt>
<dd>Reset encoder hardware and software state to off. This function isn&#8217;t
called by the core directly, only through <code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_reset()</span></code>.
It&#8217;s not a helper hook only for historical reasons.</dd>
<dt><code class="docutils literal"><span class="pre">destroy</span></code></dt>
<dd>Clean up encoder resources. This is only called at driver unload time
through <code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code> since an encoder cannot be
hotplugged in DRM.</dd>
<dt><code class="docutils literal"><span class="pre">late_register</span></code></dt>
<dd><p class="first">This optional hook can be used to register additional userspace
interfaces attached to the encoder like debugfs interfaces.
It is called late in the driver load sequence from <code class="xref c c-func docutils literal"><span class="pre">drm_dev_register()</span></code>.
Everything added from this callback should be unregistered in
the early_unregister callback.</p>
<p>Returns:</p>
<p class="last">0 on success, or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">early_unregister</span></code></dt>
<dd>This optional hook should be used to unregister the additional
userspace interfaces attached to the encoder from
<strong>late_register</strong>. It is called from <code class="xref c c-func docutils literal"><span class="pre">drm_dev_unregister()</span></code>,
early in the driver unload sequence to disable userspace access
before data structures are torndown.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Encoders sit between CRTCs and connectors.</p>
<dl class="type">
<dt id="c.drm_encoder">
struct <code class="descname">drm_encoder</code><a class="headerlink" href="#c.drm_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>central DRM encoder structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_encoder {
  struct drm_device * dev;
  struct list_head head;
  struct drm_mode_object base;
  char * name;
  int encoder_type;
  unsigned index;
  uint32_t possible_crtcs;
  uint32_t possible_clones;
  struct drm_crtc * crtc;
  struct drm_bridge * bridge;
  const struct drm_encoder_funcs * funcs;
  const struct drm_encoder_helper_funcs * helper_private;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>parent DRM device</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>list management</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base KMS object</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>human readable name, can be overwritten by the driver</dd>
<dt><code class="docutils literal"><span class="pre">encoder_type</span></code></dt>
<dd><p class="first">One of the DRM_MODE_ENCODER_&lt;foo&gt; types in drm_mode.h. The following
encoder types are defined thus far:</p>
<ul class="last simple">
<li>DRM_MODE_ENCODER_DAC for VGA and analog on DVI-I/DVI-A.</li>
<li>DRM_MODE_ENCODER_TMDS for DVI, HDMI and (embedded) DisplayPort.</li>
<li>DRM_MODE_ENCODER_LVDS for display panels, or in general any panel
with a proprietary parallel connector.</li>
<li>DRM_MODE_ENCODER_TVDAC for TV output (Composite, S-Video,
Component, SCART).</li>
<li>DRM_MODE_ENCODER_VIRTUAL for virtual machine displays</li>
<li>DRM_MODE_ENCODER_DSI for panels connected using the DSI serial bus.</li>
<li>DRM_MODE_ENCODER_DPI for panels connected using the DPI parallel
bus.</li>
<li>DRM_MODE_ENCODER_DPMST for special fake encoders used to allow
mutliple DP MST streams to share one physical encoder.</li>
</ul>
</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>Position inside the mode_config.list, can be used as an array
index. It is invariant over the lifetime of the encoder.</dd>
<dt><code class="docutils literal"><span class="pre">possible_crtcs</span></code></dt>
<dd><p class="first">Bitmask of potential CRTC bindings, using
<a class="reference internal" href="#c.drm_crtc_index" title="drm_crtc_index"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_index()</span></code></a> as the index into the bitfield. The driver must set
the bits for all <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> objects this encoder can be connected to
before calling <code class="xref c c-func docutils literal"><span class="pre">drm_encoder_init()</span></code>.</p>
<p>In reality almost every driver gets this wrong.</p>
<p class="last">Note that since CRTC objects can&#8217;t be hotplugged the assigned indices
are stable and hence known before registering all objects.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">possible_clones</span></code></dt>
<dd><p class="first">Bitmask of potential sibling encoders for cloning,
using <a class="reference internal" href="#c.drm_encoder_index" title="drm_encoder_index"><code class="xref c c-func docutils literal"><span class="pre">drm_encoder_index()</span></code></a> as the index into the bitfield. The driver
must set the bits for all <a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a> objects which can clone a
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> together with this encoder before calling
<code class="xref c c-func docutils literal"><span class="pre">drm_encoder_init()</span></code>. Drivers should set the bit representing the
encoder itself, too. Cloning bits should be set such that when two
encoders can be used in a cloned configuration, they both should have
each another bits set.</p>
<p>In reality almost every driver gets this wrong.</p>
<p class="last">Note that since encoder objects can&#8217;t be hotplugged the assigned indices
are stable and hence known before registering all objects.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>currently bound CRTC</dd>
<dt><code class="docutils literal"><span class="pre">bridge</span></code></dt>
<dd>bridge associated to the encoder</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>control functions</dd>
<dt><code class="docutils literal"><span class="pre">helper_private</span></code></dt>
<dd>mid-layer private data</dd>
</dl>
<p><strong>Description</strong></p>
<p>CRTCs drive pixels to encoders, which convert them into signals
appropriate for a given connector or set of connectors.</p>
<dl class="function">
<dt id="c.drm_encoder_index">
unsigned int <code class="descname">drm_encoder_index</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find the index of a registered encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>encoder to find index for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered encoder, return the index of that encoder within a DRM
device&#8217;s list of encoders.</p>
<dl class="function">
<dt id="c.drm_encoder_crtc_ok">
bool <code class="descname">drm_encoder_crtc_ok</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_crtc_ok" title="Permalink to this definition">¶</a></dt>
<dd><p>can a given crtc drive a given encoder?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>encoder to test</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to test</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns false if <strong>encoder</strong> can&#8217;t be driven by <strong>crtc</strong>, true otherwise.</p>
<dl class="function">
<dt id="c.drm_encoder_find">
struct <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> * <code class="descname">drm_encoder_find</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_find" title="Permalink to this definition">¶</a></dt>
<dd><p>find a <a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>drm file to check for lease against.</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>encoder id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the encoder with <strong>id</strong>, NULL if it doesn&#8217;t exist. Simple wrapper around
<code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_find()</span></code>.</p>
<dl class="function">
<dt id="c.drm_for_each_encoder_mask">
<code class="descname">drm_for_each_encoder_mask</code><span class="sig-paren">(</span><em>encoder</em>, <em>dev</em>, <em>encoder_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_encoder_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over encoders specified by bitmask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">encoder</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the DRM device</dd>
<dt><code class="docutils literal"><span class="pre">encoder_mask</span></code></dt>
<dd>bitmask of encoder indices</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all encoders specified by bitmask.</p>
<dl class="function">
<dt id="c.drm_for_each_encoder">
<code class="descname">drm_for_each_encoder</code><span class="sig-paren">(</span><em>encoder</em>, <em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all encoders</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">encoder</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all encoders of <strong>dev</strong>.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
</div>
<div class="section" id="kms-initialization-and-cleanup">
<h2>KMS Initialization and Cleanup<a class="headerlink" href="#kms-initialization-and-cleanup" title="Permalink to this headline">¶</a></h2>
<p>A KMS device is abstracted and exposed as a set of planes, CRTCs,
encoders and connectors. KMS drivers must thus create and initialize all
those objects at load time after initializing mode setting.</p>
<div class="section" id="crtcs-struct-drm-crtc">
<h3>CRTCs (<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>)<a class="headerlink" href="#crtcs-struct-drm-crtc" title="Permalink to this headline">¶</a></h3>
<p>A CRTC is an abstraction representing a part of the chip that contains a
pointer to a scanout buffer. Therefore, the number of CRTCs available
determines how many independent scanout buffers can be active at any
given time. The CRTC structure contains several fields to support this:
a pointer to some video memory (abstracted as a frame buffer object), a
display mode, and an (x, y) offset into the video memory to support
panning or configurations where one piece of video memory spans multiple
CRTCs.</p>
<div class="section" id="crtc-initialization">
<h4>CRTC Initialization<a class="headerlink" href="#crtc-initialization" title="Permalink to this headline">¶</a></h4>
<p>A KMS device must create and register at least one struct
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> instance. The instance is
allocated and zeroed by the driver, possibly as part of a larger
structure, and registered with a call to <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init()</span></code>
with a pointer to CRTC functions.</p>
</div>
</div>
<div class="section" id="cleanup">
<h3>Cleanup<a class="headerlink" href="#cleanup" title="Permalink to this headline">¶</a></h3>
<p>The DRM core manages its objects&#8217; lifetime. When an object is not needed
anymore the core calls its destroy function, which must clean up and
free every resource allocated for the object. Every
<code class="xref c c-func docutils literal"><span class="pre">drm_*_init()</span></code> call must be matched with a corresponding
<code class="xref c c-func docutils literal"><span class="pre">drm_*_cleanup()</span></code> call to cleanup CRTCs
(<code class="xref c c-func docutils literal"><span class="pre">drm_crtc_cleanup()</span></code>), planes
(<code class="xref c c-func docutils literal"><span class="pre">drm_plane_cleanup()</span></code>), encoders
(<code class="xref c c-func docutils literal"><span class="pre">drm_encoder_cleanup()</span></code>) and connectors
(<code class="xref c c-func docutils literal"><span class="pre">drm_connector_cleanup()</span></code>). Furthermore, connectors that
have been added to sysfs must be removed by a call to
<code class="xref c c-func docutils literal"><span class="pre">drm_connector_unregister()</span></code> before calling
<code class="xref c c-func docutils literal"><span class="pre">drm_connector_cleanup()</span></code>.</p>
<p>Connectors state change detection must be cleanup up with a call to
<code class="xref c c-func docutils literal"><span class="pre">drm_kms_helper_poll_fini()</span></code>.</p>
</div>
<div class="section" id="output-discovery-and-initialization-example">
<h3>Output discovery and initialization example<a class="headerlink" href="#output-discovery-and-initialization-example" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">intel_crt_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">intel_output</span> <span class="o">*</span><span class="n">intel_output</span><span class="p">;</span>

    <span class="n">intel_output</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_output</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intel_output</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">connector</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
    <span class="n">drm_connector_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
               <span class="o">&amp;</span><span class="n">intel_crt_connector_funcs</span><span class="p">,</span> <span class="n">DRM_MODE_CONNECTOR_VGA</span><span class="p">);</span>

    <span class="n">drm_encoder_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">enc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intel_crt_enc_funcs</span><span class="p">,</span>
             <span class="n">DRM_MODE_ENCODER_DAC</span><span class="p">);</span>

    <span class="n">drm_mode_connector_attach_encoder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
                      <span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">enc</span><span class="p">);</span>

    <span class="cm">/* Set up the DDC bus. */</span>
    <span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">ddc_bus</span> <span class="o">=</span> <span class="n">intel_i2c_create</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">GPIOA</span><span class="p">,</span> <span class="s">&quot;CRTDDC_A&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">ddc_bus</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DDC bus registration &quot;</span>
               <span class="s">&quot;failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">INTEL_OUTPUT_ANALOG</span><span class="p">;</span>
    <span class="n">connector</span><span class="o">-&gt;</span><span class="n">interlace_allowed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">connector</span><span class="o">-&gt;</span><span class="n">doublescan_allowed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">drm_encoder_helper_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">enc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intel_crt_helper_funcs</span><span class="p">);</span>
    <span class="n">drm_connector_helper_add</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intel_crt_connector_helper_funcs</span><span class="p">);</span>

    <span class="n">drm_connector_register</span><span class="p">(</span><span class="n">connector</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the example above (taken from the i915 driver), a CRTC, connector and
encoder combination is created. A device-specific i2c bus is also
created for fetching EDID data and performing monitor detection. Once
the process is complete, the new connector is registered with sysfs to
make its properties available to applications.</p>
</div>
</div>
<div class="section" id="kms-locking">
<h2>KMS Locking<a class="headerlink" href="#kms-locking" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<dl class="type">
<dt id="c.drm_modeset_acquire_ctx">
struct <code class="descname">drm_modeset_acquire_ctx</code><a class="headerlink" href="#c.drm_modeset_acquire_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>locking context (see ww_acquire_ctx)</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_modeset_acquire_ctx {
  struct ww_acquire_ctx ww_ctx;
  struct drm_modeset_lock * contended;
  struct list_head locked;
  bool trylock_only;
  bool interruptible;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ww_ctx</span></code></dt>
<dd>base acquire ctx</dd>
<dt><code class="docutils literal"><span class="pre">contended</span></code></dt>
<dd>used internally for -EDEADLK handling</dd>
<dt><code class="docutils literal"><span class="pre">locked</span></code></dt>
<dd>list of held locks</dd>
<dt><code class="docutils literal"><span class="pre">trylock_only</span></code></dt>
<dd>trylock mode used in atomic contexts/panic notifiers</dd>
<dt><code class="docutils literal"><span class="pre">interruptible</span></code></dt>
<dd>whether interruptible locking should be used.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each thread competing for a set of locks must use one acquire
ctx.  And if any lock fxn returns -EDEADLK, it must backoff and
retry.</p>
<dl class="type">
<dt id="c.drm_modeset_lock">
struct <code class="descname">drm_modeset_lock</code><a class="headerlink" href="#c.drm_modeset_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>used for locking modeset resources.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_modeset_lock {
  struct ww_mutex mutex;
  struct list_head head;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd>resource locking</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>used to hold it&#8217;s place on <code class="xref c c-type docutils literal"><span class="pre">drm_atomi_state.locked</span></code> list when
part of an atomic update</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used for locking CRTCs and other modeset resources.</p>
<dl class="function">
<dt id="c.drm_modeset_lock_fini">
void <code class="descname">drm_modeset_lock_fini</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_lock_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>lock to cleanup</dd>
</dl>
<dl class="function">
<dt id="c.drm_modeset_is_locked">
bool <code class="descname">drm_modeset_is_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_is_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>equivalent to <a class="reference internal" href="../kernel-hacking/locking.html#c.mutex_is_locked" title="mutex_is_locked"><code class="xref c c-func docutils literal"><span class="pre">mutex_is_locked()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>lock to check</dd>
</dl>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="kms-properties">
<h2>KMS Properties<a class="headerlink" href="#kms-properties" title="Permalink to this headline">¶</a></h2>
<div class="section" id="property-types-and-blob-property-support">
<h3>Property Types and Blob Property Support<a class="headerlink" href="#property-types-and-blob-property-support" title="Permalink to this headline">¶</a></h3>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<dl class="type">
<dt id="c.drm_property_enum">
struct <code class="descname">drm_property_enum</code><a class="headerlink" href="#c.drm_property_enum" title="Permalink to this definition">¶</a></dt>
<dd><p>symbolic values for enumerations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_property_enum {
  uint64_t value;
  struct list_head head;
  char name;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">value</span></code></dt>
<dd>numeric property value for this enum entry</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>list of enum values, linked to <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property.enum_list</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>symbolic name for the enum</dd>
</dl>
<p><strong>Description</strong></p>
<p>For enumeration and bitmask properties this structure stores the symbolic
decoding for each value. This is used for example for the rotation property.</p>
<dl class="type">
<dt id="c.drm_property">
struct <code class="descname">drm_property</code><a class="headerlink" href="#c.drm_property" title="Permalink to this definition">¶</a></dt>
<dd><p>modeset object property</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_property {
  struct list_head head;
  struct drm_mode_object base;
  uint32_t flags;
  char name;
  uint32_t num_values;
  uint64_t * values;
  struct drm_device * dev;
  struct list_head enum_list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>per-device list of properties, for cleanup.</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base KMS object</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd><p class="first">Property flags and type. A property needs to be one of the following
types:</p>
<dl class="docutils">
<dt>DRM_MODE_PROP_RANGE</dt>
<dd>Range properties report their minimum and maximum admissible unsigned values.
The KMS core verifies that values set by application fit in that
range. The range is unsigned. Range properties are created using
<code class="xref c c-func docutils literal"><span class="pre">drm_property_create_range()</span></code>.</dd>
<dt>DRM_MODE_PROP_SIGNED_RANGE</dt>
<dd>Range properties report their minimum and maximum admissible unsigned values.
The KMS core verifies that values set by application fit in that
range. The range is signed. Range properties are created using
<code class="xref c c-func docutils literal"><span class="pre">drm_property_create_signed_range()</span></code>.</dd>
<dt>DRM_MODE_PROP_ENUM</dt>
<dd>Enumerated properties take a numerical value that ranges from 0 to
the number of enumerated values defined by the property minus one,
and associate a free-formed string name to each value. Applications
can retrieve the list of defined value-name pairs and use the
numerical value to get and set property instance values. Enum
properties are created using <code class="xref c c-func docutils literal"><span class="pre">drm_property_create_enum()</span></code>.</dd>
<dt>DRM_MODE_PROP_BITMASK</dt>
<dd>Bitmask properties are enumeration properties that additionally
restrict all enumerated values to the 0..63 range. Bitmask property
instance values combine one or more of the enumerated bits defined
by the property. Bitmask properties are created using
<code class="xref c c-func docutils literal"><span class="pre">drm_property_create_bitmask()</span></code>.</dd>
<dt>DRM_MODE_PROB_OBJECT</dt>
<dd><p class="first">Object properties are used to link modeset objects. This is used
extensively in the atomic support to create the display pipeline,
by linking <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a> to <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a>, <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a> to
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a> to <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>. An object property can
only link to a specific type of <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_object</span></code></a>, this limit is
enforced by the core. Object properties are created using
<code class="xref c c-func docutils literal"><span class="pre">drm_property_create_object()</span></code>.</p>
<p class="last">Object properties work like blob properties, but in a more
general fashion. They are limited to atomic drivers and must have
the DRM_MODE_PROP_ATOMIC flag set.</p>
</dd>
<dt>DRM_MODE_PROP_BLOB</dt>
<dd><p class="first">Blob properties store a binary blob without any format restriction.
The binary blobs are created as KMS standalone objects, and blob
property instance values store the ID of their associated blob
object. Blob properties are created by calling
<code class="xref c c-func docutils literal"><span class="pre">drm_property_create()</span></code> with DRM_MODE_PROP_BLOB as the type.</p>
<p>Actual blob objects to contain blob data are created using
<code class="xref c c-func docutils literal"><span class="pre">drm_property_create_blob()</span></code>, or through the corresponding IOCTL.</p>
<p class="last">Besides the built-in limit to only accept blob objects blob
properties work exactly like object properties. The only reasons
blob properties exist is backwards compatibility with existing
userspace.</p>
</dd>
</dl>
<p>In addition a property can have any combination of the below flags:</p>
<dl class="last docutils">
<dt>DRM_MODE_PROP_ATOMIC</dt>
<dd>Set for properties which encode atomic modeset state. Such
properties are not exposed to legacy userspace.</dd>
<dt>DRM_MODE_PROP_IMMUTABLE</dt>
<dd>Set for properties where userspace cannot be changed by
userspace. The kernel is allowed to update the value of these
properties. This is generally used to expose probe state to
usersapce, e.g. the EDID, or the connector path property on DP
MST sinks.</dd>
</dl>
</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>symbolic name of the properties</dd>
<dt><code class="docutils literal"><span class="pre">num_values</span></code></dt>
<dd>size of the <strong>values</strong> array.</dd>
<dt><code class="docutils literal"><span class="pre">values</span></code></dt>
<dd>Array with limits and values for the property. The
interpretation of these limits is dependent upon the type per <strong>flags</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">enum_list</span></code></dt>
<dd>List of <code class="xref c c-type docutils literal"><span class="pre">drm_prop_enum_list</span></code> structures with the symbolic names for
enum and bitmask values.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represent a modeset object property. It combines both the name
of the property with the set of permissible values. This means that when a
driver wants to use a property with the same name on different objects, but
with different value ranges, then it must create property for each one. An
example would be rotation of <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a>, when e.g. the primary plane cannot
be rotated. But if both the name and the value range match, then the same
property structure can be instantiated multiple times for the same object.
Userspace must be able to cope with this and cannot assume that the same
symbolic property will have the same modeset object ID on all modeset
objects.</p>
<p>Properties are created by one of the special functions, as explained in
detail in the <strong>flags</strong> structure member.</p>
<p>To actually expose a property it must be attached to each object using
<code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code>. Currently properties can only be attached to
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a>, <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a>.</p>
<p>Properties are also used as the generic metadatatransport for the atomic
IOCTL. Everything that was set directly in structures in the legacy modeset
IOCTLs (like the plane source or destination windows, or e.g. the links to
the CRTC) is exposed as a property with the DRM_MODE_PROP_ATOMIC flag set.</p>
<dl class="type">
<dt id="c.drm_property_blob">
struct <code class="descname">drm_property_blob</code><a class="headerlink" href="#c.drm_property_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>Blob data for <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property</span></code></a></p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_property_blob {
  struct drm_mode_object base;
  struct drm_device * dev;
  struct list_head head_global;
  struct list_head head_file;
  size_t length;
  unsigned char data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base KMS object</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">head_global</span></code></dt>
<dd>entry on the global blob list in
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.property_blob_list</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">head_file</span></code></dt>
<dd>entry on the per-file blob list in <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.blobs</span></code></a> list.</dd>
<dt><code class="docutils literal"><span class="pre">length</span></code></dt>
<dd>size of the blob in bytes, invariant over the lifetime of the object</dd>
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>actual data, embedded at the end of this structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Blobs are used to store bigger values than what fits directly into the 64
bits available for a <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property</span></code></a>.</p>
<p>Blobs are reference counted using <code class="xref c c-func docutils literal"><span class="pre">drm_property_blob_get()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">drm_property_blob_put()</span></code>. They are created using <code class="xref c c-func docutils literal"><span class="pre">drm_property_create_blob()</span></code>.</p>
<dl class="function">
<dt id="c.drm_property_type_is">
bool <code class="descname">drm_property_type_is</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint32_t<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_type_is" title="Permalink to this definition">¶</a></dt>
<dd><p>check the type of a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>property to check</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">type</span></code></dt>
<dd>property type to compare with</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a helper function becauase the uapi encoding of property types is
a bit special for historical reasons.</p>
<dl class="function">
<dt id="c.drm_property_reference_blob">
struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> * <code class="descname">drm_property_reference_blob</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<em>&nbsp;blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_reference_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a blob property reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*</span> <span class="pre">blob</span></code></dt>
<dd>DRM blob property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <code class="xref c c-func docutils literal"><span class="pre">drm_property_blob_get()</span></code> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_property_unreference_blob">
void <code class="descname">drm_property_unreference_blob</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<em>&nbsp;blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_unreference_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>release a blob property reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*</span> <span class="pre">blob</span></code></dt>
<dd>DRM blob property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <code class="xref c c-func docutils literal"><span class="pre">drm_property_blob_put()</span></code> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_property_find">
struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> * <code class="descname">drm_property_find</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_find" title="Permalink to this definition">¶</a></dt>
<dd><p>find property object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>drm file to check for lease against.</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>property object id</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function looks up the property object specified by id and returns it.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="standard-connector-properties">
<h3>Standard Connector Properties<a class="headerlink" href="#standard-connector-properties" title="Permalink to this headline">¶</a></h3>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="plane-composition-properties">
<h3>Plane Composition Properties<a class="headerlink" href="#plane-composition-properties" title="Permalink to this headline">¶</a></h3>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="color-management-properties">
<h3>Color Management Properties<a class="headerlink" href="#color-management-properties" title="Permalink to this headline">¶</a></h3>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="tile-group-property">
<h3>Tile Group Property<a class="headerlink" href="#tile-group-property" title="Permalink to this headline">¶</a></h3>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="explicit-fencing-properties">
<h3>Explicit Fencing Properties<a class="headerlink" href="#explicit-fencing-properties" title="Permalink to this headline">¶</a></h3>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="existing-kms-properties">
<h3>Existing KMS Properties<a class="headerlink" href="#existing-kms-properties" title="Permalink to this headline">¶</a></h3>
<p>The following table gives description of drm properties exposed by
various modules/drivers.</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Owner Module/Drivers</th>
<th class="head">Group</th>
<th class="head">Property Name</th>
<th class="head">Type</th>
<th class="head">Property Values</th>
<th class="head">Object attached</th>
<th class="head">Description/Restrictions</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“scaling mode”</td>
<td>ENUM</td>
<td>{ &#8220;None&#8221;, &#8220;Full&#8221;, &#8220;Center&#8221;, &#8220;Full aspect&#8221; }</td>
<td>Connector</td>
<td>Supported by: amdgpu, gma500, i915, nouveau and radeon.</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>DVI-I</td>
<td>“subconnector”</td>
<td>ENUM</td>
<td>{ “Unknown”, “DVI-D”, “DVI-A” }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“select subconnector”</td>
<td>ENUM</td>
<td>{ “Automatic”, “DVI-D”, “DVI-A” }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>TV</td>
<td>“subconnector”</td>
<td>ENUM</td>
<td>{ &#8220;Unknown&#8221;, &#8220;Composite&#8221;, &#8220;SVIDEO&#8221;, &#8220;Component&#8221;, &#8220;SCART&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“select subconnector”</td>
<td>ENUM</td>
<td>{ &#8220;Automatic&#8221;, &#8220;Composite&#8221;, &#8220;SVIDEO&#8221;, &#8220;Component&#8221;, &#8220;SCART&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“mode”</td>
<td>ENUM</td>
<td>{ &#8220;NTSC_M&#8221;, &#8220;NTSC_J&#8221;, &#8220;NTSC_443&#8221;, &#8220;PAL_B&#8221; } etc.</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“left margin”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“right margin”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“top margin”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“bottom margin”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“brightness”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“contrast”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“flicker reduction”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“overscan”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“saturation”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“hue”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>Virtual GPU</td>
<td>“suggested X”</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffffff</td>
<td>Connector</td>
<td>property to suggest an X offset for a connector</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“suggested Y”</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffffff</td>
<td>Connector</td>
<td>property to suggest an Y offset for a connector</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>Optional</td>
<td>&#8220;aspect ratio&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;None&#8221;, &#8220;4:3&#8221;, &#8220;16:9&#8221; }</td>
<td>Connector</td>
<td>TDB</td>
</tr>
<tr class="row-odd"><td>i915</td>
<td>Generic</td>
<td>&#8220;Broadcast RGB&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;Automatic&#8221;, &#8220;Full&#8221;, &#8220;Limited 16:235&#8221; }</td>
<td>Connector</td>
<td>When this property is set to Limited 16:235 and CTM is set, the hardware will be programmed with the result of the multiplication of CTM by the limited range matrix to ensure the pixels normaly in the range 0..1.0 are remapped to the range 16/255..235/255.</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“audio”</td>
<td>ENUM</td>
<td>{ &#8220;force-dvi&#8221;, &#8220;off&#8221;, &#8220;auto&#8221;, &#8220;on&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>SDVO-TV</td>
<td>“mode”</td>
<td>ENUM</td>
<td>{ &#8220;NTSC_M&#8221;, &#8220;NTSC_J&#8221;, &#8220;NTSC_443&#8221;, &#8220;PAL_B&#8221; } etc.</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;left_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;right_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;top_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;bottom_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“hpos”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“vpos”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“contrast”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“saturation”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“hue”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“sharpness”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“flicker_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“flicker_filter_adaptive”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“flicker_filter_2d”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“tv_chroma_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“tv_luma_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“dot_crawl”</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>SDVO-TV/LVDS</td>
<td>“brightness”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>CDV gma-500</td>
<td>Generic</td>
<td>&#8220;Broadcast RGB&#8221;</td>
<td>ENUM</td>
<td>{ “Full”, “Limited 16:235” }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;Broadcast RGB&#8221;</td>
<td>ENUM</td>
<td>{ “off”, “auto”, “on” }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>Poulsbo</td>
<td>Generic</td>
<td>“backlight”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>SDVO-TV</td>
<td>“mode”</td>
<td>ENUM</td>
<td>{ &#8220;NTSC_M&#8221;, &#8220;NTSC_J&#8221;, &#8220;NTSC_443&#8221;, &#8220;PAL_B&#8221; } etc.</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;left_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;right_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;top_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;bottom_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“hpos”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“vpos”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“contrast”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“saturation”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“hue”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“sharpness”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“flicker_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“flicker_filter_adaptive”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“flicker_filter_2d”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“tv_chroma_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“tv_luma_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“dot_crawl”</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>SDVO-TV/LVDS</td>
<td>“brightness”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>armada</td>
<td>CRTC</td>
<td>&#8220;CSC_YUV&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;Auto&#8221; , &#8220;CCIR601&#8221;, &#8220;CCIR709&#8221; }</td>
<td>CRTC</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;CSC_RGB&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;Auto&#8221;, &#8220;Computer system&#8221;, &#8220;Studio&#8221; }</td>
<td>CRTC</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>Overlay</td>
<td>&#8220;colorkey&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;colorkey_min&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;colorkey_max&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;colorkey_val&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;colorkey_alpha&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;colorkey_mode&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;disabled&#8221;, &#8220;Y component&#8221;, &#8220;U component&#8221; , &#8220;V component&#8221;, &#8220;RGB&#8221;, “R component&#8221;, &#8220;G component&#8221;, &#8220;B component&#8221; }</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;brightness&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=256 + 255</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;contrast&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0x7fff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;saturation&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0x7fff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>exynos</td>
<td>CRTC</td>
<td>“mode”</td>
<td>ENUM</td>
<td>{ &#8220;normal&#8221;, &#8220;blank&#8221; }</td>
<td>CRTC</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>i2c/ch7006_drv</td>
<td>Generic</td>
<td>“scale”</td>
<td>RANGE</td>
<td>Min=0, Max=2</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>TV</td>
<td>“mode”</td>
<td>ENUM</td>
<td>{ &#8220;PAL&#8221;, &#8220;PAL-M&#8221;,&#8221;PAL-N&#8221;}, ”PAL-Nc&#8221; , &#8220;PAL-60&#8221;, &#8220;NTSC-M&#8221;, &#8220;NTSC-J&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>nouveau</td>
<td>NV10 Overlay</td>
<td>&#8220;colorkey&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0x01ffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“contrast”</td>
<td>RANGE</td>
<td>Min=0, Max=8192-1</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“brightness”</td>
<td>RANGE</td>
<td>Min=0, Max=1024</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“hue”</td>
<td>RANGE</td>
<td>Min=0, Max=359</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“saturation”</td>
<td>RANGE</td>
<td>Min=0, Max=8192-1</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“iturbt_709”</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>Nv04 Overlay</td>
<td>“colorkey”</td>
<td>RANGE</td>
<td>Min=0, Max=0x01ffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“brightness”</td>
<td>RANGE</td>
<td>Min=0, Max=1024</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>Display</td>
<td>“dithering mode”</td>
<td>ENUM</td>
<td>{ &#8220;auto&#8221;, &#8220;off&#8221;, &#8220;on&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“dithering depth”</td>
<td>ENUM</td>
<td>{ &#8220;auto&#8221;, &#8220;off&#8221;, &#8220;on&#8221;, &#8220;static 2x2&#8221;, &#8220;dynamic 2x2&#8221;, &#8220;temporal&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“underscan”</td>
<td>ENUM</td>
<td>{ &#8220;auto&#8221;, &#8220;6 bpc&#8221;, &#8220;8 bpc&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“underscan hborder”</td>
<td>RANGE</td>
<td>Min=0, Max=128</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“underscan vborder”</td>
<td>RANGE</td>
<td>Min=0, Max=128</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“vibrant hue”</td>
<td>RANGE</td>
<td>Min=0, Max=180</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“color vibrance”</td>
<td>RANGE</td>
<td>Min=0, Max=200</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>omap</td>
<td>Generic</td>
<td>“zorder”</td>
<td>RANGE</td>
<td>Min=0, Max=3</td>
<td>CRTC, Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>qxl</td>
<td>Generic</td>
<td>“hotplug_mode_update&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>radeon</td>
<td>DVI-I</td>
<td>“coherent”</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>DAC enable load detect</td>
<td>“load detection”</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>TV Standard</td>
<td>&#8220;tv standard&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;ntsc&#8221;, &#8220;pal&#8221;, &#8220;pal-m&#8221;, &#8220;pal-60&#8221;, &#8220;ntsc-j&#8221; , &#8220;scart-pal&#8221;, &#8220;pal-cn&#8221;, &#8220;secam&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>legacy TMDS PLL detect</td>
<td>&#8220;tmds_pll&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;driver&#8221;, &#8220;bios&#8221; }</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>Underscan</td>
<td>&#8220;underscan&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;off&#8221;, &#8220;on&#8221;, &#8220;auto&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;underscan hborder&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=128</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;underscan vborder&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=128</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>Audio</td>
<td>“audio”</td>
<td>ENUM</td>
<td>{ &#8220;off&#8221;, &#8220;on&#8221;, &#8220;auto&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>FMT Dithering</td>
<td>“dither”</td>
<td>ENUM</td>
<td>{ &#8220;off&#8221;, &#8220;on&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>rcar-du</td>
<td>Generic</td>
<td>&#8220;alpha&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=255</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;colorkey&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0x01ffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="vertical-blanking">
<h2>Vertical Blanking<a class="headerlink" href="#vertical-blanking" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="section" id="vertical-blanking-and-interrupt-handling-functions-reference">
<h3>Vertical Blanking and Interrupt Handling Functions Reference<a class="headerlink" href="#vertical-blanking-and-interrupt-handling-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_pending_vblank_event">
struct <code class="descname">drm_pending_vblank_event</code><a class="headerlink" href="#c.drm_pending_vblank_event" title="Permalink to this definition">¶</a></dt>
<dd><p>pending vblank event tracking</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_pending_vblank_event {
  struct drm_pending_event base;
  unsigned int pipe;
  u64 sequence;
  union event;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>Base structure for tracking pending DRM events.</dd>
<dt><code class="docutils literal"><span class="pre">pipe</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_index" title="drm_crtc_index"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_index()</span></code></a> of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> this event is for.</dd>
<dt><code class="docutils literal"><span class="pre">sequence</span></code></dt>
<dd>frame event should be triggered at</dd>
<dt><code class="docutils literal"><span class="pre">event</span></code></dt>
<dd>Actual event which will be sent to userspace.</dd>
</dl>
<dl class="type">
<dt id="c.drm_vblank_crtc">
struct <code class="descname">drm_vblank_crtc</code><a class="headerlink" href="#c.drm_vblank_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>vblank tracking for a CRTC</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_vblank_crtc {
  struct drm_device * dev;
  wait_queue_head_t queue;
  struct timer_list disable_timer;
  seqlock_t seqlock;
  u64 count;
  ktime_t time;
  atomic_t refcount;
  u32 last;
  unsigned int inmodeset;
  unsigned int pipe;
  int framedur_ns;
  int linedur_ns;
  struct drm_display_mode hwmode;
  bool enabled;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>Pointer to the <code class="xref c c-type docutils literal"><span class="pre">drm_device</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">queue</span></code></dt>
<dd>Wait queue for vblank waiters.</dd>
<dt><code class="docutils literal"><span class="pre">disable_timer</span></code></dt>
<dd>Disable timer for the delayed vblank disabling
hysteresis logic. Vblank disabling is controlled through the
drm_vblank_offdelay module option and the setting of the
<code class="xref c c-type docutils literal"><span class="pre">drm_device.max_vblank_count</span></code> value.</dd>
<dt><code class="docutils literal"><span class="pre">seqlock</span></code></dt>
<dd>Protect vblank count and time.</dd>
<dt><code class="docutils literal"><span class="pre">count</span></code></dt>
<dd>Current software vblank counter.</dd>
<dt><code class="docutils literal"><span class="pre">time</span></code></dt>
<dd>Vblank timestamp corresponding to <strong>count</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd>Number of users/waiters of the vblank interrupt. Only when
this refcount reaches 0 can the hardware interrupt be disabled using
<strong>disable_timer</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">last</span></code></dt>
<dd>Protected by <code class="xref c c-type docutils literal"><span class="pre">drm_device.vbl_lock</span></code>, used for wraparound handling.</dd>
<dt><code class="docutils literal"><span class="pre">inmodeset</span></code></dt>
<dd>Tracks whether the vblank is disabled due to a modeset.
For legacy driver bit 2 additionally tracks whether an additional
temporary vblank reference has been acquired to paper over the
hardware counter resetting/jumping. KMS drivers should instead just
call <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_on()</span></code>, which explicitly
save and restore the vblank count.</dd>
<dt><code class="docutils literal"><span class="pre">pipe</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_index" title="drm_crtc_index"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_index()</span></code></a> of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> corresponding to this
structure.</dd>
<dt><code class="docutils literal"><span class="pre">framedur_ns</span></code></dt>
<dd>Frame/Field duration in ns, used by
<code class="xref c c-func docutils literal"><span class="pre">drm_calc_vbltimestamp_from_scanoutpos()</span></code> and computed by
<code class="xref c c-func docutils literal"><span class="pre">drm_calc_timestamping_constants()</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">linedur_ns</span></code></dt>
<dd>Line duration in ns, used by
<code class="xref c c-func docutils literal"><span class="pre">drm_calc_vbltimestamp_from_scanoutpos()</span></code> and computed by
<code class="xref c c-func docutils literal"><span class="pre">drm_calc_timestamping_constants()</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">hwmode</span></code></dt>
<dd>Cache of the current hardware display mode. Only valid when <strong>enabled</strong>
is set. This is used by helpers like
<code class="xref c c-func docutils literal"><span class="pre">drm_calc_vbltimestamp_from_scanoutpos()</span></code>. We can&#8217;t just access the
hardware mode by e.g. looking at <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a>,
because that one is really hard to get from interrupt context.</dd>
<dt><code class="docutils literal"><span class="pre">enabled</span></code></dt>
<dd>Tracks the enabling state of the corresponding <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> to
avoid double-disabling and hence corrupting saved state. Needed by
drivers not using atomic KMS, since those might go through their CRTC
disabling functions multiple times.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure tracks the vblank state for one CRTC.</p>
<p>Note that for historical reasons - the vblank handling code is still shared
with legacy/non-kms drivers - this is a free-standing structure not directly
connected to <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>. But all public interface functions are taking
a <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> to hide this implementation detail.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="drm-kms-helpers.html" class="btn btn-neutral float-right" title="Mode Setting Helper Functions" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drm-mm.html" class="btn btn-neutral" title="DRM Memory Management" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.15.0-rc7',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>