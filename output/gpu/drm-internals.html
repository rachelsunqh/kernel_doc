

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>DRM Internals &mdash; The Linux Kernel 4.15.0-rc7 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel 4.15.0-rc7 documentation" href="../index.html"/>
        <link rel="up" title="Linux GPU Driver Developer’s Guide" href="index.html"/>
        <link rel="next" title="DRM Memory Management" href="drm-mm.html"/>
        <link rel="prev" title="Introduction" href="introduction.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.15.0-rc9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer&#8217;s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">DRM Internals</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#driver-initialization">Driver Initialization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#driver-information">Driver Information</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-instance-and-driver-handling">Device Instance and Driver Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#driver-load">Driver Load</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bus-specific-device-registration-and-pci-support">Bus-specific Device Registration and PCI Support</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#open-close-file-operations-and-ioctls">Open/Close, File Operations and IOCTLs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#file-operations">File Operations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#misc-utilities">Misc Utilities</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#printer">Printer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#legacy-support-code">Legacy Support Code</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#legacy-suspend-resume">Legacy Suspend/Resume</a></li>
<li class="toctree-l4"><a class="reference internal" href="#legacy-dma-services">Legacy DMA Services</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms.html">Kernel Mode Setting (KMS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms-helpers.html">Mode Setting Helper Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-uapi.html">Userland interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="i915.html">drm/i915 Intel GFX Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="meson.html">drm/meson AmLogic Meson Video Processing Unit</a></li>
<li class="toctree-l2"><a class="reference internal" href="pl111.html">drm/pl111 ARM PrimeCell PL111 CLCD Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tegra.html">drm/tegra NVIDIA Tegra GPU and display driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tinydrm.html">drm/tinydrm Driver library</a></li>
<li class="toctree-l2"><a class="reference internal" href="tve200.html">drm/tve200 Faraday TV Encoder 200</a></li>
<li class="toctree-l2"><a class="reference internal" href="vc4.html">drm/vc4 Broadcom VC4 Graphics Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="bridge/dw-hdmi.html">drm/bridge/dw-hdmi Synopsys DesignWare HDMI Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="todo.html">TODO list</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Linux GPU Driver Developer&#8217;s Guide</a> &raquo;</li>
      
    <li>DRM Internals</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/gpu/drm-internals.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="drm-internals">
<h1>DRM Internals<a class="headerlink" href="#drm-internals" title="Permalink to this headline">¶</a></h1>
<p>This chapter documents DRM internals relevant to driver authors and
developers working to add support for the latest features to existing
drivers.</p>
<p>First, we go over some typical driver initialization requirements, like
setting up command buffers, creating an initial output configuration,
and initializing core services. Subsequent sections cover core internals
in more detail, providing implementation notes and examples.</p>
<p>The DRM layer provides several services to graphics drivers, many of
them driven by the application interfaces it provides through libdrm,
the library that wraps most of the DRM ioctls. These include vblank
event handling, memory management, output management, framebuffer
management, command submission &amp; fencing, suspend/resume support, and
DMA services.</p>
<div class="section" id="driver-initialization">
<h2>Driver Initialization<a class="headerlink" href="#driver-initialization" title="Permalink to this headline">¶</a></h2>
<p>At the core of every DRM driver is a <a class="reference internal" href="#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a> structure. Drivers typically statically initialize
a drm_driver structure, and then pass it to
<code class="xref c c-func docutils literal"><span class="pre">drm_dev_alloc()</span></code> to allocate a device instance. After the
device instance is fully initialized it can be registered (which makes
it accessible from userspace) using <code class="xref c c-func docutils literal"><span class="pre">drm_dev_register()</span></code>.</p>
<p>The <a class="reference internal" href="#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a> structure
contains static information that describes the driver and features it
supports, and pointers to methods that the DRM core will call to
implement the DRM API. We will first go through the <a class="reference internal" href="#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_driver</span></code></a> static information fields, and will
then describe individual operations in details as they get used in later
sections.</p>
<div class="section" id="driver-information">
<h3>Driver Information<a class="headerlink" href="#driver-information" title="Permalink to this headline">¶</a></h3>
<div class="section" id="driver-features">
<h4>Driver Features<a class="headerlink" href="#driver-features" title="Permalink to this headline">¶</a></h4>
<p>Drivers inform the DRM core about their requirements and supported
features by setting appropriate flags in the driver_features field.
Since those flags influence the DRM core behaviour since registration
time, most of them must be set to registering the <a class="reference internal" href="#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_driver</span></code></a> instance.</p>
<p>u32 driver_features;</p>
<dl class="docutils">
<dt>DRIVER_USE_AGP</dt>
<dd>Driver uses AGP interface, the DRM core will manage AGP resources.</dd>
<dt>DRIVER_LEGACY</dt>
<dd>Denote a legacy driver using shadow attach. Don&#8217;t use.</dd>
<dt>DRIVER_KMS_LEGACY_CONTEXT</dt>
<dd>Used only by nouveau for backwards compatibility with existing userspace.
Don&#8217;t use.</dd>
<dt>DRIVER_PCI_DMA</dt>
<dd>Driver is capable of PCI DMA, mapping of PCI DMA buffers to
userspace will be enabled. Deprecated.</dd>
<dt>DRIVER_SG</dt>
<dd>Driver can perform scatter/gather DMA, allocation and mapping of
scatter/gather buffers will be enabled. Deprecated.</dd>
<dt>DRIVER_HAVE_DMA</dt>
<dd>Driver supports DMA, the userspace DMA API will be supported.
Deprecated.</dd>
<dt>DRIVER_HAVE_IRQ; DRIVER_IRQ_SHARED</dt>
<dd><p class="first">DRIVER_HAVE_IRQ indicates whether the driver has an IRQ handler
managed by the DRM Core. The core will support simple IRQ handler
installation when the flag is set. The installation process is
described in ?.</p>
<p class="last">DRIVER_IRQ_SHARED indicates whether the device &amp; handler support
shared IRQs (note that this is required of PCI drivers).</p>
</dd>
<dt>DRIVER_GEM</dt>
<dd>Driver use the GEM memory manager.</dd>
<dt>DRIVER_MODESET</dt>
<dd>Driver supports mode setting interfaces (KMS).</dd>
<dt>DRIVER_PRIME</dt>
<dd>Driver implements DRM PRIME buffer sharing.</dd>
<dt>DRIVER_RENDER</dt>
<dd>Driver supports dedicated render nodes.</dd>
<dt>DRIVER_ATOMIC</dt>
<dd>Driver supports atomic properties. In this case the driver must
implement appropriate obj-&gt;atomic_get_property() vfuncs for any
modeset objects with driver specific properties.</dd>
<dt>DRIVER_SYNCOBJ</dt>
<dd>Driver support drm sync objects.</dd>
</dl>
</div>
<div class="section" id="major-minor-and-patchlevel">
<h4>Major, Minor and Patchlevel<a class="headerlink" href="#major-minor-and-patchlevel" title="Permalink to this headline">¶</a></h4>
<p>int major; int minor; int patchlevel;
The DRM core identifies driver versions by a major, minor and patch
level triplet. The information is printed to the kernel log at
initialization time and passed to userspace through the
DRM_IOCTL_VERSION ioctl.</p>
<p>The major and minor numbers are also used to verify the requested driver
API version passed to DRM_IOCTL_SET_VERSION. When the driver API
changes between minor versions, applications can call
DRM_IOCTL_SET_VERSION to select a specific version of the API. If the
requested major isn&#8217;t equal to the driver major, or the requested minor
is larger than the driver minor, the DRM_IOCTL_SET_VERSION call will
return an error. Otherwise the driver&#8217;s set_version() method will be
called with the requested version.</p>
</div>
<div class="section" id="name-description-and-date">
<h4>Name, Description and Date<a class="headerlink" href="#name-description-and-date" title="Permalink to this headline">¶</a></h4>
<p>char *name; char *desc; char *date;
The driver name is printed to the kernel log at initialization time,
used for IRQ registration and passed to userspace through
DRM_IOCTL_VERSION.</p>
<p>The driver description is a purely informative string passed to
userspace through the DRM_IOCTL_VERSION ioctl and otherwise unused by
the kernel.</p>
<p>The driver date, formatted as YYYYMMDD, is meant to identify the date of
the latest modification to the driver. However, as most drivers fail to
update it, its value is mostly useless. The DRM core prints it to the
kernel log at initialization time and passes it to userspace through the
DRM_IOCTL_VERSION ioctl.</p>
</div>
</div>
<div class="section" id="device-instance-and-driver-handling">
<h3>Device Instance and Driver Handling<a class="headerlink" href="#device-instance-and-driver-handling" title="Permalink to this headline">¶</a></h3>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<dl class="type">
<dt id="c.drm_driver">
struct <code class="descname">drm_driver</code><a class="headerlink" href="#c.drm_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM driver structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_driver {
  int (* load) (struct drm_device *, unsigned long flags);
  int (* open) (struct drm_device *, struct drm_file *);
  void (* postclose) (struct drm_device *, struct drm_file *);
  void (* lastclose) (struct drm_device *);
  void (* unload) (struct drm_device *);
  void (* release) (struct drm_device *);
  u32 (* get_vblank_counter) (struct drm_device *dev, unsigned int pipe);
  int (* enable_vblank) (struct drm_device *dev, unsigned int pipe);
  void (* disable_vblank) (struct drm_device *dev, unsigned int pipe);
  bool (* get_scanout_position) (struct drm_device *dev, unsigned int pipe,bool in_vblank_irq, int *vpos, int *hpos,ktime_t *stime, ktime_t *etime, const struct drm_display_mode *mode);
  bool (* get_vblank_timestamp) (struct drm_device *dev, unsigned int pipe,int *max_error,ktime_t *vblank_time, bool in_vblank_irq);
  irqreturn_t(* irq_handler) (int irq, void *arg);
  void (* irq_preinstall) (struct drm_device *dev);
  int (* irq_postinstall) (struct drm_device *dev);
  void (* irq_uninstall) (struct drm_device *dev);
  int (* master_create) (struct drm_device *dev, struct drm_master *master);
  void (* master_destroy) (struct drm_device *dev, struct drm_master *master);
  int (* master_set) (struct drm_device *dev, struct drm_file *file_priv, bool from_open);
  void (* master_drop) (struct drm_device *dev, struct drm_file *file_priv);
  int (* debugfs_init) (struct drm_minor *minor);
  void (* gem_free_object) (struct drm_gem_object *obj);
  void (* gem_free_object_unlocked) (struct drm_gem_object *obj);
  int (* gem_open_object) (struct drm_gem_object *, struct drm_file *);
  void (* gem_close_object) (struct drm_gem_object *, struct drm_file *);
  struct drm_gem_object *(* gem_create_object) (struct drm_device *dev, size_t size);
  int (* prime_handle_to_fd) (struct drm_device *dev, struct drm_file *file_priv, uint32_t handle, uint32_t flags, int *prime_fd);
  int (* prime_fd_to_handle) (struct drm_device *dev, struct drm_file *file_priv, int prime_fd, uint32_t *handle);
  struct dma_buf * (* gem_prime_export) (struct drm_device *dev, struct drm_gem_object *obj, int flags);
  struct drm_gem_object * (* gem_prime_import) (struct drm_device *dev, struct dma_buf *dma_buf);
  int (* dumb_create) (struct drm_file *file_priv,struct drm_device *dev, struct drm_mode_create_dumb *args);
  int (* dumb_map_offset) (struct drm_file *file_priv,struct drm_device *dev, uint32_t handle, uint64_t *offset);
  int (* dumb_destroy) (struct drm_file *file_priv,struct drm_device *dev, uint32_t handle);
  const struct vm_operations_struct * gem_vm_ops;
  int major;
  int minor;
  int patchlevel;
  char * name;
  char * desc;
  char * date;
  u32 driver_features;
  const struct drm_ioctl_desc * ioctls;
  int num_ioctls;
  const struct file_operations * fops;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">load</span></code></dt>
<dd><p class="first">Backward-compatible driver callback to complete
initialization steps after the driver is registered.  For
this reason, may suffer from race conditions and its use is
deprecated for new drivers.  It is therefore only supported
for existing drivers not yet converted to the new scheme.
See <code class="xref c c-func docutils literal"><span class="pre">drm_dev_init()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">drm_dev_register()</span></code> for proper and
race-free way to set up a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span></code>.</p>
<p>This is deprecated, do not use!</p>
<p>Returns:</p>
<p class="last">Zero on success, non-zero value on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">open</span></code></dt>
<dd><p class="first">Driver callback when a new <a class="reference internal" href="#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span></code></a> is opened. Useful for
setting up driver-private data structures like buffer allocators,
execution contexts or similar things. Such driver-private resources
must be released again in <strong>postclose</strong>.</p>
<p>Since the display/modeset side of DRM can only be owned by exactly
one <a class="reference internal" href="#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span></code></a> (see <a class="reference internal" href="#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.is_master</span></code></a> and <code class="xref c c-type docutils literal"><span class="pre">drm_device.master</span></code>)
there should never be a need to set up any modeset related resources
in this callback. Doing so would be a driver design bug.</p>
<p>Returns:</p>
<p class="last">0 on success, a negative error code on failure, which will be
promoted to userspace as the result of the <a class="reference internal" href="../media/uapi/dvb/video-fopen.html#c.open" title="open"><code class="xref c c-func docutils literal"><span class="pre">open()</span></code></a> system call.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">postclose</span></code></dt>
<dd><p class="first">One of the driver callbacks when a new <a class="reference internal" href="#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span></code></a> is closed.
Useful for tearing down driver-private data structures allocated in
<strong>open</strong> like buffer allocators, execution contexts or similar things.</p>
<p class="last">Since the display/modeset side of DRM can only be owned by exactly
one <a class="reference internal" href="#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span></code></a> (see <a class="reference internal" href="#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.is_master</span></code></a> and <code class="xref c c-type docutils literal"><span class="pre">drm_device.master</span></code>)
there should never be a need to tear down any modeset related
resources in this callback. Doing so would be a driver design bug.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">lastclose</span></code></dt>
<dd><p class="first">Called when the last <a class="reference internal" href="#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span></code></a> has been closed and there&#8217;s
currently no userspace client for the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span></code>.</p>
<p>Modern drivers should only use this to force-restore the fbdev
framebuffer using <code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_restore_fbdev_mode_unlocked()</span></code>.
Anything else would indicate there&#8217;s something seriously wrong.
Modern drivers can also use this to execute delayed power switching
state changes, e.g. in conjunction with the <a class="reference internal" href="vga-switcheroo.html#vga-switcheroo"><span>VGA Switcheroo</span></a>
infrastructure.</p>
<p>This is called after <strong>postclose</strong> hook has been called.</p>
<p>NOTE:</p>
<p>All legacy drivers use this callback to de-initialize the hardware.
This is purely because of the shadow-attach model, where the DRM
kernel driver does not really own the hardware. Instead ownershipe is
handled with the help of userspace through an inheritedly racy dance
to set/unset the VT into raw mode.</p>
<p class="last">Legacy drivers initialize the hardware in the <strong>firstopen</strong> callback,
which isn&#8217;t even called for modern drivers.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">unload</span></code></dt>
<dd><p class="first">Reverse the effects of the driver load callback.  Ideally,
the clean up performed by the driver should happen in the
reverse order of the initialization.  Similarly to the load
hook, this handler is deprecated and its usage should be
dropped in favor of an open-coded teardown function at the
driver layer.  See <code class="xref c c-func docutils literal"><span class="pre">drm_dev_unregister()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">drm_dev_put()</span></code>
for the proper way to remove a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span></code>.</p>
<p class="last">The <code class="xref c c-func docutils literal"><span class="pre">unload()</span></code> hook is called right after unregistering
the device.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">release</span></code></dt>
<dd>Optional callback for destroying device data after the final
reference is released, i.e. the device is being destroyed. Drivers
using this callback are responsible for calling <code class="xref c c-func docutils literal"><span class="pre">drm_dev_fini()</span></code>
to finalize the device and then freeing the struct themselves.</dd>
<dt><code class="docutils literal"><span class="pre">get_vblank_counter</span></code></dt>
<dd><p class="first">Driver callback for fetching a raw hardware vblank counter for the
CRTC specified with the pipe argument.  If a device doesn&#8217;t have a
hardware counter, the driver can simply leave the hook as NULL.
The DRM core will account for missed vblank events while interrupts
where disabled based on system timestamps.</p>
<p>Wraparound handling and loss of events due to modesetting is dealt
with in the DRM core code, as long as drivers call
<code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_on()</span></code> when disabling or
enabling a CRTC.</p>
<p>This is deprecated and should not be used by new drivers.
Use <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.get_vblank_counter</span></code></a> instead.</p>
<p>Returns:</p>
<p class="last">Raw vblank counter value.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">enable_vblank</span></code></dt>
<dd><p class="first">Enable vblank interrupts for the CRTC specified with the pipe
argument.</p>
<p>This is deprecated and should not be used by new drivers.
Use <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.enable_vblank</span></code></a> instead.</p>
<p>Returns:</p>
<p class="last">Zero on success, appropriate errno if the given <strong>crtc</strong>&#8216;s vblank
interrupt cannot be enabled.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">disable_vblank</span></code></dt>
<dd><p class="first">Disable vblank interrupts for the CRTC specified with the pipe
argument.</p>
<p class="last">This is deprecated and should not be used by new drivers.
Use <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.disable_vblank</span></code></a> instead.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">get_scanout_position</span></code></dt>
<dd><p class="first">Called by vblank timestamping code.</p>
<p>Returns the current display scanout position from a crtc, and an
optional accurate <code class="xref c c-func docutils literal"><span class="pre">ktime_get()</span></code> timestamp of when position was
measured. Note that this is a helper callback which is only used if a
driver uses <code class="xref c c-func docutils literal"><span class="pre">drm_calc_vbltimestamp_from_scanoutpos()</span></code> for the
<strong>get_vblank_timestamp</strong> callback.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>dev:</dt>
<dd>DRM device.</dd>
<dt>pipe:</dt>
<dd>Id of the crtc to query.</dd>
<dt>in_vblank_irq:</dt>
<dd>True when called from <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_handle_vblank()</span></code>.  Some drivers
need to apply some workarounds for gpu-specific vblank irq quirks
if flag is set.</dd>
<dt>vpos:</dt>
<dd>Target location for current vertical scanout position.</dd>
<dt>hpos:</dt>
<dd>Target location for current horizontal scanout position.</dd>
<dt>stime:</dt>
<dd>Target location for timestamp taken immediately before
scanout position query. Can be NULL to skip timestamp.</dd>
<dt>etime:</dt>
<dd>Target location for timestamp taken immediately after
scanout position query. Can be NULL to skip timestamp.</dd>
<dt>mode:</dt>
<dd>Current display timings.</dd>
</dl>
<p>Returns vpos as a positive number while in active scanout area.
Returns vpos as a negative number inside vblank, counting the number
of scanlines to go until end of vblank, e.g., -1 means &#8220;one scanline
until start of active scanout / end of vblank.&#8221;</p>
<p>Returns:</p>
<p>True on success, false if a reliable scanout position counter could
not be read out.</p>
<p>FIXME:</p>
<p class="last">Since this is a helper to implement <strong>get_vblank_timestamp</strong>, we should
move it to <a class="reference internal" href="drm-kms-helpers.html#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_helper_funcs</span></code></a>, like all the other
helper-internal hooks.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">get_vblank_timestamp</span></code></dt>
<dd><p class="first">Called by <code class="xref c c-func docutils literal"><span class="pre">drm_get_last_vbltimestamp()</span></code>. Should return a precise
timestamp when the most recent VBLANK interval ended or will end.</p>
<p>Specifically, the timestamp in <strong>vblank_time</strong> should correspond as
closely as possible to the time when the first video scanline of
the video frame after the end of VBLANK will start scanning out,
the time immediately after end of the VBLANK interval. If the
<strong>crtc</strong> is currently inside VBLANK, this will be a time in the future.
If the <strong>crtc</strong> is currently scanning out a frame, this will be the
past start time of the current scanout. This is meant to adhere
to the OpenML OML_sync_control extension specification.</p>
<p>Paramters:</p>
<dl class="docutils">
<dt>dev:</dt>
<dd>dev DRM device handle.</dd>
<dt>pipe:</dt>
<dd>crtc for which timestamp should be returned.</dd>
<dt>max_error:</dt>
<dd>Maximum allowable timestamp error in nanoseconds.
Implementation should strive to provide timestamp
with an error of at most max_error nanoseconds.
Returns true upper bound on error for timestamp.</dd>
<dt>vblank_time:</dt>
<dd>Target location for returned vblank timestamp.</dd>
<dt>in_vblank_irq:</dt>
<dd>True when called from <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_handle_vblank()</span></code>.  Some drivers
need to apply some workarounds for gpu-specific vblank irq quirks
if flag is set.</dd>
</dl>
<p>Returns:</p>
<p>True on success, false on failure, which means the core should
fallback to a simple timestamp taken in <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_handle_vblank()</span></code>.</p>
<p>FIXME:</p>
<p class="last">We should move this hook to <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_funcs</span></code></a> like all the other
vblank hooks.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">irq_handler</span></code></dt>
<dd>Interrupt handler called when using <code class="xref c c-func docutils literal"><span class="pre">drm_irq_install()</span></code>. Not used by
drivers which implement their own interrupt handling.</dd>
<dt><code class="docutils literal"><span class="pre">irq_preinstall</span></code></dt>
<dd>Optional callback used by <code class="xref c c-func docutils literal"><span class="pre">drm_irq_install()</span></code> which is called before
the interrupt handler is registered. This should be used to clear out
any pending interrupts (from e.g. firmware based drives) and reset
the interrupt handling registers.</dd>
<dt><code class="docutils literal"><span class="pre">irq_postinstall</span></code></dt>
<dd>Optional callback used by <code class="xref c c-func docutils literal"><span class="pre">drm_irq_install()</span></code> which is called after
the interrupt handler is registered. This should be used to enable
interrupt generation in the hardware.</dd>
<dt><code class="docutils literal"><span class="pre">irq_uninstall</span></code></dt>
<dd>Optional callback used by <code class="xref c c-func docutils literal"><span class="pre">drm_irq_uninstall()</span></code> which is called before
the interrupt handler is unregistered. This should be used to disable
interrupt generation in the hardware.</dd>
<dt><code class="docutils literal"><span class="pre">master_create</span></code></dt>
<dd>Called whenever a new master is created. Only used by vmwgfx.</dd>
<dt><code class="docutils literal"><span class="pre">master_destroy</span></code></dt>
<dd>Called whenever a master is destroyed. Only used by vmwgfx.</dd>
<dt><code class="docutils literal"><span class="pre">master_set</span></code></dt>
<dd>Called whenever the minor master is set. Only used by vmwgfx.</dd>
<dt><code class="docutils literal"><span class="pre">master_drop</span></code></dt>
<dd>Called whenever the minor master is dropped. Only used by vmwgfx.</dd>
<dt><code class="docutils literal"><span class="pre">debugfs_init</span></code></dt>
<dd>Allows drivers to create driver-specific debugfs files.</dd>
<dt><code class="docutils literal"><span class="pre">gem_free_object</span></code></dt>
<dd><p class="first">deconstructor for drm_gem_objects</p>
<p class="last">This is deprecated and should not be used by new drivers. Use
<strong>gem_free_object_unlocked</strong> instead.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">gem_free_object_unlocked</span></code></dt>
<dd><p class="first">deconstructor for drm_gem_objects</p>
<p class="last">This is for drivers which are not encumbered with <code class="xref c c-type docutils literal"><span class="pre">drm_device.struct_mutex</span></code>
legacy locking schemes. Use this hook instead of <strong>gem_free_object</strong>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">gem_open_object</span></code></dt>
<dd>Driver hook called upon gem handle creation</dd>
<dt><code class="docutils literal"><span class="pre">gem_close_object</span></code></dt>
<dd>Driver hook called upon gem handle release</dd>
<dt><code class="docutils literal"><span class="pre">gem_create_object</span></code></dt>
<dd><p class="first">constructor for gem objects</p>
<p class="last">Hook for allocating the GEM object struct, for use by core
helpers.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">prime_handle_to_fd</span></code></dt>
<dd>export handle -&gt; fd (see <code class="xref c c-func docutils literal"><span class="pre">drm_gem_prime_handle_to_fd()</span></code> helper)</dd>
<dt><code class="docutils literal"><span class="pre">prime_fd_to_handle</span></code></dt>
<dd>import fd -&gt; handle (see <code class="xref c c-func docutils literal"><span class="pre">drm_gem_prime_fd_to_handle()</span></code> helper)</dd>
<dt><code class="docutils literal"><span class="pre">gem_prime_export</span></code></dt>
<dd>export GEM -&gt; dmabuf</dd>
<dt><code class="docutils literal"><span class="pre">gem_prime_import</span></code></dt>
<dd>import dmabuf -&gt; GEM</dd>
<dt><code class="docutils literal"><span class="pre">dumb_create</span></code></dt>
<dd><p class="first">This creates a new dumb buffer in the driver&#8217;s backing storage manager (GEM,
TTM or something else entirely) and returns the resulting buffer handle. This
handle can then be wrapped up into a framebuffer modeset object.</p>
<p>Note that userspace is not allowed to use such objects for render
acceleration - drivers must create their own private ioctls for such a use
case.</p>
<p>Width, height and depth are specified in the <code class="xref c c-type docutils literal"><span class="pre">drm_mode_create_dumb</span></code>
argument. The callback needs to fill the handle, pitch and size for
the created buffer.</p>
<p>Called by the user via ioctl.</p>
<p>Returns:</p>
<p class="last">Zero on success, negative errno on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">dumb_map_offset</span></code></dt>
<dd><p class="first">Allocate an offset in the drm device node&#8217;s address space to be able to
memory map a dumb buffer. GEM-based drivers must use
<code class="xref c c-func docutils literal"><span class="pre">drm_gem_create_mmap_offset()</span></code> to implement this.</p>
<p>Called by the user via ioctl.</p>
<p>Returns:</p>
<p class="last">Zero on success, negative errno on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">dumb_destroy</span></code></dt>
<dd><p class="first">This destroys the userspace handle for the given dumb backing storage buffer.
Since buffer objects must be reference counted in the kernel a buffer object
won&#8217;t be immediately freed if a framebuffer modeset object still uses it.</p>
<p>Called by the user via ioctl.</p>
<p>Returns:</p>
<p class="last">Zero on success, negative errno on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">gem_vm_ops</span></code></dt>
<dd>Driver private ops for this object</dd>
<dt><code class="docutils literal"><span class="pre">major</span></code></dt>
<dd>driver major number</dd>
<dt><code class="docutils literal"><span class="pre">minor</span></code></dt>
<dd>driver minor number</dd>
<dt><code class="docutils literal"><span class="pre">patchlevel</span></code></dt>
<dd>driver patch level</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>driver name</dd>
<dt><code class="docutils literal"><span class="pre">desc</span></code></dt>
<dd>driver description</dd>
<dt><code class="docutils literal"><span class="pre">date</span></code></dt>
<dd>driver date</dd>
<dt><code class="docutils literal"><span class="pre">driver_features</span></code></dt>
<dd>driver features</dd>
<dt><code class="docutils literal"><span class="pre">ioctls</span></code></dt>
<dd>Array of driver-private IOCTL description entries. See the chapter on
<a class="reference internal" href="drm-uapi.html#drm-driver-ioctl"><span>IOCTL support in the userland interfaces
chapter</span></a> for the full details.</dd>
<dt><code class="docutils literal"><span class="pre">num_ioctls</span></code></dt>
<dd>Number of entries in <strong>ioctls</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">fops</span></code></dt>
<dd>File operations for the DRM device node. See the discussion in
<a class="reference internal" href="#drm-driver-fops"><span>file operations</span></a> for in-depth coverage and
some examples.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represent the common code for a family of cards. There will
one drm_device for each card present in this family. It contains lots of
vfunc entries, and a pile of those probably should be moved to more
appropriate places like <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs</span></code></a> or into a new operations
structure for GEM drivers.</p>
<dl class="function">
<dt id="c.drm_dev_is_unplugged">
int <code class="descname">drm_dev_is_unplugged</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dev_is_unplugged" title="Permalink to this definition">¶</a></dt>
<dd><p>is a DRM device unplugged</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be called to check whether a hotpluggable is unplugged.
Unplugging itself is singalled through <code class="xref c c-func docutils literal"><span class="pre">drm_dev_unplug()</span></code>. If a device is
unplugged, these two functions guarantee that any store before calling
<code class="xref c c-func docutils literal"><span class="pre">drm_dev_unplug()</span></code> is visible to callers of this function after it completes</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="driver-load">
<h3>Driver Load<a class="headerlink" href="#driver-load" title="Permalink to this headline">¶</a></h3>
<div class="section" id="irq-helper-library">
<h4>IRQ Helper Library<a class="headerlink" href="#irq-helper-library" title="Permalink to this headline">¶</a></h4>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="memory-manager-initialization">
<h4>Memory Manager Initialization<a class="headerlink" href="#memory-manager-initialization" title="Permalink to this headline">¶</a></h4>
<p>Every DRM driver requires a memory manager which must be initialized at
load time. DRM currently contains two memory managers, the Translation
Table Manager (TTM) and the Graphics Execution Manager (GEM). This
document describes the use of the GEM memory manager only. See ? for
details.</p>
</div>
<div class="section" id="miscellaneous-device-configuration">
<h4>Miscellaneous Device Configuration<a class="headerlink" href="#miscellaneous-device-configuration" title="Permalink to this headline">¶</a></h4>
<p>Another task that may be necessary for PCI devices during configuration
is mapping the video BIOS. On many devices, the VBIOS describes device
configuration, LCD panel timings (if any), and contains flags indicating
device state. Mapping the BIOS can be done using the pci_map_rom()
call, a convenience function that takes care of mapping the actual ROM,
whether it has been shadowed into memory (typically at address 0xc0000)
or exists on the PCI device in the ROM BAR. Note that after the ROM has
been mapped and any necessary information has been extracted, it should
be unmapped; on many devices, the ROM address decoder is shared with
other BARs, so leaving it mapped could cause undesired behaviour like
hangs or memory corruption.</p>
</div>
</div>
<div class="section" id="bus-specific-device-registration-and-pci-support">
<h3>Bus-specific Device Registration and PCI Support<a class="headerlink" href="#bus-specific-device-registration-and-pci-support" title="Permalink to this headline">¶</a></h3>
<p>A number of functions are provided to help with device registration. The
functions deal with PCI and platform devices respectively and are only
provided for historical reasons. These are all deprecated and shouldn&#8217;t
be used in new drivers. Besides that there&#8217;s a few helpers for pci
drivers.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
</div>
<div class="section" id="open-close-file-operations-and-ioctls">
<h2>Open/Close, File Operations and IOCTLs<a class="headerlink" href="#open-close-file-operations-and-ioctls" title="Permalink to this headline">¶</a></h2>
<div class="section" id="file-operations">
<span id="drm-driver-fops"></span><h3>File Operations<a class="headerlink" href="#file-operations" title="Permalink to this headline">¶</a></h3>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<dl class="type">
<dt id="c.drm_minor">
struct <code class="descname">drm_minor</code><a class="headerlink" href="#c.drm_minor" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM device minor structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_minor {
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<p><strong>Description</strong></p>
<p>This structure represents a DRM minor number for device nodes in /dev.
Entirely opaque to drivers and should never be inspected directly by drivers.
Drivers instead should only interact with <a class="reference internal" href="#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span></code></a> and of course
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span></code>, which is also where driver-private data and resources can
be attached to.</p>
<dl class="type">
<dt id="c.drm_pending_event">
struct <code class="descname">drm_pending_event</code><a class="headerlink" href="#c.drm_pending_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Event queued up for userspace to read</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_pending_event {
  struct completion * completion;
  void (* completion_release) (struct completion *completion);
  struct drm_event * event;
  struct dma_fence * fence;
  struct drm_file * file_priv;
  struct list_head link;
  struct list_head pending_link;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">completion</span></code></dt>
<dd>Optional pointer to a kernel internal completion signalled when
<code class="xref c c-func docutils literal"><span class="pre">drm_send_event()</span></code> is called, useful to internally synchronize with
nonblocking operations.</dd>
<dt><code class="docutils literal"><span class="pre">completion_release</span></code></dt>
<dd>Optional callback currently only used by the atomic modeset helpers
to clean up the reference count for the structure <strong>completion</strong> is
stored in.</dd>
<dt><code class="docutils literal"><span class="pre">event</span></code></dt>
<dd>Pointer to the actual event that should be sent to userspace to be
read using <code class="xref c c-func docutils literal"><span class="pre">drm_read()</span></code>. Can be optional, since nowadays events are
also used to signal kernel internal threads with <strong>completion</strong> or DMA
transactions using <strong>fence</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">fence</span></code></dt>
<dd>Optional DMA fence to unblock other hardware transactions which
depend upon the nonblocking DRM operation this event represents.</dd>
<dt><code class="docutils literal"><span class="pre">file_priv</span></code></dt>
<dd><a class="reference internal" href="#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span></code></a> where <strong>event</strong> should be delivered to. Only set when
<strong>event</strong> is set.</dd>
<dt><code class="docutils literal"><span class="pre">link</span></code></dt>
<dd>Double-linked list to keep track of this event. Can be used by the
driver up to the point when it calls <code class="xref c c-func docutils literal"><span class="pre">drm_send_event()</span></code>, after that
this list entry is owned by the core for its own book-keeping.</dd>
<dt><code class="docutils literal"><span class="pre">pending_link</span></code></dt>
<dd>Entry on <a class="reference internal" href="#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.pending_event_list</span></code></a>, to keep track of all pending
events for <strong>file_priv</strong>, to allow correct unwinding of them when
userspace closes the file before the event is delivered.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This represents a DRM event. Drivers can use this as a generic completion
mechanism, which supports kernel-internal <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">completion</span></code>, <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span></code></a>
and also the DRM-specific <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_event</span></code> delivery mechanism.</p>
<dl class="type">
<dt id="c.drm_file">
struct <code class="descname">drm_file</code><a class="headerlink" href="#c.drm_file" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM file private data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_file {
  unsigned authenticated:1;
  unsigned stereo_allowed:1;
  unsigned universal_planes:1;
  unsigned atomic:1;
  unsigned is_master:1;
  struct drm_master * master;
  struct pid * pid;
  drm_magic_t magic;
  struct list_head lhead;
  struct drm_minor * minor;
  struct idr object_idr;
  spinlock_t table_lock;
  struct idr syncobj_idr;
  spinlock_t syncobj_table_lock;
  struct file * filp;
  void * driver_priv;
  struct list_head fbs;
  struct mutex fbs_lock;
  struct list_head blobs;
  wait_queue_head_t event_wait;
  struct list_head pending_event_list;
  struct list_head event_list;
  int event_space;
  struct mutex event_read_lock;
  struct drm_prime_file_private prime;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">authenticated</span></code></dt>
<dd><p class="first">Whether the client is allowed to submit rendering, which for legacy
nodes means it must be authenticated.</p>
<p class="last">See also the <a class="reference internal" href="drm-uapi.html#drm-primary-node"><span>section on primary nodes and authentication</span></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">stereo_allowed</span></code></dt>
<dd>True when the client has asked us to expose stereo 3D mode flags.</dd>
<dt><code class="docutils literal"><span class="pre">universal_planes</span></code></dt>
<dd>True if client understands CRTC primary planes and cursor planes
in the plane list. Automatically set when <strong>atomic</strong> is set.</dd>
<dt><code class="docutils literal"><span class="pre">atomic</span></code></dt>
<dd>True if client understands atomic properties.</dd>
<dt><code class="docutils literal"><span class="pre">is_master</span></code></dt>
<dd><p class="first">This client is the creator of <strong>master</strong>. Protected by struct
<code class="xref c c-type docutils literal"><span class="pre">drm_device.master_mutex</span></code>.</p>
<p class="last">See also the <a class="reference internal" href="drm-uapi.html#drm-primary-node"><span>section on primary nodes and authentication</span></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">master</span></code></dt>
<dd><p class="first">Master this node is currently associated with. Only relevant if
<a class="reference internal" href="#c.drm_is_primary_client" title="drm_is_primary_client"><code class="xref c c-func docutils literal"><span class="pre">drm_is_primary_client()</span></code></a> returns true. Note that this only
matches <code class="xref c c-type docutils literal"><span class="pre">drm_device.master</span></code> if the master is the currently active one.</p>
<p class="last">See also <strong>authentication</strong> and <strong>is_master</strong> and the <a class="reference internal" href="drm-uapi.html#drm-primary-node"><span>section on
primary nodes and authentication</span></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">pid</span></code></dt>
<dd>Process that opened this file.</dd>
<dt><code class="docutils literal"><span class="pre">magic</span></code></dt>
<dd>Authentication magic, see <strong>authenticated</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">lhead</span></code></dt>
<dd>List of all open files of a DRM device, linked into
<code class="xref c c-type docutils literal"><span class="pre">drm_device.filelist</span></code>. Protected by <code class="xref c c-type docutils literal"><span class="pre">drm_device.filelist_mutex</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">minor</span></code></dt>
<dd><a class="reference internal" href="#c.drm_minor" title="drm_minor"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_minor</span></code></a> for this file.</dd>
<dt><code class="docutils literal"><span class="pre">object_idr</span></code></dt>
<dd>Mapping of mm object handles to object pointers. Used by the GEM
subsystem. Protected by <strong>table_lock</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">table_lock</span></code></dt>
<dd>Protects <strong>object_idr</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">syncobj_idr</span></code></dt>
<dd>Mapping of sync object handles to object pointers.</dd>
<dt><code class="docutils literal"><span class="pre">syncobj_table_lock</span></code></dt>
<dd>Protects <strong>syncobj_idr</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">filp</span></code></dt>
<dd>Pointer to the core file structure.</dd>
<dt><code class="docutils literal"><span class="pre">driver_priv</span></code></dt>
<dd>Optional pointer for driver private data. Can be allocated in
<a class="reference internal" href="#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.open</span></code></a> and should be freed in <a class="reference internal" href="#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.postclose</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">fbs</span></code></dt>
<dd><p class="first">List of <a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span></code></a> associated with this file, using the
<a class="reference internal" href="drm-kms.html#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer.filp_head</span></code></a> entry.</p>
<p class="last">Protected by <strong>fbs_lock</strong>. Note that the <strong>fbs</strong> list holds a reference on
the framebuffer object to prevent it from untimely disappearing.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">fbs_lock</span></code></dt>
<dd>Protects <strong>fbs</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">blobs</span></code></dt>
<dd><p class="first">User-created blob properties; this retains a reference on the
property.</p>
<p class="last">Protected by <strong>drm_mode_config</strong>.blob_lock;</p>
</dd>
<dt><code class="docutils literal"><span class="pre">event_wait</span></code></dt>
<dd>Waitqueue for new events added to <strong>event_list</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">pending_event_list</span></code></dt>
<dd><p class="first">List of pending <a class="reference internal" href="#c.drm_pending_event" title="drm_pending_event"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_pending_event</span></code></a>, used to clean up pending
events in case this file gets closed before the event is signalled.
Uses the <a class="reference internal" href="#c.drm_pending_event" title="drm_pending_event"><code class="xref c c-type docutils literal"><span class="pre">drm_pending_event.pending_link</span></code></a> entry.</p>
<p class="last">Protect by <code class="xref c c-type docutils literal"><span class="pre">drm_device.event_lock</span></code>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">event_list</span></code></dt>
<dd><p class="first">List of <a class="reference internal" href="#c.drm_pending_event" title="drm_pending_event"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_pending_event</span></code></a>, ready for delivery to userspace
through <code class="xref c c-func docutils literal"><span class="pre">drm_read()</span></code>. Uses the <a class="reference internal" href="#c.drm_pending_event" title="drm_pending_event"><code class="xref c c-type docutils literal"><span class="pre">drm_pending_event.link</span></code></a> entry.</p>
<p class="last">Protect by <code class="xref c c-type docutils literal"><span class="pre">drm_device.event_lock</span></code>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">event_space</span></code></dt>
<dd>Available event space to prevent userspace from
exhausting kernel memory. Currently limited to the fairly arbitrary
value of 4KB.</dd>
<dt><code class="docutils literal"><span class="pre">event_read_lock</span></code></dt>
<dd>Serializes <code class="xref c c-func docutils literal"><span class="pre">drm_read()</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">prime</span></code></dt>
<dd>Per-file buffer caches used by the PRIME buffer sharing code.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure tracks DRM state per open file descriptor.</p>
<dl class="function">
<dt id="c.drm_is_primary_client">
bool <code class="descname">drm_is_primary_client</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_is_primary_client" title="Permalink to this definition">¶</a></dt>
<dd><p>is this an open file of the primary node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>DRM file</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if this is an open file of the primary node, i.e.
<a class="reference internal" href="#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.minor</span></code></a> of <strong>file_priv</strong> is a primary minor.</p>
<p>See also the <a class="reference internal" href="drm-uapi.html#drm-primary-node"><span>section on primary nodes and authentication</span></a>.</p>
<dl class="function">
<dt id="c.drm_is_render_client">
bool <code class="descname">drm_is_render_client</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_is_render_client" title="Permalink to this definition">¶</a></dt>
<dd><p>is this an open file of the render node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>DRM file</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if this is an open file of the render node, i.e.
<a class="reference internal" href="#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.minor</span></code></a> of <strong>file_priv</strong> is a render minor.</p>
<p>See also the <a class="reference internal" href="drm-uapi.html#drm-render-node"><span>section on render nodes</span></a>.</p>
<dl class="function">
<dt id="c.drm_is_control_client">
bool <code class="descname">drm_is_control_client</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_is_control_client" title="Permalink to this definition">¶</a></dt>
<dd><p>is this an open file of the control node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>DRM file</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control nodes are deprecated and in the process of getting removed from the
DRM userspace API. Do not ever use!</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
</div>
<div class="section" id="misc-utilities">
<h2>Misc Utilities<a class="headerlink" href="#misc-utilities" title="Permalink to this headline">¶</a></h2>
<div class="section" id="printer">
<h3>Printer<a class="headerlink" href="#printer" title="Permalink to this headline">¶</a></h3>
<p>A simple wrapper for <code class="xref c c-func docutils literal"><span class="pre">dev_printk()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">seq_printf()</span></code>, etc.  Allows same
debug code to be used for both debugfs and printk logging.</p>
<p>For example:</p>
<div class="highlight-none"><div class="highlight"><pre>void log_some_info(struct drm_printer *p)
{
        drm_printf(p, &quot;foo=``d``\n&quot;, foo);
        drm_printf(p, &quot;bar=``d``\n&quot;, bar);
}

#ifdef CONFIG_DEBUG_FS
void debugfs_show(struct seq_file *f)
{
        struct drm_printer p = drm_seq_file_printer(f);
        log_some_info(:c:type:`p`);
}
#endif

void some_other_function(...)
{
        struct drm_printer p = drm_info_printer(drm-&gt;dev);
        log_some_info(:c:type:`p`);
}
</pre></div>
</div>
<dl class="type">
<dt id="c.drm_printer">
struct <code class="descname">drm_printer</code><a class="headerlink" href="#c.drm_printer" title="Permalink to this definition">¶</a></dt>
<dd><p>drm output &#8220;stream&#8221;</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_printer {
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<p><strong>Description</strong></p>
<p>Do not use struct members directly.  Use <code class="xref c c-func docutils literal"><span class="pre">drm_printer_seq_file()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">drm_printer_info()</span></code>, etc to initialize.  And <code class="xref c c-func docutils literal"><span class="pre">drm_printf()</span></code> for output.</p>
<dl class="function">
<dt id="c.drm_seq_file_printer">
struct <a class="reference internal" href="#c.drm_printer" title="drm_printer">drm_printer</a> <code class="descname">drm_seq_file_printer</code><span class="sig-paren">(</span>struct seq_file *<em>&nbsp;f</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_seq_file_printer" title="Permalink to this definition">¶</a></dt>
<dd><p>construct a <a class="reference internal" href="#c.drm_printer" title="drm_printer"><code class="xref c c-type docutils literal"><span class="pre">drm_printer</span></code></a> that outputs to <code class="xref c c-type docutils literal"><span class="pre">seq_file</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">f</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">seq_file</span></code> to output to</dd>
</dl>
<p><strong>Return</strong></p>
<p>The <a class="reference internal" href="#c.drm_printer" title="drm_printer"><code class="xref c c-type docutils literal"><span class="pre">drm_printer</span></code></a> object</p>
<dl class="function">
<dt id="c.drm_info_printer">
struct <a class="reference internal" href="#c.drm_printer" title="drm_printer">drm_printer</a> <code class="descname">drm_info_printer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_info_printer" title="Permalink to this definition">¶</a></dt>
<dd><p>construct a <a class="reference internal" href="#c.drm_printer" title="drm_printer"><code class="xref c c-type docutils literal"><span class="pre">drm_printer</span></code></a> that outputs to <code class="xref c c-func docutils literal"><span class="pre">dev_printk()</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code></a> pointer</dd>
</dl>
<p><strong>Return</strong></p>
<p>The <a class="reference internal" href="#c.drm_printer" title="drm_printer"><code class="xref c c-type docutils literal"><span class="pre">drm_printer</span></code></a> object</p>
<dl class="function">
<dt id="c.drm_debug_printer">
struct <a class="reference internal" href="#c.drm_printer" title="drm_printer">drm_printer</a> <code class="descname">drm_debug_printer</code><span class="sig-paren">(</span>const char *<em>&nbsp;prefix</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_debug_printer" title="Permalink to this definition">¶</a></dt>
<dd><p>construct a <a class="reference internal" href="#c.drm_printer" title="drm_printer"><code class="xref c c-type docutils literal"><span class="pre">drm_printer</span></code></a> that outputs to <code class="xref c c-func docutils literal"><span class="pre">pr_debug()</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">prefix</span></code></dt>
<dd>debug output prefix</dd>
</dl>
<p><strong>Return</strong></p>
<p>The <a class="reference internal" href="#c.drm_printer" title="drm_printer"><code class="xref c c-type docutils literal"><span class="pre">drm_printer</span></code></a> object</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
</div>
<div class="section" id="legacy-support-code">
<h2>Legacy Support Code<a class="headerlink" href="#legacy-support-code" title="Permalink to this headline">¶</a></h2>
<p>The section very briefly covers some of the old legacy support code
which is only used by old DRM drivers which have done a so-called
shadow-attach to the underlying device instead of registering as a real
driver. This also includes some of the old generic buffer management and
command submission code. Do not use any of this in new and modern
drivers.</p>
<div class="section" id="legacy-suspend-resume">
<h3>Legacy Suspend/Resume<a class="headerlink" href="#legacy-suspend-resume" title="Permalink to this headline">¶</a></h3>
<p>The DRM core provides some suspend/resume code, but drivers wanting full
suspend/resume support should provide save() and restore() functions.
These are called at suspend, hibernate, or resume time, and should
perform any state save or restore required by your device across suspend
or hibernate states.</p>
<p>int (*suspend) (struct drm_device *, pm_message_t state); int
(*resume) (struct drm_device *);
Those are legacy suspend and resume methods which <em>only</em> work with the
legacy shadow-attach driver registration functions. New driver should
use the power management interface provided by their bus type (usually
through the <a class="reference internal" href="../driver-api/infrastructure.html#c.device_driver" title="device_driver"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span></code></a>
dev_pm_ops) and set these methods to NULL.</p>
</div>
<div class="section" id="legacy-dma-services">
<h3>Legacy DMA Services<a class="headerlink" href="#legacy-dma-services" title="Permalink to this headline">¶</a></h3>
<p>This should cover how DMA mapping etc. is supported by the core. These
functions are deprecated and should not be used.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="drm-mm.html" class="btn btn-neutral float-right" title="DRM Memory Management" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="introduction.html" class="btn btn-neutral" title="Introduction" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.15.0-rc7',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>