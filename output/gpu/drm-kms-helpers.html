

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Mode Setting Helper Functions &mdash; The Linux Kernel 4.15.0-rc7 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel 4.15.0-rc7 documentation" href="../index.html"/>
        <link rel="up" title="Linux GPU Driver Developer’s Guide" href="index.html"/>
        <link rel="next" title="Userland interfaces" href="drm-uapi.html"/>
        <link rel="prev" title="Kernel Mode Setting (KMS)" href="drm-kms.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.15.0-rc9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer&#8217;s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms.html">Kernel Mode Setting (KMS)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Mode Setting Helper Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#modeset-helper-reference-for-common-vtables">Modeset Helper Reference for Common Vtables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#atomic-modeset-helper-functions-reference">Atomic Modeset Helper Functions Reference</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementing-asynchronous-atomic-commit">Implementing Asynchronous Atomic Commit</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomic-state-reset-and-initialization">Atomic State Reset and Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#helper-functions-reference">Helper Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#legacy-crtc-modeset-helper-functions-reference">Legacy CRTC/Modeset Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simple-kms-helper-reference">Simple KMS Helper Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fbdev-helper-functions-reference">fbdev Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#framebuffer-cma-helper-functions-reference">Framebuffer CMA Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bridges">Bridges</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#default-bridge-callback-sequence">Default bridge callback sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bridge-helper-reference">Bridge Helper Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#panel-bridge-helper-reference">Panel-Bridge Helper Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#panel-helper-reference">Panel Helper Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#display-port-helper-functions-reference">Display Port Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#display-port-dual-mode-adaptor-helper-functions-reference">Display Port Dual Mode Adaptor Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#display-port-mst-helper-functions-reference">Display Port MST Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mipi-dsi-helper-functions-reference">MIPI DSI Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#output-probing-helper-functions-reference">Output Probing Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#edid-helper-functions-reference">EDID Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scdc-helper-functions-reference">SCDC Helper Functions Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rectangle-utilities-reference">Rectangle Utilities Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hdmi-infoframes-helper-reference">HDMI Infoframes Helper Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#flip-work-helper-reference">Flip-work Helper Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plane-helper-reference">Plane Helper Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#auxiliary-modeset-helpers">Auxiliary Modeset Helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#framebuffer-gem-helper-reference">Framebuffer GEM Helper Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="drm-uapi.html">Userland interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="i915.html">drm/i915 Intel GFX Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="meson.html">drm/meson AmLogic Meson Video Processing Unit</a></li>
<li class="toctree-l2"><a class="reference internal" href="pl111.html">drm/pl111 ARM PrimeCell PL111 CLCD Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tegra.html">drm/tegra NVIDIA Tegra GPU and display driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tinydrm.html">drm/tinydrm Driver library</a></li>
<li class="toctree-l2"><a class="reference internal" href="tve200.html">drm/tve200 Faraday TV Encoder 200</a></li>
<li class="toctree-l2"><a class="reference internal" href="vc4.html">drm/vc4 Broadcom VC4 Graphics Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="bridge/dw-hdmi.html">drm/bridge/dw-hdmi Synopsys DesignWare HDMI Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="todo.html">TODO list</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Linux GPU Driver Developer&#8217;s Guide</a> &raquo;</li>
      
    <li>Mode Setting Helper Functions</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/gpu/drm-kms-helpers.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mode-setting-helper-functions">
<h1>Mode Setting Helper Functions<a class="headerlink" href="#mode-setting-helper-functions" title="Permalink to this headline">¶</a></h1>
<p>The DRM subsystem aims for a strong separation between core code and helper
libraries. Core code takes care of general setup and teardown and decoding
userspace requests to kernel internal objects. Everything else is handled by a
large set of helper libraries, which can be combined freely to pick and choose
for each driver what fits, and avoid shared code where special behaviour is
needed.</p>
<p>This distinction between core code and helpers is especially strong in the
modesetting code, where there&#8217;s a shared userspace ABI for all drivers. This is
in contrast to the render side, where pretty much everything (with very few
exceptions) can be considered optional helper code.</p>
<p>There are a few areas these helpers can grouped into:</p>
<ul class="simple">
<li>Helpers to implement modesetting. The important ones here are the atomic
helpers. Old drivers still often use the legacy CRTC helpers. They both share
the same set of common helper vtables. For really simple drivers (anything
that would have been a great fit in the deprecated fbdev subsystem) there&#8217;s
also the simple display pipe helpers.</li>
<li>There&#8217;s a big pile of helpers for handling outputs. First the generic bridge
helpers for handling encoder and transcoder IP blocks. Second the panel helpers
for handling panel-related information and logic. Plus then a big set of
helpers for the various sink standards (DisplayPort, HDMI, MIPI DSI). Finally
there&#8217;s also generic helpers for handling output probing, and for dealing with
EDIDs.</li>
<li>The last group of helpers concerns itself with the frontend side of a display
pipeline: Planes, handling rectangles for visibility checking and scissoring,
flip queues and assorted bits.</li>
</ul>
<div class="section" id="modeset-helper-reference-for-common-vtables">
<h2>Modeset Helper Reference for Common Vtables<a class="headerlink" href="#modeset-helper-reference-for-common-vtables" title="Permalink to this headline">¶</a></h2>
<p>The DRM mode setting helper functions are common code for drivers to use if
they wish.  Drivers are not forced to use this code in their
implementations but it would be useful if the code they do use at least
provides a consistent interface and operation to userspace. Therefore it is
highly recommended to use the provided helpers as much as possible.</p>
<p>Because there is only one pointer per modeset object to hold a vfunc table
for helper libraries they are by necessity shared among the different
helpers.</p>
<p>To make this clear all the helper vtables are pulled together in this location here.</p>
<dl class="type">
<dt id="c.drm_crtc_helper_funcs">
struct <code class="descname">drm_crtc_helper_funcs</code><a class="headerlink" href="#c.drm_crtc_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for CRTCs</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_crtc_helper_funcs {
  void (* dpms) (struct drm_crtc *crtc, int mode);
  void (* prepare) (struct drm_crtc *crtc);
  void (* commit) (struct drm_crtc *crtc);
  enum drm_mode_status (* mode_valid) (struct drm_crtc *crtc, const struct drm_display_mode *mode);
  bool (* mode_fixup) (struct drm_crtc *crtc,const struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);
  int (* mode_set) (struct drm_crtc *crtc, struct drm_display_mode *mode,struct drm_display_mode *adjusted_mode, int x, int y, struct drm_framebuffer *old_fb);
  void (* mode_set_nofb) (struct drm_crtc *crtc);
  int (* mode_set_base) (struct drm_crtc *crtc, int x, int y, struct drm_framebuffer *old_fb);
  int (* mode_set_base_atomic) (struct drm_crtc *crtc,struct drm_framebuffer *fb, int x, int y, enum mode_set_atomic);
  void (* disable) (struct drm_crtc *crtc);
  int (* atomic_check) (struct drm_crtc *crtc, struct drm_crtc_state *state);
  void (* atomic_begin) (struct drm_crtc *crtc, struct drm_crtc_state *old_crtc_state);
  void (* atomic_flush) (struct drm_crtc *crtc, struct drm_crtc_state *old_crtc_state);
  void (* atomic_enable) (struct drm_crtc *crtc, struct drm_crtc_state *old_crtc_state);
  void (* atomic_disable) (struct drm_crtc *crtc, struct drm_crtc_state *old_crtc_state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dpms</span></code></dt>
<dd><p class="first">Callback to control power levels on the CRTC.  If the mode passed in
is unsupported, the provider must use the next lowest power level.
This is used by the legacy CRTC helpers to implement DPMS
functionality in <code class="xref c c-func docutils literal"><span class="pre">drm_helper_connector_dpms()</span></code>.</p>
<p>This callback is also used to disable a CRTC by calling it with
DRM_MODE_DPMS_OFF if the <strong>disable</strong> hook isn&#8217;t used.</p>
<p class="last">This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling and disabling a CRTC to
facilitate transitions to atomic, but it is deprecated. Instead
<strong>atomic_enable</strong> and <strong>atomic_disable</strong> should be used.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">prepare</span></code></dt>
<dd><p class="first">This callback should prepare the CRTC for a subsequent modeset, which
in practice means the driver should disable the CRTC if it is
running. Most drivers ended up implementing this by calling their
<strong>dpms</strong> hook with DRM_MODE_DPMS_OFF.</p>
<p class="last">This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for disabling a CRTC to facilitate
transitions to atomic, but it is deprecated. Instead <strong>atomic_disable</strong>
should be used.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">commit</span></code></dt>
<dd><p class="first">This callback should commit the new mode on the CRTC after a modeset,
which in practice means the driver should enable the CRTC.  Most
drivers ended up implementing this by calling their <strong>dpms</strong> hook with
DRM_MODE_DPMS_ON.</p>
<p class="last">This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling a CRTC to facilitate
transitions to atomic, but it is deprecated. Instead <strong>atomic_enable</strong>
should be used.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_valid</span></code></dt>
<dd><p class="first">This callback is used to check if a specific mode is valid in this
crtc. This should be implemented if the crtc has some sort of
restriction in the modes it can display. For example, a given crtc
may be responsible to set a clock value. If the clock can not
produce all the values for the available modes then this callback
can be used to restrict the number of modes to only the ones that
can be displayed.</p>
<p>This hook is used by the probe helpers to filter the mode list in
<code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes()</span></code>, and it is used by the
atomic helpers to validate modes supplied by userspace in
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code>.</p>
<p>This function is optional.</p>
<p>NOTE:</p>
<p>Since this function is both called from the check phase of an atomic
commit, and the mode validation in the probe paths it is not allowed
to look at anything else but the passed-in mode, and validate it
against configuration-invariant hardward constraints. Any further
limits which depend upon the configuration can only be checked in
<strong>mode_fixup</strong> or <strong>atomic_check</strong>.</p>
<p>RETURNS:</p>
<p class="last">drm_mode_status Enum</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_fixup</span></code></dt>
<dd><p class="first">This callback is used to validate a mode. The parameter mode is the
display mode that userspace requested, adjusted_mode is the mode the
encoders need to be fed with. Note that this is the inverse semantics
of the meaning for the <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a> and <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs.mode_fixup</span></code></a>
vfunc. If the CRTC cannot support the requested conversion from mode
to adjusted_mode it should reject the modeset. See also
<a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a> for more details.</p>
<p>This function is used by both legacy CRTC helpers and atomic helpers.
With atomic helpers it is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of atomic modesets, which
can be aborted for any reason (including on userspace&#8217;s request to
just check whether a configuration would be possible). Atomic drivers
MUST NOT touch any persistent state (hardware or software) or data
structures except the passed in adjusted_mode parameter.</p>
<p>This is in contrast to the legacy CRTC helpers where this was
allowed.</p>
<p>Atomic drivers which need to inspect and adjust more state should
instead use the <strong>atomic_check</strong> callback, but note that they&#8217;re not
perfectly equivalent: <strong>mode_valid</strong> is called from
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code>, but <strong>atomic_check</strong> is called from
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_planes()</span></code>, because originally it was meant for
plane update checks only.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any CRTC constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p class="last">True if an acceptable configuration is possible, false if the modeset
operation should be rejected.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_set</span></code></dt>
<dd><p class="first">This callback is used by the legacy CRTC helpers to set a new mode,
position and framebuffer. Since it ties the primary plane to every
mode change it is incompatible with universal plane support. And
since it can&#8217;t update other planes it&#8217;s incompatible with atomic
modeset support.</p>
<p>This callback is only used by CRTC helpers and deprecated.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_set_nofb</span></code></dt>
<dd><p class="first">This callback is used to update the display mode of a CRTC without
changing anything of the primary plane configuration. This fits the
requirement of atomic and hence is used by the atomic helpers. It is
also used by the transitional plane helpers to implement a
<strong>mode_set</strong> hook in <code class="xref c c-func docutils literal"><span class="pre">drm_helper_crtc_mode_set()</span></code>.</p>
<p>Note that the display pipe is completely off when this function is
called. Atomic drivers which need hardware to be running before they
program the new display mode (e.g. because they implement runtime PM)
should not use this hook. This is because the helper library calls
this hook only once per mode change and not every time the display
pipeline is suspended using either DPMS or the new &#8220;ACTIVE&#8221; property.
Which means register values set in this callback might get reset when
the CRTC is suspended, but not restored.  Such drivers should instead
move all their CRTC setup into the <strong>atomic_enable</strong> callback.</p>
<p class="last">This callback is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_set_base</span></code></dt>
<dd><p class="first">This callback is used by the legacy CRTC helpers to set a new
framebuffer and scanout position. It is optional and used as an
optimized fast-path instead of a full mode set operation with all the
resulting flickering. If it is not present
<code class="xref c c-func docutils literal"><span class="pre">drm_crtc_helper_set_config()</span></code> will fall back to a full modeset, using
the <strong>mode_set</strong> callback. Since it can&#8217;t update other planes it&#8217;s
incompatible with atomic modeset support.</p>
<p>This callback is only used by the CRTC helpers and deprecated.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_set_base_atomic</span></code></dt>
<dd><p class="first">This callback is used by the fbdev helpers to set a new framebuffer
and scanout without sleeping, i.e. from an atomic calling context. It
is only used to implement kgdb support.</p>
<p>This callback is optional and only needed for kgdb support in the fbdev
helpers.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">disable</span></code></dt>
<dd><p class="first">This callback should be used to disable the CRTC. With the atomic
drivers it is called after all encoders connected to this CRTC have
been shut off already using their own
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.disable</span></code></a> hook. If that sequence is too
simple drivers can just add their own hooks and call it from this
CRTC callback here by looping over all encoders connected to it using
<code class="xref c c-func docutils literal"><span class="pre">for_each_encoder_on_crtc()</span></code>.</p>
<p>This hook is used both by legacy CRTC helpers and atomic helpers.
Atomic drivers don&#8217;t need to implement it if there&#8217;s no need to
disable anything at the CRTC level. To ensure that runtime PM
handling (using either DPMS or the new &#8220;ACTIVE&#8221; property) works
<strong>disable</strong> must be the inverse of <strong>atomic_enable</strong> for atomic drivers.
Atomic drivers should consider to use <strong>atomic_disable</strong> instead of
this one.</p>
<p>NOTE:</p>
<p>With legacy CRTC helpers there&#8217;s a big semantic difference between
<strong>disable</strong> and other hooks (like <strong>prepare</strong> or <strong>dpms</strong>) used to shut down a
CRTC: <strong>disable</strong> is only called when also logically disabling the
display pipeline and needs to release any resources acquired in
<strong>mode_set</strong> (like shared PLLs, or again release pinned framebuffers).</p>
<p class="last">Therefore <strong>disable</strong> must be the inverse of <strong>mode_set</strong> plus <strong>commit</strong> for
drivers still using legacy CRTC helpers, which is different from the
rules under atomic.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_check</span></code></dt>
<dd><p class="first">Drivers should check plane-update related CRTC constraints in this
hook. They can also check mode related limitations but need to be
aware of the calling order, since this hook is used by
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_planes()</span></code> whereas the preparations needed to
check output routing and the display mode is done in
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code>. Therefore drivers that want to
check output routing and display mode constraints in this callback
must ensure that <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code> has been called
beforehand. This is calling order used by the default helper
implementation in <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check()</span></code>.</p>
<p>When using <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_planes()</span></code> this hook is called
after the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.atomic_check</span></code></a> hook for planes, which
allows drivers to assign shared resources requested by planes in this
callback here. For more complicated dependencies the driver can call
the provided check helpers multiple times until the computed state
has a final configuration and everything has been checked.</p>
<p>This function is also allowed to inspect any other object&#8217;s state and
can add more state objects to the atomic commit if needed. Care must
be taken though to ensure that state check and compute functions for
these added states are all called, and derived state in other objects
all updated. Again the recommendation is to just call check helpers
until a maximal configuration is reached.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>
update tracking structure.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any CRTC constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the state or the transition can&#8217;t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_begin</span></code></dt>
<dd><p class="first">Drivers should prepare for an atomic update of multiple planes on
a CRTC in this hook. Depending upon hardware this might be vblank
evasion, blocking updates by setting bits or doing preparatory work
for e.g. manual update display.</p>
<p>This hook is called before any plane commit functions are called.</p>
<p>Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_planes()</span></code> for a discussion of
the tradeoffs and variants of plane commit helpers.</p>
<p class="last">This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_flush</span></code></dt>
<dd><p class="first">Drivers should finalize an atomic update of multiple planes on
a CRTC in this hook. Depending upon hardware this might include
checking that vblank evasion was successful, unblocking updates by
setting bits or setting the GO bit to flush out all updates.</p>
<p>Simple hardware or hardware with special requirements can commit and
flush out all updates for all planes from this hook and forgo all the
other commit hooks for plane updates.</p>
<p>This hook is called after any plane commit functions are called.</p>
<p>Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_planes()</span></code> for a discussion of
the tradeoffs and variants of plane commit helpers.</p>
<p class="last">This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_enable</span></code></dt>
<dd><p class="first">This callback should be used to enable the CRTC. With the atomic
drivers it is called before all encoders connected to this CRTC are
enabled through the encoder&#8217;s own <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.enable</span></code></a>
hook.  If that sequence is too simple drivers can just add their own
hooks and call it from this CRTC callback here by looping over all
encoders connected to it using <code class="xref c c-func docutils literal"><span class="pre">for_each_encoder_on_crtc()</span></code>.</p>
<p>This hook is used only by atomic helpers, for symmetry with
<strong>atomic_disable</strong>. Atomic drivers don&#8217;t need to implement it if there&#8217;s
no need to enable anything at the CRTC level. To ensure that runtime
PM handling (using either DPMS or the new &#8220;ACTIVE&#8221; property) works
<strong>atomic_enable</strong> must be the inverse of <strong>atomic_disable</strong> for atomic
drivers.</p>
<p class="last">Drivers can use the <strong>old_crtc_state</strong> input parameter if the operations
needed to enable the CRTC don&#8217;t depend solely on the new state but
also on the transition between the old state and the new state.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_disable</span></code></dt>
<dd><p class="first">This callback should be used to disable the CRTC. With the atomic
drivers it is called after all encoders connected to this CRTC have
been shut off already using their own
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.disable</span></code></a> hook. If that sequence is too
simple drivers can just add their own hooks and call it from this
CRTC callback here by looping over all encoders connected to it using
<code class="xref c c-func docutils literal"><span class="pre">for_each_encoder_on_crtc()</span></code>.</p>
<p>This hook is used only by atomic helpers. Atomic drivers don&#8217;t
need to implement it if there&#8217;s no need to disable anything at the
CRTC level.</p>
<p class="last">Comparing to <strong>disable</strong>, this one provides the additional input
parameter <strong>old_crtc_state</strong> which could be used to access the old
state. Atomic drivers should consider to use this one instead
of <strong>disable</strong>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These hooks are used by the legacy CRTC helpers, the transitional plane
helpers and the new atomic modesetting helpers.</p>
<dl class="function">
<dt id="c.drm_crtc_helper_add">
void <code class="descname">drm_crtc_helper_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, const struct <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs">drm_crtc_helper_funcs</a> *<em>&nbsp;funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_helper_add" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the helper vtable for a crtc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>DRM CRTC</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_helper_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>helper vtable to set for <strong>crtc</strong></dd>
</dl>
<dl class="type">
<dt id="c.drm_encoder_helper_funcs">
struct <code class="descname">drm_encoder_helper_funcs</code><a class="headerlink" href="#c.drm_encoder_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for encoders</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_encoder_helper_funcs {
  void (* dpms) (struct drm_encoder *encoder, int mode);
  enum drm_mode_status (* mode_valid) (struct drm_encoder *crtc, const struct drm_display_mode *mode);
  bool (* mode_fixup) (struct drm_encoder *encoder,const struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);
  void (* prepare) (struct drm_encoder *encoder);
  void (* commit) (struct drm_encoder *encoder);
  void (* mode_set) (struct drm_encoder *encoder,struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);
  void (* atomic_mode_set) (struct drm_encoder *encoder,struct drm_crtc_state *crtc_state, struct drm_connector_state *conn_state);
  struct drm_crtc *(* get_crtc) (struct drm_encoder *encoder);
  enum drm_connector_status (* detect) (struct drm_encoder *encoder, struct drm_connector *connector);
  void (* disable) (struct drm_encoder *encoder);
  void (* enable) (struct drm_encoder *encoder);
  int (* atomic_check) (struct drm_encoder *encoder,struct drm_crtc_state *crtc_state, struct drm_connector_state *conn_state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dpms</span></code></dt>
<dd><p class="first">Callback to control power levels on the encoder.  If the mode passed in
is unsupported, the provider must use the next lowest power level.
This is used by the legacy encoder helpers to implement DPMS
functionality in <code class="xref c c-func docutils literal"><span class="pre">drm_helper_connector_dpms()</span></code>.</p>
<p>This callback is also used to disable an encoder by calling it with
DRM_MODE_DPMS_OFF if the <strong>disable</strong> hook isn&#8217;t used.</p>
<p class="last">This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling and disabling an encoder to
facilitate transitions to atomic, but it is deprecated. Instead
<strong>enable</strong> and <strong>disable</strong> should be used.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_valid</span></code></dt>
<dd><p class="first">This callback is used to check if a specific mode is valid in this
encoder. This should be implemented if the encoder has some sort
of restriction in the modes it can display. For example, a given
encoder may be responsible to set a clock value. If the clock can
not produce all the values for the available modes then this callback
can be used to restrict the number of modes to only the ones that
can be displayed.</p>
<p>This hook is used by the probe helpers to filter the mode list in
<code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes()</span></code>, and it is used by the
atomic helpers to validate modes supplied by userspace in
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code>.</p>
<p>This function is optional.</p>
<p>NOTE:</p>
<p>Since this function is both called from the check phase of an atomic
commit, and the mode validation in the probe paths it is not allowed
to look at anything else but the passed-in mode, and validate it
against configuration-invariant hardward constraints. Any further
limits which depend upon the configuration can only be checked in
<strong>mode_fixup</strong> or <strong>atomic_check</strong>.</p>
<p>RETURNS:</p>
<p class="last">drm_mode_status Enum</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_fixup</span></code></dt>
<dd><p class="first">This callback is used to validate and adjust a mode. The parameter
mode is the display mode that should be fed to the next element in
the display chain, either the final <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a> or a <a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge</span></code></a>.
The parameter adjusted_mode is the input mode the encoder requires. It
can be modified by this callback and does not need to match mode. See
also <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a> for more details.</p>
<p>This function is used by both legacy CRTC helpers and atomic helpers.
This hook is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of atomic modesets, which
can be aborted for any reason (including on userspace&#8217;s request to
just check whether a configuration would be possible). Atomic drivers
MUST NOT touch any persistent state (hardware or software) or data
structures except the passed in adjusted_mode parameter.</p>
<p>This is in contrast to the legacy CRTC helpers where this was
allowed.</p>
<p>Atomic drivers which need to inspect and adjust more state should
instead use the <strong>atomic_check</strong> callback. If <strong>atomic_check</strong> is used,
this hook isn&#8217;t called since <strong>atomic_check</strong> allows a strict superset
of the functionality of <strong>mode_fixup</strong>.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any encoder constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p class="last">True if an acceptable configuration is possible, false if the modeset
operation should be rejected.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">prepare</span></code></dt>
<dd><p class="first">This callback should prepare the encoder for a subsequent modeset,
which in practice means the driver should disable the encoder if it
is running. Most drivers ended up implementing this by calling their
<strong>dpms</strong> hook with DRM_MODE_DPMS_OFF.</p>
<p class="last">This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for disabling an encoder to facilitate
transitions to atomic, but it is deprecated. Instead <strong>disable</strong> should
be used.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">commit</span></code></dt>
<dd><p class="first">This callback should commit the new mode on the encoder after a modeset,
which in practice means the driver should enable the encoder.  Most
drivers ended up implementing this by calling their <strong>dpms</strong> hook with
DRM_MODE_DPMS_ON.</p>
<p class="last">This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling an encoder to facilitate
transitions to atomic, but it is deprecated. Instead <strong>enable</strong> should
be used.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_set</span></code></dt>
<dd><p class="first">This callback is used to update the display mode of an encoder.</p>
<p>Note that the display pipe is completely off when this function is
called. Drivers which need hardware to be running before they program
the new display mode (because they implement runtime PM) should not
use this hook, because the helper library calls it only once and not
every time the display pipeline is suspend using either DPMS or the
new &#8220;ACTIVE&#8221; property. Such drivers should instead move all their
encoder setup into the <strong>enable</strong> callback.</p>
<p>This callback is used both by the legacy CRTC helpers and the atomic
modeset helpers. It is optional in the atomic helpers.</p>
<p>NOTE:</p>
<p class="last">If the driver uses the atomic modeset helpers and needs to inspect
the connector state or connector display info during mode setting,
<strong>atomic_mode_set</strong> can be used instead.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_mode_set</span></code></dt>
<dd><p class="first">This callback is used to update the display mode of an encoder.</p>
<p>Note that the display pipe is completely off when this function is
called. Drivers which need hardware to be running before they program
the new display mode (because they implement runtime PM) should not
use this hook, because the helper library calls it only once and not
every time the display pipeline is suspended using either DPMS or the
new &#8220;ACTIVE&#8221; property. Such drivers should instead move all their
encoder setup into the <strong>enable</strong> callback.</p>
<p class="last">This callback is used by the atomic modeset helpers in place of the
<strong>mode_set</strong> callback, if set by the driver. It is optional and should
be used instead of <strong>mode_set</strong> if the driver needs to inspect the
connector state or display info, since there is no direct way to
go from the encoder to the current connector.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">get_crtc</span></code></dt>
<dd><p class="first">This callback is used by the legacy CRTC helpers to work around
deficiencies in its own book-keeping.</p>
<p>Do not use, use atomic helpers instead, which get the book keeping
right.</p>
<p>FIXME:</p>
<p class="last">Currently only nouveau is using this, and as soon as nouveau is
atomic we can ditch this hook.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">detect</span></code></dt>
<dd><p class="first">This callback can be used by drivers who want to do detection on the
encoder object instead of in connector functions.</p>
<p>It is not used by any helper and therefore has purely driver-specific
semantics. New drivers shouldn&#8217;t use this and instead just implement
their own private callbacks.</p>
<p>FIXME:</p>
<p class="last">This should just be converted into a pile of driver vfuncs.
Currently radeon, amdgpu and nouveau are using it.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">disable</span></code></dt>
<dd><p class="first">This callback should be used to disable the encoder. With the atomic
drivers it is called before this encoder&#8217;s CRTC has been shut off
using their own <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.disable</span></code></a> hook.  If that
sequence is too simple drivers can just add their own driver private
encoder hooks and call them from CRTC&#8217;s callback by looping over all
encoders connected to it using <code class="xref c c-func docutils literal"><span class="pre">for_each_encoder_on_crtc()</span></code>.</p>
<p>This hook is used both by legacy CRTC helpers and atomic helpers.
Atomic drivers don&#8217;t need to implement it if there&#8217;s no need to
disable anything at the encoder level. To ensure that runtime PM
handling (using either DPMS or the new &#8220;ACTIVE&#8221; property) works
<strong>disable</strong> must be the inverse of <strong>enable</strong> for atomic drivers.</p>
<p>NOTE:</p>
<p>With legacy CRTC helpers there&#8217;s a big semantic difference between
<strong>disable</strong> and other hooks (like <strong>prepare</strong> or <strong>dpms</strong>) used to shut down a
encoder: <strong>disable</strong> is only called when also logically disabling the
display pipeline and needs to release any resources acquired in
<strong>mode_set</strong> (like shared PLLs, or again release pinned framebuffers).</p>
<p class="last">Therefore <strong>disable</strong> must be the inverse of <strong>mode_set</strong> plus <strong>commit</strong> for
drivers still using legacy CRTC helpers, which is different from the
rules under atomic.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">enable</span></code></dt>
<dd><p class="first">This callback should be used to enable the encoder. With the atomic
drivers it is called after this encoder&#8217;s CRTC has been enabled using
their own <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.enable</span></code></a> hook.  If that sequence is
too simple drivers can just add their own driver private encoder
hooks and call them from CRTC&#8217;s callback by looping over all encoders
connected to it using <code class="xref c c-func docutils literal"><span class="pre">for_each_encoder_on_crtc()</span></code>.</p>
<p class="last">This hook is used only by atomic helpers, for symmetry with <strong>disable</strong>.
Atomic drivers don&#8217;t need to implement it if there&#8217;s no need to
enable anything at the encoder level. To ensure that runtime PM handling
(using either DPMS or the new &#8220;ACTIVE&#8221; property) works
<strong>enable</strong> must be the inverse of <strong>disable</strong> for atomic drivers.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_check</span></code></dt>
<dd><p class="first">This callback is used to validate encoder state for atomic drivers.
Since the encoder is the object connecting the CRTC and connector it
gets passed both states, to be able to validate interactions and
update the CRTC to match what the encoder needs for the requested
connector.</p>
<p>Since this provides a strict superset of the functionality of
<strong>mode_fixup</strong> (the requested and adjusted modes are both available
through the passed in <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a>) <strong>mode_fixup</strong> is not
called when <strong>atomic_check</strong> is implemented.</p>
<p>This function is used by the atomic helpers, but it is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>
update tracking structure.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any encoder constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the state or the transition can&#8217;t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These hooks are used by the legacy CRTC helpers, the transitional plane
helpers and the new atomic modesetting helpers.</p>
<dl class="function">
<dt id="c.drm_encoder_helper_add">
void <code class="descname">drm_encoder_helper_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em>, const struct <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs">drm_encoder_helper_funcs</a> *<em>&nbsp;funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_helper_add" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the helper vtable for an encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>DRM encoder</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_encoder_helper_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>helper vtable to set for <strong>encoder</strong></dd>
</dl>
<dl class="type">
<dt id="c.drm_connector_helper_funcs">
struct <code class="descname">drm_connector_helper_funcs</code><a class="headerlink" href="#c.drm_connector_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for connectors</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_connector_helper_funcs {
  int (* get_modes) (struct drm_connector *connector);
  int (* detect_ctx) (struct drm_connector *connector,struct drm_modeset_acquire_ctx *ctx, bool force);
  enum drm_mode_status (* mode_valid) (struct drm_connector *connector, struct drm_display_mode *mode);
  struct drm_encoder *(* best_encoder) (struct drm_connector *connector);
  struct drm_encoder *(* atomic_best_encoder) (struct drm_connector *connector, struct drm_connector_state *connector_state);
  int (* atomic_check) (struct drm_connector *connector, struct drm_connector_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">get_modes</span></code></dt>
<dd><p class="first">This function should fill in all modes currently valid for the sink
into the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.probed_modes</span></code></a> list. It should also update the
EDID property by calling <code class="xref c c-func docutils literal"><span class="pre">drm_mode_connector_update_edid_property()</span></code>.</p>
<p>The usual way to implement this is to cache the EDID retrieved in the
probe callback somewhere in the driver-private connector structure.
In this function drivers then parse the modes in the EDID and add
them by calling <code class="xref c c-func docutils literal"><span class="pre">drm_add_edid_modes()</span></code>. But connectors that driver a
fixed panel can also manually add specific modes using
<code class="xref c c-func docutils literal"><span class="pre">drm_mode_probed_add()</span></code>. Drivers which manually add modes should also
make sure that the <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.display_info</span></code></a>,
<a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.width_mm</span></code></a> and <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.height_mm</span></code></a> fields are
filled in.</p>
<p>Virtual drivers that just want some standard VESA mode with a given
resolution can call <code class="xref c c-func docutils literal"><span class="pre">drm_add_modes_noedid()</span></code>, and mark the preferred
one using <code class="xref c c-func docutils literal"><span class="pre">drm_set_preferred_mode()</span></code>.</p>
<p>Finally drivers that support audio probably want to update the ELD
data, too, using <code class="xref c c-func docutils literal"><span class="pre">drm_edid_to_eld()</span></code>.</p>
<p>This function is only called after the <strong>detect</strong> hook has indicated
that a sink is connected and when the EDID isn&#8217;t overridden through
sysfs or the kernel commandline.</p>
<p>This callback is used by the probe helpers in e.g.
<code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes()</span></code>.</p>
<p>To avoid races with concurrent connector state updates, the helper
libraries always call this with the <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connection_mutex</span></code></a>
held. Because of this it&#8217;s safe to inspect <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector-&gt;state</span></code></a>.</p>
<p>RETURNS:</p>
<p class="last">The number of modes added by calling <code class="xref c c-func docutils literal"><span class="pre">drm_mode_probed_add()</span></code>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">detect_ctx</span></code></dt>
<dd><p class="first">Check to see if anything is attached to the connector. The parameter
force is set to false whilst polling, true when checking the
connector due to a user request. force can be used by the driver to
avoid expensive, destructive operations during automated probing.</p>
<p>This callback is optional, if not implemented the connector will be
considered as always being attached.</p>
<p>This is the atomic version of <a class="reference internal" href="drm-kms.html#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.detect</span></code></a>.</p>
<p>To avoid races against concurrent connector state updates, the
helper libraries always call this with ctx set to a valid context,
and <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connection_mutex</span></code></a> will always be locked with
the ctx parameter set to this ctx. This allows taking additional
locks as required.</p>
<p>RETURNS:</p>
<p class="last"><a class="reference internal" href="drm-kms.html#c.drm_connector_status" title="drm_connector_status"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_status</span></code></a> indicating the connector&#8217;s status,
or the error code returned by <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock()</span></code></a>, -EDEADLK.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_valid</span></code></dt>
<dd><p class="first">Callback to validate a mode for a connector, irrespective of the
specific display configuration.</p>
<p>This callback is used by the probe helpers to filter the mode list
(which is usually derived from the EDID data block from the sink).
See e.g. <code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes()</span></code>.</p>
<p>This function is optional.</p>
<p>NOTE:</p>
<p>This only filters the mode list supplied to userspace in the
GETCONNECTOR IOCTL. Compared to <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.mode_valid</span></code></a>,
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.mode_valid</span></code></a> and <a class="reference internal" href="#c.drm_bridge_funcs" title="drm_bridge_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge_funcs.mode_valid</span></code></a>,
which are also called by the atomic helpers from
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code>. This allows userspace to force and
ignore sink constraint (like the pixel clock limits in the screen&#8217;s
EDID), which is useful for e.g. testing, or working around a broken
EDID. Any source hardware constraint (which always need to be
enforced) therefore should be checked in one of the above callbacks,
and not this one here.</p>
<p>To avoid races with concurrent connector state updates, the helper
libraries always call this with the <a class="reference internal" href="drm-kms.html#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connection_mutex</span></code></a>
held. Because of this it&#8217;s safe to inspect <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector-&gt;state</span></code></a>.</p>
<p>RETURNS:</p>
<p class="last">Either <a class="reference internal" href="drm-kms.html#c.drm_mode_status" title="drm_mode_status"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_status.MODE_OK</span></code></a> or one of the failure reasons in <a class="reference internal" href="drm-kms.html#c.drm_mode_status" title="drm_mode_status"><code class="xref c c-type docutils literal"><span class="pre">enum</span>
<span class="pre">drm_mode_status</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">best_encoder</span></code></dt>
<dd><p class="first">This function should select the best encoder for the given connector.</p>
<p>This function is used by both the atomic helpers (in the
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code> function) and in the legacy CRTC
helpers.</p>
<p>NOTE:</p>
<p>In atomic drivers this function is called in the check phase of an
atomic update. The driver is not allowed to change or inspect
anything outside of arguments passed-in. Atomic drivers which need to
inspect dynamic configuration state should instead use
<strong>atomic_best_encoder</strong>.</p>
<p>You can leave this function to NULL if the connector is only
attached to a single encoder and you are using the atomic helpers.
In this case, the core will call <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_best_encoder()</span></code>
for you.</p>
<p>RETURNS:</p>
<p class="last">Encoder that should be used for the given connector and connector
state, or NULL if no suitable encoder exists. Note that the helpers
will ensure that encoders aren&#8217;t used twice, drivers should not check
for this.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_best_encoder</span></code></dt>
<dd><p class="first">This is the atomic version of <strong>best_encoder</strong> for atomic drivers which
need to select the best encoder depending upon the desired
configuration and can&#8217;t select it statically.</p>
<p>This function is used by <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code>.
If it is not implemented, the core will fallback to <strong>best_encoder</strong>
(or <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_best_encoder()</span></code> if <strong>best_encoder</strong> is NULL).</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>
update tracking structure.</p>
<p>RETURNS:</p>
<p class="last">Encoder that should be used for the given connector and connector
state, or NULL if no suitable encoder exists. Note that the helpers
will ensure that encoders aren&#8217;t used twice, drivers should not check
for this.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_check</span></code></dt>
<dd><p class="first">This hook is used to validate connector state. This function is
called from <code class="xref c c-type docutils literal"><span class="pre">drm_atomic_helper_check_modeset</span></code>, and is called when
a connector property is set, or a modeset on the crtc is forced.</p>
<p>Because <code class="xref c c-type docutils literal"><span class="pre">drm_atomic_helper_check_modeset</span></code> may be called multiple times,
this function should handle being called multiple times as well.</p>
<p>This function is also allowed to inspect any other object&#8217;s state and
can add more state objects to the atomic commit if needed. Care must
be taken though to ensure that state check and compute functions for
these added states are all called, and derived state in other objects
all updated. Again the recommendation is to just call check helpers
until a maximal configuration is reached.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>
update tracking structure.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the state or the transition can&#8217;t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These functions are used by the atomic and legacy modeset helpers and by the
probe helpers.</p>
<dl class="function">
<dt id="c.drm_connector_helper_add">
void <code class="descname">drm_connector_helper_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, const struct <a class="reference internal" href="#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs">drm_connector_helper_funcs</a> *<em>&nbsp;funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_helper_add" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the helper vtable for a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>DRM connector</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_helper_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>helper vtable to set for <strong>connector</strong></dd>
</dl>
<dl class="type">
<dt id="c.drm_plane_helper_funcs">
struct <code class="descname">drm_plane_helper_funcs</code><a class="headerlink" href="#c.drm_plane_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for planes</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_plane_helper_funcs {
  int (* prepare_fb) (struct drm_plane *plane, struct drm_plane_state *new_state);
  void (* cleanup_fb) (struct drm_plane *plane, struct drm_plane_state *old_state);
  int (* atomic_check) (struct drm_plane *plane, struct drm_plane_state *state);
  void (* atomic_update) (struct drm_plane *plane, struct drm_plane_state *old_state);
  void (* atomic_disable) (struct drm_plane *plane, struct drm_plane_state *old_state);
  int (* atomic_async_check) (struct drm_plane *plane, struct drm_plane_state *state);
  void (* atomic_async_update) (struct drm_plane *plane, struct drm_plane_state *new_state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">prepare_fb</span></code></dt>
<dd><p class="first">This hook is to prepare a framebuffer for scanout by e.g. pinning
it&#8217;s backing storage or relocating it into a contiguous block of
VRAM. Other possible preparatory work includes flushing caches.</p>
<p>This function must not block for outstanding rendering, since it is
called in the context of the atomic IOCTL even for async commits to
be able to return any errors to userspace. Instead the recommended
way is to fill out the fence member of the passed-in
<a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state</span></code></a>. If the driver doesn&#8217;t support native fences then
equivalent functionality should be implemented through private
members in the plane structure.</p>
<p>The helpers will call <strong>cleanup_fb</strong> with matching arguments for every
successful call to this hook.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
<p>RETURNS:</p>
<p class="last">0 on success or one of the following negative error codes allowed by
the <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a> vfunc. When using helpers
this callback is the only one which can fail an atomic commit,
everything else must complete successfully.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cleanup_fb</span></code></dt>
<dd><p class="first">This hook is called to clean up any resources allocated for the given
framebuffer and plane configuration in <strong>prepare_fb</strong>.</p>
<p class="last">This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_check</span></code></dt>
<dd><p class="first">Drivers should check plane specific constraints in this hook.</p>
<p>When using <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_planes()</span></code> plane&#8217;s <strong>atomic_check</strong>
hooks are called before the ones for CRTCs, which allows drivers to
request shared resources that the CRTC controls here. For more
complicated dependencies the driver can call the provided check helpers
multiple times until the computed state has a final configuration and
everything has been checked.</p>
<p>This function is also allowed to inspect any other object&#8217;s state and
can add more state objects to the atomic commit if needed. Care must
be taken though to ensure that state check and compute functions for
these added states are all called, and derived state in other objects
all updated. Again the recommendation is to just call check helpers
until a maximal configuration is reached.</p>
<p>This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall <a class="reference internal" href="drm-kms.html#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>
update tracking structure.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the state or the transition can&#8217;t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_update</span></code></dt>
<dd><p class="first">Drivers should use this function to update the plane state.  This
hook is called in-between the <a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.atomic_begin</span></code></a> and
drm_crtc_helper_funcs.atomic_flush callbacks.</p>
<p>Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_planes()</span></code> for a discussion of
the tradeoffs and variants of plane commit helpers.</p>
<p class="last">This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_disable</span></code></dt>
<dd><p class="first">Drivers should use this function to unconditionally disable a plane.
This hook is called in-between the
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.atomic_begin</span></code></a> and
drm_crtc_helper_funcs.atomic_flush callbacks. It is an alternative to
<strong>atomic_update</strong>, which will be called for disabling planes, too, if
the <strong>atomic_disable</strong> hook isn&#8217;t implemented.</p>
<p>This hook is also useful to disable planes in preparation of a modeset,
by calling <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_disable_planes_on_crtc()</span></code> from the
<a class="reference internal" href="#c.drm_crtc_helper_funcs" title="drm_crtc_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_helper_funcs.disable</span></code></a> hook.</p>
<p>Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_planes()</span></code> for a discussion of
the tradeoffs and variants of plane commit helpers.</p>
<p class="last">This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_async_check</span></code></dt>
<dd><p class="first">Drivers should set this function pointer to check if the plane state
can be updated in a async fashion. Here async means &#8220;not vblank
synchronized&#8221;.</p>
<p>This hook is called by <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_async_check()</span></code> to establish if a
given update can be committed asynchronously, that is, if it can
jump ahead of the state currently queued for update.</p>
<p>RETURNS:</p>
<p class="last">Return 0 on success and any error returned indicates that the update
can not be applied in asynchronous manner.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_async_update</span></code></dt>
<dd><p class="first">Drivers should set this function pointer to perform asynchronous
updates of planes, that is, jump ahead of the currently queued
state and update the plane. Here async means &#8220;not vblank
synchronized&#8221;.</p>
<p>This hook is called by <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_async_commit()</span></code>.</p>
<p>An async update will happen on legacy cursor updates. An async
update won&#8217;t happen if there is an outstanding commit modifying
the same plane.</p>
<p>Note that unlike <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.atomic_update</span></code></a> this hook
takes the new <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state</span></code></a> as parameter. When doing async_update
drivers shouldn&#8217;t replace the <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state</span></code></a> but update the
current one with the new plane configurations in the new
plane_state.</p>
<dl class="last docutils">
<dt>FIXME:</dt>
<dd><ul class="first last simple">
<li>It only works for single plane updates</li>
<li>Async Pageflips are not supported yet</li>
<li>Some hw might still scan out the old buffer until the next
vblank, however we let go of the fb references as soon as
we run this hook. For now drivers must implement their own workers
for deferring if needed, until a common solution is created.</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These functions are used by the atomic helpers and by the transitional plane
helpers.</p>
<dl class="function">
<dt id="c.drm_plane_helper_add">
void <code class="descname">drm_plane_helper_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, const struct <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs">drm_plane_helper_funcs</a> *<em>&nbsp;funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_helper_add" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the helper vtable for a plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>DRM plane</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_helper_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>helper vtable to set for <strong>plane</strong></dd>
</dl>
<dl class="type">
<dt id="c.drm_mode_config_helper_funcs">
struct <code class="descname">drm_mode_config_helper_funcs</code><a class="headerlink" href="#c.drm_mode_config_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>global modeset helper operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_mode_config_helper_funcs {
  void (* atomic_commit_tail) (struct drm_atomic_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">atomic_commit_tail</span></code></dt>
<dd><p class="first">This hook is used by the default <code class="xref c c-func docutils literal"><span class="pre">atomic_commit()</span></code> hook implemented in
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit()</span></code> together with the nonblocking commit
helpers (see <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_setup_commit()</span></code> for a starting point)
to implement blocking and nonblocking commits easily. It is not used
by the atomic helpers</p>
<p>This function is called when the new atomic state has already been
swapped into the various state pointers. The passed in state
therefore contains copies of the old/previous state. This hook should
commit the new state into hardware. Note that the helpers have
already waited for preceeding atomic commits and fences, but drivers
can add more waiting calls at the start of their implementation, e.g.
to wait for driver-internal request for implicit syncing, before
starting to commit the update to the hardware.</p>
<p>After the atomic update is committed to the hardware this hook needs
to call <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_hw_done()</span></code>. Then wait for the upate
to be executed by the hardware, for example using
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_wait_for_vblanks()</span></code> or
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_wait_for_flip_done()</span></code>, and then clean up the old
framebuffers using <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code>.</p>
<p>When disabling a CRTC this hook _must_ stall for the commit to
complete. Vblank waits don&#8217;t work on disabled CRTC, hence the core
can&#8217;t take care of this. And it also can&#8217;t rely on the vblank event,
since that can be signalled already when the screen shows black,
which can happen much earlier than the last hardware access needed to
shut off the display pipeline completely.</p>
<p class="last">This hook is optional, the default implementation is
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_tail()</span></code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>These helper functions are used by the atomic helpers.</p>
</div>
<div class="section" id="atomic-modeset-helper-functions-reference">
<span id="drm-atomic-helper"></span><h2>Atomic Modeset Helper Functions Reference<a class="headerlink" href="#atomic-modeset-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="implementing-asynchronous-atomic-commit">
<h3>Implementing Asynchronous Atomic Commit<a class="headerlink" href="#implementing-asynchronous-atomic-commit" title="Permalink to this headline">¶</a></h3>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="atomic-state-reset-and-initialization">
<h3>Atomic State Reset and Initialization<a class="headerlink" href="#atomic-state-reset-and-initialization" title="Permalink to this headline">¶</a></h3>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="helper-functions-reference">
<h3>Helper Functions Reference<a class="headerlink" href="#helper-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.drm_atomic_crtc_for_each_plane">
<code class="descname">drm_atomic_crtc_for_each_plane</code><span class="sig-paren">(</span><em>plane</em>, <em>crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_for_each_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over planes currently attached to CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>the crtc whose planes are iterated</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over the current state, useful (for example) when applying
atomic state after it has been checked and swapped.  To iterate over the
planes which <em>will</em> be attached (more useful in code called from
<a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a>) see
<a class="reference internal" href="#c.drm_atomic_crtc_state_for_each_plane" title="drm_atomic_crtc_state_for_each_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_state_for_each_plane()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_atomic_crtc_state_for_each_plane">
<code class="descname">drm_atomic_crtc_state_for_each_plane</code><span class="sig-paren">(</span><em>plane</em>, <em>crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_state_for_each_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over attached planes in new state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">crtc_state</span></code></dt>
<dd>the incoming crtc-state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_for_each_plane()</span></code>, but iterates the planes that will be
attached if the specified state is applied.  Useful during for example
in code called from <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> operations, to
validate the incoming state.</p>
<dl class="function">
<dt id="c.drm_atomic_crtc_state_for_each_plane_state">
<code class="descname">drm_atomic_crtc_state_for_each_plane_state</code><span class="sig-paren">(</span><em>plane</em>, <em>plane_state</em>, <em>crtc_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_state_for_each_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over attached planes in new state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">plane_state</span></code></dt>
<dd>loop cursor for the plane&#8217;s state, must be const</dd>
<dt><code class="docutils literal"><span class="pre">crtc_state</span></code></dt>
<dd>the incoming crtc-state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_for_each_plane()</span></code>, but iterates the planes that will be
attached if the specified state is applied.  Useful during for example
in code called from <a class="reference internal" href="drm-kms.html#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> operations, to
validate the incoming state.</p>
<p>Compared to just <a class="reference internal" href="#c.drm_atomic_crtc_state_for_each_plane" title="drm_atomic_crtc_state_for_each_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_state_for_each_plane()</span></code></a> this also fills in a
const plane_state. This is useful when a driver just wants to peek at other
active planes on this crtc, but does not need to change it.</p>
<dl class="function">
<dt id="c.drm_atomic_plane_disabling">
bool <code class="descname">drm_atomic_plane_disabling</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;old_plane_state</em>, struct <a class="reference internal" href="drm-kms.html#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;new_plane_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_plane_disabling" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether a plane is being disabled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">old_plane_state</span></code></dt>
<dd>old atomic plane state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">new_plane_state</span></code></dt>
<dd>new atomic plane state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks the atomic state of a plane to determine whether it&#8217;s being disabled
or not. This also WARNs if it detects an invalid state (both CRTC and FB
need to either both be NULL or both be non-NULL).</p>
<p><strong>Return</strong></p>
<p>True if the plane is being disabled, false otherwise.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
</div>
<div class="section" id="legacy-crtc-modeset-helper-functions-reference">
<h2>Legacy CRTC/Modeset Helper Functions Reference<a class="headerlink" href="#legacy-crtc-modeset-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="simple-kms-helper-reference">
<h2>Simple KMS Helper Reference<a class="headerlink" href="#simple-kms-helper-reference" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<dl class="type">
<dt id="c.drm_simple_display_pipe_funcs">
struct <code class="descname">drm_simple_display_pipe_funcs</code><a class="headerlink" href="#c.drm_simple_display_pipe_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>helper operations for a simple display pipeline</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_simple_display_pipe_funcs {
  void (* enable) (struct drm_simple_display_pipe *pipe, struct drm_crtc_state *crtc_state);
  void (* disable) (struct drm_simple_display_pipe *pipe);
  int (* check) (struct drm_simple_display_pipe *pipe,struct drm_plane_state *plane_state, struct drm_crtc_state *crtc_state);
  void (* update) (struct drm_simple_display_pipe *pipe, struct drm_plane_state *old_plane_state);
  int (* prepare_fb) (struct drm_simple_display_pipe *pipe, struct drm_plane_state *plane_state);
  void (* cleanup_fb) (struct drm_simple_display_pipe *pipe, struct drm_plane_state *plane_state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enable</span></code></dt>
<dd>This function should be used to enable the pipeline.
It is called when the underlying crtc is enabled.
This hook is optional.</dd>
<dt><code class="docutils literal"><span class="pre">disable</span></code></dt>
<dd>This function should be used to disable the pipeline.
It is called when the underlying crtc is disabled.
This hook is optional.</dd>
<dt><code class="docutils literal"><span class="pre">check</span></code></dt>
<dd><p class="first">This function is called in the check phase of an atomic update,
specifically when the underlying plane is checked.
The simple display pipeline helpers already check that the plane is
not scaled, fills the entire visible area and is always enabled
when the crtc is also enabled.
This hook is optional.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the state or the transition can&#8217;t be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a <a class="reference internal" href="drm-kms.html#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a>
deadlock.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">update</span></code></dt>
<dd><p class="first">This function is called when the underlying plane state is updated.
This hook is optional.</p>
<p class="last">This is the function drivers should submit the
<a class="reference internal" href="drm-kms.html#c.drm_pending_vblank_event" title="drm_pending_vblank_event"><code class="xref c c-type docutils literal"><span class="pre">drm_pending_vblank_event</span></code></a> from. Using either
<code class="xref c c-func docutils literal"><span class="pre">drm_crtc_arm_vblank_event()</span></code>, when the driver supports vblank
interrupt handling, or <code class="xref c c-func docutils literal"><span class="pre">drm_crtc_send_vblank_event()</span></code> directly in case
the hardware lacks vblank support entirely.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">prepare_fb</span></code></dt>
<dd>Optional, called by <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.prepare_fb</span></code></a>.  Please read
the documentation for the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.prepare_fb</span></code></a> hook for
more details.</dd>
<dt><code class="docutils literal"><span class="pre">cleanup_fb</span></code></dt>
<dd>Optional, called by <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.cleanup_fb</span></code></a>.  Please read
the documentation for the <a class="reference internal" href="#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.cleanup_fb</span></code></a> hook for
more details.</dd>
</dl>
<dl class="type">
<dt id="c.drm_simple_display_pipe">
struct <code class="descname">drm_simple_display_pipe</code><a class="headerlink" href="#c.drm_simple_display_pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>simple display pipeline</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_simple_display_pipe {
  struct drm_crtc crtc;
  struct drm_plane plane;
  struct drm_encoder encoder;
  struct drm_connector * connector;
  const struct drm_simple_display_pipe_funcs * funcs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>CRTC control structure</dd>
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>Plane control structure</dd>
<dt><code class="docutils literal"><span class="pre">encoder</span></code></dt>
<dd>Encoder control structure</dd>
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd>Connector control structure</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>Pipeline control functions (optional)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Simple display pipeline with plane, crtc and encoder collapsed into one
entity. It should be initialized by calling <code class="xref c c-func docutils literal"><span class="pre">drm_simple_display_pipe_init()</span></code>.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="fbdev-helper-functions-reference">
<h2>fbdev Helper Functions Reference<a class="headerlink" href="#fbdev-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<dl class="type">
<dt id="c.drm_fb_helper_surface_size">
struct <code class="descname">drm_fb_helper_surface_size</code><a class="headerlink" href="#c.drm_fb_helper_surface_size" title="Permalink to this definition">¶</a></dt>
<dd><p>describes fbdev size and scanout surface size</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_fb_helper_surface_size {
  u32 fb_width;
  u32 fb_height;
  u32 surface_width;
  u32 surface_height;
  u32 surface_bpp;
  u32 surface_depth;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fb_width</span></code></dt>
<dd>fbdev width</dd>
<dt><code class="docutils literal"><span class="pre">fb_height</span></code></dt>
<dd>fbdev height</dd>
<dt><code class="docutils literal"><span class="pre">surface_width</span></code></dt>
<dd>scanout buffer width</dd>
<dt><code class="docutils literal"><span class="pre">surface_height</span></code></dt>
<dd>scanout buffer height</dd>
<dt><code class="docutils literal"><span class="pre">surface_bpp</span></code></dt>
<dd>scanout buffer bpp</dd>
<dt><code class="docutils literal"><span class="pre">surface_depth</span></code></dt>
<dd>scanout buffer depth</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the scanout surface width/height may be larger than the fbdev
width/height.  In case of multiple displays, the scanout surface is sized
according to the largest width/height (so it is large enough for all CRTCs
to scanout).  But the fbdev width/height is sized to the minimum width/
height of all the displays.  This ensures that fbcon fits on the smallest
of the attached displays.</p>
<p>So what is passed to <code class="xref c c-func docutils literal"><span class="pre">drm_fb_helper_fill_var()</span></code> should be fb_width/fb_height,
rather than the surface size.</p>
<dl class="type">
<dt id="c.drm_fb_helper_funcs">
struct <code class="descname">drm_fb_helper_funcs</code><a class="headerlink" href="#c.drm_fb_helper_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>driver callbacks for the fbdev emulation library</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_fb_helper_funcs {
  int (* fb_probe) (struct drm_fb_helper *helper, struct drm_fb_helper_surface_size *sizes);
  bool (* initial_config) (struct drm_fb_helper *fb_helper,struct drm_fb_helper_crtc **crtcs,struct drm_display_mode **modes,struct drm_fb_offset *offsets, bool *enabled, int width, int height);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fb_probe</span></code></dt>
<dd><p class="first">Driver callback to allocate and initialize the fbdev info structure.
Furthermore it also needs to allocate the DRM framebuffer used to
back the fbdev.</p>
<p>This callback is mandatory.</p>
<p>RETURNS:</p>
<p class="last">The driver should return 0 on success and a negative error code on
failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">initial_config</span></code></dt>
<dd><p class="first">Driver callback to setup an initial fbdev display configuration.
Drivers can use this callback to tell the fbdev emulation what the
preferred initial configuration is. This is useful to implement
smooth booting where the fbdev (and subsequently all userspace) never
changes the mode, but always inherits the existing configuration.</p>
<p>This callback is optional.</p>
<p>RETURNS:</p>
<p class="last">The driver should return true if a suitable initial configuration has
been filled out and false when the fbdev helper should fall back to
the default probing logic.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Driver callbacks used by the fbdev emulation helper library.</p>
<dl class="type">
<dt id="c.drm_fb_helper">
struct <code class="descname">drm_fb_helper</code><a class="headerlink" href="#c.drm_fb_helper" title="Permalink to this definition">¶</a></dt>
<dd><p>main structure to emulate fbdev on top of KMS</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_fb_helper {
  struct drm_framebuffer * fb;
  struct drm_device * dev;
  int crtc_count;
  struct drm_fb_helper_crtc * crtc_info;
  int connector_count;
  int connector_info_alloc_count;
  struct drm_fb_helper_connector ** connector_info;
  const struct drm_fb_helper_funcs * funcs;
  struct fb_info * fbdev;
  u32 pseudo_palette;
  struct drm_clip_rect dirty_clip;
  spinlock_t dirty_lock;
  struct work_struct dirty_work;
  struct work_struct resume_work;
  struct mutex lock;
  struct list_head kernel_fb_list;
  bool delayed_hotplug;
  bool deferred_setup;
  int preferred_bpp;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fb</span></code></dt>
<dd>Scanout framebuffer object</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">crtc_count</span></code></dt>
<dd>number of possible CRTCs</dd>
<dt><code class="docutils literal"><span class="pre">crtc_info</span></code></dt>
<dd>per-CRTC helper state (mode, x/y offset, etc)</dd>
<dt><code class="docutils literal"><span class="pre">connector_count</span></code></dt>
<dd>number of connected connectors</dd>
<dt><code class="docutils literal"><span class="pre">connector_info_alloc_count</span></code></dt>
<dd>size of connector_info</dd>
<dt><code class="docutils literal"><span class="pre">connector_info</span></code></dt>
<dd>Array of per-connector information. Do not iterate directly, but use
drm_fb_helper_for_each_connector.</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>driver callbacks for fb helper</dd>
<dt><code class="docutils literal"><span class="pre">fbdev</span></code></dt>
<dd>emulated fbdev device info struct</dd>
<dt><code class="docutils literal"><span class="pre">pseudo_palette</span></code></dt>
<dd>fake palette of 16 colors</dd>
<dt><code class="docutils literal"><span class="pre">dirty_clip</span></code></dt>
<dd>clip rectangle used with deferred_io to accumulate damage to
the screen buffer</dd>
<dt><code class="docutils literal"><span class="pre">dirty_lock</span></code></dt>
<dd>spinlock protecting <strong>dirty_clip</strong></dd>
<dt><code class="docutils literal"><span class="pre">dirty_work</span></code></dt>
<dd>worker used to flush the framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">resume_work</span></code></dt>
<dd>worker used during resume if the console lock is already taken</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd><p class="first">Top-level FBDEV helper lock. This protects all internal data
structures and lists, such as <strong>connector_info</strong> and <strong>crtc_info</strong>.</p>
<p class="last">FIXME: fbdev emulation locking is a mess and long term we want to
protect all helper internal state with this lock as well as reduce
core KMS locking as much as possible.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">kernel_fb_list</span></code></dt>
<dd>Entry on the global kernel_fb_helper_list, used for kgdb entry/exit.</dd>
<dt><code class="docutils literal"><span class="pre">delayed_hotplug</span></code></dt>
<dd>A hotplug was received while fbdev wasn&#8217;t in control of the DRM
device, i.e. another KMS master was active. The output configuration
needs to be reprobe when fbdev is in control again.</dd>
<dt><code class="docutils literal"><span class="pre">deferred_setup</span></code></dt>
<dd><p class="first">If no outputs are connected (disconnected or unknown) the FB helper
code will defer setup until at least one of the outputs shows up.
This field keeps track of the status so that setup can be retried
at every hotplug event until it succeeds eventually.</p>
<p class="last">Protected by <strong>lock</strong>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">preferred_bpp</span></code></dt>
<dd><p class="first">Temporary storage for the driver&#8217;s preferred BPP setting passed to
FB helper initialization. This needs to be tracked so that deferred
FB helper setup can pass this on.</p>
<p class="last">See also: <strong>deferred_setup</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the main structure used by the fbdev helpers. Drivers supporting
fbdev emulation should embedded this into their overall driver structure.
Drivers must also fill out a <a class="reference internal" href="#c.drm_fb_helper_funcs" title="drm_fb_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_fb_helper_funcs</span></code></a> with a few
operations.</p>
<dl class="function">
<dt id="c.DRM_FB_HELPER_DEFAULT_OPS">
<code class="descname">DRM_FB_HELPER_DEFAULT_OPS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_FB_HELPER_DEFAULT_OPS" title="Permalink to this definition">¶</a></dt>
<dd><p>helper define for drm drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>Helper define to register default implementations of drm_fb_helper
functions. To be used in struct fb_ops of drm drivers.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="framebuffer-cma-helper-functions-reference">
<h2>Framebuffer CMA Helper Functions Reference<a class="headerlink" href="#framebuffer-cma-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="bridges">
<span id="drm-bridges"></span><h2>Bridges<a class="headerlink" href="#bridges" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Overview<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="default-bridge-callback-sequence">
<h3>Default bridge callback sequence<a class="headerlink" href="#default-bridge-callback-sequence" title="Permalink to this headline">¶</a></h3>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="bridge-helper-reference">
<h3>Bridge Helper Reference<a class="headerlink" href="#bridge-helper-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_bridge_funcs">
struct <code class="descname">drm_bridge_funcs</code><a class="headerlink" href="#c.drm_bridge_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>drm_bridge control functions</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_bridge_funcs {
  int (* attach) (struct drm_bridge *bridge);
  void (* detach) (struct drm_bridge *bridge);
  enum drm_mode_status (* mode_valid) (struct drm_bridge *crtc, const struct drm_display_mode *mode);
  bool (* mode_fixup) (struct drm_bridge *bridge,const struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);
  void (* disable) (struct drm_bridge *bridge);
  void (* post_disable) (struct drm_bridge *bridge);
  void (* mode_set) (struct drm_bridge *bridge,struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode);
  void (* pre_enable) (struct drm_bridge *bridge);
  void (* enable) (struct drm_bridge *bridge);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">attach</span></code></dt>
<dd><p class="first">This callback is invoked whenever our bridge is being attached to a
<a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a>.</p>
<p>The attach callback is optional.</p>
<p>RETURNS:</p>
<p class="last">Zero on success, error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">detach</span></code></dt>
<dd><p class="first">This callback is invoked whenever our bridge is being detached from a
<a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a>.</p>
<p class="last">The detach callback is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_valid</span></code></dt>
<dd><p class="first">This callback is used to check if a specific mode is valid in this
bridge. This should be implemented if the bridge has some sort of
restriction in the modes it can display. For example, a given bridge
may be responsible to set a clock value. If the clock can not
produce all the values for the available modes then this callback
can be used to restrict the number of modes to only the ones that
can be displayed.</p>
<p>This hook is used by the probe helpers to filter the mode list in
<code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes()</span></code>, and it is used by the
atomic helpers to validate modes supplied by userspace in
<code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_modeset()</span></code>.</p>
<p>This function is optional.</p>
<p>NOTE:</p>
<p>Since this function is both called from the check phase of an atomic
commit, and the mode validation in the probe paths it is not allowed
to look at anything else but the passed-in mode, and validate it
against configuration-invariant hardward constraints. Any further
limits which depend upon the configuration can only be checked in
<strong>mode_fixup</strong>.</p>
<p>RETURNS:</p>
<p class="last">drm_mode_status Enum</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_fixup</span></code></dt>
<dd><p class="first">This callback is used to validate and adjust a mode. The paramater
mode is the display mode that should be fed to the next element in
the display chain, either the final <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a> or the next
<a class="reference internal" href="#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge</span></code></a>. The parameter adjusted_mode is the input mode the bridge
requires. It can be modified by this callback and does not need to
match mode. See also <a class="reference internal" href="drm-kms.html#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a> for more details.</p>
<p>This is the only hook that allows a bridge to reject a modeset. If
this function passes all other callbacks must succeed for this
configuration.</p>
<p>The mode_fixup callback is optional.</p>
<p>NOTE:</p>
<p>This function is called in the check phase of atomic modesets, which
can be aborted for any reason (including on userspace&#8217;s request to
just check whether a configuration would be possible). Drivers MUST
NOT touch any persistent state (hardware or software) or data
structures except the passed in <strong>state</strong> parameter.</p>
<p>Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>. To ensure
that modes are filtered consistently put any bridge constraints and
limits checks into <strong>mode_valid</strong>.</p>
<p>RETURNS:</p>
<p class="last">True if an acceptable configuration is possible, false if the modeset
operation should be rejected.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">disable</span></code></dt>
<dd><p class="first">This callback should disable the bridge. It is called right before
the preceding element in the display pipe is disabled. If the
preceding element is a bridge this means it&#8217;s called before that
bridge&#8217;s <strong>disable</strong> vfunc. If the preceding element is a <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a>
it&#8217;s called right before the <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.disable</span></code></a>,
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.prepare</span></code></a> or <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a>
hook.</p>
<p>The bridge can assume that the display pipe (i.e. clocks and timing
signals) feeding it is still running when this callback is called.</p>
<p class="last">The disable callback is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">post_disable</span></code></dt>
<dd><p class="first">This callback should disable the bridge. It is called right after the
preceding element in the display pipe is disabled. If the preceding
element is a bridge this means it&#8217;s called after that bridge&#8217;s
<strong>post_disable</strong> function. If the preceding element is a <a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a>
it&#8217;s called right after the encoder&#8217;s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.disable</span></code></a>, <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.prepare</span></code></a>
or <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> hook.</p>
<p>The bridge must assume that the display pipe (i.e. clocks and timing
singals) feeding it is no longer running when this callback is
called.</p>
<p class="last">The post_disable callback is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_set</span></code></dt>
<dd>This callback should set the given mode on the bridge. It is called
after the <strong>mode_set</strong> callback for the preceding element in the display
pipeline has been called already. If the bridge is the first element
then this would be <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.mode_set</span></code></a>. The display
pipe (i.e.  clocks and timing signals) is off when this function is
called.</dd>
<dt><code class="docutils literal"><span class="pre">pre_enable</span></code></dt>
<dd><p class="first">This callback should enable the bridge. It is called right before
the preceding element in the display pipe is enabled. If the
preceding element is a bridge this means it&#8217;s called before that
bridge&#8217;s <strong>pre_enable</strong> function. If the preceding element is a
<a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a> it&#8217;s called right before the encoder&#8217;s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.enable</span></code></a>, <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.commit</span></code></a> or
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> hook.</p>
<p>The display pipe (i.e. clocks and timing signals) feeding this bridge
will not yet be running when this callback is called. The bridge must
not enable the display link feeding the next bridge in the chain (if
there is one) when this callback is called.</p>
<p class="last">The pre_enable callback is optional.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">enable</span></code></dt>
<dd><p class="first">This callback should enable the bridge. It is called right after
the preceding element in the display pipe is enabled. If the
preceding element is a bridge this means it&#8217;s called after that
bridge&#8217;s <strong>enable</strong> function. If the preceding element is a
<a class="reference internal" href="drm-kms.html#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a> it&#8217;s called right after the encoder&#8217;s
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.enable</span></code></a>, <a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.commit</span></code></a> or
<a class="reference internal" href="#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.dpms</span></code></a> hook.</p>
<p>The bridge can assume that the display pipe (i.e. clocks and timing
signals) feeding it is running when this callback is called. This
callback must enable the display link feeding the next bridge in the
chain if there is one.</p>
<p class="last">The enable callback is optional.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_bridge">
struct <code class="descname">drm_bridge</code><a class="headerlink" href="#c.drm_bridge" title="Permalink to this definition">¶</a></dt>
<dd><p>central DRM bridge control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_bridge {
  struct drm_device * dev;
  struct drm_encoder * encoder;
  struct drm_bridge * next;
#ifdef CONFIG_OF
  struct device_node * of_node;
#endif
  struct list_head list;
  const struct drm_bridge_funcs * funcs;
  void * driver_private;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device this bridge belongs to</dd>
<dt><code class="docutils literal"><span class="pre">encoder</span></code></dt>
<dd>encoder to which this bridge is connected</dd>
<dt><code class="docutils literal"><span class="pre">next</span></code></dt>
<dd>the next bridge in the encoder chain</dd>
<dt><code class="docutils literal"><span class="pre">of_node</span></code></dt>
<dd>device node pointer to the bridge</dd>
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>to keep track of all added bridges</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>control functions</dd>
<dt><code class="docutils literal"><span class="pre">driver_private</span></code></dt>
<dd>pointer to the bridge driver&#8217;s internal context</dd>
</dl>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="panel-bridge-helper-reference">
<h3>Panel-Bridge Helper Reference<a class="headerlink" href="#panel-bridge-helper-reference" title="Permalink to this headline">¶</a></h3>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
</div>
<div class="section" id="panel-helper-reference">
<span id="drm-panel-helper"></span><h2>Panel Helper Reference<a class="headerlink" href="#panel-helper-reference" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<dl class="type">
<dt id="c.drm_panel_funcs">
struct <code class="descname">drm_panel_funcs</code><a class="headerlink" href="#c.drm_panel_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>perform operations on a given panel</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_panel_funcs {
  int (* disable) (struct drm_panel *panel);
  int (* unprepare) (struct drm_panel *panel);
  int (* prepare) (struct drm_panel *panel);
  int (* enable) (struct drm_panel *panel);
  int (* get_modes) (struct drm_panel *panel);
  int (* get_timings) (struct drm_panel *panel, unsigned int num_timings, struct display_timing *timings);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">disable</span></code></dt>
<dd>disable panel (turn off back light, etc.)</dd>
<dt><code class="docutils literal"><span class="pre">unprepare</span></code></dt>
<dd>turn off panel</dd>
<dt><code class="docutils literal"><span class="pre">prepare</span></code></dt>
<dd>turn on panel and perform set up</dd>
<dt><code class="docutils literal"><span class="pre">enable</span></code></dt>
<dd>enable panel (turn on back light, etc.)</dd>
<dt><code class="docutils literal"><span class="pre">get_modes</span></code></dt>
<dd>add modes to the connector that the panel is attached to and
return the number of modes added</dd>
<dt><code class="docutils literal"><span class="pre">get_timings</span></code></dt>
<dd>copy display timings into the provided array and return
the number of display timings available</dd>
</dl>
<p><strong>Description</strong></p>
<p>The .:c:func:<cite>prepare()</cite> function is typically called before the display controller
starts to transmit video data. Panel drivers can use this to turn the panel
on and wait for it to become ready. If additional configuration is required
(via a control bus such as I2C, SPI or DSI for example) this is a good time
to do that.</p>
<p>After the display controller has started transmitting video data, it&#8217;s safe
to call the .:c:func:<cite>enable()</cite> function. This will typically enable the backlight to
make the image on screen visible. Some panels require a certain amount of
time or frames before the image is displayed. This function is responsible
for taking this into account before enabling the backlight to avoid visual
glitches.</p>
<p>Before stopping video transmission from the display controller it can be
necessary to turn off the panel to avoid visual glitches. This is done in
the .:c:func:<cite>disable()</cite> function. Analogously to .:c:func:<cite>enable()</cite> this typically involves
turning off the backlight and waiting for some time to make sure no image
is visible on the panel. It is then safe for the display controller to
cease transmission of video data.</p>
<p>To save power when no video data is transmitted, a driver can power down
the panel. This is the job of the .:c:func:<cite>unprepare()</cite> function.</p>
<dl class="type">
<dt id="c.drm_panel">
struct <code class="descname">drm_panel</code><a class="headerlink" href="#c.drm_panel" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM panel object</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_panel {
  struct drm_device * drm;
  struct drm_connector * connector;
  struct device * dev;
  const struct drm_panel_funcs * funcs;
  struct list_head list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">drm</span></code></dt>
<dd>DRM device owning the panel</dd>
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd>DRM connector that the panel is attached to</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>parent device of the panel</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>operations that can be performed on the panel</dd>
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>panel entry in registry</dd>
</dl>
<dl class="function">
<dt id="c.drm_panel_unprepare">
int <code class="descname">drm_panel_unprepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em>&nbsp;panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_unprepare" title="Permalink to this definition">¶</a></dt>
<dd><p>power off a panel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt>
<dd>DRM panel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function will completely power off a panel (assert the panel&#8217;s
reset, turn off power supplies, ...). After this function has completed, it
is usually no longer possible to communicate with the panel until another
call to <a class="reference internal" href="#c.drm_panel_prepare" title="drm_panel_prepare"><code class="xref c c-func docutils literal"><span class="pre">drm_panel_prepare()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_panel_disable">
int <code class="descname">drm_panel_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em>&nbsp;panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>disable a panel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt>
<dd>DRM panel</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will typically turn off the panel&#8217;s backlight or disable the display
drivers. For smart panels it should still be possible to communicate with
the integrated circuitry via any command bus after this call.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_panel_prepare">
int <code class="descname">drm_panel_prepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em>&nbsp;panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>power on a panel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt>
<dd>DRM panel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function will enable power and deassert any reset signals to
the panel. After this has completed it is possible to communicate with any
integrated circuitry via a command bus.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_panel_enable">
int <code class="descname">drm_panel_enable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em>&nbsp;panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enable a panel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt>
<dd>DRM panel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function will cause the panel display drivers to be turned on
and the backlight to be enabled. Content will be visible on screen after
this call completes.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_panel_get_modes">
int <code class="descname">drm_panel_get_modes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_panel" title="drm_panel">drm_panel</a> *<em>&nbsp;panel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_panel_get_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>probe the available display modes of a panel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span> <span class="pre">*</span> <span class="pre">panel</span></code></dt>
<dd>DRM panel</dd>
</dl>
<p><strong>Description</strong></p>
<p>The modes probed from the panel are automatically added to the connector
that the panel is attached to.</p>
<p><strong>Return</strong></p>
<p>The number of modes available from the panel on success or a
negative error code on failure.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="display-port-helper-functions-reference">
<h2>Display Port Helper Functions Reference<a class="headerlink" href="#display-port-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<dl class="type">
<dt id="c.drm_dp_aux_msg">
struct <code class="descname">drm_dp_aux_msg</code><a class="headerlink" href="#c.drm_dp_aux_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>DisplayPort AUX channel transaction</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_dp_aux_msg {
  unsigned int address;
  u8 request;
  u8 reply;
  void * buffer;
  size_t size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">address</span></code></dt>
<dd>address of the (first) register to access</dd>
<dt><code class="docutils literal"><span class="pre">request</span></code></dt>
<dd>contains the type of transaction (see DP_AUX_* macros)</dd>
<dt><code class="docutils literal"><span class="pre">reply</span></code></dt>
<dd>upon completion, contains the reply type of the transaction</dd>
<dt><code class="docutils literal"><span class="pre">buffer</span></code></dt>
<dd>pointer to a transmission or reception buffer</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>size of <strong>buffer</strong></dd>
</dl>
<dl class="type">
<dt id="c.drm_dp_aux">
struct <code class="descname">drm_dp_aux</code><a class="headerlink" href="#c.drm_dp_aux" title="Permalink to this definition">¶</a></dt>
<dd><p>DisplayPort AUX channel</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_dp_aux {
  const char * name;
  struct i2c_adapter ddc;
  struct device * dev;
  struct drm_crtc * crtc;
  struct mutex hw_mutex;
  struct work_struct crc_work;
  u8 crc_count;
  ssize_t (* transfer) (struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg);
  unsigned i2c_nack_count;
  unsigned i2c_defer_count;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>user-visible name of this AUX channel and the I2C-over-AUX adapter</dd>
<dt><code class="docutils literal"><span class="pre">ddc</span></code></dt>
<dd>I2C adapter that can be used for I2C-over-AUX communication</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>pointer to struct device that is the parent for this AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>backpointer to the crtc that is currently using this AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">hw_mutex</span></code></dt>
<dd>internal mutex used for locking transfers</dd>
<dt><code class="docutils literal"><span class="pre">crc_work</span></code></dt>
<dd>worker that captures CRCs for each frame</dd>
<dt><code class="docutils literal"><span class="pre">crc_count</span></code></dt>
<dd>counter of captured frame CRCs</dd>
<dt><code class="docutils literal"><span class="pre">transfer</span></code></dt>
<dd>transfers a message representing a single AUX transaction</dd>
<dt><code class="docutils literal"><span class="pre">i2c_nack_count</span></code></dt>
<dd>Counts I2C NACKs, used for DP validation.</dd>
<dt><code class="docutils literal"><span class="pre">i2c_defer_count</span></code></dt>
<dd>Counts I2C DEFERs, used for DP validation.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The .dev field should be set to a pointer to the device that implements
the AUX channel.</p>
<p>The .name field may be used to specify the name of the I2C adapter. If set to
NULL, <code class="xref c c-func docutils literal"><span class="pre">dev_name()</span></code> of .dev will be used.</p>
<p>Drivers provide a hardware-specific implementation of how transactions
are executed via the .:c:func:<cite>transfer()</cite> function. A pointer to a drm_dp_aux_msg
structure describing the transaction is passed into this function. Upon
success, the implementation should return the number of payload bytes
that were transferred, or a negative error-code on failure. Helpers
propagate errors from the .:c:func:<cite>transfer()</cite> function, with the exception of
the -EBUSY error, which causes a transaction to be retried. On a short,
helpers will return -EPROTO to make it simpler to check for failure.</p>
<p>An AUX channel can also be used to transport I2C messages to a sink. A
typical application of that is to access an EDID that&#8217;s present in the
sink device. The .:c:func:<cite>transfer()</cite> function can also be used to execute such
transactions. The <code class="xref c c-func docutils literal"><span class="pre">drm_dp_aux_register()</span></code> function registers an I2C
adapter that can be passed to <code class="xref c c-func docutils literal"><span class="pre">drm_probe_ddc()</span></code>. Upon removal, drivers
should call <code class="xref c c-func docutils literal"><span class="pre">drm_dp_aux_unregister()</span></code> to remove the I2C adapter.
The I2C adapter uses long transfers by default; if a partial response is
received, the adapter will drop down to the size given by the partial
response for this transaction only.</p>
<p>Note that the aux helper code assumes that the .:c:func:<cite>transfer()</cite> function
only modifies the reply field of the drm_dp_aux_msg structure.  The
retry logic and i2c helpers assume this is the case.</p>
<dl class="function">
<dt id="c.drm_dp_dpcd_readb">
ssize_t <code class="descname">drm_dp_dpcd_readb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em>, unsigned int<em>&nbsp;offset</em>, u8 *<em>&nbsp;valuep</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_readb" title="Permalink to this definition">¶</a></dt>
<dd><p>read a single byte from the DPCD</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>address of the register to read</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">valuep</span></code></dt>
<dd>location where the value of the register will be stored</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred (1) on success, or a negative
error code on failure.</p>
<dl class="function">
<dt id="c.drm_dp_dpcd_writeb">
ssize_t <code class="descname">drm_dp_dpcd_writeb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_dp_aux" title="drm_dp_aux">drm_dp_aux</a> *<em>&nbsp;aux</em>, unsigned int<em>&nbsp;offset</em>, u8<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_dpcd_writeb" title="Permalink to this definition">¶</a></dt>
<dd><p>write a single byte to the DPCD</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_dp_aux</span> <span class="pre">*</span> <span class="pre">aux</span></code></dt>
<dd>DisplayPort AUX channel</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>address of the register to write</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">value</span></code></dt>
<dd>value to write to the register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes transferred (1) on success, or a negative
error code on failure.</p>
<dl class="type">
<dt id="c.drm_dp_desc">
struct <code class="descname">drm_dp_desc</code><a class="headerlink" href="#c.drm_dp_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>DP branch/sink device descriptor</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_dp_desc {
  struct drm_dp_dpcd_ident ident;
  u32 quirks;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ident</span></code></dt>
<dd>DP device identification from DPCD 0x400 (sink) or 0x500 (branch).</dd>
<dt><code class="docutils literal"><span class="pre">quirks</span></code></dt>
<dd>Quirks; use <a class="reference internal" href="#c.drm_dp_has_quirk" title="drm_dp_has_quirk"><code class="xref c c-func docutils literal"><span class="pre">drm_dp_has_quirk()</span></code></a> to query for the quirks.</dd>
</dl>
<dl class="type">
<dt id="c.drm_dp_quirk">
enum <code class="descname">drm_dp_quirk</code><a class="headerlink" href="#c.drm_dp_quirk" title="Permalink to this definition">¶</a></dt>
<dd><p>Display Port sink/branch device specific quirks</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DP_DPCD_QUIRK_LIMITED_M_N</span></code></dt>
<dd>The device requires main link attributes Mvid and Nvid to be limited
to 16 bits.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Display Port sink and branch devices in the wild have a variety of bugs, try
to collect them here. The quirks are shared, but it&#8217;s up to the drivers to
implement workarounds for them.</p>
<dl class="function">
<dt id="c.drm_dp_has_quirk">
bool <code class="descname">drm_dp_has_quirk</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_dp_desc" title="drm_dp_desc">drm_dp_desc</a> *<em>&nbsp;desc</em>, enum <a class="reference internal" href="#c.drm_dp_quirk" title="drm_dp_quirk">drm_dp_quirk</a><em>&nbsp;quirk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_dp_has_quirk" title="Permalink to this definition">¶</a></dt>
<dd><p>does the DP device have a specific quirk</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_dp_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>Device decriptor filled by <code class="xref c c-func docutils literal"><span class="pre">drm_dp_read_desc()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_dp_quirk</span> <span class="pre">quirk</span></code></dt>
<dd>Quirk to query for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if DP device identified by <strong>desc</strong> has <strong>quirk</strong>.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="display-port-dual-mode-adaptor-helper-functions-reference">
<h2>Display Port Dual Mode Adaptor Helper Functions Reference<a class="headerlink" href="#display-port-dual-mode-adaptor-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<dl class="type">
<dt id="c.drm_lspcon_mode">
enum <code class="descname">drm_lspcon_mode</code><a class="headerlink" href="#c.drm_lspcon_mode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DRM_LSPCON_MODE_INVALID</span></code></dt>
<dd>No LSPCON.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_LSPCON_MODE_LS</span></code></dt>
<dd>Level shifter mode of LSPCON
which drives DP++ to HDMI 1.4 conversion.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_LSPCON_MODE_PCON</span></code></dt>
<dd>Protocol converter mode of LSPCON
which drives DP++ to HDMI 2.0 active conversion.</dd>
</dl>
<dl class="type">
<dt id="c.drm_dp_dual_mode_type">
enum <code class="descname">drm_dp_dual_mode_type</code><a class="headerlink" href="#c.drm_dp_dual_mode_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of the DP dual mode adaptor</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DRM_DP_DUAL_MODE_NONE</span></code></dt>
<dd>No DP dual mode adaptor</dd>
<dt><code class="docutils literal"><span class="pre">DRM_DP_DUAL_MODE_UNKNOWN</span></code></dt>
<dd>Could be either none or type 1 DVI adaptor</dd>
<dt><code class="docutils literal"><span class="pre">DRM_DP_DUAL_MODE_TYPE1_DVI</span></code></dt>
<dd>Type 1 DVI adaptor</dd>
<dt><code class="docutils literal"><span class="pre">DRM_DP_DUAL_MODE_TYPE1_HDMI</span></code></dt>
<dd>Type 1 HDMI adaptor</dd>
<dt><code class="docutils literal"><span class="pre">DRM_DP_DUAL_MODE_TYPE2_DVI</span></code></dt>
<dd>Type 2 DVI adaptor</dd>
<dt><code class="docutils literal"><span class="pre">DRM_DP_DUAL_MODE_TYPE2_HDMI</span></code></dt>
<dd>Type 2 HDMI adaptor</dd>
<dt><code class="docutils literal"><span class="pre">DRM_DP_DUAL_MODE_LSPCON</span></code></dt>
<dd>Level shifter / protocol converter</dd>
</dl>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="display-port-mst-helper-functions-reference">
<h2>Display Port MST Helper Functions Reference<a class="headerlink" href="#display-port-mst-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<dl class="type">
<dt id="c.drm_dp_vcpi">
struct <code class="descname">drm_dp_vcpi</code><a class="headerlink" href="#c.drm_dp_vcpi" title="Permalink to this definition">¶</a></dt>
<dd><p>Virtual Channel Payload Identifier</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_dp_vcpi {
  int vcpi;
  int pbn;
  int aligned_pbn;
  int num_slots;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">vcpi</span></code></dt>
<dd>Virtual channel ID.</dd>
<dt><code class="docutils literal"><span class="pre">pbn</span></code></dt>
<dd>Payload Bandwidth Number for this channel</dd>
<dt><code class="docutils literal"><span class="pre">aligned_pbn</span></code></dt>
<dd>PBN aligned with slot size</dd>
<dt><code class="docutils literal"><span class="pre">num_slots</span></code></dt>
<dd>number of slots for this PBN</dd>
</dl>
<dl class="type">
<dt id="c.drm_dp_mst_port">
struct <code class="descname">drm_dp_mst_port</code><a class="headerlink" href="#c.drm_dp_mst_port" title="Permalink to this definition">¶</a></dt>
<dd><p>MST port</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_dp_mst_port {
  struct kref kref;
  u8 port_num;
  bool input;
  bool mcs;
  bool ddps;
  u8 pdt;
  bool ldps;
  u8 dpcd_rev;
  u8 num_sdp_streams;
  u8 num_sdp_stream_sinks;
  uint16_t available_pbn;
  struct list_head next;
  struct drm_dp_mst_branch * mstb;
  struct drm_dp_aux aux;
  struct drm_dp_mst_branch * parent;
  struct drm_dp_vcpi vcpi;
  struct drm_connector * connector;
  struct drm_dp_mst_topology_mgr * mgr;
  struct edid * cached_edid;
  bool has_audio;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">kref</span></code></dt>
<dd>reference count for this port.</dd>
<dt><code class="docutils literal"><span class="pre">port_num</span></code></dt>
<dd>port number</dd>
<dt><code class="docutils literal"><span class="pre">input</span></code></dt>
<dd>if this port is an input port.</dd>
<dt><code class="docutils literal"><span class="pre">mcs</span></code></dt>
<dd>message capability status - DP 1.2 spec.</dd>
<dt><code class="docutils literal"><span class="pre">ddps</span></code></dt>
<dd>DisplayPort Device Plug Status - DP 1.2</dd>
<dt><code class="docutils literal"><span class="pre">pdt</span></code></dt>
<dd>Peer Device Type</dd>
<dt><code class="docutils literal"><span class="pre">ldps</span></code></dt>
<dd>Legacy Device Plug Status</dd>
<dt><code class="docutils literal"><span class="pre">dpcd_rev</span></code></dt>
<dd>DPCD revision of device on this port</dd>
<dt><code class="docutils literal"><span class="pre">num_sdp_streams</span></code></dt>
<dd>Number of simultaneous streams</dd>
<dt><code class="docutils literal"><span class="pre">num_sdp_stream_sinks</span></code></dt>
<dd>Number of stream sinks</dd>
<dt><code class="docutils literal"><span class="pre">available_pbn</span></code></dt>
<dd>Available bandwidth for this port.</dd>
<dt><code class="docutils literal"><span class="pre">next</span></code></dt>
<dd>link to next port on this branch device</dd>
<dt><code class="docutils literal"><span class="pre">mstb</span></code></dt>
<dd>branch device attach below this port</dd>
<dt><code class="docutils literal"><span class="pre">aux</span></code></dt>
<dd>i2c aux transport to talk to device connected to this port.</dd>
<dt><code class="docutils literal"><span class="pre">parent</span></code></dt>
<dd>branch device parent of this port</dd>
<dt><code class="docutils literal"><span class="pre">vcpi</span></code></dt>
<dd>Virtual Channel Payload info for this port.</dd>
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd>DRM connector this port is connected to.</dd>
<dt><code class="docutils literal"><span class="pre">mgr</span></code></dt>
<dd>topology manager this port lives under.</dd>
<dt><code class="docutils literal"><span class="pre">cached_edid</span></code></dt>
<dd>for DP logical ports - make tiling work by ensuring
that the EDID for all connectors is read immediately.</dd>
<dt><code class="docutils literal"><span class="pre">has_audio</span></code></dt>
<dd>Tracks whether the sink connector to this port is
audio-capable.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents an MST port endpoint on a device somewhere
in the MST topology.</p>
<dl class="type">
<dt id="c.drm_dp_mst_branch">
struct <code class="descname">drm_dp_mst_branch</code><a class="headerlink" href="#c.drm_dp_mst_branch" title="Permalink to this definition">¶</a></dt>
<dd><p>MST branch device.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_dp_mst_branch {
  struct kref kref;
  u8 rad;
  u8 lct;
  int num_ports;
  int msg_slots;
  struct list_head ports;
  struct drm_dp_mst_port * port_parent;
  struct drm_dp_mst_topology_mgr * mgr;
  struct drm_dp_sideband_msg_tx * tx_slots;
  int last_seqno;
  bool link_address_sent;
  u8 guid;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">kref</span></code></dt>
<dd>reference count for this port.</dd>
<dt><code class="docutils literal"><span class="pre">rad</span></code></dt>
<dd>Relative Address to talk to this branch device.</dd>
<dt><code class="docutils literal"><span class="pre">lct</span></code></dt>
<dd>Link count total to talk to this branch device.</dd>
<dt><code class="docutils literal"><span class="pre">num_ports</span></code></dt>
<dd>number of ports on the branch.</dd>
<dt><code class="docutils literal"><span class="pre">msg_slots</span></code></dt>
<dd>one bit per transmitted msg slot.</dd>
<dt><code class="docutils literal"><span class="pre">ports</span></code></dt>
<dd>linked list of ports on this branch.</dd>
<dt><code class="docutils literal"><span class="pre">port_parent</span></code></dt>
<dd>pointer to the port parent, NULL if toplevel.</dd>
<dt><code class="docutils literal"><span class="pre">mgr</span></code></dt>
<dd>topology manager for this branch device.</dd>
<dt><code class="docutils literal"><span class="pre">tx_slots</span></code></dt>
<dd>transmission slots for this device.</dd>
<dt><code class="docutils literal"><span class="pre">last_seqno</span></code></dt>
<dd>last sequence number used to talk to this.</dd>
<dt><code class="docutils literal"><span class="pre">link_address_sent</span></code></dt>
<dd>if a link address message has been sent to this device yet.</dd>
<dt><code class="docutils literal"><span class="pre">guid</span></code></dt>
<dd>guid for DP 1.2 branch device. port under this branch can be
identified by port #.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents an MST branch device, there is one
primary branch device at the root, along with any other branches connected
to downstream port of parent branches.</p>
<dl class="type">
<dt id="c.drm_dp_mst_topology_mgr">
struct <code class="descname">drm_dp_mst_topology_mgr</code><a class="headerlink" href="#c.drm_dp_mst_topology_mgr" title="Permalink to this definition">¶</a></dt>
<dd><p>DisplayPort MST manager</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_dp_mst_topology_mgr {
  struct drm_private_obj base;
  struct drm_device * dev;
  const struct drm_dp_mst_topology_cbs * cbs;
  int max_dpcd_transaction_bytes;
  struct drm_dp_aux * aux;
  int max_payloads;
  int conn_base_id;
  struct drm_dp_sideband_msg_rx down_rep_recv;
  struct drm_dp_sideband_msg_rx up_req_recv;
  struct mutex lock;
  bool mst_state;
  struct drm_dp_mst_branch * mst_primary;
  u8 dpcd;
  u8 sink_count;
  int pbn_div;
  struct drm_dp_mst_topology_state * state;
  const struct drm_private_state_funcs * funcs;
  struct mutex qlock;
  struct list_head tx_msg_downq;
  struct mutex payload_lock;
  struct drm_dp_vcpi ** proposed_vcpis;
  struct drm_dp_payload * payloads;
  unsigned long payload_mask;
  unsigned long vcpi_mask;
  wait_queue_head_t tx_waitq;
  struct work_struct work;
  struct work_struct tx_work;
  struct list_head destroy_connector_list;
  struct mutex destroy_connector_lock;
  struct work_struct destroy_connector_work;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>Base private object for atomic</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>device pointer for adding i2c devices etc.</dd>
<dt><code class="docutils literal"><span class="pre">cbs</span></code></dt>
<dd>callbacks for connector addition and destruction.</dd>
<dt><code class="docutils literal"><span class="pre">max_dpcd_transaction_bytes</span></code></dt>
<dd>maximum number of bytes to read/write
in one go.</dd>
<dt><code class="docutils literal"><span class="pre">aux</span></code></dt>
<dd>AUX channel for the DP MST connector this topolgy mgr is
controlling.</dd>
<dt><code class="docutils literal"><span class="pre">max_payloads</span></code></dt>
<dd>maximum number of payloads the GPU can generate.</dd>
<dt><code class="docutils literal"><span class="pre">conn_base_id</span></code></dt>
<dd>DRM connector ID this mgr is connected to. Only used
to build the MST connector path value.</dd>
<dt><code class="docutils literal"><span class="pre">down_rep_recv</span></code></dt>
<dd>Message receiver state for down replies. This and
<strong>up_req_recv</strong> are only ever access from the work item, which is
serialised.</dd>
<dt><code class="docutils literal"><span class="pre">up_req_recv</span></code></dt>
<dd>Message receiver state for up requests. This and
<strong>down_rep_recv</strong> are only ever access from the work item, which is
serialised.</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>protects mst state, primary, dpcd.</dd>
<dt><code class="docutils literal"><span class="pre">mst_state</span></code></dt>
<dd>If this manager is enabled for an MST capable port. False
if no MST sink/branch devices is connected.</dd>
<dt><code class="docutils literal"><span class="pre">mst_primary</span></code></dt>
<dd>Pointer to the primary/first branch device.</dd>
<dt><code class="docutils literal"><span class="pre">dpcd</span></code></dt>
<dd>Cache of DPCD for primary port.</dd>
<dt><code class="docutils literal"><span class="pre">sink_count</span></code></dt>
<dd>Sink count from DEVICE_SERVICE_IRQ_VECTOR_ESI0.</dd>
<dt><code class="docutils literal"><span class="pre">pbn_div</span></code></dt>
<dd>PBN to slots divisor.</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>State information for topology manager</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>Atomic helper callbacks</dd>
<dt><code class="docutils literal"><span class="pre">qlock</span></code></dt>
<dd>protects <strong>tx_msg_downq</strong>, the <a class="reference internal" href="#c.drm_dp_mst_branch" title="drm_dp_mst_branch"><code class="xref c c-type docutils literal"><span class="pre">drm_dp_mst_branch.txslost</span></code></a> and
<code class="xref c c-type docutils literal"><span class="pre">drm_dp_sideband_msg_tx.state</span></code> once they are queued</dd>
<dt><code class="docutils literal"><span class="pre">tx_msg_downq</span></code></dt>
<dd>List of pending down replies.</dd>
<dt><code class="docutils literal"><span class="pre">payload_lock</span></code></dt>
<dd>Protect payload information.</dd>
<dt><code class="docutils literal"><span class="pre">proposed_vcpis</span></code></dt>
<dd>Array of pointers for the new VCPI allocation. The
VCPI structure itself is <a class="reference internal" href="#c.drm_dp_mst_port" title="drm_dp_mst_port"><code class="xref c c-type docutils literal"><span class="pre">drm_dp_mst_port.vcpi</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">payloads</span></code></dt>
<dd>Array of payloads.</dd>
<dt><code class="docutils literal"><span class="pre">payload_mask</span></code></dt>
<dd>Elements of <strong>payloads</strong> actually in use. Since
reallocation of active outputs isn&#8217;t possible gaps can be created by
disabling outputs out of order compared to how they&#8217;ve been enabled.</dd>
<dt><code class="docutils literal"><span class="pre">vcpi_mask</span></code></dt>
<dd>Similar to <strong>payload_mask</strong>, but for <strong>proposed_vcpis</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">tx_waitq</span></code></dt>
<dd>Wait to queue stall for the tx worker.</dd>
<dt><code class="docutils literal"><span class="pre">work</span></code></dt>
<dd>Probe work.</dd>
<dt><code class="docutils literal"><span class="pre">tx_work</span></code></dt>
<dd>Sideband transmit worker. This can nest within the main
<strong>work</strong> worker for each transaction <strong>work</strong> launches.</dd>
<dt><code class="docutils literal"><span class="pre">destroy_connector_list</span></code></dt>
<dd>List of to be destroyed connectors.</dd>
<dt><code class="docutils literal"><span class="pre">destroy_connector_lock</span></code></dt>
<dd>Protects <strong>connector_list</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">destroy_connector_work</span></code></dt>
<dd>Work item to destroy connectors. Needed to
avoid locking inversion.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This struct represents the toplevel displayport MST topology manager.
There should be one instance of this for every MST capable DP connector
on the GPU.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="mipi-dsi-helper-functions-reference">
<h2>MIPI DSI Helper Functions Reference<a class="headerlink" href="#mipi-dsi-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<dl class="type">
<dt id="c.mipi_dsi_msg">
struct <code class="descname">mipi_dsi_msg</code><a class="headerlink" href="#c.mipi_dsi_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>read/write DSI buffer</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct mipi_dsi_msg {
  u8 channel;
  u8 type;
  u16 flags;
  size_t tx_len;
  const void * tx_buf;
  size_t rx_len;
  void * rx_buf;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">channel</span></code></dt>
<dd>virtual channel id</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>payload data type</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>flags controlling this message transmission</dd>
<dt><code class="docutils literal"><span class="pre">tx_len</span></code></dt>
<dd>length of <strong>tx_buf</strong></dd>
<dt><code class="docutils literal"><span class="pre">tx_buf</span></code></dt>
<dd>data to be written</dd>
<dt><code class="docutils literal"><span class="pre">rx_len</span></code></dt>
<dd>length of <strong>rx_buf</strong></dd>
<dt><code class="docutils literal"><span class="pre">rx_buf</span></code></dt>
<dd>data to be read, or NULL</dd>
</dl>
<dl class="type">
<dt id="c.mipi_dsi_packet">
struct <code class="descname">mipi_dsi_packet</code><a class="headerlink" href="#c.mipi_dsi_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a MIPI DSI packet in protocol format</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct mipi_dsi_packet {
  size_t size;
  u8 header;
  size_t payload_length;
  const u8 * payload;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>size (in bytes) of the packet</dd>
<dt><code class="docutils literal"><span class="pre">header</span></code></dt>
<dd>the four bytes that make up the header (Data ID, Word Count or
Packet Data, and ECC)</dd>
<dt><code class="docutils literal"><span class="pre">payload_length</span></code></dt>
<dd>number of bytes in the payload</dd>
<dt><code class="docutils literal"><span class="pre">payload</span></code></dt>
<dd>a pointer to a buffer containing the payload, if any</dd>
</dl>
<dl class="type">
<dt id="c.mipi_dsi_host_ops">
struct <code class="descname">mipi_dsi_host_ops</code><a class="headerlink" href="#c.mipi_dsi_host_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>DSI bus operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct mipi_dsi_host_ops {
  int (* attach) (struct mipi_dsi_host *host, struct mipi_dsi_device *dsi);
  int (* detach) (struct mipi_dsi_host *host, struct mipi_dsi_device *dsi);
  ssize_t (* transfer) (struct mipi_dsi_host *host, const struct mipi_dsi_msg *msg);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">attach</span></code></dt>
<dd>attach DSI device to DSI host</dd>
<dt><code class="docutils literal"><span class="pre">detach</span></code></dt>
<dd>detach DSI device from DSI host</dd>
<dt><code class="docutils literal"><span class="pre">transfer</span></code></dt>
<dd>transmit a DSI packet</dd>
</dl>
<p><strong>Description</strong></p>
<p>DSI packets transmitted by .:c:func:<cite>transfer()</cite> are passed in as mipi_dsi_msg
structures. This structure contains information about the type of packet
being transmitted as well as the transmit and receive buffers. When an
error is encountered during transmission, this function will return a
negative error code. On success it shall return the number of bytes
transmitted for write packets or the number of bytes received for read
packets.</p>
<p>Note that typically DSI packet transmission is atomic, so the .:c:func:<cite>transfer()</cite>
function will seldomly return anything other than the number of bytes
contained in the transmit buffer on success.</p>
<dl class="type">
<dt id="c.mipi_dsi_host">
struct <code class="descname">mipi_dsi_host</code><a class="headerlink" href="#c.mipi_dsi_host" title="Permalink to this definition">¶</a></dt>
<dd><p>DSI host device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct mipi_dsi_host {
  struct device * dev;
  const struct mipi_dsi_host_ops * ops;
  struct list_head list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>driver model device node for this DSI host</dd>
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>DSI host operations</dd>
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>list management</dd>
</dl>
<dl class="type">
<dt id="c.mipi_dsi_device_info">
struct <code class="descname">mipi_dsi_device_info</code><a class="headerlink" href="#c.mipi_dsi_device_info" title="Permalink to this definition">¶</a></dt>
<dd><p>template for creating a mipi_dsi_device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct mipi_dsi_device_info {
  char type;
  u32 channel;
  struct device_node * node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>DSI peripheral chip type</dd>
<dt><code class="docutils literal"><span class="pre">channel</span></code></dt>
<dd>DSI virtual channel assigned to peripheral</dd>
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>pointer to OF device node or NULL</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is populated and passed to mipi_dsi_device_new to create a new
DSI device</p>
<dl class="type">
<dt id="c.mipi_dsi_device">
struct <code class="descname">mipi_dsi_device</code><a class="headerlink" href="#c.mipi_dsi_device" title="Permalink to this definition">¶</a></dt>
<dd><p>DSI peripheral device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct mipi_dsi_device {
  struct mipi_dsi_host * host;
  struct device dev;
  char name;
  unsigned int channel;
  unsigned int lanes;
  enum mipi_dsi_pixel_format format;
  unsigned long mode_flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">host</span></code></dt>
<dd>DSI host for this peripheral</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>driver model device node for this peripheral</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>DSI peripheral chip type</dd>
<dt><code class="docutils literal"><span class="pre">channel</span></code></dt>
<dd>virtual channel assigned to the peripheral</dd>
<dt><code class="docutils literal"><span class="pre">lanes</span></code></dt>
<dd>number of active data lanes</dd>
<dt><code class="docutils literal"><span class="pre">format</span></code></dt>
<dd>pixel format for video mode</dd>
<dt><code class="docutils literal"><span class="pre">mode_flags</span></code></dt>
<dd>DSI operation mode related flags</dd>
</dl>
<dl class="function">
<dt id="c.mipi_dsi_pixel_format_to_bpp">
int <code class="descname">mipi_dsi_pixel_format_to_bpp</code><span class="sig-paren">(</span>enum mipi_dsi_pixel_format<em>&nbsp;fmt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mipi_dsi_pixel_format_to_bpp" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain the number of bits per pixel for any given pixel format defined by the MIPI DSI specification</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">mipi_dsi_pixel_format</span> <span class="pre">fmt</span></code></dt>
<dd>MIPI DSI pixel format</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of bits per pixel of the given pixel format.</p>
<dl class="type">
<dt id="c.mipi_dsi_dcs_tear_mode">
enum <code class="descname">mipi_dsi_dcs_tear_mode</code><a class="headerlink" href="#c.mipi_dsi_dcs_tear_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Tearing Effect Output Line mode</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">MIPI_DSI_DCS_TEAR_MODE_VBLANK</span></code></dt>
<dd>the TE output line consists of V-Blanking
information only</dd>
<dt><code class="docutils literal"><span class="pre">MIPI_DSI_DCS_TEAR_MODE_VHBLANK</span></code></dt>
<dd>the TE output line consists of both
V-Blanking and H-Blanking information</dd>
</dl>
<dl class="type">
<dt id="c.mipi_dsi_driver">
struct <code class="descname">mipi_dsi_driver</code><a class="headerlink" href="#c.mipi_dsi_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>DSI driver</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct mipi_dsi_driver {
  struct device_driver driver;
  int(* probe) (struct mipi_dsi_device *dsi);
  int(* remove) (struct mipi_dsi_device *dsi);
  void (* shutdown) (struct mipi_dsi_device *dsi);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">driver</span></code></dt>
<dd>device driver model driver</dd>
<dt><code class="docutils literal"><span class="pre">probe</span></code></dt>
<dd>callback for device binding</dd>
<dt><code class="docutils literal"><span class="pre">remove</span></code></dt>
<dd>callback for device unbinding</dd>
<dt><code class="docutils literal"><span class="pre">shutdown</span></code></dt>
<dd>called at shutdown time to quiesce the device</dd>
</dl>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="output-probing-helper-functions-reference">
<h2>Output Probing Helper Functions Reference<a class="headerlink" href="#output-probing-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="edid-helper-functions-reference">
<h2>EDID Helper Functions Reference<a class="headerlink" href="#edid-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.drm_eld_mnl">
int <code class="descname">drm_eld_mnl</code><span class="sig-paren">(</span>const uint8_t *<em>&nbsp;eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_mnl" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ELD monitor name length in bytes.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt>
<dd>pointer to an eld memory structure with mnl set</dd>
</dl>
<dl class="function">
<dt id="c.drm_eld_sad">
const uint8_t * <code class="descname">drm_eld_sad</code><span class="sig-paren">(</span>const uint8_t *<em>&nbsp;eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_sad" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ELD SAD structures.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt>
<dd>pointer to an eld memory structure with sad_count set</dd>
</dl>
<dl class="function">
<dt id="c.drm_eld_sad_count">
int <code class="descname">drm_eld_sad_count</code><span class="sig-paren">(</span>const uint8_t *<em>&nbsp;eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_sad_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ELD SAD count.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt>
<dd>pointer to an eld memory structure with sad_count set</dd>
</dl>
<dl class="function">
<dt id="c.drm_eld_calc_baseline_block_size">
int <code class="descname">drm_eld_calc_baseline_block_size</code><span class="sig-paren">(</span>const uint8_t *<em>&nbsp;eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_calc_baseline_block_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate baseline block size in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt>
<dd>pointer to an eld memory structure with mnl and sad_count set</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a helper for determining the payload size of the baseline block, in
bytes, for e.g. setting the Baseline_ELD_Len field in the ELD header block.</p>
<dl class="function">
<dt id="c.drm_eld_size">
int <code class="descname">drm_eld_size</code><span class="sig-paren">(</span>const uint8_t *<em>&nbsp;eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ELD size in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt>
<dd>pointer to a complete eld memory structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>The returned value does not include the vendor block. It&#8217;s vendor specific,
and comprises of the remaining bytes in the ELD memory buffer after
<a class="reference internal" href="#c.drm_eld_size" title="drm_eld_size"><code class="xref c c-func docutils literal"><span class="pre">drm_eld_size()</span></code></a> bytes of header and baseline block.</p>
<p>The returned value is guaranteed to be a multiple of 4.</p>
<dl class="function">
<dt id="c.drm_eld_get_spk_alloc">
u8 <code class="descname">drm_eld_get_spk_alloc</code><span class="sig-paren">(</span>const uint8_t *<em>&nbsp;eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_get_spk_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get speaker allocation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt>
<dd>pointer to an ELD memory structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>The returned value is the speakers mask. User has to use <code class="docutils literal"><span class="pre">DRM_ELD_SPEAKER</span></code>
field definitions to identify speakers.</p>
<dl class="function">
<dt id="c.drm_eld_get_conn_type">
u8 <code class="descname">drm_eld_get_conn_type</code><span class="sig-paren">(</span>const uint8_t *<em>&nbsp;eld</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_eld_get_conn_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Get device type hdmi/dp connected</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">eld</span></code></dt>
<dd>pointer to an ELD memory structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller need to use <code class="docutils literal"><span class="pre">DRM_ELD_CONN_TYPE_HDMI</span></code> or <code class="docutils literal"><span class="pre">DRM_ELD_CONN_TYPE_DP</span></code> to
identify the display type connected.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="scdc-helper-functions-reference">
<h2>SCDC Helper Functions Reference<a class="headerlink" href="#scdc-helper-functions-reference" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<dl class="function">
<dt id="c.drm_scdc_readb">
int <code class="descname">drm_scdc_readb</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, u8<em>&nbsp;offset</em>, u8 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_readb" title="Permalink to this definition">¶</a></dt>
<dd><p>read a single byte from SCDC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">offset</span></code></dt>
<dd>offset of register to read</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>return location for the register value</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads a single byte from SCDC. This is a convenience wrapper around the
<code class="xref c c-func docutils literal"><span class="pre">drm_scdc_read()</span></code> function.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_scdc_writeb">
int <code class="descname">drm_scdc_writeb</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, u8<em>&nbsp;offset</em>, u8<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_scdc_writeb" title="Permalink to this definition">¶</a></dt>
<dd><p>write a single byte to SCDC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>I2C adapter</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">offset</span></code></dt>
<dd>offset of register to read</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">value</span></code></dt>
<dd>return location for the register value</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes a single byte to SCDC. This is a convenience wrapper around the
<code class="xref c c-func docutils literal"><span class="pre">drm_scdc_write()</span></code> function.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="rectangle-utilities-reference">
<h2>Rectangle Utilities Reference<a class="headerlink" href="#rectangle-utilities-reference" title="Permalink to this headline">¶</a></h2>
<p>Utility functions to help manage rectangular areas for
clipping, scaling, etc. calculations.</p>
<dl class="type">
<dt id="c.drm_rect">
struct <code class="descname">drm_rect</code><a class="headerlink" href="#c.drm_rect" title="Permalink to this definition">¶</a></dt>
<dd><p>two dimensional rectangle</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_rect {
  int x1;
  int y1;
  int x2;
  int y2;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x1</span></code></dt>
<dd>horizontal starting coordinate (inclusive)</dd>
<dt><code class="docutils literal"><span class="pre">y1</span></code></dt>
<dd>vertical starting coordinate (inclusive)</dd>
<dt><code class="docutils literal"><span class="pre">x2</span></code></dt>
<dd>horizontal ending coordinate (exclusive)</dd>
<dt><code class="docutils literal"><span class="pre">y2</span></code></dt>
<dd>vertical ending coordinate (exclusive)</dd>
</dl>
<dl class="function">
<dt id="c.DRM_RECT_FMT">
<code class="descname">DRM_RECT_FMT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_RECT_FMT" title="Permalink to this definition">¶</a></dt>
<dd><p>printf string for <a class="reference internal" href="#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="function">
<dt id="c.DRM_RECT_ARG">
<code class="descname">DRM_RECT_ARG</code><span class="sig-paren">(</span><em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_RECT_ARG" title="Permalink to this definition">¶</a></dt>
<dd><p>printf arguments for <a class="reference internal" href="#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">r</span></code></dt>
<dd>rectangle struct</dd>
</dl>
<dl class="function">
<dt id="c.DRM_RECT_FP_FMT">
<code class="descname">DRM_RECT_FP_FMT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_RECT_FP_FMT" title="Permalink to this definition">¶</a></dt>
<dd><p>printf string for <a class="reference internal" href="#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a> in 16.16 fixed point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="function">
<dt id="c.DRM_RECT_FP_ARG">
<code class="descname">DRM_RECT_FP_ARG</code><span class="sig-paren">(</span><em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_RECT_FP_ARG" title="Permalink to this definition">¶</a></dt>
<dd><p>printf arguments for <a class="reference internal" href="#c.drm_rect" title="drm_rect"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span></code></a> in 16.16 fixed point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">r</span></code></dt>
<dd>rectangle struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is useful for e.g. printing plane source rectangles, which are in 16.16
fixed point.</p>
<dl class="function">
<dt id="c.drm_rect_adjust_size">
void <code class="descname">drm_rect_adjust_size</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r</em>, int<em>&nbsp;dw</em>, int<em>&nbsp;dh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_adjust_size" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust the size of the rectangle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>rectangle to be adjusted</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">dw</span></code></dt>
<dd>horizontal adjustment</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">dh</span></code></dt>
<dd>vertical adjustment</dd>
</dl>
<p><strong>Description</strong></p>
<p>Change the size of rectangle <strong>r</strong> by <strong>dw</strong> in the horizontal direction,
and by <strong>dh</strong> in the vertical direction, while keeping the center
of <strong>r</strong> stationary.</p>
<p>Positive <strong>dw</strong> and <strong>dh</strong> increase the size, negative values decrease it.</p>
<dl class="function">
<dt id="c.drm_rect_translate">
void <code class="descname">drm_rect_translate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r</em>, int<em>&nbsp;dx</em>, int<em>&nbsp;dy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_translate" title="Permalink to this definition">¶</a></dt>
<dd><p>translate the rectangle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>rectangle to be tranlated</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">dx</span></code></dt>
<dd>horizontal translation</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">dy</span></code></dt>
<dd>vertical translation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move rectangle <strong>r</strong> by <strong>dx</strong> in the horizontal direction,
and by <strong>dy</strong> in the vertical direction.</p>
<dl class="function">
<dt id="c.drm_rect_downscale">
void <code class="descname">drm_rect_downscale</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r</em>, int<em>&nbsp;horz</em>, int<em>&nbsp;vert</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_downscale" title="Permalink to this definition">¶</a></dt>
<dd><p>downscale a rectangle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>rectangle to be downscaled</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">horz</span></code></dt>
<dd>horizontal downscale factor</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vert</span></code></dt>
<dd>vertical downscale factor</dd>
</dl>
<p><strong>Description</strong></p>
<p>Divide the coordinates of rectangle <strong>r</strong> by <strong>horz</strong> and <strong>vert</strong>.</p>
<dl class="function">
<dt id="c.drm_rect_width">
int <code class="descname">drm_rect_width</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_width" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the rectangle width</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>rectangle whose width is returned</dd>
</dl>
<p><strong>Return</strong></p>
<p>The width of the rectangle.</p>
<dl class="function">
<dt id="c.drm_rect_height">
int <code class="descname">drm_rect_height</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_height" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the rectangle height</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>rectangle whose height is returned</dd>
</dl>
<p><strong>Return</strong></p>
<p>The height of the rectangle.</p>
<dl class="function">
<dt id="c.drm_rect_visible">
bool <code class="descname">drm_rect_visible</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_visible" title="Permalink to this definition">¶</a></dt>
<dd><p>determine if the the rectangle is visible</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>rectangle whose visibility is returned</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if the rectangle is visible, <code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
<dl class="function">
<dt id="c.drm_rect_equals">
bool <code class="descname">drm_rect_equals</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r1</em>, const struct <a class="reference internal" href="#c.drm_rect" title="drm_rect">drm_rect</a> *<em>&nbsp;r2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rect_equals" title="Permalink to this definition">¶</a></dt>
<dd><p>determine if two rectangles are equal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r1</span></code></dt>
<dd>first rectangle</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_rect</span> <span class="pre">*</span> <span class="pre">r2</span></code></dt>
<dd>second rectangle</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if the rectangles are equal, <code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="hdmi-infoframes-helper-reference">
<h2>HDMI Infoframes Helper Reference<a class="headerlink" href="#hdmi-infoframes-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>Strictly speaking this is not a DRM helper library but generally useable
by any driver interfacing with HDMI outputs like v4l or alsa drivers.
But it nicely fits into the overall topic of mode setting helper
libraries and hence is also included here.</p>
<dl class="type">
<dt id="c.hdmi_infoframe">
union <code class="descname">hdmi_infoframe</code><a class="headerlink" href="#c.hdmi_infoframe" title="Permalink to this definition">¶</a></dt>
<dd><p>overall union of all abstract infoframe representations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>union hdmi_infoframe {
  struct hdmi_any_infoframe any;
  struct hdmi_avi_infoframe avi;
  struct hdmi_spd_infoframe spd;
  union hdmi_vendor_any_infoframe vendor;
  struct hdmi_audio_infoframe audio;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">any</span></code></dt>
<dd>generic infoframe</dd>
<dt><code class="docutils literal"><span class="pre">avi</span></code></dt>
<dd>avi infoframe</dd>
<dt><code class="docutils literal"><span class="pre">spd</span></code></dt>
<dd>spd infoframe</dd>
<dt><code class="docutils literal"><span class="pre">vendor</span></code></dt>
<dd>union of all vendor infoframes</dd>
<dt><code class="docutils literal"><span class="pre">audio</span></code></dt>
<dd>audio infoframe</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used by the generic pack function. This works since all infoframes
have the same header which also indicates which type of infoframe should be
packed.</p>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="flip-work-helper-reference">
<h2>Flip-work Helper Reference<a class="headerlink" href="#flip-work-helper-reference" title="Permalink to this headline">¶</a></h2>
<p>Util to queue up work to run from work-queue context after flip/vblank.
Typically this can be used to defer unref of framebuffer&#8217;s, cursor
bo&#8217;s, etc until after vblank.  The APIs are all thread-safe.
Moreover, drm_flip_work_queue_task and drm_flip_work_queue can be called
in atomic context.</p>
<dl class="type">
<dt id="c.drm_flip_task">
struct <code class="descname">drm_flip_task</code><a class="headerlink" href="#c.drm_flip_task" title="Permalink to this definition">¶</a></dt>
<dd><p>flip work task</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_flip_task {
  struct list_head node;
  void * data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>list entry element</dd>
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>data to pass to <a class="reference internal" href="#c.drm_flip_work" title="drm_flip_work"><code class="xref c c-type docutils literal"><span class="pre">drm_flip_work.func</span></code></a></dd>
</dl>
<dl class="type">
<dt id="c.drm_flip_work">
struct <code class="descname">drm_flip_work</code><a class="headerlink" href="#c.drm_flip_work" title="Permalink to this definition">¶</a></dt>
<dd><p>flip work queue</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_flip_work {
  const char * name;
  drm_flip_func_t func;
  struct work_struct worker;
  struct list_head queued;
  struct list_head commited;
  spinlock_t lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>debug name</dd>
<dt><code class="docutils literal"><span class="pre">func</span></code></dt>
<dd>callback fxn called for each committed item</dd>
<dt><code class="docutils literal"><span class="pre">worker</span></code></dt>
<dd>worker which calls <strong>func</strong></dd>
<dt><code class="docutils literal"><span class="pre">queued</span></code></dt>
<dd>queued tasks</dd>
<dt><code class="docutils literal"><span class="pre">commited</span></code></dt>
<dd>commited tasks</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>lock to access queued and commited lists</dd>
</dl>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="plane-helper-reference">
<h2>Plane Helper Reference<a class="headerlink" href="#plane-helper-reference" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="auxiliary-modeset-helpers">
<h2>Auxiliary Modeset Helpers<a class="headerlink" href="#auxiliary-modeset-helpers" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="framebuffer-gem-helper-reference">
<h2>Framebuffer GEM Helper Reference<a class="headerlink" href="#framebuffer-gem-helper-reference" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="drm-uapi.html" class="btn btn-neutral float-right" title="Userland interfaces" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drm-kms.html" class="btn btn-neutral" title="Kernel Mode Setting (KMS)" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.15.0-rc7',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>