

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2.2. Digital TV Frontend kABI &mdash; The Linux Kernel 4.15.0-rc7 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel 4.15.0-rc7 documentation" href="../../index.html"/>
        <link rel="up" title="2. Digital TV (DVB) devices" href="dtv-core.html"/>
        <link rel="next" title="2.3. Digital TV Demux kABI" href="dtv-demux.html"/>
        <link rel="prev" title="2.1. Digital TV Common functions" href="dtv-common.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.15.0-rc9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Linux Media Subsystem Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../media_uapi.html">Linux Media Infrastructure userspace API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../media_kapi.html">Media subsystem kernel internal API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="v4l2-core.html">1. Video4Linux devices</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="dtv-core.html">2. Digital TV (DVB) devices</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="dtv-common.html">2.1. Digital TV Common functions</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="">2.2. Digital TV Frontend kABI</a></li>
<li class="toctree-l4"><a class="reference internal" href="dtv-demux.html">2.3. Digital TV Demux kABI</a></li>
<li class="toctree-l4"><a class="reference internal" href="dtv-ca.html">2.4. Digital TV Conditional Access kABI</a></li>
<li class="toctree-l4"><a class="reference internal" href="dtv-net.html">2.5. Digital TV Network kABI</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rc-core.html">3. Remote Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="mc-core.html">4. Media Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="cec-core.html">5. CEC Kernel Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="csi2.html">6. MIPI CSI-2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dvb-drivers/index.html">Linux Digital TV driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../v4l-drivers/index.html">Video4Linux (V4L)  driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cec-drivers/index.html">CEC driver-specific documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Linux Media Subsystem Documentation</a> &raquo;</li>
      
          <li><a href="../media_kapi.html">Media subsystem kernel internal API</a> &raquo;</li>
      
          <li><a href="dtv-core.html">2. Digital TV (DVB) devices</a> &raquo;</li>
      
    <li>2.2. Digital TV Frontend kABI</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/media/kapi/dtv-frontend.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="digital-tv-frontend-kabi">
<h1>2.2. Digital TV Frontend kABI<a class="headerlink" href="#digital-tv-frontend-kabi" title="Permalink to this headline">¶</a></h1>
<div class="section" id="digital-tv-frontend">
<h2>2.2.1. Digital TV Frontend<a class="headerlink" href="#digital-tv-frontend" title="Permalink to this headline">¶</a></h2>
<p>The Digital TV Frontend kABI defines a driver-internal interface for
registering low-level, hardware specific driver to a hardware independent
frontend layer. It is only of interest for Digital TV device driver writers.
The header file for this API is named <code class="docutils literal"><span class="pre">dvb_frontend.h</span></code> and located in
<code class="docutils literal"><span class="pre">drivers/media/dvb-core</span></code>.</p>
<div class="section" id="demodulator-driver">
<h3>2.2.1.1. Demodulator driver<a class="headerlink" href="#demodulator-driver" title="Permalink to this headline">¶</a></h3>
<p>The demodulator driver is responsible to talk with the decoding part of the
hardware. Such driver should implement <code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops</span></code>, with
tells what type of digital TV standards are supported, and points to a
series of functions that allow the DVB core to command the hardware via
the code under <code class="docutils literal"><span class="pre">drivers/media/dvb-core/dvb_frontend.c</span></code>.</p>
<p>A typical example of such struct in a driver <code class="docutils literal"><span class="pre">foo</span></code> is:</p>
<div class="highlight-none"><div class="highlight"><pre>static struct dvb_frontend_ops foo_ops = {
        .delsys = { SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A },
        .info = {
                .name   = &quot;foo DVB-T/T2/C driver&quot;,
                .caps = FE_CAN_FEC_1_2 |
                        FE_CAN_FEC_2_3 |
                        FE_CAN_FEC_3_4 |
                        FE_CAN_FEC_5_6 |
                        FE_CAN_FEC_7_8 |
                        FE_CAN_FEC_AUTO |
                        FE_CAN_QPSK |
                        FE_CAN_QAM_16 |
                        FE_CAN_QAM_32 |
                        FE_CAN_QAM_64 |
                        FE_CAN_QAM_128 |
                        FE_CAN_QAM_256 |
                        FE_CAN_QAM_AUTO |
                        FE_CAN_TRANSMISSION_MODE_AUTO |
                        FE_CAN_GUARD_INTERVAL_AUTO |
                        FE_CAN_HIERARCHY_AUTO |
                        FE_CAN_MUTE_TS |
                        FE_CAN_2G_MODULATION,
                .frequency_min = 42000000, /* Hz */
                .frequency_max = 1002000000, /* Hz */
                .symbol_rate_min = 870000,
                .symbol_rate_max = 11700000
        },
        .init = foo_init,
        .sleep = foo_sleep,
        .release = foo_release,
        .set_frontend = foo_set_frontend,
        .get_frontend = foo_get_frontend,
        .read_status = foo_get_status_and_stats,
        .tune = foo_tune,
        .i2c_gate_ctrl = foo_i2c_gate_ctrl,
        .get_frontend_algo = foo_get_algo,
};
</pre></div>
</div>
<p>A typical example of such struct in a driver <code class="docutils literal"><span class="pre">bar</span></code> meant to be used on
Satellite TV reception is:</p>
<div class="highlight-none"><div class="highlight"><pre>static const struct dvb_frontend_ops bar_ops = {
        .delsys = { SYS_DVBS, SYS_DVBS2 },
        .info = {
                .name           = &quot;Bar DVB-S/S2 demodulator&quot;,
                .frequency_min  = 500000, /* KHz */
                .frequency_max  = 2500000, /* KHz */
                .frequency_stepsize     = 0,
                .symbol_rate_min = 1000000,
                .symbol_rate_max = 45000000,
                .symbol_rate_tolerance = 500,
                .caps = FE_CAN_INVERSION_AUTO |
                        FE_CAN_FEC_AUTO |
                        FE_CAN_QPSK,
        },
        .init = bar_init,
        .sleep = bar_sleep,
        .release = bar_release,
        .set_frontend = bar_set_frontend,
        .get_frontend = bar_get_frontend,
        .read_status = bar_get_status_and_stats,
        .i2c_gate_ctrl = bar_i2c_gate_ctrl,
        .get_frontend_algo = bar_get_algo,
        .tune = bar_tune,

        /* Satellite-specific */
        .diseqc_send_master_cmd = bar_send_diseqc_msg,
        .diseqc_send_burst = bar_send_burst,
        .set_tone = bar_set_tone,
        .set_voltage = bar_set_voltage,
};
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="last arabic simple">
<li>For satellite digital TV standards (DVB-S, DVB-S2, ISDB-S), the
frequencies are specified in kHz, while, for terrestrial and cable
standards, they&#8217;re specified in Hz. Due to that, if the same frontend
supports both types, you&#8217;ll need to have two separate
<code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops</span></code> structures, one for each standard.</li>
<li>The <code class="docutils literal"><span class="pre">.i2c_gate_ctrl</span></code> field is present only when the hardware has
allows controlling an I2C gate (either directly of via some GPIO pin),
in order to remove the tuner from the I2C bus after a channel is
tuned.</li>
<li>All new drivers should implement the
<a class="reference internal" href="#dvbv5-stats"><span>DVBv5 statistics</span></a> via <code class="docutils literal"><span class="pre">.read_status</span></code>.
Yet, there are a number of callbacks meant to get statistics for
signal strength, S/N and UCB. Those are there to provide backward
compatibility with legacy applications that don&#8217;t support the DVBv5
API. Implementing those callbacks are optional. Those callbacks may be
removed in the future, after we have all existing drivers supporting
DVBv5 stats.</li>
<li>Other callbacks are required for satellite TV standards, in order to
control LNBf and DiSEqC: <code class="docutils literal"><span class="pre">.diseqc_send_master_cmd</span></code>,
<code class="docutils literal"><span class="pre">.diseqc_send_burst</span></code>, <code class="docutils literal"><span class="pre">.set_tone</span></code>, <code class="docutils literal"><span class="pre">.set_voltage</span></code>.</li>
</ol>
</div>
<p>The <code class="docutils literal"><span class="pre">drivers/media/dvb-core/dvb_frontend.c</span></code> has a kernel thread with is
responsible for tuning the device. It supports multiple algorithms to
detect a channel, as defined at enum <code class="xref c c-func docutils literal"><span class="pre">dvbfe_algo()</span></code>.</p>
<p>The algorithm to be used is obtained via <code class="docutils literal"><span class="pre">.get_frontend_algo</span></code>. If the driver
doesn&#8217;t fill its field at struct <code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops</span></code>, it will default to
<code class="docutils literal"><span class="pre">DVBFE_ALGO_SW</span></code>, meaning that the dvb-core will do a zigzag when tuning,
e. g. it will try first to use the specified center frequency <code class="docutils literal"><span class="pre">f</span></code>,
then, it will do <code class="docutils literal"><span class="pre">f</span></code> + Δ, <code class="docutils literal"><span class="pre">f</span></code> - Δ, <code class="docutils literal"><span class="pre">f</span></code> + 2 x Δ,
<code class="docutils literal"><span class="pre">f</span></code> - 2 x Δ and so on.</p>
<p>If the hardware has internally a some sort of zigzag algorithm, you should
define a <code class="docutils literal"><span class="pre">.get_frontend_algo</span></code> function that would return <code class="docutils literal"><span class="pre">DVBFE_ALGO_HW</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The core frontend support also supports
a third type (<code class="docutils literal"><span class="pre">DVBFE_ALGO_CUSTOM</span></code>), in order to allow the driver to
define its own hardware-assisted algorithm. Very few hardware need to
use it nowadays. Using <code class="docutils literal"><span class="pre">DVBFE_ALGO_CUSTOM</span></code> require to provide other
function callbacks at struct <code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops</span></code>.</p>
</div>
</div>
<div class="section" id="attaching-frontend-driver-to-the-bridge-driver">
<h3>2.2.1.2. Attaching frontend driver to the bridge driver<a class="headerlink" href="#attaching-frontend-driver-to-the-bridge-driver" title="Permalink to this headline">¶</a></h3>
<p>Before using the Digital TV frontend core, the bridge driver should attach
the frontend demod, tuner and SEC devices and call
<code class="xref c c-func docutils literal"><span class="pre">dvb_register_frontend()</span></code>,
in order to register the new frontend at the subsystem. At device
detach/removal, the bridge driver should call
<code class="xref c c-func docutils literal"><span class="pre">dvb_unregister_frontend()</span></code> to
remove the frontend from the core and then <code class="xref c c-func docutils literal"><span class="pre">dvb_frontend_detach()</span></code>
to free the memory allocated by the frontend drivers.</p>
<p>The drivers should also call <code class="xref c c-func docutils literal"><span class="pre">dvb_frontend_suspend()</span></code> as part of
their handler for the <a class="reference internal" href="../../driver-api/infrastructure.html#c.device_driver" title="device_driver"><code class="xref c c-type docutils literal"><span class="pre">device_driver</span></code></a>.<code class="docutils literal"><span class="pre">suspend()</span></code>, and
<code class="xref c c-func docutils literal"><span class="pre">dvb_frontend_resume()</span></code> as
part of their handler for <a class="reference internal" href="../../driver-api/infrastructure.html#c.device_driver" title="device_driver"><code class="xref c c-type docutils literal"><span class="pre">device_driver</span></code></a>.<code class="docutils literal"><span class="pre">resume()</span></code>.</p>
<p>A few other optional functions are provided to handle some special cases.</p>
</div>
</div>
<div class="section" id="digital-tv-frontend-statistics">
<span id="dvbv5-stats"></span><h2>2.2.2. Digital TV Frontend statistics<a class="headerlink" href="#digital-tv-frontend-statistics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="introduction">
<h3>2.2.2.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h3>
<p>Digital TV frontends provide a range of
<a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#frontend-stat-properties"><span>statistics</span></a> meant to help tuning the device
and measuring the quality of service.</p>
<p>For each statistics measurement, the driver should set the type of scale used,
or <code class="docutils literal"><span class="pre">FE_SCALE_NOT_AVAILABLE</span></code> if the statistics is not available on a given
time. Drivers should also provide the number of statistics for each type.
that&#8217;s usually 1 for most video standards <a class="footnote-reference" href="#f2" id="id1">[1]</a>.</p>
<p>Drivers should initialize each statistic counters with length and
scale at its init code. For example, if the frontend provides signal
strength, it should have, on its init code:</p>
<div class="highlight-none"><div class="highlight"><pre>struct dtv_frontend_properties *c = &amp;state-&gt;fe.dtv_property_cache;

c-&gt;strength.len = 1;
c-&gt;strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
</pre></div>
</div>
<p>And, when the statistics got updated, set the scale:</p>
<div class="highlight-none"><div class="highlight"><pre>c-&gt;strength.stat[0].scale = FE_SCALE_DECIBEL;
c-&gt;strength.stat[0].uvalue = strength;
</pre></div>
</div>
<table class="docutils footnote" frame="void" id="f2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><p class="first">For ISDB-T, it may provide both a global statistics and a per-layer
set of statistics. On such cases, len should be equal to 4. The first
value corresponds to the global stat; the other ones to each layer, e. g.:</p>
<ul class="last simple">
<li>c-&gt;cnr.stat[0] for global S/N carrier ratio,</li>
<li>c-&gt;cnr.stat[1] for Layer A S/N carrier ratio,</li>
<li>c-&gt;cnr.stat[2] for layer B S/N carrier ratio,</li>
<li>c-&gt;cnr.stat[3] for layer C S/N carrier ratio.</li>
</ul>
</td></tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please prefer to use <code class="docutils literal"><span class="pre">FE_SCALE_DECIBEL</span></code> instead of
<code class="docutils literal"><span class="pre">FE_SCALE_RELATIVE</span></code> for signal strength and CNR measurements.</p>
</div>
</div>
<div class="section" id="groups-of-statistics">
<h3>2.2.2.2. Groups of statistics<a class="headerlink" href="#groups-of-statistics" title="Permalink to this headline">¶</a></h3>
<p>There are several groups of statistics currently supported:</p>
<dl class="docutils">
<dt>Signal strength (<a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#dtv-stat-signal-strength"><span>DTV_STAT_SIGNAL_STRENGTH</span></a>)</dt>
<dd><ul class="first simple">
<li>Measures the signal strength level at the analog part of the tuner or
demod.</li>
<li>Typically obtained from the gain applied to the tuner and/or frontend
in order to detect the carrier. When no carrier is detected, the gain is
at the maximum value (so, strength is on its minimal).</li>
<li>As the gain is visible through the set of registers that adjust the gain,
typically, this statistics is always available <a class="footnote-reference" href="#f3" id="id2">[2]</a>.</li>
<li>Drivers should try to make it available all the times, as this statistics
can be used when adjusting an antenna position and to check for troubles
at the cabling.</li>
</ul>
<table class="last docutils footnote" frame="void" id="f3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>On a few devices, the gain keeps floating if no carrier.
On such devices, strength report should check first if carrier is
detected at the tuner (<code class="docutils literal"><span class="pre">FE_HAS_CARRIER</span></code>, see <a class="reference internal" href="../uapi/dvb/frontend-header.html#c.fe_status" title="fe_status"><code class="xref c c-type docutils literal"><span class="pre">fe_status</span></code></a>),
and otherwise return the lowest possible value.</td></tr>
</tbody>
</table>
</dd>
<dt>Carrier Signal to Noise ratio (<a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#dtv-stat-cnr"><span>DTV_STAT_CNR</span></a>)</dt>
<dd><ul class="first last">
<li><p class="first">Signal to Noise ratio for the main carrier.</p>
</li>
<li><p class="first">Signal to Noise measurement depends on the device. On some hardware, is
available when the main carrier is detected. On those hardware, CNR
measurement usually comes from the tuner (e. g. after <code class="docutils literal"><span class="pre">FE_HAS_CARRIER</span></code>,
see <a class="reference internal" href="../uapi/dvb/frontend-header.html#c.fe_status" title="fe_status"><code class="xref c c-type docutils literal"><span class="pre">fe_status</span></code></a>).</p>
<p>On other devices, it requires inner FEC decoding,
as the frontend measures it indirectly from other parameters (e. g. after
<code class="docutils literal"><span class="pre">FE_HAS_VITERBI</span></code>, see <a class="reference internal" href="../uapi/dvb/frontend-header.html#c.fe_status" title="fe_status"><code class="xref c c-type docutils literal"><span class="pre">fe_status</span></code></a>).</p>
<p>Having it available after inner FEC is more common.</p>
</li>
</ul>
</dd>
<dt>Bit counts post-FEC (<a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#dtv-stat-post-error-bit-count"><span>DTV_STAT_POST_ERROR_BIT_COUNT</span></a> and <a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#dtv-stat-post-total-bit-count"><span>DTV_STAT_POST_TOTAL_BIT_COUNT</span></a>)</dt>
<dd><ul class="first last simple">
<li>Those counters measure the number of bits and bit errors errors after
the forward error correction (FEC) on the inner coding block
(after Viterbi, LDPC or other inner code).</li>
<li>Due to its nature, those statistics depend on full coding lock
(e. g. after <code class="docutils literal"><span class="pre">FE_HAS_SYNC</span></code> or after <code class="docutils literal"><span class="pre">FE_HAS_LOCK</span></code>,
see <a class="reference internal" href="../uapi/dvb/frontend-header.html#c.fe_status" title="fe_status"><code class="xref c c-type docutils literal"><span class="pre">fe_status</span></code></a>).</li>
</ul>
</dd>
<dt>Bit counts pre-FEC (<a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#dtv-stat-pre-error-bit-count"><span>DTV_STAT_PRE_ERROR_BIT_COUNT</span></a> and <a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#dtv-stat-pre-total-bit-count"><span>DTV_STAT_PRE_TOTAL_BIT_COUNT</span></a>)</dt>
<dd><ul class="first last simple">
<li>Those counters measure the number of bits and bit errors errors before
the forward error correction (FEC) on the inner coding block
(before Viterbi, LDPC or other inner code).</li>
<li>Not all frontends provide this kind of statistics.</li>
<li>Due to its nature, those statistics depend on inner coding lock (e. g.
after <code class="docutils literal"><span class="pre">FE_HAS_VITERBI</span></code>, see <a class="reference internal" href="../uapi/dvb/frontend-header.html#c.fe_status" title="fe_status"><code class="xref c c-type docutils literal"><span class="pre">fe_status</span></code></a>).</li>
</ul>
</dd>
<dt>Block counts (<a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#dtv-stat-error-block-count"><span>DTV_STAT_ERROR_BLOCK_COUNT</span></a> and <a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#dtv-stat-total-block-count"><span>DTV-STAT_TOTAL_BLOCK_COUNT</span></a>)</dt>
<dd><ul class="first last simple">
<li>Those counters measure the number of blocks and block errors errors after
the forward error correction (FEC) on the inner coding block
(before Viterbi, LDPC or other inner code).</li>
<li>Due to its nature, those statistics depend on full coding lock
(e. g. after <code class="docutils literal"><span class="pre">FE_HAS_SYNC</span></code> or after
<code class="docutils literal"><span class="pre">FE_HAS_LOCK</span></code>, see <a class="reference internal" href="../uapi/dvb/frontend-header.html#c.fe_status" title="fe_status"><code class="xref c c-type docutils literal"><span class="pre">fe_status</span></code></a>).</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All counters should be monotonically increased as they&#8217;re
collected from the hardware.</p>
</div>
<p>A typical example of the logic that handle status and statistics is:</p>
<div class="highlight-none"><div class="highlight"><pre>static int foo_get_status_and_stats(struct dvb_frontend *fe)
{
        struct foo_state *state = fe-&gt;demodulator_priv;
        struct dtv_frontend_properties *c = &amp;fe-&gt;dtv_property_cache;

        int rc;
        enum fe_status *status;

        /* Both status and strength are always available */
        rc = foo_read_status(fe, &amp;status);
        if (rc &lt; 0)
                return rc;

        rc = foo_read_strength(fe);
        if (rc &lt; 0)
                return rc;

        /* Check if CNR is available */
        if (!(fe-&gt;status &amp; FE_HAS_CARRIER))
                return 0;

        rc = foo_read_cnr(fe);
        if (rc &lt; 0)
                return rc;

        /* Check if pre-BER stats are available */
        if (!(fe-&gt;status &amp; FE_HAS_VITERBI))
                return 0;

        rc = foo_get_pre_ber(fe);
        if (rc &lt; 0)
                return rc;

        /* Check if post-BER stats are available */
        if (!(fe-&gt;status &amp; FE_HAS_SYNC))
                return 0;

        rc = foo_get_post_ber(fe);
        if (rc &lt; 0)
                return rc;
}

static const struct dvb_frontend_ops ops = {
        /* ... */
        .read_status = foo_get_status_and_stats,
};
</pre></div>
</div>
</div>
<div class="section" id="statistics-collect">
<h3>2.2.2.3. Statistics collect<a class="headerlink" href="#statistics-collect" title="Permalink to this headline">¶</a></h3>
<p>On almost all frontend hardware, the bit and byte counts are stored by
the hardware after a certain amount of time or after the total bit/block
counter reaches a certain value (usually programable), for example, on
every 1000 ms or after receiving 1,000,000 bits.</p>
<p>So, if you read the registers too soon, you&#8217;ll end by reading the same
value as in the previous reading, causing the monotonic value to be
incremented too often.</p>
<p>Drivers should take the responsibility to avoid too often reads. That
can be done using two approaches:</p>
<div class="section" id="if-the-driver-have-a-bit-that-indicates-when-a-collected-data-is-ready">
<h4>2.2.2.3.1. if the driver have a bit that indicates when a collected data is ready<a class="headerlink" href="#if-the-driver-have-a-bit-that-indicates-when-a-collected-data-is-ready" title="Permalink to this headline">¶</a></h4>
<p>Driver should check such bit before making the statistics available.</p>
<p>An example of such behavior can be found at this code snippet (adapted
from mb86a20s driver&#8217;s logic):</p>
<div class="highlight-none"><div class="highlight"><pre>static int foo_get_pre_ber(struct dvb_frontend *fe)
{
        struct foo_state *state = fe-&gt;demodulator_priv;
        struct dtv_frontend_properties *c = &amp;fe-&gt;dtv_property_cache;
        int rc, bit_error;

        /* Check if the BER measures are already available */
        rc = foo_read_u8(state, 0x54);
        if (rc &lt; 0)
                return rc;

        if (!rc)
                return 0;

        /* Read Bit Error Count */
        bit_error = foo_read_u32(state, 0x55);
        if (bit_error &lt; 0)
                return bit_error;

        /* Read Total Bit Count */
        rc = foo_read_u32(state, 0x51);
        if (rc &lt; 0)
                return rc;

        c-&gt;pre_bit_error.stat[0].scale = FE_SCALE_COUNTER;
        c-&gt;pre_bit_error.stat[0].uvalue += bit_error;
        c-&gt;pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;
        c-&gt;pre_bit_count.stat[0].uvalue += rc;

        return 0;
}
</pre></div>
</div>
</div>
<div class="section" id="if-the-driver-doesn-t-provide-a-statistics-available-check-bit">
<h4>2.2.2.3.2. If the driver doesn&#8217;t provide a statistics available check bit<a class="headerlink" href="#if-the-driver-doesn-t-provide-a-statistics-available-check-bit" title="Permalink to this headline">¶</a></h4>
<p>A few devices, however, may not provide a way to check if the stats are
available (or the way to check it is unknown). They may not even provide
a way to directly read the total number of bits or blocks.</p>
<p>On those devices, the driver need to ensure that it won&#8217;t be reading from
the register too often and/or estimate the total number of bits/blocks.</p>
<p>On such drivers, a typical routine to get statistics would be like
(adapted from dib8000 driver&#8217;s logic):</p>
<div class="highlight-none"><div class="highlight"><pre>struct foo_state {
        /* ... */

        unsigned long per_jiffies_stats;
}

static int foo_get_pre_ber(struct dvb_frontend *fe)
{
        struct foo_state *state = fe-&gt;demodulator_priv;
        struct dtv_frontend_properties *c = &amp;fe-&gt;dtv_property_cache;
        int rc, bit_error;
        u64 bits;

        /* Check if time for stats was elapsed */
        if (!time_after(jiffies, state-&gt;per_jiffies_stats))
                return 0;

        /* Next stat should be collected in 1000 ms */
        state-&gt;per_jiffies_stats = jiffies + msecs_to_jiffies(1000);

        /* Read Bit Error Count */
        bit_error = foo_read_u32(state, 0x55);
        if (bit_error &lt; 0)
                return bit_error;

        /*
         * On this particular frontend, there&#39;s no register that
         * would provide the number of bits per 1000ms sample. So,
         * some function would calculate it based on DTV properties
         */
        bits = get_number_of_bits_per_1000ms(fe);

        c-&gt;pre_bit_error.stat[0].scale = FE_SCALE_COUNTER;
        c-&gt;pre_bit_error.stat[0].uvalue += bit_error;
        c-&gt;pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;
        c-&gt;pre_bit_count.stat[0].uvalue += bits;

        return 0;
}
</pre></div>
</div>
<p>Please notice that, on both cases, we&#8217;re getting the statistics using the
<code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops</span></code> <code class="docutils literal"><span class="pre">.read_status</span></code> callback. The rationale is that
the frontend core will automatically call this function periodically
(usually, 3 times per second, when the frontend is locked).</p>
<p>That warrants that we won&#8217;t miss to collect a counter and increment the
monotonic stats at the right time.</p>
</div>
</div>
</div>
<div class="section" id="digital-tv-frontend-functions-and-types">
<h2>2.2.3. Digital TV Frontend functions and types<a class="headerlink" href="#digital-tv-frontend-functions-and-types" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dtv-demux.html" class="btn btn-neutral float-right" title="2.3. Digital TV Demux kABI" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dtv-common.html" class="btn btn-neutral" title="2.1. Digital TV Common functions" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'4.15.0-rc7',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>