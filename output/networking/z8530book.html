

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Z8530 Programming Guide &mdash; The Linux Kernel 4.15.0-rc7 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel 4.15.0-rc7 documentation" href="../index.html"/>
        <link rel="up" title="Linux Networking Documentation" href="index.html"/>
        <link rel="next" title="MSG_ZEROCOPY" href="msg_zerocopy.html"/>
        <link rel="prev" title="Linux Networking and Network Devices APIs" href="kapi.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.15.0-rc9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Networking Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="batman-adv.html">batman-adv</a></li>
<li class="toctree-l2"><a class="reference internal" href="kapi.html">Linux Networking and Network Devices APIs</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Z8530 Programming Guide</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#driver-modes">Driver Modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-z85230-driver">Using the Z85230 driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#attaching-network-interfaces">Attaching Network Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#configuring-and-activating-the-port">Configuring And Activating The Port</a></li>
<li class="toctree-l3"><a class="reference internal" href="#network-layer-functions">Network Layer Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#porting-the-z8530-driver">Porting The Z8530 Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#known-bugs-and-assumptions">Known Bugs And Assumptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#public-functions-provided">Public Functions Provided</a></li>
<li class="toctree-l3"><a class="reference internal" href="#internal-functions">Internal Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="msg_zerocopy.html">MSG_ZEROCOPY</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Linux Networking Documentation</a> &raquo;</li>
      
    <li>Z8530 Programming Guide</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/networking/z8530book.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="z8530-programming-guide">
<h1>Z8530 Programming Guide<a class="headerlink" href="#z8530-programming-guide" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Alan Cox</td>
</tr>
</tbody>
</table>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The Z85x30 family synchronous/asynchronous controller chips are used on
a large number of cheap network interface cards. The kernel provides a
core interface layer that is designed to make it easy to provide WAN
services using this chip.</p>
<p>The current driver only support synchronous operation. Merging the
asynchronous driver support into this code to allow any Z85x30 device to
be used as both a tty interface and as a synchronous controller is a
project for Linux post the 2.4 release</p>
</div>
<div class="section" id="driver-modes">
<h2>Driver Modes<a class="headerlink" href="#driver-modes" title="Permalink to this headline">¶</a></h2>
<p>The Z85230 driver layer can drive Z8530, Z85C30 and Z85230 devices in
three different modes. Each mode can be applied to an individual channel
on the chip (each chip has two channels).</p>
<p>The PIO synchronous mode supports the most common Z8530 wiring. Here the
chip is interface to the I/O and interrupt facilities of the host
machine but not to the DMA subsystem. When running PIO the Z8530 has
extremely tight timing requirements. Doing high speeds, even with a
Z85230 will be tricky. Typically you should expect to achieve at best
9600 baud with a Z8C530 and 64Kbits with a Z85230.</p>
<p>The DMA mode supports the chip when it is configured to use dual DMA
channels on an ISA bus. The better cards tend to support this mode of
operation for a single channel. With DMA running the Z85230 tops out
when it starts to hit ISA DMA constraints at about 512Kbits. It is worth
noting here that many PC machines hang or crash when the chip is driven
fast enough to hold the ISA bus solid.</p>
<p>Transmit DMA mode uses a single DMA channel. The DMA channel is used for
transmission as the transmit FIFO is smaller than the receive FIFO. it
gives better performance than pure PIO mode but is nowhere near as ideal
as pure DMA mode.</p>
</div>
<div class="section" id="using-the-z85230-driver">
<h2>Using the Z85230 driver<a class="headerlink" href="#using-the-z85230-driver" title="Permalink to this headline">¶</a></h2>
<p>The Z85230 driver provides the back end interface to your board. To
configure a Z8530 interface you need to detect the board and to identify
its ports and interrupt resources. It is also your problem to verify the
resources are available.</p>
<p>Having identified the chip you need to fill in a struct z8530_dev,
which describes each chip. This object must exist until you finally
shutdown the board. Firstly zero the active field. This ensures nothing
goes off without you intending it. The irq field should be set to the
interrupt number of the chip. (Each chip has a single interrupt source
rather than each channel). You are responsible for allocating the
interrupt line. The interrupt handler should be set to
<code class="xref c c-func docutils literal"><span class="pre">z8530_interrupt()</span></code>. The device id should be set to the
z8530_dev structure pointer. Whether the interrupt can be shared or not
is board dependent, and up to you to initialise.</p>
<p>The structure holds two channel structures. Initialise chanA.ctrlio and
chanA.dataio with the address of the control and data ports. You can or
this with Z8530_PORT_SLEEP to indicate your interface needs the 5uS
delay for chip settling done in software. The PORT_SLEEP option is
architecture specific. Other flags may become available on future
platforms, eg for MMIO. Initialise the chanA.irqs to &amp;z8530_nop to
start the chip up as disabled and discarding interrupt events. This
ensures that stray interrupts will be mopped up and not hang the bus.
Set chanA.dev to point to the device structure itself. The private and
name field you may use as you wish. The private field is unused by the
Z85230 layer. The name is used for error reporting and it may thus make
sense to make it match the network name.</p>
<p>Repeat the same operation with the B channel if your chip has both
channels wired to something useful. This isn&#8217;t always the case. If it is
not wired then the I/O values do not matter, but you must initialise
chanB.dev.</p>
<p>If your board has DMA facilities then initialise the txdma and rxdma
fields for the relevant channels. You must also allocate the ISA DMA
channels and do any necessary board level initialisation to configure
them. The low level driver will do the Z8530 and DMA controller
programming but not board specific magic.</p>
<p>Having initialised the device you can then call
<code class="xref c c-func docutils literal"><span class="pre">z8530_init()</span></code>. This will probe the chip and reset it into
a known state. An identification sequence is then run to identify the
chip type. If the checks fail to pass the function returns a non zero
error code. Typically this indicates that the port given is not valid.
After this call the type field of the z8530_dev structure is
initialised to either Z8530, Z85C30 or Z85230 according to the chip
found.</p>
<p>Once you have called z8530_init you can also make use of the utility
function <code class="xref c c-func docutils literal"><span class="pre">z8530_describe()</span></code>. This provides a consistent
reporting format for the Z8530 devices, and allows all the drivers to
provide consistent reporting.</p>
</div>
<div class="section" id="attaching-network-interfaces">
<h2>Attaching Network Interfaces<a class="headerlink" href="#attaching-network-interfaces" title="Permalink to this headline">¶</a></h2>
<p>If you wish to use the network interface facilities of the driver, then
you need to attach a network device to each channel that is present and
in use. In addition to use the generic HDLC you need to follow some
additional plumbing rules. They may seem complex but a look at the
example hostess_sv11 driver should reassure you.</p>
<p>The network device used for each channel should be pointed to by the
netdevice field of each channel. The hdlc-&gt; priv field of the network
device points to your private data - you will need to be able to find
your private data from this.</p>
<p>The way most drivers approach this particular problem is to create a
structure holding the Z8530 device definition and put that into the
private field of the network device. The network device fields of the
channels then point back to the network devices.</p>
<p>If you wish to use the generic HDLC then you need to register the HDLC
device.</p>
<p>Before you register your network device you will also need to provide
suitable handlers for most of the network device callbacks. See the
network device documentation for more details on this.</p>
</div>
<div class="section" id="configuring-and-activating-the-port">
<h2>Configuring And Activating The Port<a class="headerlink" href="#configuring-and-activating-the-port" title="Permalink to this headline">¶</a></h2>
<p>The Z85230 driver provides helper functions and tables to load the port
registers on the Z8530 chips. When programming the register settings for
a channel be aware that the documentation recommends initialisation
orders. Strange things happen when these are not followed.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">z8530_channel_load()</span></code> takes an array of pairs of
initialisation values in an array of u8 type. The first value is the
Z8530 register number. Add 16 to indicate the alternate register bank on
the later chips. The array is terminated by a 255.</p>
<p>The driver provides a pair of public tables. The z8530_hdlc_kilostream
table is for the UK &#8216;Kilostream&#8217; service and also happens to cover most
other end host configurations. The z8530_hdlc_kilostream_85230 table
is the same configuration using the enhancements of the 85230 chip. The
configuration loaded is standard NRZ encoded synchronous data with HDLC
bitstuffing. All of the timing is taken from the other end of the link.</p>
<p>When writing your own tables be aware that the driver internally tracks
register values. It may need to reload values. You should therefore be
sure to set registers 1-7, 9-11, 14 and 15 in all configurations. Where
the register settings depend on DMA selection the driver will update the
bits itself when you open or close. Loading a new table with the
interface open is not recommended.</p>
<p>There are three standard configurations supported by the core code. In
PIO mode the interface is programmed up to use interrupt driven PIO.
This places high demands on the host processor to avoid latency. The
driver is written to take account of latency issues but it cannot avoid
latencies caused by other drivers, notably IDE in PIO mode. Because the
drivers allocate buffers you must also prevent MTU changes while the
port is open.</p>
<p>Once the port is open it will call the rx_function of each channel
whenever a completed packet arrived. This is invoked from interrupt
context and passes you the channel and a network buffer (struct
sk_buff) holding the data. The data includes the CRC bytes so most
users will want to trim the last two bytes before processing the data.
This function is very timing critical. When you wish to simply discard
data the support code provides the function
<code class="xref c c-func docutils literal"><span class="pre">z8530_null_rx()</span></code> to discard the data.</p>
<p>To active PIO mode sending and receiving the <code class="docutils literal"><span class="pre">z8530_sync_open</span></code> is called.
This expects to be passed the network device and the channel. Typically
this is called from your network device open callback. On a failure a
non zero error status is returned.
The <code class="xref c c-func docutils literal"><span class="pre">z8530_sync_close()</span></code> function shuts down a PIO
channel. This must be done before the channel is opened again and before
the driver shuts down and unloads.</p>
<p>The ideal mode of operation is dual channel DMA mode. Here the kernel
driver will configure the board for DMA in both directions. The driver
also handles ISA DMA issues such as controller programming and the
memory range limit for you. This mode is activated by calling the
<code class="xref c c-func docutils literal"><span class="pre">z8530_sync_dma_open()</span></code> function. On failure a non zero
error value is returned. Once this mode is activated it can be shut down
by calling the <code class="xref c c-func docutils literal"><span class="pre">z8530_sync_dma_close()</span></code>. You must call
the close function matching the open mode you used.</p>
<p>The final supported mode uses a single DMA channel to drive the transmit
side. As the Z85C30 has a larger FIFO on the receive channel this tends
to increase the maximum speed a little. This is activated by calling the
<code class="docutils literal"><span class="pre">z8530_sync_txdma_open</span></code>. This returns a non zero error code on failure. The
<code class="xref c c-func docutils literal"><span class="pre">z8530_sync_txdma_close()</span></code> function closes down the Z8530
interface from this mode.</p>
</div>
<div class="section" id="network-layer-functions">
<h2>Network Layer Functions<a class="headerlink" href="#network-layer-functions" title="Permalink to this headline">¶</a></h2>
<p>The Z8530 layer provides functions to queue packets for transmission.
The driver internally buffers the frame currently being transmitted and
one further frame (in order to keep back to back transmission running).
Any further buffering is up to the caller.</p>
<p>The function <code class="xref c c-func docutils literal"><span class="pre">z8530_queue_xmit()</span></code> takes a network buffer
in sk_buff format and queues it for transmission. The caller must
provide the entire packet with the exception of the bitstuffing and CRC.
This is normally done by the caller via the generic HDLC interface
layer. It returns 0 if the buffer has been queued and non zero values
for queue full. If the function accepts the buffer it becomes property
of the Z8530 layer and the caller should not free it.</p>
<p>The function <code class="xref c c-func docutils literal"><span class="pre">z8530_get_stats()</span></code> returns a pointer to an
internally maintained per interface statistics block. This provides most
of the interface code needed to implement the network layer get_stats
callback.</p>
</div>
<div class="section" id="porting-the-z8530-driver">
<h2>Porting The Z8530 Driver<a class="headerlink" href="#porting-the-z8530-driver" title="Permalink to this headline">¶</a></h2>
<p>The Z8530 driver is written to be portable. In DMA mode it makes
assumptions about the use of ISA DMA. These are probably warranted in
most cases as the Z85230 in particular was designed to glue to PC type
machines. The PIO mode makes no real assumptions.</p>
<p>Should you need to retarget the Z8530 driver to another architecture the
only code that should need changing are the port I/O functions. At the
moment these assume PC I/O port accesses. This may not be appropriate
for all platforms. Replacing <code class="xref c c-func docutils literal"><span class="pre">z8530_read_port()</span></code> and
<code class="docutils literal"><span class="pre">z8530_write_port</span></code> is intended to be all that is required to port
this driver layer.</p>
</div>
<div class="section" id="known-bugs-and-assumptions">
<h2>Known Bugs And Assumptions<a class="headerlink" href="#known-bugs-and-assumptions" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>Interrupt Locking</dt>
<dd>The locking in the driver is done via the global cli/sti lock. This
makes for relatively poor SMP performance. Switching this to use a
per device spin lock would probably materially improve performance.</dd>
<dt>Occasional Failures</dt>
<dd>We have reports of occasional failures when run for very long
periods of time and the driver starts to receive junk frames. At the
moment the cause of this is not clear.</dd>
</dl>
</div>
<div class="section" id="public-functions-provided">
<h2>Public Functions Provided<a class="headerlink" href="#public-functions-provided" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
<div class="section" id="internal-functions">
<h2>Internal Functions<a class="headerlink" href="#internal-functions" title="Permalink to this headline">¶</a></h2>
<div class="admonition error">
<p class="first admonition-title">Error</p>
<p class="last">kernel-doc missing</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="msg_zerocopy.html" class="btn btn-neutral float-right" title="MSG_ZEROCOPY" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="kapi.html" class="btn btn-neutral" title="Linux Networking and Network Devices APIs" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'4.15.0-rc7',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>