% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,8pt,english]{sphinxmanual}


\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }


	% Use some font with UTF-8 support with XeLaTeX
        \usepackage{fontspec}
        \setsansfont{DejaVu Serif}
        \setromanfont{DejaVu Sans}
        \setmonofont{DejaVu Sans Mono}

     \usepackage[margin=0.5in, top=1in, bottom=1in]{geometry}
        \usepackage{ifthen}

        % Put notes in color and let them be inside a table
	\definecolor{NoteColor}{RGB}{204,255,255}
	\definecolor{WarningColor}{RGB}{255,204,204}
	\definecolor{AttentionColor}{RGB}{255,255,204}
	\definecolor{ImportantColor}{RGB}{192,255,204}
	\definecolor{OtherColor}{RGB}{204,204,204}
        \newlength{\mynoticelength}
        \makeatletter\newenvironment{coloredbox}[1]{%
	   \setlength{\fboxrule}{1pt}
	   \setlength{\fboxsep}{7pt}
	   \setlength{\mynoticelength}{\linewidth}
	   \addtolength{\mynoticelength}{-2\fboxsep}
	   \addtolength{\mynoticelength}{-2\fboxrule}
           \begin{lrbox}{\@tempboxa}\begin{minipage}{\mynoticelength}}{\end{minipage}\end{lrbox}%
	   \ifthenelse%
	      {\equal{\py@noticetype}{note}}%
	      {\colorbox{NoteColor}{\usebox{\@tempboxa}}}%
	      {%
	         \ifthenelse%
	         {\equal{\py@noticetype}{warning}}%
	         {\colorbox{WarningColor}{\usebox{\@tempboxa}}}%
		 {%
	            \ifthenelse%
	            {\equal{\py@noticetype}{attention}}%
	            {\colorbox{AttentionColor}{\usebox{\@tempboxa}}}%
		    {%
	               \ifthenelse%
	               {\equal{\py@noticetype}{important}}%
	               {\colorbox{ImportantColor}{\usebox{\@tempboxa}}}%
	               {\colorbox{OtherColor}{\usebox{\@tempboxa}}}%
		    }%
		 }%
	      }%
        }\makeatother

        \makeatletter
        \renewenvironment{notice}[2]{%
          \def\py@noticetype{#1}
          \begin{coloredbox}{#1}
          \bf\it
          \par\strong{#2}
          \csname py@noticestart@#1\endcsname
        }
	{
          \csname py@noticeend@\py@noticetype\endcsname
          \end{coloredbox}
        }
	\makeatother

     

\title{Linux GPU Driver Developer's Guide}
\date{March 08, 2018}
\release{4.16.0-rc4+}
\author{The kernel development community}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}

\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{gpu/index::doc}



\chapter{Introduction}
\label{gpu/introduction:introduction}\label{gpu/introduction::doc}\label{gpu/introduction:linux-gpu-driver-developer-s-guide}
The Linux DRM layer contains code intended to support the needs of
complex graphics devices, usually containing programmable pipelines well
suited to 3D graphics acceleration. Graphics drivers in the kernel may
make use of DRM functions to make tasks like memory management,
interrupt handling and DMA easier, and provide a uniform interface to
applications.

A note on versions: this guide covers features found in the DRM tree,
including the TTM memory manager, output configuration and mode setting,
and the new vblank internals, in addition to all the regular features
found in current kernels.

{[}Insert diagram of typical DRM stack here{]}


\section{Style Guidelines}
\label{gpu/introduction:style-guidelines}
For consistency this documentation uses American English. Abbreviations
are written as all-uppercase, for example: DRM, KMS, IOCTL, CRTC, and so
on. To aid in reading, documentations make full use of the markup
characters kerneldoc provides: @parameter for function parameters,
@member for structure members (within the same structure), \&struct structure to
reference structures and function() for functions. These all get automatically
hyperlinked if kerneldoc for the referenced objects exists. When referencing
entries in function vtables (and structure members in general) please use
\&vtable\_name.vfunc. Unfortunately this does not yet yield a direct link to the
member, only the structure.

Except in special situations (to separate locked from unlocked variants)
locking requirements for functions aren't documented in the kerneldoc.
Instead locking should be check at runtime using e.g.
\code{WARN\_ON(!mutex\_is\_locked(...));}. Since it's much easier to ignore
documentation than runtime noise this provides more value. And on top of
that runtime checks do need to be updated when the locking rules change,
increasing the chances that they're correct. Within the documentation
the locking rules should be explained in the relevant structures: Either
in the comment for the lock explaining what it protects, or data fields
need a note about which lock protects them, or both.

Functions which have a non-\code{void} return value should have a section
called ``Returns'' explaining the expected return values in different
cases and their meanings. Currently there's no consensus whether that
section name should be all upper-case or not, and whether it should end
in a colon or not. Go with the file-local style. Other common section
names are ``Notes'' with information for dangerous or tricky corner cases,
and ``FIXME'' where the interface could be cleaned up.

Also read the \DUspan{xref,std,std-ref}{guidelines for the kernel documentation at large}.


\section{Getting Started}
\label{gpu/introduction:getting-started}
Developers interested in helping out with the DRM subsystem are very welcome.
Often people will resort to sending in patches for various issues reported by
checkpatch or sparse. We welcome such contributions.

Anyone looking to kick it up a notch can find a list of janitorial tasks on
the {\hyperref[gpu/todo:todo]{\emph{TODO list}}}.


\section{Contribution Process}
\label{gpu/introduction:contribution-process}
Mostly the DRM subsystem works like any other kernel subsystem, see \DUspan{xref,std,std-ref}{the
main process guidelines and documentation} for how things work.
Here we just document some of the specialities of the GPU subsystem.


\subsection{Feature Merge Deadlines}
\label{gpu/introduction:feature-merge-deadlines}
All feature work must be in the linux-next tree by the -rc6 release of the
current release cycle, otherwise they must be postponed and can't reach the next
merge window. All patches must have landed in the drm-next tree by latest -rc7,
but if your branch is not in linux-next then this must have happened by -rc6
already.

After that point only bugfixes (like after the upstream merge window has closed
with the -rc1 release) are allowed. No new platform enabling or new drivers are
allowed.

This means that there's a blackout-period of about one month where feature work
can't be merged. The recommended way to deal with that is having a -next tree
that's always open, but making sure to not feed it into linux-next during the
blackout period. As an example, drm-misc works like that.


\subsection{Code of Conduct}
\label{gpu/introduction:code-of-conduct}
As a freedesktop.org project, dri-devel, and the DRM community, follows the
Contributor Covenant, found at: \href{https://www.freedesktop.org/wiki/CodeOfConduct}{https://www.freedesktop.org/wiki/CodeOfConduct}

Please conduct yourself in a respectful and civilised manner when
interacting with community members on mailing lists, IRC, or bug
trackers. The community represents the project as a whole, and abusive
or bullying behaviour is not tolerated by the project.


\chapter{DRM Internals}
\label{gpu/drm-internals::doc}\label{gpu/drm-internals:drm-internals}
This chapter documents DRM internals relevant to driver authors and
developers working to add support for the latest features to existing
drivers.

First, we go over some typical driver initialization requirements, like
setting up command buffers, creating an initial output configuration,
and initializing core services. Subsequent sections cover core internals
in more detail, providing implementation notes and examples.

The DRM layer provides several services to graphics drivers, many of
them driven by the application interfaces it provides through libdrm,
the library that wraps most of the DRM ioctls. These include vblank
event handling, memory management, output management, framebuffer
management, command submission \& fencing, suspend/resume support, and
DMA services.


\section{Driver Initialization}
\label{gpu/drm-internals:driver-initialization}
At the core of every DRM driver is a {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{struct drm\_driver}}}} structure. Drivers typically statically initialize
a drm\_driver structure, and then pass it to
{\hyperref[gpu/drm\string-internals:c.drm_dev_alloc]{\emph{\code{drm\_dev\_alloc()}}}} to allocate a device instance. After the
device instance is fully initialized it can be registered (which makes
it accessible from userspace) using {\hyperref[gpu/drm\string-internals:c.drm_dev_register]{\emph{\code{drm\_dev\_register()}}}}.

The {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{struct drm\_driver}}}} structure
contains static information that describes the driver and features it
supports, and pointers to methods that the DRM core will call to
implement the DRM API. We will first go through the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{struct
drm\_driver}}}} static information fields, and will
then describe individual operations in details as they get used in later
sections.


\subsection{Driver Information}
\label{gpu/drm-internals:driver-information}

\subsubsection{Driver Features}
\label{gpu/drm-internals:driver-features}
Drivers inform the DRM core about their requirements and supported
features by setting appropriate flags in the driver\_features field.
Since those flags influence the DRM core behaviour since registration
time, most of them must be set to registering the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{struct
drm\_driver}}}} instance.

u32 driver\_features;
\begin{description}
\item[{DRIVER\_USE\_AGP}] \leavevmode
Driver uses AGP interface, the DRM core will manage AGP resources.

\item[{DRIVER\_LEGACY}] \leavevmode
Denote a legacy driver using shadow attach. Don't use.

\item[{DRIVER\_KMS\_LEGACY\_CONTEXT}] \leavevmode
Used only by nouveau for backwards compatibility with existing userspace.
Don't use.

\item[{DRIVER\_PCI\_DMA}] \leavevmode
Driver is capable of PCI DMA, mapping of PCI DMA buffers to
userspace will be enabled. Deprecated.

\item[{DRIVER\_SG}] \leavevmode
Driver can perform scatter/gather DMA, allocation and mapping of
scatter/gather buffers will be enabled. Deprecated.

\item[{DRIVER\_HAVE\_DMA}] \leavevmode
Driver supports DMA, the userspace DMA API will be supported.
Deprecated.

\item[{DRIVER\_HAVE\_IRQ; DRIVER\_IRQ\_SHARED}] \leavevmode
DRIVER\_HAVE\_IRQ indicates whether the driver has an IRQ handler
managed by the DRM Core. The core will support simple IRQ handler
installation when the flag is set. The installation process is
described in ?.

DRIVER\_IRQ\_SHARED indicates whether the device \& handler support
shared IRQs (note that this is required of PCI drivers).

\item[{DRIVER\_GEM}] \leavevmode
Driver use the GEM memory manager.

\item[{DRIVER\_MODESET}] \leavevmode
Driver supports mode setting interfaces (KMS).

\item[{DRIVER\_PRIME}] \leavevmode
Driver implements DRM PRIME buffer sharing.

\item[{DRIVER\_RENDER}] \leavevmode
Driver supports dedicated render nodes.

\item[{DRIVER\_ATOMIC}] \leavevmode
Driver supports atomic properties. In this case the driver must
implement appropriate obj-\textgreater{}atomic\_get\_property() vfuncs for any
modeset objects with driver specific properties.

\item[{DRIVER\_SYNCOBJ}] \leavevmode
Driver support drm sync objects.

\end{description}


\subsubsection{Major, Minor and Patchlevel}
\label{gpu/drm-internals:major-minor-and-patchlevel}
int major; int minor; int patchlevel;
The DRM core identifies driver versions by a major, minor and patch
level triplet. The information is printed to the kernel log at
initialization time and passed to userspace through the
DRM\_IOCTL\_VERSION ioctl.

The major and minor numbers are also used to verify the requested driver
API version passed to DRM\_IOCTL\_SET\_VERSION. When the driver API
changes between minor versions, applications can call
DRM\_IOCTL\_SET\_VERSION to select a specific version of the API. If the
requested major isn't equal to the driver major, or the requested minor
is larger than the driver minor, the DRM\_IOCTL\_SET\_VERSION call will
return an error. Otherwise the driver's set\_version() method will be
called with the requested version.


\subsubsection{Name, Description and Date}
\label{gpu/drm-internals:name-description-and-date}
char *name; char *desc; char *date;
The driver name is printed to the kernel log at initialization time,
used for IRQ registration and passed to userspace through
DRM\_IOCTL\_VERSION.

The driver description is a purely informative string passed to
userspace through the DRM\_IOCTL\_VERSION ioctl and otherwise unused by
the kernel.

The driver date, formatted as YYYYMMDD, is meant to identify the date of
the latest modification to the driver. However, as most drivers fail to
update it, its value is mostly useless. The DRM core prints it to the
kernel log at initialization time and passes it to userspace through the
DRM\_IOCTL\_VERSION ioctl.


\subsection{Device Instance and Driver Handling}
\label{gpu/drm-internals:device-instance-and-driver-handling}
A device instance for a drm driver is represented by \code{struct drm\_device}. This
is allocated with {\hyperref[gpu/drm\string-internals:c.drm_dev_alloc]{\emph{\code{drm\_dev\_alloc()}}}}, usually from bus-specific -\textgreater{}:c:func:\emph{probe()}
callbacks implemented by the driver. The driver then needs to initialize all
the various subsystems for the drm device like memory management, vblank
handling, modesetting support and intial output configuration plus obviously
initialize all the corresponding hardware bits. An important part of this is
also calling {\hyperref[gpu/drm\string-internals:c.drm_dev_set_unique]{\emph{\code{drm\_dev\_set\_unique()}}}} to set the userspace-visible unique name of
this device instance. Finally when everything is up and running and ready for
userspace the device instance can be published using {\hyperref[gpu/drm\string-internals:c.drm_dev_register]{\emph{\code{drm\_dev\_register()}}}}.

There is also deprecated support for initalizing device instances using
bus-specific helpers and the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.load}}}} callback. But due to
backwards-compatibility needs the device instance have to be published too
early, which requires unpretty global locking to make safe and is therefore
only support for existing drivers not yet converted to the new scheme.

When cleaning up a device instance everything needs to be done in reverse:
First unpublish the device instance with {\hyperref[gpu/drm\string-internals:c.drm_dev_unregister]{\emph{\code{drm\_dev\_unregister()}}}}. Then clean up
any other resources allocated at device initialization and drop the driver's
reference to \code{drm\_device} using {\hyperref[gpu/drm\string-internals:c.drm_dev_put]{\emph{\code{drm\_dev\_put()}}}}.

Note that the lifetime rules for \code{drm\_device} instance has still a lot of
historical baggage. Hence use the reference counting provided by
{\hyperref[gpu/drm\string-internals:c.drm_dev_get]{\emph{\code{drm\_dev\_get()}}}} and {\hyperref[gpu/drm\string-internals:c.drm_dev_put]{\emph{\code{drm\_dev\_put()}}}} only carefully.

It is recommended that drivers embed \code{struct drm\_device} into their own device
structure, which is supported through {\hyperref[gpu/drm\string-internals:c.drm_dev_init]{\emph{\code{drm\_dev\_init()}}}}.
\index{drm\_driver (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_driver}\pysigline{struct \bfcode{drm\_driver}}
DRM driver structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}driver \PYGZob{}
  int (*load) (struct drm\PYGZus{}device *, unsigned long flags);
  int (*open) (struct drm\PYGZus{}device *, struct drm\PYGZus{}file *);
  void (*postclose) (struct drm\PYGZus{}device *, struct drm\PYGZus{}file *);
  void (*lastclose) (struct drm\PYGZus{}device *);
  void (*unload) (struct drm\PYGZus{}device *);
  void (*release) (struct drm\PYGZus{}device *);
  u32 (*get\PYGZus{}vblank\PYGZus{}counter) (struct drm\PYGZus{}device *dev, unsigned int pipe);
  int (*enable\PYGZus{}vblank) (struct drm\PYGZus{}device *dev, unsigned int pipe);
  void (*disable\PYGZus{}vblank) (struct drm\PYGZus{}device *dev, unsigned int pipe);
  bool (*get\PYGZus{}scanout\PYGZus{}position) (struct drm\PYGZus{}device *dev, unsigned int pipe,bool in\PYGZus{}vblank\PYGZus{}irq, int *vpos, int *hpos,ktime\PYGZus{}t *stime, ktime\PYGZus{}t *etime, const struct drm\PYGZus{}display\PYGZus{}mode *mode);
  bool (*get\PYGZus{}vblank\PYGZus{}timestamp) (struct drm\PYGZus{}device *dev, unsigned int pipe,int *max\PYGZus{}error,ktime\PYGZus{}t *vblank\PYGZus{}time, bool in\PYGZus{}vblank\PYGZus{}irq);
  irqreturn\PYGZus{}t(*irq\PYGZus{}handler) (int irq, void *arg);
  void (*irq\PYGZus{}preinstall) (struct drm\PYGZus{}device *dev);
  int (*irq\PYGZus{}postinstall) (struct drm\PYGZus{}device *dev);
  void (*irq\PYGZus{}uninstall) (struct drm\PYGZus{}device *dev);
  int (*master\PYGZus{}create)(struct drm\PYGZus{}device *dev, struct drm\PYGZus{}master *master);
  void (*master\PYGZus{}destroy)(struct drm\PYGZus{}device *dev, struct drm\PYGZus{}master *master);
  int (*master\PYGZus{}set)(struct drm\PYGZus{}device *dev, struct drm\PYGZus{}file *file\PYGZus{}priv, bool from\PYGZus{}open);
  void (*master\PYGZus{}drop)(struct drm\PYGZus{}device *dev, struct drm\PYGZus{}file *file\PYGZus{}priv);
  int (*debugfs\PYGZus{}init)(struct drm\PYGZus{}minor *minor);
  void (*gem\PYGZus{}free\PYGZus{}object) (struct drm\PYGZus{}gem\PYGZus{}object *obj);
  void (*gem\PYGZus{}free\PYGZus{}object\PYGZus{}unlocked) (struct drm\PYGZus{}gem\PYGZus{}object *obj);
  int (*gem\PYGZus{}open\PYGZus{}object) (struct drm\PYGZus{}gem\PYGZus{}object *, struct drm\PYGZus{}file *);
  void (*gem\PYGZus{}close\PYGZus{}object) (struct drm\PYGZus{}gem\PYGZus{}object *, struct drm\PYGZus{}file *);
  void (*gem\PYGZus{}print\PYGZus{}info)(struct drm\PYGZus{}printer *p, unsigned int indent, const struct drm\PYGZus{}gem\PYGZus{}object *obj);
  struct drm\PYGZus{}gem\PYGZus{}object *(*gem\PYGZus{}create\PYGZus{}object)(struct drm\PYGZus{}device *dev, size\PYGZus{}t size);
  int (*prime\PYGZus{}handle\PYGZus{}to\PYGZus{}fd)(struct drm\PYGZus{}device *dev, struct drm\PYGZus{}file *file\PYGZus{}priv, uint32\PYGZus{}t handle, uint32\PYGZus{}t flags, int *prime\PYGZus{}fd);
  int (*prime\PYGZus{}fd\PYGZus{}to\PYGZus{}handle)(struct drm\PYGZus{}device *dev, struct drm\PYGZus{}file *file\PYGZus{}priv, int prime\PYGZus{}fd, uint32\PYGZus{}t *handle);
  struct dma\PYGZus{}buf * (*gem\PYGZus{}prime\PYGZus{}export)(struct drm\PYGZus{}device *dev, struct drm\PYGZus{}gem\PYGZus{}object *obj, int flags);
  struct drm\PYGZus{}gem\PYGZus{}object * (*gem\PYGZus{}prime\PYGZus{}import)(struct drm\PYGZus{}device *dev, struct dma\PYGZus{}buf *dma\PYGZus{}buf);
  int (*gem\PYGZus{}prime\PYGZus{}pin)(struct drm\PYGZus{}gem\PYGZus{}object *obj);
  void (*gem\PYGZus{}prime\PYGZus{}unpin)(struct drm\PYGZus{}gem\PYGZus{}object *obj);
  struct reservation\PYGZus{}object * (*gem\PYGZus{}prime\PYGZus{}res\PYGZus{}obj)( struct drm\PYGZus{}gem\PYGZus{}object *obj);
  struct sg\PYGZus{}table *(*gem\PYGZus{}prime\PYGZus{}get\PYGZus{}sg\PYGZus{}table)(struct drm\PYGZus{}gem\PYGZus{}object *obj);
  struct drm\PYGZus{}gem\PYGZus{}object *(*gem\PYGZus{}prime\PYGZus{}import\PYGZus{}sg\PYGZus{}table)(struct drm\PYGZus{}device *dev,struct dma\PYGZus{}buf\PYGZus{}attachment *attach, struct sg\PYGZus{}table *sgt);
  void *(*gem\PYGZus{}prime\PYGZus{}vmap)(struct drm\PYGZus{}gem\PYGZus{}object *obj);
  void (*gem\PYGZus{}prime\PYGZus{}vunmap)(struct drm\PYGZus{}gem\PYGZus{}object *obj, void *vaddr);
  int (*gem\PYGZus{}prime\PYGZus{}mmap)(struct drm\PYGZus{}gem\PYGZus{}object *obj, struct vm\PYGZus{}area\PYGZus{}struct *vma);
  int (*dumb\PYGZus{}create)(struct drm\PYGZus{}file *file\PYGZus{}priv,struct drm\PYGZus{}device *dev, struct drm\PYGZus{}mode\PYGZus{}create\PYGZus{}dumb *args);
  int (*dumb\PYGZus{}map\PYGZus{}offset)(struct drm\PYGZus{}file *file\PYGZus{}priv,struct drm\PYGZus{}device *dev, uint32\PYGZus{}t handle, uint64\PYGZus{}t *offset);
  int (*dumb\PYGZus{}destroy)(struct drm\PYGZus{}file *file\PYGZus{}priv,struct drm\PYGZus{}device *dev, uint32\PYGZus{}t handle);
  const struct vm\PYGZus{}operations\PYGZus{}struct *gem\PYGZus{}vm\PYGZus{}ops;
  int major;
  int minor;
  int patchlevel;
  char *name;
  char *desc;
  char *date;
  u32 driver\PYGZus{}features;
  const struct drm\PYGZus{}ioctl\PYGZus{}desc *ioctls;
  int num\PYGZus{}ioctls;
  const struct file\PYGZus{}operations *fops;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{load}}] \leavevmode
Backward-compatible driver callback to complete
initialization steps after the driver is registered.  For
this reason, may suffer from race conditions and its use is
deprecated for new drivers.  It is therefore only supported
for existing drivers not yet converted to the new scheme.
See {\hyperref[gpu/drm\string-internals:c.drm_dev_init]{\emph{\code{drm\_dev\_init()}}}} and {\hyperref[gpu/drm\string-internals:c.drm_dev_register]{\emph{\code{drm\_dev\_register()}}}} for proper and
race-free way to set up a \code{struct drm\_device}.

This is deprecated, do not use!

Returns:

Zero on success, non-zero value on failure.

\item[{\code{open}}] \leavevmode
Driver callback when a new {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{struct drm\_file}}}} is opened. Useful for
setting up driver-private data structures like buffer allocators,
execution contexts or similar things. Such driver-private resources
must be released again in \textbf{postclose}.

Since the display/modeset side of DRM can only be owned by exactly
one {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{struct drm\_file}}}} (see {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{drm\_file.is\_master}}}} and \code{drm\_device.master})
there should never be a need to set up any modeset related resources
in this callback. Doing so would be a driver design bug.

Returns:

0 on success, a negative error code on failure, which will be
promoted to userspace as the result of the \code{open()} system call.

\item[{\code{postclose}}] \leavevmode
One of the driver callbacks when a new {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{struct drm\_file}}}} is closed.
Useful for tearing down driver-private data structures allocated in
\textbf{open} like buffer allocators, execution contexts or similar things.

Since the display/modeset side of DRM can only be owned by exactly
one {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{struct drm\_file}}}} (see {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{drm\_file.is\_master}}}} and \code{drm\_device.master})
there should never be a need to tear down any modeset related
resources in this callback. Doing so would be a driver design bug.

\item[{\code{lastclose}}] \leavevmode
Called when the last {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{struct drm\_file}}}} has been closed and there's
currently no userspace client for the \code{struct drm\_device}.

Modern drivers should only use this to force-restore the fbdev
framebuffer using {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_restore_fbdev_mode_unlocked]{\emph{\code{drm\_fb\_helper\_restore\_fbdev\_mode\_unlocked()}}}}.
Anything else would indicate there's something seriously wrong.
Modern drivers can also use this to execute delayed power switching
state changes, e.g. in conjunction with the {\hyperref[gpu/vga\string-switcheroo:vga\string-switcheroo]{\emph{VGA Switcheroo}}}
infrastructure.

This is called after \textbf{postclose} hook has been called.

NOTE:

All legacy drivers use this callback to de-initialize the hardware.
This is purely because of the shadow-attach model, where the DRM
kernel driver does not really own the hardware. Instead ownershipe is
handled with the help of userspace through an inheritedly racy dance
to set/unset the VT into raw mode.

Legacy drivers initialize the hardware in the \textbf{firstopen} callback,
which isn't even called for modern drivers.

\item[{\code{unload}}] \leavevmode
Reverse the effects of the driver load callback.  Ideally,
the clean up performed by the driver should happen in the
reverse order of the initialization.  Similarly to the load
hook, this handler is deprecated and its usage should be
dropped in favor of an open-coded teardown function at the
driver layer.  See {\hyperref[gpu/drm\string-internals:c.drm_dev_unregister]{\emph{\code{drm\_dev\_unregister()}}}} and {\hyperref[gpu/drm\string-internals:c.drm_dev_put]{\emph{\code{drm\_dev\_put()}}}}
for the proper way to remove a \code{struct drm\_device}.

The \code{unload()} hook is called right after unregistering
the device.

\item[{\code{release}}] \leavevmode
Optional callback for destroying device data after the final
reference is released, i.e. the device is being destroyed. Drivers
using this callback are responsible for calling {\hyperref[gpu/drm\string-internals:c.drm_dev_fini]{\emph{\code{drm\_dev\_fini()}}}}
to finalize the device and then freeing the struct themselves.

\item[{\code{get\_vblank\_counter}}] \leavevmode
Driver callback for fetching a raw hardware vblank counter for the
CRTC specified with the pipe argument.  If a device doesn't have a
hardware counter, the driver can simply leave the hook as NULL.
The DRM core will account for missed vblank events while interrupts
where disabled based on system timestamps.

Wraparound handling and loss of events due to modesetting is dealt
with in the DRM core code, as long as drivers call
{\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_off]{\emph{\code{drm\_crtc\_vblank\_off()}}}} and {\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_on]{\emph{\code{drm\_crtc\_vblank\_on()}}}} when disabling or
enabling a CRTC.

This is deprecated and should not be used by new drivers.
Use {\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.get\_vblank\_counter}}}} instead.

Returns:

Raw vblank counter value.

\item[{\code{enable\_vblank}}] \leavevmode
Enable vblank interrupts for the CRTC specified with the pipe
argument.

This is deprecated and should not be used by new drivers.
Use {\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.enable\_vblank}}}} instead.

Returns:

Zero on success, appropriate errno if the given \textbf{crtc}`s vblank
interrupt cannot be enabled.

\item[{\code{disable\_vblank}}] \leavevmode
Disable vblank interrupts for the CRTC specified with the pipe
argument.

This is deprecated and should not be used by new drivers.
Use {\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.disable\_vblank}}}} instead.

\item[{\code{get\_scanout\_position}}] \leavevmode
Called by vblank timestamping code.

Returns the current display scanout position from a crtc, and an
optional accurate \code{ktime\_get()} timestamp of when position was
measured. Note that this is a helper callback which is only used if a
driver uses {\hyperref[gpu/drm\string-kms:c.drm_calc_vbltimestamp_from_scanoutpos]{\emph{\code{drm\_calc\_vbltimestamp\_from\_scanoutpos()}}}} for the
\textbf{get\_vblank\_timestamp} callback.

Parameters:
\begin{description}
\item[{dev:}] \leavevmode
DRM device.

\item[{pipe:}] \leavevmode
Id of the crtc to query.

\item[{in\_vblank\_irq:}] \leavevmode
True when called from {\hyperref[gpu/drm\string-kms:c.drm_crtc_handle_vblank]{\emph{\code{drm\_crtc\_handle\_vblank()}}}}.  Some drivers
need to apply some workarounds for gpu-specific vblank irq quirks
if flag is set.

\item[{vpos:}] \leavevmode
Target location for current vertical scanout position.

\item[{hpos:}] \leavevmode
Target location for current horizontal scanout position.

\item[{stime:}] \leavevmode
Target location for timestamp taken immediately before
scanout position query. Can be NULL to skip timestamp.

\item[{etime:}] \leavevmode
Target location for timestamp taken immediately after
scanout position query. Can be NULL to skip timestamp.

\item[{mode:}] \leavevmode
Current display timings.

\end{description}

Returns vpos as a positive number while in active scanout area.
Returns vpos as a negative number inside vblank, counting the number
of scanlines to go until end of vblank, e.g., -1 means ``one scanline
until start of active scanout / end of vblank.''

Returns:

True on success, false if a reliable scanout position counter could
not be read out.

FIXME:

Since this is a helper to implement \textbf{get\_vblank\_timestamp}, we should
move it to {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{\code{struct drm\_crtc\_helper\_funcs}}}}, like all the other
helper-internal hooks.

\item[{\code{get\_vblank\_timestamp}}] \leavevmode
Called by \code{drm\_get\_last\_vbltimestamp()}. Should return a precise
timestamp when the most recent VBLANK interval ended or will end.

Specifically, the timestamp in \textbf{vblank\_time} should correspond as
closely as possible to the time when the first video scanline of
the video frame after the end of VBLANK will start scanning out,
the time immediately after end of the VBLANK interval. If the
\textbf{crtc} is currently inside VBLANK, this will be a time in the future.
If the \textbf{crtc} is currently scanning out a frame, this will be the
past start time of the current scanout. This is meant to adhere
to the OpenML OML\_sync\_control extension specification.

Paramters:
\begin{description}
\item[{dev:}] \leavevmode
dev DRM device handle.

\item[{pipe:}] \leavevmode
crtc for which timestamp should be returned.

\item[{max\_error:}] \leavevmode
Maximum allowable timestamp error in nanoseconds.
Implementation should strive to provide timestamp
with an error of at most max\_error nanoseconds.
Returns true upper bound on error for timestamp.

\item[{vblank\_time:}] \leavevmode
Target location for returned vblank timestamp.

\item[{in\_vblank\_irq:}] \leavevmode
True when called from {\hyperref[gpu/drm\string-kms:c.drm_crtc_handle_vblank]{\emph{\code{drm\_crtc\_handle\_vblank()}}}}.  Some drivers
need to apply some workarounds for gpu-specific vblank irq quirks
if flag is set.

\end{description}

Returns:

True on success, false on failure, which means the core should
fallback to a simple timestamp taken in {\hyperref[gpu/drm\string-kms:c.drm_crtc_handle_vblank]{\emph{\code{drm\_crtc\_handle\_vblank()}}}}.

FIXME:

We should move this hook to {\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{struct drm\_crtc\_funcs}}}} like all the other
vblank hooks.

\item[{\code{irq\_handler}}] \leavevmode
Interrupt handler called when using {\hyperref[gpu/drm\string-internals:c.drm_irq_install]{\emph{\code{drm\_irq\_install()}}}}. Not used by
drivers which implement their own interrupt handling.

\item[{\code{irq\_preinstall}}] \leavevmode
Optional callback used by {\hyperref[gpu/drm\string-internals:c.drm_irq_install]{\emph{\code{drm\_irq\_install()}}}} which is called before
the interrupt handler is registered. This should be used to clear out
any pending interrupts (from e.g. firmware based drives) and reset
the interrupt handling registers.

\item[{\code{irq\_postinstall}}] \leavevmode
Optional callback used by {\hyperref[gpu/drm\string-internals:c.drm_irq_install]{\emph{\code{drm\_irq\_install()}}}} which is called after
the interrupt handler is registered. This should be used to enable
interrupt generation in the hardware.

\item[{\code{irq\_uninstall}}] \leavevmode
Optional callback used by {\hyperref[gpu/drm\string-internals:c.drm_irq_uninstall]{\emph{\code{drm\_irq\_uninstall()}}}} which is called before
the interrupt handler is unregistered. This should be used to disable
interrupt generation in the hardware.

\item[{\code{master\_create}}] \leavevmode
Called whenever a new master is created. Only used by vmwgfx.

\item[{\code{master\_destroy}}] \leavevmode
Called whenever a master is destroyed. Only used by vmwgfx.

\item[{\code{master\_set}}] \leavevmode
Called whenever the minor master is set. Only used by vmwgfx.

\item[{\code{master\_drop}}] \leavevmode
Called whenever the minor master is dropped. Only used by vmwgfx.

\item[{\code{debugfs\_init}}] \leavevmode
Allows drivers to create driver-specific debugfs files.

\item[{\code{gem\_free\_object}}] \leavevmode
deconstructor for drm\_gem\_objects

This is deprecated and should not be used by new drivers. Use
\textbf{gem\_free\_object\_unlocked} instead.

\item[{\code{gem\_free\_object\_unlocked}}] \leavevmode
deconstructor for drm\_gem\_objects

This is for drivers which are not encumbered with \code{drm\_device.struct\_mutex}
legacy locking schemes. Use this hook instead of \textbf{gem\_free\_object}.

\item[{\code{gem\_open\_object}}] \leavevmode
Driver hook called upon gem handle creation

\item[{\code{gem\_close\_object}}] \leavevmode
Driver hook called upon gem handle release

\item[{\code{gem\_print\_info}}] \leavevmode
If driver subclasses struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{\code{drm\_gem\_object}}}}, it can implement this
optional hook for printing additional driver specific info.

{\hyperref[gpu/drm\string-internals:c.drm_printf_indent]{\emph{\code{drm\_printf\_indent()}}}} should be used in the callback passing it the
indent argument.

This callback is called from \code{drm\_gem\_print\_info()}.

\item[{\code{gem\_create\_object}}] \leavevmode
constructor for gem objects

Hook for allocating the GEM object struct, for use by core
helpers.

\item[{\code{prime\_handle\_to\_fd}}] \leavevmode
export handle -\textgreater{} fd (see {\hyperref[gpu/drm\string-mm:c.drm_gem_prime_handle_to_fd]{\emph{\code{drm\_gem\_prime\_handle\_to\_fd()}}}} helper)

\item[{\code{prime\_fd\_to\_handle}}] \leavevmode
import fd -\textgreater{} handle (see {\hyperref[gpu/drm\string-mm:c.drm_gem_prime_fd_to_handle]{\emph{\code{drm\_gem\_prime\_fd\_to\_handle()}}}} helper)

\item[{\code{gem\_prime\_export}}] \leavevmode
export GEM -\textgreater{} dmabuf

\item[{\code{gem\_prime\_import}}] \leavevmode
import dmabuf -\textgreater{} GEM

\item[{\code{dumb\_create}}] \leavevmode
This creates a new dumb buffer in the driver's backing storage manager (GEM,
TTM or something else entirely) and returns the resulting buffer handle. This
handle can then be wrapped up into a framebuffer modeset object.

Note that userspace is not allowed to use such objects for render
acceleration - drivers must create their own private ioctls for such a use
case.

Width, height and depth are specified in the \code{drm\_mode\_create\_dumb}
argument. The callback needs to fill the handle, pitch and size for
the created buffer.

Called by the user via ioctl.

Returns:

Zero on success, negative errno on failure.

\item[{\code{dumb\_map\_offset}}] \leavevmode
Allocate an offset in the drm device node's address space to be able to
memory map a dumb buffer. GEM-based drivers must use
{\hyperref[gpu/drm\string-mm:c.drm_gem_create_mmap_offset]{\emph{\code{drm\_gem\_create\_mmap\_offset()}}}} to implement this.

Called by the user via ioctl.

Returns:

Zero on success, negative errno on failure.

\item[{\code{dumb\_destroy}}] \leavevmode
This destroys the userspace handle for the given dumb backing storage buffer.
Since buffer objects must be reference counted in the kernel a buffer object
won't be immediately freed if a framebuffer modeset object still uses it.

Called by the user via ioctl.

Returns:

Zero on success, negative errno on failure.

\item[{\code{gem\_vm\_ops}}] \leavevmode
Driver private ops for this object

\item[{\code{major}}] \leavevmode
driver major number

\item[{\code{minor}}] \leavevmode
driver minor number

\item[{\code{patchlevel}}] \leavevmode
driver patch level

\item[{\code{name}}] \leavevmode
driver name

\item[{\code{desc}}] \leavevmode
driver description

\item[{\code{date}}] \leavevmode
driver date

\item[{\code{driver\_features}}] \leavevmode
driver features

\item[{\code{ioctls}}] \leavevmode
Array of driver-private IOCTL description entries. See the chapter on
{\hyperref[gpu/drm\string-uapi:drm\string-driver\string-ioctl]{\emph{IOCTL support in the userland interfaces
chapter}}} for the full details.

\item[{\code{num\_ioctls}}] \leavevmode
Number of entries in \textbf{ioctls}.

\item[{\code{fops}}] \leavevmode
File operations for the DRM device node. See the discussion in
{\hyperref[gpu/drm\string-internals:drm\string-driver\string-fops]{\emph{file operations}}} for in-depth coverage and
some examples.

\end{description}

\textbf{Description}

This structure represent the common code for a family of cards. There will
one drm\_device for each card present in this family. It contains lots of
vfunc entries, and a pile of those probably should be moved to more
appropriate places like {\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs}}}} or into a new operations
structure for GEM drivers.
\index{drm\_dev\_is\_unplugged (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_dev_is_unplugged}\pysiglinewithargsret{int \bfcode{drm\_dev\_is\_unplugged}}{struct drm\_device *\emph{ dev}}{}
is a DRM device unplugged

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

This function can be called to check whether a hotpluggable is unplugged.
Unplugging itself is singalled through {\hyperref[gpu/drm\string-internals:c.drm_dev_unplug]{\emph{\code{drm\_dev\_unplug()}}}}. If a device is
unplugged, these two functions guarantee that any store before calling
{\hyperref[gpu/drm\string-internals:c.drm_dev_unplug]{\emph{\code{drm\_dev\_unplug()}}}} is visible to callers of this function after it completes
\index{drm\_put\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_put_dev}\pysiglinewithargsret{void \bfcode{drm\_put\_dev}}{struct drm\_device *\emph{ dev}}{}
Unregister and release a DRM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

Called at module unload time or when a PCI device is unplugged.

Cleans up all DRM device, calling \code{drm\_lastclose()}.

\textbf{Note}

Use of this function is deprecated. It will eventually go away
completely.  Please use {\hyperref[gpu/drm\string-internals:c.drm_dev_unregister]{\emph{\code{drm\_dev\_unregister()}}}} and {\hyperref[gpu/drm\string-internals:c.drm_dev_put]{\emph{\code{drm\_dev\_put()}}}} explicitly
instead to make sure that the device isn't userspace accessible any more
while teardown is in progress, ensuring that userspace can't access an
inconsistent state.
\index{drm\_dev\_unplug (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_dev_unplug}\pysiglinewithargsret{void \bfcode{drm\_dev\_unplug}}{struct drm\_device *\emph{ dev}}{}
unplug a DRM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

This unplugs a hotpluggable DRM device, which makes it inaccessible to
userspace operations. Entry-points can use {\hyperref[gpu/drm\string-internals:c.drm_dev_is_unplugged]{\emph{\code{drm\_dev\_is\_unplugged()}}}}. This
essentially unregisters the device like {\hyperref[gpu/drm\string-internals:c.drm_dev_unregister]{\emph{\code{drm\_dev\_unregister()}}}}, but can be
called while there are still open users of \textbf{dev}.
\index{drm\_dev\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_dev_init}\pysiglinewithargsret{int \bfcode{drm\_dev\_init}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{drm\_driver}}} *\emph{ driver}, struct device *\emph{ parent}}{}
Initialise new DRM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_driver * driver}}] \leavevmode
DRM driver

\item[{\code{struct device * parent}}] \leavevmode
Parent device object

\end{description}

\textbf{Description}

Initialize a new DRM device. No device registration is done.
Call {\hyperref[gpu/drm\string-internals:c.drm_dev_register]{\emph{\code{drm\_dev\_register()}}}} to advertice the device to user space and register it
with other core subsystems. This should be done last in the device
initialization sequence to make sure userspace can't access an inconsistent
state.

The initial ref-count of the object is 1. Use {\hyperref[gpu/drm\string-internals:c.drm_dev_get]{\emph{\code{drm\_dev\_get()}}}} and
{\hyperref[gpu/drm\string-internals:c.drm_dev_put]{\emph{\code{drm\_dev\_put()}}}} to take and drop further ref-counts.

Note that for purely virtual devices \textbf{parent} can be NULL.

Drivers that do not want to allocate their own device struct
embedding \code{struct drm\_device} can call {\hyperref[gpu/drm\string-internals:c.drm_dev_alloc]{\emph{\code{drm\_dev\_alloc()}}}} instead. For drivers
that do embed \code{struct drm\_device} it must be placed first in the overall
structure, and the overall structure must be allocated using \code{kmalloc()}: The
drm core's release function unconditionally calls \code{kfree()} on the \textbf{dev} pointer
when the final reference is released. To override this behaviour, and so
allow embedding of the drm\_device inside the driver's device struct at an
arbitrary offset, you must supply a {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.release}}}} callback and control
the finalization explicitly.

\textbf{Return}

0 on success, or error code on failure.
\index{drm\_dev\_fini (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_dev_fini}\pysiglinewithargsret{void \bfcode{drm\_dev\_fini}}{struct drm\_device *\emph{ dev}}{}
Finalize a dead DRM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

Finalize a dead DRM device. This is the converse to {\hyperref[gpu/drm\string-internals:c.drm_dev_init]{\emph{\code{drm\_dev\_init()}}}} and
frees up all data allocated by it. All driver private data should be
finalized first. Note that this function does not free the \textbf{dev}, that is
left to the caller.

The ref-count of \textbf{dev} must be zero, and {\hyperref[gpu/drm\string-internals:c.drm_dev_fini]{\emph{\code{drm\_dev\_fini()}}}} should only be called
from a {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.release}}}} callback.
\index{drm\_dev\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_dev_alloc}\pysiglinewithargsret{struct drm\_device * \bfcode{drm\_dev\_alloc}}{struct {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{drm\_driver}}} *\emph{ driver}, struct device *\emph{ parent}}{}
Allocate new DRM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_driver * driver}}] \leavevmode
DRM driver to allocate device for

\item[{\code{struct device * parent}}] \leavevmode
Parent device object

\end{description}

\textbf{Description}

Allocate and initialize a new DRM device. No device registration is done.
Call {\hyperref[gpu/drm\string-internals:c.drm_dev_register]{\emph{\code{drm\_dev\_register()}}}} to advertice the device to user space and register it
with other core subsystems. This should be done last in the device
initialization sequence to make sure userspace can't access an inconsistent
state.

The initial ref-count of the object is 1. Use {\hyperref[gpu/drm\string-internals:c.drm_dev_get]{\emph{\code{drm\_dev\_get()}}}} and
{\hyperref[gpu/drm\string-internals:c.drm_dev_put]{\emph{\code{drm\_dev\_put()}}}} to take and drop further ref-counts.

Note that for purely virtual devices \textbf{parent} can be NULL.

Drivers that wish to subclass or embed \code{struct drm\_device} into their
own struct should look at using {\hyperref[gpu/drm\string-internals:c.drm_dev_init]{\emph{\code{drm\_dev\_init()}}}} instead.

\textbf{Return}

Pointer to new DRM device, or ERR\_PTR on failure.
\index{drm\_dev\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_dev_get}\pysiglinewithargsret{void \bfcode{drm\_dev\_get}}{struct drm\_device *\emph{ dev}}{}
Take reference of a DRM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
device to take reference of or NULL

\end{description}

\textbf{Description}

This increases the ref-count of \textbf{dev} by one. You \emph{must} already own a
reference when calling this. Use {\hyperref[gpu/drm\string-internals:c.drm_dev_put]{\emph{\code{drm\_dev\_put()}}}} to drop this reference
again.

This function never fails. However, this function does not provide \emph{any}
guarantee whether the device is alive or running. It only provides a
reference to the object and the memory associated with it.
\index{drm\_dev\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_dev_put}\pysiglinewithargsret{void \bfcode{drm\_dev\_put}}{struct drm\_device *\emph{ dev}}{}
Drop reference of a DRM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
device to drop reference of or NULL

\end{description}

\textbf{Description}

This decreases the ref-count of \textbf{dev} by one. The device is destroyed if the
ref-count drops to zero.
\index{drm\_dev\_unref (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_dev_unref}\pysiglinewithargsret{void \bfcode{drm\_dev\_unref}}{struct drm\_device *\emph{ dev}}{}
Drop reference of a DRM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
device to drop reference of or NULL

\end{description}

\textbf{Description}

This is a compatibility alias for {\hyperref[gpu/drm\string-internals:c.drm_dev_put]{\emph{\code{drm\_dev\_put()}}}} and should not be used by new
code.
\index{drm\_dev\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_dev_register}\pysiglinewithargsret{int \bfcode{drm\_dev\_register}}{struct drm\_device *\emph{ dev}, unsigned long\emph{ flags}}{}
Register DRM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
Device to register

\item[{\code{unsigned long flags}}] \leavevmode
Flags passed to the driver's .:c:func:\emph{load()} function

\end{description}

\textbf{Description}

Register the DRM device \textbf{dev} with the system, advertise device to user-space
and start normal device operation. \textbf{dev} must be allocated via {\hyperref[gpu/drm\string-internals:c.drm_dev_alloc]{\emph{\code{drm\_dev\_alloc()}}}}
previously.

Never call this twice on any device!

\textbf{NOTE}

To ensure backward compatibility with existing drivers method this
function calls the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.load}}}} method after registering the device
nodes, creating race conditions. Usage of the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.load}}}} methods is
therefore deprecated, drivers must perform all initialization before calling
{\hyperref[gpu/drm\string-internals:c.drm_dev_register]{\emph{\code{drm\_dev\_register()}}}}.

\textbf{Return}

0 on success, negative error code on failure.
\index{drm\_dev\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_dev_unregister}\pysiglinewithargsret{void \bfcode{drm\_dev\_unregister}}{struct drm\_device *\emph{ dev}}{}
Unregister DRM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
Device to unregister

\end{description}

\textbf{Description}

Unregister the DRM device from the system. This does the reverse of
{\hyperref[gpu/drm\string-internals:c.drm_dev_register]{\emph{\code{drm\_dev\_register()}}}} but does not deallocate the device. The caller must call
{\hyperref[gpu/drm\string-internals:c.drm_dev_put]{\emph{\code{drm\_dev\_put()}}}} to drop their final reference.

A special form of unregistering for hotpluggable devices is {\hyperref[gpu/drm\string-internals:c.drm_dev_unplug]{\emph{\code{drm\_dev\_unplug()}}}},
which can be called while there are still open users of \textbf{dev}.

This should be called first in the device teardown code to make sure
userspace can't access the device instance any more.
\index{drm\_dev\_set\_unique (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_dev_set_unique}\pysiglinewithargsret{int \bfcode{drm\_dev\_set\_unique}}{struct drm\_device *\emph{ dev}, const char *\emph{ name}}{}
Set the unique name of a DRM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
device of which to set the unique name

\item[{\code{const char * name}}] \leavevmode
unique name

\end{description}

\textbf{Description}

Sets the unique name of a DRM device using the specified string. Drivers
can use this at driver probe time if the unique name of the devices they
drive is static.

\textbf{Return}

0 on success or a negative error code on failure.


\subsection{Driver Load}
\label{gpu/drm-internals:driver-load}

\subsubsection{IRQ Helper Library}
\label{gpu/drm-internals:irq-helper-library}
The DRM core provides very simple support helpers to enable IRQ handling on a
device through the {\hyperref[gpu/drm\string-internals:c.drm_irq_install]{\emph{\code{drm\_irq\_install()}}}} and {\hyperref[gpu/drm\string-internals:c.drm_irq_uninstall]{\emph{\code{drm\_irq\_uninstall()}}}} functions. This
only supports devices with a single interrupt on the main device stored in
\code{drm\_device.dev} and set as the device paramter in {\hyperref[gpu/drm\string-internals:c.drm_dev_alloc]{\emph{\code{drm\_dev\_alloc()}}}}.

These IRQ helpers are strictly optional. Drivers which roll their own only
need to set \code{drm\_device.irq\_enabled} to signal the DRM core that vblank
interrupts are working. Since these helpers don't automatically clean up the
requested interrupt like e.g. \code{devm\_request\_irq()} they're not really
recommended.
\index{drm\_irq\_install (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_irq_install}\pysiglinewithargsret{int \bfcode{drm\_irq\_install}}{struct drm\_device *\emph{ dev}, int\emph{ irq}}{}
install IRQ handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{int irq}}] \leavevmode
IRQ number to install the handler for

\end{description}

\textbf{Description}

Initializes the IRQ related data. Installs the handler, calling the driver
{\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.irq\_preinstall}}}} and {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.irq\_postinstall}}}} functions before
and after the installation.

This is the simplified helper interface provided for drivers with no special
needs. Drivers which need to install interrupt handlers for multiple
interrupts must instead set \code{drm\_device.irq\_enabled} to signal the DRM core
that vblank interrupts are available.

\textbf{irq} must match the interrupt number that would be passed to \code{request\_irq()},
if called directly instead of using this helper function.

{\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.irq\_handler}}}} is called to handle the registered interrupt.

\textbf{Return}

Zero on success or a negative error code on failure.
\index{drm\_irq\_uninstall (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_irq_uninstall}\pysiglinewithargsret{int \bfcode{drm\_irq\_uninstall}}{struct drm\_device *\emph{ dev}}{}
uninstall the IRQ handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

Calls the driver's {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.irq\_uninstall}}}} function and unregisters the IRQ
handler.  This should only be called by drivers which used {\hyperref[gpu/drm\string-internals:c.drm_irq_install]{\emph{\code{drm\_irq\_install()}}}}
to set up their interrupt handler. Other drivers must only reset
\code{drm\_device.irq\_enabled} to false.

Note that for kernel modesetting drivers it is a bug if this function fails.
The sanity checks are only to catch buggy user modesetting drivers which call
the same function through an ioctl.

\textbf{Return}

Zero on success or a negative error code on failure.


\subsubsection{Memory Manager Initialization}
\label{gpu/drm-internals:memory-manager-initialization}
Every DRM driver requires a memory manager which must be initialized at
load time. DRM currently contains two memory managers, the Translation
Table Manager (TTM) and the Graphics Execution Manager (GEM). This
document describes the use of the GEM memory manager only. See ? for
details.


\subsubsection{Miscellaneous Device Configuration}
\label{gpu/drm-internals:miscellaneous-device-configuration}
Another task that may be necessary for PCI devices during configuration
is mapping the video BIOS. On many devices, the VBIOS describes device
configuration, LCD panel timings (if any), and contains flags indicating
device state. Mapping the BIOS can be done using the pci\_map\_rom()
call, a convenience function that takes care of mapping the actual ROM,
whether it has been shadowed into memory (typically at address 0xc0000)
or exists on the PCI device in the ROM BAR. Note that after the ROM has
been mapped and any necessary information has been extracted, it should
be unmapped; on many devices, the ROM address decoder is shared with
other BARs, so leaving it mapped could cause undesired behaviour like
hangs or memory corruption.


\subsection{Bus-specific Device Registration and PCI Support}
\label{gpu/drm-internals:bus-specific-device-registration-and-pci-support}
A number of functions are provided to help with device registration. The
functions deal with PCI and platform devices respectively and are only
provided for historical reasons. These are all deprecated and shouldn't
be used in new drivers. Besides that there's a few helpers for pci
drivers.
\index{drm\_pci\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_pci_alloc}\pysiglinewithargsret{drm\_dma\_handle\_t * \bfcode{drm\_pci\_alloc}}{struct drm\_device *\emph{ dev}, size\_t\emph{ size}, size\_t\emph{ align}}{}
Allocate a PCI consistent memory block, for DMA.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{size\_t size}}] \leavevmode
size of block to allocate

\item[{\code{size\_t align}}] \leavevmode
alignment of block

\end{description}

\textbf{Description}

FIXME: This is a needless abstraction of the Linux dma-api and should be
removed.

\textbf{Return}

A handle to the allocated memory block on success or NULL on
failure.
\index{drm\_pci\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_pci_free}\pysiglinewithargsret{void \bfcode{drm\_pci\_free}}{struct drm\_device *\emph{ dev}, drm\_dma\_handle\_t *\emph{ dmah}}{}
Free a PCI consistent memory block

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{drm\_dma\_handle\_t * dmah}}] \leavevmode
handle to memory block

\end{description}

\textbf{Description}

FIXME: This is a needless abstraction of the Linux dma-api and should be
removed.
\index{drm\_get\_pci\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_get_pci_dev}\pysiglinewithargsret{int \bfcode{drm\_get\_pci\_dev}}{struct pci\_dev *\emph{ pdev}, const struct pci\_device\_id *\emph{ ent}, struct {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{drm\_driver}}} *\emph{ driver}}{}
Register a PCI device with the DRM subsystem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
PCI device

\item[{\code{const struct pci\_device\_id * ent}}] \leavevmode
entry from the PCI ID table that matches \textbf{pdev}

\item[{\code{struct drm\_driver * driver}}] \leavevmode
DRM device driver

\end{description}

\textbf{Description}

Attempt to gets inter module ``drm'' information. If we are first
then register the character device and inter module information.
Try and register, if we fail to register, backout previous work.

\textbf{NOTE}

This function is deprecated, please use {\hyperref[gpu/drm\string-internals:c.drm_dev_alloc]{\emph{\code{drm\_dev\_alloc()}}}} and
{\hyperref[gpu/drm\string-internals:c.drm_dev_register]{\emph{\code{drm\_dev\_register()}}}} instead and remove your {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.load}}}} callback.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_legacy\_pci\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_legacy_pci_init}\pysiglinewithargsret{int \bfcode{drm\_legacy\_pci\_init}}{struct {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{drm\_driver}}} *\emph{ driver}, struct pci\_driver *\emph{ pdriver}}{}
shadow-attach a legacy DRM PCI driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_driver * driver}}] \leavevmode
DRM device driver

\item[{\code{struct pci\_driver * pdriver}}] \leavevmode
PCI device driver

\end{description}

\textbf{Description}

This is only used by legacy dri1 drivers and deprecated.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_legacy\_pci\_exit (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_legacy_pci_exit}\pysiglinewithargsret{void \bfcode{drm\_legacy\_pci\_exit}}{struct {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{drm\_driver}}} *\emph{ driver}, struct pci\_driver *\emph{ pdriver}}{}
unregister shadow-attach legacy DRM driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_driver * driver}}] \leavevmode
DRM device driver

\item[{\code{struct pci\_driver * pdriver}}] \leavevmode
PCI device driver

\end{description}

\textbf{Description}

Unregister a DRM driver shadow-attached through {\hyperref[gpu/drm\string-internals:c.drm_legacy_pci_init]{\emph{\code{drm\_legacy\_pci\_init()}}}}. This
is deprecated and only used by dri1 drivers.


\section{Open/Close, File Operations and IOCTLs}
\label{gpu/drm-internals:open-close-file-operations-and-ioctls}

\subsection{File Operations}
\label{gpu/drm-internals:file-operations}\label{gpu/drm-internals:drm-driver-fops}
Drivers must define the file operations structure that forms the DRM
userspace API entry point, even though most of those operations are
implemented in the DRM core. The resulting \code{struct file\_operations} must be
stored in the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.fops}}}} field. The mandatory functions are {\hyperref[gpu/drm\string-internals:c.drm_open]{\emph{\code{drm\_open()}}}},
{\hyperref[gpu/drm\string-internals:c.drm_read]{\emph{\code{drm\_read()}}}}, {\hyperref[gpu/drm\string-uapi:c.drm_ioctl]{\emph{\code{drm\_ioctl()}}}} and {\hyperref[gpu/drm\string-uapi:c.drm_compat_ioctl]{\emph{\code{drm\_compat\_ioctl()}}}} if CONFIG\_COMPAT is enabled
Note that drm\_compat\_ioctl will be NULL if CONFIG\_COMPAT=n, so there's no
need to sprinkle \#ifdef into the code. Drivers which implement private ioctls
that require 32/64 bit compatibility support must provide their own
\code{file\_operations.compat\_ioctl} handler that processes private ioctls and calls
{\hyperref[gpu/drm\string-uapi:c.drm_compat_ioctl]{\emph{\code{drm\_compat\_ioctl()}}}} for core ioctls.

In addition {\hyperref[gpu/drm\string-internals:c.drm_read]{\emph{\code{drm\_read()}}}} and {\hyperref[gpu/drm\string-internals:c.drm_poll]{\emph{\code{drm\_poll()}}}} provide support for DRM events. DRM
events are a generic and extensible means to send asynchronous events to
userspace through the file descriptor. They are used to send vblank event and
page flip completions by the KMS API. But drivers can also use it for their
own needs, e.g. to signal completion of rendering.

For the driver-side event interface see {\hyperref[gpu/drm\string-internals:c.drm_event_reserve_init]{\emph{\code{drm\_event\_reserve\_init()}}}} and
{\hyperref[gpu/drm\string-internals:c.drm_send_event]{\emph{\code{drm\_send\_event()}}}} as the main starting points.

The memory mapping implementation will vary depending on how the driver
manages memory. Legacy drivers will use the deprecated \code{drm\_legacy\_mmap()}
function, modern drivers should use one of the provided memory-manager
specific implementations. For GEM-based drivers this is {\hyperref[gpu/drm\string-mm:c.drm_gem_mmap]{\emph{\code{drm\_gem\_mmap()}}}}, and
for drivers which use the CMA GEM helpers it's {\hyperref[gpu/drm\string-mm:c.drm_gem_cma_mmap]{\emph{\code{drm\_gem\_cma\_mmap()}}}}.

No other file operations are supported by the DRM userspace API. Overall the
following is an example \code{file\_operations} structure:

\begin{Verbatim}[commandchars=\\\{\}]
static const example\PYGZus{}drm\PYGZus{}fops = \PYGZob{}
        .owner = THIS\PYGZus{}MODULE,
        .open = drm\PYGZus{}open,
        .release = drm\PYGZus{}release,
        .unlocked\PYGZus{}ioctl = drm\PYGZus{}ioctl,
        .compat\PYGZus{}ioctl = drm\PYGZus{}compat\PYGZus{}ioctl, // NULL if CONFIG\PYGZus{}COMPAT=n
        .poll = drm\PYGZus{}poll,
        .read = drm\PYGZus{}read,
        .llseek = no\PYGZus{}llseek,
        .mmap = drm\PYGZus{}gem\PYGZus{}mmap,
\PYGZcb{};
\end{Verbatim}

For plain GEM based drivers there is the {\hyperref[gpu/drm\string-mm:c.DEFINE_DRM_GEM_FOPS]{\emph{\code{DEFINE\_DRM\_GEM\_FOPS()}}}} macro, and for
CMA based drivers there is the {\hyperref[gpu/drm\string-mm:c.DEFINE_DRM_GEM_CMA_FOPS]{\emph{\code{DEFINE\_DRM\_GEM\_CMA\_FOPS()}}}} macro to make this
simpler.

The driver's \code{file\_operations} must be stored in {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.fops}}}}.

For driver-private IOCTL handling see the more detailed discussion in
{\hyperref[gpu/drm\string-uapi:drm\string-driver\string-ioctl]{\emph{IOCTL support in the userland interfaces chapter}}}.
\index{drm\_minor (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_minor}\pysigline{struct \bfcode{drm\_minor}}
DRM device minor structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}minor \PYGZob{}
\PYGZcb{};
\end{Verbatim}

\textbf{Members}

\textbf{Description}

This structure represents a DRM minor number for device nodes in /dev.
Entirely opaque to drivers and should never be inspected directly by drivers.
Drivers instead should only interact with {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{struct drm\_file}}}} and of course
\code{struct drm\_device}, which is also where driver-private data and resources can
be attached to.
\index{drm\_pending\_event (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_pending_event}\pysigline{struct \bfcode{drm\_pending\_event}}
Event queued up for userspace to read

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}pending\PYGZus{}event \PYGZob{}
  struct completion *completion;
  void (*completion\PYGZus{}release)(struct completion *completion);
  struct drm\PYGZus{}event *event;
  struct dma\PYGZus{}fence *fence;
  struct drm\PYGZus{}file *file\PYGZus{}priv;
  struct list\PYGZus{}head link;
  struct list\PYGZus{}head pending\PYGZus{}link;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{completion}}] \leavevmode
Optional pointer to a kernel internal completion signalled when
{\hyperref[gpu/drm\string-internals:c.drm_send_event]{\emph{\code{drm\_send\_event()}}}} is called, useful to internally synchronize with
nonblocking operations.

\item[{\code{completion\_release}}] \leavevmode
Optional callback currently only used by the atomic modeset helpers
to clean up the reference count for the structure \textbf{completion} is
stored in.

\item[{\code{event}}] \leavevmode
Pointer to the actual event that should be sent to userspace to be
read using {\hyperref[gpu/drm\string-internals:c.drm_read]{\emph{\code{drm\_read()}}}}. Can be optional, since nowadays events are
also used to signal kernel internal threads with \textbf{completion} or DMA
transactions using \textbf{fence}.

\item[{\code{fence}}] \leavevmode
Optional DMA fence to unblock other hardware transactions which
depend upon the nonblocking DRM operation this event represents.

\item[{\code{file\_priv}}] \leavevmode
{\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{struct drm\_file}}}} where \textbf{event} should be delivered to. Only set when
\textbf{event} is set.

\item[{\code{link}}] \leavevmode
Double-linked list to keep track of this event. Can be used by the
driver up to the point when it calls {\hyperref[gpu/drm\string-internals:c.drm_send_event]{\emph{\code{drm\_send\_event()}}}}, after that
this list entry is owned by the core for its own book-keeping.

\item[{\code{pending\_link}}] \leavevmode
Entry on {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{drm\_file.pending\_event\_list}}}}, to keep track of all pending
events for \textbf{file\_priv}, to allow correct unwinding of them when
userspace closes the file before the event is delivered.

\end{description}

\textbf{Description}

This represents a DRM event. Drivers can use this as a generic completion
mechanism, which supports kernel-internal \code{struct completion}, \code{struct dma\_fence}
and also the DRM-specific \code{struct drm\_event} delivery mechanism.
\index{drm\_file (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_file}\pysigline{struct \bfcode{drm\_file}}
DRM file private data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}file \PYGZob{}
  unsigned authenticated :1;
  unsigned stereo\PYGZus{}allowed :1;
  unsigned universal\PYGZus{}planes:1;
  unsigned atomic:1;
  unsigned is\PYGZus{}master:1;
  struct drm\PYGZus{}master *master;
  struct pid *pid;
  drm\PYGZus{}magic\PYGZus{}t magic;
  struct list\PYGZus{}head lhead;
  struct drm\PYGZus{}minor *minor;
  struct idr object\PYGZus{}idr;
  spinlock\PYGZus{}t table\PYGZus{}lock;
  struct idr syncobj\PYGZus{}idr;
  spinlock\PYGZus{}t syncobj\PYGZus{}table\PYGZus{}lock;
  struct file *filp;
  void *driver\PYGZus{}priv;
  struct list\PYGZus{}head fbs;
  struct mutex fbs\PYGZus{}lock;
  struct list\PYGZus{}head blobs;
  wait\PYGZus{}queue\PYGZus{}head\PYGZus{}t event\PYGZus{}wait;
  struct list\PYGZus{}head pending\PYGZus{}event\PYGZus{}list;
  struct list\PYGZus{}head event\PYGZus{}list;
  int event\PYGZus{}space;
  struct mutex event\PYGZus{}read\PYGZus{}lock;
  struct drm\PYGZus{}prime\PYGZus{}file\PYGZus{}private prime;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{authenticated}}] \leavevmode
Whether the client is allowed to submit rendering, which for legacy
nodes means it must be authenticated.

See also the {\hyperref[gpu/drm\string-uapi:drm\string-primary\string-node]{\emph{section on primary nodes and authentication}}}.

\item[{\code{stereo\_allowed}}] \leavevmode
True when the client has asked us to expose stereo 3D mode flags.

\item[{\code{universal\_planes}}] \leavevmode
True if client understands CRTC primary planes and cursor planes
in the plane list. Automatically set when \textbf{atomic} is set.

\item[{\code{atomic}}] \leavevmode
True if client understands atomic properties.

\item[{\code{is\_master}}] \leavevmode
This client is the creator of \textbf{master}. Protected by struct
\code{drm\_device.master\_mutex}.

See also the {\hyperref[gpu/drm\string-uapi:drm\string-primary\string-node]{\emph{section on primary nodes and authentication}}}.

\item[{\code{master}}] \leavevmode
Master this node is currently associated with. Only relevant if
{\hyperref[gpu/drm\string-internals:c.drm_is_primary_client]{\emph{\code{drm\_is\_primary\_client()}}}} returns true. Note that this only
matches \code{drm\_device.master} if the master is the currently active one.

See also \textbf{authentication} and \textbf{is\_master} and the {\hyperref[gpu/drm\string-uapi:drm\string-primary\string-node]{\emph{section on
primary nodes and authentication}}}.

\item[{\code{pid}}] \leavevmode
Process that opened this file.

\item[{\code{magic}}] \leavevmode
Authentication magic, see \textbf{authenticated}.

\item[{\code{lhead}}] \leavevmode
List of all open files of a DRM device, linked into
\code{drm\_device.filelist}. Protected by \code{drm\_device.filelist\_mutex}.

\item[{\code{minor}}] \leavevmode
{\hyperref[gpu/drm\string-internals:c.drm_minor]{\emph{\code{struct drm\_minor}}}} for this file.

\item[{\code{object\_idr}}] \leavevmode
Mapping of mm object handles to object pointers. Used by the GEM
subsystem. Protected by \textbf{table\_lock}.

\item[{\code{table\_lock}}] \leavevmode
Protects \textbf{object\_idr}.

\item[{\code{syncobj\_idr}}] \leavevmode
Mapping of sync object handles to object pointers.

\item[{\code{syncobj\_table\_lock}}] \leavevmode
Protects \textbf{syncobj\_idr}.

\item[{\code{filp}}] \leavevmode
Pointer to the core file structure.

\item[{\code{driver\_priv}}] \leavevmode
Optional pointer for driver private data. Can be allocated in
{\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.open}}}} and should be freed in {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.postclose}}}}.

\item[{\code{fbs}}] \leavevmode
List of {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{struct drm\_framebuffer}}}} associated with this file, using the
{\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer.filp\_head}}}} entry.

Protected by \textbf{fbs\_lock}. Note that the \textbf{fbs} list holds a reference on
the framebuffer object to prevent it from untimely disappearing.

\item[{\code{fbs\_lock}}] \leavevmode
Protects \textbf{fbs}.

\item[{\code{blobs}}] \leavevmode
User-created blob properties; this retains a reference on the
property.

Protected by \textbf{drm\_mode\_config.blob\_lock};

\item[{\code{event\_wait}}] \leavevmode
Waitqueue for new events added to \textbf{event\_list}.

\item[{\code{pending\_event\_list}}] \leavevmode
List of pending {\hyperref[gpu/drm\string-internals:c.drm_pending_event]{\emph{\code{struct drm\_pending\_event}}}}, used to clean up pending
events in case this file gets closed before the event is signalled.
Uses the {\hyperref[gpu/drm\string-internals:c.drm_pending_event]{\emph{\code{drm\_pending\_event.pending\_link}}}} entry.

Protect by \code{drm\_device.event\_lock}.

\item[{\code{event\_list}}] \leavevmode
List of {\hyperref[gpu/drm\string-internals:c.drm_pending_event]{\emph{\code{struct drm\_pending\_event}}}}, ready for delivery to userspace
through {\hyperref[gpu/drm\string-internals:c.drm_read]{\emph{\code{drm\_read()}}}}. Uses the {\hyperref[gpu/drm\string-internals:c.drm_pending_event]{\emph{\code{drm\_pending\_event.link}}}} entry.

Protect by \code{drm\_device.event\_lock}.

\item[{\code{event\_space}}] \leavevmode
Available event space to prevent userspace from
exhausting kernel memory. Currently limited to the fairly arbitrary
value of 4KB.

\item[{\code{event\_read\_lock}}] \leavevmode
Serializes {\hyperref[gpu/drm\string-internals:c.drm_read]{\emph{\code{drm\_read()}}}}.

\item[{\code{prime}}] \leavevmode
Per-file buffer caches used by the PRIME buffer sharing code.

\end{description}

\textbf{Description}

This structure tracks DRM state per open file descriptor.
\index{drm\_is\_primary\_client (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_is_primary_client}\pysiglinewithargsret{bool \bfcode{drm\_is\_primary\_client}}{const struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}}{}
is this an open file of the primary node

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_file * file\_priv}}] \leavevmode
DRM file

\end{description}

\textbf{Description}

Returns true if this is an open file of the primary node, i.e.
{\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{drm\_file.minor}}}} of \textbf{file\_priv} is a primary minor.

See also the {\hyperref[gpu/drm\string-uapi:drm\string-primary\string-node]{\emph{section on primary nodes and authentication}}}.
\index{drm\_is\_render\_client (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_is_render_client}\pysiglinewithargsret{bool \bfcode{drm\_is\_render\_client}}{const struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}}{}
is this an open file of the render node

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_file * file\_priv}}] \leavevmode
DRM file

\end{description}

\textbf{Description}

Returns true if this is an open file of the render node, i.e.
{\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{drm\_file.minor}}}} of \textbf{file\_priv} is a render minor.

See also the {\hyperref[gpu/drm\string-uapi:drm\string-render\string-node]{\emph{section on render nodes}}}.
\index{drm\_is\_control\_client (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_is_control_client}\pysiglinewithargsret{bool \bfcode{drm\_is\_control\_client}}{const struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}}{}
is this an open file of the control node

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_file * file\_priv}}] \leavevmode
DRM file

\end{description}

\textbf{Description}

Control nodes are deprecated and in the process of getting removed from the
DRM userspace API. Do not ever use!
\index{drm\_open (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_open}\pysiglinewithargsret{int \bfcode{drm\_open}}{struct inode *\emph{ inode}, struct file *\emph{ filp}}{}
open method for DRM file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
device inode

\item[{\code{struct file * filp}}] \leavevmode
file pointer.

\end{description}

\textbf{Description}

This function must be used by drivers as their \code{file\_operations.open} method.
It looks up the correct DRM device and instantiates all the per-file
resources for it. It also calls the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.open}}}} driver callback.

\textbf{Return}

0 on success or negative errno value on falure.
\index{drm\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_release}\pysiglinewithargsret{int \bfcode{drm\_release}}{struct inode *\emph{ inode}, struct file *\emph{ filp}}{}
release method for DRM file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
device inode

\item[{\code{struct file * filp}}] \leavevmode
file pointer.

\end{description}

\textbf{Description}

This function must be used by drivers as their \code{file\_operations.release}
method. It frees any resources associated with the open file, and calls the
{\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.postclose}}}} driver callback. If this is the last open file for the
DRM device also proceeds to call the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.lastclose}}}} driver callback.

\textbf{Return}

Always succeeds and returns 0.
\index{drm\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_read}\pysiglinewithargsret{ssize\_t \bfcode{drm\_read}}{struct file *\emph{ filp}, char \_\_user *\emph{ buffer}, size\_t\emph{ count}, loff\_t *\emph{ offset}}{}
read method for DRM file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
file pointer

\item[{\code{char \_\_user * buffer}}] \leavevmode
userspace destination pointer for the read

\item[{\code{size\_t count}}] \leavevmode
count in bytes to read

\item[{\code{loff\_t * offset}}] \leavevmode
offset to read

\end{description}

\textbf{Description}

This function must be used by drivers as their \code{file\_operations.read}
method iff they use DRM events for asynchronous signalling to userspace.
Since events are used by the KMS API for vblank and page flip completion this
means all modern display drivers must use it.

\textbf{offset} is ignored, DRM events are read like a pipe. Therefore drivers also
must set the \code{file\_operation.llseek} to \code{no\_llseek()}. Polling support is
provided by {\hyperref[gpu/drm\string-internals:c.drm_poll]{\emph{\code{drm\_poll()}}}}.

This function will only ever read a full event. Therefore userspace must
supply a big enough buffer to fit any event to ensure forward progress. Since
the maximum event space is currently 4K it's recommended to just use that for
safety.

\textbf{Return}

Number of bytes read (always aligned to full events, and can be 0) or a
negative error code on failure.
\index{drm\_poll (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_poll}\pysiglinewithargsret{\_\_poll\_t \bfcode{drm\_poll}}{struct file *\emph{ filp}, struct poll\_table\_struct *\emph{ wait}}{}
poll method for DRM file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
file pointer

\item[{\code{struct poll\_table\_struct * wait}}] \leavevmode
poll waiter table

\end{description}

\textbf{Description}

This function must be used by drivers as their \code{file\_operations.read} method
iff they use DRM events for asynchronous signalling to userspace.  Since
events are used by the KMS API for vblank and page flip completion this means
all modern display drivers must use it.

See also {\hyperref[gpu/drm\string-internals:c.drm_read]{\emph{\code{drm\_read()}}}}.

\textbf{Return}

Mask of POLL flags indicating the current status of the file.
\index{drm\_event\_reserve\_init\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_event_reserve_init_locked}\pysiglinewithargsret{int \bfcode{drm\_event\_reserve\_init\_locked}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}, struct {\hyperref[gpu/drm\string-internals:c.drm_pending_event]{\emph{drm\_pending\_event}}} *\emph{ p}, struct drm\_event *\emph{ e}}{}
init a DRM event and reserve space for it

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
DRM file private data

\item[{\code{struct drm\_pending\_event * p}}] \leavevmode
tracking structure for the pending event

\item[{\code{struct drm\_event * e}}] \leavevmode
actual event data to deliver to userspace

\end{description}

\textbf{Description}

This function prepares the passed in event for eventual delivery. If the event
doesn't get delivered (because the IOCTL fails later on, before queuing up
anything) then the even must be cancelled and freed using
{\hyperref[gpu/drm\string-internals:c.drm_event_cancel_free]{\emph{\code{drm\_event\_cancel\_free()}}}}. Successfully initialized events should be sent out
using {\hyperref[gpu/drm\string-internals:c.drm_send_event]{\emph{\code{drm\_send\_event()}}}} or {\hyperref[gpu/drm\string-internals:c.drm_send_event_locked]{\emph{\code{drm\_send\_event\_locked()}}}} to signal completion of the
asynchronous event to userspace.

If callers embedded \textbf{p} into a larger structure it must be allocated with
kmalloc and \textbf{p} must be the first member element.

This is the locked version of {\hyperref[gpu/drm\string-internals:c.drm_event_reserve_init]{\emph{\code{drm\_event\_reserve\_init()}}}} for callers which
already hold \code{drm\_device.event\_lock}.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_event\_reserve\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_event_reserve_init}\pysiglinewithargsret{int \bfcode{drm\_event\_reserve\_init}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}, struct {\hyperref[gpu/drm\string-internals:c.drm_pending_event]{\emph{drm\_pending\_event}}} *\emph{ p}, struct drm\_event *\emph{ e}}{}
init a DRM event and reserve space for it

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
DRM file private data

\item[{\code{struct drm\_pending\_event * p}}] \leavevmode
tracking structure for the pending event

\item[{\code{struct drm\_event * e}}] \leavevmode
actual event data to deliver to userspace

\end{description}

\textbf{Description}

This function prepares the passed in event for eventual delivery. If the event
doesn't get delivered (because the IOCTL fails later on, before queuing up
anything) then the even must be cancelled and freed using
{\hyperref[gpu/drm\string-internals:c.drm_event_cancel_free]{\emph{\code{drm\_event\_cancel\_free()}}}}. Successfully initialized events should be sent out
using {\hyperref[gpu/drm\string-internals:c.drm_send_event]{\emph{\code{drm\_send\_event()}}}} or {\hyperref[gpu/drm\string-internals:c.drm_send_event_locked]{\emph{\code{drm\_send\_event\_locked()}}}} to signal completion of the
asynchronous event to userspace.

If callers embedded \textbf{p} into a larger structure it must be allocated with
kmalloc and \textbf{p} must be the first member element.

Callers which already hold \code{drm\_device.event\_lock} should use
{\hyperref[gpu/drm\string-internals:c.drm_event_reserve_init_locked]{\emph{\code{drm\_event\_reserve\_init\_locked()}}}} instead.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_event\_cancel\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_event_cancel_free}\pysiglinewithargsret{void \bfcode{drm\_event\_cancel\_free}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_pending_event]{\emph{drm\_pending\_event}}} *\emph{ p}}{}
free a DRM event and release it's space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_pending\_event * p}}] \leavevmode
tracking structure for the pending event

\end{description}

\textbf{Description}

This function frees the event \textbf{p} initialized with {\hyperref[gpu/drm\string-internals:c.drm_event_reserve_init]{\emph{\code{drm\_event\_reserve\_init()}}}}
and releases any allocated space. It is used to cancel an event when the
nonblocking operation could not be submitted and needed to be aborted.
\index{drm\_send\_event\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_send_event_locked}\pysiglinewithargsret{void \bfcode{drm\_send\_event\_locked}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_pending_event]{\emph{drm\_pending\_event}}} *\emph{ e}}{}
send DRM event to file descriptor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_pending\_event * e}}] \leavevmode
DRM event to deliver

\end{description}

\textbf{Description}

This function sends the event \textbf{e}, initialized with {\hyperref[gpu/drm\string-internals:c.drm_event_reserve_init]{\emph{\code{drm\_event\_reserve\_init()}}}},
to its associated userspace DRM file. Callers must already hold
\code{drm\_device.event\_lock}, see {\hyperref[gpu/drm\string-internals:c.drm_send_event]{\emph{\code{drm\_send\_event()}}}} for the unlocked version.

Note that the core will take care of unlinking and disarming events when the
corresponding DRM file is closed. Drivers need not worry about whether the
DRM file for this event still exists and can call this function upon
completion of the asynchronous work unconditionally.
\index{drm\_send\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_send_event}\pysiglinewithargsret{void \bfcode{drm\_send\_event}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_pending_event]{\emph{drm\_pending\_event}}} *\emph{ e}}{}
send DRM event to file descriptor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_pending\_event * e}}] \leavevmode
DRM event to deliver

\end{description}

\textbf{Description}

This function sends the event \textbf{e}, initialized with {\hyperref[gpu/drm\string-internals:c.drm_event_reserve_init]{\emph{\code{drm\_event\_reserve\_init()}}}},
to its associated userspace DRM file. This function acquires
\code{drm\_device.event\_lock}, see {\hyperref[gpu/drm\string-internals:c.drm_send_event_locked]{\emph{\code{drm\_send\_event\_locked()}}}} for callers which already
hold this lock.

Note that the core will take care of unlinking and disarming events when the
corresponding DRM file is closed. Drivers need not worry about whether the
DRM file for this event still exists and can call this function upon
completion of the asynchronous work unconditionally.


\section{Misc Utilities}
\label{gpu/drm-internals:misc-utilities}

\subsection{Printer}
\label{gpu/drm-internals:printer}
A simple wrapper for \code{dev\_printk()}, \code{seq\_printf()}, etc.  Allows same
debug code to be used for both debugfs and printk logging.

For example:

\begin{Verbatim}[commandchars=\\\{\}]
void log\PYGZus{}some\PYGZus{}info(struct drm\PYGZus{}printer *p)
\PYGZob{}
        drm\PYGZus{}printf(p, \PYGZdq{}foo={}`{}`d{}`{}`\PYGZbs{}n\PYGZdq{}, foo);
        drm\PYGZus{}printf(p, \PYGZdq{}bar={}`{}`d{}`{}`\PYGZbs{}n\PYGZdq{}, bar);
\PYGZcb{}

\PYGZsh{}ifdef CONFIG\PYGZus{}DEBUG\PYGZus{}FS
void debugfs\PYGZus{}show(struct seq\PYGZus{}file *f)
\PYGZob{}
        struct drm\PYGZus{}printer p = drm\PYGZus{}seq\PYGZus{}file\PYGZus{}printer(f);
        log\PYGZus{}some\PYGZus{}info(:c:type:{}`p{}`);
\PYGZcb{}
\PYGZsh{}endif

void some\PYGZus{}other\PYGZus{}function(...)
\PYGZob{}
        struct drm\PYGZus{}printer p = drm\PYGZus{}info\PYGZus{}printer(drm\PYGZhy{}\PYGZgt{}dev);
        log\PYGZus{}some\PYGZus{}info(:c:type:{}`p{}`);
\PYGZcb{}
\end{Verbatim}
\index{drm\_printer (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_printer}\pysigline{struct \bfcode{drm\_printer}}
drm output ``stream''

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}printer \PYGZob{}
\PYGZcb{};
\end{Verbatim}

\textbf{Members}

\textbf{Description}

Do not use struct members directly.  Use \code{drm\_printer\_seq\_file()},
\code{drm\_printer\_info()}, etc to initialize.  And {\hyperref[gpu/drm\string-internals:c.drm_printf]{\emph{\code{drm\_printf()}}}} for output.
\index{drm\_vprintf (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_vprintf}\pysiglinewithargsret{void \bfcode{drm\_vprintf}}{struct {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{drm\_printer}}} *\emph{ p}, const char *\emph{ fmt}, va\_list *\emph{ va}}{}
print to a {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{\code{drm\_printer}}}} stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_printer * p}}] \leavevmode
the {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{\code{drm\_printer}}}}

\item[{\code{const char * fmt}}] \leavevmode
format string

\item[{\code{va\_list * va}}] \leavevmode
the va\_list

\end{description}
\index{drm\_printf\_indent (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_printf_indent}\pysiglinewithargsret{\bfcode{drm\_printf\_indent}}{\emph{printer}, \emph{indent}, \emph{fmt}, \emph{...}}{}
Print to a {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{\code{drm\_printer}}}} stream with indentation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{printer}}] \leavevmode
DRM printer

\item[{\code{indent}}] \leavevmode
Tab indentation level (max 5)

\item[{\code{fmt}}] \leavevmode
Format string

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}
\index{drm\_seq\_file\_printer (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_seq_file_printer}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{drm\_printer}}} \bfcode{drm\_seq\_file\_printer}}{struct seq\_file *\emph{ f}}{}
construct a {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{\code{drm\_printer}}}} that outputs to \code{seq\_file}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct seq\_file * f}}] \leavevmode
the \code{struct seq\_file} to output to

\end{description}

\textbf{Return}

The {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{\code{drm\_printer}}}} object
\index{drm\_info\_printer (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_info_printer}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{drm\_printer}}} \bfcode{drm\_info\_printer}}{struct device *\emph{ dev}}{}
construct a {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{\code{drm\_printer}}}} that outputs to \code{dev\_printk()}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
the \code{struct device} pointer

\end{description}

\textbf{Return}

The {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{\code{drm\_printer}}}} object
\index{drm\_debug\_printer (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_debug_printer}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{drm\_printer}}} \bfcode{drm\_debug\_printer}}{const char *\emph{ prefix}}{}
construct a {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{\code{drm\_printer}}}} that outputs to \code{pr\_debug()}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * prefix}}] \leavevmode
debug output prefix

\end{description}

\textbf{Return}

The {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{\code{drm\_printer}}}} object
\index{DRM\_DEV\_ERROR (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.DRM_DEV_ERROR}\pysiglinewithargsret{\bfcode{DRM\_DEV\_ERROR}}{\emph{dev}, \emph{fmt}, \emph{...}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{dev}}] \leavevmode
device pointer

\item[{\code{fmt}}] \leavevmode
\code{printf()} like format string.

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}
\index{DRM\_DEV\_ERROR\_RATELIMITED (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.DRM_DEV_ERROR_RATELIMITED}\pysiglinewithargsret{\bfcode{DRM\_DEV\_ERROR\_RATELIMITED}}{\emph{dev}, \emph{fmt}, \emph{...}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{dev}}] \leavevmode
device pointer

\item[{\code{fmt}}] \leavevmode
\code{printf()} like format string.

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}
\index{DRM\_DEV\_DEBUG (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.DRM_DEV_DEBUG}\pysiglinewithargsret{\bfcode{DRM\_DEV\_DEBUG}}{\emph{dev}, \emph{fmt}, \emph{args...}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{dev}}] \leavevmode
device pointer

\item[{\code{fmt}}] \leavevmode
\code{printf()} like format string.

\item[{\code{args...}}] \leavevmode
variable arguments

\end{description}
\index{DRM\_DEV\_DEBUG\_RATELIMITED (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.DRM_DEV_DEBUG_RATELIMITED}\pysiglinewithargsret{\bfcode{DRM\_DEV\_DEBUG\_RATELIMITED}}{\emph{dev}, \emph{fmt}, \emph{args...}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{dev}}] \leavevmode
device pointer

\item[{\code{fmt}}] \leavevmode
\code{printf()} like format string.

\item[{\code{args...}}] \leavevmode
variable arguments

\end{description}
\index{drm\_printf (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-internals:c.drm_printf}\pysiglinewithargsret{void \bfcode{drm\_printf}}{struct {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{drm\_printer}}} *\emph{ p}, const char *\emph{ f}, ...}{}
print to a {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{\code{drm\_printer}}}} stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_printer * p}}] \leavevmode
the {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{\code{drm\_printer}}}}

\item[{\code{const char * f}}] \leavevmode
format string

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}


\section{Legacy Support Code}
\label{gpu/drm-internals:legacy-support-code}
The section very briefly covers some of the old legacy support code
which is only used by old DRM drivers which have done a so-called
shadow-attach to the underlying device instead of registering as a real
driver. This also includes some of the old generic buffer management and
command submission code. Do not use any of this in new and modern
drivers.


\subsection{Legacy Suspend/Resume}
\label{gpu/drm-internals:legacy-suspend-resume}
The DRM core provides some suspend/resume code, but drivers wanting full
suspend/resume support should provide save() and restore() functions.
These are called at suspend, hibernate, or resume time, and should
perform any state save or restore required by your device across suspend
or hibernate states.

int (*suspend) (struct drm\_device *, pm\_message\_t state); int
(*resume) (struct drm\_device *);
Those are legacy suspend and resume methods which \emph{only} work with the
legacy shadow-attach driver registration functions. New driver should
use the power management interface provided by their bus type (usually
through the \code{struct device\_driver}
dev\_pm\_ops) and set these methods to NULL.


\subsection{Legacy DMA Services}
\label{gpu/drm-internals:legacy-dma-services}
This should cover how DMA mapping etc. is supported by the core. These
functions are deprecated and should not be used.


\chapter{DRM Memory Management}
\label{gpu/drm-mm::doc}\label{gpu/drm-mm:drm-memory-management}
Modern Linux systems require large amount of graphics memory to store
frame buffers, textures, vertices and other graphics-related data. Given
the very dynamic nature of many of that data, managing graphics memory
efficiently is thus crucial for the graphics stack and plays a central
role in the DRM infrastructure.

The DRM core includes two memory managers, namely Translation Table Maps
(TTM) and Graphics Execution Manager (GEM). TTM was the first DRM memory
manager to be developed and tried to be a one-size-fits-them all
solution. It provides a single userspace API to accommodate the need of
all hardware, supporting both Unified Memory Architecture (UMA) devices
and devices with dedicated video RAM (i.e. most discrete video cards).
This resulted in a large, complex piece of code that turned out to be
hard to use for driver development.

GEM started as an Intel-sponsored project in reaction to TTM's
complexity. Its design philosophy is completely different: instead of
providing a solution to every graphics memory-related problems, GEM
identified common code between drivers and created a support library to
share it. GEM has simpler initialization and execution requirements than
TTM, but has no video RAM management capabilities and is thus limited to
UMA devices.


\section{The Translation Table Manager (TTM)}
\label{gpu/drm-mm:the-translation-table-manager-ttm}
TTM design background and information belongs here.


\subsection{TTM initialization}
\label{gpu/drm-mm:ttm-initialization}\begin{quote}

\textbf{Warning}
This section is outdated.
\end{quote}

Drivers wishing to support TTM must pass a filled \code{ttm\_bo\_driver} structure to ttm\_bo\_device\_init, together with an
initialized global reference to the memory manager.  The ttm\_bo\_driver
structure contains several fields with function pointers for
initializing the TTM, allocating and freeing memory, waiting for command
completion and fence synchronization, and memory migration.

The \code{struct drm\_global\_reference} is made
up of several fields:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{drm\PYGZus{}global\PYGZus{}reference} \PYG{p}{\PYGZob{}}
        \PYG{k}{enum} \PYG{n}{ttm\PYGZus{}global\PYGZus{}types} \PYG{n}{global\PYGZus{}type}\PYG{p}{;}
        \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{size}\PYG{p}{;}
        \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{object}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{p}{(}\PYG{o}{*}\PYG{n}{init}\PYG{p}{)} \PYG{p}{(}\PYG{k}{struct} \PYG{n}{drm\PYGZus{}global\PYGZus{}reference} \PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{void} \PYG{p}{(}\PYG{o}{*}\PYG{n}{release}\PYG{p}{)} \PYG{p}{(}\PYG{k}{struct} \PYG{n}{drm\PYGZus{}global\PYGZus{}reference} \PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

There should be one global reference structure for your memory manager
as a whole, and there will be others for each object created by the
memory manager at runtime. Your global TTM should have a type of
TTM\_GLOBAL\_TTM\_MEM. The size field for the global object should be
sizeof(struct ttm\_mem\_global), and the init and release hooks should
point at your driver-specific init and release routines, which probably
eventually call ttm\_mem\_global\_init and ttm\_mem\_global\_release,
respectively.

Once your global TTM accounting structure is set up and initialized by
calling ttm\_global\_item\_ref() on it, you need to create a buffer
object TTM to provide a pool for buffer object allocation by clients and
the kernel itself. The type of this object should be
TTM\_GLOBAL\_TTM\_BO, and its size should be sizeof(struct
ttm\_bo\_global). Again, driver-specific init and release functions may
be provided, likely eventually calling ttm\_bo\_global\_init() and
ttm\_bo\_global\_release(), respectively. Also, like the previous
object, ttm\_global\_item\_ref() is used to create an initial reference
count for the TTM, which will call your initialization function.

See the radeon\_ttm.c file for an example of usage.
\index{drm\_global\_item\_ref (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_global_item_ref}\pysiglinewithargsret{int \bfcode{drm\_global\_item\_ref}}{struct drm\_global\_reference *\emph{ ref}}{}
Initialize and acquire reference to memory object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_global\_reference * ref}}] \leavevmode
Object for initialization

\end{description}

\textbf{Description}

This initializes a memory object, allocating memory and calling the
.:c:func:\emph{init()} hook. Further calls will increase the reference count for
that item.

\textbf{Return}

Zero on success, non-zero otherwise.
\index{drm\_global\_item\_unref (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_global_item_unref}\pysiglinewithargsret{void \bfcode{drm\_global\_item\_unref}}{struct drm\_global\_reference *\emph{ ref}}{}
Drop reference to memory object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_global\_reference * ref}}] \leavevmode
Object being removed

\end{description}

\textbf{Description}

Drop a reference to the memory object and eventually call the
\code{release()} hook.  The allocated object should be dropped in the
\code{release()} hook or before calling this function


\section{The Graphics Execution Manager (GEM)}
\label{gpu/drm-mm:the-graphics-execution-manager-gem}
The GEM design approach has resulted in a memory manager that doesn't
provide full coverage of all (or even all common) use cases in its
userspace or kernel API. GEM exposes a set of standard memory-related
operations to userspace and a set of helper functions to drivers, and
let drivers implement hardware-specific operations with their own
private API.

The GEM userspace API is described in the \href{http://lwn.net/Articles/283798/}{GEM - the Graphics Execution
Manager} article on LWN. While
slightly outdated, the document provides a good overview of the GEM API
principles. Buffer allocation and read and write operations, described
as part of the common GEM API, are currently implemented using
driver-specific ioctls.

GEM is data-agnostic. It manages abstract buffer objects without knowing
what individual buffers contain. APIs that require knowledge of buffer
contents or purpose, such as buffer allocation or synchronization
primitives, are thus outside of the scope of GEM and must be implemented
using driver-specific ioctls.

On a fundamental level, GEM involves several operations:
\begin{itemize}
\item {} 
Memory allocation and freeing

\item {} 
Command execution

\item {} 
Aperture management at command execution time

\end{itemize}

Buffer object allocation is relatively straightforward and largely
provided by Linux's shmem layer, which provides memory to back each
object.

Device-specific operations, such as command execution, pinning, buffer
read \& write, mapping, and domain ownership transfers are left to
driver-specific ioctls.


\subsection{GEM Initialization}
\label{gpu/drm-mm:gem-initialization}
Drivers that use GEM must set the DRIVER\_GEM bit in the struct
{\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{struct drm\_driver}}}} driver\_features
field. The DRM core will then automatically initialize the GEM core
before calling the load operation. Behind the scene, this will create a
DRM Memory Manager object which provides an address space pool for
object allocation.

In a KMS configuration, drivers need to allocate and initialize a
command ring buffer following core GEM initialization if required by the
hardware. UMA devices usually have what is called a ``stolen'' memory
region, which provides space for the initial framebuffer and large,
contiguous memory regions required by the device. This space is
typically not managed by GEM, and must be initialized separately into
its own DRM MM object.


\subsection{GEM Objects Creation}
\label{gpu/drm-mm:gem-objects-creation}
GEM splits creation of GEM objects and allocation of the memory that
backs them in two distinct operations.

GEM objects are represented by an instance of struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{\code{struct
drm\_gem\_object}}}}. Drivers usually need to
extend GEM objects with private information and thus create a
driver-specific GEM object structure type that embeds an instance of
struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{\code{struct drm\_gem\_object}}}}.

To create a GEM object, a driver allocates memory for an instance of its
specific GEM object type and initializes the embedded struct
{\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{\code{struct drm\_gem\_object}}}} with a call
to {\hyperref[gpu/drm\string-mm:c.drm_gem_object_init]{\emph{\code{drm\_gem\_object\_init()}}}}. The function takes a pointer
to the DRM device, a pointer to the GEM object and the buffer object
size in bytes.

GEM uses shmem to allocate anonymous pageable memory.
{\hyperref[gpu/drm\string-mm:c.drm_gem_object_init]{\emph{\code{drm\_gem\_object\_init()}}}} will create an shmfs file of the
requested size and store it into the struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{\code{struct
drm\_gem\_object}}}} filp field. The memory is
used as either main storage for the object when the graphics hardware
uses system memory directly or as a backing store otherwise.

Drivers are responsible for the actual physical pages allocation by
calling \code{shmem\_read\_mapping\_page\_gfp()} for each page.
Note that they can decide to allocate pages when initializing the GEM
object, or to delay allocation until the memory is needed (for instance
when a page fault occurs as a result of a userspace memory access or
when the driver needs to start a DMA transfer involving the memory).

Anonymous pageable memory allocation is not always desired, for instance
when the hardware requires physically contiguous system memory as is
often the case in embedded devices. Drivers can create GEM objects with
no shmfs backing (called private GEM objects) by initializing them with
a call to {\hyperref[gpu/drm\string-mm:c.drm_gem_private_object_init]{\emph{\code{drm\_gem\_private\_object\_init()}}}} instead of
{\hyperref[gpu/drm\string-mm:c.drm_gem_object_init]{\emph{\code{drm\_gem\_object\_init()}}}}. Storage for private GEM objects
must be managed by drivers.


\subsection{GEM Objects Lifetime}
\label{gpu/drm-mm:gem-objects-lifetime}
All GEM objects are reference-counted by the GEM core. References can be
acquired and release by \code{calling drm\_gem\_object\_get()} and
{\hyperref[gpu/drm\string-mm:c.drm_gem_object_put]{\emph{\code{drm\_gem\_object\_put()}}}} respectively. The caller must hold the
\code{struct drm\_device} struct\_mutex lock when calling
{\hyperref[gpu/drm\string-mm:c.drm_gem_object_get]{\emph{\code{drm\_gem\_object\_get()}}}}. As a convenience, GEM provides
{\hyperref[gpu/drm\string-mm:c.drm_gem_object_put_unlocked]{\emph{\code{drm\_gem\_object\_put\_unlocked()}}}} functions that can be called without
holding the lock.

When the last reference to a GEM object is released the GEM core calls
the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{struct drm\_driver}}}} gem\_free\_object\_unlocked
operation. That operation is mandatory for GEM-enabled drivers and must
free the GEM object and all associated resources.

void (*gem\_free\_object) (struct drm\_gem\_object *obj); Drivers are
responsible for freeing all GEM object resources. This includes the
resources created by the GEM core, which need to be released with
{\hyperref[gpu/drm\string-mm:c.drm_gem_object_release]{\emph{\code{drm\_gem\_object\_release()}}}}.


\subsection{GEM Objects Naming}
\label{gpu/drm-mm:gem-objects-naming}
Communication between userspace and the kernel refers to GEM objects
using local handles, global names or, more recently, file descriptors.
All of those are 32-bit integer values; the usual Linux kernel limits
apply to the file descriptors.

GEM handles are local to a DRM file. Applications get a handle to a GEM
object through a driver-specific ioctl, and can use that handle to refer
to the GEM object in other standard or driver-specific ioctls. Closing a
DRM file handle frees all its GEM handles and dereferences the
associated GEM objects.

To create a handle for a GEM object drivers call
{\hyperref[gpu/drm\string-mm:c.drm_gem_handle_create]{\emph{\code{drm\_gem\_handle\_create()}}}}. The function takes a pointer
to the DRM file and the GEM object and returns a locally unique handle.
When the handle is no longer needed drivers delete it with a call to
{\hyperref[gpu/drm\string-mm:c.drm_gem_handle_delete]{\emph{\code{drm\_gem\_handle\_delete()}}}}. Finally the GEM object
associated with a handle can be retrieved by a call to
{\hyperref[gpu/drm\string-mm:c.drm_gem_object_lookup]{\emph{\code{drm\_gem\_object\_lookup()}}}}.

Handles don't take ownership of GEM objects, they only take a reference
to the object that will be dropped when the handle is destroyed. To
avoid leaking GEM objects, drivers must make sure they drop the
reference(s) they own (such as the initial reference taken at object
creation time) as appropriate, without any special consideration for the
handle. For example, in the particular case of combined GEM object and
handle creation in the implementation of the dumb\_create operation,
drivers must drop the initial reference to the GEM object before
returning the handle.

GEM names are similar in purpose to handles but are not local to DRM
files. They can be passed between processes to reference a GEM object
globally. Names can't be used directly to refer to objects in the DRM
API, applications must convert handles to names and names to handles
using the DRM\_IOCTL\_GEM\_FLINK and DRM\_IOCTL\_GEM\_OPEN ioctls
respectively. The conversion is handled by the DRM core without any
driver-specific support.

GEM also supports buffer sharing with dma-buf file descriptors through
PRIME. GEM-based drivers must use the provided helpers functions to
implement the exporting and importing correctly. See ?. Since sharing
file descriptors is inherently more secure than the easily guessable and
global GEM names it is the preferred buffer sharing mechanism. Sharing
buffers through GEM names is only supported for legacy userspace.
Furthermore PRIME also allows cross-device buffer sharing since it is
based on dma-bufs.


\subsection{GEM Objects Mapping}
\label{gpu/drm-mm:gem-objects-mapping}
Because mapping operations are fairly heavyweight GEM favours
read/write-like access to buffers, implemented through driver-specific
ioctls, over mapping buffers to userspace. However, when random access
to the buffer is needed (to perform software rendering for instance),
direct access to the object can be more efficient.

The mmap system call can't be used directly to map GEM objects, as they
don't have their own file handle. Two alternative methods currently
co-exist to map GEM objects to userspace. The first method uses a
driver-specific ioctl to perform the mapping operation, calling
\code{do\_mmap()} under the hood. This is often considered
dubious, seems to be discouraged for new GEM-enabled drivers, and will
thus not be described here.

The second method uses the mmap system call on the DRM file handle. void
*mmap(void *addr, size\_t length, int prot, int flags, int fd, off\_t
offset); DRM identifies the GEM object to be mapped by a fake offset
passed through the mmap offset argument. Prior to being mapped, a GEM
object must thus be associated with a fake offset. To do so, drivers
must call {\hyperref[gpu/drm\string-mm:c.drm_gem_create_mmap_offset]{\emph{\code{drm\_gem\_create\_mmap\_offset()}}}} on the object.

Once allocated, the fake offset value must be passed to the application
in a driver-specific way and can then be used as the mmap offset
argument.

The GEM core provides a helper method {\hyperref[gpu/drm\string-mm:c.drm_gem_mmap]{\emph{\code{drm\_gem\_mmap()}}}} to
handle object mapping. The method can be set directly as the mmap file
operation handler. It will look up the GEM object based on the offset
value and set the VMA operations to the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{struct drm\_driver}}}} gem\_vm\_ops field. Note that
{\hyperref[gpu/drm\string-mm:c.drm_gem_mmap]{\emph{\code{drm\_gem\_mmap()}}}} doesn't map memory to userspace, but
relies on the driver-provided fault handler to map pages individually.

To use {\hyperref[gpu/drm\string-mm:c.drm_gem_mmap]{\emph{\code{drm\_gem\_mmap()}}}}, drivers must fill the struct
{\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{struct drm\_driver}}}} gem\_vm\_ops field
with a pointer to VM operations.

The VM operations is a \code{struct vm\_operations\_struct}
made up of several fields, the more interesting ones being:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{vm\PYGZus{}operations\PYGZus{}struct} \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{void} \PYG{p}{(}\PYG{o}{*}\PYG{n}{open}\PYG{p}{)}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{vm\PYGZus{}area\PYGZus{}struct} \PYG{o}{*} \PYG{n}{area}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{void} \PYG{p}{(}\PYG{o}{*}\PYG{n}{close}\PYG{p}{)}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{vm\PYGZus{}area\PYGZus{}struct} \PYG{o}{*} \PYG{n}{area}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{p}{(}\PYG{o}{*}\PYG{n}{fault}\PYG{p}{)}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{vm\PYGZus{}fault} \PYG{o}{*}\PYG{n}{vmf}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

The open and close operations must update the GEM object reference
count. Drivers can use the {\hyperref[gpu/drm\string-mm:c.drm_gem_vm_open]{\emph{\code{drm\_gem\_vm\_open()}}}} and
{\hyperref[gpu/drm\string-mm:c.drm_gem_vm_close]{\emph{\code{drm\_gem\_vm\_close()}}}} helper functions directly as open
and close handlers.

The fault operation handler is responsible for mapping individual pages
to userspace when a page fault occurs. Depending on the memory
allocation scheme, drivers can allocate pages at fault time, or can
decide to allocate memory for the GEM object at the time the object is
created.

Drivers that want to map the GEM object upfront instead of handling page
faults can implement their own mmap file operation handler.

For platforms without MMU the GEM core provides a helper method
{\hyperref[gpu/drm\string-mm:c.drm_gem_cma_get_unmapped_area]{\emph{\code{drm\_gem\_cma\_get\_unmapped\_area()}}}}. The mmap() routines will call
this to get a proposed address for the mapping.

To use {\hyperref[gpu/drm\string-mm:c.drm_gem_cma_get_unmapped_area]{\emph{\code{drm\_gem\_cma\_get\_unmapped\_area()}}}}, drivers must fill the
struct \code{struct file\_operations} get\_unmapped\_area
field with a pointer on {\hyperref[gpu/drm\string-mm:c.drm_gem_cma_get_unmapped_area]{\emph{\code{drm\_gem\_cma\_get\_unmapped\_area()}}}}.

More detailed information about get\_unmapped\_area can be found in
Documentation/nommu-mmap.txt


\subsection{Memory Coherency}
\label{gpu/drm-mm:memory-coherency}
When mapped to the device or used in a command buffer, backing pages for
an object are flushed to memory and marked write combined so as to be
coherent with the GPU. Likewise, if the CPU accesses an object after the
GPU has finished rendering to the object, then the object must be made
coherent with the CPU's view of memory, usually involving GPU cache
flushing of various kinds. This core CPU\textless{}-\textgreater{}GPU coherency management is
provided by a device-specific ioctl, which evaluates an object's current
domain and performs any necessary flushing or synchronization to put the
object into the desired coherency domain (note that the object may be
busy, i.e. an active render target; in that case, setting the domain
blocks the client and waits for rendering to complete before performing
any necessary flushing operations).


\subsection{Command Execution}
\label{gpu/drm-mm:command-execution}
Perhaps the most important GEM function for GPU devices is providing a
command execution interface to clients. Client programs construct
command buffers containing references to previously allocated memory
objects, and then submit them to GEM. At that point, GEM takes care to
bind all the objects into the GTT, execute the buffer, and provide
necessary synchronization between clients accessing the same buffers.
This often involves evicting some objects from the GTT and re-binding
others (a fairly expensive operation), and providing relocation support
which hides fixed GTT offsets from clients. Clients must take care not
to submit command buffers that reference more objects than can fit in
the GTT; otherwise, GEM will reject them and no rendering will occur.
Similarly, if several objects in the buffer require fence registers to
be allocated for correct rendering (e.g. 2D blits on pre-965 chips),
care must be taken not to require more fence registers than are
available to the client. Such resource management should be abstracted
from the client in libdrm.


\subsection{GEM Function Reference}
\label{gpu/drm-mm:gem-function-reference}\index{drm\_gem\_object (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_object}\pysigline{struct \bfcode{drm\_gem\_object}}
GEM buffer object

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}gem\PYGZus{}object \PYGZob{}
  struct kref refcount;
  unsigned handle\PYGZus{}count;
  struct drm\PYGZus{}device *dev;
  struct file *filp;
  struct drm\PYGZus{}vma\PYGZus{}offset\PYGZus{}node vma\PYGZus{}node;
  size\PYGZus{}t size;
  int name;
  uint32\PYGZus{}t read\PYGZus{}domains;
  uint32\PYGZus{}t write\PYGZus{}domain;
  struct dma\PYGZus{}buf *dma\PYGZus{}buf;
  struct dma\PYGZus{}buf\PYGZus{}attachment *import\PYGZus{}attach;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{refcount}}] \leavevmode
Reference count of this object

Please use {\hyperref[gpu/drm\string-mm:c.drm_gem_object_get]{\emph{\code{drm\_gem\_object\_get()}}}} to acquire and {\hyperref[gpu/drm\string-mm:c.drm_gem_object_put]{\emph{\code{drm\_gem\_object\_put()}}}}
or {\hyperref[gpu/drm\string-mm:c.drm_gem_object_put_unlocked]{\emph{\code{drm\_gem\_object\_put\_unlocked()}}}} to release a reference to a GEM
buffer object.

\item[{\code{handle\_count}}] \leavevmode
This is the GEM file\_priv handle count of this object.

Each handle also holds a reference. Note that when the handle\_count
drops to 0 any global names (e.g. the id in the flink namespace) will
be cleared.

Protected by \code{drm\_device.object\_name\_lock}.

\item[{\code{dev}}] \leavevmode
DRM dev this object belongs to.

\item[{\code{filp}}] \leavevmode
SHMEM file node used as backing storage for swappable buffer objects.
GEM also supports driver private objects with driver-specific backing
storage (contiguous CMA memory, special reserved blocks). In this
case \textbf{filp} is NULL.

\item[{\code{vma\_node}}] \leavevmode
Mapping info for this object to support mmap. Drivers are supposed to
allocate the mmap offset using {\hyperref[gpu/drm\string-mm:c.drm_gem_create_mmap_offset]{\emph{\code{drm\_gem\_create\_mmap\_offset()}}}}. The
offset itself can be retrieved using {\hyperref[gpu/drm\string-mm:c.drm_vma_node_offset_addr]{\emph{\code{drm\_vma\_node\_offset\_addr()}}}}.

Memory mapping itself is handled by {\hyperref[gpu/drm\string-mm:c.drm_gem_mmap]{\emph{\code{drm\_gem\_mmap()}}}}, which also checks
that userspace is allowed to access the object.

\item[{\code{size}}] \leavevmode
Size of the object, in bytes.  Immutable over the object's
lifetime.

\item[{\code{name}}] \leavevmode
Global name for this object, starts at 1. 0 means unnamed.
Access is covered by \code{drm\_device.object\_name\_lock}. This is used by
the GEM\_FLINK and GEM\_OPEN ioctls.

\item[{\code{read\_domains}}] \leavevmode
Read memory domains. These monitor which caches contain read/write data
related to the object. When transitioning from one set of domains
to another, the driver is called to ensure that caches are suitably
flushed and invalidated.

\item[{\code{write\_domain}}] \leavevmode
Corresponding unique write memory domain.

\item[{\code{dma\_buf}}] \leavevmode
dma-buf associated with this GEM object.

Pointer to the dma-buf associated with this gem object (either
through importing or exporting). We break the resulting reference
loop when the last gem handle for this object is released.

Protected by \code{drm\_device.object\_name\_lock}.

\item[{\code{import\_attach}}] \leavevmode
dma-buf attachment backing this object.

Any foreign dma\_buf imported as a gem object has this set to the
attachment point for the device. This is invariant over the lifetime
of a gem object.

The {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.gem\_free\_object}}}} callback is responsible for cleaning
up the dma\_buf attachment and references acquired at import time.

Note that the drm gem/prime core does not depend upon drivers setting
this field any more. So for drivers where this doesn't make sense
(e.g. virtual devices or a displaylink behind an usb bus) they can
simply leave it as NULL.

\end{description}

\textbf{Description}

This structure defines the generic parts for GEM buffer objects, which are
mostly around handling mmap and userspace handles.

Buffer objects are often abbreviated to BO.
\index{DEFINE\_DRM\_GEM\_FOPS (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.DEFINE_DRM_GEM_FOPS}\pysiglinewithargsret{\bfcode{DEFINE\_DRM\_GEM\_FOPS}}{\emph{name}}{}
macro to generate file operations for GEM drivers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{name}}] \leavevmode
name for the generated structure

\end{description}

\textbf{Description}

This macro autogenerates a suitable \code{struct file\_operations} for GEM based
drivers, which can be assigned to {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.fops}}}}. Note that this structure
cannot be shared between drivers, because it contains a reference to the
current module using THIS\_MODULE.

Note that the declaration is already marked as static - if you need a
non-static version of this you're probably doing it wrong and will break the
THIS\_MODULE reference by accident.
\index{drm\_gem\_object\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_object_get}\pysiglinewithargsret{void \bfcode{drm\_gem\_object\_get}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}}{}
acquire a GEM buffer object reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
GEM buffer object

\end{description}

\textbf{Description}

This function acquires an additional reference to \textbf{obj}. It is illegal to
call this without already holding a reference. No locks required.
\index{\_\_drm\_gem\_object\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.__drm_gem_object_put}\pysiglinewithargsret{void \bfcode{\_\_drm\_gem\_object\_put}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}}{}
raw function to release a GEM buffer object reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
GEM buffer object

\end{description}

\textbf{Description}

This function is meant to be used by drivers which are not encumbered with
\code{drm\_device.struct\_mutex} legacy locking and which are using the
gem\_free\_object\_unlocked callback. It avoids all the locking checks and
locking overhead of {\hyperref[gpu/drm\string-mm:c.drm_gem_object_put]{\emph{\code{drm\_gem\_object\_put()}}}} and {\hyperref[gpu/drm\string-mm:c.drm_gem_object_put_unlocked]{\emph{\code{drm\_gem\_object\_put\_unlocked()}}}}.

Drivers should never call this directly in their code. Instead they should
wrap it up into a \code{driver\_gem\_object\_put(struct driver\_gem\_object *obj)}
wrapper function, and use that. Shared code should never call this, to
avoid breaking drivers by accident which still depend upon
\code{drm\_device.struct\_mutex} locking.
\index{drm\_gem\_object\_reference (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_object_reference}\pysiglinewithargsret{void \bfcode{drm\_gem\_object\_reference}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}}{}
acquire a GEM buffer object reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
GEM buffer object

\end{description}

\textbf{Description}

This is a compatibility alias for {\hyperref[gpu/drm\string-mm:c.drm_gem_object_get]{\emph{\code{drm\_gem\_object\_get()}}}} and should not be
used by new code.
\index{\_\_drm\_gem\_object\_unreference (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.__drm_gem_object_unreference}\pysiglinewithargsret{void \bfcode{\_\_drm\_gem\_object\_unreference}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}}{}
raw function to release a GEM buffer object reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
GEM buffer object

\end{description}

\textbf{Description}

This is a compatibility alias for {\hyperref[gpu/drm\string-mm:c.__drm_gem_object_put]{\emph{\code{\_\_drm\_gem\_object\_put()}}}} and should not be
used by new code.
\index{drm\_gem\_object\_unreference\_unlocked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_object_unreference_unlocked}\pysiglinewithargsret{void \bfcode{drm\_gem\_object\_unreference\_unlocked}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}}{}
release a GEM buffer object reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
GEM buffer object

\end{description}

\textbf{Description}

This is a compatibility alias for {\hyperref[gpu/drm\string-mm:c.drm_gem_object_put_unlocked]{\emph{\code{drm\_gem\_object\_put\_unlocked()}}}} and should
not be used by new code.
\index{drm\_gem\_object\_unreference (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_object_unreference}\pysiglinewithargsret{void \bfcode{drm\_gem\_object\_unreference}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}}{}
release a GEM buffer object reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
GEM buffer object

\end{description}

\textbf{Description}

This is a compatibility alias for {\hyperref[gpu/drm\string-mm:c.drm_gem_object_put]{\emph{\code{drm\_gem\_object\_put()}}}} and should not be
used by new code.
\index{drm\_gem\_object\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_object_init}\pysiglinewithargsret{int \bfcode{drm\_gem\_object\_init}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}, size\_t\emph{ size}}{}
initialize an allocated shmem-backed GEM object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm\_device the object should be initialized for

\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
drm\_gem\_object to initialize

\item[{\code{size\_t size}}] \leavevmode
object size

\end{description}

\textbf{Description}

Initialize an already allocated GEM object of the specified size with
shmfs backing store.
\index{drm\_gem\_private\_object\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_private_object_init}\pysiglinewithargsret{void \bfcode{drm\_gem\_private\_object\_init}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}, size\_t\emph{ size}}{}
initialize an allocated private GEM object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm\_device the object should be initialized for

\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
drm\_gem\_object to initialize

\item[{\code{size\_t size}}] \leavevmode
object size

\end{description}

\textbf{Description}

Initialize an already allocated GEM object of the specified size with
no GEM provided backing store. Instead the caller is responsible for
backing the object and handling it.
\index{drm\_gem\_handle\_delete (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_handle_delete}\pysiglinewithargsret{int \bfcode{drm\_gem\_handle\_delete}}{struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ filp}, u32\emph{ handle}}{}
deletes the given file-private handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_file * filp}}] \leavevmode
drm file-private structure to use for the handle look up

\item[{\code{u32 handle}}] \leavevmode
userspace handle to delete

\end{description}

\textbf{Description}

Removes the GEM handle from the \textbf{filp} lookup table which has been added with
{\hyperref[gpu/drm\string-mm:c.drm_gem_handle_create]{\emph{\code{drm\_gem\_handle\_create()}}}}. If this is the last handle also cleans up linked
resources like GEM names.
\index{drm\_gem\_dumb\_map\_offset (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_dumb_map_offset}\pysiglinewithargsret{int \bfcode{drm\_gem\_dumb\_map\_offset}}{struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file}, struct drm\_device *\emph{ dev}, u32\emph{ handle}, u64 *\emph{ offset}}{}
return the fake mmap offset for a gem object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_file * file}}] \leavevmode
drm file-private structure containing the gem object

\item[{\code{struct drm\_device * dev}}] \leavevmode
corresponding drm\_device

\item[{\code{u32 handle}}] \leavevmode
gem object handle

\item[{\code{u64 * offset}}] \leavevmode
return location for the fake mmap offset

\end{description}

\textbf{Description}

This implements the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.dumb\_map\_offset}}}} kms driver callback for
drivers which use gem to manage their backing storage.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_gem\_dumb\_destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_dumb_destroy}\pysiglinewithargsret{int \bfcode{drm\_gem\_dumb\_destroy}}{struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file}, struct drm\_device *\emph{ dev}, uint32\_t\emph{ handle}}{}
dumb fb callback helper for gem based drivers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_file * file}}] \leavevmode
drm file-private structure to remove the dumb handle from

\item[{\code{struct drm\_device * dev}}] \leavevmode
corresponding drm\_device

\item[{\code{uint32\_t handle}}] \leavevmode
the dumb handle to remove

\end{description}

\textbf{Description}

This implements the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.dumb\_destroy}}}} kms driver callback for drivers
which use gem to manage their backing storage.
\index{drm\_gem\_handle\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_handle_create}\pysiglinewithargsret{int \bfcode{drm\_gem\_handle\_create}}{struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}, struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}, u32 *\emph{ handlep}}{}
create a gem handle for an object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
drm file-private structure to register the handle for

\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
object to register

\item[{\code{u32 * handlep}}] \leavevmode
pionter to return the created handle to the caller

\end{description}

\textbf{Description}

Create a handle for this object. This adds a handle reference
to the object, which includes a regular reference count. Callers
will likely want to dereference the object afterwards.
\index{drm\_gem\_free\_mmap\_offset (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_free_mmap_offset}\pysiglinewithargsret{void \bfcode{drm\_gem\_free\_mmap\_offset}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}}{}
release a fake mmap offset for an object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
obj in question

\end{description}

\textbf{Description}

This routine frees fake offsets allocated by {\hyperref[gpu/drm\string-mm:c.drm_gem_create_mmap_offset]{\emph{\code{drm\_gem\_create\_mmap\_offset()}}}}.

Note that {\hyperref[gpu/drm\string-mm:c.drm_gem_object_release]{\emph{\code{drm\_gem\_object\_release()}}}} already calls this function, so drivers
don't have to take care of releasing the mmap offset themselves when freeing
the GEM object.
\index{drm\_gem\_create\_mmap\_offset\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_create_mmap_offset_size}\pysiglinewithargsret{int \bfcode{drm\_gem\_create\_mmap\_offset\_size}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}, size\_t\emph{ size}}{}
create a fake mmap offset for an object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
obj in question

\item[{\code{size\_t size}}] \leavevmode
the virtual size

\end{description}

\textbf{Description}

GEM memory mapping works by handing back to userspace a fake mmap offset
it can use in a subsequent mmap(2) call.  The DRM core code then looks
up the object based on the offset and sets up the various memory mapping
structures.

This routine allocates and attaches a fake offset for \textbf{obj}, in cases where
the virtual size differs from the physical size (ie. {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{\code{drm\_gem\_object.size}}}}).
Otherwise just use {\hyperref[gpu/drm\string-mm:c.drm_gem_create_mmap_offset]{\emph{\code{drm\_gem\_create\_mmap\_offset()}}}}.

This function is idempotent and handles an already allocated mmap offset
transparently. Drivers do not need to check for this case.
\index{drm\_gem\_create\_mmap\_offset (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_create_mmap_offset}\pysiglinewithargsret{int \bfcode{drm\_gem\_create\_mmap\_offset}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}}{}
create a fake mmap offset for an object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
obj in question

\end{description}

\textbf{Description}

GEM memory mapping works by handing back to userspace a fake mmap offset
it can use in a subsequent mmap(2) call.  The DRM core code then looks
up the object based on the offset and sets up the various memory mapping
structures.

This routine allocates and attaches a fake offset for \textbf{obj}.

Drivers can call {\hyperref[gpu/drm\string-mm:c.drm_gem_free_mmap_offset]{\emph{\code{drm\_gem\_free\_mmap\_offset()}}}} before freeing \textbf{obj} to release
the fake offset again.
\index{drm\_gem\_get\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_get_pages}\pysiglinewithargsret{struct page ** \bfcode{drm\_gem\_get\_pages}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}}{}
helper to allocate backing pages for a GEM object from shmem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
obj in question

\end{description}

\textbf{Description}

This reads the page-array of the shmem-backing storage of the given gem
object. An array of pages is returned. If a page is not allocated or
swapped-out, this will allocate/swap-in the required pages. Note that the
whole object is covered by the page-array and pinned in memory.

Use {\hyperref[gpu/drm\string-mm:c.drm_gem_put_pages]{\emph{\code{drm\_gem\_put\_pages()}}}} to release the array and unpin all pages.

This uses the GFP-mask set on the shmem-mapping (see \code{mapping\_set\_gfp\_mask()}).
If you require other GFP-masks, you have to do those allocations yourself.

Note that you are not allowed to change gfp-zones during runtime. That is,
\code{shmem\_read\_mapping\_page\_gfp()} must be called with the same gfp\_zone(gfp) as
set during initialization. If you have special zone constraints, set them
after {\hyperref[gpu/drm\string-mm:c.drm_gem_object_init]{\emph{\code{drm\_gem\_object\_init()}}}} via \code{mapping\_set\_gfp\_mask()}. shmem-core takes care
to keep pages in the required zone during swap-in.
\index{drm\_gem\_put\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_put_pages}\pysiglinewithargsret{void \bfcode{drm\_gem\_put\_pages}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}, struct page **\emph{ pages}, bool\emph{ dirty}, bool\emph{ accessed}}{}
helper to free backing pages for a GEM object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
obj in question

\item[{\code{struct page ** pages}}] \leavevmode
pages to free

\item[{\code{bool dirty}}] \leavevmode
if true, pages will be marked as dirty

\item[{\code{bool accessed}}] \leavevmode
if true, the pages will be marked as accessed

\end{description}
\index{drm\_gem\_object\_lookup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_object_lookup}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} * \bfcode{drm\_gem\_object\_lookup}}{struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ filp}, u32\emph{ handle}}{}
look up a GEM object from it's handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_file * filp}}] \leavevmode
DRM file private date

\item[{\code{u32 handle}}] \leavevmode
userspace handle

\end{description}

\textbf{Return}

A reference to the object named by the handle if such exists on \textbf{filp}, NULL
otherwise.
\index{drm\_gem\_object\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_object_release}\pysiglinewithargsret{void \bfcode{drm\_gem\_object\_release}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}}{}
release GEM buffer object resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
GEM buffer object

\end{description}

\textbf{Description}

This releases any structures and resources used by \textbf{obj} and is the invers of
{\hyperref[gpu/drm\string-mm:c.drm_gem_object_init]{\emph{\code{drm\_gem\_object\_init()}}}}.
\index{drm\_gem\_object\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_object_free}\pysiglinewithargsret{void \bfcode{drm\_gem\_object\_free}}{struct kref *\emph{ kref}}{}
free a GEM object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kref * kref}}] \leavevmode
kref of the object to free

\end{description}

\textbf{Description}

Called after the last reference to the object has been lost.
Must be called holding \code{drm\_device.struct\_mutex}.

Frees the object
\index{drm\_gem\_object\_put\_unlocked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_object_put_unlocked}\pysiglinewithargsret{void \bfcode{drm\_gem\_object\_put\_unlocked}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}}{}
drop a GEM buffer object reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
GEM buffer object

\end{description}

\textbf{Description}

This releases a reference to \textbf{obj}. Callers must not hold the
\code{drm\_device.struct\_mutex} lock when calling this function.

See also {\hyperref[gpu/drm\string-mm:c.__drm_gem_object_put]{\emph{\code{\_\_drm\_gem\_object\_put()}}}}.
\index{drm\_gem\_object\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_object_put}\pysiglinewithargsret{void \bfcode{drm\_gem\_object\_put}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}}{}
release a GEM buffer object reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
GEM buffer object

\end{description}

\textbf{Description}

This releases a reference to \textbf{obj}. Callers must hold the
\code{drm\_device.struct\_mutex} lock when calling this function, even when the
driver doesn't use \code{drm\_device.struct\_mutex} for anything.

For drivers not encumbered with legacy locking use
{\hyperref[gpu/drm\string-mm:c.drm_gem_object_put_unlocked]{\emph{\code{drm\_gem\_object\_put\_unlocked()}}}} instead.
\index{drm\_gem\_vm\_open (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_vm_open}\pysiglinewithargsret{void \bfcode{drm\_gem\_vm\_open}}{struct vm\_area\_struct *\emph{ vma}}{}
vma-\textgreater{}ops-\textgreater{}open implementation for GEM

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vm\_area\_struct * vma}}] \leavevmode
VM area structure

\end{description}

\textbf{Description}

This function implements the \#vm\_operations\_struct \code{open()} callback for GEM
drivers. This must be used together with {\hyperref[gpu/drm\string-mm:c.drm_gem_vm_close]{\emph{\code{drm\_gem\_vm\_close()}}}}.
\index{drm\_gem\_vm\_close (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_vm_close}\pysiglinewithargsret{void \bfcode{drm\_gem\_vm\_close}}{struct vm\_area\_struct *\emph{ vma}}{}
vma-\textgreater{}ops-\textgreater{}close implementation for GEM

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vm\_area\_struct * vma}}] \leavevmode
VM area structure

\end{description}

\textbf{Description}

This function implements the \#vm\_operations\_struct \code{close()} callback for GEM
drivers. This must be used together with {\hyperref[gpu/drm\string-mm:c.drm_gem_vm_open]{\emph{\code{drm\_gem\_vm\_open()}}}}.
\index{drm\_gem\_mmap\_obj (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_mmap_obj}\pysiglinewithargsret{int \bfcode{drm\_gem\_mmap\_obj}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}, unsigned long\emph{ obj\_size}, struct vm\_area\_struct *\emph{ vma}}{}
memory map a GEM object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
the GEM object to map

\item[{\code{unsigned long obj\_size}}] \leavevmode
the object size to be mapped, in bytes

\item[{\code{struct vm\_area\_struct * vma}}] \leavevmode
VMA for the area to be mapped

\end{description}

\textbf{Description}

Set up the VMA to prepare mapping of the GEM object using the gem\_vm\_ops
provided by the driver. Depending on their requirements, drivers can either
provide a fault handler in their gem\_vm\_ops (in which case any accesses to
the object will be trapped, to perform migration, GTT binding, surface
register allocation, or performance monitoring), or mmap the buffer memory
synchronously after calling drm\_gem\_mmap\_obj.

This function is mainly intended to implement the DMABUF mmap operation, when
the GEM object is not looked up based on its fake offset. To implement the
DRM mmap operation, drivers should use the {\hyperref[gpu/drm\string-mm:c.drm_gem_mmap]{\emph{\code{drm\_gem\_mmap()}}}} function.

{\hyperref[gpu/drm\string-mm:c.drm_gem_mmap_obj]{\emph{\code{drm\_gem\_mmap\_obj()}}}} assumes the user is granted access to the buffer while
{\hyperref[gpu/drm\string-mm:c.drm_gem_mmap]{\emph{\code{drm\_gem\_mmap()}}}} prevents unprivileged users from mapping random objects. So
callers must verify access restrictions before calling this helper.

Return 0 or success or -EINVAL if the object size is smaller than the VMA
size, or if no gem\_vm\_ops are provided.
\index{drm\_gem\_mmap (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_mmap}\pysiglinewithargsret{int \bfcode{drm\_gem\_mmap}}{struct file *\emph{ filp}, struct vm\_area\_struct *\emph{ vma}}{}
memory map routine for GEM objects

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
DRM file pointer

\item[{\code{struct vm\_area\_struct * vma}}] \leavevmode
VMA for the area to be mapped

\end{description}

\textbf{Description}

If a driver supports GEM object mapping, mmap calls on the DRM file
descriptor will end up here.

Look up the GEM object based on the offset passed in (vma-\textgreater{}vm\_pgoff will
contain the fake offset we created when the GTT map ioctl was called on
the object) and map it with a call to {\hyperref[gpu/drm\string-mm:c.drm_gem_mmap_obj]{\emph{\code{drm\_gem\_mmap\_obj()}}}}.

If the caller is not granted access to the buffer object, the mmap will fail
with EACCES. Please see the vma manager for more information.


\subsection{GEM CMA Helper Functions Reference}
\label{gpu/drm-mm:gem-cma-helper-functions-reference}
The Contiguous Memory Allocator reserves a pool of memory at early boot
that is used to service requests for large blocks of contiguous memory.

The DRM GEM/CMA helpers use this allocator as a means to provide buffer
objects that are physically contiguous in memory. This is useful for
display drivers that are unable to map scattered buffers via an IOMMU.
\index{drm\_gem\_cma\_object (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_cma_object}\pysigline{struct \bfcode{drm\_gem\_cma\_object}}
GEM object backed by CMA memory allocations

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}gem\PYGZus{}cma\PYGZus{}object \PYGZob{}
  struct drm\PYGZus{}gem\PYGZus{}object base;
  dma\PYGZus{}addr\PYGZus{}t paddr;
  struct sg\PYGZus{}table *sgt;
  void *vaddr;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{base}}] \leavevmode
base GEM object

\item[{\code{paddr}}] \leavevmode
physical address of the backing memory

\item[{\code{sgt}}] \leavevmode
scatter/gather table for imported PRIME buffers. The table can have
more than one entry but they are guaranteed to have contiguous
DMA addresses.

\item[{\code{vaddr}}] \leavevmode
kernel virtual address of the backing memory

\end{description}
\index{DEFINE\_DRM\_GEM\_CMA\_FOPS (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.DEFINE_DRM_GEM_CMA_FOPS}\pysiglinewithargsret{\bfcode{DEFINE\_DRM\_GEM\_CMA\_FOPS}}{\emph{name}}{}
macro to generate file operations for CMA drivers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{name}}] \leavevmode
name for the generated structure

\end{description}

\textbf{Description}

This macro autogenerates a suitable \code{struct file\_operations} for CMA based
drivers, which can be assigned to {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.fops}}}}. Note that this structure
cannot be shared between drivers, because it contains a reference to the
current module using THIS\_MODULE.

Note that the declaration is already marked as static - if you need a
non-static version of this you're probably doing it wrong and will break the
THIS\_MODULE reference by accident.
\index{drm\_gem\_cma\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_cma_create}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_cma_object]{\emph{drm\_gem\_cma\_object}}} * \bfcode{drm\_gem\_cma\_create}}{struct drm\_device *\emph{ drm}, size\_t\emph{ size}}{}
allocate an object with the given size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * drm}}] \leavevmode
DRM device

\item[{\code{size\_t size}}] \leavevmode
size of the object to allocate

\end{description}

\textbf{Description}

This function creates a CMA GEM object and allocates a contiguous chunk of
memory as backing store. The backing memory has the writecombine attribute
set.

\textbf{Return}

A struct drm\_gem\_cma\_object * on success or an \code{ERR\_PTR()}-encoded negative
error code on failure.
\index{drm\_gem\_cma\_free\_object (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_cma_free_object}\pysiglinewithargsret{void \bfcode{drm\_gem\_cma\_free\_object}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ gem\_obj}}{}
free resources associated with a CMA GEM object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * gem\_obj}}] \leavevmode
GEM object to free

\end{description}

\textbf{Description}

This function frees the backing memory of the CMA GEM object, cleans up the
GEM object state and frees the memory used to store the object itself.
Drivers using the CMA helpers should set this as their
{\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.gem\_free\_object\_unlocked}}}} callback.
\index{drm\_gem\_cma\_dumb\_create\_internal (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_cma_dumb_create_internal}\pysiglinewithargsret{int \bfcode{drm\_gem\_cma\_dumb\_create\_internal}}{struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}, struct drm\_device *\emph{ drm}, struct drm\_mode\_create\_dumb *\emph{ args}}{}
create a dumb buffer object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
DRM file-private structure to create the dumb buffer for

\item[{\code{struct drm\_device * drm}}] \leavevmode
DRM device

\item[{\code{struct drm\_mode\_create\_dumb * args}}] \leavevmode
IOCTL data

\end{description}

\textbf{Description}

This aligns the pitch and size arguments to the minimum required. This is
an internal helper that can be wrapped by a driver to account for hardware
with more specific alignment requirements. It should not be used directly
as their {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.dumb\_create}}}} callback.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_gem\_cma\_dumb\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_cma_dumb_create}\pysiglinewithargsret{int \bfcode{drm\_gem\_cma\_dumb\_create}}{struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}, struct drm\_device *\emph{ drm}, struct drm\_mode\_create\_dumb *\emph{ args}}{}
create a dumb buffer object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
DRM file-private structure to create the dumb buffer for

\item[{\code{struct drm\_device * drm}}] \leavevmode
DRM device

\item[{\code{struct drm\_mode\_create\_dumb * args}}] \leavevmode
IOCTL data

\end{description}

\textbf{Description}

This function computes the pitch of the dumb buffer and rounds it up to an
integer number of bytes per pixel. Drivers for hardware that doesn't have
any additional restrictions on the pitch can directly use this function as
their {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.dumb\_create}}}} callback.

For hardware with additional restrictions, drivers can adjust the fields
set up by userspace and pass the IOCTL data along to the
{\hyperref[gpu/drm\string-mm:c.drm_gem_cma_dumb_create_internal]{\emph{\code{drm\_gem\_cma\_dumb\_create\_internal()}}}} function.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_gem\_cma\_mmap (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_cma_mmap}\pysiglinewithargsret{int \bfcode{drm\_gem\_cma\_mmap}}{struct file *\emph{ filp}, struct vm\_area\_struct *\emph{ vma}}{}
memory-map a CMA GEM object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
file object

\item[{\code{struct vm\_area\_struct * vma}}] \leavevmode
VMA for the area to be mapped

\end{description}

\textbf{Description}

This function implements an augmented version of the GEM DRM file mmap
operation for CMA objects: In addition to the usual GEM VMA setup it
immediately faults in the entire object instead of using on-demaind
faulting. Drivers which employ the CMA helpers should use this function
as their -\textgreater{}:c:func:\emph{mmap()} handler in the DRM device file's file\_operations
structure.

Instead of directly referencing this function, drivers should use the
{\hyperref[gpu/drm\string-mm:c.DEFINE_DRM_GEM_CMA_FOPS]{\emph{\code{DEFINE\_DRM\_GEM\_CMA\_FOPS()}}}}.macro.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_gem\_cma\_get\_unmapped\_area (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_cma_get_unmapped_area}\pysiglinewithargsret{unsigned long \bfcode{drm\_gem\_cma\_get\_unmapped\_area}}{struct file *\emph{ filp}, unsigned long\emph{ addr}, unsigned long\emph{ len}, unsigned long\emph{ pgoff}, unsigned long\emph{ flags}}{}
propose address for mapping in noMMU cases

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
file object

\item[{\code{unsigned long addr}}] \leavevmode
memory address

\item[{\code{unsigned long len}}] \leavevmode
buffer size

\item[{\code{unsigned long pgoff}}] \leavevmode
page offset

\item[{\code{unsigned long flags}}] \leavevmode
memory flags

\end{description}

\textbf{Description}

This function is used in noMMU platforms to propose address mapping
for a given buffer.
It's intended to be used as a direct handler for the struct
\code{file\_operations.get\_unmapped\_area} operation.

\textbf{Return}

mapping address on success or a negative error code on failure.
\index{drm\_gem\_cma\_print\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_cma_print_info}\pysiglinewithargsret{void \bfcode{drm\_gem\_cma\_print\_info}}{struct {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{drm\_printer}}} *\emph{ p}, unsigned int\emph{ indent}, const struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}}{}
Print {\hyperref[gpu/drm\string-mm:c.drm_gem_cma_object]{\emph{\code{drm\_gem\_cma\_object}}}} info for debugfs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_printer * p}}] \leavevmode
DRM printer

\item[{\code{unsigned int indent}}] \leavevmode
Tab indentation level

\item[{\code{const struct drm\_gem\_object * obj}}] \leavevmode
GEM object

\end{description}

\textbf{Description}

This function can be used as the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver-\textgreater{}gem\_print\_info}}}} callback.
It prints paddr and vaddr for use in e.g. debugfs output.
\index{drm\_gem\_cma\_prime\_get\_sg\_table (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_cma_prime_get_sg_table}\pysiglinewithargsret{struct sg\_table * \bfcode{drm\_gem\_cma\_prime\_get\_sg\_table}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}}{}
provide a scatter/gather table of pinned pages for a CMA GEM object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
GEM object

\end{description}

\textbf{Description}

This function exports a scatter/gather table suitable for PRIME usage by
calling the standard DMA mapping API. Drivers using the CMA helpers should
set this as their {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.gem\_prime\_get\_sg\_table}}}} callback.

\textbf{Return}

A pointer to the scatter/gather table of pinned pages or NULL on failure.
\index{drm\_gem\_cma\_prime\_import\_sg\_table (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_cma_prime_import_sg_table}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} * \bfcode{drm\_gem\_cma\_prime\_import\_sg\_table}}{struct drm\_device *\emph{ dev}, struct dma\_buf\_attachment *\emph{ attach}, struct sg\_table *\emph{ sgt}}{}
produce a CMA GEM object from another driver's scatter/gather table of pinned pages

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
device to import into

\item[{\code{struct dma\_buf\_attachment * attach}}] \leavevmode
DMA-BUF attachment

\item[{\code{struct sg\_table * sgt}}] \leavevmode
scatter/gather table of pinned pages

\end{description}

\textbf{Description}

This function imports a scatter/gather table exported via DMA-BUF by
another driver. Imported buffers must be physically contiguous in memory
(i.e. the scatter/gather table must contain a single entry). Drivers that
use the CMA helpers should set this as their
{\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.gem\_prime\_import\_sg\_table}}}} callback.

\textbf{Return}

A pointer to a newly created GEM object or an ERR\_PTR-encoded negative
error code on failure.
\index{drm\_gem\_cma\_prime\_mmap (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_cma_prime_mmap}\pysiglinewithargsret{int \bfcode{drm\_gem\_cma\_prime\_mmap}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}, struct vm\_area\_struct *\emph{ vma}}{}
memory-map an exported CMA GEM object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
GEM object

\item[{\code{struct vm\_area\_struct * vma}}] \leavevmode
VMA for the area to be mapped

\end{description}

\textbf{Description}

This function maps a buffer imported via DRM PRIME into a userspace
process's address space. Drivers that use the CMA helpers should set this
as their {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.gem\_prime\_mmap}}}} callback.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_gem\_cma\_prime\_vmap (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_cma_prime_vmap}\pysiglinewithargsret{void * \bfcode{drm\_gem\_cma\_prime\_vmap}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}}{}
map a CMA GEM object into the kernel's virtual address space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
GEM object

\end{description}

\textbf{Description}

This function maps a buffer exported via DRM PRIME into the kernel's
virtual address space. Since the CMA buffers are already mapped into the
kernel virtual address space this simply returns the cached virtual
address. Drivers using the CMA helpers should set this as their DRM
driver's {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.gem\_prime\_vmap}}}} callback.

\textbf{Return}

The kernel virtual address of the CMA GEM object's backing store.
\index{drm\_gem\_cma\_prime\_vunmap (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_cma_prime_vunmap}\pysiglinewithargsret{void \bfcode{drm\_gem\_cma\_prime\_vunmap}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}, void *\emph{ vaddr}}{}
unmap a CMA GEM object from the kernel's virtual address space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
GEM object

\item[{\code{void * vaddr}}] \leavevmode
kernel virtual address where the CMA GEM object was mapped

\end{description}

\textbf{Description}

This function removes a buffer exported via DRM PRIME from the kernel's
virtual address space. This is a no-op because CMA buffers cannot be
unmapped from kernel space. Drivers using the CMA helpers should set this
as their {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.gem\_prime\_vunmap}}}} callback.


\section{VMA Offset Manager}
\label{gpu/drm-mm:vma-offset-manager}
The vma-manager is responsible to map arbitrary driver-dependent memory
regions into the linear user address-space. It provides offsets to the
caller which can then be used on the address\_space of the drm-device. It
takes care to not overlap regions, size them appropriately and to not
confuse mm-core by inconsistent fake vm\_pgoff fields.
Drivers shouldn't use this for object placement in VMEM. This manager should
only be used to manage mappings into linear user-space VMs.

We use drm\_mm as backend to manage object allocations. But it is highly
optimized for alloc/free calls, not lookups. Hence, we use an rb-tree to
speed up offset lookups.

You must not use multiple offset managers on a single address\_space.
Otherwise, mm-core will be unable to tear down memory mappings as the VM will
no longer be linear.

This offset manager works on page-based addresses. That is, every argument
and return code (with the exception of {\hyperref[gpu/drm\string-mm:c.drm_vma_node_offset_addr]{\emph{\code{drm\_vma\_node\_offset\_addr()}}}}) is given
in number of pages, not number of bytes. That means, object sizes and offsets
must always be page-aligned (as usual).
If you want to get a valid byte-based user-space address for a given offset,
please see {\hyperref[gpu/drm\string-mm:c.drm_vma_node_offset_addr]{\emph{\code{drm\_vma\_node\_offset\_addr()}}}}.

Additionally to offset management, the vma offset manager also handles access
management. For every open-file context that is allowed to access a given
node, you must call {\hyperref[gpu/drm\string-mm:c.drm_vma_node_allow]{\emph{\code{drm\_vma\_node\_allow()}}}}. Otherwise, an \code{mmap()} call on this
open-file with the offset of the node will fail with -EACCES. To revoke
access again, use {\hyperref[gpu/drm\string-mm:c.drm_vma_node_revoke]{\emph{\code{drm\_vma\_node\_revoke()}}}}. However, the caller is responsible
for destroying already existing mappings, if required.
\index{drm\_vma\_offset\_exact\_lookup\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_vma_offset_exact_lookup_locked}\pysiglinewithargsret{struct drm\_vma\_offset\_node * \bfcode{drm\_vma\_offset\_exact\_lookup\_locked}}{struct drm\_vma\_offset\_manager *\emph{ mgr}, unsigned long\emph{ start}, unsigned long\emph{ pages}}{}
Look up node by exact address

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_vma\_offset\_manager * mgr}}] \leavevmode
Manager object

\item[{\code{unsigned long start}}] \leavevmode
Start address (page-based, not byte-based)

\item[{\code{unsigned long pages}}] \leavevmode
Size of object (page-based)

\end{description}

\textbf{Description}

Same as {\hyperref[gpu/drm\string-mm:c.drm_vma_offset_lookup_locked]{\emph{\code{drm\_vma\_offset\_lookup\_locked()}}}} but does not allow any offset into the node.
It only returns the exact object with the given start address.

\textbf{Return}

Node at exact start address \textbf{start}.
\index{drm\_vma\_offset\_lock\_lookup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_vma_offset_lock_lookup}\pysiglinewithargsret{void \bfcode{drm\_vma\_offset\_lock\_lookup}}{struct drm\_vma\_offset\_manager *\emph{ mgr}}{}
Lock lookup for extended private use

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_vma\_offset\_manager * mgr}}] \leavevmode
Manager object

\end{description}

\textbf{Description}

Lock VMA manager for extended lookups. Only locked VMA function calls
are allowed while holding this lock. All other contexts are blocked from VMA
until the lock is released via {\hyperref[gpu/drm\string-mm:c.drm_vma_offset_unlock_lookup]{\emph{\code{drm\_vma\_offset\_unlock\_lookup()}}}}.

Use this if you need to take a reference to the objects returned by
{\hyperref[gpu/drm\string-mm:c.drm_vma_offset_lookup_locked]{\emph{\code{drm\_vma\_offset\_lookup\_locked()}}}} before releasing this lock again.

This lock must not be used for anything else than extended lookups. You must
not call any other VMA helpers while holding this lock.

\textbf{Note}

You're in atomic-context while holding this lock!
\index{drm\_vma\_offset\_unlock\_lookup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_vma_offset_unlock_lookup}\pysiglinewithargsret{void \bfcode{drm\_vma\_offset\_unlock\_lookup}}{struct drm\_vma\_offset\_manager *\emph{ mgr}}{}
Unlock lookup for extended private use

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_vma\_offset\_manager * mgr}}] \leavevmode
Manager object

\end{description}

\textbf{Description}

Release lookup-lock. See {\hyperref[gpu/drm\string-mm:c.drm_vma_offset_lock_lookup]{\emph{\code{drm\_vma\_offset\_lock\_lookup()}}}} for more information.
\index{drm\_vma\_node\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_vma_node_reset}\pysiglinewithargsret{void \bfcode{drm\_vma\_node\_reset}}{struct drm\_vma\_offset\_node *\emph{ node}}{}
Initialize or reset node object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_vma\_offset\_node * node}}] \leavevmode
Node to initialize or reset

\end{description}

\textbf{Description}

Reset a node to its initial state. This must be called before using it with
any VMA offset manager.

This must not be called on an already allocated node, or you will leak
memory.
\index{drm\_vma\_node\_start (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_vma_node_start}\pysiglinewithargsret{unsigned long \bfcode{drm\_vma\_node\_start}}{const struct drm\_vma\_offset\_node *\emph{ node}}{}
Return start address for page-based addressing

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_vma\_offset\_node * node}}] \leavevmode
Node to inspect

\end{description}

\textbf{Description}

Return the start address of the given node. This can be used as offset into
the linear VM space that is provided by the VMA offset manager. Note that
this can only be used for page-based addressing. If you need a proper offset
for user-space mappings, you must apply ``\textless{}\textless{} PAGE\_SHIFT'' or use the
{\hyperref[gpu/drm\string-mm:c.drm_vma_node_offset_addr]{\emph{\code{drm\_vma\_node\_offset\_addr()}}}} helper instead.

\textbf{Return}

Start address of \textbf{node} for page-based addressing. 0 if the node does not
have an offset allocated.
\index{drm\_vma\_node\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_vma_node_size}\pysiglinewithargsret{unsigned long \bfcode{drm\_vma\_node\_size}}{struct drm\_vma\_offset\_node *\emph{ node}}{}
Return size (page-based)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_vma\_offset\_node * node}}] \leavevmode
Node to inspect

\end{description}

\textbf{Description}

Return the size as number of pages for the given node. This is the same size
that was passed to {\hyperref[gpu/drm\string-mm:c.drm_vma_offset_add]{\emph{\code{drm\_vma\_offset\_add()}}}}. If no offset is allocated for the
node, this is 0.

\textbf{Return}

Size of \textbf{node} as number of pages. 0 if the node does not have an offset
allocated.
\index{drm\_vma\_node\_offset\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_vma_node_offset_addr}\pysiglinewithargsret{\_\_u64 \bfcode{drm\_vma\_node\_offset\_addr}}{struct drm\_vma\_offset\_node *\emph{ node}}{}
Return sanitized offset for user-space mmaps

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_vma\_offset\_node * node}}] \leavevmode
Linked offset node

\end{description}

\textbf{Description}

Same as {\hyperref[gpu/drm\string-mm:c.drm_vma_node_start]{\emph{\code{drm\_vma\_node\_start()}}}} but returns the address as a valid offset that
can be used for user-space mappings during \code{mmap()}.
This must not be called on unlinked nodes.

\textbf{Return}

Offset of \textbf{node} for byte-based addressing. 0 if the node does not have an
object allocated.
\index{drm\_vma\_node\_unmap (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_vma_node_unmap}\pysiglinewithargsret{void \bfcode{drm\_vma\_node\_unmap}}{struct drm\_vma\_offset\_node *\emph{ node}, struct address\_space *\emph{ file\_mapping}}{}
Unmap offset node

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_vma\_offset\_node * node}}] \leavevmode
Offset node

\item[{\code{struct address\_space * file\_mapping}}] \leavevmode
Address space to unmap \textbf{node} from

\end{description}

\textbf{Description}

Unmap all userspace mappings for a given offset node. The mappings must be
associated with the \textbf{file\_mapping} address-space. If no offset exists
nothing is done.

This call is unlocked. The caller must guarantee that {\hyperref[gpu/drm\string-mm:c.drm_vma_offset_remove]{\emph{\code{drm\_vma\_offset\_remove()}}}}
is not called on this node concurrently.
\index{drm\_vma\_node\_verify\_access (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_vma_node_verify_access}\pysiglinewithargsret{int \bfcode{drm\_vma\_node\_verify\_access}}{struct drm\_vma\_offset\_node *\emph{ node}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ tag}}{}
Access verification helper for TTM

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_vma\_offset\_node * node}}] \leavevmode
Offset node

\item[{\code{struct drm\_file * tag}}] \leavevmode
Tag of file to check

\end{description}

\textbf{Description}

This checks whether \textbf{tag} is granted access to \textbf{node}. It is the same as
{\hyperref[gpu/drm\string-mm:c.drm_vma_node_is_allowed]{\emph{\code{drm\_vma\_node\_is\_allowed()}}}} but suitable as drop-in helper for TTM
\code{verify\_access()} callbacks.

\textbf{Return}

0 if access is granted, -EACCES otherwise.
\index{drm\_vma\_offset\_manager\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_vma_offset_manager_init}\pysiglinewithargsret{void \bfcode{drm\_vma\_offset\_manager\_init}}{struct drm\_vma\_offset\_manager *\emph{ mgr}, unsigned long\emph{ page\_offset}, unsigned long\emph{ size}}{}
Initialize new offset-manager

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_vma\_offset\_manager * mgr}}] \leavevmode
Manager object

\item[{\code{unsigned long page\_offset}}] \leavevmode
Offset of available memory area (page-based)

\item[{\code{unsigned long size}}] \leavevmode
Size of available address space range (page-based)

\end{description}

\textbf{Description}

Initialize a new offset-manager. The offset and area size available for the
manager are given as \textbf{page\_offset} and \textbf{size}. Both are interpreted as
page-numbers, not bytes.

Adding/removing nodes from the manager is locked internally and protected
against concurrent access. However, node allocation and destruction is left
for the caller. While calling into the vma-manager, a given node must
always be guaranteed to be referenced.
\index{drm\_vma\_offset\_manager\_destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_vma_offset_manager_destroy}\pysiglinewithargsret{void \bfcode{drm\_vma\_offset\_manager\_destroy}}{struct drm\_vma\_offset\_manager *\emph{ mgr}}{}
Destroy offset manager

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_vma\_offset\_manager * mgr}}] \leavevmode
Manager object

\end{description}

\textbf{Description}

Destroy an object manager which was previously created via
{\hyperref[gpu/drm\string-mm:c.drm_vma_offset_manager_init]{\emph{\code{drm\_vma\_offset\_manager\_init()}}}}. The caller must remove all allocated nodes
before destroying the manager. Otherwise, drm\_mm will refuse to free the
requested resources.

The manager must not be accessed after this function is called.
\index{drm\_vma\_offset\_lookup\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_vma_offset_lookup_locked}\pysiglinewithargsret{struct drm\_vma\_offset\_node * \bfcode{drm\_vma\_offset\_lookup\_locked}}{struct drm\_vma\_offset\_manager *\emph{ mgr}, unsigned long\emph{ start}, unsigned long\emph{ pages}}{}
Find node in offset space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_vma\_offset\_manager * mgr}}] \leavevmode
Manager object

\item[{\code{unsigned long start}}] \leavevmode
Start address for object (page-based)

\item[{\code{unsigned long pages}}] \leavevmode
Size of object (page-based)

\end{description}

\textbf{Description}

Find a node given a start address and object size. This returns the \_best\_
match for the given node. That is, \textbf{start} may point somewhere into a valid
region and the given node will be returned, as long as the node spans the
whole requested area (given the size in number of pages as \textbf{pages}).

Note that before lookup the vma offset manager lookup lock must be acquired
with {\hyperref[gpu/drm\string-mm:c.drm_vma_offset_lock_lookup]{\emph{\code{drm\_vma\_offset\_lock\_lookup()}}}}. See there for an example. This can then be
used to implement weakly referenced lookups using \code{kref\_get\_unless\_zero()}.

\textbf{Example}

\begin{Verbatim}[commandchars=\\\{\}]
drm\PYGZus{}vma\PYGZus{}offset\PYGZus{}lock\PYGZus{}lookup(mgr);
node = drm\PYGZus{}vma\PYGZus{}offset\PYGZus{}lookup\PYGZus{}locked(mgr);
if (node)
    kref\PYGZus{}get\PYGZus{}unless\PYGZus{}zero(container\PYGZus{}of(node, sth, entr));
drm\PYGZus{}vma\PYGZus{}offset\PYGZus{}unlock\PYGZus{}lookup(mgr);
\end{Verbatim}

\textbf{Return}

Returns NULL if no suitable node can be found. Otherwise, the best match
is returned. It's the caller's responsibility to make sure the node doesn't
get destroyed before the caller can access it.
\index{drm\_vma\_offset\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_vma_offset_add}\pysiglinewithargsret{int \bfcode{drm\_vma\_offset\_add}}{struct drm\_vma\_offset\_manager *\emph{ mgr}, struct drm\_vma\_offset\_node *\emph{ node}, unsigned long\emph{ pages}}{}
Add offset node to manager

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_vma\_offset\_manager * mgr}}] \leavevmode
Manager object

\item[{\code{struct drm\_vma\_offset\_node * node}}] \leavevmode
Node to be added

\item[{\code{unsigned long pages}}] \leavevmode
Allocation size visible to user-space (in number of pages)

\end{description}

\textbf{Description}

Add a node to the offset-manager. If the node was already added, this does
nothing and return 0. \textbf{pages} is the size of the object given in number of
pages.
After this call succeeds, you can access the offset of the node until it
is removed again.

If this call fails, it is safe to retry the operation or call
{\hyperref[gpu/drm\string-mm:c.drm_vma_offset_remove]{\emph{\code{drm\_vma\_offset\_remove()}}}}, anyway. However, no cleanup is required in that
case.

\textbf{pages} is not required to be the same size as the underlying memory object
that you want to map. It only limits the size that user-space can map into
their address space.

\textbf{Return}

0 on success, negative error code on failure.
\index{drm\_vma\_offset\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_vma_offset_remove}\pysiglinewithargsret{void \bfcode{drm\_vma\_offset\_remove}}{struct drm\_vma\_offset\_manager *\emph{ mgr}, struct drm\_vma\_offset\_node *\emph{ node}}{}
Remove offset node from manager

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_vma\_offset\_manager * mgr}}] \leavevmode
Manager object

\item[{\code{struct drm\_vma\_offset\_node * node}}] \leavevmode
Node to be removed

\end{description}

\textbf{Description}

Remove a node from the offset manager. If the node wasn't added before, this
does nothing. After this call returns, the offset and size will be 0 until a
new offset is allocated via {\hyperref[gpu/drm\string-mm:c.drm_vma_offset_add]{\emph{\code{drm\_vma\_offset\_add()}}}} again. Helper functions like
{\hyperref[gpu/drm\string-mm:c.drm_vma_node_start]{\emph{\code{drm\_vma\_node\_start()}}}} and {\hyperref[gpu/drm\string-mm:c.drm_vma_node_offset_addr]{\emph{\code{drm\_vma\_node\_offset\_addr()}}}} will return 0 if no
offset is allocated.
\index{drm\_vma\_node\_allow (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_vma_node_allow}\pysiglinewithargsret{int \bfcode{drm\_vma\_node\_allow}}{struct drm\_vma\_offset\_node *\emph{ node}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ tag}}{}
Add open-file to list of allowed users

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_vma\_offset\_node * node}}] \leavevmode
Node to modify

\item[{\code{struct drm\_file * tag}}] \leavevmode
Tag of file to remove

\end{description}

\textbf{Description}

Add \textbf{tag} to the list of allowed open-files for this node. If \textbf{tag} is
already on this list, the ref-count is incremented.

The list of allowed-users is preserved across {\hyperref[gpu/drm\string-mm:c.drm_vma_offset_add]{\emph{\code{drm\_vma\_offset\_add()}}}} and
{\hyperref[gpu/drm\string-mm:c.drm_vma_offset_remove]{\emph{\code{drm\_vma\_offset\_remove()}}}} calls. You may even call it if the node is currently
not added to any offset-manager.

You must remove all open-files the same number of times as you added them
before destroying the node. Otherwise, you will leak memory.

This is locked against concurrent access internally.

\textbf{Return}

0 on success, negative error code on internal failure (out-of-mem)
\index{drm\_vma\_node\_revoke (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_vma_node_revoke}\pysiglinewithargsret{void \bfcode{drm\_vma\_node\_revoke}}{struct drm\_vma\_offset\_node *\emph{ node}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ tag}}{}
Remove open-file from list of allowed users

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_vma\_offset\_node * node}}] \leavevmode
Node to modify

\item[{\code{struct drm\_file * tag}}] \leavevmode
Tag of file to remove

\end{description}

\textbf{Description}

Decrement the ref-count of \textbf{tag} in the list of allowed open-files on \textbf{node}.
If the ref-count drops to zero, remove \textbf{tag} from the list. You must call
this once for every {\hyperref[gpu/drm\string-mm:c.drm_vma_node_allow]{\emph{\code{drm\_vma\_node\_allow()}}}} on \textbf{tag}.

This is locked against concurrent access internally.

If \textbf{tag} is not on the list, nothing is done.
\index{drm\_vma\_node\_is\_allowed (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_vma_node_is_allowed}\pysiglinewithargsret{bool \bfcode{drm\_vma\_node\_is\_allowed}}{struct drm\_vma\_offset\_node *\emph{ node}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ tag}}{}
Check whether an open-file is granted access

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_vma\_offset\_node * node}}] \leavevmode
Node to check

\item[{\code{struct drm\_file * tag}}] \leavevmode
Tag of file to remove

\end{description}

\textbf{Description}

Search the list in \textbf{node} whether \textbf{tag} is currently on the list of allowed
open-files (see {\hyperref[gpu/drm\string-mm:c.drm_vma_node_allow]{\emph{\code{drm\_vma\_node\_allow()}}}}).

This is locked against concurrent access internally.

\textbf{Return}

true iff \textbf{filp} is on the list


\section{PRIME Buffer Sharing}
\label{gpu/drm-mm:prime-buffer-sharing}
PRIME is the cross device buffer sharing framework in drm, originally
created for the OPTIMUS range of multi-gpu platforms. To userspace PRIME
buffers are dma-buf based file descriptors.


\subsection{Overview and Driver Interface}
\label{gpu/drm-mm:overview-and-driver-interface}
Similar to GEM global names, PRIME file descriptors are also used to
share buffer objects across processes. They offer additional security:
as file descriptors must be explicitly sent over UNIX domain sockets to
be shared between applications, they can't be guessed like the globally
unique GEM names.

Drivers that support the PRIME API must set the DRIVER\_PRIME bit in the
struct {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{struct drm\_driver}}}}
driver\_features field, and implement the prime\_handle\_to\_fd and
prime\_fd\_to\_handle operations.

int (*prime\_handle\_to\_fd)(struct drm\_device *dev, struct drm\_file
*file\_priv, uint32\_t handle, uint32\_t flags, int *prime\_fd); int
(*prime\_fd\_to\_handle)(struct drm\_device *dev, struct drm\_file
*file\_priv, int prime\_fd, uint32\_t *handle); Those two operations
convert a handle to a PRIME file descriptor and vice versa. Drivers must
use the kernel dma-buf buffer sharing framework to manage the PRIME file
descriptors. Similar to the mode setting API PRIME is agnostic to the
underlying buffer object manager, as long as handles are 32bit unsigned
integers.

While non-GEM drivers must implement the operations themselves, GEM
drivers must use the {\hyperref[gpu/drm\string-mm:c.drm_gem_prime_handle_to_fd]{\emph{\code{drm\_gem\_prime\_handle\_to\_fd()}}}} and
{\hyperref[gpu/drm\string-mm:c.drm_gem_prime_fd_to_handle]{\emph{\code{drm\_gem\_prime\_fd\_to\_handle()}}}} helper functions. Those
helpers rely on the driver gem\_prime\_export and gem\_prime\_import
operations to create a dma-buf instance from a GEM object (dma-buf
exporter role) and to create a GEM object from a dma-buf instance
(dma-buf importer role).

struct dma\_buf * (*gem\_prime\_export)(struct drm\_device *dev,
struct drm\_gem\_object *obj, int flags); struct drm\_gem\_object *
(*gem\_prime\_import)(struct drm\_device *dev, struct dma\_buf
*dma\_buf); These two operations are mandatory for GEM drivers that
support PRIME.


\subsection{PRIME Helper Functions}
\label{gpu/drm-mm:prime-helper-functions}
Drivers can implement \textbf{gem\_prime\_export} and \textbf{gem\_prime\_import} in terms of
simpler APIs by using the helper functions \textbf{drm\_gem\_prime\_export} and
\textbf{drm\_gem\_prime\_import}.  These functions implement dma-buf support in terms of
six lower-level driver callbacks:

Export callbacks:
\begin{itemize}
\item {} 
\textbf{gem\_prime\_pin} (optional): prepare a GEM object for exporting

\item {} 
\textbf{gem\_prime\_get\_sg\_table}: provide a scatter/gather table of pinned pages

\item {} 
\textbf{gem\_prime\_vmap}: vmap a buffer exported by your driver

\item {} 
\textbf{gem\_prime\_vunmap}: vunmap a buffer exported by your driver

\item {} 
\textbf{gem\_prime\_mmap} (optional): mmap a buffer exported by your driver

\end{itemize}

Import callback:
\begin{itemize}
\item {} 
\textbf{gem\_prime\_import\_sg\_table} (import): produce a GEM object from another
driver's scatter/gather table

\end{itemize}


\subsection{PRIME Function References}
\label{gpu/drm-mm:prime-function-references}\index{drm\_prime\_file\_private (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_prime_file_private}\pysigline{struct \bfcode{drm\_prime\_file\_private}}
per-file tracking for PRIME

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}prime\PYGZus{}file\PYGZus{}private \PYGZob{}
\PYGZcb{};
\end{Verbatim}

\textbf{Members}

\textbf{Description}

This just contains the internal \code{struct dma\_buf} and handle caches for each
{\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{struct drm\_file}}}} used by the PRIME core code.
\index{drm\_gem\_dmabuf\_export (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_dmabuf_export}\pysiglinewithargsret{struct dma\_buf * \bfcode{drm\_gem\_dmabuf\_export}}{struct drm\_device *\emph{ dev}, struct dma\_buf\_export\_info *\emph{ exp\_info}}{}
dma\_buf export implementation for GEM

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
parent device for the exported dmabuf

\item[{\code{struct dma\_buf\_export\_info * exp\_info}}] \leavevmode
the export information used by \code{dma\_buf\_export()}

\end{description}

\textbf{Description}

This wraps \code{dma\_buf\_export()} for use by generic GEM drivers that are using
{\hyperref[gpu/drm\string-mm:c.drm_gem_dmabuf_release]{\emph{\code{drm\_gem\_dmabuf\_release()}}}}. In addition to calling \code{dma\_buf\_export()}, we take
a reference to the \code{drm\_device} and the exported {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{\code{drm\_gem\_object}}}} (stored in
\code{dma\_buf\_export\_info.priv}) which is released by {\hyperref[gpu/drm\string-mm:c.drm_gem_dmabuf_release]{\emph{\code{drm\_gem\_dmabuf\_release()}}}}.

Returns the new dmabuf.
\index{drm\_gem\_dmabuf\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_dmabuf_release}\pysiglinewithargsret{void \bfcode{drm\_gem\_dmabuf\_release}}{struct dma\_buf *\emph{ dma\_buf}}{}
dma\_buf release implementation for GEM

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_buf * dma\_buf}}] \leavevmode
buffer to be released

\end{description}

\textbf{Description}

Generic release function for dma\_bufs exported as PRIME buffers. GEM drivers
must use this in their dma\_buf ops structure as the release callback.
{\hyperref[gpu/drm\string-mm:c.drm_gem_dmabuf_release]{\emph{\code{drm\_gem\_dmabuf\_release()}}}} should be used in conjunction with
{\hyperref[gpu/drm\string-mm:c.drm_gem_dmabuf_export]{\emph{\code{drm\_gem\_dmabuf\_export()}}}}.
\index{drm\_gem\_prime\_export (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_prime_export}\pysiglinewithargsret{struct dma\_buf * \bfcode{drm\_gem\_prime\_export}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}, int\emph{ flags}}{}
helper library implementation of the export callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm\_device to export from

\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
GEM object to export

\item[{\code{int flags}}] \leavevmode
flags like DRM\_CLOEXEC and DRM\_RDWR

\end{description}

\textbf{Description}

This is the implementation of the gem\_prime\_export functions for GEM drivers
using the PRIME helpers.
\index{drm\_gem\_prime\_handle\_to\_fd (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_prime_handle_to_fd}\pysiglinewithargsret{int \bfcode{drm\_gem\_prime\_handle\_to\_fd}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}, uint32\_t\emph{ handle}, uint32\_t\emph{ flags}, int *\emph{ prime\_fd}}{}
PRIME export function for GEM drivers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
dev to export the buffer from

\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
drm file-private structure

\item[{\code{uint32\_t handle}}] \leavevmode
buffer handle to export

\item[{\code{uint32\_t flags}}] \leavevmode
flags like DRM\_CLOEXEC

\item[{\code{int * prime\_fd}}] \leavevmode
pointer to storage for the fd id of the create dma-buf

\end{description}

\textbf{Description}

This is the PRIME export function which must be used mandatorily by GEM
drivers to ensure correct lifetime management of the underlying GEM object.
The actual exporting from GEM object to a dma-buf is done through the
gem\_prime\_export driver callback.
\index{drm\_gem\_prime\_import\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_prime_import_dev}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} * \bfcode{drm\_gem\_prime\_import\_dev}}{struct drm\_device *\emph{ dev}, struct dma\_buf *\emph{ dma\_buf}, struct device *\emph{ attach\_dev}}{}
core implementation of the import callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm\_device to import into

\item[{\code{struct dma\_buf * dma\_buf}}] \leavevmode
dma-buf object to import

\item[{\code{struct device * attach\_dev}}] \leavevmode
struct device to dma\_buf attach

\end{description}

\textbf{Description}

This is the core of drm\_gem\_prime\_import. It's designed to be called by
drivers who want to use a different device structure than dev-\textgreater{}dev for
attaching via dma\_buf.
\index{drm\_gem\_prime\_import (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_prime_import}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} * \bfcode{drm\_gem\_prime\_import}}{struct drm\_device *\emph{ dev}, struct dma\_buf *\emph{ dma\_buf}}{}
helper library implementation of the import callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm\_device to import into

\item[{\code{struct dma\_buf * dma\_buf}}] \leavevmode
dma-buf object to import

\end{description}

\textbf{Description}

This is the implementation of the gem\_prime\_import functions for GEM drivers
using the PRIME helpers.
\index{drm\_gem\_prime\_fd\_to\_handle (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_gem_prime_fd_to_handle}\pysiglinewithargsret{int \bfcode{drm\_gem\_prime\_fd\_to\_handle}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}, int\emph{ prime\_fd}, uint32\_t *\emph{ handle}}{}
PRIME import function for GEM drivers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
dev to export the buffer from

\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
drm file-private structure

\item[{\code{int prime\_fd}}] \leavevmode
fd id of the dma-buf which should be imported

\item[{\code{uint32\_t * handle}}] \leavevmode
pointer to storage for the handle of the imported buffer object

\end{description}

\textbf{Description}

This is the PRIME import function which must be used mandatorily by GEM
drivers to ensure correct lifetime management of the underlying GEM object.
The actual importing of GEM object from the dma-buf is done through the
gem\_import\_export driver callback.
\index{drm\_prime\_pages\_to\_sg (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_prime_pages_to_sg}\pysiglinewithargsret{struct sg\_table * \bfcode{drm\_prime\_pages\_to\_sg}}{struct page **\emph{ pages}, unsigned int\emph{ nr\_pages}}{}
converts a page array into an sg list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct page ** pages}}] \leavevmode
pointer to the array of page pointers to convert

\item[{\code{unsigned int nr\_pages}}] \leavevmode
length of the page vector

\end{description}

\textbf{Description}

This helper creates an sg table object from a set of pages
the driver is responsible for mapping the pages into the
importers address space for use with dma\_buf itself.
\index{drm\_prime\_sg\_to\_page\_addr\_arrays (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_prime_sg_to_page_addr_arrays}\pysiglinewithargsret{int \bfcode{drm\_prime\_sg\_to\_page\_addr\_arrays}}{struct sg\_table *\emph{ sgt}, struct page **\emph{ pages}, dma\_addr\_t *\emph{ addrs}, int\emph{ max\_pages}}{}
convert an sg table into a page array

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sg\_table * sgt}}] \leavevmode
scatter-gather table to convert

\item[{\code{struct page ** pages}}] \leavevmode
array of page pointers to store the page array in

\item[{\code{dma\_addr\_t * addrs}}] \leavevmode
optional array to store the dma bus address of each page

\item[{\code{int max\_pages}}] \leavevmode
size of both the passed-in arrays

\end{description}

\textbf{Description}

Exports an sg table into an array of pages and addresses. This is currently
required by the TTM driver in order to do correct fault handling.
\index{drm\_prime\_gem\_destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_prime_gem_destroy}\pysiglinewithargsret{void \bfcode{drm\_prime\_gem\_destroy}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}, struct sg\_table *\emph{ sg}}{}
helper to clean up a PRIME-imported GEM object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
GEM object which was created from a dma-buf

\item[{\code{struct sg\_table * sg}}] \leavevmode
the sg-table which was pinned at import time

\end{description}

\textbf{Description}

This is the cleanup functions which GEM drivers need to call when they use
\textbf{drm\_gem\_prime\_import} to import dma-bufs.


\section{DRM MM Range Allocator}
\label{gpu/drm-mm:drm-mm-range-allocator}

\subsection{Overview}
\label{gpu/drm-mm:overview}
drm\_mm provides a simple range allocator. The drivers are free to use the
resource allocator from the linux core if it suits them, the upside of drm\_mm
is that it's in the DRM core. Which means that it's easier to extend for
some of the crazier special purpose needs of gpus.

The main data struct is {\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{\code{drm\_mm}}}}, allocations are tracked in {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{\code{drm\_mm\_node}}}}.
Drivers are free to embed either of them into their own suitable
datastructures. drm\_mm itself will not do any memory allocations of its own,
so if drivers choose not to embed nodes they need to still allocate them
themselves.

The range allocator also supports reservation of preallocated blocks. This is
useful for taking over initial mode setting configurations from the firmware,
where an object needs to be created which exactly matches the firmware's
scanout target. As long as the range is still free it can be inserted anytime
after the allocator is initialized, which helps with avoiding looped
dependencies in the driver load sequence.

drm\_mm maintains a stack of most recently freed holes, which of all
simplistic datastructures seems to be a fairly decent approach to clustering
allocations and avoiding too much fragmentation. This means free space
searches are O(num\_holes). Given that all the fancy features drm\_mm supports
something better would be fairly complex and since gfx thrashing is a fairly
steep cliff not a real concern. Removing a node again is O(1).

drm\_mm supports a few features: Alignment and range restrictions can be
supplied. Furthermore every {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{\code{drm\_mm\_node}}}} has a color value (which is just an
opaque unsigned long) which in conjunction with a driver callback can be used
to implement sophisticated placement restrictions. The i915 DRM driver uses
this to implement guard pages between incompatible caching domains in the
graphics TT.

Two behaviors are supported for searching and allocating: bottom-up and
top-down. The default is bottom-up. Top-down allocation can be used if the
memory area has different restrictions, or just to reduce fragmentation.

Finally iteration helpers to walk all nodes and all holes are provided as are
some basic allocator dumpers for debugging.

Note that this range allocator is not thread-safe, drivers need to protect
modifications with their own locking. The idea behind this is that for a full
memory manager additional data needs to be protected anyway, hence internal
locking would be fully redundant.


\subsection{LRU Scan/Eviction Support}
\label{gpu/drm-mm:lru-scan-eviction-support}
Very often GPUs need to have continuous allocations for a given object. When
evicting objects to make space for a new one it is therefore not most
efficient when we simply start to select all objects from the tail of an LRU
until there's a suitable hole: Especially for big objects or nodes that
otherwise have special allocation constraints there's a good chance we evict
lots of (smaller) objects unnecessarily.

The DRM range allocator supports this use-case through the scanning
interfaces. First a scan operation needs to be initialized with
{\hyperref[gpu/drm\string-mm:c.drm_mm_scan_init]{\emph{\code{drm\_mm\_scan\_init()}}}} or {\hyperref[gpu/drm\string-mm:c.drm_mm_scan_init_with_range]{\emph{\code{drm\_mm\_scan\_init\_with\_range()}}}}. The driver adds
objects to the roster, probably by walking an LRU list, but this can be
freely implemented. Eviction candiates are added using
{\hyperref[gpu/drm\string-mm:c.drm_mm_scan_add_block]{\emph{\code{drm\_mm\_scan\_add\_block()}}}} until a suitable hole is found or there are no
further evictable objects. Eviction roster metadata is tracked in {\hyperref[gpu/drm\string-mm:c.drm_mm_scan]{\emph{\code{struct
drm\_mm\_scan}}}}.

The driver must walk through all objects again in exactly the reverse
order to restore the allocator state. Note that while the allocator is used
in the scan mode no other operation is allowed.

Finally the driver evicts all objects selected ({\hyperref[gpu/drm\string-mm:c.drm_mm_scan_remove_block]{\emph{\code{drm\_mm\_scan\_remove\_block()}}}}
reported true) in the scan, and any overlapping nodes after color adjustment
({\hyperref[gpu/drm\string-mm:c.drm_mm_scan_color_evict]{\emph{\code{drm\_mm\_scan\_color\_evict()}}}}). Adding and removing an object is O(1), and
since freeing a node is also O(1) the overall complexity is
O(scanned\_objects). So like the free stack which needs to be walked before a
scan operation even begins this is linear in the number of objects. It
doesn't seem to hurt too badly.


\subsection{DRM MM Range Allocator Function References}
\label{gpu/drm-mm:drm-mm-range-allocator-function-references}\index{drm\_mm\_insert\_mode (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_insert_mode}\pysigline{enum \bfcode{drm\_mm\_insert\_mode}}
control search and allocation behaviour

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{DRM\_MM\_INSERT\_BEST}}] \leavevmode
Search for the smallest hole (within the search range) that fits
the desired node.

Allocates the node from the bottom of the found hole.

\item[{\code{DRM\_MM\_INSERT\_LOW}}] \leavevmode
Search for the lowest hole (address closest to 0, within the search
range) that fits the desired node.

Allocates the node from the bottom of the found hole.

\item[{\code{DRM\_MM\_INSERT\_HIGH}}] \leavevmode
Search for the highest hole (address closest to U64\_MAX, within the
search range) that fits the desired node.

Allocates the node from the \emph{top} of the found hole. The specified
alignment for the node is applied to the base of the node
({\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{\code{drm\_mm\_node.start}}}}).

\item[{\code{DRM\_MM\_INSERT\_EVICT}}] \leavevmode
Search for the most recently evicted hole (within the search range)
that fits the desired node. This is appropriate for use immediately
after performing an eviction scan (see {\hyperref[gpu/drm\string-mm:c.drm_mm_scan_init]{\emph{\code{drm\_mm\_scan\_init()}}}}) and
removing the selected nodes to form a hole.

Allocates the node from the bottom of the found hole.

\end{description}

\textbf{Description}

The {\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{\code{struct drm\_mm}}}} range manager supports finding a suitable modes using
a number of search trees. These trees are oranised by size, by address and
in most recent eviction order. This allows the user to find either the
smallest hole to reuse, the lowest or highest address to reuse, or simply
reuse the most recent eviction that fits. When allocating the {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{\code{drm\_mm\_node}}}}
from within the hole, the {\hyperref[gpu/drm\string-mm:c.drm_mm_insert_mode]{\emph{\code{drm\_mm\_insert\_mode}}}} also dictate whether to
allocate the lowest matching address or the highest.
\index{drm\_mm\_node (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_node}\pysigline{struct \bfcode{drm\_mm\_node}}
allocated block in the DRM allocator

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}mm\PYGZus{}node \PYGZob{}
  unsigned long color;
  u64 start;
  u64 size;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{color}}] \leavevmode
Opaque driver-private tag.

\item[{\code{start}}] \leavevmode
Start address of the allocated block.

\item[{\code{size}}] \leavevmode
Size of the allocated block.

\end{description}

\textbf{Description}

This represents an allocated block in a {\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{\code{drm\_mm}}}} allocator. Except for
pre-reserved nodes inserted using {\hyperref[gpu/drm\string-mm:c.drm_mm_reserve_node]{\emph{\code{drm\_mm\_reserve\_node()}}}} the structure is
entirely opaque and should only be accessed through the provided funcions.
Since allocation of these nodes is entirely handled by the driver they can be
embedded.
\index{drm\_mm (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm}\pysigline{struct \bfcode{drm\_mm}}
DRM allocator

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}mm \PYGZob{}
  void (*color\PYGZus{}adjust)(const struct drm\PYGZus{}mm\PYGZus{}node *node,unsigned long color, u64 *start, u64 *end);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{color\_adjust}}] \leavevmode
Optional driver callback to further apply restrictions on a hole. The
node argument points at the node containing the hole from which the
block would be allocated (see {\hyperref[gpu/drm\string-mm:c.drm_mm_hole_follows]{\emph{\code{drm\_mm\_hole\_follows()}}}} and friends). The
other arguments are the size of the block to be allocated. The driver
can adjust the start and end as needed to e.g. insert guard pages.

\end{description}

\textbf{Description}

DRM range allocator with a few special functions and features geared towards
managing GPU memory. Except for the \textbf{color\_adjust} callback the structure is
entirely opaque and should only be accessed through the provided functions
and macros. This structure can be embedded into larger driver structures.
\index{drm\_mm\_scan (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_scan}\pysigline{struct \bfcode{drm\_mm\_scan}}
DRM allocator eviction roaster data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}mm\PYGZus{}scan \PYGZob{}
\PYGZcb{};
\end{Verbatim}

\textbf{Members}

\textbf{Description}

This structure tracks data needed for the eviction roaster set up using
{\hyperref[gpu/drm\string-mm:c.drm_mm_scan_init]{\emph{\code{drm\_mm\_scan\_init()}}}}, and used with {\hyperref[gpu/drm\string-mm:c.drm_mm_scan_add_block]{\emph{\code{drm\_mm\_scan\_add\_block()}}}} and
{\hyperref[gpu/drm\string-mm:c.drm_mm_scan_remove_block]{\emph{\code{drm\_mm\_scan\_remove\_block()}}}}. The structure is entirely opaque and should only
be accessed through the provided functions and macros. It is meant to be
allocated temporarily by the driver on the stack.
\index{drm\_mm\_node\_allocated (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_node_allocated}\pysiglinewithargsret{bool \bfcode{drm\_mm\_node\_allocated}}{const struct {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{drm\_mm\_node}}} *\emph{ node}}{}
checks whether a node is allocated

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_mm\_node * node}}] \leavevmode
drm\_mm\_node to check

\end{description}

\textbf{Description}

Drivers are required to clear a node prior to using it with the
drm\_mm range manager.

Drivers should use this helper for proper encapsulation of drm\_mm
internals.

\textbf{Return}

True if the \textbf{node} is allocated.
\index{drm\_mm\_initialized (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_initialized}\pysiglinewithargsret{bool \bfcode{drm\_mm\_initialized}}{const struct {\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{drm\_mm}}} *\emph{ mm}}{}
checks whether an allocator is initialized

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_mm * mm}}] \leavevmode
drm\_mm to check

\end{description}

\textbf{Description}

Drivers should clear the struct drm\_mm prior to initialisation if they
want to use this function.

Drivers should use this helper for proper encapsulation of drm\_mm
internals.

\textbf{Return}

True if the \textbf{mm} is initialized.
\index{drm\_mm\_hole\_follows (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_hole_follows}\pysiglinewithargsret{bool \bfcode{drm\_mm\_hole\_follows}}{const struct {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{drm\_mm\_node}}} *\emph{ node}}{}
checks whether a hole follows this node

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_mm\_node * node}}] \leavevmode
drm\_mm\_node to check

\end{description}

\textbf{Description}

Holes are embedded into the drm\_mm using the tail of a drm\_mm\_node.
If you wish to know whether a hole follows this particular node,
query this function. See also {\hyperref[gpu/drm\string-mm:c.drm_mm_hole_node_start]{\emph{\code{drm\_mm\_hole\_node\_start()}}}} and
{\hyperref[gpu/drm\string-mm:c.drm_mm_hole_node_end]{\emph{\code{drm\_mm\_hole\_node\_end()}}}}.

\textbf{Return}

True if a hole follows the \textbf{node}.
\index{drm\_mm\_hole\_node\_start (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_hole_node_start}\pysiglinewithargsret{u64 \bfcode{drm\_mm\_hole\_node\_start}}{const struct {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{drm\_mm\_node}}} *\emph{ hole\_node}}{}
computes the start of the hole following \textbf{node}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_mm\_node * hole\_node}}] \leavevmode
drm\_mm\_node which implicitly tracks the following hole

\end{description}

\textbf{Description}

This is useful for driver-specific debug dumpers. Otherwise drivers should
not inspect holes themselves. Drivers must check first whether a hole indeed
follows by looking at {\hyperref[gpu/drm\string-mm:c.drm_mm_hole_follows]{\emph{\code{drm\_mm\_hole\_follows()}}}}

\textbf{Return}

Start of the subsequent hole.
\index{drm\_mm\_hole\_node\_end (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_hole_node_end}\pysiglinewithargsret{u64 \bfcode{drm\_mm\_hole\_node\_end}}{const struct {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{drm\_mm\_node}}} *\emph{ hole\_node}}{}
computes the end of the hole following \textbf{node}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_mm\_node * hole\_node}}] \leavevmode
drm\_mm\_node which implicitly tracks the following hole

\end{description}

\textbf{Description}

This is useful for driver-specific debug dumpers. Otherwise drivers should
not inspect holes themselves. Drivers must check first whether a hole indeed
follows by looking at {\hyperref[gpu/drm\string-mm:c.drm_mm_hole_follows]{\emph{\code{drm\_mm\_hole\_follows()}}}}.

\textbf{Return}

End of the subsequent hole.
\index{drm\_mm\_nodes (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_nodes}\pysiglinewithargsret{\bfcode{drm\_mm\_nodes}}{\emph{mm}}{}
list of nodes under the drm\_mm range manager

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{mm}}] \leavevmode
the struct drm\_mm range manger

\end{description}

\textbf{Description}

As the drm\_mm range manager hides its node\_list deep with its
structure, extracting it looks painful and repetitive. This is
not expected to be used outside of the {\hyperref[gpu/drm\string-mm:c.drm_mm_for_each_node]{\emph{\code{drm\_mm\_for\_each\_node()}}}}
macros and similar internal functions.

\textbf{Return}

The node list, may be empty.
\index{drm\_mm\_for\_each\_node (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_for_each_node}\pysiglinewithargsret{\bfcode{drm\_mm\_for\_each\_node}}{\emph{entry}, \emph{mm}}{}
iterator to walk over all allocated nodes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{entry}}] \leavevmode
{\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{\code{struct drm\_mm\_node}}}} to assign to in each iteration step

\item[{\code{mm}}] \leavevmode
{\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{\code{drm\_mm}}}} allocator to walk

\end{description}

\textbf{Description}

This iterator walks over all nodes in the range allocator. It is implemented
with \code{list\_for\_each()}, so not save against removal of elements.
\index{drm\_mm\_for\_each\_node\_safe (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_for_each_node_safe}\pysiglinewithargsret{\bfcode{drm\_mm\_for\_each\_node\_safe}}{\emph{entry}, \emph{next}, \emph{mm}}{}
iterator to walk over all allocated nodes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{entry}}] \leavevmode
{\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{\code{struct drm\_mm\_node}}}} to assign to in each iteration step

\item[{\code{next}}] \leavevmode
{\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{\code{struct drm\_mm\_node}}}} to store the next step

\item[{\code{mm}}] \leavevmode
{\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{\code{drm\_mm}}}} allocator to walk

\end{description}

\textbf{Description}

This iterator walks over all nodes in the range allocator. It is implemented
with \code{list\_for\_each\_safe()}, so save against removal of elements.
\index{drm\_mm\_for\_each\_hole (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_for_each_hole}\pysiglinewithargsret{\bfcode{drm\_mm\_for\_each\_hole}}{\emph{pos}, \emph{mm}, \emph{hole\_start}, \emph{hole\_end}}{}
iterator to walk over all holes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{pos}}] \leavevmode
{\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{\code{drm\_mm\_node}}}} used internally to track progress

\item[{\code{mm}}] \leavevmode
{\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{\code{drm\_mm}}}} allocator to walk

\item[{\code{hole\_start}}] \leavevmode
ulong variable to assign the hole start to on each iteration

\item[{\code{hole\_end}}] \leavevmode
ulong variable to assign the hole end to on each iteration

\end{description}

\textbf{Description}

This iterator walks over all holes in the range allocator. It is implemented
with \code{list\_for\_each()}, so not save against removal of elements. \textbf{entry} is used
internally and will not reflect a real drm\_mm\_node for the very first hole.
Hence users of this iterator may not access it.

Implementation Note:
We need to inline list\_for\_each\_entry in order to be able to set hole\_start
and hole\_end on each iteration while keeping the macro sane.
\index{drm\_mm\_insert\_node\_generic (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_insert_node_generic}\pysiglinewithargsret{int \bfcode{drm\_mm\_insert\_node\_generic}}{struct {\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{drm\_mm}}} *\emph{ mm}, struct {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{drm\_mm\_node}}} *\emph{ node}, u64\emph{ size}, u64\emph{ alignment}, unsigned long\emph{ color}, enum {\hyperref[gpu/drm\string-mm:c.drm_mm_insert_mode]{\emph{drm\_mm\_insert\_mode}}}\emph{ mode}}{}
search for space and insert \textbf{node}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mm * mm}}] \leavevmode
drm\_mm to allocate from

\item[{\code{struct drm\_mm\_node * node}}] \leavevmode
preallocate node to insert

\item[{\code{u64 size}}] \leavevmode
size of the allocation

\item[{\code{u64 alignment}}] \leavevmode
alignment of the allocation

\item[{\code{unsigned long color}}] \leavevmode
opaque tag value to use for this node

\item[{\code{enum drm\_mm\_insert\_mode mode}}] \leavevmode
fine-tune the allocation search and placement

\end{description}

\textbf{Description}

This is a simplified version of {\hyperref[gpu/drm\string-mm:c.drm_mm_insert_node_in_range]{\emph{\code{drm\_mm\_insert\_node\_in\_range()}}}} with no
range restrictions applied.

The preallocated node must be cleared to 0.

\textbf{Return}

0 on success, -ENOSPC if there's no suitable hole.
\index{drm\_mm\_insert\_node (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_insert_node}\pysiglinewithargsret{int \bfcode{drm\_mm\_insert\_node}}{struct {\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{drm\_mm}}} *\emph{ mm}, struct {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{drm\_mm\_node}}} *\emph{ node}, u64\emph{ size}}{}
search for space and insert \textbf{node}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mm * mm}}] \leavevmode
drm\_mm to allocate from

\item[{\code{struct drm\_mm\_node * node}}] \leavevmode
preallocate node to insert

\item[{\code{u64 size}}] \leavevmode
size of the allocation

\end{description}

\textbf{Description}

This is a simplified version of {\hyperref[gpu/drm\string-mm:c.drm_mm_insert_node_generic]{\emph{\code{drm\_mm\_insert\_node\_generic()}}}} with \textbf{color} set
to 0.

The preallocated node must be cleared to 0.

\textbf{Return}

0 on success, -ENOSPC if there's no suitable hole.
\index{drm\_mm\_clean (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_clean}\pysiglinewithargsret{bool \bfcode{drm\_mm\_clean}}{const struct {\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{drm\_mm}}} *\emph{ mm}}{}
checks whether an allocator is clean

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_mm * mm}}] \leavevmode
drm\_mm allocator to check

\end{description}

\textbf{Return}

True if the allocator is completely free, false if there's still a node
allocated in it.
\index{drm\_mm\_for\_each\_node\_in\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_for_each_node_in_range}\pysiglinewithargsret{\bfcode{drm\_mm\_for\_each\_node\_in\_range}}{\emph{node\_\_}, \emph{mm\_\_}, \emph{start\_\_}, \emph{end\_\_}}{}
iterator to walk over a range of allocated nodes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{node\_\_}}] \leavevmode
drm\_mm\_node structure to assign to in each iteration step

\item[{\code{mm\_\_}}] \leavevmode
drm\_mm allocator to walk

\item[{\code{start\_\_}}] \leavevmode
starting offset, the first node will overlap this

\item[{\code{end\_\_}}] \leavevmode
ending offset, the last node will start before this (but may overlap)

\end{description}

\textbf{Description}

This iterator walks over all nodes in the range allocator that lie
between \textbf{start} and \textbf{end}. It is implemented similarly to \code{list\_for\_each()},
but using the internal interval tree to accelerate the search for the
starting node, and so not safe against removal of elements. It assumes
that \textbf{end} is within (or is the upper limit of) the drm\_mm allocator.
If {[}\textbf{start}, \textbf{end}{]} are beyond the range of the drm\_mm, the iterator may walk
over the special \_unallocated\_ {\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{\code{drm\_mm.head\_node}}}}, and may even continue
indefinitely.
\index{drm\_mm\_scan\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_scan_init}\pysiglinewithargsret{void \bfcode{drm\_mm\_scan\_init}}{struct {\hyperref[gpu/drm\string-mm:c.drm_mm_scan]{\emph{drm\_mm\_scan}}} *\emph{ scan}, struct {\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{drm\_mm}}} *\emph{ mm}, u64\emph{ size}, u64\emph{ alignment}, unsigned long\emph{ color}, enum {\hyperref[gpu/drm\string-mm:c.drm_mm_insert_mode]{\emph{drm\_mm\_insert\_mode}}}\emph{ mode}}{}
initialize lru scanning

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mm\_scan * scan}}] \leavevmode
scan state

\item[{\code{struct drm\_mm * mm}}] \leavevmode
drm\_mm to scan

\item[{\code{u64 size}}] \leavevmode
size of the allocation

\item[{\code{u64 alignment}}] \leavevmode
alignment of the allocation

\item[{\code{unsigned long color}}] \leavevmode
opaque tag value to use for the allocation

\item[{\code{enum drm\_mm\_insert\_mode mode}}] \leavevmode
fine-tune the allocation search and placement

\end{description}

\textbf{Description}

This is a simplified version of {\hyperref[gpu/drm\string-mm:c.drm_mm_scan_init_with_range]{\emph{\code{drm\_mm\_scan\_init\_with\_range()}}}} with no range
restrictions applied.

This simply sets up the scanning routines with the parameters for the desired
hole.

Warning:
As long as the scan list is non-empty, no other operations than
adding/removing nodes to/from the scan list are allowed.
\index{drm\_mm\_reserve\_node (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_reserve_node}\pysiglinewithargsret{int \bfcode{drm\_mm\_reserve\_node}}{struct {\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{drm\_mm}}} *\emph{ mm}, struct {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{drm\_mm\_node}}} *\emph{ node}}{}
insert an pre-initialized node

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mm * mm}}] \leavevmode
drm\_mm allocator to insert \textbf{node} into

\item[{\code{struct drm\_mm\_node * node}}] \leavevmode
drm\_mm\_node to insert

\end{description}

\textbf{Description}

This functions inserts an already set-up {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{\code{drm\_mm\_node}}}} into the allocator,
meaning that start, size and color must be set by the caller. All other
fields must be cleared to 0. This is useful to initialize the allocator with
preallocated objects which must be set-up before the range allocator can be
set-up, e.g. when taking over a firmware framebuffer.

\textbf{Return}

0 on success, -ENOSPC if there's no hole where \textbf{node} is.
\index{drm\_mm\_insert\_node\_in\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_insert_node_in_range}\pysiglinewithargsret{int \bfcode{drm\_mm\_insert\_node\_in\_range}}{struct {\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{drm\_mm}}} *const\emph{ mm}, struct {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{drm\_mm\_node}}} *const\emph{ node}, u64\emph{ size}, u64\emph{ alignment}, unsigned long\emph{ color}, u64\emph{ range\_start}, u64\emph{ range\_end}, enum {\hyperref[gpu/drm\string-mm:c.drm_mm_insert_mode]{\emph{drm\_mm\_insert\_mode}}}\emph{ mode}}{}
ranged search for space and insert \textbf{node}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mm *const mm}}] \leavevmode
drm\_mm to allocate from

\item[{\code{struct drm\_mm\_node *const node}}] \leavevmode
preallocate node to insert

\item[{\code{u64 size}}] \leavevmode
size of the allocation

\item[{\code{u64 alignment}}] \leavevmode
alignment of the allocation

\item[{\code{unsigned long color}}] \leavevmode
opaque tag value to use for this node

\item[{\code{u64 range\_start}}] \leavevmode
start of the allowed range for this node

\item[{\code{u64 range\_end}}] \leavevmode
end of the allowed range for this node

\item[{\code{enum drm\_mm\_insert\_mode mode}}] \leavevmode
fine-tune the allocation search and placement

\end{description}

\textbf{Description}

The preallocated \textbf{node} must be cleared to 0.

\textbf{Return}

0 on success, -ENOSPC if there's no suitable hole.
\index{drm\_mm\_remove\_node (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_remove_node}\pysiglinewithargsret{void \bfcode{drm\_mm\_remove\_node}}{struct {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{drm\_mm\_node}}} *\emph{ node}}{}
Remove a memory node from the allocator.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mm\_node * node}}] \leavevmode
drm\_mm\_node to remove

\end{description}

\textbf{Description}

This just removes a node from its drm\_mm allocator. The node does not need to
be cleared again before it can be re-inserted into this or any other drm\_mm
allocator. It is a bug to call this function on a unallocated node.
\index{drm\_mm\_replace\_node (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_replace_node}\pysiglinewithargsret{void \bfcode{drm\_mm\_replace\_node}}{struct {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{drm\_mm\_node}}} *\emph{ old}, struct {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{drm\_mm\_node}}} *\emph{ new}}{}
move an allocation from \textbf{old} to \textbf{new}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mm\_node * old}}] \leavevmode
drm\_mm\_node to remove from the allocator

\item[{\code{struct drm\_mm\_node * new}}] \leavevmode
drm\_mm\_node which should inherit \textbf{old}`s allocation

\end{description}

\textbf{Description}

This is useful for when drivers embed the drm\_mm\_node structure and hence
can't move allocations by reassigning pointers. It's a combination of remove
and insert with the guarantee that the allocation start will match.
\index{drm\_mm\_scan\_init\_with\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_scan_init_with_range}\pysiglinewithargsret{void \bfcode{drm\_mm\_scan\_init\_with\_range}}{struct {\hyperref[gpu/drm\string-mm:c.drm_mm_scan]{\emph{drm\_mm\_scan}}} *\emph{ scan}, struct {\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{drm\_mm}}} *\emph{ mm}, u64\emph{ size}, u64\emph{ alignment}, unsigned long\emph{ color}, u64\emph{ start}, u64\emph{ end}, enum {\hyperref[gpu/drm\string-mm:c.drm_mm_insert_mode]{\emph{drm\_mm\_insert\_mode}}}\emph{ mode}}{}
initialize range-restricted lru scanning

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mm\_scan * scan}}] \leavevmode
scan state

\item[{\code{struct drm\_mm * mm}}] \leavevmode
drm\_mm to scan

\item[{\code{u64 size}}] \leavevmode
size of the allocation

\item[{\code{u64 alignment}}] \leavevmode
alignment of the allocation

\item[{\code{unsigned long color}}] \leavevmode
opaque tag value to use for the allocation

\item[{\code{u64 start}}] \leavevmode
start of the allowed range for the allocation

\item[{\code{u64 end}}] \leavevmode
end of the allowed range for the allocation

\item[{\code{enum drm\_mm\_insert\_mode mode}}] \leavevmode
fine-tune the allocation search and placement

\end{description}

\textbf{Description}

This simply sets up the scanning routines with the parameters for the desired
hole.

Warning:
As long as the scan list is non-empty, no other operations than
adding/removing nodes to/from the scan list are allowed.
\index{drm\_mm\_scan\_add\_block (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_scan_add_block}\pysiglinewithargsret{bool \bfcode{drm\_mm\_scan\_add\_block}}{struct {\hyperref[gpu/drm\string-mm:c.drm_mm_scan]{\emph{drm\_mm\_scan}}} *\emph{ scan}, struct {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{drm\_mm\_node}}} *\emph{ node}}{}
add a node to the scan list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mm\_scan * scan}}] \leavevmode
the active drm\_mm scanner

\item[{\code{struct drm\_mm\_node * node}}] \leavevmode
drm\_mm\_node to add

\end{description}

\textbf{Description}

Add a node to the scan list that might be freed to make space for the desired
hole.

\textbf{Return}

True if a hole has been found, false otherwise.
\index{drm\_mm\_scan\_remove\_block (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_scan_remove_block}\pysiglinewithargsret{bool \bfcode{drm\_mm\_scan\_remove\_block}}{struct {\hyperref[gpu/drm\string-mm:c.drm_mm_scan]{\emph{drm\_mm\_scan}}} *\emph{ scan}, struct {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{drm\_mm\_node}}} *\emph{ node}}{}
remove a node from the scan list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mm\_scan * scan}}] \leavevmode
the active drm\_mm scanner

\item[{\code{struct drm\_mm\_node * node}}] \leavevmode
drm\_mm\_node to remove

\end{description}

\textbf{Description}

Nodes \textbf{must} be removed in exactly the reverse order from the scan list as
they have been added (e.g. using \code{list\_add()} as they are added and then
\code{list\_for\_each()} over that eviction list to remove), otherwise the internal
state of the memory manager will be corrupted.

When the scan list is empty, the selected memory nodes can be freed. An
immediately following \code{drm\_mm\_insert\_node\_in\_range\_generic()} or one of the
simpler versions of that function with !DRM\_MM\_SEARCH\_BEST will then return
the just freed block (because its at the top of the free\_stack list).

\textbf{Return}

True if this block should be evicted, false otherwise. Will always
return false when no hole has been found.
\index{drm\_mm\_scan\_color\_evict (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_scan_color_evict}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{drm\_mm\_node}}} * \bfcode{drm\_mm\_scan\_color\_evict}}{struct {\hyperref[gpu/drm\string-mm:c.drm_mm_scan]{\emph{drm\_mm\_scan}}} *\emph{ scan}}{}
evict overlapping nodes on either side of hole

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mm\_scan * scan}}] \leavevmode
drm\_mm scan with target hole

\end{description}

\textbf{Description}

After completing an eviction scan and removing the selected nodes, we may
need to remove a few more nodes from either side of the target hole if
mm.color\_adjust is being used.

\textbf{Return}

A node to evict, or NULL if there are no overlapping nodes.
\index{drm\_mm\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_init}\pysiglinewithargsret{void \bfcode{drm\_mm\_init}}{struct {\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{drm\_mm}}} *\emph{ mm}, u64\emph{ start}, u64\emph{ size}}{}
initialize a drm-mm allocator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mm * mm}}] \leavevmode
the drm\_mm structure to initialize

\item[{\code{u64 start}}] \leavevmode
start of the range managed by \textbf{mm}

\item[{\code{u64 size}}] \leavevmode
end of the range managed by \textbf{mm}

\end{description}

\textbf{Description}

Note that \textbf{mm} must be cleared to 0 before calling this function.
\index{drm\_mm\_takedown (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_takedown}\pysiglinewithargsret{void \bfcode{drm\_mm\_takedown}}{struct {\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{drm\_mm}}} *\emph{ mm}}{}
clean up a drm\_mm allocator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mm * mm}}] \leavevmode
drm\_mm allocator to clean up

\end{description}

\textbf{Description}

Note that it is a bug to call this function on an allocator which is not
clean.
\index{drm\_mm\_print (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_mm_print}\pysiglinewithargsret{void \bfcode{drm\_mm\_print}}{const struct {\hyperref[gpu/drm\string-mm:c.drm_mm]{\emph{drm\_mm}}} *\emph{ mm}, struct {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{drm\_printer}}} *\emph{ p}}{}
print allocator state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_mm * mm}}] \leavevmode
drm\_mm allocator to print

\item[{\code{struct drm\_printer * p}}] \leavevmode
DRM printer to use

\end{description}


\section{DRM Cache Handling}
\label{gpu/drm-mm:drm-cache-handling}\index{drm\_clflush\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_clflush_pages}\pysiglinewithargsret{void \bfcode{drm\_clflush\_pages}}{struct page *\emph{ pages}, unsigned long\emph{ num\_pages}}{}
Flush dcache lines of a set of pages.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct page * pages}}] \leavevmode
List of pages to be flushed.

\item[{\code{unsigned long num\_pages}}] \leavevmode
Number of pages in the array.

\end{description}

\textbf{Description}

Flush every data cache line entry that points to an address belonging
to a page in the array.
\index{drm\_clflush\_sg (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_clflush_sg}\pysiglinewithargsret{void \bfcode{drm\_clflush\_sg}}{struct sg\_table *\emph{ st}}{}
Flush dcache lines pointing to a scather-gather.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sg\_table * st}}] \leavevmode
struct sg\_table.

\end{description}

\textbf{Description}

Flush every data cache line entry that points to an address in the
sg.
\index{drm\_clflush\_virt\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_clflush_virt_range}\pysiglinewithargsret{void \bfcode{drm\_clflush\_virt\_range}}{void *\emph{ addr}, unsigned long\emph{ length}}{}
Flush dcache lines of a region

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * addr}}] \leavevmode
Initial kernel memory address.

\item[{\code{unsigned long length}}] \leavevmode
Region size.

\end{description}

\textbf{Description}

Flush every data cache line entry that points to an address in the
region requested.


\section{DRM Sync Objects}
\label{gpu/drm-mm:drm-sync-objects}
DRM synchronisation objects (syncobj, see struct {\hyperref[gpu/drm\string-mm:c.drm_syncobj]{\emph{\code{drm\_syncobj}}}}) are
persistent objects that contain an optional fence. The fence can be updated
with a new fence, or be NULL.

syncobj's can be waited upon, where it will wait for the underlying
fence.

syncobj's can be export to fd's and back, these fd's are opaque and
have no other use case, except passing the syncobj between processes.

Their primary use-case is to implement Vulkan fences and semaphores.

syncobj have a kref reference count, but also have an optional file.
The file is only created once the syncobj is exported.
The file takes a reference on the kref.
\index{drm\_syncobj (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_syncobj}\pysigline{struct \bfcode{drm\_syncobj}}
sync object.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}syncobj \PYGZob{}
  struct kref refcount;
  struct dma\PYGZus{}fence \PYGZus{}\PYGZus{}rcu *fence;
  struct list\PYGZus{}head cb\PYGZus{}list;
  spinlock\PYGZus{}t lock;
  struct file *file;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{refcount}}] \leavevmode
Reference count of this object.

\item[{\code{fence}}] \leavevmode
NULL or a pointer to the fence bound to this object.

This field should not be used directly. Use {\hyperref[gpu/drm\string-mm:c.drm_syncobj_fence_get]{\emph{\code{drm\_syncobj\_fence\_get()}}}}
and {\hyperref[gpu/drm\string-mm:c.drm_syncobj_replace_fence]{\emph{\code{drm\_syncobj\_replace\_fence()}}}} instead.

\item[{\code{cb\_list}}] \leavevmode
List of callbacks to call when the \code{fence} gets replaced.

\item[{\code{lock}}] \leavevmode
Protects \code{cb\_list} and write-locks \code{fence}.

\item[{\code{file}}] \leavevmode
A file backing for this syncobj.

\end{description}

\textbf{Description}

This structure defines a generic sync object which wraps a \code{dma\_fence}.
\index{drm\_syncobj\_cb (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_syncobj_cb}\pysigline{struct \bfcode{drm\_syncobj\_cb}}
callback for drm\_syncobj\_add\_callback

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}syncobj\PYGZus{}cb \PYGZob{}
  struct list\PYGZus{}head node;
  drm\PYGZus{}syncobj\PYGZus{}func\PYGZus{}t func;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{node}}] \leavevmode
used by drm\_syncob\_add\_callback to append this struct to
{\hyperref[gpu/drm\string-mm:c.drm_syncobj]{\emph{\code{drm\_syncobj.cb\_list}}}}

\item[{\code{func}}] \leavevmode
drm\_syncobj\_func\_t to call

\end{description}

\textbf{Description}

This struct will be initialized by drm\_syncobj\_add\_callback, additional
data can be passed along by embedding drm\_syncobj\_cb in another struct.
The callback will get called the next time drm\_syncobj\_replace\_fence is
called.
\index{drm\_syncobj\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_syncobj_get}\pysiglinewithargsret{void \bfcode{drm\_syncobj\_get}}{struct {\hyperref[gpu/drm\string-mm:c.drm_syncobj]{\emph{drm\_syncobj}}} *\emph{ obj}}{}
acquire a syncobj reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_syncobj * obj}}] \leavevmode
sync object

\end{description}

\textbf{Description}

This acquires an additional reference to \textbf{obj}. It is illegal to call this
without already holding a reference. No locks required.
\index{drm\_syncobj\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_syncobj_put}\pysiglinewithargsret{void \bfcode{drm\_syncobj\_put}}{struct {\hyperref[gpu/drm\string-mm:c.drm_syncobj]{\emph{drm\_syncobj}}} *\emph{ obj}}{}
release a reference to a sync object.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_syncobj * obj}}] \leavevmode
sync object.

\end{description}
\index{drm\_syncobj\_fence\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_syncobj_fence_get}\pysiglinewithargsret{struct dma\_fence * \bfcode{drm\_syncobj\_fence\_get}}{struct {\hyperref[gpu/drm\string-mm:c.drm_syncobj]{\emph{drm\_syncobj}}} *\emph{ syncobj}}{}
get a reference to a fence in a sync object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_syncobj * syncobj}}] \leavevmode
sync object.

\end{description}

\textbf{Description}

This acquires additional reference to {\hyperref[gpu/drm\string-mm:c.drm_syncobj]{\emph{\code{drm\_syncobj.fence}}}} contained in \textbf{obj},
if not NULL. It is illegal to call this without already holding a reference.
No locks required.

\textbf{Return}

Either the fence of \textbf{obj} or NULL if there's none.
\index{drm\_syncobj\_find (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_syncobj_find}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-mm:c.drm_syncobj]{\emph{drm\_syncobj}}} * \bfcode{drm\_syncobj\_find}}{struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_private}, u32\emph{ handle}}{}
lookup and reference a sync object.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_file * file\_private}}] \leavevmode
drm file private pointer

\item[{\code{u32 handle}}] \leavevmode
sync object handle to lookup.

\end{description}

\textbf{Description}

Returns a reference to the syncobj pointed to by handle or NULL. The
reference must be released by calling {\hyperref[gpu/drm\string-mm:c.drm_syncobj_put]{\emph{\code{drm\_syncobj\_put()}}}}.
\index{drm\_syncobj\_add\_callback (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_syncobj_add_callback}\pysiglinewithargsret{void \bfcode{drm\_syncobj\_add\_callback}}{struct {\hyperref[gpu/drm\string-mm:c.drm_syncobj]{\emph{drm\_syncobj}}} *\emph{ syncobj}, struct {\hyperref[gpu/drm\string-mm:c.drm_syncobj_cb]{\emph{drm\_syncobj\_cb}}} *\emph{ cb}, drm\_syncobj\_func\_t\emph{ func}}{}
adds a callback to syncobj::cb\_list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_syncobj * syncobj}}] \leavevmode
Sync object to which to add the callback

\item[{\code{struct drm\_syncobj\_cb * cb}}] \leavevmode
Callback to add

\item[{\code{drm\_syncobj\_func\_t func}}] \leavevmode
Func to use when initializing the drm\_syncobj\_cb struct

\end{description}

\textbf{Description}

This adds a callback to be called next time the fence is replaced
\index{drm\_syncobj\_remove\_callback (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_syncobj_remove_callback}\pysiglinewithargsret{void \bfcode{drm\_syncobj\_remove\_callback}}{struct {\hyperref[gpu/drm\string-mm:c.drm_syncobj]{\emph{drm\_syncobj}}} *\emph{ syncobj}, struct {\hyperref[gpu/drm\string-mm:c.drm_syncobj_cb]{\emph{drm\_syncobj\_cb}}} *\emph{ cb}}{}
removes a callback to syncobj::cb\_list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_syncobj * syncobj}}] \leavevmode
Sync object from which to remove the callback

\item[{\code{struct drm\_syncobj\_cb * cb}}] \leavevmode
Callback to remove

\end{description}
\index{drm\_syncobj\_replace\_fence (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_syncobj_replace_fence}\pysiglinewithargsret{void \bfcode{drm\_syncobj\_replace\_fence}}{struct {\hyperref[gpu/drm\string-mm:c.drm_syncobj]{\emph{drm\_syncobj}}} *\emph{ syncobj}, struct dma\_fence *\emph{ fence}}{}
replace fence in a sync object.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_syncobj * syncobj}}] \leavevmode
Sync object to replace fence in

\item[{\code{struct dma\_fence * fence}}] \leavevmode
fence to install in sync file.

\end{description}

\textbf{Description}

This replaces the fence on a sync object.
\index{drm\_syncobj\_find\_fence (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_syncobj_find_fence}\pysiglinewithargsret{int \bfcode{drm\_syncobj\_find\_fence}}{struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_private}, u32\emph{ handle}, struct dma\_fence **\emph{ fence}}{}
lookup and reference the fence in a sync object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_file * file\_private}}] \leavevmode
drm file private pointer

\item[{\code{u32 handle}}] \leavevmode
sync object handle to lookup.

\item[{\code{struct dma\_fence ** fence}}] \leavevmode
out parameter for the fence

\end{description}

\textbf{Description}

This is just a convenience function that combines {\hyperref[gpu/drm\string-mm:c.drm_syncobj_find]{\emph{\code{drm\_syncobj\_find()}}}} and
{\hyperref[gpu/drm\string-mm:c.drm_syncobj_fence_get]{\emph{\code{drm\_syncobj\_fence\_get()}}}}.

Returns 0 on success or a negative error value on failure. On success \textbf{fence}
contains a reference to the fence, which must be released by calling
\code{dma\_fence\_put()}.
\index{drm\_syncobj\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_syncobj_free}\pysiglinewithargsret{void \bfcode{drm\_syncobj\_free}}{struct kref *\emph{ kref}}{}
free a sync object.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kref * kref}}] \leavevmode
kref to free.

\end{description}

\textbf{Description}

Only to be called from kref\_put in drm\_syncobj\_put.
\index{drm\_syncobj\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_syncobj_create}\pysiglinewithargsret{int \bfcode{drm\_syncobj\_create}}{struct {\hyperref[gpu/drm\string-mm:c.drm_syncobj]{\emph{drm\_syncobj}}} **\emph{ out\_syncobj}, uint32\_t\emph{ flags}, struct dma\_fence *\emph{ fence}}{}
create a new syncobj

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_syncobj ** out\_syncobj}}] \leavevmode
returned syncobj

\item[{\code{uint32\_t flags}}] \leavevmode
DRM\_SYNCOBJ\_* flags

\item[{\code{struct dma\_fence * fence}}] \leavevmode
if non-NULL, the syncobj will represent this fence

\end{description}

\textbf{Description}

This is the first function to create a sync object. After creating, drivers
probably want to make it available to userspace, either through
{\hyperref[gpu/drm\string-mm:c.drm_syncobj_get_handle]{\emph{\code{drm\_syncobj\_get\_handle()}}}} or {\hyperref[gpu/drm\string-mm:c.drm_syncobj_get_fd]{\emph{\code{drm\_syncobj\_get\_fd()}}}}.

Returns 0 on success or a negative error value on failure.
\index{drm\_syncobj\_get\_handle (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_syncobj_get_handle}\pysiglinewithargsret{int \bfcode{drm\_syncobj\_get\_handle}}{struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_private}, struct {\hyperref[gpu/drm\string-mm:c.drm_syncobj]{\emph{drm\_syncobj}}} *\emph{ syncobj}, u32 *\emph{ handle}}{}
get a handle from a syncobj

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_file * file\_private}}] \leavevmode
drm file private pointer

\item[{\code{struct drm\_syncobj * syncobj}}] \leavevmode
Sync object to export

\item[{\code{u32 * handle}}] \leavevmode
out parameter with the new handle

\end{description}

\textbf{Description}

Exports a sync object created with {\hyperref[gpu/drm\string-mm:c.drm_syncobj_create]{\emph{\code{drm\_syncobj\_create()}}}} as a handle on
\textbf{file\_private} to userspace.

Returns 0 on success or a negative error value on failure.
\index{drm\_syncobj\_get\_fd (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-mm:c.drm_syncobj_get_fd}\pysiglinewithargsret{int \bfcode{drm\_syncobj\_get\_fd}}{struct {\hyperref[gpu/drm\string-mm:c.drm_syncobj]{\emph{drm\_syncobj}}} *\emph{ syncobj}, int *\emph{ p\_fd}}{}
get a file descriptor from a syncobj

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_syncobj * syncobj}}] \leavevmode
Sync object to export

\item[{\code{int * p\_fd}}] \leavevmode
out parameter with the new file descriptor

\end{description}

\textbf{Description}

Exports a sync object created with {\hyperref[gpu/drm\string-mm:c.drm_syncobj_create]{\emph{\code{drm\_syncobj\_create()}}}} as a file descriptor.

Returns 0 on success or a negative error value on failure.


\chapter{Kernel Mode Setting (KMS)}
\label{gpu/drm-kms::doc}\label{gpu/drm-kms:kernel-mode-setting-kms}
Drivers must initialize the mode setting core by calling
{\hyperref[gpu/drm\string-kms:c.drm_mode_config_init]{\emph{\code{drm\_mode\_config\_init()}}}} on the DRM device. The function
initializes the \code{struct drm\_device}
mode\_config field and never fails. Once done, mode configuration must
be setup by initializing the following fields.
\begin{itemize}
\item {} 
int min\_width, min\_height; int max\_width, max\_height;
Minimum and maximum width and height of the frame buffers in pixel
units.

\item {} 
struct drm\_mode\_config\_funcs *funcs;
Mode setting functions.

\end{itemize}


\section{Overview}
\label{gpu/drm-kms:overview}\begin{figure}[htbp]
\centering
\capstart

\includegraphics{{DOT-dade12aa9127c64406e41cdf8d7f80694c134db2}.pdf}
\caption{KMS Display Pipeline Overview}\end{figure}

The basic object structure KMS presents to userspace is fairly simple.
Framebuffers (represented by {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{struct drm\_framebuffer}}}},
see {\hyperref[gpu/drm\string-kms:frame\string-buffer\string-abstraction]{\emph{Frame Buffer Abstraction}}}) feed into planes. One or more (or even no)
planes feed their pixel data into a CRTC (represented by {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{struct
drm\_crtc}}}}, see {\hyperref[gpu/drm\string-kms:crtc\string-abstraction]{\emph{CRTC Abstraction}}}) for blending. The precise
blending step is explained in more detail in {\hyperref[gpu/drm\string-kms:plane\string-composition\string-properties]{\emph{Plane Composition Properties}}} and
related chapters.

For the output routing the first step is encoders (represented by
{\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{\code{struct drm\_encoder}}}}, see {\hyperref[gpu/drm\string-kms:encoder\string-abstraction]{\emph{Encoder Abstraction}}}). Those
are really just internal artifacts of the helper libraries used to implement KMS
drivers. Besides that they make it unecessarily more complicated for userspace
to figure out which connections between a CRTC and a connector are possible, and
what kind of cloning is supported, they serve no purpose in the userspace API.
Unfortunately encoders have been exposed to userspace, hence can't remove them
at this point.  Futhermore the exposed restrictions are often wrongly set by
drivers, and in many cases not powerful enough to express the real restrictions.
A CRTC can be connected to multiple encoders, and for an active CRTC there must
be at least one encoder.

The final, and real, endpoint in the display chain is the connector (represented
by {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{struct drm\_connector}}}}, see {\hyperref[gpu/drm\string-kms:connector\string-abstraction]{\emph{Connector
Abstraction}}}). Connectors can have different possible encoders, but the kernel
driver selects which encoder to use for each connector. The use case is DVI,
which could switch between an analog and a digital encoder. Encoders can also
drive multiple different connectors. There is exactly one active connector for
every active encoder.

Internally the output pipeline is a bit more complex and matches today's
hardware more closely:
\begin{figure}[htbp]
\centering
\capstart

\includegraphics{{DOT-6445c75fc4859992454fd377127d4d309e82f09a}.pdf}
\caption{KMS Output Pipeline}\end{figure}

Internally two additional helper objects come into play. First, to be able to
share code for encoders (sometimes on the same SoC, sometimes off-chip) one or
more {\hyperref[gpu/drm\string-kms\string-helpers:drm\string-bridges]{\emph{Bridges}}} (represented by {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{\code{struct drm\_bridge}}}}) can be linked to an encoder. This link is static and cannot be
changed, which means the cross-bar (if there is any) needs to be mapped between
the CRTC and any encoders. Often for drivers with bridges there's no code left
at the encoder level. Atomic drivers can leave out all the encoder callbacks to
essentially only leave a dummy routing object behind, which is needed for
backwards compatibility since encoders are exposed to userspace.

The second object is for panels, represented by {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel]{\emph{\code{struct drm\_panel}}}}, see {\hyperref[gpu/drm\string-kms\string-helpers:drm\string-panel\string-helper]{\emph{Panel Helper Reference}}}. Panels do not have a fixed binding
point, but are generally linked to the driver private structure that embeds
{\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{struct drm\_connector}}}}.

Note that currently the bridge chaining and interactions with connectors and
panels are still in-flux and not really fully sorted out yet.


\section{KMS Core Structures and Functions}
\label{gpu/drm-kms:kms-core-structures-and-functions}\index{drm\_mode\_config\_funcs (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_config_funcs}\pysigline{struct \bfcode{drm\_mode\_config\_funcs}}
basic driver provided mode setting functions

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}mode\PYGZus{}config\PYGZus{}funcs \PYGZob{}
  struct drm\PYGZus{}framebuffer *(*fb\PYGZus{}create)(struct drm\PYGZus{}device *dev,struct drm\PYGZus{}file *file\PYGZus{}priv, const struct drm\PYGZus{}mode\PYGZus{}fb\PYGZus{}cmd2 *mode\PYGZus{}cmd);
  const struct drm\PYGZus{}format\PYGZus{}info *(*get\PYGZus{}format\PYGZus{}info)(const struct drm\PYGZus{}mode\PYGZus{}fb\PYGZus{}cmd2 *mode\PYGZus{}cmd);
  void (*output\PYGZus{}poll\PYGZus{}changed)(struct drm\PYGZus{}device *dev);
  int (*atomic\PYGZus{}check)(struct drm\PYGZus{}device *dev, struct drm\PYGZus{}atomic\PYGZus{}state *state);
  int (*atomic\PYGZus{}commit)(struct drm\PYGZus{}device *dev,struct drm\PYGZus{}atomic\PYGZus{}state *state, bool nonblock);
  struct drm\PYGZus{}atomic\PYGZus{}state *(*atomic\PYGZus{}state\PYGZus{}alloc)(struct drm\PYGZus{}device *dev);
  void (*atomic\PYGZus{}state\PYGZus{}clear)(struct drm\PYGZus{}atomic\PYGZus{}state *state);
  void (*atomic\PYGZus{}state\PYGZus{}free)(struct drm\PYGZus{}atomic\PYGZus{}state *state);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{fb\_create}}] \leavevmode
Create a new framebuffer object. The core does basic checks on the
requested metadata, but most of that is left to the driver. See
\code{struct drm\_mode\_fb\_cmd2} for details.

If the parameters are deemed valid and the backing storage objects in
the underlying memory manager all exist, then the driver allocates
a new {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}} structure, subclassed to contain
driver-specific information (like the internal native buffer object
references). It also needs to fill out all relevant metadata, which
should be done by calling {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_helper_mode_fill_fb_struct]{\emph{\code{drm\_helper\_mode\_fill\_fb\_struct()}}}}.

The initialization is finalized by calling {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_init]{\emph{\code{drm\_framebuffer\_init()}}}},
which registers the framebuffer and makes it accessible to other
threads.

RETURNS:

A new framebuffer with an initial reference count of 1 or a negative
error code encoded with \code{ERR\_PTR()}.

\item[{\code{get\_format\_info}}] \leavevmode
Allows a driver to return custom format information for special
fb layouts (eg. ones with auxiliary compression control planes).

RETURNS:

The format information specific to the given fb metadata, or
NULL if none is found.

\item[{\code{output\_poll\_changed}}] \leavevmode
Callback used by helpers to inform the driver of output configuration
changes.

Drivers implementing fbdev emulation with the helpers can call
drm\_fb\_helper\_hotplug\_changed from this hook to inform the fbdev
helper of output changes.

FIXME:

Except that there's no vtable for device-level helper callbacks
there's no reason this is a core function.

\item[{\code{atomic\_check}}] \leavevmode
This is the only hook to validate an atomic modeset update. This
function must reject any modeset and state changes which the hardware
or driver doesn't support. This includes but is of course not limited
to:
\begin{itemize}
\item {} 
Checking that the modes, framebuffers, scaling and placement
requirements and so on are within the limits of the hardware.

\item {} 
Checking that any hidden shared resources are not oversubscribed.
This can be shared PLLs, shared lanes, overall memory bandwidth,
display fifo space (where shared between planes or maybe even
CRTCs).

\item {} 
Checking that virtualized resources exported to userspace are not
oversubscribed. For various reasons it can make sense to expose
more planes, crtcs or encoders than which are physically there. One
example is dual-pipe operations (which generally should be hidden
from userspace if when lockstepped in hardware, exposed otherwise),
where a plane might need 1 hardware plane (if it's just on one
pipe), 2 hardware planes (when it spans both pipes) or maybe even
shared a hardware plane with a 2nd plane (if there's a compatible
plane requested on the area handled by the other pipe).

\item {} 
Check that any transitional state is possible and that if
requested, the update can indeed be done in the vblank period
without temporarily disabling some functions.

\item {} 
Check any other constraints the driver or hardware might have.

\item {} 
This callback also needs to correctly fill out the {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state}}}}
in this update to make sure that {\hyperref[gpu/drm\string-kms:c.drm_atomic_crtc_needs_modeset]{\emph{\code{drm\_atomic\_crtc\_needs\_modeset()}}}}
reflects the nature of the possible update and returns true if and
only if the update cannot be applied without tearing within one
vblank on that CRTC. The core uses that information to reject
updates which require a full modeset (i.e. blanking the screen, or
at least pausing updates for a substantial amount of time) if
userspace has disallowed that in its request.

\item {} 
The driver also does not need to repeat basic input validation
like done for the corresponding legacy entry points. The core does
that before calling this hook.

\end{itemize}

See the documentation of \textbf{atomic\_commit} for an exhaustive list of
error conditions which don't have to be checked at the in this
callback.

See the documentation for {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{struct drm\_atomic\_state}}}} for how exactly
an atomic modeset update is described.

Drivers using the atomic helpers can implement this hook using
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check]{\emph{\code{drm\_atomic\_helper\_check()}}}}, or one of the exported sub-functions of
it.

RETURNS:

0 on success or one of the below negative error codes:
\begin{itemize}
\item {} 
-EINVAL, if any of the above constraints are violated.

\item {} 
-EDEADLK, when returned from an attempt to acquire an additional
{\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock}}}} through {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock()}}}}.

\item {} 
-ENOMEM, if allocating additional state sub-structures failed due
to lack of memory.

\item {} 
-EINTR, -EAGAIN or -ERESTARTSYS, if the IOCTL should be restarted.
This can either be due to a pending signal, or because the driver
needs to completely bail out to recover from an exceptional
situation like a GPU hang. From a userspace point all errors are
treated equally.

\end{itemize}

\item[{\code{atomic\_commit}}] \leavevmode
This is the only hook to commit an atomic modeset update. The core
guarantees that \textbf{atomic\_check} has been called successfully before
calling this function, and that nothing has been changed in the
interim.

See the documentation for {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{struct drm\_atomic\_state}}}} for how exactly
an atomic modeset update is described.

Drivers using the atomic helpers can implement this hook using
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit]{\emph{\code{drm\_atomic\_helper\_commit()}}}}, or one of the exported sub-functions of
it.

Nonblocking commits (as indicated with the nonblock parameter) must
do any preparatory work which might result in an unsuccessful commit
in the context of this callback. The only exceptions are hardware
errors resulting in -EIO. But even in that case the driver must
ensure that the display pipe is at least running, to avoid
compositors crashing when pageflips don't work. Anything else,
specifically committing the update to the hardware, should be done
without blocking the caller. For updates which do not require a
modeset this must be guaranteed.

The driver must wait for any pending rendering to the new
framebuffers to complete before executing the flip. It should also
wait for any pending rendering from other drivers if the underlying
buffer is a shared dma-buf. Nonblocking commits must not wait for
rendering in the context of this callback.

An application can request to be notified when the atomic commit has
completed. These events are per-CRTC and can be distinguished by the
CRTC index supplied in \code{drm\_event} to userspace.

The drm core will supply a \code{struct drm\_event} in each CRTC's
{\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.event}}}}. See the documentation for
{\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.event}}}} for more details about the precise semantics of
this event.

NOTE:

Drivers are not allowed to shut down any display pipe successfully
enabled through an atomic commit on their own. Doing so can result in
compositors crashing if a page flip is suddenly rejected because the
pipe is off.

RETURNS:

0 on success or one of the below negative error codes:
\begin{itemize}
\item {} 
-EBUSY, if a nonblocking updated is requested and there is
an earlier updated pending. Drivers are allowed to support a queue
of outstanding updates, but currently no driver supports that.
Note that drivers must wait for preceding updates to complete if a
synchronous update is requested, they are not allowed to fail the
commit in that case.

\item {} 
-ENOMEM, if the driver failed to allocate memory. Specifically
this can happen when trying to pin framebuffers, which must only
be done when committing the state.

\item {} 
-ENOSPC, as a refinement of the more generic -ENOMEM to indicate
that the driver has run out of vram, iommu space or similar GPU
address space needed for framebuffer.

\item {} 
-EIO, if the hardware completely died.

\item {} 
-EINTR, -EAGAIN or -ERESTARTSYS, if the IOCTL should be restarted.
This can either be due to a pending signal, or because the driver
needs to completely bail out to recover from an exceptional
situation like a GPU hang. From a userspace point of view all errors are
treated equally.

\end{itemize}

This list is exhaustive. Specifically this hook is not allowed to
return -EINVAL (any invalid requests should be caught in
\textbf{atomic\_check}) or -EDEADLK (this function must not acquire
additional modeset locks).

\item[{\code{atomic\_state\_alloc}}] \leavevmode
This optional hook can be used by drivers that want to subclass struct
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}} to be able to track their own driver-private global
state easily. If this hook is implemented, drivers must also
implement \textbf{atomic\_state\_clear} and \textbf{atomic\_state\_free}.

Subclassing of {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}} is deprecated in favour of using
{\hyperref[gpu/drm\string-kms:c.drm_private_state]{\emph{\code{drm\_private\_state}}}} and {\hyperref[gpu/drm\string-kms:c.drm_private_obj]{\emph{\code{drm\_private\_obj}}}}.

RETURNS:

A new {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}} on success or NULL on failure.

\item[{\code{atomic\_state\_clear}}] \leavevmode
This hook must clear any driver private state duplicated into the
passed-in {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}}. This hook is called when the caller
encountered a {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock}}}} deadlock and needs to drop all
already acquired locks as part of the deadlock avoidance dance
implemented in {\hyperref[gpu/drm\string-kms:c.drm_modeset_backoff]{\emph{\code{drm\_modeset\_backoff()}}}}.

Any duplicated state must be invalidated since a concurrent atomic
update might change it, and the drm atomic interfaces always apply
updates as relative changes to the current state.

Drivers that implement this must call {\hyperref[gpu/drm\string-kms:c.drm_atomic_state_default_clear]{\emph{\code{drm\_atomic\_state\_default\_clear()}}}}
to clear common state.

Subclassing of {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}} is deprecated in favour of using
{\hyperref[gpu/drm\string-kms:c.drm_private_state]{\emph{\code{drm\_private\_state}}}} and {\hyperref[gpu/drm\string-kms:c.drm_private_obj]{\emph{\code{drm\_private\_obj}}}}.

\item[{\code{atomic\_state\_free}}] \leavevmode
This hook needs driver private resources and the {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}}
itself. Note that the core first calls {\hyperref[gpu/drm\string-kms:c.drm_atomic_state_clear]{\emph{\code{drm\_atomic\_state\_clear()}}}} to
avoid code duplicate between the clear and free hooks.

Drivers that implement this must call
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state_default_release]{\emph{\code{drm\_atomic\_state\_default\_release()}}}} to release common resources.

Subclassing of {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}} is deprecated in favour of using
{\hyperref[gpu/drm\string-kms:c.drm_private_state]{\emph{\code{drm\_private\_state}}}} and {\hyperref[gpu/drm\string-kms:c.drm_private_obj]{\emph{\code{drm\_private\_obj}}}}.

\end{description}

\textbf{Description}

Some global (i.e. not per-CRTC, connector, etc) mode setting functions that
involve drivers.
\index{drm\_mode\_config (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_config}\pysigline{struct \bfcode{drm\_mode\_config}}
Mode configuration control structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}mode\PYGZus{}config \PYGZob{}
  struct mutex mutex;
  struct drm\PYGZus{}modeset\PYGZus{}lock connection\PYGZus{}mutex;
  struct drm\PYGZus{}modeset\PYGZus{}acquire\PYGZus{}ctx *acquire\PYGZus{}ctx;
  struct mutex idr\PYGZus{}mutex;
  struct idr crtc\PYGZus{}idr;
  struct idr tile\PYGZus{}idr;
  struct mutex fb\PYGZus{}lock;
  int num\PYGZus{}fb;
  struct list\PYGZus{}head fb\PYGZus{}list;
  spinlock\PYGZus{}t connector\PYGZus{}list\PYGZus{}lock;
  int num\PYGZus{}connector;
  struct ida connector\PYGZus{}ida;
  struct list\PYGZus{}head connector\PYGZus{}list;
  struct llist\PYGZus{}head connector\PYGZus{}free\PYGZus{}list;
  struct work\PYGZus{}struct connector\PYGZus{}free\PYGZus{}work;
  int num\PYGZus{}encoder;
  struct list\PYGZus{}head encoder\PYGZus{}list;
  int num\PYGZus{}total\PYGZus{}plane;
  struct list\PYGZus{}head plane\PYGZus{}list;
  int num\PYGZus{}crtc;
  struct list\PYGZus{}head crtc\PYGZus{}list;
  struct list\PYGZus{}head property\PYGZus{}list;
  int min\PYGZus{}width, min\PYGZus{}height;
  int max\PYGZus{}width, max\PYGZus{}height;
  const struct drm\PYGZus{}mode\PYGZus{}config\PYGZus{}funcs *funcs;
  resource\PYGZus{}size\PYGZus{}t fb\PYGZus{}base;
  bool poll\PYGZus{}enabled;
  bool poll\PYGZus{}running;
  bool delayed\PYGZus{}event;
  struct delayed\PYGZus{}work output\PYGZus{}poll\PYGZus{}work;
  struct mutex blob\PYGZus{}lock;
  struct list\PYGZus{}head property\PYGZus{}blob\PYGZus{}list;
  struct drm\PYGZus{}property *edid\PYGZus{}property;
  struct drm\PYGZus{}property *dpms\PYGZus{}property;
  struct drm\PYGZus{}property *path\PYGZus{}property;
  struct drm\PYGZus{}property *tile\PYGZus{}property;
  struct drm\PYGZus{}property *link\PYGZus{}status\PYGZus{}property;
  struct drm\PYGZus{}property *plane\PYGZus{}type\PYGZus{}property;
  struct drm\PYGZus{}property *prop\PYGZus{}src\PYGZus{}x;
  struct drm\PYGZus{}property *prop\PYGZus{}src\PYGZus{}y;
  struct drm\PYGZus{}property *prop\PYGZus{}src\PYGZus{}w;
  struct drm\PYGZus{}property *prop\PYGZus{}src\PYGZus{}h;
  struct drm\PYGZus{}property *prop\PYGZus{}crtc\PYGZus{}x;
  struct drm\PYGZus{}property *prop\PYGZus{}crtc\PYGZus{}y;
  struct drm\PYGZus{}property *prop\PYGZus{}crtc\PYGZus{}w;
  struct drm\PYGZus{}property *prop\PYGZus{}crtc\PYGZus{}h;
  struct drm\PYGZus{}property *prop\PYGZus{}fb\PYGZus{}id;
  struct drm\PYGZus{}property *prop\PYGZus{}in\PYGZus{}fence\PYGZus{}fd;
  struct drm\PYGZus{}property *prop\PYGZus{}out\PYGZus{}fence\PYGZus{}ptr;
  struct drm\PYGZus{}property *prop\PYGZus{}crtc\PYGZus{}id;
  struct drm\PYGZus{}property *prop\PYGZus{}active;
  struct drm\PYGZus{}property *prop\PYGZus{}mode\PYGZus{}id;
  struct drm\PYGZus{}property *dvi\PYGZus{}i\PYGZus{}subconnector\PYGZus{}property;
  struct drm\PYGZus{}property *dvi\PYGZus{}i\PYGZus{}select\PYGZus{}subconnector\PYGZus{}property;
  struct drm\PYGZus{}property *tv\PYGZus{}subconnector\PYGZus{}property;
  struct drm\PYGZus{}property *tv\PYGZus{}select\PYGZus{}subconnector\PYGZus{}property;
  struct drm\PYGZus{}property *tv\PYGZus{}mode\PYGZus{}property;
  struct drm\PYGZus{}property *tv\PYGZus{}left\PYGZus{}margin\PYGZus{}property;
  struct drm\PYGZus{}property *tv\PYGZus{}right\PYGZus{}margin\PYGZus{}property;
  struct drm\PYGZus{}property *tv\PYGZus{}top\PYGZus{}margin\PYGZus{}property;
  struct drm\PYGZus{}property *tv\PYGZus{}bottom\PYGZus{}margin\PYGZus{}property;
  struct drm\PYGZus{}property *tv\PYGZus{}brightness\PYGZus{}property;
  struct drm\PYGZus{}property *tv\PYGZus{}contrast\PYGZus{}property;
  struct drm\PYGZus{}property *tv\PYGZus{}flicker\PYGZus{}reduction\PYGZus{}property;
  struct drm\PYGZus{}property *tv\PYGZus{}overscan\PYGZus{}property;
  struct drm\PYGZus{}property *tv\PYGZus{}saturation\PYGZus{}property;
  struct drm\PYGZus{}property *tv\PYGZus{}hue\PYGZus{}property;
  struct drm\PYGZus{}property *scaling\PYGZus{}mode\PYGZus{}property;
  struct drm\PYGZus{}property *aspect\PYGZus{}ratio\PYGZus{}property;
  struct drm\PYGZus{}property *degamma\PYGZus{}lut\PYGZus{}property;
  struct drm\PYGZus{}property *degamma\PYGZus{}lut\PYGZus{}size\PYGZus{}property;
  struct drm\PYGZus{}property *ctm\PYGZus{}property;
  struct drm\PYGZus{}property *gamma\PYGZus{}lut\PYGZus{}property;
  struct drm\PYGZus{}property *gamma\PYGZus{}lut\PYGZus{}size\PYGZus{}property;
  struct drm\PYGZus{}property *suggested\PYGZus{}x\PYGZus{}property;
  struct drm\PYGZus{}property *suggested\PYGZus{}y\PYGZus{}property;
  struct drm\PYGZus{}property *non\PYGZus{}desktop\PYGZus{}property;
  struct drm\PYGZus{}property *panel\PYGZus{}orientation\PYGZus{}property;
  uint32\PYGZus{}t preferred\PYGZus{}depth, prefer\PYGZus{}shadow;
  bool async\PYGZus{}page\PYGZus{}flip;
  bool allow\PYGZus{}fb\PYGZus{}modifiers;
  struct drm\PYGZus{}property *modifiers\PYGZus{}property;
  uint32\PYGZus{}t cursor\PYGZus{}width, cursor\PYGZus{}height;
  struct drm\PYGZus{}atomic\PYGZus{}state *suspend\PYGZus{}state;
  const struct drm\PYGZus{}mode\PYGZus{}config\PYGZus{}helper\PYGZus{}funcs *helper\PYGZus{}private;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{mutex}}] \leavevmode
This is the big scary modeset BKL which protects everything that
isn't protect otherwise. Scope is unclear and fuzzy, try to remove
anything from under it's protection and move it into more well-scoped
locks.

The one important thing this protects is the use of \textbf{acquire\_ctx}.

\item[{\code{connection\_mutex}}] \leavevmode
This protects connector state and the connector to encoder to CRTC
routing chain.

For atomic drivers specifically this protects {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.state}}}}.

\item[{\code{acquire\_ctx}}] \leavevmode
Global implicit acquire context used by atomic drivers for legacy
IOCTLs. Deprecated, since implicit locking contexts make it
impossible to use driver-private {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{struct drm\_modeset\_lock}}}}. Users of
this must hold \textbf{mutex}.

\item[{\code{idr\_mutex}}] \leavevmode
Mutex for KMS ID allocation and management. Protects both \textbf{crtc\_idr}
and \textbf{tile\_idr}.

\item[{\code{crtc\_idr}}] \leavevmode
Main KMS ID tracking object. Use this idr for all IDs, fb, crtc,
connector, modes - just makes life easier to have only one.

\item[{\code{tile\_idr}}] \leavevmode
Use this idr for allocating new IDs for tiled sinks like use in some
high-res DP MST screens.

\item[{\code{fb\_lock}}] \leavevmode
Mutex to protect fb the global \textbf{fb\_list} and \textbf{num\_fb}.

\item[{\code{num\_fb}}] \leavevmode
Number of entries on \textbf{fb\_list}.

\item[{\code{fb\_list}}] \leavevmode
List of all {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{struct drm\_framebuffer}}}}.

\item[{\code{connector\_list\_lock}}] \leavevmode
Protects \textbf{num\_connector} and
\textbf{connector\_list} and \textbf{connector\_free\_list}.

\item[{\code{num\_connector}}] \leavevmode
Number of connectors on this device. Protected by
\textbf{connector\_list\_lock}.

\item[{\code{connector\_ida}}] \leavevmode
ID allocator for connector indices.

\item[{\code{connector\_list}}] \leavevmode
List of connector objects linked with {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.head}}}}. Protected
by \textbf{connector\_list\_lock}. Only use {\hyperref[gpu/drm\string-kms:c.drm_for_each_connector_iter]{\emph{\code{drm\_for\_each\_connector\_iter()}}}} and
{\hyperref[gpu/drm\string-kms:c.drm_connector_list_iter]{\emph{\code{struct drm\_connector\_list\_iter}}}} to walk this list.

\item[{\code{connector\_free\_list}}] \leavevmode
List of connector objects linked with {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.free\_head}}}}.
Protected by \textbf{connector\_list\_lock}. Used by
{\hyperref[gpu/drm\string-kms:c.drm_for_each_connector_iter]{\emph{\code{drm\_for\_each\_connector\_iter()}}}} and
{\hyperref[gpu/drm\string-kms:c.drm_connector_list_iter]{\emph{\code{struct drm\_connector\_list\_iter}}}} to savely free connectors using
\textbf{connector\_free\_work}.

\item[{\code{connector\_free\_work}}] \leavevmode
Work to clean up \textbf{connector\_free\_list}.

\item[{\code{num\_encoder}}] \leavevmode
Number of encoders on this device. This is invariant over the
lifetime of a device and hence doesn't need any locks.

\item[{\code{encoder\_list}}] \leavevmode
List of encoder objects linked with {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{\code{drm\_encoder.head}}}}. This is
invariant over the lifetime of a device and hence doesn't need any
locks.

\item[{\code{num\_total\_plane}}] \leavevmode
Number of universal (i.e. with primary/curso) planes on this device.
This is invariant over the lifetime of a device and hence doesn't
need any locks.

\item[{\code{plane\_list}}] \leavevmode
List of plane objects linked with {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{drm\_plane.head}}}}. This is invariant
over the lifetime of a device and hence doesn't need any locks.

\item[{\code{num\_crtc}}] \leavevmode
Number of CRTCs on this device linked with {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc.head}}}}. This is invariant over the lifetime
of a device and hence doesn't need any locks.

\item[{\code{crtc\_list}}] \leavevmode
List of CRTC objects linked with {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc.head}}}}. This is invariant
over the lifetime of a device and hence doesn't need any locks.

\item[{\code{property\_list}}] \leavevmode
List of property type objects linked with {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{\code{drm\_property.head}}}}. This is
invariant over the lifetime of a device and hence doesn't need any
locks.

\item[{\code{min\_width}}] \leavevmode
minimum pixel width on this device

\item[{\code{min\_height}}] \leavevmode
minimum pixel height on this device

\item[{\code{max\_width}}] \leavevmode
maximum pixel width on this device

\item[{\code{max\_height}}] \leavevmode
maximum pixel height on this device

\item[{\code{funcs}}] \leavevmode
core driver provided mode setting functions

\item[{\code{fb\_base}}] \leavevmode
base address of the framebuffer

\item[{\code{poll\_enabled}}] \leavevmode
track polling support for this device

\item[{\code{poll\_running}}] \leavevmode
track polling status for this device

\item[{\code{delayed\_event}}] \leavevmode
track delayed poll uevent deliver for this device

\item[{\code{output\_poll\_work}}] \leavevmode
delayed work for polling in process context

\item[{\code{blob\_lock}}] \leavevmode
Mutex for blob property allocation and management, protects
\textbf{property\_blob\_list} and {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{drm\_file.blobs}}}}.

\item[{\code{property\_blob\_list}}] \leavevmode
List of all the blob property objects linked with
{\hyperref[gpu/drm\string-kms:c.drm_property_blob]{\emph{\code{drm\_property\_blob.head}}}}. Protected by \textbf{blob\_lock}.

\item[{\code{edid\_property}}] \leavevmode
Default connector property to hold the EDID of the
currently connected sink, if any.

\item[{\code{dpms\_property}}] \leavevmode
Default connector property to control the
connector's DPMS state.

\item[{\code{path\_property}}] \leavevmode
Default connector property to hold the DP MST path
for the port.

\item[{\code{tile\_property}}] \leavevmode
Default connector property to store the tile
position of a tiled screen, for sinks which need to be driven with
multiple CRTCs.

\item[{\code{link\_status\_property}}] \leavevmode
Default connector property for link status
of a connector

\item[{\code{plane\_type\_property}}] \leavevmode
Default plane property to differentiate
CURSOR, PRIMARY and OVERLAY legacy uses of planes.

\item[{\code{prop\_src\_x}}] \leavevmode
Default atomic plane property for the plane source
position in the connected {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}}.

\item[{\code{prop\_src\_y}}] \leavevmode
Default atomic plane property for the plane source
position in the connected {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}}.

\item[{\code{prop\_src\_w}}] \leavevmode
Default atomic plane property for the plane source
position in the connected {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}}.

\item[{\code{prop\_src\_h}}] \leavevmode
Default atomic plane property for the plane source
position in the connected {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}}.

\item[{\code{prop\_crtc\_x}}] \leavevmode
Default atomic plane property for the plane destination
position in the {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} is is being shown on.

\item[{\code{prop\_crtc\_y}}] \leavevmode
Default atomic plane property for the plane destination
position in the {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} is is being shown on.

\item[{\code{prop\_crtc\_w}}] \leavevmode
Default atomic plane property for the plane destination
position in the {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} is is being shown on.

\item[{\code{prop\_crtc\_h}}] \leavevmode
Default atomic plane property for the plane destination
position in the {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} is is being shown on.

\item[{\code{prop\_fb\_id}}] \leavevmode
Default atomic plane property to specify the
{\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}}.

\item[{\code{prop\_in\_fence\_fd}}] \leavevmode
Sync File fd representing the incoming fences
for a Plane.

\item[{\code{prop\_out\_fence\_ptr}}] \leavevmode
Sync File fd pointer representing the
outgoing fences for a CRTC. Userspace should provide a pointer to a
value of type s32, and then cast that pointer to u64.

\item[{\code{prop\_crtc\_id}}] \leavevmode
Default atomic plane property to specify the
{\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}}.

\item[{\code{prop\_active}}] \leavevmode
Default atomic CRTC property to control the active
state, which is the simplified implementation for DPMS in atomic
drivers.

\item[{\code{prop\_mode\_id}}] \leavevmode
Default atomic CRTC property to set the mode for a
CRTC. A 0 mode implies that the CRTC is entirely disabled - all
connectors must be of and active must be set to disabled, too.

\item[{\code{dvi\_i\_subconnector\_property}}] \leavevmode
Optional DVI-I property to
differentiate between analog or digital mode.

\item[{\code{dvi\_i\_select\_subconnector\_property}}] \leavevmode
Optional DVI-I property to
select between analog or digital mode.

\item[{\code{tv\_subconnector\_property}}] \leavevmode
Optional TV property to differentiate
between different TV connector types.

\item[{\code{tv\_select\_subconnector\_property}}] \leavevmode
Optional TV property to select
between different TV connector types.

\item[{\code{tv\_mode\_property}}] \leavevmode
Optional TV property to select
the output TV mode.

\item[{\code{tv\_left\_margin\_property}}] \leavevmode
Optional TV property to set the left
margin.

\item[{\code{tv\_right\_margin\_property}}] \leavevmode
Optional TV property to set the right
margin.

\item[{\code{tv\_top\_margin\_property}}] \leavevmode
Optional TV property to set the right
margin.

\item[{\code{tv\_bottom\_margin\_property}}] \leavevmode
Optional TV property to set the right
margin.

\item[{\code{tv\_brightness\_property}}] \leavevmode
Optional TV property to set the
brightness.

\item[{\code{tv\_contrast\_property}}] \leavevmode
Optional TV property to set the
contrast.

\item[{\code{tv\_flicker\_reduction\_property}}] \leavevmode
Optional TV property to control the
flicker reduction mode.

\item[{\code{tv\_overscan\_property}}] \leavevmode
Optional TV property to control the overscan
setting.

\item[{\code{tv\_saturation\_property}}] \leavevmode
Optional TV property to set the
saturation.

\item[{\code{tv\_hue\_property}}] \leavevmode
Optional TV property to set the hue.

\item[{\code{scaling\_mode\_property}}] \leavevmode
Optional connector property to control the
upscaling, mostly used for built-in panels.

\item[{\code{aspect\_ratio\_property}}] \leavevmode
Optional connector property to control the
HDMI infoframe aspect ratio setting.

\item[{\code{degamma\_lut\_property}}] \leavevmode
Optional CRTC property to set the LUT used to
convert the framebuffer's colors to linear gamma.

\item[{\code{degamma\_lut\_size\_property}}] \leavevmode
Optional CRTC property for the size of
the degamma LUT as supported by the driver (read-only).

\item[{\code{ctm\_property}}] \leavevmode
Optional CRTC property to set the
matrix used to convert colors after the lookup in the
degamma LUT.

\item[{\code{gamma\_lut\_property}}] \leavevmode
Optional CRTC property to set the LUT used to
convert the colors, after the CTM matrix, to the gamma space of the
connected screen.

\item[{\code{gamma\_lut\_size\_property}}] \leavevmode
Optional CRTC property for the size of the
gamma LUT as supported by the driver (read-only).

\item[{\code{suggested\_x\_property}}] \leavevmode
Optional connector property with a hint for
the position of the output on the host's screen.

\item[{\code{suggested\_y\_property}}] \leavevmode
Optional connector property with a hint for
the position of the output on the host's screen.

\item[{\code{non\_desktop\_property}}] \leavevmode
Optional connector property with a hint
that device isn't a standard display, and the console/desktop,
should not be displayed on it.

\item[{\code{panel\_orientation\_property}}] \leavevmode
Optional connector property indicating
how the lcd-panel is mounted inside the casing (e.g. normal or
upside-down).

\item[{\code{preferred\_depth}}] \leavevmode
preferred RBG pixel depth, used by fb helpers

\item[{\code{prefer\_shadow}}] \leavevmode
hint to userspace to prefer shadow-fb rendering

\item[{\code{async\_page\_flip}}] \leavevmode
Does this device support async flips on the primary
plane?

\item[{\code{allow\_fb\_modifiers}}] \leavevmode
Whether the driver supports fb modifiers in the ADDFB2.1 ioctl call.

\item[{\code{modifiers\_property}}] \leavevmode
Plane property to list support modifier/format
combination.

\item[{\code{cursor\_width}}] \leavevmode
hint to userspace for max cursor width

\item[{\code{cursor\_height}}] \leavevmode
hint to userspace for max cursor height

\item[{\code{suspend\_state}}] \leavevmode
Atomic state when suspended.
Set by {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_mode_config_helper_suspend]{\emph{\code{drm\_mode\_config\_helper\_suspend()}}}} and cleared by
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_mode_config_helper_resume]{\emph{\code{drm\_mode\_config\_helper\_resume()}}}}.

\item[{\code{helper\_private}}] \leavevmode
mid-layer private data

\end{description}

\textbf{Description}

Core mode resource tracking structure.  All CRTC, encoders, and connectors
enumerated by the driver are added here, as are global properties.  Some
global restrictions are also here, e.g. dimension restrictions.
\index{drm\_mode\_config\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_config_reset}\pysiglinewithargsret{void \bfcode{drm\_mode\_config\_reset}}{struct drm\_device *\emph{ dev}}{}
call -\textgreater{}reset callbacks

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\end{description}

\textbf{Description}

This functions calls all the crtc's, encoder's and connector's -\textgreater{}reset
callback. Drivers can use this in e.g. their driver load or resume code to
reset hardware and software state.
\index{drm\_mode\_config\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_config_init}\pysiglinewithargsret{void \bfcode{drm\_mode\_config\_init}}{struct drm\_device *\emph{ dev}}{}
initialize DRM mode\_configuration structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

Initialize \textbf{dev}`s mode\_config structure, used for tracking the graphics
configuration of \textbf{dev}.

Since this initializes the modeset locks, no locking is possible. Which is no
problem, since this should happen single threaded at init time. It is the
driver's problem to ensure this guarantee.
\index{drm\_mode\_config\_cleanup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_config_cleanup}\pysiglinewithargsret{void \bfcode{drm\_mode\_config\_cleanup}}{struct drm\_device *\emph{ dev}}{}
free up DRM mode\_config info

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

Free up all the connectors and CRTCs associated with this DRM device, then
free up the framebuffers and associated buffer objects.

Note that since this /should/ happen single-threaded at driver/device
teardown time, no locking is required. It's the driver's job to ensure that
this guarantee actually holds true.

FIXME: cleanup any dangling user buffer objects too


\section{Modeset Base Object Abstraction}
\label{gpu/drm-kms:modeset-base-object-abstraction}\begin{figure}[htbp]
\centering
\capstart

\includegraphics{{DOT-1eee3f74bb2de20b2b68c4aa6c9c1cabe5078857}.pdf}
\caption{Mode Objects and Properties}\end{figure}

The base structure for all KMS objects is {\hyperref[gpu/drm\string-kms:c.drm_mode_object]{\emph{\code{struct drm\_mode\_object}}}}. One of the base services it provides is tracking properties,
which are especially important for the atomic IOCTL (see {\hyperref[gpu/drm\string-kms:atomic\string-mode\string-setting]{\emph{Atomic Mode
Setting}}}). The somewhat surprising part here is that properties are not
directly instantiated on each object, but free-standing mode objects themselves,
represented by {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{\code{struct drm\_property}}}}, which only specify
the type and value range of a property. Any given property can be attached
multiple times to different objects using {\hyperref[gpu/drm\string-kms:c.drm_object_attach_property]{\emph{\code{drm\_object\_attach\_property()}}}}.
\index{drm\_mode\_object (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_object}\pysigline{struct \bfcode{drm\_mode\_object}}
base structure for modeset objects

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}mode\PYGZus{}object \PYGZob{}
  uint32\PYGZus{}t id;
  uint32\PYGZus{}t type;
  struct drm\PYGZus{}object\PYGZus{}properties *properties;
  struct kref refcount;
  void (*free\PYGZus{}cb)(struct kref *kref);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{id}}] \leavevmode
userspace visible identifier

\item[{\code{type}}] \leavevmode
type of the object, one of DRM\_MODE\_OBJECT\_*

\item[{\code{properties}}] \leavevmode
properties attached to this object, including values

\item[{\code{refcount}}] \leavevmode
reference count for objects which with dynamic lifetime

\item[{\code{free\_cb}}] \leavevmode
free function callback, only set for objects with dynamic lifetime

\end{description}

\textbf{Description}

Base structure for modeset objects visible to userspace. Objects can be
looked up using {\hyperref[gpu/drm\string-kms:c.drm_mode_object_find]{\emph{\code{drm\_mode\_object\_find()}}}}. Besides basic uapi interface
properties like \textbf{id} and \textbf{type} it provides two services:
\begin{itemize}
\item {} 
It tracks attached properties and their values. This is used by {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}},
{\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{drm\_plane}}}} and {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector}}}}. Properties are attached by calling
{\hyperref[gpu/drm\string-kms:c.drm_object_attach_property]{\emph{\code{drm\_object\_attach\_property()}}}} before the object is visible to userspace.

\item {} 
For objects with dynamic lifetimes (as indicated by a non-NULL \textbf{free\_cb}) it
provides reference counting through {\hyperref[gpu/drm\string-kms:c.drm_mode_object_get]{\emph{\code{drm\_mode\_object\_get()}}}} and
{\hyperref[gpu/drm\string-kms:c.drm_mode_object_put]{\emph{\code{drm\_mode\_object\_put()}}}}. This is used by {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}}, {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector}}}}
and {\hyperref[gpu/drm\string-kms:c.drm_property_blob]{\emph{\code{drm\_property\_blob}}}}. These objects provide specialized reference
counting wrappers.

\end{itemize}
\index{drm\_object\_properties (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_object_properties}\pysigline{struct \bfcode{drm\_object\_properties}}
property tracking for {\hyperref[gpu/drm\string-kms:c.drm_mode_object]{\emph{\code{drm\_mode\_object}}}}

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}object\PYGZus{}properties \PYGZob{}
  int count;
  struct drm\PYGZus{}property *properties[DRM\PYGZus{}OBJECT\PYGZus{}MAX\PYGZus{}PROPERTY];
  uint64\PYGZus{}t values[DRM\PYGZus{}OBJECT\PYGZus{}MAX\PYGZus{}PROPERTY];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{count}}] \leavevmode
number of valid properties, must be less than or equal to
DRM\_OBJECT\_MAX\_PROPERTY.

\item[{\code{properties}}] \leavevmode
Array of pointers to {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{\code{drm\_property}}}}.

NOTE: if we ever start dynamically destroying properties (ie.
not at {\hyperref[gpu/drm\string-kms:c.drm_mode_config_cleanup]{\emph{\code{drm\_mode\_config\_cleanup()}}}} time), then we'd have to do
a better job of detaching property from mode objects to avoid
dangling property pointers:

\item[{\code{values}}] \leavevmode
Array to store the property values, matching \textbf{properties}. Do
not read/write values directly, but use
{\hyperref[gpu/drm\string-kms:c.drm_object_property_get_value]{\emph{\code{drm\_object\_property\_get\_value()}}}} and {\hyperref[gpu/drm\string-kms:c.drm_object_property_set_value]{\emph{\code{drm\_object\_property\_set\_value()}}}}.

Note that atomic drivers do not store mutable properties in this
array, but only the decoded values in the corresponding state
structure. The decoding is done using the {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc.atomic\_get\_property}}}} and
{\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc.atomic\_set\_property}}}} hooks for {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{struct drm\_crtc}}}}. For
{\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{struct drm\_plane}}}} the hooks are {\hyperref[gpu/drm\string-kms:c.drm_plane_funcs]{\emph{\code{drm\_plane\_funcs.atomic\_get\_property}}}} and
{\hyperref[gpu/drm\string-kms:c.drm_plane_funcs]{\emph{\code{drm\_plane\_funcs.atomic\_set\_property}}}}. And for {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{struct drm\_connector}}}}
the hooks are {\hyperref[gpu/drm\string-kms:c.drm_connector_funcs]{\emph{\code{drm\_connector\_funcs.atomic\_get\_property}}}} and
{\hyperref[gpu/drm\string-kms:c.drm_connector_funcs]{\emph{\code{drm\_connector\_funcs.atomic\_set\_property}}}} .

Hence atomic drivers should not use {\hyperref[gpu/drm\string-kms:c.drm_object_property_set_value]{\emph{\code{drm\_object\_property\_set\_value()}}}}
and {\hyperref[gpu/drm\string-kms:c.drm_object_property_get_value]{\emph{\code{drm\_object\_property\_get\_value()}}}} on mutable objects, i.e. those
without the DRM\_MODE\_PROP\_IMMUTABLE flag set.

\end{description}
\index{drm\_mode\_object\_reference (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_object_reference}\pysiglinewithargsret{void \bfcode{drm\_mode\_object\_reference}}{struct {\hyperref[gpu/drm\string-kms:c.drm_mode_object]{\emph{drm\_mode\_object}}} *\emph{ obj}}{}
acquire a mode object reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mode\_object * obj}}] \leavevmode
DRM mode object

\end{description}

\textbf{Description}

This is a compatibility alias for {\hyperref[gpu/drm\string-kms:c.drm_mode_object_get]{\emph{\code{drm\_mode\_object\_get()}}}} and should not be
used by new code.
\index{drm\_mode\_object\_unreference (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_object_unreference}\pysiglinewithargsret{void \bfcode{drm\_mode\_object\_unreference}}{struct {\hyperref[gpu/drm\string-kms:c.drm_mode_object]{\emph{drm\_mode\_object}}} *\emph{ obj}}{}
release a mode object reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mode\_object * obj}}] \leavevmode
DRM mode object

\end{description}

\textbf{Description}

This is a compatibility alias for {\hyperref[gpu/drm\string-kms:c.drm_mode_object_put]{\emph{\code{drm\_mode\_object\_put()}}}} and should not be
used by new code.
\index{drm\_mode\_object\_find (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_object_find}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_mode_object]{\emph{drm\_mode\_object}}} * \bfcode{drm\_mode\_object\_find}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}, uint32\_t\emph{ id}, uint32\_t\emph{ type}}{}
look up a drm object with static lifetime

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
drm file

\item[{\code{uint32\_t id}}] \leavevmode
id of the mode object

\item[{\code{uint32\_t type}}] \leavevmode
type of the mode object

\end{description}

\textbf{Description}

This function is used to look up a modeset object. It will acquire a
reference for reference counted objects. This reference must be dropped again
by callind {\hyperref[gpu/drm\string-kms:c.drm_mode_object_put]{\emph{\code{drm\_mode\_object\_put()}}}}.
\index{drm\_mode\_object\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_object_put}\pysiglinewithargsret{void \bfcode{drm\_mode\_object\_put}}{struct {\hyperref[gpu/drm\string-kms:c.drm_mode_object]{\emph{drm\_mode\_object}}} *\emph{ obj}}{}
release a mode object reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mode\_object * obj}}] \leavevmode
DRM mode object

\end{description}

\textbf{Description}

This function decrements the object's refcount if it is a refcounted modeset
object. It is a no-op on any other object. This is used to drop references
acquired with {\hyperref[gpu/drm\string-kms:c.drm_mode_object_get]{\emph{\code{drm\_mode\_object\_get()}}}}.
\index{drm\_mode\_object\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_object_get}\pysiglinewithargsret{void \bfcode{drm\_mode\_object\_get}}{struct {\hyperref[gpu/drm\string-kms:c.drm_mode_object]{\emph{drm\_mode\_object}}} *\emph{ obj}}{}
acquire a mode object reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mode\_object * obj}}] \leavevmode
DRM mode object

\end{description}

\textbf{Description}

This function increments the object's refcount if it is a refcounted modeset
object. It is a no-op on any other object. References should be dropped again
by calling {\hyperref[gpu/drm\string-kms:c.drm_mode_object_put]{\emph{\code{drm\_mode\_object\_put()}}}}.
\index{drm\_object\_attach\_property (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_object_attach_property}\pysiglinewithargsret{void \bfcode{drm\_object\_attach\_property}}{struct {\hyperref[gpu/drm\string-kms:c.drm_mode_object]{\emph{drm\_mode\_object}}} *\emph{ obj}, struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} *\emph{ property}, uint64\_t\emph{ init\_val}}{}
attach a property to a modeset object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mode\_object * obj}}] \leavevmode
drm modeset object

\item[{\code{struct drm\_property * property}}] \leavevmode
property to attach

\item[{\code{uint64\_t init\_val}}] \leavevmode
initial value of the property

\end{description}

\textbf{Description}

This attaches the given property to the modeset object with the given initial
value. Currently this function cannot fail since the properties are stored in
a statically sized array.
\index{drm\_object\_property\_set\_value (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_object_property_set_value}\pysiglinewithargsret{int \bfcode{drm\_object\_property\_set\_value}}{struct {\hyperref[gpu/drm\string-kms:c.drm_mode_object]{\emph{drm\_mode\_object}}} *\emph{ obj}, struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} *\emph{ property}, uint64\_t\emph{ val}}{}
set the value of a property

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mode\_object * obj}}] \leavevmode
drm mode object to set property value for

\item[{\code{struct drm\_property * property}}] \leavevmode
property to set

\item[{\code{uint64\_t val}}] \leavevmode
value the property should be set to

\end{description}

\textbf{Description}

This function sets a given property on a given object. This function only
changes the software state of the property, it does not call into the
driver's -\textgreater{}set\_property callback.

Note that atomic drivers should not have any need to call this, the core will
ensure consistency of values reported back to userspace through the
appropriate -\textgreater{}atomic\_get\_property callback. Only legacy drivers should call
this function to update the tracked value (after clamping and other
restrictions have been applied).

\textbf{Return}

Zero on success, error code on failure.
\index{drm\_object\_property\_get\_value (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_object_property_get_value}\pysiglinewithargsret{int \bfcode{drm\_object\_property\_get\_value}}{struct {\hyperref[gpu/drm\string-kms:c.drm_mode_object]{\emph{drm\_mode\_object}}} *\emph{ obj}, struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} *\emph{ property}, uint64\_t *\emph{ val}}{}
retrieve the value of a property

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mode\_object * obj}}] \leavevmode
drm mode object to get property value from

\item[{\code{struct drm\_property * property}}] \leavevmode
property to retrieve

\item[{\code{uint64\_t * val}}] \leavevmode
storage for the property value

\end{description}

\textbf{Description}

This function retrieves the softare state of the given property for the given
property. Since there is no driver callback to retrieve the current property
value this might be out of sync with the hardware, depending upon the driver
and property.

Atomic drivers should never call this function directly, the core will read
out property values through the various -\textgreater{}atomic\_get\_property callbacks.

\textbf{Return}

Zero on success, error code on failure.


\section{Atomic Mode Setting}
\label{gpu/drm-kms:atomic-mode-setting}\begin{figure}[htbp]
\centering
\capstart

\includegraphics{{DOT-69c6997054dbfdfb0892fa0cab076cfd8074c7ed}.pdf}
\caption{Mode Objects and Properties}\end{figure}

Atomic provides transactional modeset (including planes) updates, but a
bit differently from the usual transactional approach of try-commit and
rollback:
\begin{itemize}
\item {} 
Firstly, no hardware changes are allowed when the commit would fail. This
allows us to implement the DRM\_MODE\_ATOMIC\_TEST\_ONLY mode, which allows
userspace to explore whether certain configurations would work or not.

\item {} 
This would still allow setting and rollback of just the software state,
simplifying conversion of existing drivers. But auditing drivers for
correctness of the atomic\_check code becomes really hard with that: Rolling
back changes in data structures all over the place is hard to get right.

\item {} 
Lastly, for backwards compatibility and to support all use-cases, atomic
updates need to be incremental and be able to execute in parallel. Hardware
doesn't always allow it, but where possible plane updates on different CRTCs
should not interfere, and not get stalled due to output routing changing on
different CRTCs.

\end{itemize}

Taken all together there's two consequences for the atomic design:
\begin{itemize}
\item {} 
The overall state is split up into per-object state structures:
{\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{struct drm\_plane\_state}}}} for planes, {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{struct
drm\_crtc\_state}}}} for CRTCs and {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{\code{struct
drm\_connector\_state}}}} for connectors. These are the only
objects with userspace-visible and settable state. For internal state drivers
can subclass these structures through embeddeding, or add entirely new state
structures for their globally shared hardware functions.

\item {} 
An atomic update is assembled and validated as an entirely free-standing pile
of structures within the {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}}
container. Driver private state structures are also tracked in the same
structure; see the next chapter.  Only when a state is committed is it applied
to the driver and modeset objects. This way rolling back an update boils down
to releasing memory and unreferencing objects like framebuffers.

\end{itemize}

Read on in this chapter, and also in {\hyperref[gpu/drm\string-kms\string-helpers:drm\string-atomic\string-helper]{\emph{Atomic Modeset Helper Functions Reference}}} for more detailed
coverage of specific topics.


\subsection{Handling Driver Private State}
\label{gpu/drm-kms:handling-driver-private-state}
Very often the DRM objects exposed to userspace in the atomic modeset api
({\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector}}}}, {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} and {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{drm\_plane}}}}) do not map neatly to the
underlying hardware. Especially for any kind of shared resources (e.g. shared
clocks, scaler units, bandwidth and fifo limits shared among a group of
planes or CRTCs, and so on) it makes sense to model these as independent
objects. Drivers then need to do similar state tracking and commit ordering for
such private (since not exposed to userpace) objects as the atomic core and
helpers already provide for connectors, planes and CRTCs.

To make this easier on drivers the atomic core provides some support to track
driver private state objects using struct {\hyperref[gpu/drm\string-kms:c.drm_private_obj]{\emph{\code{drm\_private\_obj}}}}, with the
associated state struct {\hyperref[gpu/drm\string-kms:c.drm_private_state]{\emph{\code{drm\_private\_state}}}}.

Similar to userspace-exposed objects, private state structures can be
acquired by calling {\hyperref[gpu/drm\string-kms:c.drm_atomic_get_private_obj_state]{\emph{\code{drm\_atomic\_get\_private\_obj\_state()}}}}. Since this function
does not take care of locking, drivers should wrap it for each type of
private state object they have with the required call to {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock()}}}}
for the corresponding {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock}}}}.

All private state structures contained in a {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}} update can be
iterated using {\hyperref[gpu/drm\string-kms:c.for_each_oldnew_private_obj_in_state]{\emph{\code{for\_each\_oldnew\_private\_obj\_in\_state()}}}},
{\hyperref[gpu/drm\string-kms:c.for_each_new_private_obj_in_state]{\emph{\code{for\_each\_new\_private\_obj\_in\_state()}}}} and {\hyperref[gpu/drm\string-kms:c.for_each_old_private_obj_in_state]{\emph{\code{for\_each\_old\_private\_obj\_in\_state()}}}}.
Drivers are recommended to wrap these for each type of driver private state
object they have, filtering on {\hyperref[gpu/drm\string-kms:c.drm_private_obj]{\emph{\code{drm\_private\_obj.funcs}}}} using \code{for\_each\_if()}, at
least if they want to iterate over all objects of a given type.

An earlier way to handle driver private state was by subclassing struct
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}}. But since that encourages non-standard ways to implement
the check/commit split atomic requires (by using e.g. ``check and rollback or
commit instead'' of ``duplicate state, check, then either commit or release
duplicated state) it is deprecated in favour of using {\hyperref[gpu/drm\string-kms:c.drm_private_state]{\emph{\code{drm\_private\_state}}}}.


\subsection{Atomic Mode Setting Function Reference}
\label{gpu/drm-kms:atomic-mode-setting-function-reference}\index{drm\_crtc\_commit (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_commit}\pysigline{struct \bfcode{drm\_crtc\_commit}}
track modeset commits on a CRTC

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}crtc\PYGZus{}commit \PYGZob{}
  struct drm\PYGZus{}crtc *crtc;
  struct kref ref;
  struct completion flip\PYGZus{}done;
  struct completion hw\PYGZus{}done;
  struct completion cleanup\PYGZus{}done;
  struct list\PYGZus{}head commit\PYGZus{}entry;
  struct drm\PYGZus{}pending\PYGZus{}vblank\PYGZus{}event *event;
  bool abort\PYGZus{}completion;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{crtc}}] \leavevmode
DRM CRTC for this commit.

\item[{\code{ref}}] \leavevmode
Reference count for this structure. Needed to allow blocking on
completions without the risk of the completion disappearing
meanwhile.

\item[{\code{flip\_done}}] \leavevmode
Will be signaled when the hardware has flipped to the new set of
buffers. Signals at the same time as when the drm event for this
commit is sent to userspace, or when an out-fence is singalled. Note
that for most hardware, in most cases this happens after \textbf{hw\_done} is
signalled.

\item[{\code{hw\_done}}] \leavevmode
Will be signalled when all hw register changes for this commit have
been written out. Especially when disabling a pipe this can be much
later than than \textbf{flip\_done}, since that can signal already when the
screen goes black, whereas to fully shut down a pipe more register
I/O is required.

Note that this does not need to include separately reference-counted
resources like backing storage buffer pinning, or runtime pm
management.

\item[{\code{cleanup\_done}}] \leavevmode
Will be signalled after old buffers have been cleaned up by calling
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_cleanup_planes]{\emph{\code{drm\_atomic\_helper\_cleanup\_planes()}}}}. Since this can only happen after
a vblank wait completed it might be a bit later. This completion is
useful to throttle updates and avoid hardware updates getting ahead
of the buffer cleanup too much.

\item[{\code{commit\_entry}}] \leavevmode
Entry on the per-CRTC {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc.commit\_list}}}}. Protected by
\$drm\_crtc.commit\_lock.

\item[{\code{event}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_pending_vblank_event]{\emph{\code{drm\_pending\_vblank\_event}}}} pointer to clean up private events.

\item[{\code{abort\_completion}}] \leavevmode
A flag that's set after drm\_atomic\_helper\_setup\_commit takes a second
reference for the completion of \$drm\_crtc\_state.event. It's used by
the free code to remove the second reference if commit fails.

\end{description}

\textbf{Description}

This structure is used to track pending modeset changes and atomic commit on
a per-CRTC basis. Since updating the list should never block this structure
is reference counted to allow waiters to safely wait on an event to complete,
without holding any locks.

It has 3 different events in total to allow a fine-grained synchronization
between outstanding updates:

\begin{Verbatim}[commandchars=\\\{\}]
atomic commit thread                    hardware

write new state into hardware   \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}   ...
signal hw\PYGZus{}done
                                        switch to new state on next
...                                     v/hblank

wait for buffers to show up             ...

...                                     send completion irq
                                        irq handler signals flip\PYGZus{}done
cleanup old buffers

signal cleanup\PYGZus{}done

wait for flip\PYGZus{}done              \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
clean up atomic state
\end{Verbatim}

The important bit to know is that cleanup\_done is the terminal event, but the
ordering between flip\_done and hw\_done is entirely up to the specific driver
and modeset state change.

For an implementation of how to use this look at
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_setup_commit]{\emph{\code{drm\_atomic\_helper\_setup\_commit()}}}} from the atomic helper library.
\index{drm\_private\_state\_funcs (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_private_state_funcs}\pysigline{struct \bfcode{drm\_private\_state\_funcs}}
atomic state functions for private objects

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}private\PYGZus{}state\PYGZus{}funcs \PYGZob{}
  struct drm\PYGZus{}private\PYGZus{}state *(*atomic\PYGZus{}duplicate\PYGZus{}state)(struct drm\PYGZus{}private\PYGZus{}obj *obj);
  void (*atomic\PYGZus{}destroy\PYGZus{}state)(struct drm\PYGZus{}private\PYGZus{}obj *obj, struct drm\PYGZus{}private\PYGZus{}state *state);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{atomic\_duplicate\_state}}] \leavevmode
Duplicate the current state of the private object and return it. It
is an error to call this before obj-\textgreater{}state has been initialized.

RETURNS:

Duplicated atomic state or NULL when obj-\textgreater{}state is not
initialized or allocation failed.

\item[{\code{atomic\_destroy\_state}}] \leavevmode
Frees the private object state created with \textbf{atomic\_duplicate\_state}.

\end{description}

\textbf{Description}

These hooks are used by atomic helpers to create, swap and destroy states of
private objects. The structure itself is used as a vtable to identify the
associated private object type. Each private object type that needs to be
added to the atomic states is expected to have an implementation of these
hooks and pass a pointer to it's drm\_private\_state\_funcs struct to
{\hyperref[gpu/drm\string-kms:c.drm_atomic_get_private_obj_state]{\emph{\code{drm\_atomic\_get\_private\_obj\_state()}}}}.
\index{drm\_private\_obj (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_private_obj}\pysigline{struct \bfcode{drm\_private\_obj}}
base struct for driver private atomic object

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}private\PYGZus{}obj \PYGZob{}
  struct drm\PYGZus{}private\PYGZus{}state *state;
  const struct drm\PYGZus{}private\PYGZus{}state\PYGZus{}funcs *funcs;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{state}}] \leavevmode
Current atomic state for this driver private object.

\item[{\code{funcs}}] \leavevmode
Functions to manipulate the state of this driver private object, see
{\hyperref[gpu/drm\string-kms:c.drm_private_state_funcs]{\emph{\code{drm\_private\_state\_funcs}}}}.

\end{description}

\textbf{Description}

A driver private object is initialized by calling
{\hyperref[gpu/drm\string-kms:c.drm_atomic_private_obj_init]{\emph{\code{drm\_atomic\_private\_obj\_init()}}}} and cleaned up by calling
{\hyperref[gpu/drm\string-kms:c.drm_atomic_private_obj_fini]{\emph{\code{drm\_atomic\_private\_obj\_fini()}}}}.

Currently only tracks the state update functions and the opaque driver
private state itself, but in the future might also track which
{\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock}}}} is required to duplicate and update this object's state.
\index{drm\_private\_state (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_private_state}\pysigline{struct \bfcode{drm\_private\_state}}
base struct for driver private object state

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}private\PYGZus{}state \PYGZob{}
  struct drm\PYGZus{}atomic\PYGZus{}state *state;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{state}}] \leavevmode
backpointer to global drm\_atomic\_state

\end{description}

\textbf{Description}

Currently only contains a backpointer to the overall atomic update, but in
the future also might hold synchronization information similar to e.g.
{\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc.commit}}}}.
\index{drm\_atomic\_state (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_state}\pysigline{struct \bfcode{drm\_atomic\_state}}
the global state object for atomic updates

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}atomic\PYGZus{}state \PYGZob{}
  struct kref ref;
  struct drm\PYGZus{}device *dev;
  bool allow\PYGZus{}modeset : 1;
  bool legacy\PYGZus{}cursor\PYGZus{}update : 1;
  bool async\PYGZus{}update : 1;
  struct \PYGZus{}\PYGZus{}drm\PYGZus{}planes\PYGZus{}state *planes;
  struct \PYGZus{}\PYGZus{}drm\PYGZus{}crtcs\PYGZus{}state *crtcs;
  int num\PYGZus{}connector;
  struct \PYGZus{}\PYGZus{}drm\PYGZus{}connnectors\PYGZus{}state *connectors;
  int num\PYGZus{}private\PYGZus{}objs;
  struct \PYGZus{}\PYGZus{}drm\PYGZus{}private\PYGZus{}objs\PYGZus{}state *private\PYGZus{}objs;
  struct drm\PYGZus{}modeset\PYGZus{}acquire\PYGZus{}ctx *acquire\PYGZus{}ctx;
  struct drm\PYGZus{}crtc\PYGZus{}commit *fake\PYGZus{}commit;
  struct work\PYGZus{}struct commit\PYGZus{}work;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{ref}}] \leavevmode
count of all references to this state (will not be freed until zero)

\item[{\code{dev}}] \leavevmode
parent DRM device

\item[{\code{allow\_modeset}}] \leavevmode
allow full modeset

\item[{\code{legacy\_cursor\_update}}] \leavevmode
hint to enforce legacy cursor IOCTL semantics

\item[{\code{async\_update}}] \leavevmode
hint for asynchronous plane update

\item[{\code{planes}}] \leavevmode
pointer to array of structures with per-plane data

\item[{\code{crtcs}}] \leavevmode
pointer to array of CRTC pointers

\item[{\code{num\_connector}}] \leavevmode
size of the \textbf{connectors} and \textbf{connector\_states} arrays

\item[{\code{connectors}}] \leavevmode
pointer to array of structures with per-connector data

\item[{\code{num\_private\_objs}}] \leavevmode
size of the \textbf{private\_objs} array

\item[{\code{private\_objs}}] \leavevmode
pointer to array of private object pointers

\item[{\code{acquire\_ctx}}] \leavevmode
acquire context for this atomic modeset state update

\item[{\code{fake\_commit}}] \leavevmode
Used for signaling unbound planes/connectors.
When a connector or plane is not bound to any CRTC, it's still important
to preserve linearity to prevent the atomic states from being freed to early.

This commit (if set) is not bound to any crtc, but will be completed when
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit_hw_done]{\emph{\code{drm\_atomic\_helper\_commit\_hw\_done()}}}} is called.

\item[{\code{commit\_work}}] \leavevmode
Work item which can be used by the driver or helpers to execute the
commit without blocking.

\end{description}

\textbf{Description}

States are added to an atomic update by calling {\hyperref[gpu/drm\string-kms:c.drm_atomic_get_crtc_state]{\emph{\code{drm\_atomic\_get\_crtc\_state()}}}},
{\hyperref[gpu/drm\string-kms:c.drm_atomic_get_plane_state]{\emph{\code{drm\_atomic\_get\_plane\_state()}}}}, {\hyperref[gpu/drm\string-kms:c.drm_atomic_get_connector_state]{\emph{\code{drm\_atomic\_get\_connector\_state()}}}}, or for
private state structures, {\hyperref[gpu/drm\string-kms:c.drm_atomic_get_private_obj_state]{\emph{\code{drm\_atomic\_get\_private\_obj\_state()}}}}.
\index{drm\_crtc\_commit\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_commit_get}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_commit]{\emph{drm\_crtc\_commit}}} * \bfcode{drm\_crtc\_commit\_get}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_commit]{\emph{drm\_crtc\_commit}}} *\emph{ commit}}{}
acquire a reference to the CRTC commit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc\_commit * commit}}] \leavevmode
CRTC commit

\end{description}

\textbf{Description}

Increases the reference of \textbf{commit}.

\textbf{Return}

The pointer to \textbf{commit}, with reference increased.
\index{drm\_crtc\_commit\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_commit_put}\pysiglinewithargsret{void \bfcode{drm\_crtc\_commit\_put}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_commit]{\emph{drm\_crtc\_commit}}} *\emph{ commit}}{}
release a reference to the CRTC commmit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc\_commit * commit}}] \leavevmode
CRTC commit

\end{description}

\textbf{Description}

This releases a reference to \textbf{commit} which is freed after removing the
final reference. No locking required and callable from any context.
\index{drm\_atomic\_state\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_state_get}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} * \bfcode{drm\_atomic\_state\_get}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
acquire a reference to the atomic state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
The atomic state

\end{description}

\textbf{Description}

Returns a new reference to the \textbf{state}
\index{drm\_atomic\_state\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_state_put}\pysiglinewithargsret{void \bfcode{drm\_atomic\_state\_put}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
release a reference to the atomic state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
The atomic state

\end{description}

\textbf{Description}

This releases a reference to \textbf{state} which is freed after removing the
final reference. No locking required and callable from any context.
\index{drm\_atomic\_get\_existing\_crtc\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_get_existing_crtc_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{drm\_crtc\_state}}} * \bfcode{drm\_atomic\_get\_existing\_crtc\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
get crtc state, if it exists

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
global atomic state object

\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
crtc to grab

\end{description}

\textbf{Description}

This function returns the crtc state for the given crtc, or NULL
if the crtc is not part of the global atomic state.

This function is deprecated, \textbf{drm\_atomic\_get\_old\_crtc\_state} or
\textbf{drm\_atomic\_get\_new\_crtc\_state} should be used instead.
\index{drm\_atomic\_get\_old\_crtc\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_get_old_crtc_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{drm\_crtc\_state}}} * \bfcode{drm\_atomic\_get\_old\_crtc\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
get old crtc state, if it exists

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
global atomic state object

\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
crtc to grab

\end{description}

\textbf{Description}

This function returns the old crtc state for the given crtc, or
NULL if the crtc is not part of the global atomic state.
\index{drm\_atomic\_get\_new\_crtc\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_get_new_crtc_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{drm\_crtc\_state}}} * \bfcode{drm\_atomic\_get\_new\_crtc\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
get new crtc state, if it exists

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
global atomic state object

\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
crtc to grab

\end{description}

\textbf{Description}

This function returns the new crtc state for the given crtc, or
NULL if the crtc is not part of the global atomic state.
\index{drm\_atomic\_get\_existing\_plane\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_get_existing_plane_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} * \bfcode{drm\_atomic\_get\_existing\_plane\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}}{}
get plane state, if it exists

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
global atomic state object

\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane to grab

\end{description}

\textbf{Description}

This function returns the plane state for the given plane, or NULL
if the plane is not part of the global atomic state.

This function is deprecated, \textbf{drm\_atomic\_get\_old\_plane\_state} or
\textbf{drm\_atomic\_get\_new\_plane\_state} should be used instead.
\index{drm\_atomic\_get\_old\_plane\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_get_old_plane_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} * \bfcode{drm\_atomic\_get\_old\_plane\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}}{}
get plane state, if it exists

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
global atomic state object

\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane to grab

\end{description}

\textbf{Description}

This function returns the old plane state for the given plane, or
NULL if the plane is not part of the global atomic state.
\index{drm\_atomic\_get\_new\_plane\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_get_new_plane_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} * \bfcode{drm\_atomic\_get\_new\_plane\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}}{}
get plane state, if it exists

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
global atomic state object

\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane to grab

\end{description}

\textbf{Description}

This function returns the new plane state for the given plane, or
NULL if the plane is not part of the global atomic state.
\index{drm\_atomic\_get\_existing\_connector\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_get_existing_connector_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{drm\_connector\_state}}} * \bfcode{drm\_atomic\_get\_existing\_connector\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
get connector state, if it exists

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
global atomic state object

\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector to grab

\end{description}

\textbf{Description}

This function returns the connector state for the given connector,
or NULL if the connector is not part of the global atomic state.

This function is deprecated, \textbf{drm\_atomic\_get\_old\_connector\_state} or
\textbf{drm\_atomic\_get\_new\_connector\_state} should be used instead.
\index{drm\_atomic\_get\_old\_connector\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_get_old_connector_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{drm\_connector\_state}}} * \bfcode{drm\_atomic\_get\_old\_connector\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
get connector state, if it exists

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
global atomic state object

\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector to grab

\end{description}

\textbf{Description}

This function returns the old connector state for the given connector,
or NULL if the connector is not part of the global atomic state.
\index{drm\_atomic\_get\_new\_connector\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_get_new_connector_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{drm\_connector\_state}}} * \bfcode{drm\_atomic\_get\_new\_connector\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
get connector state, if it exists

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
global atomic state object

\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector to grab

\end{description}

\textbf{Description}

This function returns the new connector state for the given connector,
or NULL if the connector is not part of the global atomic state.
\index{\_\_drm\_atomic\_get\_current\_plane\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.__drm_atomic_get_current_plane_state}\pysiglinewithargsret{const struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} * \bfcode{\_\_drm\_atomic\_get\_current\_plane\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}}{}
get current plane state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
global atomic state object

\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane to grab

\end{description}

\textbf{Description}

This function returns the plane state for the given plane, either from
\textbf{state}, or if the plane isn't part of the atomic state update, from \textbf{plane}.
This is useful in atomic check callbacks, when drivers need to peek at, but
not change, state of other planes, since it avoids threading an error code
back up the call chain.

WARNING:

Note that this function is in general unsafe since it doesn't check for the
required locking for access state structures. Drivers must ensure that it is
safe to access the returned state structure through other means. One common
example is when planes are fixed to a single CRTC, and the driver knows that
the CRTC lock is held already. In that case holding the CRTC lock gives a
read-lock on all planes connected to that CRTC. But if planes can be
reassigned things get more tricky. In that case it's better to use
drm\_atomic\_get\_plane\_state and wire up full error handling.

\textbf{Return}

Read-only pointer to the current plane state.
\index{for\_each\_oldnew\_connector\_in\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.for_each_oldnew_connector_in_state}\pysiglinewithargsret{\bfcode{for\_each\_oldnew\_connector\_in\_state}}{\emph{\_\_state}, \emph{connector}, \emph{old\_connector\_state}, \emph{new\_connector\_state}, \emph{\_\_i}}{}
iterate over all connectors in an atomic update

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{struct drm\_atomic\_state}}}} pointer

\item[{\code{connector}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{struct drm\_connector}}}} iteration cursor

\item[{\code{old\_connector\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{\code{struct drm\_connector\_state}}}} iteration cursor for the
old state

\item[{\code{new\_connector\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{\code{struct drm\_connector\_state}}}} iteration cursor for the
new state

\item[{\code{\_\_i}}] \leavevmode
int iteration cursor, for macro-internal use

\end{description}

\textbf{Description}

This iterates over all connectors in an atomic update, tracking both old and
new state. This is useful in places where the state delta needs to be
considered, for example in atomic check functions.
\index{for\_each\_old\_connector\_in\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.for_each_old_connector_in_state}\pysiglinewithargsret{\bfcode{for\_each\_old\_connector\_in\_state}}{\emph{\_\_state}, \emph{connector}, \emph{old\_connector\_state}, \emph{\_\_i}}{}
iterate over all connectors in an atomic update

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{struct drm\_atomic\_state}}}} pointer

\item[{\code{connector}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{struct drm\_connector}}}} iteration cursor

\item[{\code{old\_connector\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{\code{struct drm\_connector\_state}}}} iteration cursor for the
old state

\item[{\code{\_\_i}}] \leavevmode
int iteration cursor, for macro-internal use

\end{description}

\textbf{Description}

This iterates over all connectors in an atomic update, tracking only the old
state. This is useful in disable functions, where we need the old state the
hardware is still in.
\index{for\_each\_new\_connector\_in\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.for_each_new_connector_in_state}\pysiglinewithargsret{\bfcode{for\_each\_new\_connector\_in\_state}}{\emph{\_\_state}, \emph{connector}, \emph{new\_connector\_state}, \emph{\_\_i}}{}
iterate over all connectors in an atomic update

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{struct drm\_atomic\_state}}}} pointer

\item[{\code{connector}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{struct drm\_connector}}}} iteration cursor

\item[{\code{new\_connector\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{\code{struct drm\_connector\_state}}}} iteration cursor for the
new state

\item[{\code{\_\_i}}] \leavevmode
int iteration cursor, for macro-internal use

\end{description}

\textbf{Description}

This iterates over all connectors in an atomic update, tracking only the new
state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.
\index{for\_each\_oldnew\_crtc\_in\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.for_each_oldnew_crtc_in_state}\pysiglinewithargsret{\bfcode{for\_each\_oldnew\_crtc\_in\_state}}{\emph{\_\_state}, \emph{crtc}, \emph{old\_crtc\_state}, \emph{new\_crtc\_state}, \emph{\_\_i}}{}
iterate over all CRTCs in an atomic update

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{struct drm\_atomic\_state}}}} pointer

\item[{\code{crtc}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{struct drm\_crtc}}}} iteration cursor

\item[{\code{old\_crtc\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{struct drm\_crtc\_state}}}} iteration cursor for the old state

\item[{\code{new\_crtc\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{struct drm\_crtc\_state}}}} iteration cursor for the new state

\item[{\code{\_\_i}}] \leavevmode
int iteration cursor, for macro-internal use

\end{description}

\textbf{Description}

This iterates over all CRTCs in an atomic update, tracking both old and
new state. This is useful in places where the state delta needs to be
considered, for example in atomic check functions.
\index{for\_each\_old\_crtc\_in\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.for_each_old_crtc_in_state}\pysiglinewithargsret{\bfcode{for\_each\_old\_crtc\_in\_state}}{\emph{\_\_state}, \emph{crtc}, \emph{old\_crtc\_state}, \emph{\_\_i}}{}
iterate over all CRTCs in an atomic update

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{struct drm\_atomic\_state}}}} pointer

\item[{\code{crtc}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{struct drm\_crtc}}}} iteration cursor

\item[{\code{old\_crtc\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{struct drm\_crtc\_state}}}} iteration cursor for the old state

\item[{\code{\_\_i}}] \leavevmode
int iteration cursor, for macro-internal use

\end{description}

\textbf{Description}

This iterates over all CRTCs in an atomic update, tracking only the old
state. This is useful in disable functions, where we need the old state the
hardware is still in.
\index{for\_each\_new\_crtc\_in\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.for_each_new_crtc_in_state}\pysiglinewithargsret{\bfcode{for\_each\_new\_crtc\_in\_state}}{\emph{\_\_state}, \emph{crtc}, \emph{new\_crtc\_state}, \emph{\_\_i}}{}
iterate over all CRTCs in an atomic update

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{struct drm\_atomic\_state}}}} pointer

\item[{\code{crtc}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{struct drm\_crtc}}}} iteration cursor

\item[{\code{new\_crtc\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{struct drm\_crtc\_state}}}} iteration cursor for the new state

\item[{\code{\_\_i}}] \leavevmode
int iteration cursor, for macro-internal use

\end{description}

\textbf{Description}

This iterates over all CRTCs in an atomic update, tracking only the new
state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.
\index{for\_each\_oldnew\_plane\_in\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.for_each_oldnew_plane_in_state}\pysiglinewithargsret{\bfcode{for\_each\_oldnew\_plane\_in\_state}}{\emph{\_\_state}, \emph{plane}, \emph{old\_plane\_state}, \emph{new\_plane\_state}, \emph{\_\_i}}{}
iterate over all planes in an atomic update

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{struct drm\_atomic\_state}}}} pointer

\item[{\code{plane}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{struct drm\_plane}}}} iteration cursor

\item[{\code{old\_plane\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{struct drm\_plane\_state}}}} iteration cursor for the old state

\item[{\code{new\_plane\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{struct drm\_plane\_state}}}} iteration cursor for the new state

\item[{\code{\_\_i}}] \leavevmode
int iteration cursor, for macro-internal use

\end{description}

\textbf{Description}

This iterates over all planes in an atomic update, tracking both old and
new state. This is useful in places where the state delta needs to be
considered, for example in atomic check functions.
\index{for\_each\_old\_plane\_in\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.for_each_old_plane_in_state}\pysiglinewithargsret{\bfcode{for\_each\_old\_plane\_in\_state}}{\emph{\_\_state}, \emph{plane}, \emph{old\_plane\_state}, \emph{\_\_i}}{}
iterate over all planes in an atomic update

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{struct drm\_atomic\_state}}}} pointer

\item[{\code{plane}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{struct drm\_plane}}}} iteration cursor

\item[{\code{old\_plane\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{struct drm\_plane\_state}}}} iteration cursor for the old state

\item[{\code{\_\_i}}] \leavevmode
int iteration cursor, for macro-internal use

\end{description}

\textbf{Description}

This iterates over all planes in an atomic update, tracking only the old
state. This is useful in disable functions, where we need the old state the
hardware is still in.
\index{for\_each\_new\_plane\_in\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.for_each_new_plane_in_state}\pysiglinewithargsret{\bfcode{for\_each\_new\_plane\_in\_state}}{\emph{\_\_state}, \emph{plane}, \emph{new\_plane\_state}, \emph{\_\_i}}{}
iterate over all planes in an atomic update

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{struct drm\_atomic\_state}}}} pointer

\item[{\code{plane}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{struct drm\_plane}}}} iteration cursor

\item[{\code{new\_plane\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{struct drm\_plane\_state}}}} iteration cursor for the new state

\item[{\code{\_\_i}}] \leavevmode
int iteration cursor, for macro-internal use

\end{description}

\textbf{Description}

This iterates over all planes in an atomic update, tracking only the new
state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.
\index{for\_each\_oldnew\_private\_obj\_in\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.for_each_oldnew_private_obj_in_state}\pysiglinewithargsret{\bfcode{for\_each\_oldnew\_private\_obj\_in\_state}}{\emph{\_\_state}, \emph{obj}, \emph{old\_obj\_state}, \emph{new\_obj\_state}, \emph{\_\_i}}{}
iterate over all private objects in an atomic update

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{struct drm\_atomic\_state}}}} pointer

\item[{\code{obj}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_private_obj]{\emph{\code{struct drm\_private\_obj}}}} iteration cursor

\item[{\code{old\_obj\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_private_state]{\emph{\code{struct drm\_private\_state}}}} iteration cursor for the old state

\item[{\code{new\_obj\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_private_state]{\emph{\code{struct drm\_private\_state}}}} iteration cursor for the new state

\item[{\code{\_\_i}}] \leavevmode
int iteration cursor, for macro-internal use

\end{description}

\textbf{Description}

This iterates over all private objects in an atomic update, tracking both
old and new state. This is useful in places where the state delta needs
to be considered, for example in atomic check functions.
\index{for\_each\_old\_private\_obj\_in\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.for_each_old_private_obj_in_state}\pysiglinewithargsret{\bfcode{for\_each\_old\_private\_obj\_in\_state}}{\emph{\_\_state}, \emph{obj}, \emph{old\_obj\_state}, \emph{\_\_i}}{}
iterate over all private objects in an atomic update

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{struct drm\_atomic\_state}}}} pointer

\item[{\code{obj}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_private_obj]{\emph{\code{struct drm\_private\_obj}}}} iteration cursor

\item[{\code{old\_obj\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_private_state]{\emph{\code{struct drm\_private\_state}}}} iteration cursor for the old state

\item[{\code{\_\_i}}] \leavevmode
int iteration cursor, for macro-internal use

\end{description}

\textbf{Description}

This iterates over all private objects in an atomic update, tracking only
the old state. This is useful in disable functions, where we need the old
state the hardware is still in.
\index{for\_each\_new\_private\_obj\_in\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.for_each_new_private_obj_in_state}\pysiglinewithargsret{\bfcode{for\_each\_new\_private\_obj\_in\_state}}{\emph{\_\_state}, \emph{obj}, \emph{new\_obj\_state}, \emph{\_\_i}}{}
iterate over all private objects in an atomic update

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{struct drm\_atomic\_state}}}} pointer

\item[{\code{obj}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_private_obj]{\emph{\code{struct drm\_private\_obj}}}} iteration cursor

\item[{\code{new\_obj\_state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_private_state]{\emph{\code{struct drm\_private\_state}}}} iteration cursor for the new state

\item[{\code{\_\_i}}] \leavevmode
int iteration cursor, for macro-internal use

\end{description}

\textbf{Description}

This iterates over all private objects in an atomic update, tracking only
the new state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.
\index{drm\_atomic\_crtc\_needs\_modeset (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_crtc_needs_modeset}\pysiglinewithargsret{bool \bfcode{drm\_atomic\_crtc\_needs\_modeset}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{drm\_crtc\_state}}} *\emph{ state}}{}
compute combined modeset need

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_crtc\_state * state}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state}}}} for the CRTC

\end{description}

\textbf{Description}

To give drivers flexibility {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{struct drm\_crtc\_state}}}} has 3 booleans to track
whether the state CRTC changed enough to need a full modeset cycle:
mode\_changed, active\_changed and connectors\_changed. This helper simply
combines these three to compute the overall need for a modeset for \textbf{state}.

The atomic helper code sets these booleans, but drivers can and should
change them appropriately to accurately represent whether a modeset is
really needed. In general, drivers should avoid full modesets whenever
possible.

For example if the CRTC mode has changed, and the hardware is able to enact
the requested mode change without going through a full modeset, the driver
should clear mode\_changed in its {\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.atomic\_check}}}}
implementation.
\index{drm\_atomic\_state\_default\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_state_default_release}\pysiglinewithargsret{void \bfcode{drm\_atomic\_state\_default\_release}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
release memory initialized by drm\_atomic\_state\_init

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
atomic state

\end{description}

\textbf{Description}

Free all the memory allocated by drm\_atomic\_state\_init.
This should only be used by drivers which are still subclassing
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}} and haven't switched to {\hyperref[gpu/drm\string-kms:c.drm_private_state]{\emph{\code{drm\_private\_state}}}} yet.
\index{drm\_atomic\_state\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_state_init}\pysiglinewithargsret{int \bfcode{drm\_atomic\_state\_init}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
init new atomic state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
atomic state

\end{description}

\textbf{Description}

Default implementation for filling in a new atomic state.
This should only be used by drivers which are still subclassing
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}} and haven't switched to {\hyperref[gpu/drm\string-kms:c.drm_private_state]{\emph{\code{drm\_private\_state}}}} yet.
\index{drm\_atomic\_state\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_state_alloc}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} * \bfcode{drm\_atomic\_state\_alloc}}{struct drm\_device *\emph{ dev}}{}
allocate atomic state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

This allocates an empty atomic state to track updates.
\index{drm\_atomic\_state\_default\_clear (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_state_default_clear}\pysiglinewithargsret{void \bfcode{drm\_atomic\_state\_default\_clear}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
clear base atomic state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
atomic state

\end{description}

\textbf{Description}

Default implementation for clearing atomic state.
This should only be used by drivers which are still subclassing
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}} and haven't switched to {\hyperref[gpu/drm\string-kms:c.drm_private_state]{\emph{\code{drm\_private\_state}}}} yet.
\index{drm\_atomic\_state\_clear (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_state_clear}\pysiglinewithargsret{void \bfcode{drm\_atomic\_state\_clear}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
clear state object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
atomic state

\end{description}

\textbf{Description}

When the w/w mutex algorithm detects a deadlock we need to back off and drop
all locks. So someone else could sneak in and change the current modeset
configuration. Which means that all the state assembled in \textbf{state} is no
longer an atomic update to the current state, but to some arbitrary earlier
state. Which could break assumptions the driver's
{\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.atomic\_check}}}} likely relies on.

Hence we must clear all cached state and completely start over, using this
function.
\index{\_\_drm\_atomic\_state\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.__drm_atomic_state_free}\pysiglinewithargsret{void \bfcode{\_\_drm\_atomic\_state\_free}}{struct kref *\emph{ ref}}{}
free all memory for an atomic state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kref * ref}}] \leavevmode
This atomic state to deallocate

\end{description}

\textbf{Description}

This frees all memory associated with an atomic state, including all the
per-object state for planes, crtcs and connectors.
\index{drm\_atomic\_get\_crtc\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_get_crtc_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{drm\_crtc\_state}}} * \bfcode{drm\_atomic\_get\_crtc\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
get crtc state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
global atomic state object

\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
crtc to get state object for

\end{description}

\textbf{Description}

This function returns the crtc state for the given crtc, allocating it if
needed. It will also grab the relevant crtc lock to make sure that the state
is consistent.

\textbf{Return}

Either the allocated state or the error code encoded into the pointer. When
the error is EDEADLK then the w/w mutex code has detected a deadlock and the
entire atomic sequence must be restarted. All other errors are fatal.
\index{drm\_atomic\_set\_mode\_for\_crtc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_set_mode_for_crtc}\pysiglinewithargsret{int \bfcode{drm\_atomic\_set\_mode\_for\_crtc}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{drm\_crtc\_state}}} *\emph{ state}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
set mode for CRTC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc\_state * state}}] \leavevmode
the CRTC whose incoming state to update

\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
kernel-internal mode to use for the CRTC, or NULL to disable

\end{description}

\textbf{Description}

Set a mode (originating from the kernel) on the desired CRTC state and update
the enable property.

\textbf{Return}

Zero on success, error code on failure. Cannot return -EDEADLK.
\index{drm\_atomic\_set\_mode\_prop\_for\_crtc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_set_mode_prop_for_crtc}\pysiglinewithargsret{int \bfcode{drm\_atomic\_set\_mode\_prop\_for\_crtc}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{drm\_crtc\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_property_blob]{\emph{drm\_property\_blob}}} *\emph{ blob}}{}
set mode for CRTC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc\_state * state}}] \leavevmode
the CRTC whose incoming state to update

\item[{\code{struct drm\_property\_blob * blob}}] \leavevmode
pointer to blob property to use for mode

\end{description}

\textbf{Description}

Set a mode (originating from a blob property) on the desired CRTC state.
This function will take a reference on the blob property for the CRTC state,
and release the reference held on the state's existing mode property, if any
was set.

\textbf{Return}

Zero on success, error code on failure. Cannot return -EDEADLK.
\index{drm\_atomic\_crtc\_set\_property (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_crtc_set_property}\pysiglinewithargsret{int \bfcode{drm\_atomic\_crtc\_set\_property}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{drm\_crtc\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} *\emph{ property}, uint64\_t\emph{ val}}{}
set property on CRTC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
the drm CRTC to set a property on

\item[{\code{struct drm\_crtc\_state * state}}] \leavevmode
the state object to update with the new property value

\item[{\code{struct drm\_property * property}}] \leavevmode
the property to set

\item[{\code{uint64\_t val}}] \leavevmode
the new property value

\end{description}

\textbf{Description}

This function handles generic/core properties and calls out to driver's
{\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.atomic\_set\_property}}}} for driver properties. To ensure
consistent behavior you must call this function rather than the driver hook
directly.

\textbf{Return}

Zero on success, error code on failure
\index{drm\_atomic\_get\_plane\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_get_plane_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} * \bfcode{drm\_atomic\_get\_plane\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}}{}
get plane state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
global atomic state object

\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane to get state object for

\end{description}

\textbf{Description}

This function returns the plane state for the given plane, allocating it if
needed. It will also grab the relevant plane lock to make sure that the state
is consistent.

\textbf{Return}

Either the allocated state or the error code encoded into the pointer. When
the error is EDEADLK then the w/w mutex code has detected a deadlock and the
entire atomic sequence must be restarted. All other errors are fatal.
\index{drm\_atomic\_private\_obj\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_private_obj_init}\pysiglinewithargsret{void \bfcode{drm\_atomic\_private\_obj\_init}}{struct {\hyperref[gpu/drm\string-kms:c.drm_private_obj]{\emph{drm\_private\_obj}}} *\emph{ obj}, struct {\hyperref[gpu/drm\string-kms:c.drm_private_state]{\emph{drm\_private\_state}}} *\emph{ state}, const struct {\hyperref[gpu/drm\string-kms:c.drm_private_state_funcs]{\emph{drm\_private\_state\_funcs}}} *\emph{ funcs}}{}
initialize private object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_private\_obj * obj}}] \leavevmode
private object

\item[{\code{struct drm\_private\_state * state}}] \leavevmode
initial private object state

\item[{\code{const struct drm\_private\_state\_funcs * funcs}}] \leavevmode
pointer to the struct of function pointers that identify the object
type

\end{description}

\textbf{Description}

Initialize the private object, which can be embedded into any
driver private object that needs its own atomic state.
\index{drm\_atomic\_private\_obj\_fini (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_private_obj_fini}\pysiglinewithargsret{void \bfcode{drm\_atomic\_private\_obj\_fini}}{struct {\hyperref[gpu/drm\string-kms:c.drm_private_obj]{\emph{drm\_private\_obj}}} *\emph{ obj}}{}
finalize private object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_private\_obj * obj}}] \leavevmode
private object

\end{description}

\textbf{Description}

Finalize the private object.
\index{drm\_atomic\_get\_private\_obj\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_get_private_obj_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_private_state]{\emph{drm\_private\_state}}} * \bfcode{drm\_atomic\_get\_private\_obj\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_private_obj]{\emph{drm\_private\_obj}}} *\emph{ obj}}{}
get private object state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
global atomic state

\item[{\code{struct drm\_private\_obj * obj}}] \leavevmode
private object to get the state for

\end{description}

\textbf{Description}

This function returns the private object state for the given private object,
allocating the state if needed. It does not grab any locks as the caller is
expected to care of any required locking.

\textbf{Return}

Either the allocated state or the error code encoded into a pointer.
\index{drm\_atomic\_get\_connector\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_get_connector_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{drm\_connector\_state}}} * \bfcode{drm\_atomic\_get\_connector\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
get connector state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
global atomic state object

\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector to get state object for

\end{description}

\textbf{Description}

This function returns the connector state for the given connector,
allocating it if needed. It will also grab the relevant connector lock to
make sure that the state is consistent.

\textbf{Return}

Either the allocated state or the error code encoded into the pointer. When
the error is EDEADLK then the w/w mutex code has detected a deadlock and the
entire atomic sequence must be restarted. All other errors are fatal.
\index{drm\_atomic\_set\_crtc\_for\_plane (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_set_crtc_for_plane}\pysiglinewithargsret{int \bfcode{drm\_atomic\_set\_crtc\_for\_plane}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} *\emph{ plane\_state}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
set crtc for plane

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane\_state * plane\_state}}] \leavevmode
the plane whose incoming state to update

\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
crtc to use for the plane

\end{description}

\textbf{Description}

Changing the assigned crtc for a plane requires us to grab the lock and state
for the new crtc, as needed. This function takes care of all these details
besides updating the pointer in the state object itself.

\textbf{Return}

0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK
then the w/w mutex code has detected a deadlock and the entire atomic
sequence must be restarted. All other errors are fatal.
\index{drm\_atomic\_set\_fb\_for\_plane (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_set_fb_for_plane}\pysiglinewithargsret{void \bfcode{drm\_atomic\_set\_fb\_for\_plane}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} *\emph{ plane\_state}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}}{}
set framebuffer for plane

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane\_state * plane\_state}}] \leavevmode
atomic state object for the plane

\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
fb to use for the plane

\end{description}

\textbf{Description}

Changing the assigned framebuffer for a plane requires us to grab a reference
to the new fb and drop the reference to the old fb, if there is one. This
function takes care of all these details besides updating the pointer in the
state object itself.
\index{drm\_atomic\_set\_fence\_for\_plane (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_set_fence_for_plane}\pysiglinewithargsret{void \bfcode{drm\_atomic\_set\_fence\_for\_plane}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} *\emph{ plane\_state}, struct dma\_fence *\emph{ fence}}{}
set fence for plane

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane\_state * plane\_state}}] \leavevmode
atomic state object for the plane

\item[{\code{struct dma\_fence * fence}}] \leavevmode
dma\_fence to use for the plane

\end{description}

\textbf{Description}

Helper to setup the plane\_state fence in case it is not set yet.
By using this drivers doesn't need to worry if the user choose
implicit or explicit fencing.

This function will not set the fence to the state if it was set
via explicit fencing interfaces on the atomic ioctl. In that case it will
drop the reference to the fence as we are not storing it anywhere.
Otherwise, if {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{drm\_plane\_state.fence}}}} is not set this function we just set it
with the received implicit fence. In both cases this function consumes a
reference for \textbf{fence}.
\index{drm\_atomic\_set\_crtc\_for\_connector (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_set_crtc_for_connector}\pysiglinewithargsret{int \bfcode{drm\_atomic\_set\_crtc\_for\_connector}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{drm\_connector\_state}}} *\emph{ conn\_state}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
set crtc for connector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector\_state * conn\_state}}] \leavevmode
atomic state object for the connector

\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
crtc to use for the connector

\end{description}

\textbf{Description}

Changing the assigned crtc for a connector requires us to grab the lock and
state for the new crtc, as needed. This function takes care of all these
details besides updating the pointer in the state object itself.

\textbf{Return}

0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK
then the w/w mutex code has detected a deadlock and the entire atomic
sequence must be restarted. All other errors are fatal.
\index{drm\_atomic\_add\_affected\_connectors (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_add_affected_connectors}\pysiglinewithargsret{int \bfcode{drm\_atomic\_add\_affected\_connectors}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
add connectors for crtc

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
atomic state

\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
DRM crtc

\end{description}

\textbf{Description}

This function walks the current configuration and adds all connectors
currently using \textbf{crtc} to the atomic configuration \textbf{state}. Note that this
function must acquire the connection mutex. This can potentially cause
unneeded seralization if the update is just for the planes on one crtc. Hence
drivers and helpers should only call this when really needed (e.g. when a
full modeset needs to happen due to some change).

\textbf{Return}

0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK
then the w/w mutex code has detected a deadlock and the entire atomic
sequence must be restarted. All other errors are fatal.
\index{drm\_atomic\_add\_affected\_planes (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_add_affected_planes}\pysiglinewithargsret{int \bfcode{drm\_atomic\_add\_affected\_planes}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
add planes for crtc

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
atomic state

\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
DRM crtc

\end{description}

\textbf{Description}

This function walks the current configuration and adds all planes
currently used by \textbf{crtc} to the atomic configuration \textbf{state}. This is useful
when an atomic commit also needs to check all currently enabled plane on
\textbf{crtc}, e.g. when changing the mode. It's also useful when re-enabling a CRTC
to avoid special code to force-enable all planes.

Since acquiring a plane state will always also acquire the w/w mutex of the
current CRTC for that plane (if there is any) adding all the plane states for
a CRTC will not reduce parallism of atomic updates.

\textbf{Return}

0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK
then the w/w mutex code has detected a deadlock and the entire atomic
sequence must be restarted. All other errors are fatal.
\index{drm\_atomic\_check\_only (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_check_only}\pysiglinewithargsret{int \bfcode{drm\_atomic\_check\_only}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
check whether a given config would work

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
atomic configuration to check

\end{description}

\textbf{Description}

Note that this function can return -EDEADLK if the driver needed to acquire
more locks but encountered a deadlock. The caller must then do the usual w/w
backoff dance and restart. All other errors are fatal.

\textbf{Return}

0 on success, negative error code on failure.
\index{drm\_atomic\_commit (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_commit}\pysiglinewithargsret{int \bfcode{drm\_atomic\_commit}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
commit configuration atomically

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
atomic configuration to check

\end{description}

\textbf{Description}

Note that this function can return -EDEADLK if the driver needed to acquire
more locks but encountered a deadlock. The caller must then do the usual w/w
backoff dance and restart. All other errors are fatal.

This function will take its own reference on \textbf{state}.
Callers should always release their reference with {\hyperref[gpu/drm\string-kms:c.drm_atomic_state_put]{\emph{\code{drm\_atomic\_state\_put()}}}}.

\textbf{Return}

0 on success, negative error code on failure.
\index{drm\_atomic\_nonblocking\_commit (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_nonblocking_commit}\pysiglinewithargsret{int \bfcode{drm\_atomic\_nonblocking\_commit}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
atomic nonblocking commit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
atomic configuration to check

\end{description}

\textbf{Description}

Note that this function can return -EDEADLK if the driver needed to acquire
more locks but encountered a deadlock. The caller must then do the usual w/w
backoff dance and restart. All other errors are fatal.

This function will take its own reference on \textbf{state}.
Callers should always release their reference with {\hyperref[gpu/drm\string-kms:c.drm_atomic_state_put]{\emph{\code{drm\_atomic\_state\_put()}}}}.

\textbf{Return}

0 on success, negative error code on failure.
\index{drm\_state\_dump (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_state_dump}\pysiglinewithargsret{void \bfcode{drm\_state\_dump}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_printer]{\emph{drm\_printer}}} *\emph{ p}}{}
dump entire device atomic state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
the drm device

\item[{\code{struct drm\_printer * p}}] \leavevmode
where to print the state to

\end{description}

\textbf{Description}

Just for debugging.  Drivers might want an option to dump state
to dmesg in case of error irq's.  (Hint, you probably want to
ratelimit this!)

The caller must {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock_all]{\emph{\code{drm\_modeset\_lock\_all()}}}}, or if this is called
from error irq handler, it should not be enabled by default.
(Ie. if you are debugging errors you might not care that this
is racey.  But calling this without all modeset locks held is
not inherently safe.)
\index{drm\_atomic\_clean\_old\_fb (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_clean_old_fb}\pysiglinewithargsret{void \bfcode{drm\_atomic\_clean\_old\_fb}}{struct drm\_device *\emph{ dev}, unsigned\emph{ plane\_mask}, int\emph{ ret}}{}~\begin{itemize}
\item {} 
Unset old\_fb pointers and set plane-\textgreater{}fb pointers.

\end{itemize}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device to check.

\item[{\code{unsigned plane\_mask}}] \leavevmode
plane mask for planes that were updated.

\item[{\code{int ret}}] \leavevmode
return value, can be -EDEADLK for a retry.

\end{description}

\textbf{Description}

Before doing an update {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{drm\_plane.old\_fb}}}} is set to {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{drm\_plane.fb}}}}, but before
dropping the locks old\_fb needs to be set to NULL and plane-\textgreater{}fb updated. This
is a common operation for each atomic update, so this call is split off as a
helper.


\section{CRTC Abstraction}
\label{gpu/drm-kms:crtc-abstraction}
A CRTC represents the overall display pipeline. It receives pixel data from
{\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{drm\_plane}}}} and blends them together. The {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{\code{drm\_display\_mode}}}} is also attached
to the CRTC, specifying display timings. On the output side the data is fed
to one or more {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{\code{drm\_encoder}}}}, which are then each connected to one
{\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector}}}}.

To create a CRTC, a KMS drivers allocates and zeroes an instances of
{\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{struct drm\_crtc}}}} (possibly as part of a larger structure) and registers it
with a call to {\hyperref[gpu/drm\string-kms:c.drm_crtc_init_with_planes]{\emph{\code{drm\_crtc\_init\_with\_planes()}}}}.

The CRTC is also the entry point for legacy modeset operations, see
{\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.set\_config}}}}, legacy plane operations, see
{\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.page\_flip}}}} and {\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.cursor\_set2}}}}, and other legacy
operations like {\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.gamma\_set}}}}. For atomic drivers all these
features are controlled through {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{\code{drm\_property}}}} and
{\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.atomic\_check}}}} and {\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.atomic\_check}}}}.


\subsection{CRTC Functions Reference}
\label{gpu/drm-kms:crtc-functions-reference}\index{drm\_crtc\_state (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_state}\pysigline{struct \bfcode{drm\_crtc\_state}}
mutable CRTC state

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}crtc\PYGZus{}state \PYGZob{}
  struct drm\PYGZus{}crtc *crtc;
  bool enable;
  bool active;
  bool planes\PYGZus{}changed : 1;
  bool mode\PYGZus{}changed : 1;
  bool active\PYGZus{}changed : 1;
  bool connectors\PYGZus{}changed : 1;
  bool zpos\PYGZus{}changed : 1;
  bool color\PYGZus{}mgmt\PYGZus{}changed : 1;
  u32 plane\PYGZus{}mask;
  u32 connector\PYGZus{}mask;
  u32 encoder\PYGZus{}mask;
  struct drm\PYGZus{}display\PYGZus{}mode adjusted\PYGZus{}mode;
  struct drm\PYGZus{}display\PYGZus{}mode mode;
  struct drm\PYGZus{}property\PYGZus{}blob *mode\PYGZus{}blob;
  struct drm\PYGZus{}property\PYGZus{}blob *degamma\PYGZus{}lut;
  struct drm\PYGZus{}property\PYGZus{}blob *ctm;
  struct drm\PYGZus{}property\PYGZus{}blob *gamma\PYGZus{}lut;
  u32 target\PYGZus{}vblank;
  u32 pageflip\PYGZus{}flags;
  struct drm\PYGZus{}pending\PYGZus{}vblank\PYGZus{}event *event;
  struct drm\PYGZus{}crtc\PYGZus{}commit *commit;
  struct drm\PYGZus{}atomic\PYGZus{}state *state;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{crtc}}] \leavevmode
backpointer to the CRTC

\item[{\code{enable}}] \leavevmode
whether the CRTC should be enabled, gates all other state

\item[{\code{active}}] \leavevmode
whether the CRTC is actively displaying (used for DPMS)

\item[{\code{planes\_changed}}] \leavevmode
planes on this crtc are updated

\item[{\code{mode\_changed}}] \leavevmode
\textbf{mode} or \textbf{enable} has been changed

\item[{\code{active\_changed}}] \leavevmode
\textbf{active} has been toggled.

\item[{\code{connectors\_changed}}] \leavevmode
connectors to this crtc have been updated

\item[{\code{zpos\_changed}}] \leavevmode
zpos values of planes on this crtc have been updated

\item[{\code{color\_mgmt\_changed}}] \leavevmode
color management properties have changed (degamma or
gamma LUT or CSC matrix)

\item[{\code{plane\_mask}}] \leavevmode
bitmask of (1 \textless{}\textless{} drm\_plane\_index(plane)) of attached planes

\item[{\code{connector\_mask}}] \leavevmode
bitmask of (1 \textless{}\textless{} drm\_connector\_index(connector)) of attached connectors

\item[{\code{encoder\_mask}}] \leavevmode
bitmask of (1 \textless{}\textless{} drm\_encoder\_index(encoder)) of attached encoders

\item[{\code{adjusted\_mode}}] \leavevmode
Internal display timings which can be used by the driver to handle
differences between the mode requested by userspace in \textbf{mode} and what
is actually programmed into the hardware. It is purely driver
implementation defined what exactly this adjusted mode means. Usually
it is used to store the hardware display timings used between the
CRTC and encoder blocks.

\item[{\code{mode}}] \leavevmode
Display timings requested by userspace. The driver should try to
match the refresh rate as close as possible (but note that it's
undefined what exactly is close enough, e.g. some of the HDMI modes
only differ in less than 1\% of the refresh rate). The active width
and height as observed by userspace for positioning planes must match
exactly.

For external connectors where the sink isn't fixed (like with a
built-in panel), this mode here should match the physical mode on the
wire to the last details (i.e. including sync polarities and
everything).

\item[{\code{mode\_blob}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_property_blob]{\emph{\code{drm\_property\_blob}}}} for \textbf{mode}

\item[{\code{degamma\_lut}}] \leavevmode
Lookup table for converting framebuffer pixel data before apply the
color conversion matrix \textbf{ctm}. See {\hyperref[gpu/drm\string-kms:c.drm_crtc_enable_color_mgmt]{\emph{\code{drm\_crtc\_enable\_color\_mgmt()}}}}. The
blob (if not NULL) is an array of \code{struct drm\_color\_lut}.

\item[{\code{ctm}}] \leavevmode
Color transformation matrix. See {\hyperref[gpu/drm\string-kms:c.drm_crtc_enable_color_mgmt]{\emph{\code{drm\_crtc\_enable\_color\_mgmt()}}}}. The
blob (if not NULL) is a \code{struct drm\_color\_ctm}.

\item[{\code{gamma\_lut}}] \leavevmode
Lookup table for converting pixel data after the color conversion
matrix \textbf{ctm}.  See {\hyperref[gpu/drm\string-kms:c.drm_crtc_enable_color_mgmt]{\emph{\code{drm\_crtc\_enable\_color\_mgmt()}}}}. The blob (if not
NULL) is an array of \code{struct drm\_color\_lut}.

\item[{\code{target\_vblank}}] \leavevmode
Target vertical blank period when a page flip
should take effect.

\item[{\code{pageflip\_flags}}] \leavevmode
DRM\_MODE\_PAGE\_FLIP\_* flags, as passed to the page flip ioctl.
Zero in any other case.

\item[{\code{event}}] \leavevmode
Optional pointer to a DRM event to signal upon completion of the
state update. The driver must send out the event when the atomic
commit operation completes. There are two cases:
\begin{itemize}
\item {} 
The event is for a CRTC which is being disabled through this
atomic commit. In that case the event can be send out any time
after the hardware has stopped scanning out the current
framebuffers. It should contain the timestamp and counter for the
last vblank before the display pipeline was shut off. The simplest
way to achieve that is calling {\hyperref[gpu/drm\string-kms:c.drm_crtc_send_vblank_event]{\emph{\code{drm\_crtc\_send\_vblank\_event()}}}}
somewhen after {\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_off]{\emph{\code{drm\_crtc\_vblank\_off()}}}} has been called.

\item {} 
For a CRTC which is enabled at the end of the commit (even when it
undergoes an full modeset) the vblank timestamp and counter must
be for the vblank right before the first frame that scans out the
new set of buffers. Again the event can only be sent out after the
hardware has stopped scanning out the old buffers.

\item {} 
Events for disabled CRTCs are not allowed, and drivers can ignore
that case.

\end{itemize}

This can be handled by the {\hyperref[gpu/drm\string-kms:c.drm_crtc_send_vblank_event]{\emph{\code{drm\_crtc\_send\_vblank\_event()}}}} function,
which the driver should call on the provided event upon completion of
the atomic commit. Note that if the driver supports vblank signalling
and timestamping the vblank counters and timestamps must agree with
the ones returned from page flip events. With the current vblank
helper infrastructure this can be achieved by holding a vblank
reference while the page flip is pending, acquired through
{\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_get]{\emph{\code{drm\_crtc\_vblank\_get()}}}} and released with {\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_put]{\emph{\code{drm\_crtc\_vblank\_put()}}}}.
Drivers are free to implement their own vblank counter and timestamp
tracking though, e.g. if they have accurate timestamp registers in
hardware.

For hardware which supports some means to synchronize vblank
interrupt delivery with committing display state there's also
{\hyperref[gpu/drm\string-kms:c.drm_crtc_arm_vblank_event]{\emph{\code{drm\_crtc\_arm\_vblank\_event()}}}}. See the documentation of that function
for a detailed discussion of the constraints it needs to be used
safely.

If the device can't notify of flip completion in a race-free way
at all, then the event should be armed just after the page flip is
committed. In the worst case the driver will send the event to
userspace one frame too late. This doesn't allow for a real atomic
update, but it should avoid tearing.

\item[{\code{commit}}] \leavevmode
This tracks how the commit for this update proceeds through the
various phases. This is never cleared, except when we destroy the
state, so that subsequent commits can synchronize with previous ones.

\item[{\code{state}}] \leavevmode
backpointer to global drm\_atomic\_state

\end{description}

\textbf{Description}

Note that the distinction between \textbf{enable} and \textbf{active} is rather subtile:
Flipping \textbf{active} while \textbf{enable} is set without changing anything else may
never return in a failure from the {\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.atomic\_check}}}}
callback. Userspace assumes that a DPMS On will always succeed. In other
words: \textbf{enable} controls resource assignment, \textbf{active} controls the actual
hardware state.

The three booleans active\_changed, connectors\_changed and mode\_changed are
intended to indicate whether a full modeset is needed, rather than strictly
describing what has changed in a commit.
See also: {\hyperref[gpu/drm\string-kms:c.drm_atomic_crtc_needs_modeset]{\emph{\code{drm\_atomic\_crtc\_needs\_modeset()}}}}
\index{drm\_crtc\_funcs (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_funcs}\pysigline{struct \bfcode{drm\_crtc\_funcs}}
control CRTCs for a given device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}crtc\PYGZus{}funcs \PYGZob{}
  void (*reset)(struct drm\PYGZus{}crtc *crtc);
  int (*cursor\PYGZus{}set)(struct drm\PYGZus{}crtc *crtc, struct drm\PYGZus{}file *file\PYGZus{}priv, uint32\PYGZus{}t handle, uint32\PYGZus{}t width, uint32\PYGZus{}t height);
  int (*cursor\PYGZus{}set2)(struct drm\PYGZus{}crtc *crtc, struct drm\PYGZus{}file *file\PYGZus{}priv,uint32\PYGZus{}t handle, uint32\PYGZus{}t width, uint32\PYGZus{}t height, int32\PYGZus{}t hot\PYGZus{}x, int32\PYGZus{}t hot\PYGZus{}y);
  int (*cursor\PYGZus{}move)(struct drm\PYGZus{}crtc *crtc, int x, int y);
  int (*gamma\PYGZus{}set)(struct drm\PYGZus{}crtc *crtc, u16 *r, u16 *g, u16 *b,uint32\PYGZus{}t size, struct drm\PYGZus{}modeset\PYGZus{}acquire\PYGZus{}ctx *ctx);
  void (*destroy)(struct drm\PYGZus{}crtc *crtc);
  int (*set\PYGZus{}config)(struct drm\PYGZus{}mode\PYGZus{}set *set, struct drm\PYGZus{}modeset\PYGZus{}acquire\PYGZus{}ctx *ctx);
  int (*page\PYGZus{}flip)(struct drm\PYGZus{}crtc *crtc,struct drm\PYGZus{}framebuffer *fb,struct drm\PYGZus{}pending\PYGZus{}vblank\PYGZus{}event *event,uint32\PYGZus{}t flags, struct drm\PYGZus{}modeset\PYGZus{}acquire\PYGZus{}ctx *ctx);
  int (*page\PYGZus{}flip\PYGZus{}target)(struct drm\PYGZus{}crtc *crtc,struct drm\PYGZus{}framebuffer *fb,struct drm\PYGZus{}pending\PYGZus{}vblank\PYGZus{}event *event,uint32\PYGZus{}t flags, uint32\PYGZus{}t target, struct drm\PYGZus{}modeset\PYGZus{}acquire\PYGZus{}ctx *ctx);
  int (*set\PYGZus{}property)(struct drm\PYGZus{}crtc *crtc, struct drm\PYGZus{}property *property, uint64\PYGZus{}t val);
  struct drm\PYGZus{}crtc\PYGZus{}state *(*atomic\PYGZus{}duplicate\PYGZus{}state)(struct drm\PYGZus{}crtc *crtc);
  void (*atomic\PYGZus{}destroy\PYGZus{}state)(struct drm\PYGZus{}crtc *crtc, struct drm\PYGZus{}crtc\PYGZus{}state *state);
  int (*atomic\PYGZus{}set\PYGZus{}property)(struct drm\PYGZus{}crtc *crtc,struct drm\PYGZus{}crtc\PYGZus{}state *state,struct drm\PYGZus{}property *property, uint64\PYGZus{}t val);
  int (*atomic\PYGZus{}get\PYGZus{}property)(struct drm\PYGZus{}crtc *crtc,const struct drm\PYGZus{}crtc\PYGZus{}state *state,struct drm\PYGZus{}property *property, uint64\PYGZus{}t *val);
  int (*late\PYGZus{}register)(struct drm\PYGZus{}crtc *crtc);
  void (*early\PYGZus{}unregister)(struct drm\PYGZus{}crtc *crtc);
  int (*set\PYGZus{}crc\PYGZus{}source)(struct drm\PYGZus{}crtc *crtc, const char *source, size\PYGZus{}t *values\PYGZus{}cnt);
  void (*atomic\PYGZus{}print\PYGZus{}state)(struct drm\PYGZus{}printer *p, const struct drm\PYGZus{}crtc\PYGZus{}state *state);
  u32 (*get\PYGZus{}vblank\PYGZus{}counter)(struct drm\PYGZus{}crtc *crtc);
  int (*enable\PYGZus{}vblank)(struct drm\PYGZus{}crtc *crtc);
  void (*disable\PYGZus{}vblank)(struct drm\PYGZus{}crtc *crtc);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{reset}}] \leavevmode
Reset CRTC hardware and software state to off. This function isn't
called by the core directly, only through {\hyperref[gpu/drm\string-kms:c.drm_mode_config_reset]{\emph{\code{drm\_mode\_config\_reset()}}}}.
It's not a helper hook only for historical reasons.

Atomic drivers can use {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_crtc_reset]{\emph{\code{drm\_atomic\_helper\_crtc\_reset()}}}} to reset
atomic state using this hook.

\item[{\code{cursor\_set}}] \leavevmode
Update the cursor image. The cursor position is relative to the CRTC
and can be partially or fully outside of the visible area.

Note that contrary to all other KMS functions the legacy cursor entry
points don't take a framebuffer object, but instead take directly a
raw buffer object id from the driver's buffer manager (which is
either GEM or TTM for current drivers).

This entry point is deprecated, drivers should instead implement
universal plane support and register a proper cursor plane using
{\hyperref[gpu/drm\string-kms:c.drm_crtc_init_with_planes]{\emph{\code{drm\_crtc\_init\_with\_planes()}}}}.

This callback is optional

RETURNS:

0 on success or a negative error code on failure.

\item[{\code{cursor\_set2}}] \leavevmode
Update the cursor image, including hotspot information. The hotspot
must not affect the cursor position in CRTC coordinates, but is only
meant as a hint for virtualized display hardware to coordinate the
guests and hosts cursor position. The cursor hotspot is relative to
the cursor image. Otherwise this works exactly like \textbf{cursor\_set}.

This entry point is deprecated, drivers should instead implement
universal plane support and register a proper cursor plane using
{\hyperref[gpu/drm\string-kms:c.drm_crtc_init_with_planes]{\emph{\code{drm\_crtc\_init\_with\_planes()}}}}.

This callback is optional.

RETURNS:

0 on success or a negative error code on failure.

\item[{\code{cursor\_move}}] \leavevmode
Update the cursor position. The cursor does not need to be visible
when this hook is called.

This entry point is deprecated, drivers should instead implement
universal plane support and register a proper cursor plane using
{\hyperref[gpu/drm\string-kms:c.drm_crtc_init_with_planes]{\emph{\code{drm\_crtc\_init\_with\_planes()}}}}.

This callback is optional.

RETURNS:

0 on success or a negative error code on failure.

\item[{\code{gamma\_set}}] \leavevmode
Set gamma on the CRTC.

This callback is optional.

Atomic drivers who want to support gamma tables should implement the
atomic color management support, enabled by calling
{\hyperref[gpu/drm\string-kms:c.drm_crtc_enable_color_mgmt]{\emph{\code{drm\_crtc\_enable\_color\_mgmt()}}}}, which then supports the legacy gamma
interface through the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_legacy_gamma_set]{\emph{\code{drm\_atomic\_helper\_legacy\_gamma\_set()}}}}
compatibility implementation.

\item[{\code{destroy}}] \leavevmode
Clean up plane resources. This is only called at driver unload time
through {\hyperref[gpu/drm\string-kms:c.drm_mode_config_cleanup]{\emph{\code{drm\_mode\_config\_cleanup()}}}} since a CRTC cannot be hotplugged
in DRM.

\item[{\code{set\_config}}] \leavevmode
This is the main legacy entry point to change the modeset state on a
CRTC. All the details of the desired configuration are passed in a
{\hyperref[gpu/drm\string-kms:c.drm_mode_set]{\emph{\code{struct drm\_mode\_set}}}} - see there for details.

Drivers implementing atomic modeset should use
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_set_config]{\emph{\code{drm\_atomic\_helper\_set\_config()}}}} to implement this hook.

RETURNS:

0 on success or a negative error code on failure.

\item[{\code{page\_flip}}] \leavevmode
Legacy entry point to schedule a flip to the given framebuffer.

Page flipping is a synchronization mechanism that replaces the frame
buffer being scanned out by the CRTC with a new frame buffer during
vertical blanking, avoiding tearing (except when requested otherwise
through the DRM\_MODE\_PAGE\_FLIP\_ASYNC flag). When an application
requests a page flip the DRM core verifies that the new frame buffer
is large enough to be scanned out by the CRTC in the currently
configured mode and then calls this hook with a pointer to the new
frame buffer.

The driver must wait for any pending rendering to the new framebuffer
to complete before executing the flip. It should also wait for any
pending rendering from other drivers if the underlying buffer is a
shared dma-buf.

An application can request to be notified when the page flip has
completed. The drm core will supply a \code{struct drm\_event} in the event
parameter in this case. This can be handled by the
{\hyperref[gpu/drm\string-kms:c.drm_crtc_send_vblank_event]{\emph{\code{drm\_crtc\_send\_vblank\_event()}}}} function, which the driver should call on
the provided event upon completion of the flip. Note that if
the driver supports vblank signalling and timestamping the vblank
counters and timestamps must agree with the ones returned from page
flip events. With the current vblank helper infrastructure this can
be achieved by holding a vblank reference while the page flip is
pending, acquired through {\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_get]{\emph{\code{drm\_crtc\_vblank\_get()}}}} and released with
{\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_put]{\emph{\code{drm\_crtc\_vblank\_put()}}}}. Drivers are free to implement their own vblank
counter and timestamp tracking though, e.g. if they have accurate
timestamp registers in hardware.

This callback is optional.

NOTE:

Very early versions of the KMS ABI mandated that the driver must
block (but not reject) any rendering to the old framebuffer until the
flip operation has completed and the old framebuffer is no longer
visible. This requirement has been lifted, and userspace is instead
expected to request delivery of an event and wait with recycling old
buffers until such has been received.

RETURNS:

0 on success or a negative error code on failure. Note that if a
page flip operation is already pending the callback should return
-EBUSY. Pageflips on a disabled CRTC (either by setting a NULL mode
or just runtime disabled through DPMS respectively the new atomic
``ACTIVE'' state) should result in an -EINVAL error code. Note that
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_page_flip]{\emph{\code{drm\_atomic\_helper\_page\_flip()}}}} checks this already for atomic drivers.

\item[{\code{page\_flip\_target}}] \leavevmode
Same as \textbf{page\_flip} but with an additional parameter specifying the
absolute target vertical blank period (as reported by
{\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_count]{\emph{\code{drm\_crtc\_vblank\_count()}}}}) when the flip should take effect.

Note that the core code calls drm\_crtc\_vblank\_get before this entry
point, and will call drm\_crtc\_vblank\_put if this entry point returns
any non-0 error code. It's the driver's responsibility to call
drm\_crtc\_vblank\_put after this entry point returns 0, typically when
the flip completes.

\item[{\code{set\_property}}] \leavevmode
This is the legacy entry point to update a property attached to the
CRTC.

This callback is optional if the driver does not support any legacy
driver-private properties. For atomic drivers it is not used because
property handling is done entirely in the DRM core.

RETURNS:

0 on success or a negative error code on failure.

\item[{\code{atomic\_duplicate\_state}}] \leavevmode
Duplicate the current atomic state for this CRTC and return it.
The core and helpers guarantee that any atomic state duplicated with
this hook and still owned by the caller (i.e. not transferred to the
driver by calling {\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.atomic\_commit}}}}) will be
cleaned up by calling the \textbf{atomic\_destroy\_state} hook in this
structure.

Atomic drivers which don't subclass {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{struct drm\_crtc\_state}}}} should use
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_crtc_duplicate_state]{\emph{\code{drm\_atomic\_helper\_crtc\_duplicate\_state()}}}}. Drivers that subclass the
state structure to extend it with driver-private state should use
{\hyperref[gpu/drm\string-kms\string-helpers:c.__drm_atomic_helper_crtc_duplicate_state]{\emph{\code{\_\_drm\_atomic\_helper\_crtc\_duplicate\_state()}}}} to make sure shared state is
duplicated in a consistent fashion across drivers.

It is an error to call this hook before {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc.state}}}} has been
initialized correctly.

NOTE:

If the duplicate state references refcounted resources this hook must
acquire a reference for each of them. The driver must release these
references again in \textbf{atomic\_destroy\_state}.

RETURNS:

Duplicated atomic state or NULL when the allocation failed.

\item[{\code{atomic\_destroy\_state}}] \leavevmode
Destroy a state duplicated with \textbf{atomic\_duplicate\_state} and release
or unreference all resources it references

\item[{\code{atomic\_set\_property}}] \leavevmode
Decode a driver-private property value and store the decoded value
into the passed-in state structure. Since the atomic core decodes all
standardized properties (even for extensions beyond the core set of
properties which might not be implemented by all drivers) this
requires drivers to subclass the state structure.

Such driver-private properties should really only be implemented for
truly hardware/vendor specific state. Instead it is preferred to
standardize atomic extension and decode the properties used to expose
such an extension in the core.

Do not call this function directly, use
{\hyperref[gpu/drm\string-kms:c.drm_atomic_crtc_set_property]{\emph{\code{drm\_atomic\_crtc\_set\_property()}}}} instead.

This callback is optional if the driver does not support any
driver-private atomic properties.

NOTE:

This function is called in the state assembly phase of atomic
modesets, which can be aborted for any reason (including on
userspace's request to just check whether a configuration would be
possible). Drivers MUST NOT touch any persistent state (hardware or
software) or data structures except the passed in \textbf{state} parameter.

Also since userspace controls in which order properties are set this
function must not do any input validation (since the state update is
incomplete and hence likely inconsistent). Instead any such input
validation must be done in the various atomic\_check callbacks.

RETURNS:

0 if the property has been found, -EINVAL if the property isn't
implemented by the driver (which should never happen, the core only
asks for properties attached to this CRTC). No other validation is
allowed by the driver. The core already checks that the property
value is within the range (integer, valid enum value, ...) the driver
set when registering the property.

\item[{\code{atomic\_get\_property}}] \leavevmode
Reads out the decoded driver-private property. This is used to
implement the GETCRTC IOCTL.

Do not call this function directly, use
\code{drm\_atomic\_crtc\_get\_property()} instead.

This callback is optional if the driver does not support any
driver-private atomic properties.

RETURNS:

0 on success, -EINVAL if the property isn't implemented by the
driver (which should never happen, the core only asks for
properties attached to this CRTC).

\item[{\code{late\_register}}] \leavevmode
This optional hook can be used to register additional userspace
interfaces attached to the crtc like debugfs interfaces.
It is called late in the driver load sequence from {\hyperref[gpu/drm\string-internals:c.drm_dev_register]{\emph{\code{drm\_dev\_register()}}}}.
Everything added from this callback should be unregistered in
the early\_unregister callback.

Returns:

0 on success, or a negative error code on failure.

\item[{\code{early\_unregister}}] \leavevmode
This optional hook should be used to unregister the additional
userspace interfaces attached to the crtc from
\textbf{late\_register}. It is called from {\hyperref[gpu/drm\string-internals:c.drm_dev_unregister]{\emph{\code{drm\_dev\_unregister()}}}},
early in the driver unload sequence to disable userspace access
before data structures are torndown.

\item[{\code{set\_crc\_source}}] \leavevmode
Changes the source of CRC checksums of frames at the request of
userspace, typically for testing purposes. The sources available are
specific of each driver and a \code{NULL} value indicates that CRC
generation is to be switched off.

When CRC generation is enabled, the driver should call
{\hyperref[gpu/drm\string-uapi:c.drm_crtc_add_crc_entry]{\emph{\code{drm\_crtc\_add\_crc\_entry()}}}} at each frame, providing any information
that characterizes the frame contents in the crcN arguments, as
provided from the configured source. Drivers must accept an ``auto''
source name that will select a default source for this CRTC.

Note that ``auto'' can depend upon the current modeset configuration,
e.g. it could pick an encoder or output specific CRC sampling point.

This callback is optional if the driver does not support any CRC
generation functionality.

RETURNS:

0 on success or a negative error code on failure.

\item[{\code{atomic\_print\_state}}] \leavevmode
If driver subclasses {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{struct drm\_crtc\_state}}}}, it should implement
this optional hook for printing additional driver specific state.

Do not call this directly, use \code{drm\_atomic\_crtc\_print\_state()}
instead.

\item[{\code{get\_vblank\_counter}}] \leavevmode
Driver callback for fetching a raw hardware vblank counter for the
CRTC. It's meant to be used by new drivers as the replacement of
{\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.get\_vblank\_counter}}}} hook.

This callback is optional. If a device doesn't have a hardware
counter, the driver can simply leave the hook as NULL. The DRM core
will account for missed vblank events while interrupts where disabled
based on system timestamps.

Wraparound handling and loss of events due to modesetting is dealt
with in the DRM core code, as long as drivers call
{\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_off]{\emph{\code{drm\_crtc\_vblank\_off()}}}} and {\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_on]{\emph{\code{drm\_crtc\_vblank\_on()}}}} when disabling or
enabling a CRTC.

See also \code{drm\_device.vblank\_disable\_immediate} and
\code{drm\_device.max\_vblank\_count}.

Returns:

Raw vblank counter value.

\item[{\code{enable\_vblank}}] \leavevmode
Enable vblank interrupts for the CRTC. It's meant to be used by
new drivers as the replacement of {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.enable\_vblank}}}} hook.

Returns:

Zero on success, appropriate errno if the vblank interrupt cannot
be enabled.

\item[{\code{disable\_vblank}}] \leavevmode
Disable vblank interrupts for the CRTC. It's meant to be used by
new drivers as the replacement of {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.disable\_vblank}}}} hook.

\end{description}

\textbf{Description}

The drm\_crtc\_funcs structure is the central CRTC management structure
in the DRM.  Each CRTC controls one or more connectors (note that the name
CRTC is simply historical, a CRTC may control LVDS, VGA, DVI, TV out, etc.
connectors, not just CRTs).

Each driver is responsible for filling out this structure at startup time,
in addition to providing other modesetting features, like i2c and DDC
bus accessors.
\index{drm\_crtc (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc}\pysigline{struct \bfcode{drm\_crtc}}
central CRTC control structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}crtc \PYGZob{}
  struct drm\PYGZus{}device *dev;
  struct device\PYGZus{}node *port;
  struct list\PYGZus{}head head;
  char *name;
  struct drm\PYGZus{}modeset\PYGZus{}lock mutex;
  struct drm\PYGZus{}mode\PYGZus{}object base;
  struct drm\PYGZus{}plane *primary;
  struct drm\PYGZus{}plane *cursor;
  unsigned index;
  int cursor\PYGZus{}x;
  int cursor\PYGZus{}y;
  bool enabled;
  struct drm\PYGZus{}display\PYGZus{}mode mode;
  struct drm\PYGZus{}display\PYGZus{}mode hwmode;
  int x, y;
  const struct drm\PYGZus{}crtc\PYGZus{}funcs *funcs;
  uint32\PYGZus{}t gamma\PYGZus{}size;
  uint16\PYGZus{}t *gamma\PYGZus{}store;
  const struct drm\PYGZus{}crtc\PYGZus{}helper\PYGZus{}funcs *helper\PYGZus{}private;
  struct drm\PYGZus{}object\PYGZus{}properties properties;
  struct drm\PYGZus{}crtc\PYGZus{}state *state;
  struct list\PYGZus{}head commit\PYGZus{}list;
  spinlock\PYGZus{}t commit\PYGZus{}lock;
\PYGZsh{}ifdef CONFIG\PYGZus{}DEBUG\PYGZus{}FS;
  struct dentry *debugfs\PYGZus{}entry;
\PYGZsh{}endif;
  struct drm\PYGZus{}crtc\PYGZus{}crc crc;
  unsigned int fence\PYGZus{}context;
  spinlock\PYGZus{}t fence\PYGZus{}lock;
  unsigned long fence\PYGZus{}seqno;
  char timeline\PYGZus{}name[32];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev}}] \leavevmode
parent DRM device

\item[{\code{port}}] \leavevmode
OF node used by \code{drm\_of\_find\_possible\_crtcs()}

\item[{\code{head}}] \leavevmode
list management

\item[{\code{name}}] \leavevmode
human readable name, can be overwritten by the driver

\item[{\code{mutex}}] \leavevmode
This provides a read lock for the overall CRTC state (mode, dpms
state, ...) and a write lock for everything which can be update
without a full modeset (fb, cursor data, CRTC properties ...). A full
modeset also need to grab {\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.connection\_mutex}}}}.

For atomic drivers specifically this protects \textbf{state}.

\item[{\code{base}}] \leavevmode
base KMS object for ID tracking etc.

\item[{\code{primary}}] \leavevmode
primary plane for this CRTC

\item[{\code{cursor}}] \leavevmode
cursor plane for this CRTC

\item[{\code{index}}] \leavevmode
Position inside the mode\_config.list, can be used as an array
index. It is invariant over the lifetime of the CRTC.

\item[{\code{cursor\_x}}] \leavevmode
current x position of the cursor, used for universal cursor planes

\item[{\code{cursor\_y}}] \leavevmode
current y position of the cursor, used for universal cursor planes

\item[{\code{enabled}}] \leavevmode
is this CRTC enabled?

\item[{\code{mode}}] \leavevmode
current mode timings

\item[{\code{hwmode}}] \leavevmode
mode timings as programmed to hw regs

\item[{\code{x}}] \leavevmode
x position on screen

\item[{\code{y}}] \leavevmode
y position on screen

\item[{\code{funcs}}] \leavevmode
CRTC control functions

\item[{\code{gamma\_size}}] \leavevmode
size of gamma ramp

\item[{\code{gamma\_store}}] \leavevmode
gamma ramp values

\item[{\code{helper\_private}}] \leavevmode
mid-layer private data

\item[{\code{properties}}] \leavevmode
property tracking for this CRTC

\item[{\code{state}}] \leavevmode
Current atomic state for this CRTC.

This is protected by \textbf{mutex}. Note that nonblocking atomic commits
access the current CRTC state without taking locks. Either by going
through the {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{struct drm\_atomic\_state}}}} pointers, see
{\hyperref[gpu/drm\string-kms:c.for_each_oldnew_crtc_in_state]{\emph{\code{for\_each\_oldnew\_crtc\_in\_state()}}}}, {\hyperref[gpu/drm\string-kms:c.for_each_old_crtc_in_state]{\emph{\code{for\_each\_old\_crtc\_in\_state()}}}} and
{\hyperref[gpu/drm\string-kms:c.for_each_new_crtc_in_state]{\emph{\code{for\_each\_new\_crtc\_in\_state()}}}}. Or through careful ordering of atomic
commit operations as implemented in the atomic helpers, see
{\hyperref[gpu/drm\string-kms:c.drm_crtc_commit]{\emph{\code{struct drm\_crtc\_commit}}}}.

\item[{\code{commit\_list}}] \leavevmode
List of {\hyperref[gpu/drm\string-kms:c.drm_crtc_commit]{\emph{\code{drm\_crtc\_commit}}}} structures tracking pending commits.
Protected by \textbf{commit\_lock}. This list holds its own full reference,
as does the ongoing commit.

``Note that the commit for a state change is also tracked in
{\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.commit}}}}. For accessing the immediately preceding
commit in an atomic update it is recommended to just use that
pointer in the old CRTC state, since accessing that doesn't need
any locking or list-walking. \textbf{commit\_list} should only be used to
stall for framebuffer cleanup that's signalled through
{\hyperref[gpu/drm\string-kms:c.drm_crtc_commit]{\emph{\code{drm\_crtc\_commit.cleanup\_done}}}}.''

\item[{\code{commit\_lock}}] \leavevmode
Spinlock to protect \textbf{commit\_list}.

\item[{\code{debugfs\_entry}}] \leavevmode
Debugfs directory for this CRTC.

\item[{\code{crc}}] \leavevmode
Configuration settings of CRC capture.

\item[{\code{fence\_context}}] \leavevmode
timeline context used for fence operations.

\item[{\code{fence\_lock}}] \leavevmode
spinlock to protect the fences in the fence\_context.

\item[{\code{fence\_seqno}}] \leavevmode
Seqno variable used as monotonic counter for the fences
created on the CRTC's timeline.

\item[{\code{timeline\_name}}] \leavevmode
The name of the CRTC's fence timeline.

\end{description}

\textbf{Description}

Each CRTC may have one or more connectors associated with it.  This structure
allows the CRTC to be controlled.
\index{drm\_mode\_set (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_set}\pysigline{struct \bfcode{drm\_mode\_set}}
new values for a CRTC config change

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}mode\PYGZus{}set \PYGZob{}
  struct drm\PYGZus{}framebuffer *fb;
  struct drm\PYGZus{}crtc *crtc;
  struct drm\PYGZus{}display\PYGZus{}mode *mode;
  uint32\PYGZus{}t x;
  uint32\PYGZus{}t y;
  struct drm\PYGZus{}connector **connectors;
  size\PYGZus{}t num\PYGZus{}connectors;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{fb}}] \leavevmode
framebuffer to use for new config

\item[{\code{crtc}}] \leavevmode
CRTC whose configuration we're about to change

\item[{\code{mode}}] \leavevmode
mode timings to use

\item[{\code{x}}] \leavevmode
position of this CRTC relative to \textbf{fb}

\item[{\code{y}}] \leavevmode
position of this CRTC relative to \textbf{fb}

\item[{\code{connectors}}] \leavevmode
array of connectors to drive with this CRTC if possible

\item[{\code{num\_connectors}}] \leavevmode
size of \textbf{connectors} array

\end{description}

\textbf{Description}

This represents a modeset configuration for the legacy SETCRTC ioctl and is
also used internally. Atomic drivers instead use {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}}.
\index{drm\_crtc\_index (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_index}\pysiglinewithargsret{unsigned int \bfcode{drm\_crtc\_index}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
find the index of a registered CRTC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_crtc * crtc}}] \leavevmode
CRTC to find index for

\end{description}

\textbf{Description}

Given a registered CRTC, return the index of that CRTC within a DRM
device's list of CRTCs.
\index{drm\_crtc\_mask (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_mask}\pysiglinewithargsret{uint32\_t \bfcode{drm\_crtc\_mask}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
find the mask of a registered CRTC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_crtc * crtc}}] \leavevmode
CRTC to find mask for

\end{description}

\textbf{Description}

Given a registered CRTC, return the mask bit of that CRTC for an
encoder's possible\_crtcs field.
\index{drm\_crtc\_find (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_find}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} * \bfcode{drm\_crtc\_find}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}, uint32\_t\emph{ id}}{}
look up a CRTC object from its ID

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
drm file to check for lease against.

\item[{\code{uint32\_t id}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_mode_object]{\emph{\code{drm\_mode\_object}}}} ID

\end{description}

\textbf{Description}

This can be used to look up a CRTC from its userspace ID. Only used by
drivers for legacy IOCTLs and interface, nowadays extensions to the KMS
userspace interface should be done using {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{\code{drm\_property}}}}.
\index{drm\_for\_each\_crtc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_for_each_crtc}\pysiglinewithargsret{\bfcode{drm\_for\_each\_crtc}}{\emph{crtc}, \emph{dev}}{}
iterate over all CRTCs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{crtc}}] \leavevmode
a {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{struct drm\_crtc}}}} as the loop cursor

\item[{\code{dev}}] \leavevmode
the \code{struct drm\_device}

\end{description}

\textbf{Description}

Iterate over all CRTCs of \textbf{dev}.
\index{drm\_crtc\_from\_index (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_from_index}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} * \bfcode{drm\_crtc\_from\_index}}{struct drm\_device *\emph{ dev}, int\emph{ idx}}{}
find the registered CRTC at an index

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{int idx}}] \leavevmode
index of registered CRTC to find for

\end{description}

\textbf{Description}

Given a CRTC index, return the registered CRTC from DRM device's
list of CRTCs with matching index. This is the inverse of {\hyperref[gpu/drm\string-kms:c.drm_crtc_index]{\emph{\code{drm\_crtc\_index()}}}}.
It's useful in the vblank callbacks (like {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.enable\_vblank}}}} or
{\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.disable\_vblank}}}}), since that still deals with indices instead
of pointers to {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{struct drm\_crtc}}}}.''
\index{drm\_crtc\_force\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_force_disable}\pysiglinewithargsret{int \bfcode{drm\_crtc\_force\_disable}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
Forcibly turn off a CRTC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
CRTC to turn off

\end{description}

\textbf{Note}

This should only be used by non-atomic legacy drivers.

\textbf{Return}

Zero on success, error code on failure.
\index{drm\_crtc\_force\_disable\_all (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_force_disable_all}\pysiglinewithargsret{int \bfcode{drm\_crtc\_force\_disable\_all}}{struct drm\_device *\emph{ dev}}{}
Forcibly turn off all enabled CRTCs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device whose CRTCs to turn off

\end{description}

\textbf{Description}

Drivers may want to call this on unload to ensure that all displays are
unlit and the GPU is in a consistent, low power state. Takes modeset locks.

\textbf{Note}

This should only be used by non-atomic legacy drivers. For an atomic
version look at {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_shutdown]{\emph{\code{drm\_atomic\_helper\_shutdown()}}}}.

\textbf{Return}

Zero on success, error code on failure.
\index{drm\_crtc\_init\_with\_planes (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_init_with_planes}\pysiglinewithargsret{int \bfcode{drm\_crtc\_init\_with\_planes}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ primary}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ cursor}, const struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{drm\_crtc\_funcs}}} *\emph{ funcs}, const char *\emph{ name}, ...}{}
Initialise a new CRTC object with specified primary and cursor planes.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
CRTC object to init

\item[{\code{struct drm\_plane * primary}}] \leavevmode
Primary plane for CRTC

\item[{\code{struct drm\_plane * cursor}}] \leavevmode
Cursor plane for CRTC

\item[{\code{const struct drm\_crtc\_funcs * funcs}}] \leavevmode
callbacks for the new CRTC

\item[{\code{const char * name}}] \leavevmode
printf style format string for the CRTC name, or NULL for default name

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

Inits a new object created as base part of a driver crtc object. Drivers
should use this function instead of {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_init]{\emph{\code{drm\_crtc\_init()}}}}, which is only provided
for backwards compatibility with drivers which do not yet support universal
planes). For really simple hardware which has only 1 plane look at
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe_init]{\emph{\code{drm\_simple\_display\_pipe\_init()}}}} instead.

\textbf{Return}

Zero on success, error code on failure.
\index{drm\_crtc\_cleanup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_cleanup}\pysiglinewithargsret{void \bfcode{drm\_crtc\_cleanup}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
Clean up the core crtc usage

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
CRTC to cleanup

\end{description}

\textbf{Description}

This function cleans up \textbf{crtc} and removes it from the DRM mode setting
core. Note that the function does \emph{not} free the crtc structure itself,
this is the responsibility of the caller.
\index{drm\_mode\_set\_config\_internal (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_set_config_internal}\pysiglinewithargsret{int \bfcode{drm\_mode\_set\_config\_internal}}{struct {\hyperref[gpu/drm\string-kms:c.drm_mode_set]{\emph{drm\_mode\_set}}} *\emph{ set}}{}
helper to call {\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.set\_config}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mode\_set * set}}] \leavevmode
modeset config to set

\end{description}

\textbf{Description}

This is a little helper to wrap internal calls to the
{\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.set\_config}}}} driver interface. The only thing it adds is
correct refcounting dance.

This should only be used by non-atomic legacy drivers.

\textbf{Return}

Zero on success, negative errno on failure.
\index{drm\_crtc\_check\_viewport (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_check_viewport}\pysiglinewithargsret{int \bfcode{drm\_crtc\_check\_viewport}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, int\emph{ x}, int\emph{ y}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}, const struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}}{}
Checks that a framebuffer is big enough for the CRTC viewport

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_crtc * crtc}}] \leavevmode
CRTC that framebuffer will be displayed on

\item[{\code{int x}}] \leavevmode
x panning

\item[{\code{int y}}] \leavevmode
y panning

\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
mode that framebuffer will be displayed under

\item[{\code{const struct drm\_framebuffer * fb}}] \leavevmode
framebuffer to check size of

\end{description}


\section{Frame Buffer Abstraction}
\label{gpu/drm-kms:frame-buffer-abstraction}
Frame buffers are abstract memory objects that provide a source of pixels to
scanout to a CRTC. Applications explicitly request the creation of frame
buffers through the DRM\_IOCTL\_MODE\_ADDFB(2) ioctls and receive an opaque
handle that can be passed to the KMS CRTC control, plane configuration and
page flip functions.

Frame buffers rely on the underlying memory manager for allocating backing
storage. When creating a frame buffer applications pass a memory handle
(or a list of memory handles for multi-planar formats) through the
\code{struct drm\_mode\_fb\_cmd2} argument. For drivers using GEM as their userspace
buffer management interface this would be a GEM handle.  Drivers are however
free to use their own backing storage object handles, e.g. vmwgfx directly
exposes special TTM handles to userspace and so expects TTM handles in the
create ioctl and not GEM handles.

Framebuffers are tracked with {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{struct drm\_framebuffer}}}}. They are published
using {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_init]{\emph{\code{drm\_framebuffer\_init()}}}} - after calling that function userspace can use
and access the framebuffer object. The helper function
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_helper_mode_fill_fb_struct]{\emph{\code{drm\_helper\_mode\_fill\_fb\_struct()}}}} can be used to pre-fill the required
metadata fields.

The lifetime of a drm framebuffer is controlled with a reference count,
drivers can grab additional references with {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_get]{\emph{\code{drm\_framebuffer\_get()}}}} and drop
them again with {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_put]{\emph{\code{drm\_framebuffer\_put()}}}}. For driver-private framebuffers for
which the last reference is never dropped (e.g. for the fbdev framebuffer
when the struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{struct drm\_framebuffer}}}} is embedded into the fbdev helper
struct) drivers can manually clean up a framebuffer at module unload time
with {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_unregister_private]{\emph{\code{drm\_framebuffer\_unregister\_private()}}}}. But doing this is not
recommended, and it's better to have a normal free-standing {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{struct
drm\_framebuffer}}}}.


\subsection{Frame Buffer Functions Reference}
\label{gpu/drm-kms:frame-buffer-functions-reference}\index{drm\_framebuffer\_funcs (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_framebuffer_funcs}\pysigline{struct \bfcode{drm\_framebuffer\_funcs}}
framebuffer hooks

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}framebuffer\PYGZus{}funcs \PYGZob{}
  void (*destroy)(struct drm\PYGZus{}framebuffer *framebuffer);
  int (*create\PYGZus{}handle)(struct drm\PYGZus{}framebuffer *fb,struct drm\PYGZus{}file *file\PYGZus{}priv, unsigned int *handle);
  int (*dirty)(struct drm\PYGZus{}framebuffer *framebuffer,struct drm\PYGZus{}file *file\PYGZus{}priv, unsigned flags,unsigned color, struct drm\PYGZus{}clip\PYGZus{}rect *clips, unsigned num\PYGZus{}clips);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{destroy}}] \leavevmode
Clean up framebuffer resources, specifically also unreference the
backing storage. The core guarantees to call this function for every
framebuffer successfully created by calling
{\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.fb\_create}}}}. Drivers must also call
{\hyperref[gpu/drm\string-kms:c.drm_framebuffer_cleanup]{\emph{\code{drm\_framebuffer\_cleanup()}}}} to release DRM core resources for this
framebuffer.

\item[{\code{create\_handle}}] \leavevmode
Create a buffer handle in the driver-specific buffer manager (either
GEM or TTM) valid for the passed-in {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{struct drm\_file}}}}. This is used by
the core to implement the GETFB IOCTL, which returns (for
sufficiently priviledged user) also a native buffer handle. This can
be used for seamless transitions between modesetting clients by
copying the current screen contents to a private buffer and blending
between that and the new contents.

GEM based drivers should call {\hyperref[gpu/drm\string-mm:c.drm_gem_handle_create]{\emph{\code{drm\_gem\_handle\_create()}}}} to create the
handle.

RETURNS:

0 on success or a negative error code on failure.

\item[{\code{dirty}}] \leavevmode
Optional callback for the dirty fb IOCTL.

Userspace can notify the driver via this callback that an area of the
framebuffer has changed and should be flushed to the display
hardware. This can also be used internally, e.g. by the fbdev
emulation, though that's not the case currently.

See documentation in drm\_mode.h for the struct drm\_mode\_fb\_dirty\_cmd
for more information as all the semantics and arguments have a one to
one mapping on this function.

RETURNS:

0 on success or a negative error code on failure.

\end{description}
\index{drm\_framebuffer (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_framebuffer}\pysigline{struct \bfcode{drm\_framebuffer}}
frame buffer object

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}framebuffer \PYGZob{}
  struct drm\PYGZus{}device *dev;
  struct list\PYGZus{}head head;
  struct drm\PYGZus{}mode\PYGZus{}object base;
  char comm[TASK\PYGZus{}COMM\PYGZus{}LEN];
  const struct drm\PYGZus{}format\PYGZus{}info *format;
  const struct drm\PYGZus{}framebuffer\PYGZus{}funcs *funcs;
  unsigned int pitches[4];
  unsigned int offsets[4];
  uint64\PYGZus{}t modifier;
  unsigned int width;
  unsigned int height;
  int flags;
  int hot\PYGZus{}x;
  int hot\PYGZus{}y;
  struct list\PYGZus{}head filp\PYGZus{}head;
  struct drm\PYGZus{}gem\PYGZus{}object *obj[4];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev}}] \leavevmode
DRM device this framebuffer belongs to

\item[{\code{head}}] \leavevmode
Place on the {\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.fb\_list}}}}, access protected by
{\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.fb\_lock}}}}.

\item[{\code{base}}] \leavevmode
base modeset object structure, contains the reference count.

\item[{\code{comm}}] \leavevmode
Name of the process allocating the fb, used for fb dumping.

\item[{\code{format}}] \leavevmode
framebuffer format information

\item[{\code{funcs}}] \leavevmode
framebuffer vfunc table

\item[{\code{pitches}}] \leavevmode
Line stride per buffer. For userspace created object this
is copied from drm\_mode\_fb\_cmd2.

\item[{\code{offsets}}] \leavevmode
Offset from buffer start to the actual pixel data in bytes,
per buffer. For userspace created object this is copied from
drm\_mode\_fb\_cmd2.

Note that this is a linear offset and does not take into account
tiling or buffer laytou per \textbf{modifier}. It meant to be used when the
actual pixel data for this framebuffer plane starts at an offset,
e.g.  when multiple planes are allocated within the same backing
storage buffer object. For tiled layouts this generally means it
\textbf{offsets} must at least be tile-size aligned, but hardware often has
stricter requirements.

This should not be used to specifiy x/y pixel offsets into the buffer
data (even for linear buffers). Specifying an x/y pixel offset is
instead done through the source rectangle in {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{struct drm\_plane\_state}}}}.

\item[{\code{modifier}}] \leavevmode
Data layout modifier. This is used to describe
tiling, or also special layouts (like compression) of auxiliary
buffers. For userspace created object this is copied from
drm\_mode\_fb\_cmd2.

\item[{\code{width}}] \leavevmode
Logical width of the visible area of the framebuffer, in
pixels.

\item[{\code{height}}] \leavevmode
Logical height of the visible area of the framebuffer, in
pixels.

\item[{\code{flags}}] \leavevmode
Framebuffer flags like DRM\_MODE\_FB\_INTERLACED or
DRM\_MODE\_FB\_MODIFIERS.

\item[{\code{hot\_x}}] \leavevmode
X coordinate of the cursor hotspot. Used by the legacy cursor
IOCTL when the driver supports cursor through a DRM\_PLANE\_TYPE\_CURSOR
universal plane.

\item[{\code{hot\_y}}] \leavevmode
Y coordinate of the cursor hotspot. Used by the legacy cursor
IOCTL when the driver supports cursor through a DRM\_PLANE\_TYPE\_CURSOR
universal plane.

\item[{\code{filp\_head}}] \leavevmode
Placed on {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{drm\_file.fbs}}}}, protected by {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{drm\_file.fbs\_lock}}}}.

\item[{\code{obj}}] \leavevmode
GEM objects backing the framebuffer, one per plane (optional).

This is used by the GEM framebuffer helpers, see e.g.
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_gem_fb_create]{\emph{\code{drm\_gem\_fb\_create()}}}}.

\end{description}

\textbf{Description}

Note that the fb is refcounted for the benefit of driver internals,
for example some hw, disabling a CRTC/plane is asynchronous, and
scanout does not actually complete until the next vblank.  So some
cleanup (like releasing the reference(s) on the backing GEM bo(s))
should be deferred.  In cases like this, the driver would like to
hold a ref to the fb even though it has already been removed from
userspace perspective. See {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_get]{\emph{\code{drm\_framebuffer\_get()}}}} and
{\hyperref[gpu/drm\string-kms:c.drm_framebuffer_put]{\emph{\code{drm\_framebuffer\_put()}}}}.

The refcount is stored inside the mode object \textbf{base}.
\index{drm\_framebuffer\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_framebuffer_get}\pysiglinewithargsret{void \bfcode{drm\_framebuffer\_get}}{struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}}{}
acquire a framebuffer reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
DRM framebuffer

\end{description}

\textbf{Description}

This function increments the framebuffer's reference count.
\index{drm\_framebuffer\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_framebuffer_put}\pysiglinewithargsret{void \bfcode{drm\_framebuffer\_put}}{struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}}{}
release a framebuffer reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
DRM framebuffer

\end{description}

\textbf{Description}

This function decrements the framebuffer's reference count and frees the
framebuffer if the reference count drops to zero.
\index{drm\_framebuffer\_reference (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_framebuffer_reference}\pysiglinewithargsret{void \bfcode{drm\_framebuffer\_reference}}{struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}}{}
acquire a framebuffer reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
DRM framebuffer

\end{description}

\textbf{Description}

This is a compatibility alias for {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_get]{\emph{\code{drm\_framebuffer\_get()}}}} and should not be
used by new code.
\index{drm\_framebuffer\_unreference (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_framebuffer_unreference}\pysiglinewithargsret{void \bfcode{drm\_framebuffer\_unreference}}{struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}}{}
release a framebuffer reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
DRM framebuffer

\end{description}

\textbf{Description}

This is a compatibility alias for {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_put]{\emph{\code{drm\_framebuffer\_put()}}}} and should not be
used by new code.
\index{drm\_framebuffer\_read\_refcount (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_framebuffer_read_refcount}\pysiglinewithargsret{uint32\_t \bfcode{drm\_framebuffer\_read\_refcount}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}}{}
read the framebuffer reference count.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_framebuffer * fb}}] \leavevmode
framebuffer

\end{description}

\textbf{Description}

This functions returns the framebuffer's reference count.
\index{drm\_framebuffer\_assign (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_framebuffer_assign}\pysiglinewithargsret{void \bfcode{drm\_framebuffer\_assign}}{struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} **\emph{ p}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}}{}
store a reference to the fb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_framebuffer ** p}}] \leavevmode
location to store framebuffer

\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
new framebuffer (maybe NULL)

\end{description}

\textbf{Description}

This functions sets the location to store a reference to the framebuffer,
unreferencing the framebuffer that was previously stored in that location.
\index{drm\_framebuffer\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_framebuffer_init}\pysiglinewithargsret{int \bfcode{drm\_framebuffer\_init}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, const struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_funcs]{\emph{drm\_framebuffer\_funcs}}} *\emph{ funcs}}{}
initialize a framebuffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
framebuffer to be initialized

\item[{\code{const struct drm\_framebuffer\_funcs * funcs}}] \leavevmode
... with these functions

\end{description}

\textbf{Description}

Allocates an ID for the framebuffer's parent mode object, sets its mode
functions \& device file and adds it to the master fd list.

IMPORTANT:
This functions publishes the fb and makes it available for concurrent access
by other users. Which means by this point the fb \_must\_ be fully set up -
since all the fb attributes are invariant over its lifetime, no further
locking but only correct reference counting is required.

\textbf{Return}

Zero on success, error code on failure.
\index{drm\_framebuffer\_lookup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_framebuffer_lookup}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} * \bfcode{drm\_framebuffer\_lookup}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}, uint32\_t\emph{ id}}{}
look up a drm framebuffer and grab a reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
drm file to check for lease against.

\item[{\code{uint32\_t id}}] \leavevmode
id of the fb object

\end{description}

\textbf{Description}

If successful, this grabs an additional reference to the framebuffer -
callers need to make sure to eventually unreference the returned framebuffer
again, using {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_put]{\emph{\code{drm\_framebuffer\_put()}}}}.
\index{drm\_framebuffer\_unregister\_private (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_framebuffer_unregister_private}\pysiglinewithargsret{void \bfcode{drm\_framebuffer\_unregister\_private}}{struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}}{}
unregister a private fb from the lookup idr

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
fb to unregister

\end{description}

\textbf{Description}

Drivers need to call this when cleaning up driver-private framebuffers, e.g.
those used for fbdev. Note that the caller must hold a reference of it's own,
i.e. the object may not be destroyed through this call (since it'll lead to a
locking inversion).

\textbf{NOTE}

This function is deprecated. For driver-private framebuffers it is not
recommended to embed a framebuffer struct info fbdev struct, instead, a
framebuffer pointer is preferred and {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_put]{\emph{\code{drm\_framebuffer\_put()}}}} should be called
when the framebuffer is to be cleaned up.
\index{drm\_framebuffer\_cleanup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_framebuffer_cleanup}\pysiglinewithargsret{void \bfcode{drm\_framebuffer\_cleanup}}{struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}}{}
remove a framebuffer object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
framebuffer to remove

\end{description}

\textbf{Description}

Cleanup framebuffer. This function is intended to be used from the drivers
{\hyperref[gpu/drm\string-kms:c.drm_framebuffer_funcs]{\emph{\code{drm\_framebuffer\_funcs.destroy}}}} callback. It can also be used to clean up
driver private framebuffers embedded into a larger structure.

Note that this function does not remove the fb from active usage - if it is
still used anywhere, hilarity can ensue since userspace could call getfb on
the id and get back -EINVAL. Obviously no concern at driver unload time.

Also, the framebuffer will not be removed from the lookup idr - for
user-created framebuffers this will happen in in the rmfb ioctl. For
driver-private objects (e.g. for fbdev) drivers need to explicitly call
drm\_framebuffer\_unregister\_private.
\index{drm\_framebuffer\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_framebuffer_remove}\pysiglinewithargsret{void \bfcode{drm\_framebuffer\_remove}}{struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}}{}
remove and unreference a framebuffer object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
framebuffer to remove

\end{description}

\textbf{Description}

Scans all the CRTCs and planes in \textbf{dev}`s mode\_config.  If they're
using \textbf{fb}, removes it, setting it to NULL. Then drops the reference to the
passed-in framebuffer. Might take the modeset locks.

Note that this function optimizes the cleanup away if the caller holds the
last reference to the framebuffer. It is also guaranteed to not take the
modeset locks in this case.
\index{drm\_framebuffer\_plane\_width (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_framebuffer_plane_width}\pysiglinewithargsret{int \bfcode{drm\_framebuffer\_plane\_width}}{int\emph{ width}, const struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, int\emph{ plane}}{}
width of the plane given the first plane

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int width}}] \leavevmode
width of the first plane

\item[{\code{const struct drm\_framebuffer * fb}}] \leavevmode
the framebuffer

\item[{\code{int plane}}] \leavevmode
plane index

\end{description}

\textbf{Return}

The width of \textbf{plane}, given that the width of the first plane is \textbf{width}.
\index{drm\_framebuffer\_plane\_height (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_framebuffer_plane_height}\pysiglinewithargsret{int \bfcode{drm\_framebuffer\_plane\_height}}{int\emph{ height}, const struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, int\emph{ plane}}{}
height of the plane given the first plane

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int height}}] \leavevmode
height of the first plane

\item[{\code{const struct drm\_framebuffer * fb}}] \leavevmode
the framebuffer

\item[{\code{int plane}}] \leavevmode
plane index

\end{description}

\textbf{Return}

The height of \textbf{plane}, given that the height of the first plane is \textbf{height}.


\section{DRM Format Handling}
\label{gpu/drm-kms:drm-format-handling}\index{drm\_format\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_format_info}\pysigline{struct \bfcode{drm\_format\_info}}
information about a DRM format

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}format\PYGZus{}info \PYGZob{}
  u32 format;
  u8 depth;
  u8 num\PYGZus{}planes;
  u8 cpp[3];
  u8 hsub;
  u8 vsub;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{format}}] \leavevmode
4CC format identifier (DRM\_FORMAT\_*)

\item[{\code{depth}}] \leavevmode
Color depth (number of bits per pixel excluding padding bits),
valid for a subset of RGB formats only. This is a legacy field, do not
use in new code and set to 0 for new formats.

\item[{\code{num\_planes}}] \leavevmode
Number of color planes (1 to 3)

\item[{\code{cpp}}] \leavevmode
Number of bytes per pixel (per plane)

\item[{\code{hsub}}] \leavevmode
Horizontal chroma subsampling factor

\item[{\code{vsub}}] \leavevmode
Vertical chroma subsampling factor

\end{description}
\index{drm\_format\_name\_buf (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_format_name_buf}\pysigline{struct \bfcode{drm\_format\_name\_buf}}
name of a DRM format

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}format\PYGZus{}name\PYGZus{}buf \PYGZob{}
  char str[32];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{str}}] \leavevmode
string buffer containing the format name

\end{description}
\index{drm\_mode\_legacy\_fb\_format (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_legacy_fb_format}\pysiglinewithargsret{uint32\_t \bfcode{drm\_mode\_legacy\_fb\_format}}{uint32\_t\emph{ bpp}, uint32\_t\emph{ depth}}{}
compute drm fourcc code from legacy description

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{uint32\_t bpp}}] \leavevmode
bits per pixels

\item[{\code{uint32\_t depth}}] \leavevmode
bit depth per pixel

\end{description}

\textbf{Description}

Computes a drm fourcc pixel format code for the given \textbf{bpp}/\textbf{depth} values.
Useful in fbdev emulation code, since that deals in those values.
\index{drm\_get\_format\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_get_format_name}\pysiglinewithargsret{const char * \bfcode{drm\_get\_format\_name}}{uint32\_t\emph{ format}, struct {\hyperref[gpu/drm\string-kms:c.drm_format_name_buf]{\emph{drm\_format\_name\_buf}}} *\emph{ buf}}{}
fill a string with a drm fourcc format's name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{uint32\_t format}}] \leavevmode
format to compute name of

\item[{\code{struct drm\_format\_name\_buf * buf}}] \leavevmode
caller-supplied buffer

\end{description}
\index{drm\_format\_info (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{const struct {\hyperref[gpu/drm\string-kms:c.drm_format_info]{\emph{drm\_format\_info}}} * \bfcode{drm\_format\_info}}{u32\emph{ format}}{}
query information for a given format

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u32 format}}] \leavevmode
pixel format (DRM\_FORMAT\_*)

\end{description}

\textbf{Description}

The caller should only pass a supported pixel format to this function.
Unsupported pixel formats will generate a warning in the kernel log.

\textbf{Return}

The instance of struct drm\_format\_info that describes the pixel format, or
NULL if the format is unsupported.
\index{drm\_get\_format\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_get_format_info}\pysiglinewithargsret{const struct {\hyperref[gpu/drm\string-kms:c.drm_format_info]{\emph{drm\_format\_info}}} * \bfcode{drm\_get\_format\_info}}{struct drm\_device *\emph{ dev}, const struct drm\_mode\_fb\_cmd2 *\emph{ mode\_cmd}}{}
query information for a given framebuffer configuration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{const struct drm\_mode\_fb\_cmd2 * mode\_cmd}}] \leavevmode
metadata from the userspace fb creation request

\end{description}

\textbf{Return}

The instance of struct drm\_format\_info that describes the pixel format, or
NULL if the format is unsupported.
\index{drm\_format\_num\_planes (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_format_num_planes}\pysiglinewithargsret{int \bfcode{drm\_format\_num\_planes}}{uint32\_t\emph{ format}}{}
get the number of planes for format

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{uint32\_t format}}] \leavevmode
pixel format (DRM\_FORMAT\_*)

\end{description}

\textbf{Return}

The number of planes used by the specified pixel format.
\index{drm\_format\_plane\_cpp (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_format_plane_cpp}\pysiglinewithargsret{int \bfcode{drm\_format\_plane\_cpp}}{uint32\_t\emph{ format}, int\emph{ plane}}{}
determine the bytes per pixel value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{uint32\_t format}}] \leavevmode
pixel format (DRM\_FORMAT\_*)

\item[{\code{int plane}}] \leavevmode
plane index

\end{description}

\textbf{Return}

The bytes per pixel value for the specified plane.
\index{drm\_format\_horz\_chroma\_subsampling (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_format_horz_chroma_subsampling}\pysiglinewithargsret{int \bfcode{drm\_format\_horz\_chroma\_subsampling}}{uint32\_t\emph{ format}}{}
get the horizontal chroma subsampling factor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{uint32\_t format}}] \leavevmode
pixel format (DRM\_FORMAT\_*)

\end{description}

\textbf{Return}

The horizontal chroma subsampling factor for the
specified pixel format.
\index{drm\_format\_vert\_chroma\_subsampling (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_format_vert_chroma_subsampling}\pysiglinewithargsret{int \bfcode{drm\_format\_vert\_chroma\_subsampling}}{uint32\_t\emph{ format}}{}
get the vertical chroma subsampling factor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{uint32\_t format}}] \leavevmode
pixel format (DRM\_FORMAT\_*)

\end{description}

\textbf{Return}

The vertical chroma subsampling factor for the
specified pixel format.
\index{drm\_format\_plane\_width (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_format_plane_width}\pysiglinewithargsret{int \bfcode{drm\_format\_plane\_width}}{int\emph{ width}, uint32\_t\emph{ format}, int\emph{ plane}}{}
width of the plane given the first plane

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int width}}] \leavevmode
width of the first plane

\item[{\code{uint32\_t format}}] \leavevmode
pixel format

\item[{\code{int plane}}] \leavevmode
plane index

\end{description}

\textbf{Return}

The width of \textbf{plane}, given that the width of the first plane is \textbf{width}.
\index{drm\_format\_plane\_height (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_format_plane_height}\pysiglinewithargsret{int \bfcode{drm\_format\_plane\_height}}{int\emph{ height}, uint32\_t\emph{ format}, int\emph{ plane}}{}
height of the plane given the first plane

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int height}}] \leavevmode
height of the first plane

\item[{\code{uint32\_t format}}] \leavevmode
pixel format

\item[{\code{int plane}}] \leavevmode
plane index

\end{description}

\textbf{Return}

The height of \textbf{plane}, given that the height of the first plane is \textbf{height}.


\section{Dumb Buffer Objects}
\label{gpu/drm-kms:dumb-buffer-objects}
The KMS API doesn't standardize backing storage object creation and leaves it
to driver-specific ioctls. Furthermore actually creating a buffer object even
for GEM-based drivers is done through a driver-specific ioctl - GEM only has
a common userspace interface for sharing and destroying objects. While not an
issue for full-fledged graphics stacks that include device-specific userspace
components (in libdrm for instance), this limit makes DRM-based early boot
graphics unnecessarily complex.

Dumb objects partly alleviate the problem by providing a standard API to
create dumb buffers suitable for scanout, which can then be used to create
KMS frame buffers.

To support dumb objects drivers must implement the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.dumb\_create}}}}
operation. {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.dumb\_destroy}}}} defaults to {\hyperref[gpu/drm\string-mm:c.drm_gem_dumb_destroy]{\emph{\code{drm\_gem\_dumb\_destroy()}}}} if
not set and {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.dumb\_map\_offset}}}} defaults to
{\hyperref[gpu/drm\string-mm:c.drm_gem_dumb_map_offset]{\emph{\code{drm\_gem\_dumb\_map\_offset()}}}}. See the callbacks for further details.

Note that dumb objects may not be used for gpu acceleration, as has been
attempted on some ARM embedded platforms. Such drivers really must have
a hardware-specific ioctl to allocate suitable buffer objects.


\section{Plane Abstraction}
\label{gpu/drm-kms:plane-abstraction}
A plane represents an image source that can be blended with or overlayed on
top of a CRTC during the scanout process. Planes take their input data from a
{\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}} object. The plane itself specifies the cropping and scaling
of that image, and where it is placed on the visible are of a display
pipeline, represented by {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}}. A plane can also have additional
properties that specify how the pixels are positioned and blended, like
rotation or Z-position. All these properties are stored in {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{drm\_plane\_state}}}}.

To create a plane, a KMS drivers allocates and zeroes an instances of
{\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{struct drm\_plane}}}} (possibly as part of a larger structure) and registers it
with a call to {\hyperref[gpu/drm\string-kms:c.drm_universal_plane_init]{\emph{\code{drm\_universal\_plane\_init()}}}}.

Cursor and overlay planes are optional. All drivers should provide one
primary plane per CRTC to avoid surprising userspace too much. See enum
drm\_plane\_type for a more in-depth discussion of these special uapi-relevant
plane types. Special planes are associated with their CRTC by calling
{\hyperref[gpu/drm\string-kms:c.drm_crtc_init_with_planes]{\emph{\code{drm\_crtc\_init\_with\_planes()}}}}.

The type of a plane is exposed in the immutable ``type'' enumeration property,
which has one of the following values: ``Overlay'', ``Primary'', ``Cursor''.


\subsection{Plane Functions Reference}
\label{gpu/drm-kms:plane-functions-reference}\index{drm\_plane\_state (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_plane_state}\pysigline{struct \bfcode{drm\_plane\_state}}
mutable plane state

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}plane\PYGZus{}state \PYGZob{}
  struct drm\PYGZus{}plane *plane;
  struct drm\PYGZus{}crtc *crtc;
  struct drm\PYGZus{}framebuffer *fb;
  struct dma\PYGZus{}fence *fence;
  int32\PYGZus{}t crtc\PYGZus{}x;
  int32\PYGZus{}t crtc\PYGZus{}y;
  uint32\PYGZus{}t crtc\PYGZus{}w, crtc\PYGZus{}h;
  uint32\PYGZus{}t src\PYGZus{}x, src\PYGZus{}y;
  uint32\PYGZus{}t src\PYGZus{}h, src\PYGZus{}w;
  unsigned int rotation;
  unsigned int zpos;
  unsigned int normalized\PYGZus{}zpos;
  struct drm\PYGZus{}rect src, dst;
  bool visible;
  struct drm\PYGZus{}crtc\PYGZus{}commit *commit;
  struct drm\PYGZus{}atomic\PYGZus{}state *state;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{plane}}] \leavevmode
backpointer to the plane

\item[{\code{crtc}}] \leavevmode
Currently bound CRTC, NULL if disabled. Do not this write directly,
use {\hyperref[gpu/drm\string-kms:c.drm_atomic_set_crtc_for_plane]{\emph{\code{drm\_atomic\_set\_crtc\_for\_plane()}}}}

\item[{\code{fb}}] \leavevmode
Currently bound framebuffer. Do not write this directly, use
{\hyperref[gpu/drm\string-kms:c.drm_atomic_set_fb_for_plane]{\emph{\code{drm\_atomic\_set\_fb\_for\_plane()}}}}

\item[{\code{fence}}] \leavevmode
Optional fence to wait for before scanning out \textbf{fb}. Do not write this
directly, use {\hyperref[gpu/drm\string-kms:c.drm_atomic_set_fence_for_plane]{\emph{\code{drm\_atomic\_set\_fence\_for\_plane()}}}}

\item[{\code{crtc\_x}}] \leavevmode
Left position of visible portion of plane on crtc, signed dest
location allows it to be partially off screen.

\item[{\code{crtc\_y}}] \leavevmode
Upper position of visible portion of plane on crtc, signed dest
location allows it to be partially off screen.

\item[{\code{crtc\_w}}] \leavevmode
width of visible portion of plane on crtc

\item[{\code{crtc\_h}}] \leavevmode
height of visible portion of plane on crtc

\item[{\code{src\_x}}] \leavevmode
left position of visible portion of plane within
plane (in 16.16)

\item[{\code{src\_y}}] \leavevmode
upper position of visible portion of plane within
plane (in 16.16)

\item[{\code{src\_h}}] \leavevmode
height of visible portion of plane (in 16.16)

\item[{\code{src\_w}}] \leavevmode
width of visible portion of plane (in 16.16)

\item[{\code{rotation}}] \leavevmode
rotation of the plane

\item[{\code{zpos}}] \leavevmode
priority of the given plane on crtc (optional)
Note that multiple active planes on the same crtc can have an identical
zpos value. The rule to solving the conflict is to compare the plane
object IDs; the plane with a higher ID must be stacked on top of a
plane with a lower ID.

\item[{\code{normalized\_zpos}}] \leavevmode
normalized value of zpos: unique, range from 0 to N-1
where N is the number of active planes for given crtc. Note that
the driver must call {\hyperref[gpu/drm\string-kms:c.drm_atomic_normalize_zpos]{\emph{\code{drm\_atomic\_normalize\_zpos()}}}} to update this before
it can be trusted.

\item[{\code{src}}] \leavevmode
clipped source coordinates of the plane (in 16.16)

\item[{\code{dst}}] \leavevmode
clipped destination coordinates of the plane

\item[{\code{visible}}] \leavevmode
Visibility of the plane. This can be false even if fb!=NULL and
crtc!=NULL, due to clipping.

\item[{\code{commit}}] \leavevmode
Tracks the pending commit to prevent use-after-free conditions,
and for async plane updates.

May be NULL.

\item[{\code{state}}] \leavevmode
backpointer to global drm\_atomic\_state

\end{description}
\index{drm\_plane\_funcs (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_plane_funcs}\pysigline{struct \bfcode{drm\_plane\_funcs}}
driver plane control functions

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}plane\PYGZus{}funcs \PYGZob{}
  int (*update\PYGZus{}plane)(struct drm\PYGZus{}plane *plane,struct drm\PYGZus{}crtc *crtc, struct drm\PYGZus{}framebuffer *fb,int crtc\PYGZus{}x, int crtc\PYGZus{}y,unsigned int crtc\PYGZus{}w, unsigned int crtc\PYGZus{}h,uint32\PYGZus{}t src\PYGZus{}x, uint32\PYGZus{}t src\PYGZus{}y,uint32\PYGZus{}t src\PYGZus{}w, uint32\PYGZus{}t src\PYGZus{}h, struct drm\PYGZus{}modeset\PYGZus{}acquire\PYGZus{}ctx *ctx);
  int (*disable\PYGZus{}plane)(struct drm\PYGZus{}plane *plane, struct drm\PYGZus{}modeset\PYGZus{}acquire\PYGZus{}ctx *ctx);
  void (*destroy)(struct drm\PYGZus{}plane *plane);
  void (*reset)(struct drm\PYGZus{}plane *plane);
  int (*set\PYGZus{}property)(struct drm\PYGZus{}plane *plane, struct drm\PYGZus{}property *property, uint64\PYGZus{}t val);
  struct drm\PYGZus{}plane\PYGZus{}state *(*atomic\PYGZus{}duplicate\PYGZus{}state)(struct drm\PYGZus{}plane *plane);
  void (*atomic\PYGZus{}destroy\PYGZus{}state)(struct drm\PYGZus{}plane *plane, struct drm\PYGZus{}plane\PYGZus{}state *state);
  int (*atomic\PYGZus{}set\PYGZus{}property)(struct drm\PYGZus{}plane *plane,struct drm\PYGZus{}plane\PYGZus{}state *state,struct drm\PYGZus{}property *property, uint64\PYGZus{}t val);
  int (*atomic\PYGZus{}get\PYGZus{}property)(struct drm\PYGZus{}plane *plane,const struct drm\PYGZus{}plane\PYGZus{}state *state,struct drm\PYGZus{}property *property, uint64\PYGZus{}t *val);
  int (*late\PYGZus{}register)(struct drm\PYGZus{}plane *plane);
  void (*early\PYGZus{}unregister)(struct drm\PYGZus{}plane *plane);
  void (*atomic\PYGZus{}print\PYGZus{}state)(struct drm\PYGZus{}printer *p, const struct drm\PYGZus{}plane\PYGZus{}state *state);
  bool (*format\PYGZus{}mod\PYGZus{}supported)(struct drm\PYGZus{}plane *plane, uint32\PYGZus{}t format, uint64\PYGZus{}t modifier);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{update\_plane}}] \leavevmode
This is the legacy entry point to enable and configure the plane for
the given CRTC and framebuffer. It is never called to disable the
plane, i.e. the passed-in crtc and fb paramters are never NULL.

The source rectangle in frame buffer memory coordinates is given by
the src\_x, src\_y, src\_w and src\_h parameters (as 16.16 fixed point
values). Devices that don't support subpixel plane coordinates can
ignore the fractional part.

The destination rectangle in CRTC coordinates is given by the
crtc\_x, crtc\_y, crtc\_w and crtc\_h parameters (as integer values).
Devices scale the source rectangle to the destination rectangle. If
scaling is not supported, and the source rectangle size doesn't match
the destination rectangle size, the driver must return a
-\textless{}errorname\textgreater{}EINVAL\textless{}/errorname\textgreater{} error.

Drivers implementing atomic modeset should use
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_update_plane]{\emph{\code{drm\_atomic\_helper\_update\_plane()}}}} to implement this hook.

RETURNS:

0 on success or a negative error code on failure.

\item[{\code{disable\_plane}}] \leavevmode
This is the legacy entry point to disable the plane. The DRM core
calls this method in response to a DRM\_IOCTL\_MODE\_SETPLANE IOCTL call
with the frame buffer ID set to 0.  Disabled planes must not be
processed by the CRTC.

Drivers implementing atomic modeset should use
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_disable_plane]{\emph{\code{drm\_atomic\_helper\_disable\_plane()}}}} to implement this hook.

RETURNS:

0 on success or a negative error code on failure.

\item[{\code{destroy}}] \leavevmode
Clean up plane resources. This is only called at driver unload time
through {\hyperref[gpu/drm\string-kms:c.drm_mode_config_cleanup]{\emph{\code{drm\_mode\_config\_cleanup()}}}} since a plane cannot be hotplugged
in DRM.

\item[{\code{reset}}] \leavevmode
Reset plane hardware and software state to off. This function isn't
called by the core directly, only through {\hyperref[gpu/drm\string-kms:c.drm_mode_config_reset]{\emph{\code{drm\_mode\_config\_reset()}}}}.
It's not a helper hook only for historical reasons.

Atomic drivers can use {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_plane_reset]{\emph{\code{drm\_atomic\_helper\_plane\_reset()}}}} to reset
atomic state using this hook.

\item[{\code{set\_property}}] \leavevmode
This is the legacy entry point to update a property attached to the
plane.

This callback is optional if the driver does not support any legacy
driver-private properties. For atomic drivers it is not used because
property handling is done entirely in the DRM core.

RETURNS:

0 on success or a negative error code on failure.

\item[{\code{atomic\_duplicate\_state}}] \leavevmode
Duplicate the current atomic state for this plane and return it.
The core and helpers guarantee that any atomic state duplicated with
this hook and still owned by the caller (i.e. not transferred to the
driver by calling {\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.atomic\_commit}}}}) will be
cleaned up by calling the \textbf{atomic\_destroy\_state} hook in this
structure.

Atomic drivers which don't subclass {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{struct drm\_plane\_state}}}} should use
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_plane_duplicate_state]{\emph{\code{drm\_atomic\_helper\_plane\_duplicate\_state()}}}}. Drivers that subclass the
state structure to extend it with driver-private state should use
{\hyperref[gpu/drm\string-kms\string-helpers:c.__drm_atomic_helper_plane_duplicate_state]{\emph{\code{\_\_drm\_atomic\_helper\_plane\_duplicate\_state()}}}} to make sure shared state is
duplicated in a consistent fashion across drivers.

It is an error to call this hook before {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{drm\_plane.state}}}} has been
initialized correctly.

NOTE:

If the duplicate state references refcounted resources this hook must
acquire a reference for each of them. The driver must release these
references again in \textbf{atomic\_destroy\_state}.

RETURNS:

Duplicated atomic state or NULL when the allocation failed.

\item[{\code{atomic\_destroy\_state}}] \leavevmode
Destroy a state duplicated with \textbf{atomic\_duplicate\_state} and release
or unreference all resources it references

\item[{\code{atomic\_set\_property}}] \leavevmode
Decode a driver-private property value and store the decoded value
into the passed-in state structure. Since the atomic core decodes all
standardized properties (even for extensions beyond the core set of
properties which might not be implemented by all drivers) this
requires drivers to subclass the state structure.

Such driver-private properties should really only be implemented for
truly hardware/vendor specific state. Instead it is preferred to
standardize atomic extension and decode the properties used to expose
such an extension in the core.

Do not call this function directly, use
\code{drm\_atomic\_plane\_set\_property()} instead.

This callback is optional if the driver does not support any
driver-private atomic properties.

NOTE:

This function is called in the state assembly phase of atomic
modesets, which can be aborted for any reason (including on
userspace's request to just check whether a configuration would be
possible). Drivers MUST NOT touch any persistent state (hardware or
software) or data structures except the passed in \textbf{state} parameter.

Also since userspace controls in which order properties are set this
function must not do any input validation (since the state update is
incomplete and hence likely inconsistent). Instead any such input
validation must be done in the various atomic\_check callbacks.

RETURNS:

0 if the property has been found, -EINVAL if the property isn't
implemented by the driver (which shouldn't ever happen, the core only
asks for properties attached to this plane). No other validation is
allowed by the driver. The core already checks that the property
value is within the range (integer, valid enum value, ...) the driver
set when registering the property.

\item[{\code{atomic\_get\_property}}] \leavevmode
Reads out the decoded driver-private property. This is used to
implement the GETPLANE IOCTL.

Do not call this function directly, use
\code{drm\_atomic\_plane\_get\_property()} instead.

This callback is optional if the driver does not support any
driver-private atomic properties.

RETURNS:

0 on success, -EINVAL if the property isn't implemented by the
driver (which should never happen, the core only asks for
properties attached to this plane).

\item[{\code{late\_register}}] \leavevmode
This optional hook can be used to register additional userspace
interfaces attached to the plane like debugfs interfaces.
It is called late in the driver load sequence from {\hyperref[gpu/drm\string-internals:c.drm_dev_register]{\emph{\code{drm\_dev\_register()}}}}.
Everything added from this callback should be unregistered in
the early\_unregister callback.

Returns:

0 on success, or a negative error code on failure.

\item[{\code{early\_unregister}}] \leavevmode
This optional hook should be used to unregister the additional
userspace interfaces attached to the plane from
\textbf{late\_register}. It is called from {\hyperref[gpu/drm\string-internals:c.drm_dev_unregister]{\emph{\code{drm\_dev\_unregister()}}}},
early in the driver unload sequence to disable userspace access
before data structures are torndown.

\item[{\code{atomic\_print\_state}}] \leavevmode
If driver subclasses {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{struct drm\_plane\_state}}}}, it should implement
this optional hook for printing additional driver specific state.

Do not call this directly, use \code{drm\_atomic\_plane\_print\_state()}
instead.

\item[{\code{format\_mod\_supported}}] \leavevmode
This optional hook is used for the DRM to determine if the given
format/modifier combination is valid for the plane. This allows the
DRM to generate the correct format bitmask (which formats apply to
which modifier).

Returns:

True if the given modifier is valid for that format on the plane.
False otherwise.

\end{description}
\index{drm\_plane\_type (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_plane_type}\pysigline{enum \bfcode{drm\_plane\_type}}
uapi plane type enumeration

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{DRM\_PLANE\_TYPE\_OVERLAY}}] \leavevmode
Overlay planes represent all non-primary, non-cursor planes. Some
drivers refer to these types of planes as ``sprites'' internally.

\item[{\code{DRM\_PLANE\_TYPE\_PRIMARY}}] \leavevmode
Primary planes represent a ``main'' plane for a CRTC.  Primary planes
are the planes operated upon by CRTC modesetting and flipping
operations described in the {\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.page\_flip}}}} and
{\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.set\_config}}}} hooks.

\item[{\code{DRM\_PLANE\_TYPE\_CURSOR}}] \leavevmode
Cursor planes represent a ``cursor'' plane for a CRTC.  Cursor planes
are the planes operated upon by the DRM\_IOCTL\_MODE\_CURSOR and
DRM\_IOCTL\_MODE\_CURSOR2 IOCTLs.

\end{description}

\textbf{Description}

For historical reasons not all planes are made the same. This enumeration is
used to tell the different types of planes apart to implement the different
uapi semantics for them. For userspace which is universal plane aware and
which is using that atomic IOCTL there's no difference between these planes
(beyong what the driver and hardware can support of course).

For compatibility with legacy userspace, only overlay planes are made
available to userspace by default. Userspace clients may set the
DRM\_CLIENT\_CAP\_UNIVERSAL\_PLANES client capability bit to indicate that they
wish to receive a universal plane list containing all plane types. See also
{\hyperref[gpu/drm\string-kms:c.drm_for_each_legacy_plane]{\emph{\code{drm\_for\_each\_legacy\_plane()}}}}.

WARNING: The values of this enum is UABI since they're exposed in the ``type''
property.
\index{drm\_plane (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_plane}\pysigline{struct \bfcode{drm\_plane}}
central DRM plane control structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}plane \PYGZob{}
  struct drm\PYGZus{}device *dev;
  struct list\PYGZus{}head head;
  char *name;
  struct drm\PYGZus{}modeset\PYGZus{}lock mutex;
  struct drm\PYGZus{}mode\PYGZus{}object base;
  uint32\PYGZus{}t possible\PYGZus{}crtcs;
  uint32\PYGZus{}t *format\PYGZus{}types;
  unsigned int format\PYGZus{}count;
  bool format\PYGZus{}default;
  uint64\PYGZus{}t *modifiers;
  unsigned int modifier\PYGZus{}count;
  struct drm\PYGZus{}crtc *crtc;
  struct drm\PYGZus{}framebuffer *fb;
  struct drm\PYGZus{}framebuffer *old\PYGZus{}fb;
  const struct drm\PYGZus{}plane\PYGZus{}funcs *funcs;
  struct drm\PYGZus{}object\PYGZus{}properties properties;
  enum drm\PYGZus{}plane\PYGZus{}type type;
  unsigned index;
  const struct drm\PYGZus{}plane\PYGZus{}helper\PYGZus{}funcs *helper\PYGZus{}private;
  struct drm\PYGZus{}plane\PYGZus{}state *state;
  struct drm\PYGZus{}property *zpos\PYGZus{}property;
  struct drm\PYGZus{}property *rotation\PYGZus{}property;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev}}] \leavevmode
DRM device this plane belongs to

\item[{\code{head}}] \leavevmode
for list management

\item[{\code{name}}] \leavevmode
human readable name, can be overwritten by the driver

\item[{\code{mutex}}] \leavevmode
Protects modeset plane state, together with the {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc.mutex}}}} of
CRTC this plane is linked to (when active, getting activated or
getting disabled).

For atomic drivers specifically this protects \textbf{state}.

\item[{\code{base}}] \leavevmode
base mode object

\item[{\code{possible\_crtcs}}] \leavevmode
pipes this plane can be bound to

\item[{\code{format\_types}}] \leavevmode
array of formats supported by this plane

\item[{\code{format\_count}}] \leavevmode
number of formats supported

\item[{\code{format\_default}}] \leavevmode
driver hasn't supplied supported formats for the plane

\item[{\code{modifiers}}] \leavevmode
array of modifiers supported by this plane

\item[{\code{modifier\_count}}] \leavevmode
number of modifiers supported

\item[{\code{crtc}}] \leavevmode
Currently bound CRTC, only really meaningful for non-atomic
drivers.  Atomic drivers should instead check {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{drm\_plane\_state.crtc}}}}.

\item[{\code{fb}}] \leavevmode
Currently bound framebuffer, only really meaningful for
non-atomic drivers.  Atomic drivers should instead check
{\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{drm\_plane\_state.fb}}}}.

\item[{\code{old\_fb}}] \leavevmode
Temporary tracking of the old fb while a modeset is ongoing. Used by
{\hyperref[gpu/drm\string-kms:c.drm_mode_set_config_internal]{\emph{\code{drm\_mode\_set\_config\_internal()}}}} to implement correct refcounting.

\item[{\code{funcs}}] \leavevmode
helper functions

\item[{\code{properties}}] \leavevmode
property tracking for this plane

\item[{\code{type}}] \leavevmode
type of plane (overlay, primary, cursor)

\item[{\code{index}}] \leavevmode
Position inside the mode\_config.list, can be used as an array
index. It is invariant over the lifetime of the plane.

\item[{\code{helper\_private}}] \leavevmode
mid-layer private data

\item[{\code{state}}] \leavevmode
Current atomic state for this plane.

This is protected by \textbf{mutex}. Note that nonblocking atomic commits
access the current plane state without taking locks. Either by going
through the {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{struct drm\_atomic\_state}}}} pointers, see
{\hyperref[gpu/drm\string-kms:c.for_each_oldnew_plane_in_state]{\emph{\code{for\_each\_oldnew\_plane\_in\_state()}}}}, {\hyperref[gpu/drm\string-kms:c.for_each_old_plane_in_state]{\emph{\code{for\_each\_old\_plane\_in\_state()}}}} and
{\hyperref[gpu/drm\string-kms:c.for_each_new_plane_in_state]{\emph{\code{for\_each\_new\_plane\_in\_state()}}}}. Or through careful ordering of atomic
commit operations as implemented in the atomic helpers, see
{\hyperref[gpu/drm\string-kms:c.drm_crtc_commit]{\emph{\code{struct drm\_crtc\_commit}}}}.

\item[{\code{zpos\_property}}] \leavevmode
zpos property for this plane

\item[{\code{rotation\_property}}] \leavevmode
rotation property for this plane

\end{description}
\index{drm\_plane\_index (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_plane_index}\pysiglinewithargsret{unsigned int \bfcode{drm\_plane\_index}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}}{}
find the index of a registered plane

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane to find index for

\end{description}

\textbf{Description}

Given a registered plane, return the index of that plane within a DRM
device's list of planes.
\index{drm\_plane\_find (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_plane_find}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} * \bfcode{drm\_plane\_find}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}, uint32\_t\emph{ id}}{}
find a {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{drm\_plane}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
drm file to check for lease against.

\item[{\code{uint32\_t id}}] \leavevmode
plane id

\end{description}

\textbf{Description}

Returns the plane with \textbf{id}, NULL if it doesn't exist. Simple wrapper around
{\hyperref[gpu/drm\string-kms:c.drm_mode_object_find]{\emph{\code{drm\_mode\_object\_find()}}}}.
\index{drm\_for\_each\_plane\_mask (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_for_each_plane_mask}\pysiglinewithargsret{\bfcode{drm\_for\_each\_plane\_mask}}{\emph{plane}, \emph{dev}, \emph{plane\_mask}}{}
iterate over planes specified by bitmask

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{plane}}] \leavevmode
the loop cursor

\item[{\code{dev}}] \leavevmode
the DRM device

\item[{\code{plane\_mask}}] \leavevmode
bitmask of plane indices

\end{description}

\textbf{Description}

Iterate over all planes specified by bitmask.
\index{drm\_for\_each\_legacy\_plane (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_for_each_legacy_plane}\pysiglinewithargsret{\bfcode{drm\_for\_each\_legacy\_plane}}{\emph{plane}, \emph{dev}}{}
iterate over all planes for legacy userspace

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{plane}}] \leavevmode
the loop cursor

\item[{\code{dev}}] \leavevmode
the DRM device

\end{description}

\textbf{Description}

Iterate over all legacy planes of \textbf{dev}, excluding primary and cursor planes.
This is useful for implementing userspace apis when userspace is not
universal plane aware. See also {\hyperref[gpu/drm\string-kms:c.drm_plane_type]{\emph{\code{enum drm\_plane\_type}}}}.
\index{drm\_for\_each\_plane (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_for_each_plane}\pysiglinewithargsret{\bfcode{drm\_for\_each\_plane}}{\emph{plane}, \emph{dev}}{}
iterate over all planes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{plane}}] \leavevmode
the loop cursor

\item[{\code{dev}}] \leavevmode
the DRM device

\end{description}

\textbf{Description}

Iterate over all planes of \textbf{dev}, include primary and cursor planes.
\index{drm\_universal\_plane\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_universal_plane_init}\pysiglinewithargsret{int \bfcode{drm\_universal\_plane\_init}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, uint32\_t\emph{ possible\_crtcs}, const struct {\hyperref[gpu/drm\string-kms:c.drm_plane_funcs]{\emph{drm\_plane\_funcs}}} *\emph{ funcs}, const uint32\_t *\emph{ formats}, unsigned int\emph{ format\_count}, const uint64\_t *\emph{ format\_modifiers}, enum {\hyperref[gpu/drm\string-kms:c.drm_plane_type]{\emph{drm\_plane\_type}}}\emph{ type}, const char *\emph{ name}, ...}{}
Initialize a new universal plane object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane object to init

\item[{\code{uint32\_t possible\_crtcs}}] \leavevmode
bitmask of possible CRTCs

\item[{\code{const struct drm\_plane\_funcs * funcs}}] \leavevmode
callbacks for the new plane

\item[{\code{const uint32\_t * formats}}] \leavevmode
array of supported formats (DRM\_FORMAT\_*)

\item[{\code{unsigned int format\_count}}] \leavevmode
number of elements in \textbf{formats}

\item[{\code{const uint64\_t * format\_modifiers}}] \leavevmode
array of struct drm\_format modifiers terminated by
DRM\_FORMAT\_MOD\_INVALID

\item[{\code{enum drm\_plane\_type type}}] \leavevmode
type of plane (overlay, primary, cursor)

\item[{\code{const char * name}}] \leavevmode
printf style format string for the plane name, or NULL for default name

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

Initializes a plane object of type \textbf{type}.

\textbf{Return}

Zero on success, error code on failure.
\index{drm\_plane\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_plane_init}\pysiglinewithargsret{int \bfcode{drm\_plane\_init}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, uint32\_t\emph{ possible\_crtcs}, const struct {\hyperref[gpu/drm\string-kms:c.drm_plane_funcs]{\emph{drm\_plane\_funcs}}} *\emph{ funcs}, const uint32\_t *\emph{ formats}, unsigned int\emph{ format\_count}, bool\emph{ is\_primary}}{}
Initialize a legacy plane

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane object to init

\item[{\code{uint32\_t possible\_crtcs}}] \leavevmode
bitmask of possible CRTCs

\item[{\code{const struct drm\_plane\_funcs * funcs}}] \leavevmode
callbacks for the new plane

\item[{\code{const uint32\_t * formats}}] \leavevmode
array of supported formats (DRM\_FORMAT\_*)

\item[{\code{unsigned int format\_count}}] \leavevmode
number of elements in \textbf{formats}

\item[{\code{bool is\_primary}}] \leavevmode
plane type (primary vs overlay)

\end{description}

\textbf{Description}

Legacy API to initialize a DRM plane.

New drivers should call {\hyperref[gpu/drm\string-kms:c.drm_universal_plane_init]{\emph{\code{drm\_universal\_plane\_init()}}}} instead.

\textbf{Return}

Zero on success, error code on failure.
\index{drm\_plane\_cleanup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_plane_cleanup}\pysiglinewithargsret{void \bfcode{drm\_plane\_cleanup}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}}{}
Clean up the core plane usage

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane to cleanup

\end{description}

\textbf{Description}

This function cleans up \textbf{plane} and removes it from the DRM mode setting
core. Note that the function does \emph{not} free the plane structure itself,
this is the responsibility of the caller.
\index{drm\_plane\_from\_index (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_plane_from_index}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} * \bfcode{drm\_plane\_from\_index}}{struct drm\_device *\emph{ dev}, int\emph{ idx}}{}
find the registered plane at an index

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{int idx}}] \leavevmode
index of registered plane to find for

\end{description}

\textbf{Description}

Given a plane index, return the registered plane from DRM device's
list of planes with matching index. This is the inverse of {\hyperref[gpu/drm\string-kms:c.drm_plane_index]{\emph{\code{drm\_plane\_index()}}}}.
\index{drm\_plane\_force\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_plane_force_disable}\pysiglinewithargsret{void \bfcode{drm\_plane\_force\_disable}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}}{}
Forcibly disable a plane

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane to disable

\end{description}

\textbf{Description}

Forces the plane to be disabled.

Used when the plane's current framebuffer is destroyed,
and when restoring fbdev mode.

Note that this function is not suitable for atomic drivers, since it doesn't
wire through the lock acquisition context properly and hence can't handle
retries or driver private locks. You probably want to use
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_disable_plane]{\emph{\code{drm\_atomic\_helper\_disable\_plane()}}}} or
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_disable_planes_on_crtc]{\emph{\code{drm\_atomic\_helper\_disable\_planes\_on\_crtc()}}}} instead.
\index{drm\_mode\_plane\_set\_obj\_prop (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_plane_set_obj_prop}\pysiglinewithargsret{int \bfcode{drm\_mode\_plane\_set\_obj\_prop}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} *\emph{ property}, uint64\_t\emph{ value}}{}
set the value of a property

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
drm plane object to set property value for

\item[{\code{struct drm\_property * property}}] \leavevmode
property to set

\item[{\code{uint64\_t value}}] \leavevmode
value the property should be set to

\end{description}

\textbf{Description}

This functions sets a given property on a given plane object. This function
calls the driver's -\textgreater{}set\_property callback and changes the software state of
the property if the callback succeeds.

\textbf{Return}

Zero on success, error code on failure.


\section{Display Modes Function Reference}
\label{gpu/drm-kms:display-modes-function-reference}\index{drm\_mode\_status (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_status}\pysigline{enum \bfcode{drm\_mode\_status}}
hardware support status of a mode

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{MODE\_OK}}] \leavevmode
Mode OK

\item[{\code{MODE\_HSYNC}}] \leavevmode
hsync out of range

\item[{\code{MODE\_VSYNC}}] \leavevmode
vsync out of range

\item[{\code{MODE\_H\_ILLEGAL}}] \leavevmode
mode has illegal horizontal timings

\item[{\code{MODE\_V\_ILLEGAL}}] \leavevmode
mode has illegal horizontal timings

\item[{\code{MODE\_BAD\_WIDTH}}] \leavevmode
requires an unsupported linepitch

\item[{\code{MODE\_NOMODE}}] \leavevmode
no mode with a matching name

\item[{\code{MODE\_NO\_INTERLACE}}] \leavevmode
interlaced mode not supported

\item[{\code{MODE\_NO\_DBLESCAN}}] \leavevmode
doublescan mode not supported

\item[{\code{MODE\_NO\_VSCAN}}] \leavevmode
multiscan mode not supported

\item[{\code{MODE\_MEM}}] \leavevmode
insufficient video memory

\item[{\code{MODE\_VIRTUAL\_X}}] \leavevmode
mode width too large for specified virtual size

\item[{\code{MODE\_VIRTUAL\_Y}}] \leavevmode
mode height too large for specified virtual size

\item[{\code{MODE\_MEM\_VIRT}}] \leavevmode
insufficient video memory given virtual size

\item[{\code{MODE\_NOCLOCK}}] \leavevmode
no fixed clock available

\item[{\code{MODE\_CLOCK\_HIGH}}] \leavevmode
clock required is too high

\item[{\code{MODE\_CLOCK\_LOW}}] \leavevmode
clock required is too low

\item[{\code{MODE\_CLOCK\_RANGE}}] \leavevmode
clock/mode isn't in a ClockRange

\item[{\code{MODE\_BAD\_HVALUE}}] \leavevmode
horizontal timing was out of range

\item[{\code{MODE\_BAD\_VVALUE}}] \leavevmode
vertical timing was out of range

\item[{\code{MODE\_BAD\_VSCAN}}] \leavevmode
VScan value out of range

\item[{\code{MODE\_HSYNC\_NARROW}}] \leavevmode
horizontal sync too narrow

\item[{\code{MODE\_HSYNC\_WIDE}}] \leavevmode
horizontal sync too wide

\item[{\code{MODE\_HBLANK\_NARROW}}] \leavevmode
horizontal blanking too narrow

\item[{\code{MODE\_HBLANK\_WIDE}}] \leavevmode
horizontal blanking too wide

\item[{\code{MODE\_VSYNC\_NARROW}}] \leavevmode
vertical sync too narrow

\item[{\code{MODE\_VSYNC\_WIDE}}] \leavevmode
vertical sync too wide

\item[{\code{MODE\_VBLANK\_NARROW}}] \leavevmode
vertical blanking too narrow

\item[{\code{MODE\_VBLANK\_WIDE}}] \leavevmode
vertical blanking too wide

\item[{\code{MODE\_PANEL}}] \leavevmode
exceeds panel dimensions

\item[{\code{MODE\_INTERLACE\_WIDTH}}] \leavevmode
width too large for interlaced mode

\item[{\code{MODE\_ONE\_WIDTH}}] \leavevmode
only one width is supported

\item[{\code{MODE\_ONE\_HEIGHT}}] \leavevmode
only one height is supported

\item[{\code{MODE\_ONE\_SIZE}}] \leavevmode
only one resolution is supported

\item[{\code{MODE\_NO\_REDUCED}}] \leavevmode
monitor doesn't accept reduced blanking

\item[{\code{MODE\_NO\_STEREO}}] \leavevmode
stereo modes not supported

\item[{\code{MODE\_NO\_420}}] \leavevmode
ycbcr 420 modes not supported

\item[{\code{MODE\_STALE}}] \leavevmode
mode has become stale

\item[{\code{MODE\_BAD}}] \leavevmode
unspecified reason

\item[{\code{MODE\_ERROR}}] \leavevmode
error condition

\end{description}

\textbf{Description}

This enum is used to filter out modes not supported by the driver/hardware
combination.
\index{drm\_display\_mode (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_display_mode}\pysigline{struct \bfcode{drm\_display\_mode}}
DRM kernel-internal display mode structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}display\PYGZus{}mode \PYGZob{}
  struct list\PYGZus{}head head;
  struct drm\PYGZus{}mode\PYGZus{}object base;
  char name[DRM\PYGZus{}DISPLAY\PYGZus{}MODE\PYGZus{}LEN];
  enum drm\PYGZus{}mode\PYGZus{}status status;
  unsigned int type;
  int clock;
  int hdisplay;
  int hsync\PYGZus{}start;
  int hsync\PYGZus{}end;
  int htotal;
  int hskew;
  int vdisplay;
  int vsync\PYGZus{}start;
  int vsync\PYGZus{}end;
  int vtotal;
  int vscan;
  unsigned int flags;
  int width\PYGZus{}mm;
  int height\PYGZus{}mm;
  int crtc\PYGZus{}clock;
  int crtc\PYGZus{}hdisplay;
  int crtc\PYGZus{}hblank\PYGZus{}start;
  int crtc\PYGZus{}hblank\PYGZus{}end;
  int crtc\PYGZus{}hsync\PYGZus{}start;
  int crtc\PYGZus{}hsync\PYGZus{}end;
  int crtc\PYGZus{}htotal;
  int crtc\PYGZus{}hskew;
  int crtc\PYGZus{}vdisplay;
  int crtc\PYGZus{}vblank\PYGZus{}start;
  int crtc\PYGZus{}vblank\PYGZus{}end;
  int crtc\PYGZus{}vsync\PYGZus{}start;
  int crtc\PYGZus{}vsync\PYGZus{}end;
  int crtc\PYGZus{}vtotal;
  int *private;
  int private\PYGZus{}flags;
  int vrefresh;
  int hsync;
  enum hdmi\PYGZus{}picture\PYGZus{}aspect picture\PYGZus{}aspect\PYGZus{}ratio;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{head}}] \leavevmode
struct list\_head for mode lists.

\item[{\code{base}}] \leavevmode
A display mode is a normal modeset object, possibly including public
userspace id.

FIXME:

This can probably be removed since the entire concept of userspace
managing modes explicitly has never landed in upstream kernel mode
setting support.

\item[{\code{name}}] \leavevmode
Human-readable name of the mode, filled out with {\hyperref[gpu/drm\string-kms:c.drm_mode_set_name]{\emph{\code{drm\_mode\_set\_name()}}}}.

\item[{\code{status}}] \leavevmode
Status of the mode, used to filter out modes not supported by the
hardware. See enum {\hyperref[gpu/drm\string-kms:c.drm_mode_status]{\emph{\code{drm\_mode\_status}}}}.

\item[{\code{type}}] \leavevmode
A bitmask of flags, mostly about the source of a mode. Possible flags
are:
\begin{itemize}
\item {} 
DRM\_MODE\_TYPE\_BUILTIN: Meant for hard-coded modes, effectively
unused.

\item {} 
DRM\_MODE\_TYPE\_PREFERRED: Preferred mode, usually the native
resolution of an LCD panel. There should only be one preferred
mode per connector at any given time.

\item {} 
DRM\_MODE\_TYPE\_DRIVER: Mode created by the driver, which is all of
them really. Drivers must set this bit for all modes they create
and expose to userspace.

\end{itemize}

Plus a big list of flags which shouldn't be used at all, but are
still around since these flags are also used in the userspace ABI:
\begin{itemize}
\item {} 
DRM\_MODE\_TYPE\_DEFAULT: Again a leftover, use
DRM\_MODE\_TYPE\_PREFERRED instead.

\item {} 
DRM\_MODE\_TYPE\_CLOCK\_C and DRM\_MODE\_TYPE\_CRTC\_C: Define leftovers
which are stuck around for hysterical raisins only. No one has an
idea what they were meant for. Don't use.

\item {} 
DRM\_MODE\_TYPE\_USERDEF: Mode defined by userspace, again a vestige
from older kms designs where userspace had to first add a custom
mode to the kernel's mode list before it could use it. Don't use.

\end{itemize}

\item[{\code{clock}}] \leavevmode
Pixel clock in kHz.

\item[{\code{hdisplay}}] \leavevmode
horizontal display size

\item[{\code{hsync\_start}}] \leavevmode
horizontal sync start

\item[{\code{hsync\_end}}] \leavevmode
horizontal sync end

\item[{\code{htotal}}] \leavevmode
horizontal total size

\item[{\code{hskew}}] \leavevmode
horizontal skew?!

\item[{\code{vdisplay}}] \leavevmode
vertical display size

\item[{\code{vsync\_start}}] \leavevmode
vertical sync start

\item[{\code{vsync\_end}}] \leavevmode
vertical sync end

\item[{\code{vtotal}}] \leavevmode
vertical total size

\item[{\code{vscan}}] \leavevmode
vertical scan?!

\item[{\code{flags}}] \leavevmode
Sync and timing flags:
\begin{itemize}
\item {} 
DRM\_MODE\_FLAG\_PHSYNC: horizontal sync is active high.

\item {} 
DRM\_MODE\_FLAG\_NHSYNC: horizontal sync is active low.

\item {} 
DRM\_MODE\_FLAG\_PVSYNC: vertical sync is active high.

\item {} 
DRM\_MODE\_FLAG\_NVSYNC: vertical sync is active low.

\item {} 
DRM\_MODE\_FLAG\_INTERLACE: mode is interlaced.

\item {} 
DRM\_MODE\_FLAG\_DBLSCAN: mode uses doublescan.

\item {} 
DRM\_MODE\_FLAG\_CSYNC: mode uses composite sync.

\item {} 
DRM\_MODE\_FLAG\_PCSYNC: composite sync is active high.

\item {} 
DRM\_MODE\_FLAG\_NCSYNC: composite sync is active low.

\item {} 
DRM\_MODE\_FLAG\_HSKEW: hskew provided (not used?).

\item {} 
DRM\_MODE\_FLAG\_BCAST: not used?

\item {} 
DRM\_MODE\_FLAG\_PIXMUX: not used?

\item {} 
DRM\_MODE\_FLAG\_DBLCLK: double-clocked mode.

\item {} 
DRM\_MODE\_FLAG\_CLKDIV2: half-clocked mode.

\end{itemize}

Additionally there's flags to specify how 3D modes are packed:
\begin{itemize}
\item {} 
DRM\_MODE\_FLAG\_3D\_NONE: normal, non-3D mode.

\item {} 
DRM\_MODE\_FLAG\_3D\_FRAME\_PACKING: 2 full frames for left and right.

\item {} 
DRM\_MODE\_FLAG\_3D\_FIELD\_ALTERNATIVE: interleaved like fields.

\item {} 
DRM\_MODE\_FLAG\_3D\_LINE\_ALTERNATIVE: interleaved lines.

\item {} 
DRM\_MODE\_FLAG\_3D\_SIDE\_BY\_SIDE\_FULL: side-by-side full frames.

\item {} 
DRM\_MODE\_FLAG\_3D\_L\_DEPTH: ?

\item {} 
DRM\_MODE\_FLAG\_3D\_L\_DEPTH\_GFX\_GFX\_DEPTH: ?

\item {} 
DRM\_MODE\_FLAG\_3D\_TOP\_AND\_BOTTOM: frame split into top and bottom
parts.

\item {} 
DRM\_MODE\_FLAG\_3D\_SIDE\_BY\_SIDE\_HALF: frame split into left and
right parts.

\end{itemize}

\item[{\code{width\_mm}}] \leavevmode
Addressable size of the output in mm, projectors should set this to
0.

\item[{\code{height\_mm}}] \leavevmode
Addressable size of the output in mm, projectors should set this to
0.

\item[{\code{crtc\_clock}}] \leavevmode
Actual pixel or dot clock in the hardware. This differs from the
logical \textbf{clock} when e.g. using interlacing, double-clocking, stereo
modes or other fancy stuff that changes the timings and signals
actually sent over the wire.

This is again in kHz.

Note that with digital outputs like HDMI or DP there's usually a
massive confusion between the dot clock and the signal clock at the
bit encoding level. Especially when a 8b/10b encoding is used and the
difference is exactly a factor of 10.

\item[{\code{crtc\_hdisplay}}] \leavevmode
hardware mode horizontal display size

\item[{\code{crtc\_hblank\_start}}] \leavevmode
hardware mode horizontal blank start

\item[{\code{crtc\_hblank\_end}}] \leavevmode
hardware mode horizontal blank end

\item[{\code{crtc\_hsync\_start}}] \leavevmode
hardware mode horizontal sync start

\item[{\code{crtc\_hsync\_end}}] \leavevmode
hardware mode horizontal sync end

\item[{\code{crtc\_htotal}}] \leavevmode
hardware mode horizontal total size

\item[{\code{crtc\_hskew}}] \leavevmode
hardware mode horizontal skew?!

\item[{\code{crtc\_vdisplay}}] \leavevmode
hardware mode vertical display size

\item[{\code{crtc\_vblank\_start}}] \leavevmode
hardware mode vertical blank start

\item[{\code{crtc\_vblank\_end}}] \leavevmode
hardware mode vertical blank end

\item[{\code{crtc\_vsync\_start}}] \leavevmode
hardware mode vertical sync start

\item[{\code{crtc\_vsync\_end}}] \leavevmode
hardware mode vertical sync end

\item[{\code{crtc\_vtotal}}] \leavevmode
hardware mode vertical total size

\item[{\code{private}}] \leavevmode
Pointer for driver private data. This can only be used for mode
objects passed to drivers in modeset operations. It shouldn't be used
by atomic drivers since they can store any additional data by
subclassing state structures.

\item[{\code{private\_flags}}] \leavevmode
Similar to \textbf{private}, but just an integer.

\item[{\code{vrefresh}}] \leavevmode
Vertical refresh rate, for debug output in human readable form. Not
used in a functional way.

This value is in Hz.

\item[{\code{hsync}}] \leavevmode
Horizontal refresh rate, for debug output in human readable form. Not
used in a functional way.

This value is in kHz.

\item[{\code{picture\_aspect\_ratio}}] \leavevmode
Field for setting the HDMI picture aspect ratio of a mode.

\end{description}

\textbf{Description}

The horizontal and vertical timings are defined per the following diagram.

\begin{Verbatim}[commandchars=\\\{\}]
          Active                 Front           Sync           Back
         Region                 Porch                          Porch
\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}
  //////////////////////\textbar{}
 ////////////////////// \textbar{}
//////////////////////  \textbar{}..................               ................
                                           \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} [hv]display \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} [hv]sync\PYGZus{}start \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} [hv]sync\PYGZus{}end \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} [hv]total \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}*
\end{Verbatim}

This structure contains two copies of timings. First are the plain timings,
which specify the logical mode, as it would be for a progressive 1:1 scanout
at the refresh rate userspace can observe through vblank timestamps. Then
there's the hardware timings, which are corrected for interlacing,
double-clocking and similar things. They are provided as a convenience, and
can be appropriately computed using {\hyperref[gpu/drm\string-kms:c.drm_mode_set_crtcinfo]{\emph{\code{drm\_mode\_set\_crtcinfo()}}}}.

For printing you can use \code{DRM\_MODE\_FMT} and {\hyperref[gpu/drm\string-kms:c.DRM_MODE_ARG]{\emph{\code{DRM\_MODE\_ARG()}}}}.
\index{DRM\_MODE\_FMT (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.DRM_MODE_FMT}\pysiglinewithargsret{\bfcode{DRM\_MODE\_FMT}}{}{}
printf string for {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{\code{struct drm\_display\_mode}}}}

\end{fulllineitems}


\textbf{Parameters}
\index{DRM\_MODE\_ARG (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.DRM_MODE_ARG}\pysiglinewithargsret{\bfcode{DRM\_MODE\_ARG}}{\emph{m}}{}
printf arguments for {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{\code{struct drm\_display\_mode}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{m}}] \leavevmode
display mode

\end{description}
\index{drm\_mode\_is\_stereo (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_is_stereo}\pysiglinewithargsret{bool \bfcode{drm\_mode\_is\_stereo}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
check for stereo mode flags

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
drm\_display\_mode to check

\end{description}

\textbf{Return}

True if the mode is one of the stereo modes (like side-by-side), false if
not.
\index{drm\_mode\_debug\_printmodeline (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_debug_printmodeline}\pysiglinewithargsret{void \bfcode{drm\_mode\_debug\_printmodeline}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
print a mode to dmesg

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
mode to print

\end{description}

\textbf{Description}

Describe \textbf{mode} using DRM\_DEBUG.
\index{drm\_mode\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_create}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} * \bfcode{drm\_mode\_create}}{struct drm\_device *\emph{ dev}}{}
create a new display mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

Create a new, cleared drm\_display\_mode with kzalloc, allocate an ID for it
and return it.

\textbf{Return}

Pointer to new mode on success, NULL on error.
\index{drm\_mode\_destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_destroy}\pysiglinewithargsret{void \bfcode{drm\_mode\_destroy}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
remove a mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_display\_mode * mode}}] \leavevmode
mode to remove

\end{description}

\textbf{Description}

Release \textbf{mode}`s unique ID, then free it \textbf{mode} structure itself using kfree.
\index{drm\_mode\_probed\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_probed_add}\pysiglinewithargsret{void \bfcode{drm\_mode\_probed\_add}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
add a mode to a connector's probed\_mode list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector the new mode

\item[{\code{struct drm\_display\_mode * mode}}] \leavevmode
mode data

\end{description}

\textbf{Description}

Add \textbf{mode} to \textbf{connector}`s probed\_mode list for later use. This list should
then in a second step get filtered and all the modes actually supported by
the hardware moved to the \textbf{connector}`s modes list.
\index{drm\_cvt\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_cvt_mode}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} * \bfcode{drm\_cvt\_mode}}{struct drm\_device *\emph{ dev}, int\emph{ hdisplay}, int\emph{ vdisplay}, int\emph{ vrefresh}, bool\emph{ reduced}, bool\emph{ interlaced}, bool\emph{ margins}}{}
create a modeline based on the CVT algorithm

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{int hdisplay}}] \leavevmode
hdisplay size

\item[{\code{int vdisplay}}] \leavevmode
vdisplay size

\item[{\code{int vrefresh}}] \leavevmode
vrefresh rate

\item[{\code{bool reduced}}] \leavevmode
whether to use reduced blanking

\item[{\code{bool interlaced}}] \leavevmode
whether to compute an interlaced mode

\item[{\code{bool margins}}] \leavevmode
whether to add margins (borders)

\end{description}

\textbf{Description}

This function is called to generate the modeline based on CVT algorithm
according to the hdisplay, vdisplay, vrefresh.
It is based from the VESA(TM) Coordinated Video Timing Generator by
Graham Loveridge April 9, 2003 available at
\href{http://www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls}{http://www.elo.utfsm.cl/\textasciitilde{}elo212/docs/CVTd6r1.xls}

And it is copied from xf86CVTmode in xserver/hw/xfree86/modes/xf86cvt.c.
What I have done is to translate it by using integer calculation.

\textbf{Return}

The modeline based on the CVT algorithm stored in a drm\_display\_mode object.
The display mode object is allocated with {\hyperref[gpu/drm\string-kms:c.drm_mode_create]{\emph{\code{drm\_mode\_create()}}}}. Returns NULL
when no mode could be allocated.
\index{drm\_gtf\_mode\_complex (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_gtf_mode_complex}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} * \bfcode{drm\_gtf\_mode\_complex}}{struct drm\_device *\emph{ dev}, int\emph{ hdisplay}, int\emph{ vdisplay}, int\emph{ vrefresh}, bool\emph{ interlaced}, int\emph{ margins}, int\emph{ GTF\_M}, int\emph{ GTF\_2C}, int\emph{ GTF\_K}, int\emph{ GTF\_2J}}{}
create the modeline based on the full GTF algorithm

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{int hdisplay}}] \leavevmode
hdisplay size

\item[{\code{int vdisplay}}] \leavevmode
vdisplay size

\item[{\code{int vrefresh}}] \leavevmode
vrefresh rate.

\item[{\code{bool interlaced}}] \leavevmode
whether to compute an interlaced mode

\item[{\code{int margins}}] \leavevmode
desired margin (borders) size

\item[{\code{int GTF\_M}}] \leavevmode
extended GTF formula parameters

\item[{\code{int GTF\_2C}}] \leavevmode
extended GTF formula parameters

\item[{\code{int GTF\_K}}] \leavevmode
extended GTF formula parameters

\item[{\code{int GTF\_2J}}] \leavevmode
extended GTF formula parameters

\end{description}

\textbf{Description}

GTF feature blocks specify C and J in multiples of 0.5, so we pass them
in here multiplied by two.  For a C of 40, pass in 80.

\textbf{Return}

The modeline based on the full GTF algorithm stored in a drm\_display\_mode object.
The display mode object is allocated with {\hyperref[gpu/drm\string-kms:c.drm_mode_create]{\emph{\code{drm\_mode\_create()}}}}. Returns NULL
when no mode could be allocated.
\index{drm\_gtf\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_gtf_mode}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} * \bfcode{drm\_gtf\_mode}}{struct drm\_device *\emph{ dev}, int\emph{ hdisplay}, int\emph{ vdisplay}, int\emph{ vrefresh}, bool\emph{ interlaced}, int\emph{ margins}}{}
create the modeline based on the GTF algorithm

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{int hdisplay}}] \leavevmode
hdisplay size

\item[{\code{int vdisplay}}] \leavevmode
vdisplay size

\item[{\code{int vrefresh}}] \leavevmode
vrefresh rate.

\item[{\code{bool interlaced}}] \leavevmode
whether to compute an interlaced mode

\item[{\code{int margins}}] \leavevmode
desired margin (borders) size

\end{description}

\textbf{Description}

return the modeline based on GTF algorithm

This function is to create the modeline based on the GTF algorithm.
Generalized Timing Formula is derived from:
\begin{quote}

GTF Spreadsheet by Andy Morrish (1/5/97)
available at \href{http://www.vesa.org}{http://www.vesa.org}
\end{quote}

And it is copied from the file of xserver/hw/xfree86/modes/xf86gtf.c.
What I have done is to translate it by using integer calculation.
I also refer to the function of fb\_get\_mode in the file of
drivers/video/fbmon.c

Standard GTF parameters:

\begin{Verbatim}[commandchars=\\\{\}]
M = 600
C = 40
K = 128
J = 20
\end{Verbatim}

\textbf{Return}

The modeline based on the GTF algorithm stored in a drm\_display\_mode object.
The display mode object is allocated with {\hyperref[gpu/drm\string-kms:c.drm_mode_create]{\emph{\code{drm\_mode\_create()}}}}. Returns NULL
when no mode could be allocated.
\index{drm\_display\_mode\_from\_videomode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_display_mode_from_videomode}\pysiglinewithargsret{void \bfcode{drm\_display\_mode\_from\_videomode}}{const struct videomode *\emph{ vm}, struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ dmode}}{}
fill in \textbf{dmode} using \textbf{vm},

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct videomode * vm}}] \leavevmode
videomode structure to use as source

\item[{\code{struct drm\_display\_mode * dmode}}] \leavevmode
drm\_display\_mode structure to use as destination

\end{description}

\textbf{Description}

Fills out \textbf{dmode} using the display mode specified in \textbf{vm}.
\index{drm\_display\_mode\_to\_videomode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_display_mode_to_videomode}\pysiglinewithargsret{void \bfcode{drm\_display\_mode\_to\_videomode}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ dmode}, struct videomode *\emph{ vm}}{}
fill in \textbf{vm} using \textbf{dmode},

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_display\_mode * dmode}}] \leavevmode
drm\_display\_mode structure to use as source

\item[{\code{struct videomode * vm}}] \leavevmode
videomode structure to use as destination

\end{description}

\textbf{Description}

Fills out \textbf{vm} using the display mode specified in \textbf{dmode}.
\index{drm\_bus\_flags\_from\_videomode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_bus_flags_from_videomode}\pysiglinewithargsret{void \bfcode{drm\_bus\_flags\_from\_videomode}}{const struct videomode *\emph{ vm}, u32 *\emph{ bus\_flags}}{}
extract information about pixelclk and DE polarity from videomode and store it in a separate variable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct videomode * vm}}] \leavevmode
videomode structure to use

\item[{\code{u32 * bus\_flags}}] \leavevmode
information about pixelclk and DE polarity will be stored here

\end{description}

\textbf{Description}

Sets DRM\_BUS\_FLAG\_DE\_(LOW\textbar{}HIGH) and DRM\_BUS\_FLAG\_PIXDATA\_(POS\textbar{}NEG)EDGE
in \textbf{bus\_flags} according to DISPLAY\_FLAGS found in \textbf{vm}
\index{of\_get\_drm\_display\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.of_get_drm_display_mode}\pysiglinewithargsret{int \bfcode{of\_get\_drm\_display\_mode}}{struct device\_node *\emph{ np}, struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ dmode}, u32 *\emph{ bus\_flags}, int\emph{ index}}{}
get a drm\_display\_mode from devicetree

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device\_node * np}}] \leavevmode
device\_node with the timing specification

\item[{\code{struct drm\_display\_mode * dmode}}] \leavevmode
will be set to the return value

\item[{\code{u32 * bus\_flags}}] \leavevmode
information about pixelclk and DE polarity

\item[{\code{int index}}] \leavevmode
index into the list of display timings in devicetree

\end{description}

\textbf{Description}

This function is expensive and should only be used, if only one mode is to be
read from DT. To get multiple modes start with of\_get\_display\_timings and
work with that instead.

\textbf{Return}

0 on success, a negative errno code when no of videomode node was found.
\index{drm\_mode\_set\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_set_name}\pysiglinewithargsret{void \bfcode{drm\_mode\_set\_name}}{struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
set the name on a mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_display\_mode * mode}}] \leavevmode
name will be set in this mode

\end{description}

\textbf{Description}

Set the name of \textbf{mode} to a standard format which is \textless{}hdisplay\textgreater{}x\textless{}vdisplay\textgreater{}
with an optional `i' suffix for interlaced modes.
\index{drm\_mode\_hsync (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_hsync}\pysiglinewithargsret{int \bfcode{drm\_mode\_hsync}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
get the hsync of a mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
mode

\end{description}

\textbf{Return}

\textbf{modes}`s hsync rate in kHz, rounded to the nearest integer. Calculates the
value first if it is not yet set.
\index{drm\_mode\_vrefresh (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_vrefresh}\pysiglinewithargsret{int \bfcode{drm\_mode\_vrefresh}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
get the vrefresh of a mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
mode

\end{description}

\textbf{Return}

\textbf{modes}`s vrefresh rate in Hz, rounded to the nearest integer. Calculates the
value first if it is not yet set.
\index{drm\_mode\_get\_hv\_timing (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_get_hv_timing}\pysiglinewithargsret{void \bfcode{drm\_mode\_get\_hv\_timing}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}, int *\emph{ hdisplay}, int *\emph{ vdisplay}}{}
Fetches hdisplay/vdisplay for given mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
mode to query

\item[{\code{int * hdisplay}}] \leavevmode
hdisplay value to fill in

\item[{\code{int * vdisplay}}] \leavevmode
vdisplay value to fill in

\end{description}

\textbf{Description}

The vdisplay value will be doubled if the specified mode is a stereo mode of
the appropriate layout.
\index{drm\_mode\_set\_crtcinfo (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_set_crtcinfo}\pysiglinewithargsret{void \bfcode{drm\_mode\_set\_crtcinfo}}{struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ p}, int\emph{ adjust\_flags}}{}
set CRTC modesetting timing parameters

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_display\_mode * p}}] \leavevmode
mode

\item[{\code{int adjust\_flags}}] \leavevmode
a combination of adjustment flags

\end{description}

\textbf{Description}

Setup the CRTC modesetting timing parameters for \textbf{p}, adjusting if necessary.
\begin{itemize}
\item {} 
The CRTC\_INTERLACE\_HALVE\_V flag can be used to halve vertical timings of
interlaced modes.

\item {} 
The CRTC\_STEREO\_DOUBLE flag can be used to compute the timings for
buffers containing two eyes (only adjust the timings when needed, eg. for
``frame packing'' or ``side by side full'').

\item {} 
The CRTC\_NO\_DBLSCAN and CRTC\_NO\_VSCAN flags request that adjustment \emph{not}
be performed for doublescan and vscan \textgreater{} 1 modes respectively.

\end{itemize}
\index{drm\_mode\_copy (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_copy}\pysiglinewithargsret{void \bfcode{drm\_mode\_copy}}{struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ dst}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ src}}{}
copy the mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_display\_mode * dst}}] \leavevmode
mode to overwrite

\item[{\code{const struct drm\_display\_mode * src}}] \leavevmode
mode to copy

\end{description}

\textbf{Description}

Copy an existing mode into another mode, preserving the object id and
list head of the destination mode.
\index{drm\_mode\_duplicate (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_duplicate}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} * \bfcode{drm\_mode\_duplicate}}{struct drm\_device *\emph{ dev}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
allocate and duplicate an existing mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm\_device to allocate the duplicated mode for

\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
mode to duplicate

\end{description}

\textbf{Description}

Just allocate a new mode, copy the existing mode into it, and return
a pointer to it.  Used to create new instances of established modes.

\textbf{Return}

Pointer to duplicated mode on success, NULL on error.
\index{drm\_mode\_equal (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_equal}\pysiglinewithargsret{bool \bfcode{drm\_mode\_equal}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode1}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode2}}{}
test modes for equality

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_display\_mode * mode1}}] \leavevmode
first mode

\item[{\code{const struct drm\_display\_mode * mode2}}] \leavevmode
second mode

\end{description}

\textbf{Description}

Check to see if \textbf{mode1} and \textbf{mode2} are equivalent.

\textbf{Return}

True if the modes are equal, false otherwise.
\index{drm\_mode\_equal\_no\_clocks (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_equal_no_clocks}\pysiglinewithargsret{bool \bfcode{drm\_mode\_equal\_no\_clocks}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode1}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode2}}{}
test modes for equality

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_display\_mode * mode1}}] \leavevmode
first mode

\item[{\code{const struct drm\_display\_mode * mode2}}] \leavevmode
second mode

\end{description}

\textbf{Description}

Check to see if \textbf{mode1} and \textbf{mode2} are equivalent, but
don't check the pixel clocks.

\textbf{Return}

True if the modes are equal, false otherwise.
\index{drm\_mode\_equal\_no\_clocks\_no\_stereo (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_equal_no_clocks_no_stereo}\pysiglinewithargsret{bool \bfcode{drm\_mode\_equal\_no\_clocks\_no\_stereo}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode1}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode2}}{}
test modes for equality

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_display\_mode * mode1}}] \leavevmode
first mode

\item[{\code{const struct drm\_display\_mode * mode2}}] \leavevmode
second mode

\end{description}

\textbf{Description}

Check to see if \textbf{mode1} and \textbf{mode2} are equivalent, but
don't check the pixel clocks nor the stereo layout.

\textbf{Return}

True if the modes are equal, false otherwise.
\index{drm\_mode\_validate\_basic (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_validate_basic}\pysiglinewithargsret{enum {\hyperref[gpu/drm\string-kms:c.drm_mode_status]{\emph{drm\_mode\_status}}} \bfcode{drm\_mode\_validate\_basic}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
make sure the mode is somewhat sane

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
mode to check

\end{description}

\textbf{Description}

Check that the mode timings are at least somewhat reasonable.
Any hardware specific limits are left up for each driver to check.

\textbf{Return}

The mode status
\index{drm\_mode\_validate\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_validate_size}\pysiglinewithargsret{enum {\hyperref[gpu/drm\string-kms:c.drm_mode_status]{\emph{drm\_mode\_status}}} \bfcode{drm\_mode\_validate\_size}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}, int\emph{ maxX}, int\emph{ maxY}}{}
make sure modes adhere to size constraints

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
mode to check

\item[{\code{int maxX}}] \leavevmode
maximum width

\item[{\code{int maxY}}] \leavevmode
maximum height

\end{description}

\textbf{Description}

This function is a helper which can be used to validate modes against size
limitations of the DRM device/connector. If a mode is too big its status
member is updated with the appropriate validation failure code. The list
itself is not changed.

\textbf{Return}

The mode status
\index{drm\_mode\_validate\_ycbcr420 (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_validate_ycbcr420}\pysiglinewithargsret{enum {\hyperref[gpu/drm\string-kms:c.drm_mode_status]{\emph{drm\_mode\_status}}} \bfcode{drm\_mode\_validate\_ycbcr420}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}, struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
add `ycbcr420-only' modes only when allowed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
mode to check

\item[{\code{struct drm\_connector * connector}}] \leavevmode
drm connector under action

\end{description}

\textbf{Description}

This function is a helper which can be used to filter out any YCBCR420
only mode, when the source doesn't support it.

\textbf{Return}

The mode status
\index{drm\_mode\_prune\_invalid (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_prune_invalid}\pysiglinewithargsret{void \bfcode{drm\_mode\_prune\_invalid}}{struct drm\_device *\emph{ dev}, struct list\_head *\emph{ mode\_list}, bool\emph{ verbose}}{}
remove invalid modes from mode list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct list\_head * mode\_list}}] \leavevmode
list of modes to check

\item[{\code{bool verbose}}] \leavevmode
be verbose about it

\end{description}

\textbf{Description}

This helper function can be used to prune a display mode list after
validation has been completed. All modes who's status is not MODE\_OK will be
removed from the list, and if \textbf{verbose} the status code and mode name is also
printed to dmesg.
\index{drm\_mode\_sort (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_sort}\pysiglinewithargsret{void \bfcode{drm\_mode\_sort}}{struct list\_head *\emph{ mode\_list}}{}
sort mode list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct list\_head * mode\_list}}] \leavevmode
list of drm\_display\_mode structures to sort

\end{description}

\textbf{Description}

Sort \textbf{mode\_list} by favorability, moving good modes to the head of the list.
\index{drm\_mode\_connector\_list\_update (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_connector_list_update}\pysiglinewithargsret{void \bfcode{drm\_mode\_connector\_list\_update}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
update the mode list for the connector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
the connector to update

\end{description}

\textbf{Description}

This moves the modes from the \textbf{connector} probed\_modes list
to the actual mode list. It compares the probed mode against the current
list and only adds different/new modes.

This is just a helper functions doesn't validate any modes itself and also
doesn't prune any invalid modes. Callers need to do that themselves.
\index{drm\_mode\_parse\_command\_line\_for\_connector (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_parse_command_line_for_connector}\pysiglinewithargsret{bool \bfcode{drm\_mode\_parse\_command\_line\_for\_connector}}{const char *\emph{ mode\_option}, struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, struct drm\_cmdline\_mode *\emph{ mode}}{}
parse command line modeline for connector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * mode\_option}}] \leavevmode
optional per connector mode option

\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector to parse modeline for

\item[{\code{struct drm\_cmdline\_mode * mode}}] \leavevmode
preallocated drm\_cmdline\_mode structure to fill out

\end{description}

\textbf{Description}

This parses \textbf{mode\_option} command line modeline for modes and options to
configure the connector. If \textbf{mode\_option} is NULL the default command line
modeline in fb\_mode\_option will be parsed instead.

This uses the same parameters as the fb modedb.c, except for an extra
force-enable, force-enable-digital and force-disable bit at the end:

\textless{}xres\textgreater{}x\textless{}yres\textgreater{}{[}M{]}{[}R{]}{[}-\textless{}bpp\textgreater{}{]}{[}{\color{red}\bfseries{}**}{\color{red}\bfseries{}**}\textless{}refresh\textgreater{}{]}{[}i{]}{[}m{]}{[}eDd{]}

The intermediate drm\_cmdline\_mode structure is required to store additional
options from the command line modline like the force-enable/disable flag.

\textbf{Return}

True if a valid modeline has been parsed, false otherwise.
\index{drm\_mode\_create\_from\_cmdline\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_create_from_cmdline_mode}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} * \bfcode{drm\_mode\_create\_from\_cmdline\_mode}}{struct drm\_device *\emph{ dev}, struct drm\_cmdline\_mode *\emph{ cmd}}{}
convert a command line modeline into a DRM display mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device to create the new mode for

\item[{\code{struct drm\_cmdline\_mode * cmd}}] \leavevmode
input command line modeline

\end{description}

\textbf{Return}

Pointer to converted mode on success, NULL on error.
\index{drm\_mode\_is\_420\_only (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_is_420_only}\pysiglinewithargsret{bool \bfcode{drm\_mode\_is\_420\_only}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_display_info]{\emph{drm\_display\_info}}} *\emph{ display}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
if a given videomode can be only supported in YCBCR420 output format

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_display\_info * display}}] \leavevmode
display under action

\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
video mode to be tested.

\end{description}

\textbf{Return}

true if the mode can be supported in YCBCR420 format
false if not.
\index{drm\_mode\_is\_420\_also (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_is_420_also}\pysiglinewithargsret{bool \bfcode{drm\_mode\_is\_420\_also}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_display_info]{\emph{drm\_display\_info}}} *\emph{ display}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
if a given videomode can be supported in YCBCR420 output format also (along with RGB/YCBCR444/422)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_display\_info * display}}] \leavevmode
display under action.

\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
video mode to be tested.

\end{description}

\textbf{Return}

true if the mode can be support YCBCR420 format
false if not.
\index{drm\_mode\_is\_420 (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_is_420}\pysiglinewithargsret{bool \bfcode{drm\_mode\_is\_420}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_display_info]{\emph{drm\_display\_info}}} *\emph{ display}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
if a given videomode can be supported in YCBCR420 output format

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_display\_info * display}}] \leavevmode
display under action.

\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
video mode to be tested.

\end{description}

\textbf{Return}

true if the mode can be supported in YCBCR420 format
false if not.


\section{Connector Abstraction}
\label{gpu/drm-kms:connector-abstraction}
In DRM connectors are the general abstraction for display sinks, and include
als fixed panels or anything else that can display pixels in some form. As
opposed to all other KMS objects representing hardware (like CRTC, encoder or
plane abstractions) connectors can be hotplugged and unplugged at runtime.
Hence they are reference-counted using {\hyperref[gpu/drm\string-kms:c.drm_connector_get]{\emph{\code{drm\_connector\_get()}}}} and
{\hyperref[gpu/drm\string-kms:c.drm_connector_put]{\emph{\code{drm\_connector\_put()}}}}.

KMS driver must create, initialize, register and attach at a {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{struct
drm\_connector}}}} for each such sink. The instance is created as other KMS
objects and initialized by setting the following fields. The connector is
initialized with a call to {\hyperref[gpu/drm\string-kms:c.drm_connector_init]{\emph{\code{drm\_connector\_init()}}}} with a pointer to the
{\hyperref[gpu/drm\string-kms:c.drm_connector_funcs]{\emph{\code{struct drm\_connector\_funcs}}}} and a connector type, and then exposed to
userspace with a call to {\hyperref[gpu/drm\string-kms:c.drm_connector_register]{\emph{\code{drm\_connector\_register()}}}}.

Connectors must be attached to an encoder to be used. For devices that map
connectors to encoders 1:1, the connector should be attached at
initialization time with a call to {\hyperref[gpu/drm\string-kms:c.drm_mode_connector_attach_encoder]{\emph{\code{drm\_mode\_connector\_attach\_encoder()}}}}. The
driver must also set the {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.encoder}}}} field to point to the
attached encoder.

For connectors which are not fixed (like built-in panels) the driver needs to
support hotplug notifications. The simplest way to do that is by using the
probe helpers, see {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_kms_helper_poll_init]{\emph{\code{drm\_kms\_helper\_poll\_init()}}}} for connectors which don't have
hardware support for hotplug interrupts. Connectors with hardware hotplug
support can instead use e.g. {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_helper_hpd_irq_event]{\emph{\code{drm\_helper\_hpd\_irq\_event()}}}}.


\subsection{Connector Functions Reference}
\label{gpu/drm-kms:connector-functions-reference}\index{drm\_connector\_status (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_status}\pysigline{enum \bfcode{drm\_connector\_status}}
status for a {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector}}}}

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{connector\_status\_connected}}] \leavevmode
The connector is definitely connected to
a sink device, and can be enabled.

\item[{\code{connector\_status\_disconnected}}] \leavevmode
The connector isn't connected to a
sink device which can be autodetect. For digital outputs like DP or
HDMI (which can be realiable probed) this means there's really
nothing there. It is driver-dependent whether a connector with this
status can be lit up or not.

\item[{\code{connector\_status\_unknown}}] \leavevmode
The connector's status could not be
reliably detected. This happens when probing would either cause
flicker (like load-detection when the connector is in use), or when a
hardware resource isn't available (like when load-detection needs a
free CRTC). It should be possible to light up the connector with one
of the listed fallback modes. For default configuration userspace
should only try to light up connectors with unknown status when
there's not connector with \textbf{connector\_status\_connected}.

\end{description}

\textbf{Description}

This enum is used to track the connector status. There are no separate
\#defines for the uapi!
\index{drm\_scrambling (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_scrambling}\pysigline{struct \bfcode{drm\_scrambling}}
\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}scrambling \PYGZob{}
  bool supported;
  bool low\PYGZus{}rates;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{supported}}] \leavevmode
scrambling supported for rates \textgreater{} 340 Mhz.

\item[{\code{low\_rates}}] \leavevmode
scrambling supported for rates \textless{}= 340 Mhz.

\end{description}
\index{drm\_hdmi\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_hdmi_info}\pysigline{struct \bfcode{drm\_hdmi\_info}}
runtime information about the connected HDMI sink

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}hdmi\PYGZus{}info \PYGZob{}
  struct drm\PYGZus{}scdc scdc;
  unsigned long y420\PYGZus{}vdb\PYGZus{}modes[BITS\PYGZus{}TO\PYGZus{}LONGS(128)];
  unsigned long y420\PYGZus{}cmdb\PYGZus{}modes[BITS\PYGZus{}TO\PYGZus{}LONGS(128)];
  u64 y420\PYGZus{}cmdb\PYGZus{}map;
  u8 y420\PYGZus{}dc\PYGZus{}modes;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{scdc}}] \leavevmode
sink's scdc support and capabilities

\item[{\code{y420\_vdb\_modes}}] \leavevmode
bitmap of modes which can support ycbcr420
output only (not normal RGB/YCBCR444/422 outputs). There are total
107 VICs defined by CEA-861-F spec, so the size is 128 bits to map
upto 128 VICs;

\item[{\code{y420\_cmdb\_modes}}] \leavevmode
bitmap of modes which can support ycbcr420
output also, along with normal HDMI outputs. There are total 107
VICs defined by CEA-861-F spec, so the size is 128 bits to map upto
128 VICs;

\item[{\code{y420\_cmdb\_map}}] \leavevmode
bitmap of SVD index, to extraxt vcb modes

\item[{\code{y420\_dc\_modes}}] \leavevmode
bitmap of deep color support index

\end{description}

\textbf{Description}

Describes if a given display supports advanced HDMI 2.0 features.
This information is available in CEA-861-F extension blocks (like HF-VSDB).
\index{drm\_link\_status (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_link_status}\pysigline{enum \bfcode{drm\_link\_status}}
connector's link\_status property value

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{DRM\_LINK\_STATUS\_GOOD}}] \leavevmode
DP Link is Good as a result of successful
link training

\item[{\code{DRM\_LINK\_STATUS\_BAD}}] \leavevmode
DP Link is BAD as a result of link training
failure

\end{description}

\textbf{Description}

This enum is used as the connector's link status property value.
It is set to the values defined in uapi.
\index{drm\_panel\_orientation (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_panel_orientation}\pysigline{enum \bfcode{drm\_panel\_orientation}}
panel\_orientation info for {\hyperref[gpu/drm\string-kms:c.drm_display_info]{\emph{\code{drm\_display\_info}}}}

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{DRM\_MODE\_PANEL\_ORIENTATION\_UNKNOWN}}] \leavevmode
The drm driver has not provided any
panel orientation information (normal
for non panels) in this case the ``panel
orientation'' connector prop will not be
attached.

\item[{\code{DRM\_MODE\_PANEL\_ORIENTATION\_NORMAL}}] \leavevmode
The top side of the panel matches the
top side of the device's casing.

\item[{\code{DRM\_MODE\_PANEL\_ORIENTATION\_BOTTOM\_UP}}] \leavevmode
The top side of the panel matches the
bottom side of the device's casing, iow
the panel is mounted upside-down.

\item[{\code{DRM\_MODE\_PANEL\_ORIENTATION\_LEFT\_UP}}] \leavevmode
The left side of the panel matches the
top side of the device's casing.

\item[{\code{DRM\_MODE\_PANEL\_ORIENTATION\_RIGHT\_UP}}] \leavevmode
The right side of the panel matches the
top side of the device's casing.

\end{description}

\textbf{Description}

This enum is used to track the (LCD) panel orientation. There are no
separate \#defines for the uapi!
\index{drm\_display\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_display_info}\pysigline{struct \bfcode{drm\_display\_info}}
runtime data about the connected sink

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}display\PYGZus{}info \PYGZob{}
  char name[DRM\PYGZus{}DISPLAY\PYGZus{}INFO\PYGZus{}LEN];
  unsigned int width\PYGZus{}mm;
  unsigned int height\PYGZus{}mm;
  unsigned int pixel\PYGZus{}clock;
  unsigned int bpc;
  enum subpixel\PYGZus{}order subpixel\PYGZus{}order;
\PYGZsh{}define DRM\PYGZus{}COLOR\PYGZus{}FORMAT\PYGZus{}RGB444         (1\PYGZlt{}\PYGZlt{}0);
\PYGZsh{}define DRM\PYGZus{}COLOR\PYGZus{}FORMAT\PYGZus{}YCRCB444       (1\PYGZlt{}\PYGZlt{}1);
\PYGZsh{}define DRM\PYGZus{}COLOR\PYGZus{}FORMAT\PYGZus{}YCRCB422       (1\PYGZlt{}\PYGZlt{}2);
\PYGZsh{}define DRM\PYGZus{}COLOR\PYGZus{}FORMAT\PYGZus{}YCRCB420       (1\PYGZlt{}\PYGZlt{}3);
  int panel\PYGZus{}orientation;
  u32 color\PYGZus{}formats;
  const u32 *bus\PYGZus{}formats;
  unsigned int num\PYGZus{}bus\PYGZus{}formats;
\PYGZsh{}define DRM\PYGZus{}BUS\PYGZus{}FLAG\PYGZus{}DE\PYGZus{}LOW             (1\PYGZlt{}\PYGZlt{}0);
\PYGZsh{}define DRM\PYGZus{}BUS\PYGZus{}FLAG\PYGZus{}DE\PYGZus{}HIGH            (1\PYGZlt{}\PYGZlt{}1);
\PYGZsh{}define DRM\PYGZus{}BUS\PYGZus{}FLAG\PYGZus{}PIXDATA\PYGZus{}POSEDGE    (1\PYGZlt{}\PYGZlt{}2);
\PYGZsh{}define DRM\PYGZus{}BUS\PYGZus{}FLAG\PYGZus{}PIXDATA\PYGZus{}NEGEDGE    (1\PYGZlt{}\PYGZlt{}3);
\PYGZsh{}define DRM\PYGZus{}BUS\PYGZus{}FLAG\PYGZus{}DATA\PYGZus{}MSB\PYGZus{}TO\PYGZus{}LSB    (1\PYGZlt{}\PYGZlt{}4);
\PYGZsh{}define DRM\PYGZus{}BUS\PYGZus{}FLAG\PYGZus{}DATA\PYGZus{}LSB\PYGZus{}TO\PYGZus{}MSB    (1\PYGZlt{}\PYGZlt{}5);
  u32 bus\PYGZus{}flags;
  int max\PYGZus{}tmds\PYGZus{}clock;
  bool dvi\PYGZus{}dual;
  bool has\PYGZus{}hdmi\PYGZus{}infoframe;
  u8 edid\PYGZus{}hdmi\PYGZus{}dc\PYGZus{}modes;
  u8 cea\PYGZus{}rev;
  struct drm\PYGZus{}hdmi\PYGZus{}info hdmi;
  bool non\PYGZus{}desktop;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
Name of the display.

\item[{\code{width\_mm}}] \leavevmode
Physical width in mm.

\item[{\code{height\_mm}}] \leavevmode
Physical height in mm.

\item[{\code{pixel\_clock}}] \leavevmode
Maximum pixel clock supported by the sink, in units of
100Hz. This mismatches the clock in {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{\code{drm\_display\_mode}}}} (which is in
kHZ), because that's what the EDID uses as base unit.

\item[{\code{bpc}}] \leavevmode
Maximum bits per color channel. Used by HDMI and DP outputs.

\item[{\code{subpixel\_order}}] \leavevmode
Subpixel order of LCD panels.

\item[{\code{panel\_orientation}}] \leavevmode
Read only connector property for built-in panels,
indicating the orientation of the panel vs the device's casing.
{\hyperref[gpu/drm\string-kms:c.drm_connector_init]{\emph{\code{drm\_connector\_init()}}}} sets this to DRM\_MODE\_PANEL\_ORIENTATION\_UNKNOWN.
When not UNKNOWN this gets used by the drm\_fb\_helpers to rotate the
fb to compensate and gets exported as prop to userspace.

\item[{\code{color\_formats}}] \leavevmode
HDMI Color formats, selects between RGB and YCrCb
modes. Used DRM\_COLOR\_FORMAT\_ defines, which are \_not\_ the same ones
as used to describe the pixel format in framebuffers, and also don't
match the formats in \textbf{bus\_formats} which are shared with v4l.

\item[{\code{bus\_formats}}] \leavevmode
Pixel data format on the wire, somewhat redundant with
\textbf{color\_formats}. Array of size \textbf{num\_bus\_formats} encoded using
MEDIA\_BUS\_FMT\_ defines shared with v4l and media drivers.

\item[{\code{num\_bus\_formats}}] \leavevmode
Size of \textbf{bus\_formats} array.

\item[{\code{bus\_flags}}] \leavevmode
Additional information (like pixel signal polarity) for
the pixel data on the bus, using DRM\_BUS\_FLAGS\_ defines.

\item[{\code{max\_tmds\_clock}}] \leavevmode
Maximum TMDS clock rate supported by the
sink in kHz. 0 means undefined.

\item[{\code{dvi\_dual}}] \leavevmode
Dual-link DVI sink?

\item[{\code{has\_hdmi\_infoframe}}] \leavevmode
Does the sink support the HDMI infoframe?

\item[{\code{edid\_hdmi\_dc\_modes}}] \leavevmode
Mask of supported hdmi deep color modes. Even
more stuff redundant with \textbf{bus\_formats}.

\item[{\code{cea\_rev}}] \leavevmode
CEA revision of the HDMI sink.

\item[{\code{hdmi}}] \leavevmode
advance features of a HDMI sink.

\item[{\code{non\_desktop}}] \leavevmode
Non desktop display (HMD).

\end{description}

\textbf{Description}

Describes a given display (e.g. CRT or flat panel) and its limitations. For
fixed display sinks like built-in panels there's not much difference between
this and {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{struct drm\_connector}}}}. But for sinks with a real cable this
structure is meant to describe all the things at the other end of the cable.

For sinks which provide an EDID this can be filled out by calling
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_add_edid_modes]{\emph{\code{drm\_add\_edid\_modes()}}}}.
\index{drm\_tv\_connector\_state (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_tv_connector_state}\pysigline{struct \bfcode{drm\_tv\_connector\_state}}
TV connector related states

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}tv\PYGZus{}connector\PYGZus{}state \PYGZob{}
  enum drm\PYGZus{}mode\PYGZus{}subconnector subconnector;
  struct \PYGZob{}
    unsigned int left;
    unsigned int right;
    unsigned int top;
    unsigned int bottom;
  \PYGZcb{} margins;
  unsigned int mode;
  unsigned int brightness;
  unsigned int contrast;
  unsigned int flicker\PYGZus{}reduction;
  unsigned int overscan;
  unsigned int saturation;
  unsigned int hue;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{subconnector}}] \leavevmode
selected subconnector

\item[{\code{margins}}] \leavevmode
left/right/top/bottom margins

\item[{\code{mode}}] \leavevmode
TV mode

\item[{\code{brightness}}] \leavevmode
brightness in percent

\item[{\code{contrast}}] \leavevmode
contrast in percent

\item[{\code{flicker\_reduction}}] \leavevmode
flicker reduction in percent

\item[{\code{overscan}}] \leavevmode
overscan in percent

\item[{\code{saturation}}] \leavevmode
saturation in percent

\item[{\code{hue}}] \leavevmode
hue in percent

\end{description}
\index{drm\_connector\_state (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_state}\pysigline{struct \bfcode{drm\_connector\_state}}
mutable connector state

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}connector\PYGZus{}state \PYGZob{}
  struct drm\PYGZus{}connector *connector;
  struct drm\PYGZus{}crtc *crtc;
  struct drm\PYGZus{}encoder *best\PYGZus{}encoder;
  enum drm\PYGZus{}link\PYGZus{}status link\PYGZus{}status;
  struct drm\PYGZus{}atomic\PYGZus{}state *state;
  struct drm\PYGZus{}crtc\PYGZus{}commit *commit;
  struct drm\PYGZus{}tv\PYGZus{}connector\PYGZus{}state tv;
  enum hdmi\PYGZus{}picture\PYGZus{}aspect picture\PYGZus{}aspect\PYGZus{}ratio;
  unsigned int scaling\PYGZus{}mode;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{connector}}] \leavevmode
backpointer to the connector

\item[{\code{crtc}}] \leavevmode
CRTC to connect connector to, NULL if disabled.

Do not change this directly, use {\hyperref[gpu/drm\string-kms:c.drm_atomic_set_crtc_for_connector]{\emph{\code{drm\_atomic\_set\_crtc\_for\_connector()}}}}
instead.

\item[{\code{best\_encoder}}] \leavevmode
can be used by helpers and drivers to select the encoder

\item[{\code{link\_status}}] \leavevmode
Connector link\_status to keep track of whether link is
GOOD or BAD to notify userspace if retraining is necessary.

\item[{\code{state}}] \leavevmode
backpointer to global drm\_atomic\_state

\item[{\code{commit}}] \leavevmode
Tracks the pending commit to prevent use-after-free conditions.

Is only set when \textbf{crtc} is NULL.

\item[{\code{tv}}] \leavevmode
TV connector state

\item[{\code{picture\_aspect\_ratio}}] \leavevmode
Connector property to control the
HDMI infoframe aspect ratio setting.

The \code{DRM\_MODE\_PICTURE\_ASPECT\_}* values much match the
values for \code{enum hdmi\_picture\_aspect}

\item[{\code{scaling\_mode}}] \leavevmode
Connector property to control the
upscaling, mostly used for built-in panels.

\end{description}
\index{drm\_connector\_funcs (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_funcs}\pysigline{struct \bfcode{drm\_connector\_funcs}}
control connectors on a given device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}connector\PYGZus{}funcs \PYGZob{}
  int (*dpms)(struct drm\PYGZus{}connector *connector, int mode);
  void (*reset)(struct drm\PYGZus{}connector *connector);
  enum drm\PYGZus{}connector\PYGZus{}status (*detect)(struct drm\PYGZus{}connector *connector, bool force);
  void (*force)(struct drm\PYGZus{}connector *connector);
  int (*fill\PYGZus{}modes)(struct drm\PYGZus{}connector *connector, uint32\PYGZus{}t max\PYGZus{}width, uint32\PYGZus{}t max\PYGZus{}height);
  int (*set\PYGZus{}property)(struct drm\PYGZus{}connector *connector, struct drm\PYGZus{}property *property, uint64\PYGZus{}t val);
  int (*late\PYGZus{}register)(struct drm\PYGZus{}connector *connector);
  void (*early\PYGZus{}unregister)(struct drm\PYGZus{}connector *connector);
  void (*destroy)(struct drm\PYGZus{}connector *connector);
  struct drm\PYGZus{}connector\PYGZus{}state *(*atomic\PYGZus{}duplicate\PYGZus{}state)(struct drm\PYGZus{}connector *connector);
  void (*atomic\PYGZus{}destroy\PYGZus{}state)(struct drm\PYGZus{}connector *connector, struct drm\PYGZus{}connector\PYGZus{}state *state);
  int (*atomic\PYGZus{}set\PYGZus{}property)(struct drm\PYGZus{}connector *connector,struct drm\PYGZus{}connector\PYGZus{}state *state,struct drm\PYGZus{}property *property, uint64\PYGZus{}t val);
  int (*atomic\PYGZus{}get\PYGZus{}property)(struct drm\PYGZus{}connector *connector,const struct drm\PYGZus{}connector\PYGZus{}state *state,struct drm\PYGZus{}property *property, uint64\PYGZus{}t *val);
  void (*atomic\PYGZus{}print\PYGZus{}state)(struct drm\PYGZus{}printer *p, const struct drm\PYGZus{}connector\PYGZus{}state *state);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dpms}}] \leavevmode
Legacy entry point to set the per-connector DPMS state. Legacy DPMS
is exposed as a standard property on the connector, but diverted to
this callback in the drm core. Note that atomic drivers don't
implement the 4 level DPMS support on the connector any more, but
instead only have an on/off ``ACTIVE'' property on the CRTC object.

This hook is not used by atomic drivers, remapping of the legacy DPMS
property is entirely handled in the DRM core.

RETURNS:

0 on success or a negative error code on failure.

\item[{\code{reset}}] \leavevmode
Reset connector hardware and software state to off. This function isn't
called by the core directly, only through {\hyperref[gpu/drm\string-kms:c.drm_mode_config_reset]{\emph{\code{drm\_mode\_config\_reset()}}}}.
It's not a helper hook only for historical reasons.

Atomic drivers can use {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_connector_reset]{\emph{\code{drm\_atomic\_helper\_connector\_reset()}}}} to reset
atomic state using this hook.

\item[{\code{detect}}] \leavevmode
Check to see if anything is attached to the connector. The parameter
force is set to false whilst polling, true when checking the
connector due to a user request. force can be used by the driver to
avoid expensive, destructive operations during automated probing.

This callback is optional, if not implemented the connector will be
considered as always being attached.

FIXME:

Note that this hook is only called by the probe helper. It's not in
the helper library vtable purely for historical reasons. The only DRM
core entry point to probe connector state is \textbf{fill\_modes}.

Note that the helper library will already hold
{\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.connection\_mutex}}}}. Drivers which need to grab additional
locks to avoid races with concurrent modeset changes need to use
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_connector_helper_funcs]{\emph{\code{drm\_connector\_helper\_funcs.detect\_ctx}}}} instead.

RETURNS:

drm\_connector\_status indicating the connector's status.

\item[{\code{force}}] \leavevmode
This function is called to update internal encoder state when the
connector is forced to a certain state by userspace, either through
the sysfs interfaces or on the kernel cmdline. In that case the
\textbf{detect} callback isn't called.

FIXME:

Note that this hook is only called by the probe helper. It's not in
the helper library vtable purely for historical reasons. The only DRM
core entry point to probe connector state is \textbf{fill\_modes}.

\item[{\code{fill\_modes}}] \leavevmode
Entry point for output detection and basic mode validation. The
driver should reprobe the output if needed (e.g. when hotplug
handling is unreliable), add all detected modes to {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.modes}}}}
and filter out any the device can't support in any configuration. It
also needs to filter out any modes wider or higher than the
parameters max\_width and max\_height indicate.

The drivers must also prune any modes no longer valid from
{\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.modes}}}}. Furthermore it must update
{\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.status}}}} and {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.edid}}}}.  If no EDID has been
received for this output connector-\textgreater{}edid must be NULL.

Drivers using the probe helpers should use
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_helper_probe_single_connector_modes]{\emph{\code{drm\_helper\_probe\_single\_connector\_modes()}}}} or
\code{drm\_helper\_probe\_single\_connector\_modes\_nomerge()} to implement this
function.

RETURNS:

The number of modes detected and filled into {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.modes}}}}.

\item[{\code{set\_property}}] \leavevmode
This is the legacy entry point to update a property attached to the
connector.

This callback is optional if the driver does not support any legacy
driver-private properties. For atomic drivers it is not used because
property handling is done entirely in the DRM core.

RETURNS:

0 on success or a negative error code on failure.

\item[{\code{late\_register}}] \leavevmode
This optional hook can be used to register additional userspace
interfaces attached to the connector, light backlight control, i2c,
DP aux or similar interfaces. It is called late in the driver load
sequence from {\hyperref[gpu/drm\string-kms:c.drm_connector_register]{\emph{\code{drm\_connector\_register()}}}} when registering all the
core drm connector interfaces. Everything added from this callback
should be unregistered in the early\_unregister callback.

This is called while holding {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.mutex}}}}.

Returns:

0 on success, or a negative error code on failure.

\item[{\code{early\_unregister}}] \leavevmode
This optional hook should be used to unregister the additional
userspace interfaces attached to the connector from
\code{late\_register()}. It is called from {\hyperref[gpu/drm\string-kms:c.drm_connector_unregister]{\emph{\code{drm\_connector\_unregister()}}}},
early in the driver unload sequence to disable userspace access
before data structures are torndown.

This is called while holding {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.mutex}}}}.

\item[{\code{destroy}}] \leavevmode
Clean up connector resources. This is called at driver unload time
through {\hyperref[gpu/drm\string-kms:c.drm_mode_config_cleanup]{\emph{\code{drm\_mode\_config\_cleanup()}}}}. It can also be called at runtime
when a connector is being hot-unplugged for drivers that support
connector hotplugging (e.g. DisplayPort MST).

\item[{\code{atomic\_duplicate\_state}}] \leavevmode
Duplicate the current atomic state for this connector and return it.
The core and helpers guarantee that any atomic state duplicated with
this hook and still owned by the caller (i.e. not transferred to the
driver by calling {\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.atomic\_commit}}}}) will be
cleaned up by calling the \textbf{atomic\_destroy\_state} hook in this
structure.

Atomic drivers which don't subclass {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{\code{struct drm\_connector\_state}}}} should use
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_connector_duplicate_state]{\emph{\code{drm\_atomic\_helper\_connector\_duplicate\_state()}}}}. Drivers that subclass the
state structure to extend it with driver-private state should use
{\hyperref[gpu/drm\string-kms\string-helpers:c.__drm_atomic_helper_connector_duplicate_state]{\emph{\code{\_\_drm\_atomic\_helper\_connector\_duplicate\_state()}}}} to make sure shared state is
duplicated in a consistent fashion across drivers.

It is an error to call this hook before {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.state}}}} has been
initialized correctly.

NOTE:

If the duplicate state references refcounted resources this hook must
acquire a reference for each of them. The driver must release these
references again in \textbf{atomic\_destroy\_state}.

RETURNS:

Duplicated atomic state or NULL when the allocation failed.

\item[{\code{atomic\_destroy\_state}}] \leavevmode
Destroy a state duplicated with \textbf{atomic\_duplicate\_state} and release
or unreference all resources it references

\item[{\code{atomic\_set\_property}}] \leavevmode
Decode a driver-private property value and store the decoded value
into the passed-in state structure. Since the atomic core decodes all
standardized properties (even for extensions beyond the core set of
properties which might not be implemented by all drivers) this
requires drivers to subclass the state structure.

Such driver-private properties should really only be implemented for
truly hardware/vendor specific state. Instead it is preferred to
standardize atomic extension and decode the properties used to expose
such an extension in the core.

Do not call this function directly, use
\code{drm\_atomic\_connector\_set\_property()} instead.

This callback is optional if the driver does not support any
driver-private atomic properties.

NOTE:

This function is called in the state assembly phase of atomic
modesets, which can be aborted for any reason (including on
userspace's request to just check whether a configuration would be
possible). Drivers MUST NOT touch any persistent state (hardware or
software) or data structures except the passed in \textbf{state} parameter.

Also since userspace controls in which order properties are set this
function must not do any input validation (since the state update is
incomplete and hence likely inconsistent). Instead any such input
validation must be done in the various atomic\_check callbacks.

RETURNS:

0 if the property has been found, -EINVAL if the property isn't
implemented by the driver (which shouldn't ever happen, the core only
asks for properties attached to this connector). No other validation
is allowed by the driver. The core already checks that the property
value is within the range (integer, valid enum value, ...) the driver
set when registering the property.

\item[{\code{atomic\_get\_property}}] \leavevmode
Reads out the decoded driver-private property. This is used to
implement the GETCONNECTOR IOCTL.

Do not call this function directly, use
\code{drm\_atomic\_connector\_get\_property()} instead.

This callback is optional if the driver does not support any
driver-private atomic properties.

RETURNS:

0 on success, -EINVAL if the property isn't implemented by the
driver (which shouldn't ever happen, the core only asks for
properties attached to this connector).

\item[{\code{atomic\_print\_state}}] \leavevmode
If driver subclasses {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{\code{struct drm\_connector\_state}}}}, it should implement
this optional hook for printing additional driver specific state.

Do not call this directly, use \code{drm\_atomic\_connector\_print\_state()}
instead.

\end{description}

\textbf{Description}

Each CRTC may have one or more connectors attached to it.  The functions
below allow the core DRM code to control connectors, enumerate available modes,
etc.
\index{drm\_connector (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector}\pysigline{struct \bfcode{drm\_connector}}
central DRM connector control structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}connector \PYGZob{}
  struct drm\PYGZus{}device *dev;
  struct device *kdev;
  struct device\PYGZus{}attribute *attr;
  struct list\PYGZus{}head head;
  struct drm\PYGZus{}mode\PYGZus{}object base;
  char *name;
  struct mutex mutex;
  unsigned index;
  int connector\PYGZus{}type;
  int connector\PYGZus{}type\PYGZus{}id;
  bool interlace\PYGZus{}allowed;
  bool doublescan\PYGZus{}allowed;
  bool stereo\PYGZus{}allowed;
  bool ycbcr\PYGZus{}420\PYGZus{}allowed;
  bool registered;
  struct list\PYGZus{}head modes;
  enum drm\PYGZus{}connector\PYGZus{}status status;
  struct list\PYGZus{}head probed\PYGZus{}modes;
  struct drm\PYGZus{}display\PYGZus{}info display\PYGZus{}info;
  const struct drm\PYGZus{}connector\PYGZus{}funcs *funcs;
  struct drm\PYGZus{}property\PYGZus{}blob *edid\PYGZus{}blob\PYGZus{}ptr;
  struct drm\PYGZus{}object\PYGZus{}properties properties;
  struct drm\PYGZus{}property *scaling\PYGZus{}mode\PYGZus{}property;
  struct drm\PYGZus{}property\PYGZus{}blob *path\PYGZus{}blob\PYGZus{}ptr;
  struct drm\PYGZus{}property\PYGZus{}blob *tile\PYGZus{}blob\PYGZus{}ptr;
\PYGZsh{}define DRM\PYGZus{}CONNECTOR\PYGZus{}POLL\PYGZus{}HPD (1 \PYGZlt{}\PYGZlt{} 0);
\PYGZsh{}define DRM\PYGZus{}CONNECTOR\PYGZus{}POLL\PYGZus{}CONNECT (1 \PYGZlt{}\PYGZlt{} 1);
\PYGZsh{}define DRM\PYGZus{}CONNECTOR\PYGZus{}POLL\PYGZus{}DISCONNECT (1 \PYGZlt{}\PYGZlt{} 2);
  uint8\PYGZus{}t polled;
  int dpms;
  const struct drm\PYGZus{}connector\PYGZus{}helper\PYGZus{}funcs *helper\PYGZus{}private;
  struct drm\PYGZus{}cmdline\PYGZus{}mode cmdline\PYGZus{}mode;
  enum drm\PYGZus{}connector\PYGZus{}force force;
  bool override\PYGZus{}edid;
\PYGZsh{}define DRM\PYGZus{}CONNECTOR\PYGZus{}MAX\PYGZus{}ENCODER 3;
  uint32\PYGZus{}t encoder\PYGZus{}ids[DRM\PYGZus{}CONNECTOR\PYGZus{}MAX\PYGZus{}ENCODER];
  struct drm\PYGZus{}encoder *encoder;
\PYGZsh{}define MAX\PYGZus{}ELD\PYGZus{}BYTES   128;
  uint8\PYGZus{}t eld[MAX\PYGZus{}ELD\PYGZus{}BYTES];
  bool latency\PYGZus{}present[2];
  int video\PYGZus{}latency[2];
  int audio\PYGZus{}latency[2];
  int null\PYGZus{}edid\PYGZus{}counter;
  unsigned bad\PYGZus{}edid\PYGZus{}counter;
  bool edid\PYGZus{}corrupt;
  struct dentry *debugfs\PYGZus{}entry;
  struct drm\PYGZus{}connector\PYGZus{}state *state;
  bool has\PYGZus{}tile;
  struct drm\PYGZus{}tile\PYGZus{}group *tile\PYGZus{}group;
  bool tile\PYGZus{}is\PYGZus{}single\PYGZus{}monitor;
  uint8\PYGZus{}t num\PYGZus{}h\PYGZus{}tile, num\PYGZus{}v\PYGZus{}tile;
  uint8\PYGZus{}t tile\PYGZus{}h\PYGZus{}loc, tile\PYGZus{}v\PYGZus{}loc;
  uint16\PYGZus{}t tile\PYGZus{}h\PYGZus{}size, tile\PYGZus{}v\PYGZus{}size;
  struct llist\PYGZus{}node free\PYGZus{}node;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev}}] \leavevmode
parent DRM device

\item[{\code{kdev}}] \leavevmode
kernel device for sysfs attributes

\item[{\code{attr}}] \leavevmode
sysfs attributes

\item[{\code{head}}] \leavevmode
list management

\item[{\code{base}}] \leavevmode
base KMS object

\item[{\code{name}}] \leavevmode
human readable name, can be overwritten by the driver

\item[{\code{mutex}}] \leavevmode
Lock for general connector state, but currently only protects
\textbf{registered}. Most of the connector state is still protected by
{\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.mutex}}}}.

\item[{\code{index}}] \leavevmode
Compacted connector index, which matches the position inside
the mode\_config.list for drivers not supporting hot-add/removing. Can
be used as an array index. It is invariant over the lifetime of the
connector.

\item[{\code{connector\_type}}] \leavevmode
one of the DRM\_MODE\_CONNECTOR\_\textless{}foo\textgreater{} types from drm\_mode.h

\item[{\code{connector\_type\_id}}] \leavevmode
index into connector type enum

\item[{\code{interlace\_allowed}}] \leavevmode
can this connector handle interlaced modes?

\item[{\code{doublescan\_allowed}}] \leavevmode
can this connector handle doublescan?

\item[{\code{stereo\_allowed}}] \leavevmode
can this connector handle stereo modes?

\item[{\code{ycbcr\_420\_allowed}}] \leavevmode
This bool indicates if this connector is
capable of handling YCBCR 420 output. While parsing the EDID
blocks, its very helpful to know, if the source is capable of
handling YCBCR 420 outputs.

\item[{\code{registered}}] \leavevmode
Is this connector exposed (registered) with userspace?
Protected by \textbf{mutex}.

\item[{\code{modes}}] \leavevmode
Modes available on this connector (from \code{fill\_modes()} + user).
Protected by {\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.mutex}}}}.

\item[{\code{status}}] \leavevmode
One of the drm\_connector\_status enums (connected, not, or unknown).
Protected by {\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.mutex}}}}.

\item[{\code{probed\_modes}}] \leavevmode
These are modes added by probing with DDC or the BIOS, before
filtering is applied. Used by the probe helpers. Protected by
{\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.mutex}}}}.

\item[{\code{display\_info}}] \leavevmode
Display information is filled from EDID information
when a display is detected. For non hot-pluggable displays such as
flat panels in embedded systems, the driver should initialize the
{\hyperref[gpu/drm\string-kms:c.drm_display_info]{\emph{\code{drm\_display\_info.width\_mm}}}} and {\hyperref[gpu/drm\string-kms:c.drm_display_info]{\emph{\code{drm\_display\_info.height\_mm}}}} fields
with the physical size of the display.

Protected by {\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.mutex}}}}.

\item[{\code{funcs}}] \leavevmode
connector control functions

\item[{\code{edid\_blob\_ptr}}] \leavevmode
DRM property containing EDID if present

\item[{\code{properties}}] \leavevmode
property tracking for this connector

\item[{\code{scaling\_mode\_property}}] \leavevmode
Optional atomic property to control the upscaling.

\item[{\code{path\_blob\_ptr}}] \leavevmode
DRM blob property data for the DP MST path property.

\item[{\code{tile\_blob\_ptr}}] \leavevmode
DRM blob property data for the tile property (used mostly by DP MST).
This is meant for screens which are driven through separate display
pipelines represented by {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}}, which might not be running with
genlocked clocks. For tiled panels which are genlocked, like
dual-link LVDS or dual-link DSI, the driver should try to not expose
the tiling and virtualize both {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} and {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{drm\_plane}}}} if needed.

\item[{\code{polled}}] \leavevmode
Connector polling mode, a combination of
\begin{description}
\item[{DRM\_CONNECTOR\_POLL\_HPD}] \leavevmode
The connector generates hotplug events and doesn't need to be
periodically polled. The CONNECT and DISCONNECT flags must not
be set together with the HPD flag.

\item[{DRM\_CONNECTOR\_POLL\_CONNECT}] \leavevmode
Periodically poll the connector for connection.

\item[{DRM\_CONNECTOR\_POLL\_DISCONNECT}] \leavevmode
Periodically poll the connector for disconnection.

\end{description}

Set to 0 for connectors that don't support connection status
discovery.

\item[{\code{dpms}}] \leavevmode
current dpms state

\item[{\code{helper\_private}}] \leavevmode
mid-layer private data

\item[{\code{cmdline\_mode}}] \leavevmode
mode line parsed from the kernel cmdline for this connector

\item[{\code{force}}] \leavevmode
a DRM\_FORCE\_\textless{}foo\textgreater{} state for forced mode sets

\item[{\code{override\_edid}}] \leavevmode
has the EDID been overwritten through debugfs for testing?

\item[{\code{encoder\_ids}}] \leavevmode
valid encoders for this connector

\item[{\code{encoder}}] \leavevmode
Currently bound encoder driving this connector, if any.
Only really meaningful for non-atomic drivers. Atomic drivers should
instead look at {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{\code{drm\_connector\_state.best\_encoder}}}}, and in case they
need the CRTC driving this output, {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{\code{drm\_connector\_state.crtc}}}}.

\item[{\code{eld}}] \leavevmode
EDID-like data, if present

\item[{\code{latency\_present}}] \leavevmode
AV delay info from ELD, if found

\item[{\code{video\_latency}}] \leavevmode
video latency info from ELD, if found

\item[{\code{audio\_latency}}] \leavevmode
audio latency info from ELD, if found

\item[{\code{null\_edid\_counter}}] \leavevmode
track sinks that give us all zeros for the EDID

\item[{\code{bad\_edid\_counter}}] \leavevmode
track sinks that give us an EDID with invalid checksum

\item[{\code{edid\_corrupt}}] \leavevmode
indicates whether the last read EDID was corrupt

\item[{\code{debugfs\_entry}}] \leavevmode
debugfs directory for this connector

\item[{\code{state}}] \leavevmode
Current atomic state for this connector.

This is protected by \textbf{drm\_mode\_config.connection\_mutex}. Note that
nonblocking atomic commits access the current connector state without
taking locks. Either by going through the {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{struct drm\_atomic\_state}}}}
pointers, see {\hyperref[gpu/drm\string-kms:c.for_each_oldnew_connector_in_state]{\emph{\code{for\_each\_oldnew\_connector\_in\_state()}}}},
{\hyperref[gpu/drm\string-kms:c.for_each_old_connector_in_state]{\emph{\code{for\_each\_old\_connector\_in\_state()}}}} and
{\hyperref[gpu/drm\string-kms:c.for_each_new_connector_in_state]{\emph{\code{for\_each\_new\_connector\_in\_state()}}}}. Or through careful ordering of
atomic commit operations as implemented in the atomic helpers, see
{\hyperref[gpu/drm\string-kms:c.drm_crtc_commit]{\emph{\code{struct drm\_crtc\_commit}}}}.

\item[{\code{has\_tile}}] \leavevmode
is this connector connected to a tiled monitor

\item[{\code{tile\_group}}] \leavevmode
tile group for the connected monitor

\item[{\code{tile\_is\_single\_monitor}}] \leavevmode
whether the tile is one monitor housing

\item[{\code{num\_h\_tile}}] \leavevmode
number of horizontal tiles in the tile group

\item[{\code{num\_v\_tile}}] \leavevmode
number of vertical tiles in the tile group

\item[{\code{tile\_h\_loc}}] \leavevmode
horizontal location of this tile

\item[{\code{tile\_v\_loc}}] \leavevmode
vertical location of this tile

\item[{\code{tile\_h\_size}}] \leavevmode
horizontal size of this tile.

\item[{\code{tile\_v\_size}}] \leavevmode
vertical size of this tile.

\item[{\code{free\_node}}] \leavevmode
List used only by \code{drm\_connector\_iter} to be able to clean up a
connector from any context, in conjunction with
{\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.connector\_free\_work}}}}.

\end{description}

\textbf{Description}

Each connector may be connected to one or more CRTCs, or may be clonable by
another connector if they can share a CRTC.  Each connector also has a specific
position in the broader display (referred to as a `screen' though it could
span multiple monitors).
\index{drm\_connector\_lookup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_lookup}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} * \bfcode{drm\_connector\_lookup}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}, uint32\_t\emph{ id}}{}
lookup connector object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
drm file to check for lease against.

\item[{\code{uint32\_t id}}] \leavevmode
connector object id

\end{description}

\textbf{Description}

This function looks up the connector object specified by id
add takes a reference to it.
\index{drm\_connector\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_get}\pysiglinewithargsret{void \bfcode{drm\_connector\_get}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
acquire a connector reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
DRM connector

\end{description}

\textbf{Description}

This function increments the connector's refcount.
\index{drm\_connector\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_put}\pysiglinewithargsret{void \bfcode{drm\_connector\_put}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
release a connector reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
DRM connector

\end{description}

\textbf{Description}

This function decrements the connector's reference count and frees the
object if the reference count drops to zero.
\index{drm\_connector\_reference (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_reference}\pysiglinewithargsret{void \bfcode{drm\_connector\_reference}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
acquire a connector reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
DRM connector

\end{description}

\textbf{Description}

This is a compatibility alias for {\hyperref[gpu/drm\string-kms:c.drm_connector_get]{\emph{\code{drm\_connector\_get()}}}} and should not be
used by new code.
\index{drm\_connector\_unreference (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_unreference}\pysiglinewithargsret{void \bfcode{drm\_connector\_unreference}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
release a connector reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
DRM connector

\end{description}

\textbf{Description}

This is a compatibility alias for {\hyperref[gpu/drm\string-kms:c.drm_connector_put]{\emph{\code{drm\_connector\_put()}}}} and should not be
used by new code.
\index{drm\_tile\_group (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_tile_group}\pysigline{struct \bfcode{drm\_tile\_group}}
Tile group metadata

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}tile\PYGZus{}group \PYGZob{}
  struct kref refcount;
  struct drm\PYGZus{}device *dev;
  int id;
  u8 group\PYGZus{}data[8];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{refcount}}] \leavevmode
reference count

\item[{\code{dev}}] \leavevmode
DRM device

\item[{\code{id}}] \leavevmode
tile group id exposed to userspace

\item[{\code{group\_data}}] \leavevmode
Sink-private data identifying this group

\end{description}

\textbf{Description}

\textbf{group\_data} corresponds to displayid vend/prod/serial for external screens
with an EDID.
\index{drm\_connector\_list\_iter (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_list_iter}\pysigline{struct \bfcode{drm\_connector\_list\_iter}}
connector\_list iterator

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}connector\PYGZus{}list\PYGZus{}iter \PYGZob{}
\PYGZcb{};
\end{Verbatim}

\textbf{Members}

\textbf{Description}

This iterator tracks state needed to be able to walk the connector\_list
within struct drm\_mode\_config. Only use together with
{\hyperref[gpu/drm\string-kms:c.drm_connector_list_iter_begin]{\emph{\code{drm\_connector\_list\_iter\_begin()}}}}, {\hyperref[gpu/drm\string-kms:c.drm_connector_list_iter_end]{\emph{\code{drm\_connector\_list\_iter\_end()}}}} and
{\hyperref[gpu/drm\string-kms:c.drm_connector_list_iter_next]{\emph{\code{drm\_connector\_list\_iter\_next()}}}} respectively the convenience macro
{\hyperref[gpu/drm\string-kms:c.drm_for_each_connector_iter]{\emph{\code{drm\_for\_each\_connector\_iter()}}}}.
\index{drm\_for\_each\_connector\_iter (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_for_each_connector_iter}\pysiglinewithargsret{\bfcode{drm\_for\_each\_connector\_iter}}{\emph{connector}, \emph{iter}}{}
connector\_list iterator macro

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{connector}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{struct drm\_connector}}}} pointer used as cursor

\item[{\code{iter}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_connector_list_iter]{\emph{\code{struct drm\_connector\_list\_iter}}}}

\end{description}

\textbf{Description}

Note that \textbf{connector} is only valid within the list body, if you want to use
\textbf{connector} after calling {\hyperref[gpu/drm\string-kms:c.drm_connector_list_iter_end]{\emph{\code{drm\_connector\_list\_iter\_end()}}}} then you need to grab
your own reference first using {\hyperref[gpu/drm\string-kms:c.drm_connector_get]{\emph{\code{drm\_connector\_get()}}}}.
\index{drm\_connector\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_init}\pysiglinewithargsret{int \bfcode{drm\_connector\_init}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, const struct {\hyperref[gpu/drm\string-kms:c.drm_connector_funcs]{\emph{drm\_connector\_funcs}}} *\emph{ funcs}, int\emph{ connector\_type}}{}
Init a preallocated connector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_connector * connector}}] \leavevmode
the connector to init

\item[{\code{const struct drm\_connector\_funcs * funcs}}] \leavevmode
callbacks for this connector

\item[{\code{int connector\_type}}] \leavevmode
user visible type of the connector

\end{description}

\textbf{Description}

Initialises a preallocated connector. Connectors should be
subclassed as part of driver connector objects.

\textbf{Return}

Zero on success, error code on failure.
\index{drm\_mode\_connector\_attach\_encoder (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_connector_attach_encoder}\pysiglinewithargsret{int \bfcode{drm\_mode\_connector\_attach\_encoder}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, struct {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{drm\_encoder}}} *\emph{ encoder}}{}
attach a connector to an encoder

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector to attach

\item[{\code{struct drm\_encoder * encoder}}] \leavevmode
encoder to attach \textbf{connector} to

\end{description}

\textbf{Description}

This function links up a connector to an encoder. Note that the routing
restrictions between encoders and crtcs are exposed to userspace through the
possible\_clones and possible\_crtcs bitmasks.

\textbf{Return}

Zero on success, negative errno on failure.
\index{drm\_connector\_cleanup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_cleanup}\pysiglinewithargsret{void \bfcode{drm\_connector\_cleanup}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
cleans up an initialised connector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector to cleanup

\end{description}

\textbf{Description}

Cleans up the connector but doesn't free the object.
\index{drm\_connector\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_register}\pysiglinewithargsret{int \bfcode{drm\_connector\_register}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
register a connector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
the connector to register

\end{description}

\textbf{Description}

Register userspace interfaces for a connector

\textbf{Return}

Zero on success, error code on failure.
\index{drm\_connector\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_unregister}\pysiglinewithargsret{void \bfcode{drm\_connector\_unregister}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
unregister a connector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
the connector to unregister

\end{description}

\textbf{Description}

Unregister userspace interfaces for a connector
\index{drm\_get\_connector\_status\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_get_connector_status_name}\pysiglinewithargsret{const char * \bfcode{drm\_get\_connector\_status\_name}}{enum {\hyperref[gpu/drm\string-kms:c.drm_connector_status]{\emph{drm\_connector\_status}}}\emph{ status}}{}
return a string for connector status

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{enum drm\_connector\_status status}}] \leavevmode
connector status to compute name of

\end{description}

\textbf{Description}

In contrast to the other drm\_get\_*\_name functions this one here returns a
const pointer and hence is threadsafe.
\index{drm\_connector\_list\_iter\_begin (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_list_iter_begin}\pysiglinewithargsret{void \bfcode{drm\_connector\_list\_iter\_begin}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_connector_list_iter]{\emph{drm\_connector\_list\_iter}}} *\emph{ iter}}{}
initialize a connector\_list iterator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_connector\_list\_iter * iter}}] \leavevmode
connector\_list iterator

\end{description}

\textbf{Description}

Sets \textbf{iter} up to walk the {\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.connector\_list}}}} of \textbf{dev}. \textbf{iter}
must always be cleaned up again by calling {\hyperref[gpu/drm\string-kms:c.drm_connector_list_iter_end]{\emph{\code{drm\_connector\_list\_iter\_end()}}}}.
Iteration itself happens using {\hyperref[gpu/drm\string-kms:c.drm_connector_list_iter_next]{\emph{\code{drm\_connector\_list\_iter\_next()}}}} or
{\hyperref[gpu/drm\string-kms:c.drm_for_each_connector_iter]{\emph{\code{drm\_for\_each\_connector\_iter()}}}}.
\index{drm\_connector\_list\_iter\_next (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_list_iter_next}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} * \bfcode{drm\_connector\_list\_iter\_next}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector_list_iter]{\emph{drm\_connector\_list\_iter}}} *\emph{ iter}}{}
return next connector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector\_list\_iter * iter}}] \leavevmode
connectr\_list iterator

\end{description}

\textbf{Description}

Returns the next connector for \textbf{iter}, or NULL when the list walk has
completed.
\index{drm\_connector\_list\_iter\_end (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_list_iter_end}\pysiglinewithargsret{void \bfcode{drm\_connector\_list\_iter\_end}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector_list_iter]{\emph{drm\_connector\_list\_iter}}} *\emph{ iter}}{}
tear down a connector\_list iterator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector\_list\_iter * iter}}] \leavevmode
connector\_list iterator

\end{description}

\textbf{Description}

Tears down \textbf{iter} and releases any resources (like {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector}}}} references)
acquired while walking the list. This must always be called, both when the
iteration completes fully or when it was aborted without walking the entire
list.
\index{drm\_get\_subpixel\_order\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_get_subpixel_order_name}\pysiglinewithargsret{const char * \bfcode{drm\_get\_subpixel\_order\_name}}{enum subpixel\_order\emph{ order}}{}
return a string for a given subpixel enum

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{enum subpixel\_order order}}] \leavevmode
enum of subpixel\_order

\end{description}

\textbf{Description}

Note you could abuse this and return something out of bounds, but that
would be a caller error.  No unscrubbed user data should make it here.
\index{drm\_display\_info\_set\_bus\_formats (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_display_info_set_bus_formats}\pysiglinewithargsret{int \bfcode{drm\_display\_info\_set\_bus\_formats}}{struct {\hyperref[gpu/drm\string-kms:c.drm_display_info]{\emph{drm\_display\_info}}} *\emph{ info}, const u32 *\emph{ formats}, unsigned int\emph{ num\_formats}}{}
set the supported bus formats

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_display\_info * info}}] \leavevmode
display info to store bus formats in

\item[{\code{const u32 * formats}}] \leavevmode
array containing the supported bus formats

\item[{\code{unsigned int num\_formats}}] \leavevmode
the number of entries in the fmts array

\end{description}

\textbf{Description}

Store the supported bus formats in display info structure.
See MEDIA\_BUS\_FMT\_* definitions in include/uapi/linux/media-bus-format.h for
a full list of available formats.
\index{drm\_mode\_create\_dvi\_i\_properties (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_create_dvi_i_properties}\pysiglinewithargsret{int \bfcode{drm\_mode\_create\_dvi\_i\_properties}}{struct drm\_device *\emph{ dev}}{}
create DVI-I specific connector properties

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

Called by a driver the first time a DVI-I connector is made.
\index{drm\_mode\_create\_tv\_properties (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_create_tv_properties}\pysiglinewithargsret{int \bfcode{drm\_mode\_create\_tv\_properties}}{struct drm\_device *\emph{ dev}, unsigned int\emph{ num\_modes}, const char *const\emph{ modes}}{}
create TV specific connector properties

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{unsigned int num\_modes}}] \leavevmode
number of different TV formats (modes) supported

\item[{\code{const char *const modes}}] \leavevmode
array of pointers to strings containing name of each format

\end{description}

\textbf{Description}

Called by a driver's TV initialization routine, this function creates
the TV specific connector properties for a given device.  Caller is
responsible for allocating a list of format names and passing them to
this routine.
\index{drm\_mode\_create\_scaling\_mode\_property (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_create_scaling_mode_property}\pysiglinewithargsret{int \bfcode{drm\_mode\_create\_scaling\_mode\_property}}{struct drm\_device *\emph{ dev}}{}
create scaling mode property

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

Called by a driver the first time it's needed, must be attached to desired
connectors.

Atomic drivers should use {\hyperref[gpu/drm\string-kms:c.drm_connector_attach_scaling_mode_property]{\emph{\code{drm\_connector\_attach\_scaling\_mode\_property()}}}}
instead to correctly assign {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{\code{drm\_connector\_state.picture\_aspect\_ratio}}}}
in the atomic state.
\index{drm\_connector\_attach\_scaling\_mode\_property (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_attach_scaling_mode_property}\pysiglinewithargsret{int \bfcode{drm\_connector\_attach\_scaling\_mode\_property}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, u32\emph{ scaling\_mode\_mask}}{}
attach atomic scaling mode property

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector to attach scaling mode property on.

\item[{\code{u32 scaling\_mode\_mask}}] \leavevmode
or'ed mask of BIT(\code{DRM\_MODE\_SCALE\_}*).

\end{description}

\textbf{Description}

This is used to add support for scaling mode to atomic drivers.
The scaling mode will be set to {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{\code{drm\_connector\_state.picture\_aspect\_ratio}}}}
and can be used from {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_connector_helper_funcs]{\emph{\code{drm\_connector\_helper\_funcs-\textgreater{}atomic\_check}}}} for validation.

This is the atomic version of {\hyperref[gpu/drm\string-kms:c.drm_mode_create_scaling_mode_property]{\emph{\code{drm\_mode\_create\_scaling\_mode\_property()}}}}.

\textbf{Return}

Zero on success, negative errno on failure.
\index{drm\_mode\_create\_aspect\_ratio\_property (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_create_aspect_ratio_property}\pysiglinewithargsret{int \bfcode{drm\_mode\_create\_aspect\_ratio\_property}}{struct drm\_device *\emph{ dev}}{}
create aspect ratio property

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

Called by a driver the first time it's needed, must be attached to desired
connectors.

\textbf{Return}

Zero on success, negative errno on failure.
\index{drm\_mode\_create\_suggested\_offset\_properties (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_create_suggested_offset_properties}\pysiglinewithargsret{int \bfcode{drm\_mode\_create\_suggested\_offset\_properties}}{struct drm\_device *\emph{ dev}}{}
create suggests offset properties

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

Create the the suggested x/y offset property for connectors.
\index{drm\_mode\_connector\_set\_path\_property (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_connector_set_path_property}\pysiglinewithargsret{int \bfcode{drm\_mode\_connector\_set\_path\_property}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, const char *\emph{ path}}{}
set tile property on connector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector to set property on.

\item[{\code{const char * path}}] \leavevmode
path to use for property; must not be NULL.

\end{description}

\textbf{Description}

This creates a property to expose to userspace to specify a
connector path. This is mainly used for DisplayPort MST where
connectors have a topology and we want to allow userspace to give
them more meaningful names.

\textbf{Return}

Zero on success, negative errno on failure.
\index{drm\_mode\_connector\_set\_tile\_property (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_connector_set_tile_property}\pysiglinewithargsret{int \bfcode{drm\_mode\_connector\_set\_tile\_property}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
set tile property on connector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector to set property on.

\end{description}

\textbf{Description}

This looks up the tile information for a connector, and creates a
property for userspace to parse if it exists. The property is of
the form of 8 integers using `:' as a separator.

\textbf{Return}

Zero on success, errno on failure.
\index{drm\_mode\_connector\_update\_edid\_property (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_connector_update_edid_property}\pysiglinewithargsret{int \bfcode{drm\_mode\_connector\_update\_edid\_property}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, const struct edid *\emph{ edid}}{}
update the edid property of a connector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
drm connector

\item[{\code{const struct edid * edid}}] \leavevmode
new value of the edid property

\end{description}

\textbf{Description}

This function creates a new blob modeset object and assigns its id to the
connector's edid property.

\textbf{Return}

Zero on success, negative errno on failure.
\index{drm\_mode\_connector\_set\_link\_status\_property (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_connector_set_link_status_property}\pysiglinewithargsret{void \bfcode{drm\_mode\_connector\_set\_link\_status\_property}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, uint64\_t\emph{ link\_status}}{}
Set link status property of a connector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
drm connector

\item[{\code{uint64\_t link\_status}}] \leavevmode
new value of link status property (0: Good, 1: Bad)

\end{description}

\textbf{Description}

In usual working scenario, this link status property will always be set to
``GOOD''. If something fails during or after a mode set, the kernel driver
may set this link status property to ``BAD''. The caller then needs to send a
hotplug uevent for userspace to re-check the valid modes through
GET\_CONNECTOR\_IOCTL and retry modeset.

\textbf{Note}

Drivers cannot rely on userspace to support this property and
issue a modeset. As such, they may choose to handle issues (like
re-training a link) without userspace's intervention.

The reason for adding this property is to handle link training failures, but
it is not limited to DP or link training. For example, if we implement
asynchronous setcrtc, this property can be used to report any failures in that.
\index{drm\_connector\_init\_panel\_orientation\_property (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_connector_init_panel_orientation_property}\pysiglinewithargsret{int \bfcode{drm\_connector\_init\_panel\_orientation\_property}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, int\emph{ width}, int\emph{ height}}{}
initialize the connecters panel\_orientation property

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector for which to init the panel-orientation property.

\item[{\code{int width}}] \leavevmode
width in pixels of the panel, used for panel quirk detection

\item[{\code{int height}}] \leavevmode
height in pixels of the panel, used for panel quirk detection

\end{description}

\textbf{Description}

This function should only be called for built-in panels, after setting
connector-\textgreater{}display\_info.panel\_orientation first (if known).

This function will check for platform specific (e.g. DMI based) quirks
overriding display\_info.panel\_orientation first, then if panel\_orientation
is not DRM\_MODE\_PANEL\_ORIENTATION\_UNKNOWN it will attach the
``panel orientation'' property to the connector.

\textbf{Return}

Zero on success, negative errno on failure.
\index{drm\_mode\_put\_tile\_group (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_put_tile_group}\pysiglinewithargsret{void \bfcode{drm\_mode\_put\_tile\_group}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_tile_group]{\emph{drm\_tile\_group}}} *\emph{ tg}}{}
drop a reference to a tile group.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_tile\_group * tg}}] \leavevmode
tile group to drop reference to.

\end{description}

\textbf{Description}

drop reference to tile group and free if 0.
\index{drm\_mode\_get\_tile\_group (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_get_tile_group}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_tile_group]{\emph{drm\_tile\_group}}} * \bfcode{drm\_mode\_get\_tile\_group}}{struct drm\_device *\emph{ dev}, char\emph{ topology}}{}
get a reference to an existing tile group

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{char topology}}] \leavevmode
8-bytes unique per monitor.

\end{description}

\textbf{Description}

Use the unique bytes to get a reference to an existing tile group.

\textbf{Return}

tile group or NULL if not found.
\index{drm\_mode\_create\_tile\_group (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_create_tile_group}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_tile_group]{\emph{drm\_tile\_group}}} * \bfcode{drm\_mode\_create\_tile\_group}}{struct drm\_device *\emph{ dev}, char\emph{ topology}}{}
create a tile group from a displayid description

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{char topology}}] \leavevmode
8-bytes unique per monitor.

\end{description}

\textbf{Description}

Create a tile group for the unique monitor, and get a unique
identifier for the tile group.

\textbf{Return}

new tile group or error.


\section{Encoder Abstraction}
\label{gpu/drm-kms:encoder-abstraction}
Encoders represent the connecting element between the CRTC (as the overall
pixel pipeline, represented by {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{struct drm\_crtc}}}}) and the connectors (as the
generic sink entity, represented by {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{struct drm\_connector}}}}). An encoder takes
pixel data from a CRTC and converts it to a format suitable for any attached
connector. Encoders are objects exposed to userspace, originally to allow
userspace to infer cloning and connector/CRTC restrictions. Unfortunately
almost all drivers get this wrong, making the uabi pretty much useless. On
top of that the exposed restrictions are too simple for today's hardware, and
the recommended way to infer restrictions is by using the
DRM\_MODE\_ATOMIC\_TEST\_ONLY flag for the atomic IOCTL.

Otherwise encoders aren't used in the uapi at all (any modeset request from
userspace directly connects a connector with a CRTC), drivers are therefore
free to use them however they wish. Modeset helper libraries make strong use
of encoders to facilitate code sharing. But for more complex settings it is
usually better to move shared code into a separate {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{\code{drm\_bridge}}}}. Compared to
encoders, bridges also have the benefit of being purely an internal
abstraction since they are not exposed to userspace at all.

Encoders are initialized with {\hyperref[gpu/drm\string-kms:c.drm_encoder_init]{\emph{\code{drm\_encoder\_init()}}}} and cleaned up using
{\hyperref[gpu/drm\string-kms:c.drm_encoder_cleanup]{\emph{\code{drm\_encoder\_cleanup()}}}}.


\subsection{Encoder Functions Reference}
\label{gpu/drm-kms:encoder-functions-reference}\index{drm\_encoder\_funcs (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_encoder_funcs}\pysigline{struct \bfcode{drm\_encoder\_funcs}}
encoder controls

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}encoder\PYGZus{}funcs \PYGZob{}
  void (*reset)(struct drm\PYGZus{}encoder *encoder);
  void (*destroy)(struct drm\PYGZus{}encoder *encoder);
  int (*late\PYGZus{}register)(struct drm\PYGZus{}encoder *encoder);
  void (*early\PYGZus{}unregister)(struct drm\PYGZus{}encoder *encoder);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{reset}}] \leavevmode
Reset encoder hardware and software state to off. This function isn't
called by the core directly, only through {\hyperref[gpu/drm\string-kms:c.drm_mode_config_reset]{\emph{\code{drm\_mode\_config\_reset()}}}}.
It's not a helper hook only for historical reasons.

\item[{\code{destroy}}] \leavevmode
Clean up encoder resources. This is only called at driver unload time
through {\hyperref[gpu/drm\string-kms:c.drm_mode_config_cleanup]{\emph{\code{drm\_mode\_config\_cleanup()}}}} since an encoder cannot be
hotplugged in DRM.

\item[{\code{late\_register}}] \leavevmode
This optional hook can be used to register additional userspace
interfaces attached to the encoder like debugfs interfaces.
It is called late in the driver load sequence from {\hyperref[gpu/drm\string-internals:c.drm_dev_register]{\emph{\code{drm\_dev\_register()}}}}.
Everything added from this callback should be unregistered in
the early\_unregister callback.

Returns:

0 on success, or a negative error code on failure.

\item[{\code{early\_unregister}}] \leavevmode
This optional hook should be used to unregister the additional
userspace interfaces attached to the encoder from
\textbf{late\_register}. It is called from {\hyperref[gpu/drm\string-internals:c.drm_dev_unregister]{\emph{\code{drm\_dev\_unregister()}}}},
early in the driver unload sequence to disable userspace access
before data structures are torndown.

\end{description}

\textbf{Description}

Encoders sit between CRTCs and connectors.
\index{drm\_encoder (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_encoder}\pysigline{struct \bfcode{drm\_encoder}}
central DRM encoder structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}encoder \PYGZob{}
  struct drm\PYGZus{}device *dev;
  struct list\PYGZus{}head head;
  struct drm\PYGZus{}mode\PYGZus{}object base;
  char *name;
  int encoder\PYGZus{}type;
  unsigned index;
  uint32\PYGZus{}t possible\PYGZus{}crtcs;
  uint32\PYGZus{}t possible\PYGZus{}clones;
  struct drm\PYGZus{}crtc *crtc;
  struct drm\PYGZus{}bridge *bridge;
  const struct drm\PYGZus{}encoder\PYGZus{}funcs *funcs;
  const struct drm\PYGZus{}encoder\PYGZus{}helper\PYGZus{}funcs *helper\PYGZus{}private;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev}}] \leavevmode
parent DRM device

\item[{\code{head}}] \leavevmode
list management

\item[{\code{base}}] \leavevmode
base KMS object

\item[{\code{name}}] \leavevmode
human readable name, can be overwritten by the driver

\item[{\code{encoder\_type}}] \leavevmode
One of the DRM\_MODE\_ENCODER\_\textless{}foo\textgreater{} types in drm\_mode.h. The following
encoder types are defined thus far:
\begin{itemize}
\item {} 
DRM\_MODE\_ENCODER\_DAC for VGA and analog on DVI-I/DVI-A.

\item {} 
DRM\_MODE\_ENCODER\_TMDS for DVI, HDMI and (embedded) DisplayPort.

\item {} 
DRM\_MODE\_ENCODER\_LVDS for display panels, or in general any panel
with a proprietary parallel connector.

\item {} 
DRM\_MODE\_ENCODER\_TVDAC for TV output (Composite, S-Video,
Component, SCART).

\item {} 
DRM\_MODE\_ENCODER\_VIRTUAL for virtual machine displays

\item {} 
DRM\_MODE\_ENCODER\_DSI for panels connected using the DSI serial bus.

\item {} 
DRM\_MODE\_ENCODER\_DPI for panels connected using the DPI parallel
bus.

\item {} 
DRM\_MODE\_ENCODER\_DPMST for special fake encoders used to allow
mutliple DP MST streams to share one physical encoder.

\end{itemize}

\item[{\code{index}}] \leavevmode
Position inside the mode\_config.list, can be used as an array
index. It is invariant over the lifetime of the encoder.

\item[{\code{possible\_crtcs}}] \leavevmode
Bitmask of potential CRTC bindings, using
{\hyperref[gpu/drm\string-kms:c.drm_crtc_index]{\emph{\code{drm\_crtc\_index()}}}} as the index into the bitfield. The driver must set
the bits for all {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} objects this encoder can be connected to
before calling {\hyperref[gpu/drm\string-kms:c.drm_encoder_init]{\emph{\code{drm\_encoder\_init()}}}}.

In reality almost every driver gets this wrong.

Note that since CRTC objects can't be hotplugged the assigned indices
are stable and hence known before registering all objects.

\item[{\code{possible\_clones}}] \leavevmode
Bitmask of potential sibling encoders for cloning,
using {\hyperref[gpu/drm\string-kms:c.drm_encoder_index]{\emph{\code{drm\_encoder\_index()}}}} as the index into the bitfield. The driver
must set the bits for all {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{\code{drm\_encoder}}}} objects which can clone a
{\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} together with this encoder before calling
{\hyperref[gpu/drm\string-kms:c.drm_encoder_init]{\emph{\code{drm\_encoder\_init()}}}}. Drivers should set the bit representing the
encoder itself, too. Cloning bits should be set such that when two
encoders can be used in a cloned configuration, they both should have
each another bits set.

In reality almost every driver gets this wrong.

Note that since encoder objects can't be hotplugged the assigned indices
are stable and hence known before registering all objects.

\item[{\code{crtc}}] \leavevmode
Currently bound CRTC, only really meaningful for non-atomic
drivers.  Atomic drivers should instead check
{\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{\code{drm\_connector\_state.crtc}}}}.

\item[{\code{bridge}}] \leavevmode
bridge associated to the encoder

\item[{\code{funcs}}] \leavevmode
control functions

\item[{\code{helper\_private}}] \leavevmode
mid-layer private data

\end{description}

\textbf{Description}

CRTCs drive pixels to encoders, which convert them into signals
appropriate for a given connector or set of connectors.
\index{drm\_encoder\_index (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_encoder_index}\pysiglinewithargsret{unsigned int \bfcode{drm\_encoder\_index}}{struct {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{drm\_encoder}}} *\emph{ encoder}}{}
find the index of a registered encoder

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_encoder * encoder}}] \leavevmode
encoder to find index for

\end{description}

\textbf{Description}

Given a registered encoder, return the index of that encoder within a DRM
device's list of encoders.
\index{drm\_encoder\_crtc\_ok (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_encoder_crtc_ok}\pysiglinewithargsret{bool \bfcode{drm\_encoder\_crtc\_ok}}{struct {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{drm\_encoder}}} *\emph{ encoder}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
can a given crtc drive a given encoder?

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_encoder * encoder}}] \leavevmode
encoder to test

\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
crtc to test

\end{description}

\textbf{Description}

Returns false if \textbf{encoder} can't be driven by \textbf{crtc}, true otherwise.
\index{drm\_encoder\_find (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_encoder_find}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{drm\_encoder}}} * \bfcode{drm\_encoder\_find}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}, uint32\_t\emph{ id}}{}
find a {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{\code{drm\_encoder}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
drm file to check for lease against.

\item[{\code{uint32\_t id}}] \leavevmode
encoder id

\end{description}

\textbf{Description}

Returns the encoder with \textbf{id}, NULL if it doesn't exist. Simple wrapper around
{\hyperref[gpu/drm\string-kms:c.drm_mode_object_find]{\emph{\code{drm\_mode\_object\_find()}}}}.
\index{drm\_for\_each\_encoder\_mask (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_for_each_encoder_mask}\pysiglinewithargsret{\bfcode{drm\_for\_each\_encoder\_mask}}{\emph{encoder}, \emph{dev}, \emph{encoder\_mask}}{}
iterate over encoders specified by bitmask

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{encoder}}] \leavevmode
the loop cursor

\item[{\code{dev}}] \leavevmode
the DRM device

\item[{\code{encoder\_mask}}] \leavevmode
bitmask of encoder indices

\end{description}

\textbf{Description}

Iterate over all encoders specified by bitmask.
\index{drm\_for\_each\_encoder (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_for_each_encoder}\pysiglinewithargsret{\bfcode{drm\_for\_each\_encoder}}{\emph{encoder}, \emph{dev}}{}
iterate over all encoders

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{encoder}}] \leavevmode
the loop cursor

\item[{\code{dev}}] \leavevmode
the DRM device

\end{description}

\textbf{Description}

Iterate over all encoders of \textbf{dev}.
\index{drm\_encoder\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_encoder_init}\pysiglinewithargsret{int \bfcode{drm\_encoder\_init}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{drm\_encoder}}} *\emph{ encoder}, const struct {\hyperref[gpu/drm\string-kms:c.drm_encoder_funcs]{\emph{drm\_encoder\_funcs}}} *\emph{ funcs}, int\emph{ encoder\_type}, const char *\emph{ name}, ...}{}
Init a preallocated encoder

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{struct drm\_encoder * encoder}}] \leavevmode
the encoder to init

\item[{\code{const struct drm\_encoder\_funcs * funcs}}] \leavevmode
callbacks for this encoder

\item[{\code{int encoder\_type}}] \leavevmode
user visible type of the encoder

\item[{\code{const char * name}}] \leavevmode
printf style format string for the encoder name, or NULL for default name

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

Initialises a preallocated encoder. Encoder should be subclassed as part of
driver encoder objects. At driver unload time {\hyperref[gpu/drm\string-kms:c.drm_encoder_cleanup]{\emph{\code{drm\_encoder\_cleanup()}}}} should be
called from the driver's {\hyperref[gpu/drm\string-kms:c.drm_encoder_funcs]{\emph{\code{drm\_encoder\_funcs.destroy}}}} hook.

\textbf{Return}

Zero on success, error code on failure.
\index{drm\_encoder\_cleanup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_encoder_cleanup}\pysiglinewithargsret{void \bfcode{drm\_encoder\_cleanup}}{struct {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{drm\_encoder}}} *\emph{ encoder}}{}
cleans up an initialised encoder

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_encoder * encoder}}] \leavevmode
encoder to cleanup

\end{description}

\textbf{Description}

Cleans up the encoder but doesn't free the object.


\section{KMS Initialization and Cleanup}
\label{gpu/drm-kms:kms-initialization-and-cleanup}
A KMS device is abstracted and exposed as a set of planes, CRTCs,
encoders and connectors. KMS drivers must thus create and initialize all
those objects at load time after initializing mode setting.


\subsection{CRTCs (\texttt{struct drm\_crtc})}
\label{gpu/drm-kms:crtcs-struct-drm-crtc}
A CRTC is an abstraction representing a part of the chip that contains a
pointer to a scanout buffer. Therefore, the number of CRTCs available
determines how many independent scanout buffers can be active at any
given time. The CRTC structure contains several fields to support this:
a pointer to some video memory (abstracted as a frame buffer object), a
display mode, and an (x, y) offset into the video memory to support
panning or configurations where one piece of video memory spans multiple
CRTCs.


\subsubsection{CRTC Initialization}
\label{gpu/drm-kms:crtc-initialization}
A KMS device must create and register at least one struct
{\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{struct drm\_crtc}}}} instance. The instance is
allocated and zeroed by the driver, possibly as part of a larger
structure, and registered with a call to {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_init]{\emph{\code{drm\_crtc\_init()}}}}
with a pointer to CRTC functions.


\subsection{Cleanup}
\label{gpu/drm-kms:cleanup}
The DRM core manages its objects' lifetime. When an object is not needed
anymore the core calls its destroy function, which must clean up and
free every resource allocated for the object. Every
\code{drm\_*\_init()} call must be matched with a corresponding
\code{drm\_*\_cleanup()} call to cleanup CRTCs
({\hyperref[gpu/drm\string-kms:c.drm_crtc_cleanup]{\emph{\code{drm\_crtc\_cleanup()}}}}), planes
({\hyperref[gpu/drm\string-kms:c.drm_plane_cleanup]{\emph{\code{drm\_plane\_cleanup()}}}}), encoders
({\hyperref[gpu/drm\string-kms:c.drm_encoder_cleanup]{\emph{\code{drm\_encoder\_cleanup()}}}}) and connectors
({\hyperref[gpu/drm\string-kms:c.drm_connector_cleanup]{\emph{\code{drm\_connector\_cleanup()}}}}). Furthermore, connectors that
have been added to sysfs must be removed by a call to
{\hyperref[gpu/drm\string-kms:c.drm_connector_unregister]{\emph{\code{drm\_connector\_unregister()}}}} before calling
{\hyperref[gpu/drm\string-kms:c.drm_connector_cleanup]{\emph{\code{drm\_connector\_cleanup()}}}}.

Connectors state change detection must be cleanup up with a call to
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_kms_helper_poll_fini]{\emph{\code{drm\_kms\_helper\_poll\_fini()}}}}.


\subsection{Output discovery and initialization example}
\label{gpu/drm-kms:output-discovery-and-initialization-example}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{intel\PYGZus{}crt\PYGZus{}init}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{drm\PYGZus{}device} \PYG{o}{*}\PYG{n}{dev}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{struct} \PYG{n}{drm\PYGZus{}connector} \PYG{o}{*}\PYG{n}{connector}\PYG{p}{;}
    \PYG{k}{struct} \PYG{n}{intel\PYGZus{}output} \PYG{o}{*}\PYG{n}{intel\PYGZus{}output}\PYG{p}{;}

    \PYG{n}{intel\PYGZus{}output} \PYG{o}{=} \PYG{n}{kzalloc}\PYG{p}{(}\PYG{k}{sizeof}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{intel\PYGZus{}output}\PYG{p}{)}\PYG{p}{,} \PYG{n}{GFP\PYGZus{}KERNEL}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{intel\PYGZus{}output}\PYG{p}{)}
        \PYG{k}{return}\PYG{p}{;}

    \PYG{n}{connector} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{intel\PYGZus{}output}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{base}\PYG{p}{;}
    \PYG{n}{drm\PYGZus{}connector\PYGZus{}init}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{intel\PYGZus{}output}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{base}\PYG{p}{,}
               \PYG{o}{\PYGZam{}}\PYG{n}{intel\PYGZus{}crt\PYGZus{}connector\PYGZus{}funcs}\PYG{p}{,} \PYG{n}{DRM\PYGZus{}MODE\PYGZus{}CONNECTOR\PYGZus{}VGA}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{drm\PYGZus{}encoder\PYGZus{}init}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{intel\PYGZus{}output}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{enc}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{intel\PYGZus{}crt\PYGZus{}enc\PYGZus{}funcs}\PYG{p}{,}
             \PYG{n}{DRM\PYGZus{}MODE\PYGZus{}ENCODER\PYGZus{}DAC}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{drm\PYGZus{}mode\PYGZus{}connector\PYGZus{}attach\PYGZus{}encoder}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{intel\PYGZus{}output}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{base}\PYG{p}{,}
                      \PYG{o}{\PYGZam{}}\PYG{n}{intel\PYGZus{}output}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{enc}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cm}{/* Set up the DDC bus. */}
    \PYG{n}{intel\PYGZus{}output}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ddc\PYGZus{}bus} \PYG{o}{=} \PYG{n}{intel\PYGZus{}i2c\PYGZus{}create}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{,} \PYG{n}{GPIOA}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CRTDDC\PYGZus{}A}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{intel\PYGZus{}output}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ddc\PYGZus{}bus}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{dev\PYGZus{}printk}\PYG{p}{(}\PYG{n}{KERN\PYGZus{}ERR}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{dev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pdev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dev}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DDC bus registration }\PYG{l+s}{\PYGZdq{}}
               \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{failed.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{intel\PYGZus{}output}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{type} \PYG{o}{=} \PYG{n}{INTEL\PYGZus{}OUTPUT\PYGZus{}ANALOG}\PYG{p}{;}
    \PYG{n}{connector}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{interlace\PYGZus{}allowed} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{connector}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{doublescan\PYGZus{}allowed} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{n}{drm\PYGZus{}encoder\PYGZus{}helper\PYGZus{}add}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{intel\PYGZus{}output}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{enc}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{intel\PYGZus{}crt\PYGZus{}helper\PYGZus{}funcs}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{drm\PYGZus{}connector\PYGZus{}helper\PYGZus{}add}\PYG{p}{(}\PYG{n}{connector}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{intel\PYGZus{}crt\PYGZus{}connector\PYGZus{}helper\PYGZus{}funcs}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{drm\PYGZus{}connector\PYGZus{}register}\PYG{p}{(}\PYG{n}{connector}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

In the example above (taken from the i915 driver), a CRTC, connector and
encoder combination is created. A device-specific i2c bus is also
created for fetching EDID data and performing monitor detection. Once
the process is complete, the new connector is registered with sysfs to
make its properties available to applications.


\section{KMS Locking}
\label{gpu/drm-kms:kms-locking}
As KMS moves toward more fine grained locking, and atomic ioctl where
userspace can indirectly control locking order, it becomes necessary
to use \code{ww\_mutex} and acquire-contexts to avoid deadlocks.  But because
the locking is more distributed around the driver code, we want a bit
of extra utility/tracking out of our acquire-ctx.  This is provided
by {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{struct drm\_modeset\_lock}}}} and {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{\code{struct drm\_modeset\_acquire\_ctx}}}}.

For basic principles of \code{ww\_mutex}, see: Documentation/locking/ww-mutex-design.txt

The basic usage pattern is to:

\begin{Verbatim}[commandchars=\\\{\}]
drm\PYGZus{}modeset\PYGZus{}acquire\PYGZus{}init(ctx, DRM\PYGZus{}MODESET\PYGZus{}ACQUIRE\PYGZus{}INTERRUPTIBLE)
retry:
foreach (lock in random\PYGZus{}ordered\PYGZus{}set\PYGZus{}of\PYGZus{}locks) \PYGZob{}
    ret = drm\PYGZus{}modeset\PYGZus{}lock(lock, ctx)
    if (ret == \PYGZhy{}EDEADLK) \PYGZob{}
        ret = drm\PYGZus{}modeset\PYGZus{}backoff(ctx);
        if (!ret)
            goto retry;
    \PYGZcb{}
    if (ret)
        goto out;
\PYGZcb{}
... do stuff ...
out:
drm\PYGZus{}modeset\PYGZus{}drop\PYGZus{}locks(ctx);
drm\PYGZus{}modeset\PYGZus{}acquire\PYGZus{}fini(ctx);
\end{Verbatim}

If all that is needed is a single modeset lock, then the {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{\code{struct
drm\_modeset\_acquire\_ctx}}}} is not needed and the locking can be simplified
by passing a NULL instead of ctx in the {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock()}}}} call or
calling  {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock_single_interruptible]{\emph{\code{drm\_modeset\_lock\_single\_interruptible()}}}}. To unlock afterwards
call {\hyperref[gpu/drm\string-kms:c.drm_modeset_unlock]{\emph{\code{drm\_modeset\_unlock()}}}}.

On top of these per-object locks using \code{ww\_mutex} there's also an overall
{\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.mutex}}}}, for protecting everything else. Mostly this means
probe state of connectors, and preventing hotplug add/removal of connectors.

Finally there's a bunch of dedicated locks to protect drm core internal
lists and lookup data structures.
\index{drm\_modeset\_acquire\_ctx (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_modeset_acquire_ctx}\pysigline{struct \bfcode{drm\_modeset\_acquire\_ctx}}
locking context (see ww\_acquire\_ctx)

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}modeset\PYGZus{}acquire\PYGZus{}ctx \PYGZob{}
  struct ww\PYGZus{}acquire\PYGZus{}ctx ww\PYGZus{}ctx;
  struct drm\PYGZus{}modeset\PYGZus{}lock *contended;
  struct list\PYGZus{}head locked;
  bool trylock\PYGZus{}only;
  bool interruptible;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{ww\_ctx}}] \leavevmode
base acquire ctx

\item[{\code{contended}}] \leavevmode
used internally for -EDEADLK handling

\item[{\code{locked}}] \leavevmode
list of held locks

\item[{\code{trylock\_only}}] \leavevmode
trylock mode used in atomic contexts/panic notifiers

\item[{\code{interruptible}}] \leavevmode
whether interruptible locking should be used.

\end{description}

\textbf{Description}

Each thread competing for a set of locks must use one acquire
ctx.  And if any lock fxn returns -EDEADLK, it must backoff and
retry.
\index{drm\_modeset\_lock (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_modeset_lock}\pysigline{struct \bfcode{drm\_modeset\_lock}}
used for locking modeset resources.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}modeset\PYGZus{}lock \PYGZob{}
  struct ww\PYGZus{}mutex mutex;
  struct list\PYGZus{}head head;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{mutex}}] \leavevmode
resource locking

\item[{\code{head}}] \leavevmode
used to hold it's place on \code{drm\_atomi\_state.locked} list when
part of an atomic update

\end{description}

\textbf{Description}

Used for locking CRTCs and other modeset resources.
\index{drm\_modeset\_lock\_fini (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_modeset_lock_fini}\pysiglinewithargsret{void \bfcode{drm\_modeset\_lock\_fini}}{struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{drm\_modeset\_lock}}} *\emph{ lock}}{}
cleanup lock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_modeset\_lock * lock}}] \leavevmode
lock to cleanup

\end{description}
\index{drm\_modeset\_is\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_modeset_is_locked}\pysiglinewithargsret{bool \bfcode{drm\_modeset\_is\_locked}}{struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{drm\_modeset\_lock}}} *\emph{ lock}}{}
equivalent to \code{mutex\_is\_locked()}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_modeset\_lock * lock}}] \leavevmode
lock to check

\end{description}
\index{drm\_modeset\_lock\_all (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_modeset_lock_all}\pysiglinewithargsret{void \bfcode{drm\_modeset\_lock\_all}}{struct drm\_device *\emph{ dev}}{}
take all modeset locks

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

This function takes all modeset locks, suitable where a more fine-grained
scheme isn't (yet) implemented. Locks must be dropped by calling the
{\hyperref[gpu/drm\string-kms:c.drm_modeset_unlock_all]{\emph{\code{drm\_modeset\_unlock\_all()}}}} function.

This function is deprecated. It allocates a lock acquisition context and
stores it in \code{drm\_device.mode\_config}. This facilitate conversion of
existing code because it removes the need to manually deal with the
acquisition context, but it is also brittle because the context is global
and care must be taken not to nest calls. New code should use the
{\hyperref[gpu/drm\string-kms:c.drm_modeset_lock_all_ctx]{\emph{\code{drm\_modeset\_lock\_all\_ctx()}}}} function and pass in the context explicitly.
\index{drm\_modeset\_unlock\_all (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_modeset_unlock_all}\pysiglinewithargsret{void \bfcode{drm\_modeset\_unlock\_all}}{struct drm\_device *\emph{ dev}}{}
drop all modeset locks

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

This function drops all modeset locks taken by a previous call to the
{\hyperref[gpu/drm\string-kms:c.drm_modeset_lock_all]{\emph{\code{drm\_modeset\_lock\_all()}}}} function.

This function is deprecated. It uses the lock acquisition context stored
in \code{drm\_device.mode\_config}. This facilitates conversion of existing
code because it removes the need to manually deal with the acquisition
context, but it is also brittle because the context is global and care must
be taken not to nest calls. New code should pass the acquisition context
directly to the {\hyperref[gpu/drm\string-kms:c.drm_modeset_drop_locks]{\emph{\code{drm\_modeset\_drop\_locks()}}}} function.
\index{drm\_warn\_on\_modeset\_not\_all\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_warn_on_modeset_not_all_locked}\pysiglinewithargsret{void \bfcode{drm\_warn\_on\_modeset\_not\_all\_locked}}{struct drm\_device *\emph{ dev}}{}
check that all modeset locks are locked

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
device

\end{description}

\textbf{Description}

Useful as a debug assert.
\index{drm\_modeset\_acquire\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_modeset_acquire_init}\pysiglinewithargsret{void \bfcode{drm\_modeset\_acquire\_init}}{struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}, uint32\_t\emph{ flags}}{}
initialize acquire context

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
the acquire context

\item[{\code{uint32\_t flags}}] \leavevmode
0 or \code{DRM\_MODESET\_ACQUIRE\_INTERRUPTIBLE}

\end{description}

\textbf{Description}

When passing \code{DRM\_MODESET\_ACQUIRE\_INTERRUPTIBLE} to \textbf{flags},
all calls to {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock()}}}} will perform an interruptible
wait.
\index{drm\_modeset\_acquire\_fini (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_modeset_acquire_fini}\pysiglinewithargsret{void \bfcode{drm\_modeset\_acquire\_fini}}{struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}}{}
cleanup acquire context

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
the acquire context

\end{description}
\index{drm\_modeset\_drop\_locks (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_modeset_drop_locks}\pysiglinewithargsret{void \bfcode{drm\_modeset\_drop\_locks}}{struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}}{}
drop all locks

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
the acquire context

\end{description}

\textbf{Description}

Drop all locks currently held against this acquire context.
\index{drm\_modeset\_backoff (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_modeset_backoff}\pysiglinewithargsret{int \bfcode{drm\_modeset\_backoff}}{struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}}{}
deadlock avoidance backoff

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
the acquire context

\end{description}

\textbf{Description}

If deadlock is detected (ie. {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock()}}}} returns -EDEADLK),
you must call this function to drop all currently held locks and
block until the contended lock becomes available.

This function returns 0 on success, or -ERESTARTSYS if this context
is initialized with \code{DRM\_MODESET\_ACQUIRE\_INTERRUPTIBLE} and the
wait has been interrupted.
\index{drm\_modeset\_lock\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_modeset_lock_init}\pysiglinewithargsret{void \bfcode{drm\_modeset\_lock\_init}}{struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{drm\_modeset\_lock}}} *\emph{ lock}}{}
initialize lock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_modeset\_lock * lock}}] \leavevmode
lock to init

\end{description}
\index{drm\_modeset\_lock (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{int \bfcode{drm\_modeset\_lock}}{struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{drm\_modeset\_lock}}} *\emph{ lock}, struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}}{}
take modeset lock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_modeset\_lock * lock}}] \leavevmode
lock to take

\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
acquire ctx

\end{description}

\textbf{Description}

If \textbf{ctx} is not NULL, then its ww acquire context is used and the
lock will be tracked by the context and can be released by calling
{\hyperref[gpu/drm\string-kms:c.drm_modeset_drop_locks]{\emph{\code{drm\_modeset\_drop\_locks()}}}}.  If -EDEADLK is returned, this means a
deadlock scenario has been detected and it is an error to attempt
to take any more locks without first calling {\hyperref[gpu/drm\string-kms:c.drm_modeset_backoff]{\emph{\code{drm\_modeset\_backoff()}}}}.

If the \textbf{ctx} is not NULL and initialized with
\code{DRM\_MODESET\_ACQUIRE\_INTERRUPTIBLE}, this function will fail with
-ERESTARTSYS when interrupted.

If \textbf{ctx} is NULL then the function call behaves like a normal,
uninterruptible non-nesting \code{mutex\_lock()} call.
\index{drm\_modeset\_lock\_single\_interruptible (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_modeset_lock_single_interruptible}\pysiglinewithargsret{int \bfcode{drm\_modeset\_lock\_single\_interruptible}}{struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{drm\_modeset\_lock}}} *\emph{ lock}}{}
take a single modeset lock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_modeset\_lock * lock}}] \leavevmode
lock to take

\end{description}

\textbf{Description}

This function behaves as {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock()}}}} with a NULL context,
but performs interruptible waits.

This function returns 0 on success, or -ERESTARTSYS when interrupted.
\index{drm\_modeset\_unlock (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_modeset_unlock}\pysiglinewithargsret{void \bfcode{drm\_modeset\_unlock}}{struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{drm\_modeset\_lock}}} *\emph{ lock}}{}
drop modeset lock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_modeset\_lock * lock}}] \leavevmode
lock to release

\end{description}
\index{drm\_modeset\_lock\_all\_ctx (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_modeset_lock_all_ctx}\pysiglinewithargsret{int \bfcode{drm\_modeset\_lock\_all\_ctx}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}}{}
take all modeset locks

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
lock acquisition context

\end{description}

\textbf{Description}

This function takes all modeset locks, suitable where a more fine-grained
scheme isn't (yet) implemented.

Unlike {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock_all]{\emph{\code{drm\_modeset\_lock\_all()}}}}, it doesn't take the {\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.mutex}}}}
since that lock isn't required for modeset state changes. Callers which
need to grab that lock too need to do so outside of the acquire context
\textbf{ctx}.

Locks acquired with this function should be released by calling the
{\hyperref[gpu/drm\string-kms:c.drm_modeset_drop_locks]{\emph{\code{drm\_modeset\_drop\_locks()}}}} function on \textbf{ctx}.

\textbf{Return}

0 on success or a negative error-code on failure.


\section{KMS Properties}
\label{gpu/drm-kms:kms-properties}

\subsection{Property Types and Blob Property Support}
\label{gpu/drm-kms:property-types-and-blob-property-support}
Properties as represented by {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{\code{drm\_property}}}} are used to extend the modeset
interface exposed to userspace. For the atomic modeset IOCTL properties are
even the only way to transport metadata about the desired new modeset
configuration from userspace to the kernel. Properties have a well-defined
value range, which is enforced by the drm core. See the documentation of the
flags member of {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{\code{struct drm\_property}}}} for an overview of the different
property types and ranges.

Properties don't store the current value directly, but need to be
instatiated by attaching them to a {\hyperref[gpu/drm\string-kms:c.drm_mode_object]{\emph{\code{drm\_mode\_object}}}} with
{\hyperref[gpu/drm\string-kms:c.drm_object_attach_property]{\emph{\code{drm\_object\_attach\_property()}}}}.

Property values are only 64bit. To support bigger piles of data (like gamma
tables, color correction matrices or large structures) a property can instead
point at a {\hyperref[gpu/drm\string-kms:c.drm_property_blob]{\emph{\code{drm\_property\_blob}}}} with that additional data.

Properties are defined by their symbolic name, userspace must keep a
per-object mapping from those names to the property ID used in the atomic
IOCTL and in the get/set property IOCTL.
\index{drm\_property\_enum (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_enum}\pysigline{struct \bfcode{drm\_property\_enum}}
symbolic values for enumerations

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}property\PYGZus{}enum \PYGZob{}
  uint64\PYGZus{}t value;
  struct list\PYGZus{}head head;
  char name[DRM\PYGZus{}PROP\PYGZus{}NAME\PYGZus{}LEN];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{value}}] \leavevmode
numeric property value for this enum entry

\item[{\code{head}}] \leavevmode
list of enum values, linked to {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{\code{drm\_property.enum\_list}}}}

\item[{\code{name}}] \leavevmode
symbolic name for the enum

\end{description}

\textbf{Description}

For enumeration and bitmask properties this structure stores the symbolic
decoding for each value. This is used for example for the rotation property.
\index{drm\_property (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property}\pysigline{struct \bfcode{drm\_property}}
modeset object property

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}property \PYGZob{}
  struct list\PYGZus{}head head;
  struct drm\PYGZus{}mode\PYGZus{}object base;
  uint32\PYGZus{}t flags;
  char name[DRM\PYGZus{}PROP\PYGZus{}NAME\PYGZus{}LEN];
  uint32\PYGZus{}t num\PYGZus{}values;
  uint64\PYGZus{}t *values;
  struct drm\PYGZus{}device *dev;
  struct list\PYGZus{}head enum\PYGZus{}list;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{head}}] \leavevmode
per-device list of properties, for cleanup.

\item[{\code{base}}] \leavevmode
base KMS object

\item[{\code{flags}}] \leavevmode
Property flags and type. A property needs to be one of the following
types:
\begin{description}
\item[{DRM\_MODE\_PROP\_RANGE}] \leavevmode
Range properties report their minimum and maximum admissible unsigned values.
The KMS core verifies that values set by application fit in that
range. The range is unsigned. Range properties are created using
{\hyperref[gpu/drm\string-kms:c.drm_property_create_range]{\emph{\code{drm\_property\_create\_range()}}}}.

\item[{DRM\_MODE\_PROP\_SIGNED\_RANGE}] \leavevmode
Range properties report their minimum and maximum admissible unsigned values.
The KMS core verifies that values set by application fit in that
range. The range is signed. Range properties are created using
{\hyperref[gpu/drm\string-kms:c.drm_property_create_signed_range]{\emph{\code{drm\_property\_create\_signed\_range()}}}}.

\item[{DRM\_MODE\_PROP\_ENUM}] \leavevmode
Enumerated properties take a numerical value that ranges from 0 to
the number of enumerated values defined by the property minus one,
and associate a free-formed string name to each value. Applications
can retrieve the list of defined value-name pairs and use the
numerical value to get and set property instance values. Enum
properties are created using {\hyperref[gpu/drm\string-kms:c.drm_property_create_enum]{\emph{\code{drm\_property\_create\_enum()}}}}.

\item[{DRM\_MODE\_PROP\_BITMASK}] \leavevmode
Bitmask properties are enumeration properties that additionally
restrict all enumerated values to the 0..63 range. Bitmask property
instance values combine one or more of the enumerated bits defined
by the property. Bitmask properties are created using
{\hyperref[gpu/drm\string-kms:c.drm_property_create_bitmask]{\emph{\code{drm\_property\_create\_bitmask()}}}}.

\item[{DRM\_MODE\_PROB\_OBJECT}] \leavevmode
Object properties are used to link modeset objects. This is used
extensively in the atomic support to create the display pipeline,
by linking {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}} to {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{drm\_plane}}}}, {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{drm\_plane}}}} to
{\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} and {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector}}}} to {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}}. An object property can
only link to a specific type of {\hyperref[gpu/drm\string-kms:c.drm_mode_object]{\emph{\code{drm\_mode\_object}}}}, this limit is
enforced by the core. Object properties are created using
{\hyperref[gpu/drm\string-kms:c.drm_property_create_object]{\emph{\code{drm\_property\_create\_object()}}}}.

Object properties work like blob properties, but in a more
general fashion. They are limited to atomic drivers and must have
the DRM\_MODE\_PROP\_ATOMIC flag set.

\item[{DRM\_MODE\_PROP\_BLOB}] \leavevmode
Blob properties store a binary blob without any format restriction.
The binary blobs are created as KMS standalone objects, and blob
property instance values store the ID of their associated blob
object. Blob properties are created by calling
{\hyperref[gpu/drm\string-kms:c.drm_property_create]{\emph{\code{drm\_property\_create()}}}} with DRM\_MODE\_PROP\_BLOB as the type.

Actual blob objects to contain blob data are created using
{\hyperref[gpu/drm\string-kms:c.drm_property_create_blob]{\emph{\code{drm\_property\_create\_blob()}}}}, or through the corresponding IOCTL.

Besides the built-in limit to only accept blob objects blob
properties work exactly like object properties. The only reasons
blob properties exist is backwards compatibility with existing
userspace.

\end{description}

In addition a property can have any combination of the below flags:
\begin{description}
\item[{DRM\_MODE\_PROP\_ATOMIC}] \leavevmode
Set for properties which encode atomic modeset state. Such
properties are not exposed to legacy userspace.

\item[{DRM\_MODE\_PROP\_IMMUTABLE}] \leavevmode
Set for properties where userspace cannot be changed by
userspace. The kernel is allowed to update the value of these
properties. This is generally used to expose probe state to
usersapce, e.g. the EDID, or the connector path property on DP
MST sinks.

\end{description}

\item[{\code{name}}] \leavevmode
symbolic name of the properties

\item[{\code{num\_values}}] \leavevmode
size of the \textbf{values} array.

\item[{\code{values}}] \leavevmode
Array with limits and values for the property. The
interpretation of these limits is dependent upon the type per \textbf{flags}.

\item[{\code{dev}}] \leavevmode
DRM device

\item[{\code{enum\_list}}] \leavevmode
List of \code{drm\_prop\_enum\_list} structures with the symbolic names for
enum and bitmask values.

\end{description}

\textbf{Description}

This structure represent a modeset object property. It combines both the name
of the property with the set of permissible values. This means that when a
driver wants to use a property with the same name on different objects, but
with different value ranges, then it must create property for each one. An
example would be rotation of {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{drm\_plane}}}}, when e.g. the primary plane cannot
be rotated. But if both the name and the value range match, then the same
property structure can be instantiated multiple times for the same object.
Userspace must be able to cope with this and cannot assume that the same
symbolic property will have the same modeset object ID on all modeset
objects.

Properties are created by one of the special functions, as explained in
detail in the \textbf{flags} structure member.

To actually expose a property it must be attached to each object using
{\hyperref[gpu/drm\string-kms:c.drm_object_attach_property]{\emph{\code{drm\_object\_attach\_property()}}}}. Currently properties can only be attached to
{\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector}}}}, {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} and {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{drm\_plane}}}}.

Properties are also used as the generic metadatatransport for the atomic
IOCTL. Everything that was set directly in structures in the legacy modeset
IOCTLs (like the plane source or destination windows, or e.g. the links to
the CRTC) is exposed as a property with the DRM\_MODE\_PROP\_ATOMIC flag set.
\index{drm\_property\_blob (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_blob}\pysigline{struct \bfcode{drm\_property\_blob}}
Blob data for {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{\code{drm\_property}}}}

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}property\PYGZus{}blob \PYGZob{}
  struct drm\PYGZus{}mode\PYGZus{}object base;
  struct drm\PYGZus{}device *dev;
  struct list\PYGZus{}head head\PYGZus{}global;
  struct list\PYGZus{}head head\PYGZus{}file;
  size\PYGZus{}t length;
  unsigned char data[];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{base}}] \leavevmode
base KMS object

\item[{\code{dev}}] \leavevmode
DRM device

\item[{\code{head\_global}}] \leavevmode
entry on the global blob list in
{\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.property\_blob\_list}}}}.

\item[{\code{head\_file}}] \leavevmode
entry on the per-file blob list in {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{drm\_file.blobs}}}} list.

\item[{\code{length}}] \leavevmode
size of the blob in bytes, invariant over the lifetime of the object

\item[{\code{data}}] \leavevmode
actual data, embedded at the end of this structure

\end{description}

\textbf{Description}

Blobs are used to store bigger values than what fits directly into the 64
bits available for a {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{\code{drm\_property}}}}.

Blobs are reference counted using {\hyperref[gpu/drm\string-kms:c.drm_property_blob_get]{\emph{\code{drm\_property\_blob\_get()}}}} and
{\hyperref[gpu/drm\string-kms:c.drm_property_blob_put]{\emph{\code{drm\_property\_blob\_put()}}}}. They are created using {\hyperref[gpu/drm\string-kms:c.drm_property_create_blob]{\emph{\code{drm\_property\_create\_blob()}}}}.
\index{drm\_property\_type\_is (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_type_is}\pysiglinewithargsret{bool \bfcode{drm\_property\_type\_is}}{struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} *\emph{ property}, uint32\_t\emph{ type}}{}
check the type of a property

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_property * property}}] \leavevmode
property to check

\item[{\code{uint32\_t type}}] \leavevmode
property type to compare with

\end{description}

\textbf{Description}

This is a helper function becauase the uapi encoding of property types is
a bit special for historical reasons.
\index{drm\_property\_reference\_blob (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_reference_blob}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_property_blob]{\emph{drm\_property\_blob}}} * \bfcode{drm\_property\_reference\_blob}}{struct {\hyperref[gpu/drm\string-kms:c.drm_property_blob]{\emph{drm\_property\_blob}}} *\emph{ blob}}{}
acquire a blob property reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_property\_blob * blob}}] \leavevmode
DRM blob property

\end{description}

\textbf{Description}

This is a compatibility alias for {\hyperref[gpu/drm\string-kms:c.drm_property_blob_get]{\emph{\code{drm\_property\_blob\_get()}}}} and should not be
used by new code.
\index{drm\_property\_unreference\_blob (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_unreference_blob}\pysiglinewithargsret{void \bfcode{drm\_property\_unreference\_blob}}{struct {\hyperref[gpu/drm\string-kms:c.drm_property_blob]{\emph{drm\_property\_blob}}} *\emph{ blob}}{}
release a blob property reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_property\_blob * blob}}] \leavevmode
DRM blob property

\end{description}

\textbf{Description}

This is a compatibility alias for {\hyperref[gpu/drm\string-kms:c.drm_property_blob_put]{\emph{\code{drm\_property\_blob\_put()}}}} and should not be
used by new code.
\index{drm\_property\_find (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_find}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} * \bfcode{drm\_property\_find}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}, uint32\_t\emph{ id}}{}
find property object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
drm file to check for lease against.

\item[{\code{uint32\_t id}}] \leavevmode
property object id

\end{description}

\textbf{Description}

This function looks up the property object specified by id and returns it.
\index{drm\_property\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_create}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} * \bfcode{drm\_property\_create}}{struct drm\_device *\emph{ dev}, int\emph{ flags}, const char *\emph{ name}, int\emph{ num\_values}}{}
create a new property type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{int flags}}] \leavevmode
flags specifying the property type

\item[{\code{const char * name}}] \leavevmode
name of the property

\item[{\code{int num\_values}}] \leavevmode
number of pre-defined values

\end{description}

\textbf{Description}

This creates a new generic drm property which can then be attached to a drm
object with {\hyperref[gpu/drm\string-kms:c.drm_object_attach_property]{\emph{\code{drm\_object\_attach\_property()}}}}. The returned property object must
be freed with {\hyperref[gpu/drm\string-kms:c.drm_property_destroy]{\emph{\code{drm\_property\_destroy()}}}}, which is done automatically when
calling {\hyperref[gpu/drm\string-kms:c.drm_mode_config_cleanup]{\emph{\code{drm\_mode\_config\_cleanup()}}}}.

\textbf{Return}

A pointer to the newly created property on success, NULL on failure.
\index{drm\_property\_create\_enum (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_create_enum}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} * \bfcode{drm\_property\_create\_enum}}{struct drm\_device *\emph{ dev}, int\emph{ flags}, const char *\emph{ name}, const struct drm\_prop\_enum\_list *\emph{ props}, int\emph{ num\_values}}{}
create a new enumeration property type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{int flags}}] \leavevmode
flags specifying the property type

\item[{\code{const char * name}}] \leavevmode
name of the property

\item[{\code{const struct drm\_prop\_enum\_list * props}}] \leavevmode
enumeration lists with property values

\item[{\code{int num\_values}}] \leavevmode
number of pre-defined values

\end{description}

\textbf{Description}

This creates a new generic drm property which can then be attached to a drm
object with {\hyperref[gpu/drm\string-kms:c.drm_object_attach_property]{\emph{\code{drm\_object\_attach\_property()}}}}. The returned property object must
be freed with {\hyperref[gpu/drm\string-kms:c.drm_property_destroy]{\emph{\code{drm\_property\_destroy()}}}}, which is done automatically when
calling {\hyperref[gpu/drm\string-kms:c.drm_mode_config_cleanup]{\emph{\code{drm\_mode\_config\_cleanup()}}}}.

Userspace is only allowed to set one of the predefined values for enumeration
properties.

\textbf{Return}

A pointer to the newly created property on success, NULL on failure.
\index{drm\_property\_create\_bitmask (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_create_bitmask}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} * \bfcode{drm\_property\_create\_bitmask}}{struct drm\_device *\emph{ dev}, int\emph{ flags}, const char *\emph{ name}, const struct drm\_prop\_enum\_list *\emph{ props}, int\emph{ num\_props}, uint64\_t\emph{ supported\_bits}}{}
create a new bitmask property type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{int flags}}] \leavevmode
flags specifying the property type

\item[{\code{const char * name}}] \leavevmode
name of the property

\item[{\code{const struct drm\_prop\_enum\_list * props}}] \leavevmode
enumeration lists with property bitflags

\item[{\code{int num\_props}}] \leavevmode
size of the \textbf{props} array

\item[{\code{uint64\_t supported\_bits}}] \leavevmode
bitmask of all supported enumeration values

\end{description}

\textbf{Description}

This creates a new bitmask drm property which can then be attached to a drm
object with {\hyperref[gpu/drm\string-kms:c.drm_object_attach_property]{\emph{\code{drm\_object\_attach\_property()}}}}. The returned property object must
be freed with {\hyperref[gpu/drm\string-kms:c.drm_property_destroy]{\emph{\code{drm\_property\_destroy()}}}}, which is done automatically when
calling {\hyperref[gpu/drm\string-kms:c.drm_mode_config_cleanup]{\emph{\code{drm\_mode\_config\_cleanup()}}}}.

Compared to plain enumeration properties userspace is allowed to set any
or'ed together combination of the predefined property bitflag values

\textbf{Return}

A pointer to the newly created property on success, NULL on failure.
\index{drm\_property\_create\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_create_range}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} * \bfcode{drm\_property\_create\_range}}{struct drm\_device *\emph{ dev}, int\emph{ flags}, const char *\emph{ name}, uint64\_t\emph{ min}, uint64\_t\emph{ max}}{}
create a new unsigned ranged property type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{int flags}}] \leavevmode
flags specifying the property type

\item[{\code{const char * name}}] \leavevmode
name of the property

\item[{\code{uint64\_t min}}] \leavevmode
minimum value of the property

\item[{\code{uint64\_t max}}] \leavevmode
maximum value of the property

\end{description}

\textbf{Description}

This creates a new generic drm property which can then be attached to a drm
object with {\hyperref[gpu/drm\string-kms:c.drm_object_attach_property]{\emph{\code{drm\_object\_attach\_property()}}}}. The returned property object must
be freed with {\hyperref[gpu/drm\string-kms:c.drm_property_destroy]{\emph{\code{drm\_property\_destroy()}}}}, which is done automatically when
calling {\hyperref[gpu/drm\string-kms:c.drm_mode_config_cleanup]{\emph{\code{drm\_mode\_config\_cleanup()}}}}.

Userspace is allowed to set any unsigned integer value in the (min, max)
range inclusive.

\textbf{Return}

A pointer to the newly created property on success, NULL on failure.
\index{drm\_property\_create\_signed\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_create_signed_range}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} * \bfcode{drm\_property\_create\_signed\_range}}{struct drm\_device *\emph{ dev}, int\emph{ flags}, const char *\emph{ name}, int64\_t\emph{ min}, int64\_t\emph{ max}}{}
create a new signed ranged property type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{int flags}}] \leavevmode
flags specifying the property type

\item[{\code{const char * name}}] \leavevmode
name of the property

\item[{\code{int64\_t min}}] \leavevmode
minimum value of the property

\item[{\code{int64\_t max}}] \leavevmode
maximum value of the property

\end{description}

\textbf{Description}

This creates a new generic drm property which can then be attached to a drm
object with {\hyperref[gpu/drm\string-kms:c.drm_object_attach_property]{\emph{\code{drm\_object\_attach\_property()}}}}. The returned property object must
be freed with {\hyperref[gpu/drm\string-kms:c.drm_property_destroy]{\emph{\code{drm\_property\_destroy()}}}}, which is done automatically when
calling {\hyperref[gpu/drm\string-kms:c.drm_mode_config_cleanup]{\emph{\code{drm\_mode\_config\_cleanup()}}}}.

Userspace is allowed to set any signed integer value in the (min, max)
range inclusive.

\textbf{Return}

A pointer to the newly created property on success, NULL on failure.
\index{drm\_property\_create\_object (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_create_object}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} * \bfcode{drm\_property\_create\_object}}{struct drm\_device *\emph{ dev}, int\emph{ flags}, const char *\emph{ name}, uint32\_t\emph{ type}}{}
create a new object property type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{int flags}}] \leavevmode
flags specifying the property type

\item[{\code{const char * name}}] \leavevmode
name of the property

\item[{\code{uint32\_t type}}] \leavevmode
object type from DRM\_MODE\_OBJECT\_* defines

\end{description}

\textbf{Description}

This creates a new generic drm property which can then be attached to a drm
object with {\hyperref[gpu/drm\string-kms:c.drm_object_attach_property]{\emph{\code{drm\_object\_attach\_property()}}}}. The returned property object must
be freed with {\hyperref[gpu/drm\string-kms:c.drm_property_destroy]{\emph{\code{drm\_property\_destroy()}}}}, which is done automatically when
calling {\hyperref[gpu/drm\string-kms:c.drm_mode_config_cleanup]{\emph{\code{drm\_mode\_config\_cleanup()}}}}.

Userspace is only allowed to set this to any property value of the given
\textbf{type}. Only useful for atomic properties, which is enforced.

\textbf{Return}

A pointer to the newly created property on success, NULL on failure.
\index{drm\_property\_create\_bool (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_create_bool}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} * \bfcode{drm\_property\_create\_bool}}{struct drm\_device *\emph{ dev}, int\emph{ flags}, const char *\emph{ name}}{}
create a new boolean property type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{int flags}}] \leavevmode
flags specifying the property type

\item[{\code{const char * name}}] \leavevmode
name of the property

\end{description}

\textbf{Description}

This creates a new generic drm property which can then be attached to a drm
object with {\hyperref[gpu/drm\string-kms:c.drm_object_attach_property]{\emph{\code{drm\_object\_attach\_property()}}}}. The returned property object must
be freed with {\hyperref[gpu/drm\string-kms:c.drm_property_destroy]{\emph{\code{drm\_property\_destroy()}}}}, which is done automatically when
calling {\hyperref[gpu/drm\string-kms:c.drm_mode_config_cleanup]{\emph{\code{drm\_mode\_config\_cleanup()}}}}.

This is implemented as a ranged property with only \{0, 1\} as valid values.

\textbf{Return}

A pointer to the newly created property on success, NULL on failure.
\index{drm\_property\_add\_enum (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_add_enum}\pysiglinewithargsret{int \bfcode{drm\_property\_add\_enum}}{struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} *\emph{ property}, int\emph{ index}, uint64\_t\emph{ value}, const char *\emph{ name}}{}
add a possible value to an enumeration property

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_property * property}}] \leavevmode
enumeration property to change

\item[{\code{int index}}] \leavevmode
index of the new enumeration

\item[{\code{uint64\_t value}}] \leavevmode
value of the new enumeration

\item[{\code{const char * name}}] \leavevmode
symbolic name of the new enumeration

\end{description}

\textbf{Description}

This functions adds enumerations to a property.

It's use is deprecated, drivers should use one of the more specific helpers
to directly create the property with all enumerations already attached.

\textbf{Return}

Zero on success, error code on failure.
\index{drm\_property\_destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_destroy}\pysiglinewithargsret{void \bfcode{drm\_property\_destroy}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} *\emph{ property}}{}
destroy a drm property

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{struct drm\_property * property}}] \leavevmode
property to destry

\end{description}

\textbf{Description}

This function frees a property including any attached resources like
enumeration values.
\index{drm\_property\_create\_blob (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_create_blob}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_property_blob]{\emph{drm\_property\_blob}}} * \bfcode{drm\_property\_create\_blob}}{struct drm\_device *\emph{ dev}, size\_t\emph{ length}, const void *\emph{ data}}{}
Create new blob property

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device to create property for

\item[{\code{size\_t length}}] \leavevmode
Length to allocate for blob data

\item[{\code{const void * data}}] \leavevmode
If specified, copies data into blob

\end{description}

\textbf{Description}

Creates a new blob property for a specified DRM device, optionally
copying data. Note that blob properties are meant to be invariant, hence the
data must be filled out before the blob is used as the value of any property.

\textbf{Return}

New blob property with a single reference on success, or an ERR\_PTR
value on failure.
\index{drm\_property\_blob\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_blob_put}\pysiglinewithargsret{void \bfcode{drm\_property\_blob\_put}}{struct {\hyperref[gpu/drm\string-kms:c.drm_property_blob]{\emph{drm\_property\_blob}}} *\emph{ blob}}{}
release a blob property reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_property\_blob * blob}}] \leavevmode
DRM blob property

\end{description}

\textbf{Description}

Releases a reference to a blob property. May free the object.
\index{drm\_property\_blob\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_blob_get}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_property_blob]{\emph{drm\_property\_blob}}} * \bfcode{drm\_property\_blob\_get}}{struct {\hyperref[gpu/drm\string-kms:c.drm_property_blob]{\emph{drm\_property\_blob}}} *\emph{ blob}}{}
acquire blob property reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_property\_blob * blob}}] \leavevmode
DRM blob property

\end{description}

\textbf{Description}

Acquires a reference to an existing blob property. Returns \textbf{blob}, which
allows this to be used as a shorthand in assignments.
\index{drm\_property\_lookup\_blob (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_lookup_blob}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_property_blob]{\emph{drm\_property\_blob}}} * \bfcode{drm\_property\_lookup\_blob}}{struct drm\_device *\emph{ dev}, uint32\_t\emph{ id}}{}
look up a blob property and take a reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{uint32\_t id}}] \leavevmode
id of the blob property

\end{description}

\textbf{Description}

If successful, this takes an additional reference to the blob property.
callers need to make sure to eventually unreference the returned property
again, using {\hyperref[gpu/drm\string-kms:c.drm_property_blob_put]{\emph{\code{drm\_property\_blob\_put()}}}}.

\textbf{Return}

NULL on failure, pointer to the blob on success.
\index{drm\_property\_replace\_global\_blob (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_replace_global_blob}\pysiglinewithargsret{int \bfcode{drm\_property\_replace\_global\_blob}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_property_blob]{\emph{drm\_property\_blob}}} **\emph{ replace}, size\_t\emph{ length}, const void *\emph{ data}, struct {\hyperref[gpu/drm\string-kms:c.drm_mode_object]{\emph{drm\_mode\_object}}} *\emph{ obj\_holds\_id}, struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} *\emph{ prop\_holds\_id}}{}
replace existing blob property

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{struct drm\_property\_blob ** replace}}] \leavevmode
location of blob property pointer to be replaced

\item[{\code{size\_t length}}] \leavevmode
length of data for new blob, or 0 for no data

\item[{\code{const void * data}}] \leavevmode
content for new blob, or NULL for no data

\item[{\code{struct drm\_mode\_object * obj\_holds\_id}}] \leavevmode
optional object for property holding blob ID

\item[{\code{struct drm\_property * prop\_holds\_id}}] \leavevmode
optional property holding blob ID
\textbf{return} 0 on success or error on failure

\end{description}

\textbf{Description}

This function will replace a global property in the blob list, optionally
updating a property which holds the ID of that property.

If length is 0 or data is NULL, no new blob will be created, and the holding
property, if specified, will be set to 0.

Access to the replace pointer is assumed to be protected by the caller, e.g.
by holding the relevant modesetting object lock for its parent.

For example, a drm\_connector has a `PATH' property, which contains the ID
of a blob property with the value of the MST path information. Calling this
function with replace pointing to the connector's path\_blob\_ptr, length and
data set for the new path information, obj\_holds\_id set to the connector's
base object, and prop\_holds\_id set to the path property name, will perform
a completely atomic update. The access to path\_blob\_ptr is protected by the
caller holding a lock on the connector.
\index{drm\_property\_replace\_blob (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_property_replace_blob}\pysiglinewithargsret{bool \bfcode{drm\_property\_replace\_blob}}{struct {\hyperref[gpu/drm\string-kms:c.drm_property_blob]{\emph{drm\_property\_blob}}} **\emph{ blob}, struct {\hyperref[gpu/drm\string-kms:c.drm_property_blob]{\emph{drm\_property\_blob}}} *\emph{ new\_blob}}{}
replace a blob property

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_property\_blob ** blob}}] \leavevmode
a pointer to the member blob to be replaced

\item[{\code{struct drm\_property\_blob * new\_blob}}] \leavevmode
the new blob to replace with

\end{description}

\textbf{Return}

true if the blob was in fact replaced.


\subsection{Standard Connector Properties}
\label{gpu/drm-kms:standard-connector-properties}
DRM connectors have a few standardized properties:
\begin{description}
\item[{EDID:}] \leavevmode
Blob property which contains the current EDID read from the sink. This
is useful to parse sink identification information like vendor, model
and serial. Drivers should update this property by calling
{\hyperref[gpu/drm\string-kms:c.drm_mode_connector_update_edid_property]{\emph{\code{drm\_mode\_connector\_update\_edid\_property()}}}}, usually after having parsed
the EDID using {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_add_edid_modes]{\emph{\code{drm\_add\_edid\_modes()}}}}. Userspace cannot change this
property.

\item[{DPMS:}] \leavevmode
Legacy property for setting the power state of the connector. For atomic
drivers this is only provided for backwards compatibility with existing
drivers, it remaps to controlling the ``ACTIVE'' property on the CRTC the
connector is linked to. Drivers should never set this property directly,
it is handled by the DRM core by calling the {\hyperref[gpu/drm\string-kms:c.drm_connector_funcs]{\emph{\code{drm\_connector\_funcs.dpms}}}}
callback. For atomic drivers the remapping to the ``ACTIVE'' property is
implemented in the DRM core.  This is the only standard connector
property that userspace can change.

Note that this property cannot be set through the MODE\_ATOMIC ioctl,
userspace must use ``ACTIVE'' on the CRTC instead.

WARNING:

For userspace also running on legacy drivers the ``DPMS'' semantics are a
lot more complicated. First, userspace cannot rely on the ``DPMS'' value
returned by the GETCONNECTOR actually reflecting reality, because many
drivers fail to update it. For atomic drivers this is taken care of in
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_update_legacy_modeset_state]{\emph{\code{drm\_atomic\_helper\_update\_legacy\_modeset\_state()}}}}.

The second issue is that the DPMS state is only well-defined when the
connector is connected to a CRTC. In atomic the DRM core enforces that
``ACTIVE'' is off in such a case, no such checks exists for ``DPMS''.

Finally, when enabling an output using the legacy SETCONFIG ioctl then
``DPMS'' is forced to ON. But see above, that might not be reflected in
the software value on legacy drivers.

Summarizing: Only set ``DPMS'' when the connector is known to be enabled,
assume that a successful SETCONFIG call also sets ``DPMS'' to on, and
never read back the value of ``DPMS'' because it can be incorrect.

\item[{PATH:}] \leavevmode
Connector path property to identify how this sink is physically
connected. Used by DP MST. This should be set by calling
{\hyperref[gpu/drm\string-kms:c.drm_mode_connector_set_path_property]{\emph{\code{drm\_mode\_connector\_set\_path\_property()}}}}, in the case of DP MST with the
path property the MST manager created. Userspace cannot change this
property.

\item[{TILE:}] \leavevmode
Connector tile group property to indicate how a set of DRM connector
compose together into one logical screen. This is used by both high-res
external screens (often only using a single cable, but exposing multiple
DP MST sinks), or high-res integrated panels (like dual-link DSI) which
are not gen-locked. Note that for tiled panels which are genlocked, like
dual-link LVDS or dual-link DSI, the driver should try to not expose the
tiling and virtualize both {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} and {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{drm\_plane}}}} if needed. Drivers
should update this value using {\hyperref[gpu/drm\string-kms:c.drm_mode_connector_set_tile_property]{\emph{\code{drm\_mode\_connector\_set\_tile\_property()}}}}.
Userspace cannot change this property.

\item[{link-status:}] \leavevmode
Connector link-status property to indicate the status of link. The default
value of link-status is ``GOOD''. If something fails during or after modeset,
the kernel driver may set this to ``BAD'' and issue a hotplug uevent. Drivers
should update this value using {\hyperref[gpu/drm\string-kms:c.drm_mode_connector_set_link_status_property]{\emph{\code{drm\_mode\_connector\_set\_link\_status\_property()}}}}.

\item[{non\_desktop:}] \leavevmode
Indicates the output should be ignored for purposes of displaying a
standard desktop environment or console. This is most likely because
the output device is not rectilinear.

\end{description}

Connectors also have one standardized atomic property:
\begin{description}
\item[{CRTC\_ID:}] \leavevmode
Mode object ID of the {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} this connector should be connected to.

\end{description}

Connectors for LCD panels may also have one standardized property:
\begin{description}
\item[{panel orientation:}] \leavevmode
On some devices the LCD panel is mounted in the casing in such a way
that the up/top side of the panel does not match with the top side of
the device. Userspace can use this property to check for this.
Note that input coordinates from touchscreens (input devices with
INPUT\_PROP\_DIRECT) will still map 1:1 to the actual LCD panel
coordinates, so if userspace rotates the picture to adjust for
the orientation it must also apply the same transformation to the
touchscreen input coordinates.

\end{description}


\subsection{Plane Composition Properties}
\label{gpu/drm-kms:plane-composition-properties}
The basic plane composition model supported by standard plane properties only
has a source rectangle (in logical pixels within the {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}}), with
sub-pixel accuracy, which is scaled up to a pixel-aligned destination
rectangle in the visible area of a {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}}. The visible area of a CRTC is
defined by the horizontal and vertical visible pixels (stored in \textbf{hdisplay}
and \textbf{vdisplay}) of the requested mode (stored in {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.mode}}}}). These
two rectangles are both stored in the {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{drm\_plane\_state}}}}.

For the atomic ioctl the following standard (atomic) properties on the plane object
encode the basic plane composition model:
\begin{description}
\item[{SRC\_X:}] \leavevmode
X coordinate offset for the source rectangle within the
{\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}}, in 16.16 fixed point. Must be positive.

\item[{SRC\_Y:}] \leavevmode
Y coordinate offset for the source rectangle within the
{\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}}, in 16.16 fixed point. Must be positive.

\item[{SRC\_W:}] \leavevmode
Width for the source rectangle within the {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}}, in 16.16
fixed point. SRC\_X plus SRC\_W must be within the width of the source
framebuffer. Must be positive.

\item[{SRC\_H:}] \leavevmode
Height for the source rectangle within the {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}}, in 16.16
fixed point. SRC\_Y plus SRC\_H must be within the height of the source
framebuffer. Must be positive.

\item[{CRTC\_X:}] \leavevmode
X coordinate offset for the destination rectangle. Can be negative.

\item[{CRTC\_Y:}] \leavevmode
Y coordinate offset for the destination rectangle. Can be negative.

\item[{CRTC\_W:}] \leavevmode
Width for the destination rectangle. CRTC\_X plus CRTC\_W can extend past
the currently visible horizontal area of the {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}}.

\item[{CRTC\_H:}] \leavevmode
Height for the destination rectangle. CRTC\_Y plus CRTC\_H can extend past
the currently visible vertical area of the {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}}.

\item[{FB\_ID:}] \leavevmode
Mode object ID of the {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}} this plane should scan out.

\item[{CRTC\_ID:}] \leavevmode
Mode object ID of the {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} this plane should be connected to.

\end{description}

Note that the source rectangle must fully lie within the bounds of the
{\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}}. The destination rectangle can lie outside of the visible
area of the current mode of the CRTC. It must be apprpriately clipped by the
driver, which can be done by calling {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_check_update]{\emph{\code{drm\_plane\_helper\_check\_update()}}}}. Drivers
are also allowed to round the subpixel sampling positions appropriately, but
only to the next full pixel. No pixel outside of the source rectangle may
ever be sampled, which is important when applying more sophisticated
filtering than just a bilinear one when scaling. The filtering mode when
scaling is unspecified.

On top of this basic transformation additional properties can be exposed by
the driver:
\begin{itemize}
\item {} 
Rotation is set up with {\hyperref[gpu/drm\string-kms:c.drm_plane_create_rotation_property]{\emph{\code{drm\_plane\_create\_rotation\_property()}}}}. It adds a
rotation and reflection step between the source and destination rectangles.
Without this property the rectangle is only scaled, but not rotated or
reflected.

\item {} 
Z position is set up with {\hyperref[gpu/drm\string-kms:c.drm_plane_create_zpos_immutable_property]{\emph{\code{drm\_plane\_create\_zpos\_immutable\_property()}}}} and
{\hyperref[gpu/drm\string-kms:c.drm_plane_create_zpos_property]{\emph{\code{drm\_plane\_create\_zpos\_property()}}}}. It controls the visibility of overlapping
planes. Without this property the primary plane is always below the cursor
plane, and ordering between all other planes is undefined.

\end{itemize}

Note that all the property extensions described here apply either to the
plane or the CRTC (e.g. for the background color, which currently is not
exposed and assumed to be black).
\index{drm\_plane\_create\_rotation\_property (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_plane_create_rotation_property}\pysiglinewithargsret{int \bfcode{drm\_plane\_create\_rotation\_property}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, unsigned int\emph{ rotation}, unsigned int\emph{ supported\_rotations}}{}
create a new rotation property

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
drm plane

\item[{\code{unsigned int rotation}}] \leavevmode
initial value of the rotation property

\item[{\code{unsigned int supported\_rotations}}] \leavevmode
bitmask of supported rotations and reflections

\end{description}

\textbf{Description}

This creates a new property with the selected support for transformations.

Since a rotation by 180° degress is the same as reflecting both along the x
and the y axis the rotation property is somewhat redundant. Drivers can use
{\hyperref[gpu/drm\string-kms:c.drm_rotation_simplify]{\emph{\code{drm\_rotation\_simplify()}}}} to normalize values of this property.

The property exposed to userspace is a bitmask property (see
{\hyperref[gpu/drm\string-kms:c.drm_property_create_bitmask]{\emph{\code{drm\_property\_create\_bitmask()}}}}) called ``rotation'' and has the following
bitmask enumaration values:
\begin{description}
\item[{DRM\_MODE\_ROTATE\_0:}] \leavevmode
``rotate-0''

\item[{DRM\_MODE\_ROTATE\_90:}] \leavevmode
``rotate-90''

\item[{DRM\_MODE\_ROTATE\_180:}] \leavevmode
``rotate-180''

\item[{DRM\_MODE\_ROTATE\_270:}] \leavevmode
``rotate-270''

\item[{DRM\_MODE\_REFLECT\_X:}] \leavevmode
``reflect-x''

\item[{DRM\_MODE\_REFLECT\_Y:}] \leavevmode
``reflect-y''

\end{description}

Rotation is the specified amount in degrees in counter clockwise direction,
the X and Y axis are within the source rectangle, i.e.  the X/Y axis before
rotation. After reflection, the rotation is applied to the image sampled from
the source rectangle, before scaling it to fit the destination rectangle.
\index{drm\_rotation\_simplify (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_rotation_simplify}\pysiglinewithargsret{unsigned int \bfcode{drm\_rotation\_simplify}}{unsigned int\emph{ rotation}, unsigned int\emph{ supported\_rotations}}{}
Try to simplify the rotation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int rotation}}] \leavevmode
Rotation to be simplified

\item[{\code{unsigned int supported\_rotations}}] \leavevmode
Supported rotations

\end{description}

\textbf{Description}

Attempt to simplify the rotation to a form that is supported.
Eg. if the hardware supports everything except DRM\_MODE\_REFLECT\_X
one could call this function like this:
\begin{description}
\item[{drm\_rotation\_simplify(rotation, DRM\_MODE\_ROTATE\_0 \textbar{}}] \leavevmode
DRM\_MODE\_ROTATE\_90 \textbar{} DRM\_MODE\_ROTATE\_180 \textbar{}
DRM\_MODE\_ROTATE\_270 \textbar{} DRM\_MODE\_REFLECT\_Y);

\end{description}

to eliminate the DRM\_MODE\_ROTATE\_X flag. Depending on what kind of
transforms the hardware supports, this function may not
be able to produce a supported transform, so the caller should
check the result afterwards.
\index{drm\_plane\_create\_zpos\_property (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_plane_create_zpos_property}\pysiglinewithargsret{int \bfcode{drm\_plane\_create\_zpos\_property}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, unsigned int\emph{ zpos}, unsigned int\emph{ min}, unsigned int\emph{ max}}{}
create mutable zpos property

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
drm plane

\item[{\code{unsigned int zpos}}] \leavevmode
initial value of zpos property

\item[{\code{unsigned int min}}] \leavevmode
minimal possible value of zpos property

\item[{\code{unsigned int max}}] \leavevmode
maximal possible value of zpos property

\end{description}

\textbf{Description}

This function initializes generic mutable zpos property and enables support
for it in drm core. Drivers can then attach this property to planes to enable
support for configurable planes arrangement during blending operation.
Drivers that attach a mutable zpos property to any plane should call the
{\hyperref[gpu/drm\string-kms:c.drm_atomic_normalize_zpos]{\emph{\code{drm\_atomic\_normalize\_zpos()}}}} helper during their implementation of
{\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.atomic\_check()}}}}, which will update the normalized zpos
values and store them in {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{drm\_plane\_state.normalized\_zpos}}}}. Usually min
should be set to 0 and max to maximal number of planes for given crtc - 1.

If zpos of some planes cannot be changed (like fixed background or
cursor/topmost planes), driver should adjust min/max values and assign those
planes immutable zpos property with lower or higher values (for more
information, see {\hyperref[gpu/drm\string-kms:c.drm_plane_create_zpos_immutable_property]{\emph{\code{drm\_plane\_create\_zpos\_immutable\_property()}}}} function). In such
case driver should also assign proper initial zpos values for all planes in
its \code{plane\_reset()} callback, so the planes will be always sorted properly.

See also {\hyperref[gpu/drm\string-kms:c.drm_atomic_normalize_zpos]{\emph{\code{drm\_atomic\_normalize\_zpos()}}}}.

The property exposed to userspace is called ``zpos''.

\textbf{Return}

Zero on success, negative errno on failure.
\index{drm\_plane\_create\_zpos\_immutable\_property (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_plane_create_zpos_immutable_property}\pysiglinewithargsret{int \bfcode{drm\_plane\_create\_zpos\_immutable\_property}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, unsigned int\emph{ zpos}}{}
create immuttable zpos property

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
drm plane

\item[{\code{unsigned int zpos}}] \leavevmode
value of zpos property

\end{description}

\textbf{Description}

This function initializes generic immutable zpos property and enables
support for it in drm core. Using this property driver lets userspace
to get the arrangement of the planes for blending operation and notifies
it that the hardware (or driver) doesn't support changing of the planes'
order. For mutable zpos see {\hyperref[gpu/drm\string-kms:c.drm_plane_create_zpos_property]{\emph{\code{drm\_plane\_create\_zpos\_property()}}}}.

The property exposed to userspace is called ``zpos''.

\textbf{Return}

Zero on success, negative errno on failure.
\index{drm\_atomic\_normalize\_zpos (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_atomic_normalize_zpos}\pysiglinewithargsret{int \bfcode{drm\_atomic\_normalize\_zpos}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
calculate normalized zpos values for all crtcs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
atomic state of DRM device

\end{description}

\textbf{Description}

This function calculates normalized zpos value for all modified planes in
the provided atomic state of DRM device.

For every CRTC this function checks new states of all planes assigned to
it and calculates normalized zpos value for these planes. Planes are compared
first by their zpos values, then by plane id (if zpos is equal). The plane
with lowest zpos value is at the bottom. The {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{drm\_plane\_state.normalized\_zpos}}}}
is then filled with unique values from 0 to number of active planes in crtc
minus one.

RETURNS
Zero for success or -errno


\subsection{Color Management Properties}
\label{gpu/drm-kms:color-management-properties}
Color management or color space adjustments is supported through a set of 5
properties on the {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} object. They are set up by calling
{\hyperref[gpu/drm\string-kms:c.drm_crtc_enable_color_mgmt]{\emph{\code{drm\_crtc\_enable\_color\_mgmt()}}}}.
\begin{description}
\item[{``DEGAMMA\_LUT”:}] \leavevmode
Blob property to set the degamma lookup table (LUT) mapping pixel data
from the framebuffer before it is given to the transformation matrix.
The data is interpreted as an array of \code{struct drm\_color\_lut} elements.
Hardware might choose not to use the full precision of the LUT elements
nor use all the elements of the LUT (for example the hardware might
choose to interpolate between LUT{[}0{]} and LUT{[}4{]}).

Setting this to NULL (blob property value set to 0) means a
linear/pass-thru gamma table should be used. This is generally the
driver boot-up state too. Drivers can access this blob through
{\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.degamma\_lut}}}}.

\item[{“DEGAMMA\_LUT\_SIZE”:}] \leavevmode
Unsinged range property to give the size of the lookup table to be set
on the DEGAMMA\_LUT property (the size depends on the underlying
hardware). If drivers support multiple LUT sizes then they should
publish the largest size, and sub-sample smaller sized LUTs (e.g. for
split-gamma modes) appropriately.

\item[{“CTM”:}] \leavevmode
Blob property to set the current transformation matrix (CTM) apply to
pixel data after the lookup through the degamma LUT and before the
lookup through the gamma LUT. The data is interpreted as a struct
\code{drm\_color\_ctm}.

Setting this to NULL (blob property value set to 0) means a
unit/pass-thru matrix should be used. This is generally the driver
boot-up state too. Drivers can access the blob for the color conversion
matrix through {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.ctm}}}}.

\item[{“GAMMA\_LUT”:}] \leavevmode
Blob property to set the gamma lookup table (LUT) mapping pixel data
after the transformation matrix to data sent to the connector. The
data is interpreted as an array of \code{struct drm\_color\_lut} elements.
Hardware might choose not to use the full precision of the LUT elements
nor use all the elements of the LUT (for example the hardware might
choose to interpolate between LUT{[}0{]} and LUT{[}4{]}).

Setting this to NULL (blob property value set to 0) means a
linear/pass-thru gamma table should be used. This is generally the
driver boot-up state too. Drivers can access this blob through
{\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.gamma\_lut}}}}.

\item[{“GAMMA\_LUT\_SIZE”:}] \leavevmode
Unsigned range property to give the size of the lookup table to be set
on the GAMMA\_LUT property (the size depends on the underlying hardware).
If drivers support multiple LUT sizes then they should publish the
largest size, and sub-sample smaller sized LUTs (e.g. for split-gamma
modes) appropriately.

\end{description}

There is also support for a legacy gamma table, which is set up by calling
{\hyperref[gpu/drm\string-kms:c.drm_mode_crtc_set_gamma_size]{\emph{\code{drm\_mode\_crtc\_set\_gamma\_size()}}}}. Drivers which support both should use
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_legacy_gamma_set]{\emph{\code{drm\_atomic\_helper\_legacy\_gamma\_set()}}}} to alias the legacy gamma ramp with the
``GAMMA\_LUT'' property above.
\index{drm\_color\_lut\_extract (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_color_lut_extract}\pysiglinewithargsret{uint32\_t \bfcode{drm\_color\_lut\_extract}}{uint32\_t\emph{ user\_input}, uint32\_t\emph{ bit\_precision}}{}
clamp and round LUT entries

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{uint32\_t user\_input}}] \leavevmode
input value

\item[{\code{uint32\_t bit\_precision}}] \leavevmode
number of bits the hw LUT supports

\end{description}

\textbf{Description}

Extract a degamma/gamma LUT value provided by user (in the form of
\code{drm\_color\_lut} entries) and round it to the precision supported by the
hardware.
\index{drm\_crtc\_enable\_color\_mgmt (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_enable_color_mgmt}\pysiglinewithargsret{void \bfcode{drm\_crtc\_enable\_color\_mgmt}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, uint\emph{ degamma\_lut\_size}, bool\emph{ has\_ctm}, uint\emph{ gamma\_lut\_size}}{}
enable color management properties

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
DRM CRTC

\item[{\code{uint degamma\_lut\_size}}] \leavevmode
the size of the degamma lut (before CSC)

\item[{\code{bool has\_ctm}}] \leavevmode
whether to attach ctm\_property for CSC matrix

\item[{\code{uint gamma\_lut\_size}}] \leavevmode
the size of the gamma lut (after CSC)

\end{description}

\textbf{Description}

This function lets the driver enable the color correction
properties on a CRTC. This includes 3 degamma, csc and gamma
properties that userspace can set and 2 size properties to inform
the userspace of the lut sizes. Each of the properties are
optional. The gamma and degamma properties are only attached if
their size is not 0 and ctm\_property is only attached if has\_ctm is
true.

Drivers should use {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_legacy_gamma_set]{\emph{\code{drm\_atomic\_helper\_legacy\_gamma\_set()}}}} to implement the
legacy {\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.gamma\_set}}}} callback.
\index{drm\_mode\_crtc\_set\_gamma\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_mode_crtc_set_gamma_size}\pysiglinewithargsret{int \bfcode{drm\_mode\_crtc\_set\_gamma\_size}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, int\emph{ gamma\_size}}{}
set the gamma table size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
CRTC to set the gamma table size for

\item[{\code{int gamma\_size}}] \leavevmode
size of the gamma table

\end{description}

\textbf{Description}

Drivers which support gamma tables should set this to the supported gamma
table size when initializing the CRTC. Currently the drm core only supports a
fixed gamma table size.

\textbf{Return}

Zero on success, negative errno on failure.


\subsection{Tile Group Property}
\label{gpu/drm-kms:tile-group-property}
Tile groups are used to represent tiled monitors with a unique integer
identifier. Tiled monitors using DisplayID v1.3 have a unique 8-byte handle,
we store this in a tile group, so we have a common identifier for all tiles
in a monitor group. The property is called ``TILE''. Drivers can manage tile
groups using {\hyperref[gpu/drm\string-kms:c.drm_mode_create_tile_group]{\emph{\code{drm\_mode\_create\_tile\_group()}}}}, {\hyperref[gpu/drm\string-kms:c.drm_mode_put_tile_group]{\emph{\code{drm\_mode\_put\_tile\_group()}}}} and
{\hyperref[gpu/drm\string-kms:c.drm_mode_get_tile_group]{\emph{\code{drm\_mode\_get\_tile\_group()}}}}. But this is only needed for internal panels where
the tile group information is exposed through a non-standard way.


\subsection{Explicit Fencing Properties}
\label{gpu/drm-kms:explicit-fencing-properties}
Explicit fencing allows userspace to control the buffer synchronization
between devices. A Fence or a group of fences are transfered to/from
userspace using Sync File fds and there are two DRM properties for that.
IN\_FENCE\_FD on each DRM Plane to send fences to the kernel and
OUT\_FENCE\_PTR on each DRM CRTC to receive fences from the kernel.

As a contrast, with implicit fencing the kernel keeps track of any
ongoing rendering, and automatically ensures that the atomic update waits
for any pending rendering to complete. For shared buffers represented with
a \code{struct dma\_buf} this is tracked in \code{struct reservation\_object}.
Implicit syncing is how Linux traditionally worked (e.g. DRI2/3 on X.org),
whereas explicit fencing is what Android wants.
\begin{description}
\item[{``IN\_FENCE\_FD”:}] \leavevmode
Use this property to pass a fence that DRM should wait on before
proceeding with the Atomic Commit request and show the framebuffer for
the plane on the screen. The fence can be either a normal fence or a
merged one, the sync\_file framework will handle both cases and use a
fence\_array if a merged fence is received. Passing -1 here means no
fences to wait on.

If the Atomic Commit request has the DRM\_MODE\_ATOMIC\_TEST\_ONLY flag
it will only check if the Sync File is a valid one.

On the driver side the fence is stored on the \textbf{fence} parameter of
{\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{struct drm\_plane\_state}}}}. Drivers which also support implicit fencing
should set the implicit fence using {\hyperref[gpu/drm\string-kms:c.drm_atomic_set_fence_for_plane]{\emph{\code{drm\_atomic\_set\_fence\_for\_plane()}}}},
to make sure there's consistent behaviour between drivers in precedence
of implicit vs. explicit fencing.

\item[{``OUT\_FENCE\_PTR”:}] \leavevmode
Use this property to pass a file descriptor pointer to DRM. Once the
Atomic Commit request call returns OUT\_FENCE\_PTR will be filled with
the file descriptor number of a Sync File. This Sync File contains the
CRTC fence that will be signaled when all framebuffers present on the
Atomic Commit * request for that given CRTC are scanned out on the
screen.

The Atomic Commit request fails if a invalid pointer is passed. If the
Atomic Commit request fails for any other reason the out fence fd
returned will be -1. On a Atomic Commit with the
DRM\_MODE\_ATOMIC\_TEST\_ONLY flag the out fence will also be set to -1.

Note that out-fences don't have a special interface to drivers and are
internally represented by a {\hyperref[gpu/drm\string-kms:c.drm_pending_vblank_event]{\emph{\code{struct drm\_pending\_vblank\_event}}}} in struct
{\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state}}}}, which is also used by the nonblocking atomic commit
helpers and for the DRM event handling for existing userspace.

\end{description}


\subsection{Existing KMS Properties}
\label{gpu/drm-kms:existing-kms-properties}
The following table gives description of drm properties exposed by
various modules/drivers.

\begin{longtable}{|p{0.136\linewidth}|p{0.136\linewidth}|p{0.136\linewidth}|p{0.136\linewidth}|p{0.136\linewidth}|p{0.136\linewidth}|p{0.136\linewidth}|}
\hline
\textsf{\relax 
Owner Module/Drivers
} & \textsf{\relax 
Group
} & \textsf{\relax 
Property Name
} & \textsf{\relax 
Type
} & \textsf{\relax 
Property Values
} & \textsf{\relax 
Object attached
} & \textsf{\relax 
Description/Restrictions
}\\
\hline\endfirsthead

\multicolumn{7}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\textsf{\relax 
Owner Module/Drivers
} & \textsf{\relax 
Group
} & \textsf{\relax 
Property Name
} & \textsf{\relax 
Type
} & \textsf{\relax 
Property Values
} & \textsf{\relax 
Object attached
} & \textsf{\relax 
Description/Restrictions
}\\
\hline\endhead

\hline \multicolumn{7}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot

 &  & 
“scaling mode”
 & 
ENUM
 & 
\{ ``None'', ``Full'', ``Center'', ``Full aspect'' \}
 & 
Connector
 & 
Supported by: amdgpu, gma500, i915, nouveau and radeon.
\\
\hline & 
DVI-I
 & 
“subconnector”
 & 
ENUM
 & 
\{ “Unknown”, “DVI-D”, “DVI-A” \}
 & 
Connector
 & 
TBD
\\
\hline &  & 
“select subconnector”
 & 
ENUM
 & 
\{ “Automatic”, “DVI-D”, “DVI-A” \}
 & 
Connector
 & 
TBD
\\
\hline & 
TV
 & 
“subconnector”
 & 
ENUM
 & 
\{ ``Unknown'', ``Composite'', ``SVIDEO'', ``Component'', ``SCART'' \}
 & 
Connector
 & 
TBD
\\
\hline &  & 
“select subconnector”
 & 
ENUM
 & 
\{ ``Automatic'', ``Composite'', ``SVIDEO'', ``Component'', ``SCART'' \}
 & 
Connector
 & 
TBD
\\
\hline &  & 
“mode”
 & 
ENUM
 & 
\{ ``NTSC\_M'', ``NTSC\_J'', ``NTSC\_443'', ``PAL\_B'' \} etc.
 & 
Connector
 & 
TBD
\\
\hline &  & 
“left margin”
 & 
RANGE
 & 
Min=0, Max=100
 & 
Connector
 & 
TBD
\\
\hline &  & 
“right margin”
 & 
RANGE
 & 
Min=0, Max=100
 & 
Connector
 & 
TBD
\\
\hline &  & 
“top margin”
 & 
RANGE
 & 
Min=0, Max=100
 & 
Connector
 & 
TBD
\\
\hline &  & 
“bottom margin”
 & 
RANGE
 & 
Min=0, Max=100
 & 
Connector
 & 
TBD
\\
\hline &  & 
“brightness”
 & 
RANGE
 & 
Min=0, Max=100
 & 
Connector
 & 
TBD
\\
\hline &  & 
“contrast”
 & 
RANGE
 & 
Min=0, Max=100
 & 
Connector
 & 
TBD
\\
\hline &  & 
“flicker reduction”
 & 
RANGE
 & 
Min=0, Max=100
 & 
Connector
 & 
TBD
\\
\hline &  & 
“overscan”
 & 
RANGE
 & 
Min=0, Max=100
 & 
Connector
 & 
TBD
\\
\hline &  & 
“saturation”
 & 
RANGE
 & 
Min=0, Max=100
 & 
Connector
 & 
TBD
\\
\hline &  & 
“hue”
 & 
RANGE
 & 
Min=0, Max=100
 & 
Connector
 & 
TBD
\\
\hline & 
Virtual GPU
 & 
“suggested X”
 & 
RANGE
 & 
Min=0, Max=0xffffffff
 & 
Connector
 & 
property to suggest an X offset for a connector
\\
\hline &  & 
“suggested Y”
 & 
RANGE
 & 
Min=0, Max=0xffffffff
 & 
Connector
 & 
property to suggest an Y offset for a connector
\\
\hline & 
Optional
 & 
``aspect ratio''
 & 
ENUM
 & 
\{ ``None'', ``4:3'', ``16:9'' \}
 & 
Connector
 & 
TDB
\\
\hline
i915
 & 
Generic
 & 
``Broadcast RGB''
 & 
ENUM
 & 
\{ ``Automatic'', ``Full'', ``Limited 16:235'' \}
 & 
Connector
 & 
When this property is set to Limited 16:235 and CTM is set, the hardware will be programmed with the result of the multiplication of CTM by the limited range matrix to ensure the pixels normaly in the range 0..1.0 are remapped to the range 16/255..235/255.
\\
\hline &  & 
“audio”
 & 
ENUM
 & 
\{ ``force-dvi'', ``off'', ``auto'', ``on'' \}
 & 
Connector
 & 
TBD
\\
\hline & 
SDVO-TV
 & 
“mode”
 & 
ENUM
 & 
\{ ``NTSC\_M'', ``NTSC\_J'', ``NTSC\_443'', ``PAL\_B'' \} etc.
 & 
Connector
 & 
TBD
\\
\hline &  & 
``left\_margin''
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
``right\_margin''
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
``top\_margin''
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
``bottom\_margin''
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“hpos”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“vpos”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“contrast”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“saturation”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“hue”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“sharpness”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“flicker\_filter”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“flicker\_filter\_adaptive”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“flicker\_filter\_2d”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“tv\_chroma\_filter”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“tv\_luma\_filter”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“dot\_crawl”
 & 
RANGE
 & 
Min=0, Max=1
 & 
Connector
 & 
TBD
\\
\hline & 
SDVO-TV/LVDS
 & 
“brightness”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline
CDV gma-500
 & 
Generic
 & 
``Broadcast RGB''
 & 
ENUM
 & 
\{ “Full”, “Limited 16:235” \}
 & 
Connector
 & 
TBD
\\
\hline &  & 
``Broadcast RGB''
 & 
ENUM
 & 
\{ “off”, “auto”, “on” \}
 & 
Connector
 & 
TBD
\\
\hline
Poulsbo
 & 
Generic
 & 
“backlight”
 & 
RANGE
 & 
Min=0, Max=100
 & 
Connector
 & 
TBD
\\
\hline & 
SDVO-TV
 & 
“mode”
 & 
ENUM
 & 
\{ ``NTSC\_M'', ``NTSC\_J'', ``NTSC\_443'', ``PAL\_B'' \} etc.
 & 
Connector
 & 
TBD
\\
\hline &  & 
``left\_margin''
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
``right\_margin''
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
``top\_margin''
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
``bottom\_margin''
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“hpos”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“vpos”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“contrast”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“saturation”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“hue”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“sharpness”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“flicker\_filter”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“flicker\_filter\_adaptive”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“flicker\_filter\_2d”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“tv\_chroma\_filter”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“tv\_luma\_filter”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline &  & 
“dot\_crawl”
 & 
RANGE
 & 
Min=0, Max=1
 & 
Connector
 & 
TBD
\\
\hline & 
SDVO-TV/LVDS
 & 
“brightness”
 & 
RANGE
 & 
Min=0, Max= SDVO dependent
 & 
Connector
 & 
TBD
\\
\hline
armada
 & 
CRTC
 & 
``CSC\_YUV''
 & 
ENUM
 & 
\{ ``Auto'' , ``CCIR601'', ``CCIR709'' \}
 & 
CRTC
 & 
TBD
\\
\hline &  & 
``CSC\_RGB''
 & 
ENUM
 & 
\{ ``Auto'', ``Computer system'', ``Studio'' \}
 & 
CRTC
 & 
TBD
\\
\hline & 
Overlay
 & 
``colorkey''
 & 
RANGE
 & 
Min=0, Max=0xffffff
 & 
Plane
 & 
TBD
\\
\hline &  & 
``colorkey\_min''
 & 
RANGE
 & 
Min=0, Max=0xffffff
 & 
Plane
 & 
TBD
\\
\hline &  & 
``colorkey\_max''
 & 
RANGE
 & 
Min=0, Max=0xffffff
 & 
Plane
 & 
TBD
\\
\hline &  & 
``colorkey\_val''
 & 
RANGE
 & 
Min=0, Max=0xffffff
 & 
Plane
 & 
TBD
\\
\hline &  & 
``colorkey\_alpha''
 & 
RANGE
 & 
Min=0, Max=0xffffff
 & 
Plane
 & 
TBD
\\
\hline &  & 
``colorkey\_mode''
 & 
ENUM
 & 
\{ ``disabled'', ``Y component'', ``U component'' , ``V component'', ``RGB'', “R component'', ``G component'', ``B component'' \}
 & 
Plane
 & 
TBD
\\
\hline &  & 
``brightness''
 & 
RANGE
 & 
Min=0, Max=256 + 255
 & 
Plane
 & 
TBD
\\
\hline &  & 
``contrast''
 & 
RANGE
 & 
Min=0, Max=0x7fff
 & 
Plane
 & 
TBD
\\
\hline &  & 
``saturation''
 & 
RANGE
 & 
Min=0, Max=0x7fff
 & 
Plane
 & 
TBD
\\
\hline
exynos
 & 
CRTC
 & 
“mode”
 & 
ENUM
 & 
\{ ``normal'', ``blank'' \}
 & 
CRTC
 & 
TBD
\\
\hline
i2c/ch7006\_drv
 & 
Generic
 & 
“scale”
 & 
RANGE
 & 
Min=0, Max=2
 & 
Connector
 & 
TBD
\\
\hline & 
TV
 & 
“mode”
 & 
ENUM
 & 
\{ ``PAL'', ``PAL-M'',''PAL-N''\}, ”PAL-Nc'' , ``PAL-60'', ``NTSC-M'', ``NTSC-J'' \}
 & 
Connector
 & 
TBD
\\
\hline
nouveau
 & 
NV10 Overlay
 & 
``colorkey''
 & 
RANGE
 & 
Min=0, Max=0x01ffffff
 & 
Plane
 & 
TBD
\\
\hline &  & 
“contrast”
 & 
RANGE
 & 
Min=0, Max=8192-1
 & 
Plane
 & 
TBD
\\
\hline &  & 
“brightness”
 & 
RANGE
 & 
Min=0, Max=1024
 & 
Plane
 & 
TBD
\\
\hline &  & 
“hue”
 & 
RANGE
 & 
Min=0, Max=359
 & 
Plane
 & 
TBD
\\
\hline &  & 
“saturation”
 & 
RANGE
 & 
Min=0, Max=8192-1
 & 
Plane
 & 
TBD
\\
\hline &  & 
“iturbt\_709”
 & 
RANGE
 & 
Min=0, Max=1
 & 
Plane
 & 
TBD
\\
\hline & 
Nv04 Overlay
 & 
“colorkey”
 & 
RANGE
 & 
Min=0, Max=0x01ffffff
 & 
Plane
 & 
TBD
\\
\hline &  & 
“brightness”
 & 
RANGE
 & 
Min=0, Max=1024
 & 
Plane
 & 
TBD
\\
\hline & 
Display
 & 
“dithering mode”
 & 
ENUM
 & 
\{ ``auto'', ``off'', ``on'' \}
 & 
Connector
 & 
TBD
\\
\hline &  & 
“dithering depth”
 & 
ENUM
 & 
\{ ``auto'', ``off'', ``on'', ``static 2x2'', ``dynamic 2x2'', ``temporal'' \}
 & 
Connector
 & 
TBD
\\
\hline &  & 
“underscan”
 & 
ENUM
 & 
\{ ``auto'', ``6 bpc'', ``8 bpc'' \}
 & 
Connector
 & 
TBD
\\
\hline &  & 
“underscan hborder”
 & 
RANGE
 & 
Min=0, Max=128
 & 
Connector
 & 
TBD
\\
\hline &  & 
“underscan vborder”
 & 
RANGE
 & 
Min=0, Max=128
 & 
Connector
 & 
TBD
\\
\hline &  & 
“vibrant hue”
 & 
RANGE
 & 
Min=0, Max=180
 & 
Connector
 & 
TBD
\\
\hline &  & 
“color vibrance”
 & 
RANGE
 & 
Min=0, Max=200
 & 
Connector
 & 
TBD
\\
\hline
omap
 & 
Generic
 & 
“zorder”
 & 
RANGE
 & 
Min=0, Max=3
 & 
CRTC, Plane
 & 
TBD
\\
\hline
qxl
 & 
Generic
 & 
“hotplug\_mode\_update''
 & 
RANGE
 & 
Min=0, Max=1
 & 
Connector
 & 
TBD
\\
\hline
radeon
 & 
DVI-I
 & 
“coherent”
 & 
RANGE
 & 
Min=0, Max=1
 & 
Connector
 & 
TBD
\\
\hline & 
DAC enable load detect
 & 
“load detection”
 & 
RANGE
 & 
Min=0, Max=1
 & 
Connector
 & 
TBD
\\
\hline & 
TV Standard
 & 
``tv standard''
 & 
ENUM
 & 
\{ ``ntsc'', ``pal'', ``pal-m'', ``pal-60'', ``ntsc-j'' , ``scart-pal'', ``pal-cn'', ``secam'' \}
 & 
Connector
 & 
TBD
\\
\hline & 
legacy TMDS PLL detect
 & 
``tmds\_pll''
 & 
ENUM
 & 
\{ ``driver'', ``bios'' \}
 & \begin{itemize}
\item {} 
\end{itemize}
 & 
TBD
\\
\hline & 
Underscan
 & 
``underscan''
 & 
ENUM
 & 
\{ ``off'', ``on'', ``auto'' \}
 & 
Connector
 & 
TBD
\\
\hline &  & 
``underscan hborder''
 & 
RANGE
 & 
Min=0, Max=128
 & 
Connector
 & 
TBD
\\
\hline &  & 
``underscan vborder''
 & 
RANGE
 & 
Min=0, Max=128
 & 
Connector
 & 
TBD
\\
\hline & 
Audio
 & 
“audio”
 & 
ENUM
 & 
\{ ``off'', ``on'', ``auto'' \}
 & 
Connector
 & 
TBD
\\
\hline & 
FMT Dithering
 & 
“dither”
 & 
ENUM
 & 
\{ ``off'', ``on'' \}
 & 
Connector
 & 
TBD
\\
\hline
rcar-du
 & 
Generic
 & 
``alpha''
 & 
RANGE
 & 
Min=0, Max=255
 & 
Plane
 & 
TBD
\\
\hline &  & 
``colorkey''
 & 
RANGE
 & 
Min=0, Max=0x01ffffff
 & 
Plane
 & 
TBD
\\
\hline\end{longtable}



\section{Vertical Blanking}
\label{gpu/drm-kms:vertical-blanking}
Vertical blanking plays a major role in graphics rendering. To achieve
tear-free display, users must synchronize page flips and/or rendering to
vertical blanking. The DRM API offers ioctls to perform page flips
synchronized to vertical blanking and wait for vertical blanking.

The DRM core handles most of the vertical blanking management logic, which
involves filtering out spurious interrupts, keeping race-free blanking
counters, coping with counter wrap-around and resets and keeping use counts.
It relies on the driver to generate vertical blanking interrupts and
optionally provide a hardware vertical blanking counter.

Drivers must initialize the vertical blanking handling core with a call to
{\hyperref[gpu/drm\string-kms:c.drm_vblank_init]{\emph{\code{drm\_vblank\_init()}}}}. Minimally, a driver needs to implement
{\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.enable\_vblank}}}} and {\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.disable\_vblank}}}} plus call
{\hyperref[gpu/drm\string-kms:c.drm_crtc_handle_vblank]{\emph{\code{drm\_crtc\_handle\_vblank()}}}} in it's vblank interrupt handler for working vblank
support.

Vertical blanking interrupts can be enabled by the DRM core or by drivers
themselves (for instance to handle page flipping operations).  The DRM core
maintains a vertical blanking use count to ensure that the interrupts are not
disabled while a user still needs them. To increment the use count, drivers
call {\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_get]{\emph{\code{drm\_crtc\_vblank\_get()}}}} and release the vblank reference again with
{\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_put]{\emph{\code{drm\_crtc\_vblank\_put()}}}}. In between these two calls vblank interrupts are
guaranteed to be enabled.

On many hardware disabling the vblank interrupt cannot be done in a race-free
manner, see {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.vblank\_disable\_immediate}}}} and
{\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.max\_vblank\_count}}}}. In that case the vblank core only disables the
vblanks after a timer has expired, which can be configured through the
\code{vblankoffdelay} module parameter.


\subsection{Vertical Blanking and Interrupt Handling Functions Reference}
\label{gpu/drm-kms:vertical-blanking-and-interrupt-handling-functions-reference}\index{drm\_pending\_vblank\_event (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_pending_vblank_event}\pysigline{struct \bfcode{drm\_pending\_vblank\_event}}
pending vblank event tracking

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}pending\PYGZus{}vblank\PYGZus{}event \PYGZob{}
  struct drm\PYGZus{}pending\PYGZus{}event base;
  unsigned int pipe;
  u64 sequence;
  union \PYGZob{}
    struct drm\PYGZus{}event base;
    struct drm\PYGZus{}event\PYGZus{}vblank vbl;
    struct drm\PYGZus{}event\PYGZus{}crtc\PYGZus{}sequence seq;
  \PYGZcb{} event;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{base}}] \leavevmode
Base structure for tracking pending DRM events.

\item[{\code{pipe}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_crtc_index]{\emph{\code{drm\_crtc\_index()}}}} of the {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} this event is for.

\item[{\code{sequence}}] \leavevmode
frame event should be triggered at

\item[{\code{event}}] \leavevmode
Actual event which will be sent to userspace.

\end{description}
\index{drm\_vblank\_crtc (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_vblank_crtc}\pysigline{struct \bfcode{drm\_vblank\_crtc}}
vblank tracking for a CRTC

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}vblank\PYGZus{}crtc \PYGZob{}
  struct drm\PYGZus{}device *dev;
  wait\PYGZus{}queue\PYGZus{}head\PYGZus{}t queue;
  struct timer\PYGZus{}list disable\PYGZus{}timer;
  seqlock\PYGZus{}t seqlock;
  u64 count;
  ktime\PYGZus{}t time;
  atomic\PYGZus{}t refcount;
  u32 last;
  unsigned int inmodeset;
  unsigned int pipe;
  int framedur\PYGZus{}ns;
  int linedur\PYGZus{}ns;
  struct drm\PYGZus{}display\PYGZus{}mode hwmode;
  bool enabled;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev}}] \leavevmode
Pointer to the \code{drm\_device}.

\item[{\code{queue}}] \leavevmode
Wait queue for vblank waiters.

\item[{\code{disable\_timer}}] \leavevmode
Disable timer for the delayed vblank disabling
hysteresis logic. Vblank disabling is controlled through the
drm\_vblank\_offdelay module option and the setting of the
\code{drm\_device.max\_vblank\_count} value.

\item[{\code{seqlock}}] \leavevmode
Protect vblank count and time.

\item[{\code{count}}] \leavevmode
Current software vblank counter.

\item[{\code{time}}] \leavevmode
Vblank timestamp corresponding to \textbf{count}.

\item[{\code{refcount}}] \leavevmode
Number of users/waiters of the vblank interrupt. Only when
this refcount reaches 0 can the hardware interrupt be disabled using
\textbf{disable\_timer}.

\item[{\code{last}}] \leavevmode
Protected by \code{drm\_device.vbl\_lock}, used for wraparound handling.

\item[{\code{inmodeset}}] \leavevmode
Tracks whether the vblank is disabled due to a modeset.
For legacy driver bit 2 additionally tracks whether an additional
temporary vblank reference has been acquired to paper over the
hardware counter resetting/jumping. KMS drivers should instead just
call {\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_off]{\emph{\code{drm\_crtc\_vblank\_off()}}}} and {\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_on]{\emph{\code{drm\_crtc\_vblank\_on()}}}}, which explicitly
save and restore the vblank count.

\item[{\code{pipe}}] \leavevmode
{\hyperref[gpu/drm\string-kms:c.drm_crtc_index]{\emph{\code{drm\_crtc\_index()}}}} of the {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} corresponding to this
structure.

\item[{\code{framedur\_ns}}] \leavevmode
Frame/Field duration in ns, used by
{\hyperref[gpu/drm\string-kms:c.drm_calc_vbltimestamp_from_scanoutpos]{\emph{\code{drm\_calc\_vbltimestamp\_from\_scanoutpos()}}}} and computed by
{\hyperref[gpu/drm\string-kms:c.drm_calc_timestamping_constants]{\emph{\code{drm\_calc\_timestamping\_constants()}}}}.

\item[{\code{linedur\_ns}}] \leavevmode
Line duration in ns, used by
{\hyperref[gpu/drm\string-kms:c.drm_calc_vbltimestamp_from_scanoutpos]{\emph{\code{drm\_calc\_vbltimestamp\_from\_scanoutpos()}}}} and computed by
{\hyperref[gpu/drm\string-kms:c.drm_calc_timestamping_constants]{\emph{\code{drm\_calc\_timestamping\_constants()}}}}.

\item[{\code{hwmode}}] \leavevmode
Cache of the current hardware display mode. Only valid when \textbf{enabled}
is set. This is used by helpers like
{\hyperref[gpu/drm\string-kms:c.drm_calc_vbltimestamp_from_scanoutpos]{\emph{\code{drm\_calc\_vbltimestamp\_from\_scanoutpos()}}}}. We can't just access the
hardware mode by e.g. looking at {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.adjusted\_mode}}}},
because that one is really hard to get from interrupt context.

\item[{\code{enabled}}] \leavevmode
Tracks the enabling state of the corresponding {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} to
avoid double-disabling and hence corrupting saved state. Needed by
drivers not using atomic KMS, since those might go through their CRTC
disabling functions multiple times.

\end{description}

\textbf{Description}

This structure tracks the vblank state for one CRTC.

Note that for historical reasons - the vblank handling code is still shared
with legacy/non-kms drivers - this is a free-standing structure not directly
connected to {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{struct drm\_crtc}}}}. But all public interface functions are taking
a {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{struct drm\_crtc}}}} to hide this implementation detail.
\index{drm\_crtc\_accurate\_vblank\_count (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_accurate_vblank_count}\pysiglinewithargsret{u32 \bfcode{drm\_crtc\_accurate\_vblank\_count}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
retrieve the master vblank counter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
which counter to retrieve

\end{description}

\textbf{Description}

This function is similar to {\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_count]{\emph{\code{drm\_crtc\_vblank\_count()}}}} but this function
interpolates to handle a race with vblank interrupts using the high precision
timestamping support.

This is mostly useful for hardware that can obtain the scanout position, but
doesn't have a hardware frame counter.
\index{drm\_vblank\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_vblank_init}\pysiglinewithargsret{int \bfcode{drm\_vblank\_init}}{struct drm\_device *\emph{ dev}, unsigned int\emph{ num\_crtcs}}{}
initialize vblank support

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{unsigned int num\_crtcs}}] \leavevmode
number of CRTCs supported by \textbf{dev}

\end{description}

\textbf{Description}

This function initializes vblank support for \textbf{num\_crtcs} display pipelines.
Cleanup is handled by the DRM core, or through calling {\hyperref[gpu/drm\string-internals:c.drm_dev_fini]{\emph{\code{drm\_dev\_fini()}}}} for
drivers with a {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.release}}}} callback.

\textbf{Return}

Zero on success or a negative error code on failure.
\index{drm\_crtc\_vblank\_waitqueue (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_vblank_waitqueue}\pysiglinewithargsret{wait\_queue\_head\_t * \bfcode{drm\_crtc\_vblank\_waitqueue}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
get vblank waitqueue for the CRTC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
which CRTC's vblank waitqueue to retrieve

\end{description}

\textbf{Description}

This function returns a pointer to the vblank waitqueue for the CRTC.
Drivers can use this to implement vblank waits using \code{wait\_event()} and related
functions.
\index{drm\_calc\_timestamping\_constants (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_calc_timestamping_constants}\pysiglinewithargsret{void \bfcode{drm\_calc\_timestamping\_constants}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
calculate vblank timestamp constants

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
drm\_crtc whose timestamp constants should be updated.

\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
display mode containing the scanout timings

\end{description}

\textbf{Description}

Calculate and store various constants which are later needed by vblank and
swap-completion timestamping, e.g, by
{\hyperref[gpu/drm\string-kms:c.drm_calc_vbltimestamp_from_scanoutpos]{\emph{\code{drm\_calc\_vbltimestamp\_from\_scanoutpos()}}}}. They are derived from CRTC's true
scanout timing, so they take things like panel scaling or other adjustments
into account.
\index{drm\_calc\_vbltimestamp\_from\_scanoutpos (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_calc_vbltimestamp_from_scanoutpos}\pysiglinewithargsret{bool \bfcode{drm\_calc\_vbltimestamp\_from\_scanoutpos}}{struct drm\_device *\emph{ dev}, unsigned int\emph{ pipe}, int *\emph{ max\_error}, ktime\_t *\emph{ vblank\_time}, bool\emph{ in\_vblank\_irq}}{}
precise vblank timestamp helper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{unsigned int pipe}}] \leavevmode
index of CRTC whose vblank timestamp to retrieve

\item[{\code{int * max\_error}}] \leavevmode
Desired maximum allowable error in timestamps (nanosecs)
On return contains true maximum error of timestamp

\item[{\code{ktime\_t * vblank\_time}}] \leavevmode
Pointer to time which should receive the timestamp

\item[{\code{bool in\_vblank\_irq}}] \leavevmode
True when called from {\hyperref[gpu/drm\string-kms:c.drm_crtc_handle_vblank]{\emph{\code{drm\_crtc\_handle\_vblank()}}}}.  Some drivers
need to apply some workarounds for gpu-specific vblank irq quirks
if flag is set.

\end{description}

\textbf{Description}

Implements calculation of exact vblank timestamps from given drm\_display\_mode
timings and current video scanout position of a CRTC. This can be directly
used as the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.get\_vblank\_timestamp}}}} implementation of a kms driver
if {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.get\_scanout\_position}}}} is implemented.

The current implementation only handles standard video modes. For double scan
and interlaced modes the driver is supposed to adjust the hardware mode
(taken from {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.adjusted}}}} mode for atomic modeset drivers) to
match the scanout position reported.

Note that atomic drivers must call {\hyperref[gpu/drm\string-kms:c.drm_calc_timestamping_constants]{\emph{\code{drm\_calc\_timestamping\_constants()}}}} before
enabling a CRTC. The atomic helpers already take care of that in
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_update_legacy_modeset_state]{\emph{\code{drm\_atomic\_helper\_update\_legacy\_modeset\_state()}}}}.

\textbf{Return}

Returns true on success, and false on failure, i.e. when no accurate
timestamp could be acquired.
\index{drm\_crtc\_vblank\_count (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_vblank_count}\pysiglinewithargsret{u64 \bfcode{drm\_crtc\_vblank\_count}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
retrieve ``cooked'' vblank counter value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
which counter to retrieve

\end{description}

\textbf{Description}

Fetches the ``cooked'' vblank count value that represents the number of
vblank events since the system was booted, including lost events due to
modesetting activity. Note that this timer isn't correct against a racing
vblank interrupt (since it only reports the software vblank counter), see
{\hyperref[gpu/drm\string-kms:c.drm_crtc_accurate_vblank_count]{\emph{\code{drm\_crtc\_accurate\_vblank\_count()}}}} for such use-cases.

\textbf{Return}

The software vblank counter.
\index{drm\_crtc\_vblank\_count\_and\_time (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_vblank_count_and_time}\pysiglinewithargsret{u64 \bfcode{drm\_crtc\_vblank\_count\_and\_time}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, ktime\_t *\emph{ vblanktime}}{}
retrieve ``cooked'' vblank counter value and the system timestamp corresponding to that vblank counter value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
which counter to retrieve

\item[{\code{ktime\_t * vblanktime}}] \leavevmode
Pointer to time to receive the vblank timestamp.

\end{description}

\textbf{Description}

Fetches the ``cooked'' vblank count value that represents the number of
vblank events since the system was booted, including lost events due to
modesetting activity. Returns corresponding system timestamp of the time
of the vblank interval that corresponds to the current vblank counter value.
\index{drm\_crtc\_arm\_vblank\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_arm_vblank_event}\pysiglinewithargsret{void \bfcode{drm\_crtc\_arm\_vblank\_event}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, struct {\hyperref[gpu/drm\string-kms:c.drm_pending_vblank_event]{\emph{drm\_pending\_vblank\_event}}} *\emph{ e}}{}
arm vblank event after pageflip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
the source CRTC of the vblank event

\item[{\code{struct drm\_pending\_vblank\_event * e}}] \leavevmode
the event to send

\end{description}

\textbf{Description}

A lot of drivers need to generate vblank events for the very next vblank
interrupt. For example when the page flip interrupt happens when the page
flip gets armed, but not when it actually executes within the next vblank
period. This helper function implements exactly the required vblank arming
behaviour.

\textbf{NOTE}

Drivers using this to send out the {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.event}}}} as part of an
atomic commit must ensure that the next vblank happens at exactly the same
time as the atomic commit is committed to the hardware. This function itself
does \textbf{not} protect against the next vblank interrupt racing with either this
function call or the atomic commit operation. A possible sequence could be:
\begin{enumerate}
\item {} 
Driver commits new hardware state into vblank-synchronized registers.

\item {} 
A vblank happens, committing the hardware state. Also the corresponding
vblank interrupt is fired off and fully processed by the interrupt
handler.

\item {} 
The atomic commit operation proceeds to call {\hyperref[gpu/drm\string-kms:c.drm_crtc_arm_vblank_event]{\emph{\code{drm\_crtc\_arm\_vblank\_event()}}}}.

\item {} 
The event is only send out for the next vblank, which is wrong.

\end{enumerate}

An equivalent race can happen when the driver calls
{\hyperref[gpu/drm\string-kms:c.drm_crtc_arm_vblank_event]{\emph{\code{drm\_crtc\_arm\_vblank\_event()}}}} before writing out the new hardware state.

The only way to make this work safely is to prevent the vblank from firing
(and the hardware from committing anything else) until the entire atomic
commit sequence has run to completion. If the hardware does not have such a
feature (e.g. using a ``go'' bit), then it is unsafe to use this functions.
Instead drivers need to manually send out the event from their interrupt
handler by calling {\hyperref[gpu/drm\string-kms:c.drm_crtc_send_vblank_event]{\emph{\code{drm\_crtc\_send\_vblank\_event()}}}} and make sure that there's no
possible race with the hardware committing the atomic update.

Caller must hold a vblank reference for the event \textbf{e}, which will be dropped
when the next vblank arrives.
\index{drm\_crtc\_send\_vblank\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_send_vblank_event}\pysiglinewithargsret{void \bfcode{drm\_crtc\_send\_vblank\_event}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, struct {\hyperref[gpu/drm\string-kms:c.drm_pending_vblank_event]{\emph{drm\_pending\_vblank\_event}}} *\emph{ e}}{}
helper to send vblank event after pageflip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
the source CRTC of the vblank event

\item[{\code{struct drm\_pending\_vblank\_event * e}}] \leavevmode
the event to send

\end{description}

\textbf{Description}

Updates sequence \# and timestamp on event for the most recently processed
vblank, and sends it to userspace.  Caller must hold event lock.

See {\hyperref[gpu/drm\string-kms:c.drm_crtc_arm_vblank_event]{\emph{\code{drm\_crtc\_arm\_vblank\_event()}}}} for a helper which can be used in certain
situation, especially to send out events for atomic commit operations.
\index{drm\_crtc\_vblank\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_vblank_get}\pysiglinewithargsret{int \bfcode{drm\_crtc\_vblank\_get}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
get a reference count on vblank events

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
which CRTC to own

\end{description}

\textbf{Description}

Acquire a reference count on vblank events to avoid having them disabled
while in use.

\textbf{Return}

Zero on success or a negative error code on failure.
\index{drm\_crtc\_vblank\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_vblank_put}\pysiglinewithargsret{void \bfcode{drm\_crtc\_vblank\_put}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
give up ownership of vblank events

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
which counter to give up

\end{description}

\textbf{Description}

Release ownership of a given vblank counter, turning off interrupts
if possible. Disable interrupts after drm\_vblank\_offdelay milliseconds.
\index{drm\_wait\_one\_vblank (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_wait_one_vblank}\pysiglinewithargsret{void \bfcode{drm\_wait\_one\_vblank}}{struct drm\_device *\emph{ dev}, unsigned int\emph{ pipe}}{}
wait for one vblank

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{unsigned int pipe}}] \leavevmode
CRTC index

\end{description}

\textbf{Description}

This waits for one vblank to pass on \textbf{pipe}, using the irq driver interfaces.
It is a failure to call this when the vblank irq for \textbf{pipe} is disabled, e.g.
due to lack of driver support or because the crtc is off.

This is the legacy version of {\hyperref[gpu/drm\string-kms:c.drm_crtc_wait_one_vblank]{\emph{\code{drm\_crtc\_wait\_one\_vblank()}}}}.
\index{drm\_crtc\_wait\_one\_vblank (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_wait_one_vblank}\pysiglinewithargsret{void \bfcode{drm\_crtc\_wait\_one\_vblank}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
wait for one vblank

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
DRM crtc

\end{description}

\textbf{Description}

This waits for one vblank to pass on \textbf{crtc}, using the irq driver interfaces.
It is a failure to call this when the vblank irq for \textbf{crtc} is disabled, e.g.
due to lack of driver support or because the crtc is off.
\index{drm\_crtc\_vblank\_off (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_vblank_off}\pysiglinewithargsret{void \bfcode{drm\_crtc\_vblank\_off}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
disable vblank events on a CRTC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
CRTC in question

\end{description}

\textbf{Description}

Drivers can use this function to shut down the vblank interrupt handling when
disabling a crtc. This function ensures that the latest vblank frame count is
stored so that drm\_vblank\_on can restore it again.

Drivers must use this function when the hardware vblank counter can get
reset, e.g. when suspending or disabling the \textbf{crtc} in general.
\index{drm\_crtc\_vblank\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_vblank_reset}\pysiglinewithargsret{void \bfcode{drm\_crtc\_vblank\_reset}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
reset vblank state to off on a CRTC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
CRTC in question

\end{description}

\textbf{Description}

Drivers can use this function to reset the vblank state to off at load time.
Drivers should use this together with the {\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_off]{\emph{\code{drm\_crtc\_vblank\_off()}}}} and
{\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_on]{\emph{\code{drm\_crtc\_vblank\_on()}}}} functions. The difference compared to
{\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_off]{\emph{\code{drm\_crtc\_vblank\_off()}}}} is that this function doesn't save the vblank counter
and hence doesn't need to call any driver hooks.

This is useful for recovering driver state e.g. on driver load, or on resume.
\index{drm\_crtc\_vblank\_on (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_vblank_on}\pysiglinewithargsret{void \bfcode{drm\_crtc\_vblank\_on}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
enable vblank events on a CRTC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
CRTC in question

\end{description}

\textbf{Description}

This functions restores the vblank interrupt state captured with
{\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_off]{\emph{\code{drm\_crtc\_vblank\_off()}}}} again and is generally called when enabling \textbf{crtc}. Note
that calls to {\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_on]{\emph{\code{drm\_crtc\_vblank\_on()}}}} and {\hyperref[gpu/drm\string-kms:c.drm_crtc_vblank_off]{\emph{\code{drm\_crtc\_vblank\_off()}}}} can be
unbalanced and so can also be unconditionally called in driver load code to
reflect the current hardware state of the crtc.
\index{drm\_handle\_vblank (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_handle_vblank}\pysiglinewithargsret{bool \bfcode{drm\_handle\_vblank}}{struct drm\_device *\emph{ dev}, unsigned int\emph{ pipe}}{}
handle a vblank event

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{unsigned int pipe}}] \leavevmode
index of CRTC where this event occurred

\end{description}

\textbf{Description}

Drivers should call this routine in their vblank interrupt handlers to
update the vblank counter and send any signals that may be pending.

This is the legacy version of {\hyperref[gpu/drm\string-kms:c.drm_crtc_handle_vblank]{\emph{\code{drm\_crtc\_handle\_vblank()}}}}.
\index{drm\_crtc\_handle\_vblank (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms:c.drm_crtc_handle_vblank}\pysiglinewithargsret{bool \bfcode{drm\_crtc\_handle\_vblank}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
handle a vblank event

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
where this event occurred

\end{description}

\textbf{Description}

Drivers should call this routine in their vblank interrupt handlers to
update the vblank counter and send any signals that may be pending.

This is the native KMS version of {\hyperref[gpu/drm\string-kms:c.drm_handle_vblank]{\emph{\code{drm\_handle\_vblank()}}}}.

\textbf{Return}

True if the event was successfully handled, false on failure.


\chapter{Mode Setting Helper Functions}
\label{gpu/drm-kms-helpers:mode-setting-helper-functions}\label{gpu/drm-kms-helpers::doc}
The DRM subsystem aims for a strong separation between core code and helper
libraries. Core code takes care of general setup and teardown and decoding
userspace requests to kernel internal objects. Everything else is handled by a
large set of helper libraries, which can be combined freely to pick and choose
for each driver what fits, and avoid shared code where special behaviour is
needed.

This distinction between core code and helpers is especially strong in the
modesetting code, where there's a shared userspace ABI for all drivers. This is
in contrast to the render side, where pretty much everything (with very few
exceptions) can be considered optional helper code.

There are a few areas these helpers can grouped into:
\begin{itemize}
\item {} 
Helpers to implement modesetting. The important ones here are the atomic
helpers. Old drivers still often use the legacy CRTC helpers. They both share
the same set of common helper vtables. For really simple drivers (anything
that would have been a great fit in the deprecated fbdev subsystem) there's
also the simple display pipe helpers.

\item {} 
There's a big pile of helpers for handling outputs. First the generic bridge
helpers for handling encoder and transcoder IP blocks. Second the panel helpers
for handling panel-related information and logic. Plus then a big set of
helpers for the various sink standards (DisplayPort, HDMI, MIPI DSI). Finally
there's also generic helpers for handling output probing, and for dealing with
EDIDs.

\item {} 
The last group of helpers concerns itself with the frontend side of a display
pipeline: Planes, handling rectangles for visibility checking and scissoring,
flip queues and assorted bits.

\end{itemize}


\section{Modeset Helper Reference for Common Vtables}
\label{gpu/drm-kms-helpers:modeset-helper-reference-for-common-vtables}
The DRM mode setting helper functions are common code for drivers to use if
they wish.  Drivers are not forced to use this code in their
implementations but it would be useful if the code they do use at least
provides a consistent interface and operation to userspace. Therefore it is
highly recommended to use the provided helpers as much as possible.

Because there is only one pointer per modeset object to hold a vfunc table
for helper libraries they are by necessity shared among the different
helpers.

To make this clear all the helper vtables are pulled together in this location here.
\index{drm\_crtc\_helper\_funcs (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_crtc_helper_funcs}\pysigline{struct \bfcode{drm\_crtc\_helper\_funcs}}
helper operations for CRTCs

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}crtc\PYGZus{}helper\PYGZus{}funcs \PYGZob{}
  void (*dpms)(struct drm\PYGZus{}crtc *crtc, int mode);
  void (*prepare)(struct drm\PYGZus{}crtc *crtc);
  void (*commit)(struct drm\PYGZus{}crtc *crtc);
  enum drm\PYGZus{}mode\PYGZus{}status (*mode\PYGZus{}valid)(struct drm\PYGZus{}crtc *crtc, const struct drm\PYGZus{}display\PYGZus{}mode *mode);
  bool (*mode\PYGZus{}fixup)(struct drm\PYGZus{}crtc *crtc,const struct drm\PYGZus{}display\PYGZus{}mode *mode, struct drm\PYGZus{}display\PYGZus{}mode *adjusted\PYGZus{}mode);
  int (*mode\PYGZus{}set)(struct drm\PYGZus{}crtc *crtc, struct drm\PYGZus{}display\PYGZus{}mode *mode,struct drm\PYGZus{}display\PYGZus{}mode *adjusted\PYGZus{}mode, int x, int y, struct drm\PYGZus{}framebuffer *old\PYGZus{}fb);
  void (*mode\PYGZus{}set\PYGZus{}nofb)(struct drm\PYGZus{}crtc *crtc);
  int (*mode\PYGZus{}set\PYGZus{}base)(struct drm\PYGZus{}crtc *crtc, int x, int y, struct drm\PYGZus{}framebuffer *old\PYGZus{}fb);
  int (*mode\PYGZus{}set\PYGZus{}base\PYGZus{}atomic)(struct drm\PYGZus{}crtc *crtc,struct drm\PYGZus{}framebuffer *fb, int x, int y, enum mode\PYGZus{}set\PYGZus{}atomic);
  void (*disable)(struct drm\PYGZus{}crtc *crtc);
  int (*atomic\PYGZus{}check)(struct drm\PYGZus{}crtc *crtc, struct drm\PYGZus{}crtc\PYGZus{}state *state);
  void (*atomic\PYGZus{}begin)(struct drm\PYGZus{}crtc *crtc, struct drm\PYGZus{}crtc\PYGZus{}state *old\PYGZus{}crtc\PYGZus{}state);
  void (*atomic\PYGZus{}flush)(struct drm\PYGZus{}crtc *crtc, struct drm\PYGZus{}crtc\PYGZus{}state *old\PYGZus{}crtc\PYGZus{}state);
  void (*atomic\PYGZus{}enable)(struct drm\PYGZus{}crtc *crtc, struct drm\PYGZus{}crtc\PYGZus{}state *old\PYGZus{}crtc\PYGZus{}state);
  void (*atomic\PYGZus{}disable)(struct drm\PYGZus{}crtc *crtc, struct drm\PYGZus{}crtc\PYGZus{}state *old\PYGZus{}crtc\PYGZus{}state);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dpms}}] \leavevmode
Callback to control power levels on the CRTC.  If the mode passed in
is unsupported, the provider must use the next lowest power level.
This is used by the legacy CRTC helpers to implement DPMS
functionality in {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_helper_connector_dpms]{\emph{\code{drm\_helper\_connector\_dpms()}}}}.

This callback is also used to disable a CRTC by calling it with
DRM\_MODE\_DPMS\_OFF if the \textbf{disable} hook isn't used.

This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling and disabling a CRTC to
facilitate transitions to atomic, but it is deprecated. Instead
\textbf{atomic\_enable} and \textbf{atomic\_disable} should be used.

\item[{\code{prepare}}] \leavevmode
This callback should prepare the CRTC for a subsequent modeset, which
in practice means the driver should disable the CRTC if it is
running. Most drivers ended up implementing this by calling their
\textbf{dpms} hook with DRM\_MODE\_DPMS\_OFF.

This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for disabling a CRTC to facilitate
transitions to atomic, but it is deprecated. Instead \textbf{atomic\_disable}
should be used.

\item[{\code{commit}}] \leavevmode
This callback should commit the new mode on the CRTC after a modeset,
which in practice means the driver should enable the CRTC.  Most
drivers ended up implementing this by calling their \textbf{dpms} hook with
DRM\_MODE\_DPMS\_ON.

This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling a CRTC to facilitate
transitions to atomic, but it is deprecated. Instead \textbf{atomic\_enable}
should be used.

\item[{\code{mode\_valid}}] \leavevmode
This callback is used to check if a specific mode is valid in this
crtc. This should be implemented if the crtc has some sort of
restriction in the modes it can display. For example, a given crtc
may be responsible to set a clock value. If the clock can not
produce all the values for the available modes then this callback
can be used to restrict the number of modes to only the ones that
can be displayed.

This hook is used by the probe helpers to filter the mode list in
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_helper_probe_single_connector_modes]{\emph{\code{drm\_helper\_probe\_single\_connector\_modes()}}}}, and it is used by the
atomic helpers to validate modes supplied by userspace in
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check_modeset]{\emph{\code{drm\_atomic\_helper\_check\_modeset()}}}}.

This function is optional.

NOTE:

Since this function is both called from the check phase of an atomic
commit, and the mode validation in the probe paths it is not allowed
to look at anything else but the passed-in mode, and validate it
against configuration-invariant hardward constraints. Any further
limits which depend upon the configuration can only be checked in
\textbf{mode\_fixup} or \textbf{atomic\_check}.

RETURNS:

drm\_mode\_status Enum

\item[{\code{mode\_fixup}}] \leavevmode
This callback is used to validate a mode. The parameter mode is the
display mode that userspace requested, adjusted\_mode is the mode the
encoders need to be fed with. Note that this is the inverse semantics
of the meaning for the {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{\code{drm\_encoder}}}} and {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge_funcs]{\emph{\code{drm\_bridge\_funcs.mode\_fixup}}}}
vfunc. If the CRTC cannot support the requested conversion from mode
to adjusted\_mode it should reject the modeset. See also
{\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.adjusted\_mode}}}} for more details.

This function is used by both legacy CRTC helpers and atomic helpers.
With atomic helpers it is optional.

NOTE:

This function is called in the check phase of atomic modesets, which
can be aborted for any reason (including on userspace's request to
just check whether a configuration would be possible). Atomic drivers
MUST NOT touch any persistent state (hardware or software) or data
structures except the passed in adjusted\_mode parameter.

This is in contrast to the legacy CRTC helpers where this was
allowed.

Atomic drivers which need to inspect and adjust more state should
instead use the \textbf{atomic\_check} callback, but note that they're not
perfectly equivalent: \textbf{mode\_valid} is called from
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check_modeset]{\emph{\code{drm\_atomic\_helper\_check\_modeset()}}}}, but \textbf{atomic\_check} is called from
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check_planes]{\emph{\code{drm\_atomic\_helper\_check\_planes()}}}}, because originally it was meant for
plane update checks only.

Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.modes}}}}. To ensure
that modes are filtered consistently put any CRTC constraints and
limits checks into \textbf{mode\_valid}.

RETURNS:

True if an acceptable configuration is possible, false if the modeset
operation should be rejected.

\item[{\code{mode\_set}}] \leavevmode
This callback is used by the legacy CRTC helpers to set a new mode,
position and framebuffer. Since it ties the primary plane to every
mode change it is incompatible with universal plane support. And
since it can't update other planes it's incompatible with atomic
modeset support.

This callback is only used by CRTC helpers and deprecated.

RETURNS:

0 on success or a negative error code on failure.

\item[{\code{mode\_set\_nofb}}] \leavevmode
This callback is used to update the display mode of a CRTC without
changing anything of the primary plane configuration. This fits the
requirement of atomic and hence is used by the atomic helpers. It is
also used by the transitional plane helpers to implement a
\textbf{mode\_set} hook in {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_helper_crtc_mode_set]{\emph{\code{drm\_helper\_crtc\_mode\_set()}}}}.

Note that the display pipe is completely off when this function is
called. Atomic drivers which need hardware to be running before they
program the new display mode (e.g. because they implement runtime PM)
should not use this hook. This is because the helper library calls
this hook only once per mode change and not every time the display
pipeline is suspended using either DPMS or the new ``ACTIVE'' property.
Which means register values set in this callback might get reset when
the CRTC is suspended, but not restored.  Such drivers should instead
move all their CRTC setup into the \textbf{atomic\_enable} callback.

This callback is optional.

\item[{\code{mode\_set\_base}}] \leavevmode
This callback is used by the legacy CRTC helpers to set a new
framebuffer and scanout position. It is optional and used as an
optimized fast-path instead of a full mode set operation with all the
resulting flickering. If it is not present
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_set_config]{\emph{\code{drm\_crtc\_helper\_set\_config()}}}} will fall back to a full modeset, using
the \textbf{mode\_set} callback. Since it can't update other planes it's
incompatible with atomic modeset support.

This callback is only used by the CRTC helpers and deprecated.

RETURNS:

0 on success or a negative error code on failure.

\item[{\code{mode\_set\_base\_atomic}}] \leavevmode
This callback is used by the fbdev helpers to set a new framebuffer
and scanout without sleeping, i.e. from an atomic calling context. It
is only used to implement kgdb support.

This callback is optional and only needed for kgdb support in the fbdev
helpers.

RETURNS:

0 on success or a negative error code on failure.

\item[{\code{disable}}] \leavevmode
This callback should be used to disable the CRTC. With the atomic
drivers it is called after all encoders connected to this CRTC have
been shut off already using their own
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.disable}}}} hook. If that sequence is too
simple drivers can just add their own hooks and call it from this
CRTC callback here by looping over all encoders connected to it using
\code{for\_each\_encoder\_on\_crtc()}.

This hook is used both by legacy CRTC helpers and atomic helpers.
Atomic drivers don't need to implement it if there's no need to
disable anything at the CRTC level. To ensure that runtime PM
handling (using either DPMS or the new ``ACTIVE'' property) works
\textbf{disable} must be the inverse of \textbf{atomic\_enable} for atomic drivers.
Atomic drivers should consider to use \textbf{atomic\_disable} instead of
this one.

NOTE:

With legacy CRTC helpers there's a big semantic difference between
\textbf{disable} and other hooks (like \textbf{prepare} or \textbf{dpms}) used to shut down a
CRTC: \textbf{disable} is only called when also logically disabling the
display pipeline and needs to release any resources acquired in
\textbf{mode\_set} (like shared PLLs, or again release pinned framebuffers).

Therefore \textbf{disable} must be the inverse of \textbf{mode\_set} plus \textbf{commit} for
drivers still using legacy CRTC helpers, which is different from the
rules under atomic.

\item[{\code{atomic\_check}}] \leavevmode
Drivers should check plane-update related CRTC constraints in this
hook. They can also check mode related limitations but need to be
aware of the calling order, since this hook is used by
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check_planes]{\emph{\code{drm\_atomic\_helper\_check\_planes()}}}} whereas the preparations needed to
check output routing and the display mode is done in
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check_modeset]{\emph{\code{drm\_atomic\_helper\_check\_modeset()}}}}. Therefore drivers that want to
check output routing and display mode constraints in this callback
must ensure that {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check_modeset]{\emph{\code{drm\_atomic\_helper\_check\_modeset()}}}} has been called
beforehand. This is calling order used by the default helper
implementation in {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check]{\emph{\code{drm\_atomic\_helper\_check()}}}}.

When using {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check_planes]{\emph{\code{drm\_atomic\_helper\_check\_planes()}}}} this hook is called
after the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_funcs]{\emph{\code{drm\_plane\_helper\_funcs.atomic\_check}}}} hook for planes, which
allows drivers to assign shared resources requested by planes in this
callback here. For more complicated dependencies the driver can call
the provided check helpers multiple times until the computed state
has a final configuration and everything has been checked.

This function is also allowed to inspect any other object's state and
can add more state objects to the atomic commit if needed. Care must
be taken though to ensure that state check and compute functions for
these added states are all called, and derived state in other objects
all updated. Again the recommendation is to just call check helpers
until a maximal configuration is reached.

This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.

NOTE:

This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}}
update tracking structure.

Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.modes}}}}. To ensure
that modes are filtered consistently put any CRTC constraints and
limits checks into \textbf{mode\_valid}.

RETURNS:

0 on success, -EINVAL if the state or the transition can't be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock}}}}
deadlock.

\item[{\code{atomic\_begin}}] \leavevmode
Drivers should prepare for an atomic update of multiple planes on
a CRTC in this hook. Depending upon hardware this might be vblank
evasion, blocking updates by setting bits or doing preparatory work
for e.g. manual update display.

This hook is called before any plane commit functions are called.

Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit_planes]{\emph{\code{drm\_atomic\_helper\_commit\_planes()}}}} for a discussion of
the tradeoffs and variants of plane commit helpers.

This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.

\item[{\code{atomic\_flush}}] \leavevmode
Drivers should finalize an atomic update of multiple planes on
a CRTC in this hook. Depending upon hardware this might include
checking that vblank evasion was successful, unblocking updates by
setting bits or setting the GO bit to flush out all updates.

Simple hardware or hardware with special requirements can commit and
flush out all updates for all planes from this hook and forgo all the
other commit hooks for plane updates.

This hook is called after any plane commit functions are called.

Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit_planes]{\emph{\code{drm\_atomic\_helper\_commit\_planes()}}}} for a discussion of
the tradeoffs and variants of plane commit helpers.

This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.

\item[{\code{atomic\_enable}}] \leavevmode
This callback should be used to enable the CRTC. With the atomic
drivers it is called before all encoders connected to this CRTC are
enabled through the encoder's own {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.enable}}}}
hook.  If that sequence is too simple drivers can just add their own
hooks and call it from this CRTC callback here by looping over all
encoders connected to it using \code{for\_each\_encoder\_on\_crtc()}.

This hook is used only by atomic helpers, for symmetry with
\textbf{atomic\_disable}. Atomic drivers don't need to implement it if there's
no need to enable anything at the CRTC level. To ensure that runtime
PM handling (using either DPMS or the new ``ACTIVE'' property) works
\textbf{atomic\_enable} must be the inverse of \textbf{atomic\_disable} for atomic
drivers.

Drivers can use the \textbf{old\_crtc\_state} input parameter if the operations
needed to enable the CRTC don't depend solely on the new state but
also on the transition between the old state and the new state.

\item[{\code{atomic\_disable}}] \leavevmode
This callback should be used to disable the CRTC. With the atomic
drivers it is called after all encoders connected to this CRTC have
been shut off already using their own
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.disable}}}} hook. If that sequence is too
simple drivers can just add their own hooks and call it from this
CRTC callback here by looping over all encoders connected to it using
\code{for\_each\_encoder\_on\_crtc()}.

This hook is used only by atomic helpers. Atomic drivers don't
need to implement it if there's no need to disable anything at the
CRTC level.

Comparing to \textbf{disable}, this one provides the additional input
parameter \textbf{old\_crtc\_state} which could be used to access the old
state. Atomic drivers should consider to use this one instead
of \textbf{disable}.

\end{description}

\textbf{Description}

These hooks are used by the legacy CRTC helpers, the transitional plane
helpers and the new atomic modesetting helpers.
\index{drm\_crtc\_helper\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_crtc_helper_add}\pysiglinewithargsret{void \bfcode{drm\_crtc\_helper\_add}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{drm\_crtc\_helper\_funcs}}} *\emph{ funcs}}{}
sets the helper vtable for a crtc

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
DRM CRTC

\item[{\code{const struct drm\_crtc\_helper\_funcs * funcs}}] \leavevmode
helper vtable to set for \textbf{crtc}

\end{description}
\index{drm\_encoder\_helper\_funcs (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_encoder_helper_funcs}\pysigline{struct \bfcode{drm\_encoder\_helper\_funcs}}
helper operations for encoders

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}encoder\PYGZus{}helper\PYGZus{}funcs \PYGZob{}
  void (*dpms)(struct drm\PYGZus{}encoder *encoder, int mode);
  enum drm\PYGZus{}mode\PYGZus{}status (*mode\PYGZus{}valid)(struct drm\PYGZus{}encoder *crtc, const struct drm\PYGZus{}display\PYGZus{}mode *mode);
  bool (*mode\PYGZus{}fixup)(struct drm\PYGZus{}encoder *encoder,const struct drm\PYGZus{}display\PYGZus{}mode *mode, struct drm\PYGZus{}display\PYGZus{}mode *adjusted\PYGZus{}mode);
  void (*prepare)(struct drm\PYGZus{}encoder *encoder);
  void (*commit)(struct drm\PYGZus{}encoder *encoder);
  void (*mode\PYGZus{}set)(struct drm\PYGZus{}encoder *encoder,struct drm\PYGZus{}display\PYGZus{}mode *mode, struct drm\PYGZus{}display\PYGZus{}mode *adjusted\PYGZus{}mode);
  void (*atomic\PYGZus{}mode\PYGZus{}set)(struct drm\PYGZus{}encoder *encoder,struct drm\PYGZus{}crtc\PYGZus{}state *crtc\PYGZus{}state, struct drm\PYGZus{}connector\PYGZus{}state *conn\PYGZus{}state);
  struct drm\PYGZus{}crtc *(*get\PYGZus{}crtc)(struct drm\PYGZus{}encoder *encoder);
  enum drm\PYGZus{}connector\PYGZus{}status (*detect)(struct drm\PYGZus{}encoder *encoder, struct drm\PYGZus{}connector *connector);
  void (*disable)(struct drm\PYGZus{}encoder *encoder);
  void (*enable)(struct drm\PYGZus{}encoder *encoder);
  int (*atomic\PYGZus{}check)(struct drm\PYGZus{}encoder *encoder,struct drm\PYGZus{}crtc\PYGZus{}state *crtc\PYGZus{}state, struct drm\PYGZus{}connector\PYGZus{}state *conn\PYGZus{}state);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dpms}}] \leavevmode
Callback to control power levels on the encoder.  If the mode passed in
is unsupported, the provider must use the next lowest power level.
This is used by the legacy encoder helpers to implement DPMS
functionality in {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_helper_connector_dpms]{\emph{\code{drm\_helper\_connector\_dpms()}}}}.

This callback is also used to disable an encoder by calling it with
DRM\_MODE\_DPMS\_OFF if the \textbf{disable} hook isn't used.

This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling and disabling an encoder to
facilitate transitions to atomic, but it is deprecated. Instead
\textbf{enable} and \textbf{disable} should be used.

\item[{\code{mode\_valid}}] \leavevmode
This callback is used to check if a specific mode is valid in this
encoder. This should be implemented if the encoder has some sort
of restriction in the modes it can display. For example, a given
encoder may be responsible to set a clock value. If the clock can
not produce all the values for the available modes then this callback
can be used to restrict the number of modes to only the ones that
can be displayed.

This hook is used by the probe helpers to filter the mode list in
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_helper_probe_single_connector_modes]{\emph{\code{drm\_helper\_probe\_single\_connector\_modes()}}}}, and it is used by the
atomic helpers to validate modes supplied by userspace in
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check_modeset]{\emph{\code{drm\_atomic\_helper\_check\_modeset()}}}}.

This function is optional.

NOTE:

Since this function is both called from the check phase of an atomic
commit, and the mode validation in the probe paths it is not allowed
to look at anything else but the passed-in mode, and validate it
against configuration-invariant hardward constraints. Any further
limits which depend upon the configuration can only be checked in
\textbf{mode\_fixup} or \textbf{atomic\_check}.

RETURNS:

drm\_mode\_status Enum

\item[{\code{mode\_fixup}}] \leavevmode
This callback is used to validate and adjust a mode. The parameter
mode is the display mode that should be fed to the next element in
the display chain, either the final {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector}}}} or a {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{\code{drm\_bridge}}}}.
The parameter adjusted\_mode is the input mode the encoder requires. It
can be modified by this callback and does not need to match mode. See
also {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.adjusted\_mode}}}} for more details.

This function is used by both legacy CRTC helpers and atomic helpers.
This hook is optional.

NOTE:

This function is called in the check phase of atomic modesets, which
can be aborted for any reason (including on userspace's request to
just check whether a configuration would be possible). Atomic drivers
MUST NOT touch any persistent state (hardware or software) or data
structures except the passed in adjusted\_mode parameter.

This is in contrast to the legacy CRTC helpers where this was
allowed.

Atomic drivers which need to inspect and adjust more state should
instead use the \textbf{atomic\_check} callback. If \textbf{atomic\_check} is used,
this hook isn't called since \textbf{atomic\_check} allows a strict superset
of the functionality of \textbf{mode\_fixup}.

Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.modes}}}}. To ensure
that modes are filtered consistently put any encoder constraints and
limits checks into \textbf{mode\_valid}.

RETURNS:

True if an acceptable configuration is possible, false if the modeset
operation should be rejected.

\item[{\code{prepare}}] \leavevmode
This callback should prepare the encoder for a subsequent modeset,
which in practice means the driver should disable the encoder if it
is running. Most drivers ended up implementing this by calling their
\textbf{dpms} hook with DRM\_MODE\_DPMS\_OFF.

This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for disabling an encoder to facilitate
transitions to atomic, but it is deprecated. Instead \textbf{disable} should
be used.

\item[{\code{commit}}] \leavevmode
This callback should commit the new mode on the encoder after a modeset,
which in practice means the driver should enable the encoder.  Most
drivers ended up implementing this by calling their \textbf{dpms} hook with
DRM\_MODE\_DPMS\_ON.

This callback is used by the legacy CRTC helpers.  Atomic helpers
also support using this hook for enabling an encoder to facilitate
transitions to atomic, but it is deprecated. Instead \textbf{enable} should
be used.

\item[{\code{mode\_set}}] \leavevmode
This callback is used to update the display mode of an encoder.

Note that the display pipe is completely off when this function is
called. Drivers which need hardware to be running before they program
the new display mode (because they implement runtime PM) should not
use this hook, because the helper library calls it only once and not
every time the display pipeline is suspend using either DPMS or the
new ``ACTIVE'' property. Such drivers should instead move all their
encoder setup into the \textbf{enable} callback.

This callback is used both by the legacy CRTC helpers and the atomic
modeset helpers. It is optional in the atomic helpers.

NOTE:

If the driver uses the atomic modeset helpers and needs to inspect
the connector state or connector display info during mode setting,
\textbf{atomic\_mode\_set} can be used instead.

\item[{\code{atomic\_mode\_set}}] \leavevmode
This callback is used to update the display mode of an encoder.

Note that the display pipe is completely off when this function is
called. Drivers which need hardware to be running before they program
the new display mode (because they implement runtime PM) should not
use this hook, because the helper library calls it only once and not
every time the display pipeline is suspended using either DPMS or the
new ``ACTIVE'' property. Such drivers should instead move all their
encoder setup into the \textbf{enable} callback.

This callback is used by the atomic modeset helpers in place of the
\textbf{mode\_set} callback, if set by the driver. It is optional and should
be used instead of \textbf{mode\_set} if the driver needs to inspect the
connector state or display info, since there is no direct way to
go from the encoder to the current connector.

\item[{\code{get\_crtc}}] \leavevmode
This callback is used by the legacy CRTC helpers to work around
deficiencies in its own book-keeping.

Do not use, use atomic helpers instead, which get the book keeping
right.

FIXME:

Currently only nouveau is using this, and as soon as nouveau is
atomic we can ditch this hook.

\item[{\code{detect}}] \leavevmode
This callback can be used by drivers who want to do detection on the
encoder object instead of in connector functions.

It is not used by any helper and therefore has purely driver-specific
semantics. New drivers shouldn't use this and instead just implement
their own private callbacks.

FIXME:

This should just be converted into a pile of driver vfuncs.
Currently radeon, amdgpu and nouveau are using it.

\item[{\code{disable}}] \leavevmode
This callback should be used to disable the encoder. With the atomic
drivers it is called before this encoder's CRTC has been shut off
using their own {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{\code{drm\_crtc\_helper\_funcs.disable}}}} hook.  If that
sequence is too simple drivers can just add their own driver private
encoder hooks and call them from CRTC's callback by looping over all
encoders connected to it using \code{for\_each\_encoder\_on\_crtc()}.

This hook is used both by legacy CRTC helpers and atomic helpers.
Atomic drivers don't need to implement it if there's no need to
disable anything at the encoder level. To ensure that runtime PM
handling (using either DPMS or the new ``ACTIVE'' property) works
\textbf{disable} must be the inverse of \textbf{enable} for atomic drivers.

NOTE:

With legacy CRTC helpers there's a big semantic difference between
\textbf{disable} and other hooks (like \textbf{prepare} or \textbf{dpms}) used to shut down a
encoder: \textbf{disable} is only called when also logically disabling the
display pipeline and needs to release any resources acquired in
\textbf{mode\_set} (like shared PLLs, or again release pinned framebuffers).

Therefore \textbf{disable} must be the inverse of \textbf{mode\_set} plus \textbf{commit} for
drivers still using legacy CRTC helpers, which is different from the
rules under atomic.

\item[{\code{enable}}] \leavevmode
This callback should be used to enable the encoder. With the atomic
drivers it is called after this encoder's CRTC has been enabled using
their own {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{\code{drm\_crtc\_helper\_funcs.enable}}}} hook.  If that sequence is
too simple drivers can just add their own driver private encoder
hooks and call them from CRTC's callback by looping over all encoders
connected to it using \code{for\_each\_encoder\_on\_crtc()}.

This hook is used only by atomic helpers, for symmetry with \textbf{disable}.
Atomic drivers don't need to implement it if there's no need to
enable anything at the encoder level. To ensure that runtime PM handling
(using either DPMS or the new ``ACTIVE'' property) works
\textbf{enable} must be the inverse of \textbf{disable} for atomic drivers.

\item[{\code{atomic\_check}}] \leavevmode
This callback is used to validate encoder state for atomic drivers.
Since the encoder is the object connecting the CRTC and connector it
gets passed both states, to be able to validate interactions and
update the CRTC to match what the encoder needs for the requested
connector.

Since this provides a strict superset of the functionality of
\textbf{mode\_fixup} (the requested and adjusted modes are both available
through the passed in {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{struct drm\_crtc\_state}}}}) \textbf{mode\_fixup} is not
called when \textbf{atomic\_check} is implemented.

This function is used by the atomic helpers, but it is optional.

NOTE:

This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}}
update tracking structure.

Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.modes}}}}. To ensure
that modes are filtered consistently put any encoder constraints and
limits checks into \textbf{mode\_valid}.

RETURNS:

0 on success, -EINVAL if the state or the transition can't be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock}}}}
deadlock.

\end{description}

\textbf{Description}

These hooks are used by the legacy CRTC helpers, the transitional plane
helpers and the new atomic modesetting helpers.
\index{drm\_encoder\_helper\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_encoder_helper_add}\pysiglinewithargsret{void \bfcode{drm\_encoder\_helper\_add}}{struct {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{drm\_encoder}}} *\emph{ encoder}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{drm\_encoder\_helper\_funcs}}} *\emph{ funcs}}{}
sets the helper vtable for an encoder

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_encoder * encoder}}] \leavevmode
DRM encoder

\item[{\code{const struct drm\_encoder\_helper\_funcs * funcs}}] \leavevmode
helper vtable to set for \textbf{encoder}

\end{description}
\index{drm\_connector\_helper\_funcs (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_connector_helper_funcs}\pysigline{struct \bfcode{drm\_connector\_helper\_funcs}}
helper operations for connectors

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}connector\PYGZus{}helper\PYGZus{}funcs \PYGZob{}
  int (*get\PYGZus{}modes)(struct drm\PYGZus{}connector *connector);
  int (*detect\PYGZus{}ctx)(struct drm\PYGZus{}connector *connector,struct drm\PYGZus{}modeset\PYGZus{}acquire\PYGZus{}ctx *ctx, bool force);
  enum drm\PYGZus{}mode\PYGZus{}status (*mode\PYGZus{}valid)(struct drm\PYGZus{}connector *connector, struct drm\PYGZus{}display\PYGZus{}mode *mode);
  struct drm\PYGZus{}encoder *(*best\PYGZus{}encoder)(struct drm\PYGZus{}connector *connector);
  struct drm\PYGZus{}encoder *(*atomic\PYGZus{}best\PYGZus{}encoder)(struct drm\PYGZus{}connector *connector, struct drm\PYGZus{}connector\PYGZus{}state *connector\PYGZus{}state);
  int (*atomic\PYGZus{}check)(struct drm\PYGZus{}connector *connector, struct drm\PYGZus{}connector\PYGZus{}state *state);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{get\_modes}}] \leavevmode
This function should fill in all modes currently valid for the sink
into the {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.probed\_modes}}}} list. It should also update the
EDID property by calling {\hyperref[gpu/drm\string-kms:c.drm_mode_connector_update_edid_property]{\emph{\code{drm\_mode\_connector\_update\_edid\_property()}}}}.

The usual way to implement this is to cache the EDID retrieved in the
probe callback somewhere in the driver-private connector structure.
In this function drivers then parse the modes in the EDID and add
them by calling {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_add_edid_modes]{\emph{\code{drm\_add\_edid\_modes()}}}}. But connectors that driver a
fixed panel can also manually add specific modes using
{\hyperref[gpu/drm\string-kms:c.drm_mode_probed_add]{\emph{\code{drm\_mode\_probed\_add()}}}}. Drivers which manually add modes should also
make sure that the {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.display\_info}}}},
{\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.width\_mm}}}} and {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.height\_mm}}}} fields are
filled in.

Virtual drivers that just want some standard VESA mode with a given
resolution can call {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_add_modes_noedid]{\emph{\code{drm\_add\_modes\_noedid()}}}}, and mark the preferred
one using {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_set_preferred_mode]{\emph{\code{drm\_set\_preferred\_mode()}}}}.

This function is only called after the \textbf{detect} hook has indicated
that a sink is connected and when the EDID isn't overridden through
sysfs or the kernel commandline.

This callback is used by the probe helpers in e.g.
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_helper_probe_single_connector_modes]{\emph{\code{drm\_helper\_probe\_single\_connector\_modes()}}}}.

To avoid races with concurrent connector state updates, the helper
libraries always call this with the {\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.connection\_mutex}}}}
held. Because of this it's safe to inspect {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector-\textgreater{}state}}}}.

RETURNS:

The number of modes added by calling {\hyperref[gpu/drm\string-kms:c.drm_mode_probed_add]{\emph{\code{drm\_mode\_probed\_add()}}}}.

\item[{\code{detect\_ctx}}] \leavevmode
Check to see if anything is attached to the connector. The parameter
force is set to false whilst polling, true when checking the
connector due to a user request. force can be used by the driver to
avoid expensive, destructive operations during automated probing.

This callback is optional, if not implemented the connector will be
considered as always being attached.

This is the atomic version of {\hyperref[gpu/drm\string-kms:c.drm_connector_funcs]{\emph{\code{drm\_connector\_funcs.detect}}}}.

To avoid races against concurrent connector state updates, the
helper libraries always call this with ctx set to a valid context,
and {\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.connection\_mutex}}}} will always be locked with
the ctx parameter set to this ctx. This allows taking additional
locks as required.

RETURNS:

{\hyperref[gpu/drm\string-kms:c.drm_connector_status]{\emph{\code{drm\_connector\_status}}}} indicating the connector's status,
or the error code returned by {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock()}}}}, -EDEADLK.

\item[{\code{mode\_valid}}] \leavevmode
Callback to validate a mode for a connector, irrespective of the
specific display configuration.

This callback is used by the probe helpers to filter the mode list
(which is usually derived from the EDID data block from the sink).
See e.g. {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_helper_probe_single_connector_modes]{\emph{\code{drm\_helper\_probe\_single\_connector\_modes()}}}}.

This function is optional.

NOTE:

This only filters the mode list supplied to userspace in the
GETCONNECTOR IOCTL. Compared to {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.mode\_valid}}}},
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{\code{drm\_crtc\_helper\_funcs.mode\_valid}}}} and {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge_funcs]{\emph{\code{drm\_bridge\_funcs.mode\_valid}}}},
which are also called by the atomic helpers from
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check_modeset]{\emph{\code{drm\_atomic\_helper\_check\_modeset()}}}}. This allows userspace to force and
ignore sink constraint (like the pixel clock limits in the screen's
EDID), which is useful for e.g. testing, or working around a broken
EDID. Any source hardware constraint (which always need to be
enforced) therefore should be checked in one of the above callbacks,
and not this one here.

To avoid races with concurrent connector state updates, the helper
libraries always call this with the {\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.connection\_mutex}}}}
held. Because of this it's safe to inspect {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector-\textgreater{}state}}}}.

RETURNS:

Either {\hyperref[gpu/drm\string-kms:c.drm_mode_status]{\emph{\code{drm\_mode\_status.MODE\_OK}}}} or one of the failure reasons in {\hyperref[gpu/drm\string-kms:c.drm_mode_status]{\emph{\code{enum
drm\_mode\_status}}}}.

\item[{\code{best\_encoder}}] \leavevmode
This function should select the best encoder for the given connector.

This function is used by both the atomic helpers (in the
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check_modeset]{\emph{\code{drm\_atomic\_helper\_check\_modeset()}}}} function) and in the legacy CRTC
helpers.

NOTE:

In atomic drivers this function is called in the check phase of an
atomic update. The driver is not allowed to change or inspect
anything outside of arguments passed-in. Atomic drivers which need to
inspect dynamic configuration state should instead use
\textbf{atomic\_best\_encoder}.

You can leave this function to NULL if the connector is only
attached to a single encoder and you are using the atomic helpers.
In this case, the core will call {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_best_encoder]{\emph{\code{drm\_atomic\_helper\_best\_encoder()}}}}
for you.

RETURNS:

Encoder that should be used for the given connector and connector
state, or NULL if no suitable encoder exists. Note that the helpers
will ensure that encoders aren't used twice, drivers should not check
for this.

\item[{\code{atomic\_best\_encoder}}] \leavevmode
This is the atomic version of \textbf{best\_encoder} for atomic drivers which
need to select the best encoder depending upon the desired
configuration and can't select it statically.

This function is used by {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check_modeset]{\emph{\code{drm\_atomic\_helper\_check\_modeset()}}}}.
If it is not implemented, the core will fallback to \textbf{best\_encoder}
(or {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_best_encoder]{\emph{\code{drm\_atomic\_helper\_best\_encoder()}}}} if \textbf{best\_encoder} is NULL).

NOTE:

This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}}
update tracking structure.

RETURNS:

Encoder that should be used for the given connector and connector
state, or NULL if no suitable encoder exists. Note that the helpers
will ensure that encoders aren't used twice, drivers should not check
for this.

\item[{\code{atomic\_check}}] \leavevmode
This hook is used to validate connector state. This function is
called from {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check_modeset]{\emph{\code{drm\_atomic\_helper\_check\_modeset}}}}, and is called when
a connector property is set, or a modeset on the crtc is forced.

Because {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check_modeset]{\emph{\code{drm\_atomic\_helper\_check\_modeset}}}} may be called multiple times,
this function should handle being called multiple times as well.

This function is also allowed to inspect any other object's state and
can add more state objects to the atomic commit if needed. Care must
be taken though to ensure that state check and compute functions for
these added states are all called, and derived state in other objects
all updated. Again the recommendation is to just call check helpers
until a maximal configuration is reached.

NOTE:

This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}}
update tracking structure.

RETURNS:

0 on success, -EINVAL if the state or the transition can't be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock}}}}
deadlock.

\end{description}

\textbf{Description}

These functions are used by the atomic and legacy modeset helpers and by the
probe helpers.
\index{drm\_connector\_helper\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_connector_helper_add}\pysiglinewithargsret{void \bfcode{drm\_connector\_helper\_add}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_connector_helper_funcs]{\emph{drm\_connector\_helper\_funcs}}} *\emph{ funcs}}{}
sets the helper vtable for a connector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
DRM connector

\item[{\code{const struct drm\_connector\_helper\_funcs * funcs}}] \leavevmode
helper vtable to set for \textbf{connector}

\end{description}
\index{drm\_plane\_helper\_funcs (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_plane_helper_funcs}\pysigline{struct \bfcode{drm\_plane\_helper\_funcs}}
helper operations for planes

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}plane\PYGZus{}helper\PYGZus{}funcs \PYGZob{}
  int (*prepare\PYGZus{}fb)(struct drm\PYGZus{}plane *plane, struct drm\PYGZus{}plane\PYGZus{}state *new\PYGZus{}state);
  void (*cleanup\PYGZus{}fb)(struct drm\PYGZus{}plane *plane, struct drm\PYGZus{}plane\PYGZus{}state *old\PYGZus{}state);
  int (*atomic\PYGZus{}check)(struct drm\PYGZus{}plane *plane, struct drm\PYGZus{}plane\PYGZus{}state *state);
  void (*atomic\PYGZus{}update)(struct drm\PYGZus{}plane *plane, struct drm\PYGZus{}plane\PYGZus{}state *old\PYGZus{}state);
  void (*atomic\PYGZus{}disable)(struct drm\PYGZus{}plane *plane, struct drm\PYGZus{}plane\PYGZus{}state *old\PYGZus{}state);
  int (*atomic\PYGZus{}async\PYGZus{}check)(struct drm\PYGZus{}plane *plane, struct drm\PYGZus{}plane\PYGZus{}state *state);
  void (*atomic\PYGZus{}async\PYGZus{}update)(struct drm\PYGZus{}plane *plane, struct drm\PYGZus{}plane\PYGZus{}state *new\PYGZus{}state);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{prepare\_fb}}] \leavevmode
This hook is to prepare a framebuffer for scanout by e.g. pinning
it's backing storage or relocating it into a contiguous block of
VRAM. Other possible preparatory work includes flushing caches.

This function must not block for outstanding rendering, since it is
called in the context of the atomic IOCTL even for async commits to
be able to return any errors to userspace. Instead the recommended
way is to fill out the fence member of the passed-in
{\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{drm\_plane\_state}}}}. If the driver doesn't support native fences then
equivalent functionality should be implemented through private
members in the plane structure.

The helpers will call \textbf{cleanup\_fb} with matching arguments for every
successful call to this hook.

This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.

RETURNS:

0 on success or one of the following negative error codes allowed by
the {\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.atomic\_commit}}}} vfunc. When using helpers
this callback is the only one which can fail an atomic commit,
everything else must complete successfully.

\item[{\code{cleanup\_fb}}] \leavevmode
This hook is called to clean up any resources allocated for the given
framebuffer and plane configuration in \textbf{prepare\_fb}.

This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.

\item[{\code{atomic\_check}}] \leavevmode
Drivers should check plane specific constraints in this hook.

When using {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check_planes]{\emph{\code{drm\_atomic\_helper\_check\_planes()}}}} plane's \textbf{atomic\_check}
hooks are called before the ones for CRTCs, which allows drivers to
request shared resources that the CRTC controls here. For more
complicated dependencies the driver can call the provided check helpers
multiple times until the computed state has a final configuration and
everything has been checked.

This function is also allowed to inspect any other object's state and
can add more state objects to the atomic commit if needed. Care must
be taken though to ensure that state check and compute functions for
these added states are all called, and derived state in other objects
all updated. Again the recommendation is to just call check helpers
until a maximal configuration is reached.

This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.

NOTE:

This function is called in the check phase of an atomic update. The
driver is not allowed to change anything outside of the free-standing
state objects passed-in or assembled in the overall {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{\code{drm\_atomic\_state}}}}
update tracking structure.

RETURNS:

0 on success, -EINVAL if the state or the transition can't be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock}}}}
deadlock.

\item[{\code{atomic\_update}}] \leavevmode
Drivers should use this function to update the plane state.  This
hook is called in-between the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{\code{drm\_crtc\_helper\_funcs.atomic\_begin}}}} and
drm\_crtc\_helper\_funcs.atomic\_flush callbacks.

Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit_planes]{\emph{\code{drm\_atomic\_helper\_commit\_planes()}}}} for a discussion of
the tradeoffs and variants of plane commit helpers.

This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.

\item[{\code{atomic\_disable}}] \leavevmode
Drivers should use this function to unconditionally disable a plane.
This hook is called in-between the
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{\code{drm\_crtc\_helper\_funcs.atomic\_begin}}}} and
drm\_crtc\_helper\_funcs.atomic\_flush callbacks. It is an alternative to
\textbf{atomic\_update}, which will be called for disabling planes, too, if
the \textbf{atomic\_disable} hook isn't implemented.

This hook is also useful to disable planes in preparation of a modeset,
by calling {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_disable_planes_on_crtc]{\emph{\code{drm\_atomic\_helper\_disable\_planes\_on\_crtc()}}}} from the
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{\code{drm\_crtc\_helper\_funcs.disable}}}} hook.

Note that the power state of the display pipe when this function is
called depends upon the exact helpers and calling sequence the driver
has picked. See {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit_planes]{\emph{\code{drm\_atomic\_helper\_commit\_planes()}}}} for a discussion of
the tradeoffs and variants of plane commit helpers.

This callback is used by the atomic modeset helpers and by the
transitional plane helpers, but it is optional.

\item[{\code{atomic\_async\_check}}] \leavevmode
Drivers should set this function pointer to check if the plane state
can be updated in a async fashion. Here async means ``not vblank
synchronized''.

This hook is called by \code{drm\_atomic\_async\_check()} to establish if a
given update can be committed asynchronously, that is, if it can
jump ahead of the state currently queued for update.

RETURNS:

Return 0 on success and any error returned indicates that the update
can not be applied in asynchronous manner.

\item[{\code{atomic\_async\_update}}] \leavevmode
Drivers should set this function pointer to perform asynchronous
updates of planes, that is, jump ahead of the currently queued
state and update the plane. Here async means ``not vblank
synchronized''.

This hook is called by {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_async_commit]{\emph{\code{drm\_atomic\_helper\_async\_commit()}}}}.

An async update will happen on legacy cursor updates. An async
update won't happen if there is an outstanding commit modifying
the same plane.

Note that unlike {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_funcs]{\emph{\code{drm\_plane\_helper\_funcs.atomic\_update}}}} this hook
takes the new {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{drm\_plane\_state}}}} as parameter. When doing async\_update
drivers shouldn't replace the {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{drm\_plane\_state}}}} but update the
current one with the new plane configurations in the new
plane\_state.
\begin{description}
\item[{FIXME:}] \leavevmode\begin{itemize}
\item {} 
It only works for single plane updates

\item {} 
Async Pageflips are not supported yet

\item {} 
Some hw might still scan out the old buffer until the next
vblank, however we let go of the fb references as soon as
we run this hook. For now drivers must implement their own workers
for deferring if needed, until a common solution is created.

\end{itemize}

\end{description}

\end{description}

\textbf{Description}

These functions are used by the atomic helpers and by the transitional plane
helpers.
\index{drm\_plane\_helper\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_plane_helper_add}\pysiglinewithargsret{void \bfcode{drm\_plane\_helper\_add}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_funcs]{\emph{drm\_plane\_helper\_funcs}}} *\emph{ funcs}}{}
sets the helper vtable for a plane

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
DRM plane

\item[{\code{const struct drm\_plane\_helper\_funcs * funcs}}] \leavevmode
helper vtable to set for \textbf{plane}

\end{description}
\index{drm\_mode\_config\_helper\_funcs (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_mode_config_helper_funcs}\pysigline{struct \bfcode{drm\_mode\_config\_helper\_funcs}}
global modeset helper operations

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}mode\PYGZus{}config\PYGZus{}helper\PYGZus{}funcs \PYGZob{}
  void (*atomic\PYGZus{}commit\PYGZus{}tail)(struct drm\PYGZus{}atomic\PYGZus{}state *state);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{atomic\_commit\_tail}}] \leavevmode
This hook is used by the default \code{atomic\_commit()} hook implemented in
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit]{\emph{\code{drm\_atomic\_helper\_commit()}}}} together with the nonblocking commit
helpers (see {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_setup_commit]{\emph{\code{drm\_atomic\_helper\_setup\_commit()}}}} for a starting point)
to implement blocking and nonblocking commits easily. It is not used
by the atomic helpers

This function is called when the new atomic state has already been
swapped into the various state pointers. The passed in state
therefore contains copies of the old/previous state. This hook should
commit the new state into hardware. Note that the helpers have
already waited for preceeding atomic commits and fences, but drivers
can add more waiting calls at the start of their implementation, e.g.
to wait for driver-internal request for implicit syncing, before
starting to commit the update to the hardware.

After the atomic update is committed to the hardware this hook needs
to call {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit_hw_done]{\emph{\code{drm\_atomic\_helper\_commit\_hw\_done()}}}}. Then wait for the upate
to be executed by the hardware, for example using
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_wait_for_vblanks]{\emph{\code{drm\_atomic\_helper\_wait\_for\_vblanks()}}}} or
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_wait_for_flip_done]{\emph{\code{drm\_atomic\_helper\_wait\_for\_flip\_done()}}}}, and then clean up the old
framebuffers using {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_cleanup_planes]{\emph{\code{drm\_atomic\_helper\_cleanup\_planes()}}}}.

When disabling a CRTC this hook \_must\_ stall for the commit to
complete. Vblank waits don't work on disabled CRTC, hence the core
can't take care of this. And it also can't rely on the vblank event,
since that can be signalled already when the screen shows black,
which can happen much earlier than the last hardware access needed to
shut off the display pipeline completely.

This hook is optional, the default implementation is
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit_tail]{\emph{\code{drm\_atomic\_helper\_commit\_tail()}}}}.

\end{description}

\textbf{Description}

These helper functions are used by the atomic helpers.


\section{Atomic Modeset Helper Functions Reference}
\label{gpu/drm-kms-helpers:atomic-modeset-helper-functions-reference}\label{gpu/drm-kms-helpers:drm-atomic-helper}

\subsection{Overview}
\label{gpu/drm-kms-helpers:overview}
This helper library provides implementations of check and commit functions on
top of the CRTC modeset helper callbacks and the plane helper callbacks. It
also provides convenience implementations for the atomic state handling
callbacks for drivers which don't need to subclass the drm core structures to
add their own additional internal state.

This library also provides default implementations for the check callback in
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check]{\emph{\code{drm\_atomic\_helper\_check()}}}} and for the commit callback with
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit]{\emph{\code{drm\_atomic\_helper\_commit()}}}}. But the individual stages and callbacks are
exposed to allow drivers to mix and match and e.g. use the plane helpers only
together with a driver private modeset implementation.

This library also provides implementations for all the legacy driver
interfaces on top of the atomic interface. See {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_set_config]{\emph{\code{drm\_atomic\_helper\_set\_config()}}}},
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_disable_plane]{\emph{\code{drm\_atomic\_helper\_disable\_plane()}}}}, {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_disable_plane]{\emph{\code{drm\_atomic\_helper\_disable\_plane()}}}} and the
various functions to implement set\_property callbacks. New drivers must not
implement these functions themselves but must use the provided helpers.

The atomic helper uses the same function table structures as all other
modesetting helpers. See the documentation for {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{\code{struct drm\_crtc\_helper\_funcs}}}},
struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs}}}} and {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_connector_helper_funcs]{\emph{\code{struct drm\_connector\_helper\_funcs}}}}. It
also shares the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_funcs]{\emph{\code{struct drm\_plane\_helper\_funcs}}}} function table with the plane
helpers.


\subsection{Implementing Asynchronous Atomic Commit}
\label{gpu/drm-kms-helpers:implementing-asynchronous-atomic-commit}
Nonblocking atomic commits have to be implemented in the following sequence:

1. Run {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_prepare_planes]{\emph{\code{drm\_atomic\_helper\_prepare\_planes()}}}} first. This is the only function
which commit needs to call which can fail, so we want to run it first and
synchronously.

2. Synchronize with any outstanding nonblocking commit worker threads which
might be affected the new state update. This can be done by either cancelling
or flushing the work items, depending upon whether the driver can deal with
cancelled updates. Note that it is important to ensure that the framebuffer
cleanup is still done when cancelling.

Asynchronous workers need to have sufficient parallelism to be able to run
different atomic commits on different CRTCs in parallel. The simplest way to
achive this is by running them on the \code{system\_unbound\_wq} work queue. Note
that drivers are not required to split up atomic commits and run an
individual commit in parallel - userspace is supposed to do that if it cares.
But it might be beneficial to do that for modesets, since those necessarily
must be done as one global operation, and enabling or disabling a CRTC can
take a long time. But even that is not required.

3. The software state is updated synchronously with
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_swap_state]{\emph{\code{drm\_atomic\_helper\_swap\_state()}}}}. Doing this under the protection of all modeset
locks means concurrent callers never see inconsistent state. And doing this
while it's guaranteed that no relevant nonblocking worker runs means that
nonblocking workers do not need grab any locks. Actually they must not grab
locks, for otherwise the work flushing will deadlock.

4. Schedule a work item to do all subsequent steps, using the split-out
commit helpers: a) pre-plane commit b) plane commit c) post-plane commit and
then cleaning up the framebuffers after the old framebuffer is no longer
being displayed.

The above scheme is implemented in the atomic helper libraries in
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit]{\emph{\code{drm\_atomic\_helper\_commit()}}}} using a bunch of helper functions. See
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_setup_commit]{\emph{\code{drm\_atomic\_helper\_setup\_commit()}}}} for a starting point.


\subsection{Atomic State Reset and Initialization}
\label{gpu/drm-kms-helpers:atomic-state-reset-and-initialization}
Both the drm core and the atomic helpers assume that there is always the full
and correct atomic software state for all connectors, CRTCs and planes
available. Which is a bit a problem on driver load and also after system
suspend. One way to solve this is to have a hardware state read-out
infrastructure which reconstructs the full software state (e.g. the i915
driver).

The simpler solution is to just reset the software state to everything off,
which is easiest to do by calling {\hyperref[gpu/drm\string-kms:c.drm_mode_config_reset]{\emph{\code{drm\_mode\_config\_reset()}}}}. To facilitate this
the atomic helpers provide default reset implementations for all hooks.

On the upside the precise state tracking of atomic simplifies system suspend
and resume a lot. For drivers using {\hyperref[gpu/drm\string-kms:c.drm_mode_config_reset]{\emph{\code{drm\_mode\_config\_reset()}}}} a complete recipe
is implemented in {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_suspend]{\emph{\code{drm\_atomic\_helper\_suspend()}}}} and {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_resume]{\emph{\code{drm\_atomic\_helper\_resume()}}}}.
For other drivers the building blocks are split out, see the documentation
for these functions.


\subsection{Helper Functions Reference}
\label{gpu/drm-kms-helpers:helper-functions-reference}\index{drm\_atomic\_crtc\_for\_each\_plane (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_crtc_for_each_plane}\pysiglinewithargsret{\bfcode{drm\_atomic\_crtc\_for\_each\_plane}}{\emph{plane}, \emph{crtc}}{}
iterate over planes currently attached to CRTC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{plane}}] \leavevmode
the loop cursor

\item[{\code{crtc}}] \leavevmode
the crtc whose planes are iterated

\end{description}

\textbf{Description}

This iterates over the current state, useful (for example) when applying
atomic state after it has been checked and swapped.  To iterate over the
planes which \emph{will} be attached (more useful in code called from
{\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.atomic\_check}}}}) see
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_crtc_state_for_each_plane]{\emph{\code{drm\_atomic\_crtc\_state\_for\_each\_plane()}}}}.
\index{drm\_atomic\_crtc\_state\_for\_each\_plane (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_crtc_state_for_each_plane}\pysiglinewithargsret{\bfcode{drm\_atomic\_crtc\_state\_for\_each\_plane}}{\emph{plane}, \emph{crtc\_state}}{}
iterate over attached planes in new state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{plane}}] \leavevmode
the loop cursor

\item[{\code{crtc\_state}}] \leavevmode
the incoming crtc-state

\end{description}

\textbf{Description}

Similar to \code{drm\_crtc\_for\_each\_plane()}, but iterates the planes that will be
attached if the specified state is applied.  Useful during for example
in code called from {\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.atomic\_check}}}} operations, to
validate the incoming state.
\index{drm\_atomic\_crtc\_state\_for\_each\_plane\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_crtc_state_for_each_plane_state}\pysiglinewithargsret{\bfcode{drm\_atomic\_crtc\_state\_for\_each\_plane\_state}}{\emph{plane}, \emph{plane\_state}, \emph{crtc\_state}}{}
iterate over attached planes in new state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{plane}}] \leavevmode
the loop cursor

\item[{\code{plane\_state}}] \leavevmode
loop cursor for the plane's state, must be const

\item[{\code{crtc\_state}}] \leavevmode
the incoming crtc-state

\end{description}

\textbf{Description}

Similar to \code{drm\_crtc\_for\_each\_plane()}, but iterates the planes that will be
attached if the specified state is applied.  Useful during for example
in code called from {\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.atomic\_check}}}} operations, to
validate the incoming state.

Compared to just {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_crtc_state_for_each_plane]{\emph{\code{drm\_atomic\_crtc\_state\_for\_each\_plane()}}}} this also fills in a
const plane\_state. This is useful when a driver just wants to peek at other
active planes on this crtc, but does not need to change it.
\index{drm\_atomic\_plane\_disabling (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_plane_disabling}\pysiglinewithargsret{bool \bfcode{drm\_atomic\_plane\_disabling}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} *\emph{ old\_plane\_state}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} *\emph{ new\_plane\_state}}{}
check whether a plane is being disabled

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane\_state * old\_plane\_state}}] \leavevmode
old atomic plane state

\item[{\code{struct drm\_plane\_state * new\_plane\_state}}] \leavevmode
new atomic plane state

\end{description}

\textbf{Description}

Checks the atomic state of a plane to determine whether it's being disabled
or not. This also WARNs if it detects an invalid state (both CRTC and FB
need to either both be NULL or both be non-NULL).

\textbf{Return}

True if the plane is being disabled, false otherwise.
\index{drm\_atomic\_helper\_check\_modeset (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_check_modeset}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_check\_modeset}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
validate state object for modeset changes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
the driver state object

\end{description}

\textbf{Description}

Check the state object to see if the requested state is physically possible.
This does all the crtc and connector related computations for an atomic
update and adds any additional connectors needed for full modesets. It calls
the various per-object callbacks in the follow order:
\begin{enumerate}
\item {} 
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_connector_helper_funcs]{\emph{\code{drm\_connector\_helper\_funcs.atomic\_best\_encoder}}}} for determining the new encoder.

\item {} 
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_connector_helper_funcs]{\emph{\code{drm\_connector\_helper\_funcs.atomic\_check}}}} to validate the connector state.

\item {} 
If it's determined a modeset is needed then all connectors on the affected crtc
crtc are added and {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_connector_helper_funcs]{\emph{\code{drm\_connector\_helper\_funcs.atomic\_check}}}} is run on them.

\item {} 
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.mode\_valid}}}}, {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge_funcs]{\emph{\code{drm\_bridge\_funcs.mode\_valid}}}} and
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{\code{drm\_crtc\_helper\_funcs.mode\_valid}}}} are called on the affected components.

\item {} 
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge_funcs]{\emph{\code{drm\_bridge\_funcs.mode\_fixup}}}} is called on all encoder bridges.

\item {} 
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.atomic\_check}}}} is called to validate any encoder state.
This function is only called when the encoder will be part of a configured crtc,
it must not be used for implementing connector property validation.
If this function is NULL, \code{drm\_atomic\_encoder\_helper\_funcs.mode\_fixup} is called
instead.

\item {} 
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{\code{drm\_crtc\_helper\_funcs.mode\_fixup}}}} is called last, to fix up the mode with crtc constraints.

\end{enumerate}

{\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.mode\_changed}}}} is set when the input mode is changed.
{\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.connectors\_changed}}}} is set when a connector is added or
removed from the crtc.  {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.active\_changed}}}} is set when
{\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.active}}}} changes, which is used for DPMS.
See also: {\hyperref[gpu/drm\string-kms:c.drm_atomic_crtc_needs_modeset]{\emph{\code{drm\_atomic\_crtc\_needs\_modeset()}}}}

IMPORTANT:

Drivers which set {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.mode\_changed}}}} (e.g. in their
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_funcs]{\emph{\code{drm\_plane\_helper\_funcs.atomic\_check}}}} hooks if a plane update can't be done
without a full modeset) \_must\_ call this function afterwards after that
change. It is permitted to call this function multiple times for the same
update, e.g. when the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{\code{drm\_crtc\_helper\_funcs.atomic\_check}}}} functions depend
upon the adjusted dotclock for fifo space allocation and watermark
computation.

\textbf{Return}

Zero for success or -errno
\index{drm\_atomic\_helper\_check\_plane\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_check_plane_state}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_check\_plane\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} *\emph{ plane\_state}, const struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{drm\_crtc\_state}}} *\emph{ crtc\_state}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ clip}, int\emph{ min\_scale}, int\emph{ max\_scale}, bool\emph{ can\_position}, bool\emph{ can\_update\_disabled}}{}
Check plane state for validity

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane\_state * plane\_state}}] \leavevmode
plane state to check

\item[{\code{const struct drm\_crtc\_state * crtc\_state}}] \leavevmode
crtc state to check

\item[{\code{const struct drm\_rect * clip}}] \leavevmode
integer clipping coordinates

\item[{\code{int min\_scale}}] \leavevmode
minimum \textbf{src}:\textbf{dest} scaling factor in 16.16 fixed point

\item[{\code{int max\_scale}}] \leavevmode
maximum \textbf{src}:\textbf{dest} scaling factor in 16.16 fixed point

\item[{\code{bool can\_position}}] \leavevmode
is it legal to position the plane such that it
doesn't cover the entire crtc?  This will generally
only be false for primary planes.

\item[{\code{bool can\_update\_disabled}}] \leavevmode
can the plane be updated while the crtc
is disabled?

\end{description}

\textbf{Description}

Checks that a desired plane update is valid, and updates various
bits of derived state (clipped coordinates etc.). Drivers that provide
their own plane handling rather than helper-provided implementations may
still wish to call this function to avoid duplication of error checking
code.

\textbf{Return}

Zero if update appears valid, error code on failure
\index{drm\_atomic\_helper\_check\_planes (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_check_planes}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_check\_planes}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
validate state object for planes changes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
the driver state object

\end{description}

\textbf{Description}

Check the state object to see if the requested state is physically possible.
This does all the plane update related checks using by calling into the
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{\code{drm\_crtc\_helper\_funcs.atomic\_check}}}} and {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_funcs]{\emph{\code{drm\_plane\_helper\_funcs.atomic\_check}}}}
hooks provided by the driver.

It also sets {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.planes\_changed}}}} to indicate that a crtc has
updated planes.

\textbf{Return}

Zero for success or -errno
\index{drm\_atomic\_helper\_check (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_check}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_check}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
validate state object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
the driver state object

\end{description}

\textbf{Description}

Check the state object to see if the requested state is physically possible.
Only crtcs and planes have check callbacks, so for any additional (global)
checking that a driver needs it can simply wrap that around this function.
Drivers without such needs can directly use this as their
{\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.atomic\_check}}}} callback.

This just wraps the two parts of the state checking for planes and modeset
state in the default order: First it calls {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check_modeset]{\emph{\code{drm\_atomic\_helper\_check\_modeset()}}}}
and then {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check_planes]{\emph{\code{drm\_atomic\_helper\_check\_planes()}}}}. The assumption is that the
\textbf{drm\_plane\_helper\_funcs.atomic\_check} and \textbf{drm\_crtc\_helper\_funcs.atomic\_check}
functions depend upon an updated adjusted\_mode.clock to e.g. properly compute
watermarks.

\textbf{Return}

Zero for success or -errno
\index{drm\_atomic\_helper\_update\_legacy\_modeset\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_update_legacy_modeset_state}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_update\_legacy\_modeset\_state}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ old\_state}}{}
update legacy modeset state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * old\_state}}] \leavevmode
atomic state object with old state structures

\end{description}

\textbf{Description}

This function updates all the various legacy modeset state pointers in
connectors, encoders and crtcs. It also updates the timestamping constants
used for precise vblank timestamps by calling
{\hyperref[gpu/drm\string-kms:c.drm_calc_timestamping_constants]{\emph{\code{drm\_calc\_timestamping\_constants()}}}}.

Drivers can use this for building their own atomic commit if they don't have
a pure helper-based modeset implementation.

Since these updates are not synchronized with lockings, only code paths
called from {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_mode_config_helper_funcs]{\emph{\code{drm\_mode\_config\_helper\_funcs.atomic\_commit\_tail}}}} can look at the
legacy state filled out by this helper. Defacto this means this helper and
the legacy state pointers are only really useful for transitioning an
existing driver to the atomic world.
\index{drm\_atomic\_helper\_commit\_modeset\_disables (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_commit_modeset_disables}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_commit\_modeset\_disables}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ old\_state}}{}
modeset commit to disable outputs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * old\_state}}] \leavevmode
atomic state object with old state structures

\end{description}

\textbf{Description}

This function shuts down all the outputs that need to be shut down and
prepares them (if required) with the new mode.

For compatibility with legacy crtc helpers this should be called before
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit_planes]{\emph{\code{drm\_atomic\_helper\_commit\_planes()}}}}, which is what the default commit function
does. But drivers with different needs can group the modeset commits together
and do the plane commits at the end. This is useful for drivers doing runtime
PM since planes updates then only happen when the CRTC is actually enabled.
\index{drm\_atomic\_helper\_commit\_modeset\_enables (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_commit_modeset_enables}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_commit\_modeset\_enables}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ old\_state}}{}
modeset commit to enable outputs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * old\_state}}] \leavevmode
atomic state object with old state structures

\end{description}

\textbf{Description}

This function enables all the outputs with the new configuration which had to
be turned off for the update.

For compatibility with legacy crtc helpers this should be called after
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit_planes]{\emph{\code{drm\_atomic\_helper\_commit\_planes()}}}}, which is what the default commit function
does. But drivers with different needs can group the modeset commits together
and do the plane commits at the end. This is useful for drivers doing runtime
PM since planes updates then only happen when the CRTC is actually enabled.
\index{drm\_atomic\_helper\_wait\_for\_fences (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_wait_for_fences}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_wait\_for\_fences}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, bool\emph{ pre\_swap}}{}
wait for fences stashed in plane state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
atomic state object with old state structures

\item[{\code{bool pre\_swap}}] \leavevmode
If true, do an interruptible wait, and \textbf{state} is the new state.
Otherwise \textbf{state} is the old state.

\end{description}

\textbf{Description}

For implicit sync, driver should fish the exclusive fence out from the
incoming fb's and stash it in the drm\_plane\_state.  This is called after
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_swap_state]{\emph{\code{drm\_atomic\_helper\_swap\_state()}}}} so it uses the current plane state (and
just uses the atomic state to find the changed planes)

Note that \textbf{pre\_swap} is needed since the point where we block for fences moves
around depending upon whether an atomic commit is blocking or
non-blocking. For non-blocking commit all waiting needs to happen after
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_swap_state]{\emph{\code{drm\_atomic\_helper\_swap\_state()}}}} is called, but for blocking commits we want
to wait \textbf{before} we do anything that can't be easily rolled back. That is
before we call {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_swap_state]{\emph{\code{drm\_atomic\_helper\_swap\_state()}}}}.

Returns zero if success or \textless{} 0 if \code{dma\_fence\_wait()} fails.
\index{drm\_atomic\_helper\_wait\_for\_vblanks (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_wait_for_vblanks}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_wait\_for\_vblanks}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ old\_state}}{}
wait for vblank on crtcs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * old\_state}}] \leavevmode
atomic state object with old state structures

\end{description}

\textbf{Description}

Helper to, after atomic commit, wait for vblanks on all effected
crtcs (ie. before cleaning up old framebuffers using
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_cleanup_planes]{\emph{\code{drm\_atomic\_helper\_cleanup\_planes()}}}}). It will only wait on CRTCs where the
framebuffers have actually changed to optimize for the legacy cursor and
plane update use-case.

Drivers using the nonblocking commit tracking support initialized by calling
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_setup_commit]{\emph{\code{drm\_atomic\_helper\_setup\_commit()}}}} should look at
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_wait_for_flip_done]{\emph{\code{drm\_atomic\_helper\_wait\_for\_flip\_done()}}}} as an alternative.
\index{drm\_atomic\_helper\_wait\_for\_flip\_done (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_wait_for_flip_done}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_wait\_for\_flip\_done}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ old\_state}}{}
wait for all page flips to be done

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * old\_state}}] \leavevmode
atomic state object with old state structures

\end{description}

\textbf{Description}

Helper to, after atomic commit, wait for page flips on all effected
crtcs (ie. before cleaning up old framebuffers using
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_cleanup_planes]{\emph{\code{drm\_atomic\_helper\_cleanup\_planes()}}}}). Compared to
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_wait_for_vblanks]{\emph{\code{drm\_atomic\_helper\_wait\_for\_vblanks()}}}} this waits for the completion of on all
CRTCs, assuming that cursors-only updates are signalling their completion
immediately (or using a different path).

This requires that drivers use the nonblocking commit tracking support
initialized using {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_setup_commit]{\emph{\code{drm\_atomic\_helper\_setup\_commit()}}}}.
\index{drm\_atomic\_helper\_commit\_tail (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_commit_tail}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_commit\_tail}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ old\_state}}{}
commit atomic update to hardware

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * old\_state}}] \leavevmode
atomic state object with old state structures

\end{description}

\textbf{Description}

This is the default implementation for the
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_mode_config_helper_funcs]{\emph{\code{drm\_mode\_config\_helper\_funcs.atomic\_commit\_tail}}}} hook, for drivers
that do not support runtime\_pm or do not need the CRTC to be
enabled to perform a commit. Otherwise, see
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit_tail_rpm]{\emph{\code{drm\_atomic\_helper\_commit\_tail\_rpm()}}}}.

Note that the default ordering of how the various stages are called is to
match the legacy modeset helper library closest.
\index{drm\_atomic\_helper\_commit\_tail\_rpm (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_commit_tail_rpm}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_commit\_tail\_rpm}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ old\_state}}{}
commit atomic update to hardware

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * old\_state}}] \leavevmode
new modeset state to be committed

\end{description}

\textbf{Description}

This is an alternative implementation for the
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_mode_config_helper_funcs]{\emph{\code{drm\_mode\_config\_helper\_funcs.atomic\_commit\_tail}}}} hook, for drivers
that support runtime\_pm or need the CRTC to be enabled to perform a
commit. Otherwise, one should use the default implementation
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit_tail]{\emph{\code{drm\_atomic\_helper\_commit\_tail()}}}}.
\index{drm\_atomic\_helper\_async\_check (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_async_check}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_async\_check}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
check if state can be commited asynchronously

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
the driver state object

\end{description}

\textbf{Description}

This helper will check if it is possible to commit the state asynchronously.
Async commits are not supposed to swap the states like normal sync commits
but just do in-place changes on the current state.

It will return 0 if the commit can happen in an asynchronous fashion or error
if not. Note that error just mean it can't be commited asynchronously, if it
fails the commit should be treated like a normal synchronous commit.
\index{drm\_atomic\_helper\_async\_commit (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_async_commit}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_async\_commit}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
commit state asynchronously

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
the driver state object

\end{description}

\textbf{Description}

This function commits a state asynchronously, i.e., not vblank
synchronized. It should be used on a state only when
\code{drm\_atomic\_async\_check()} succeeds. Async commits are not supposed to swap
the states like normal sync commits, but just do in-place changes on the
current state.
\index{drm\_atomic\_helper\_commit (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_commit}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_commit}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, bool\emph{ nonblock}}{}
commit validated state object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
the driver state object

\item[{\code{bool nonblock}}] \leavevmode
whether nonblocking behavior is requested.

\end{description}

\textbf{Description}

This function commits a with {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check]{\emph{\code{drm\_atomic\_helper\_check()}}}} pre-validated state
object. This can still fail when e.g. the framebuffer reservation fails. This
function implements nonblocking commits, using
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_setup_commit]{\emph{\code{drm\_atomic\_helper\_setup\_commit()}}}} and related functions.

Committing the actual hardware state is done through the
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_mode_config_helper_funcs]{\emph{\code{drm\_mode\_config\_helper\_funcs.atomic\_commit\_tail}}}} callback, or it's default
implementation {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit_tail]{\emph{\code{drm\_atomic\_helper\_commit\_tail()}}}}.

\textbf{Return}

Zero for success or -errno.
\index{drm\_atomic\_helper\_setup\_commit (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_setup_commit}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_setup\_commit}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, bool\emph{ nonblock}}{}
setup possibly nonblocking commit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
new modeset state to be committed

\item[{\code{bool nonblock}}] \leavevmode
whether nonblocking behavior is requested.

\end{description}

\textbf{Description}

This function prepares \textbf{state} to be used by the atomic helper's support for
nonblocking commits. Drivers using the nonblocking commit infrastructure
should always call this function from their
{\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.atomic\_commit}}}} hook.

To be able to use this support drivers need to use a few more helper
functions. {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_wait_for_dependencies]{\emph{\code{drm\_atomic\_helper\_wait\_for\_dependencies()}}}} must be called before
actually committing the hardware state, and for nonblocking commits this call
must be placed in the async worker. See also {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_swap_state]{\emph{\code{drm\_atomic\_helper\_swap\_state()}}}}
and it's stall parameter, for when a driver's commit hooks look at the
{\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc.state}}}}, {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{drm\_plane.state}}}} or {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.state}}}} pointer directly.

Completion of the hardware commit step must be signalled using
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit_hw_done]{\emph{\code{drm\_atomic\_helper\_commit\_hw\_done()}}}}. After this step the driver is not allowed
to read or change any permanent software or hardware modeset state. The only
exception is state protected by other means than {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock}}}} locks.
Only the free standing \textbf{state} with pointers to the old state structures can
be inspected, e.g. to clean up old buffers using
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_cleanup_planes]{\emph{\code{drm\_atomic\_helper\_cleanup\_planes()}}}}.

At the very end, before cleaning up \textbf{state} drivers must call
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit_cleanup_done]{\emph{\code{drm\_atomic\_helper\_commit\_cleanup\_done()}}}}.

This is all implemented by in {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit]{\emph{\code{drm\_atomic\_helper\_commit()}}}}, giving drivers a
complete and easy-to-use default implementation of the \code{atomic\_commit()} hook.

The tracking of asynchronously executed and still pending commits is done
using the core structure {\hyperref[gpu/drm\string-kms:c.drm_crtc_commit]{\emph{\code{drm\_crtc\_commit}}}}.

By default there's no need to clean up resources allocated by this function
explicitly: {\hyperref[gpu/drm\string-kms:c.drm_atomic_state_default_clear]{\emph{\code{drm\_atomic\_state\_default\_clear()}}}} will take care of that
automatically.

\textbf{Return}

0 on success. -EBUSY when userspace schedules nonblocking commits too fast,
-ENOMEM on allocation failures and -EINTR when a signal is pending.
\index{drm\_atomic\_helper\_wait\_for\_dependencies (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_wait_for_dependencies}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_wait\_for\_dependencies}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ old\_state}}{}
wait for required preceeding commits

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * old\_state}}] \leavevmode
atomic state object with old state structures

\end{description}

\textbf{Description}

This function waits for all preceeding commits that touch the same CRTC as
\textbf{old\_state} to both be committed to the hardware (as signalled by
drm\_atomic\_helper\_commit\_hw\_done) and executed by the hardware (as signalled
by calling {\hyperref[gpu/drm\string-kms:c.drm_crtc_send_vblank_event]{\emph{\code{drm\_crtc\_send\_vblank\_event()}}}} on the {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.event}}}}).

This is part of the atomic helper support for nonblocking commits, see
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_setup_commit]{\emph{\code{drm\_atomic\_helper\_setup\_commit()}}}} for an overview.
\index{drm\_atomic\_helper\_commit\_hw\_done (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_commit_hw_done}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_commit\_hw\_done}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ old\_state}}{}
setup possible nonblocking commit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * old\_state}}] \leavevmode
atomic state object with old state structures

\end{description}

\textbf{Description}

This function is used to signal completion of the hardware commit step. After
this step the driver is not allowed to read or change any permanent software
or hardware modeset state. The only exception is state protected by other
means than {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock}}}} locks.

Drivers should try to postpone any expensive or delayed cleanup work after
this function is called.

This is part of the atomic helper support for nonblocking commits, see
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_setup_commit]{\emph{\code{drm\_atomic\_helper\_setup\_commit()}}}} for an overview.
\index{drm\_atomic\_helper\_commit\_cleanup\_done (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_commit_cleanup_done}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_commit\_cleanup\_done}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ old\_state}}{}
signal completion of commit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * old\_state}}] \leavevmode
atomic state object with old state structures

\end{description}

\textbf{Description}

This signals completion of the atomic update \textbf{old\_state}, including any
cleanup work. If used, it must be called right before calling
{\hyperref[gpu/drm\string-kms:c.drm_atomic_state_put]{\emph{\code{drm\_atomic\_state\_put()}}}}.

This is part of the atomic helper support for nonblocking commits, see
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_setup_commit]{\emph{\code{drm\_atomic\_helper\_setup\_commit()}}}} for an overview.
\index{drm\_atomic\_helper\_prepare\_planes (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_prepare_planes}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_prepare\_planes}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
prepare plane resources before commit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
atomic state object with new state structures

\end{description}

\textbf{Description}

This function prepares plane state, specifically framebuffers, for the new
configuration, by calling {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_funcs]{\emph{\code{drm\_plane\_helper\_funcs.prepare\_fb}}}}. If any failure
is encountered this function will call {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_funcs]{\emph{\code{drm\_plane\_helper\_funcs.cleanup\_fb}}}} on
any already successfully prepared framebuffer.

\textbf{Return}

0 on success, negative error code on failure.
\index{drm\_atomic\_helper\_commit\_planes (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_commit_planes}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_commit\_planes}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ old\_state}, uint32\_t\emph{ flags}}{}
commit plane state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * old\_state}}] \leavevmode
atomic state object with old state structures

\item[{\code{uint32\_t flags}}] \leavevmode
flags for committing plane state

\end{description}

\textbf{Description}

This function commits the new plane state using the plane and atomic helper
functions for planes and crtcs. It assumes that the atomic state has already
been pushed into the relevant object state pointers, since this step can no
longer fail.

It still requires the global state object \textbf{old\_state} to know which planes and
crtcs need to be updated though.

Note that this function does all plane updates across all CRTCs in one step.
If the hardware can't support this approach look at
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit_planes_on_crtc]{\emph{\code{drm\_atomic\_helper\_commit\_planes\_on\_crtc()}}}} instead.

Plane parameters can be updated by applications while the associated CRTC is
disabled. The DRM/KMS core will store the parameters in the plane state,
which will be available to the driver when the CRTC is turned on. As a result
most drivers don't need to be immediately notified of plane updates for a
disabled CRTC.

Unless otherwise needed, drivers are advised to set the ACTIVE\_ONLY flag in
\textbf{flags} in order not to receive plane update notifications related to a
disabled CRTC. This avoids the need to manually ignore plane updates in
driver code when the driver and/or hardware can't or just don't need to deal
with updates on disabled CRTCs, for example when supporting runtime PM.

Drivers may set the NO\_DISABLE\_AFTER\_MODESET flag in \textbf{flags} if the relevant
display controllers require to disable a CRTC's planes when the CRTC is
disabled. This function would skip the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_funcs]{\emph{\code{drm\_plane\_helper\_funcs.atomic\_disable}}}}
call for a plane if the CRTC of the old plane state needs a modesetting
operation. Of course, the drivers need to disable the planes in their CRTC
disable callbacks since no one else would do that.

The {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit]{\emph{\code{drm\_atomic\_helper\_commit()}}}} default implementation doesn't set the
ACTIVE\_ONLY flag to most closely match the behaviour of the legacy helpers.
This should not be copied blindly by drivers.
\index{drm\_atomic\_helper\_commit\_planes\_on\_crtc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_commit_planes_on_crtc}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_commit\_planes\_on\_crtc}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{drm\_crtc\_state}}} *\emph{ old\_crtc\_state}}{}
commit plane state for a crtc

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc\_state * old\_crtc\_state}}] \leavevmode
atomic state object with the old crtc state

\end{description}

\textbf{Description}

This function commits the new plane state using the plane and atomic helper
functions for planes on the specific crtc. It assumes that the atomic state
has already been pushed into the relevant object state pointers, since this
step can no longer fail.

This function is useful when plane updates should be done crtc-by-crtc
instead of one global step like {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit_planes]{\emph{\code{drm\_atomic\_helper\_commit\_planes()}}}} does.

This function can only be savely used when planes are not allowed to move
between different CRTCs because this function doesn't handle inter-CRTC
depencies. Callers need to ensure that either no such depencies exist,
resolve them through ordering of commit calls or through some other means.
\index{drm\_atomic\_helper\_disable\_planes\_on\_crtc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_disable_planes_on_crtc}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_disable\_planes\_on\_crtc}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{drm\_crtc\_state}}} *\emph{ old\_crtc\_state}, bool\emph{ atomic}}{}
helper to disable CRTC's planes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc\_state * old\_crtc\_state}}] \leavevmode
atomic state object with the old CRTC state

\item[{\code{bool atomic}}] \leavevmode
if set, synchronize with CRTC's atomic\_begin/flush hooks

\end{description}

\textbf{Description}

Disables all planes associated with the given CRTC. This can be
used for instance in the CRTC helper atomic\_disable callback to disable
all planes.

If the atomic-parameter is set the function calls the CRTC's
atomic\_begin hook before and atomic\_flush hook after disabling the
planes.

It is a bug to call this function without having implemented the
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_funcs]{\emph{\code{drm\_plane\_helper\_funcs.atomic\_disable}}}} plane hook.
\index{drm\_atomic\_helper\_cleanup\_planes (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_cleanup_planes}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_cleanup\_planes}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ old\_state}}{}
cleanup plane resources after commit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * old\_state}}] \leavevmode
atomic state object with old state structures

\end{description}

\textbf{Description}

This function cleans up plane state, specifically framebuffers, from the old
configuration. Hence the old configuration must be perserved in \textbf{old\_state} to
be able to call this function.

This function must also be called on the new state when the atomic update
fails at any point after calling {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_prepare_planes]{\emph{\code{drm\_atomic\_helper\_prepare\_planes()}}}}.
\index{drm\_atomic\_helper\_swap\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_swap_state}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_swap\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, bool\emph{ stall}}{}
store atomic state into current sw state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
atomic state

\item[{\code{bool stall}}] \leavevmode
stall for preceeding commits

\end{description}

\textbf{Description}

This function stores the atomic state into the current state pointers in all
driver objects. It should be called after all failing steps have been done
and succeeded, but before the actual hardware state is committed.

For cleanup and error recovery the current state for all changed objects will
be swapped into \textbf{state}.

With that sequence it fits perfectly into the plane prepare/cleanup sequence:
\begin{enumerate}
\item {} 
Call {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_prepare_planes]{\emph{\code{drm\_atomic\_helper\_prepare\_planes()}}}} with the staged atomic state.

\item {} 
Do any other steps that might fail.

\item {} 
Put the staged state into the current state pointers with this function.

\item {} 
Actually commit the hardware state.

\end{enumerate}

5. Call {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_cleanup_planes]{\emph{\code{drm\_atomic\_helper\_cleanup\_planes()}}}} with \textbf{state}, which since step 3
contains the old state. Also do any other cleanup required with that state.

\textbf{stall} must be set when nonblocking commits for this driver directly access
the {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{drm\_plane.state}}}}, {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc.state}}}} or {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.state}}}} pointer. With
the current atomic helpers this is almost always the case, since the helpers
don't pass the right state structures to the callbacks.

\textbf{Return}

Returns 0 on success. Can return -ERESTARTSYS when \textbf{stall} is true and the
waiting for the previous commits has been interrupted.
\index{drm\_atomic\_helper\_update\_plane (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_update_plane}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_update\_plane}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, int\emph{ crtc\_x}, int\emph{ crtc\_y}, unsigned int\emph{ crtc\_w}, unsigned int\emph{ crtc\_h}, uint32\_t\emph{ src\_x}, uint32\_t\emph{ src\_y}, uint32\_t\emph{ src\_w}, uint32\_t\emph{ src\_h}, struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}}{}
Helper for primary plane update using atomic

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane object to update

\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
owning CRTC of owning plane

\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
framebuffer to flip onto plane

\item[{\code{int crtc\_x}}] \leavevmode
x offset of primary plane on crtc

\item[{\code{int crtc\_y}}] \leavevmode
y offset of primary plane on crtc

\item[{\code{unsigned int crtc\_w}}] \leavevmode
width of primary plane rectangle on crtc

\item[{\code{unsigned int crtc\_h}}] \leavevmode
height of primary plane rectangle on crtc

\item[{\code{uint32\_t src\_x}}] \leavevmode
x offset of \textbf{fb} for panning

\item[{\code{uint32\_t src\_y}}] \leavevmode
y offset of \textbf{fb} for panning

\item[{\code{uint32\_t src\_w}}] \leavevmode
width of source rectangle in \textbf{fb}

\item[{\code{uint32\_t src\_h}}] \leavevmode
height of source rectangle in \textbf{fb}

\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
lock acquire context

\end{description}

\textbf{Description}

Provides a default plane update handler using the atomic driver interface.

\textbf{Return}

Zero on success, error code on failure
\index{drm\_atomic\_helper\_disable\_plane (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_disable_plane}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_disable\_plane}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}}{}
Helper for primary plane disable using * atomic

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane to disable

\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
lock acquire context

\end{description}

\textbf{Description}

Provides a default plane disable handler using the atomic driver interface.

\textbf{Return}

Zero on success, error code on failure
\index{drm\_atomic\_helper\_set\_config (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_set_config}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_set\_config}}{struct {\hyperref[gpu/drm\string-kms:c.drm_mode_set]{\emph{drm\_mode\_set}}} *\emph{ set}, struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}}{}
set a new config from userspace

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mode\_set * set}}] \leavevmode
mode set configuration

\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
lock acquisition context

\end{description}

\textbf{Description}

Provides a default crtc set\_config handler using the atomic driver interface.

\textbf{NOTE}

For backwards compatibility with old userspace this automatically
resets the ``link-status'' property to GOOD, to force any link
re-training. The SETCRTC ioctl does not define whether an update does
need a full modeset or just a plane update, hence we're allowed to do
that. See also {\hyperref[gpu/drm\string-kms:c.drm_mode_connector_set_link_status_property]{\emph{\code{drm\_mode\_connector\_set\_link\_status\_property()}}}}.

\textbf{Return}

Returns 0 on success, negative errno numbers on failure.
\index{drm\_atomic\_helper\_disable\_all (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_disable_all}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_disable\_all}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}}{}
disable all currently active outputs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
lock acquisition context

\end{description}

\textbf{Description}

Loops through all connectors, finding those that aren't turned off and then
turns them off by setting their DPMS mode to OFF and deactivating the CRTC
that they are connected to.

This is used for example in suspend/resume to disable all currently active
functions when suspending. If you just want to shut down everything at e.g.
driver unload, look at {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_shutdown]{\emph{\code{drm\_atomic\_helper\_shutdown()}}}}.

Note that if callers haven't already acquired all modeset locks this might
return -EDEADLK, which must be handled by calling {\hyperref[gpu/drm\string-kms:c.drm_modeset_backoff]{\emph{\code{drm\_modeset\_backoff()}}}}.

\textbf{Return}

0 on success or a negative error code on failure.

See also:
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_suspend]{\emph{\code{drm\_atomic\_helper\_suspend()}}}}, {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_resume]{\emph{\code{drm\_atomic\_helper\_resume()}}}} and
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_shutdown]{\emph{\code{drm\_atomic\_helper\_shutdown()}}}}.
\index{drm\_atomic\_helper\_shutdown (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_shutdown}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_shutdown}}{struct drm\_device *\emph{ dev}}{}
shutdown all CRTC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

This shuts down all CRTC, which is useful for driver unloading. Shutdown on
suspend should instead be handled with {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_suspend]{\emph{\code{drm\_atomic\_helper\_suspend()}}}}, since
that also takes a snapshot of the modeset state to be restored on resume.

This is just a convenience wrapper around {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_disable_all]{\emph{\code{drm\_atomic\_helper\_disable\_all()}}}},
and it is the atomic version of {\hyperref[gpu/drm\string-kms:c.drm_crtc_force_disable_all]{\emph{\code{drm\_crtc\_force\_disable\_all()}}}}.
\index{drm\_atomic\_helper\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_suspend}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} * \bfcode{drm\_atomic\_helper\_suspend}}{struct drm\_device *\emph{ dev}}{}
subsystem-level suspend helper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

Duplicates the current atomic state, disables all active outputs and then
returns a pointer to the original atomic state to the caller. Drivers can
pass this pointer to the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_resume]{\emph{\code{drm\_atomic\_helper\_resume()}}}} helper upon resume to
restore the output configuration that was active at the time the system
entered suspend.

Note that it is potentially unsafe to use this. The atomic state object
returned by this function is assumed to be persistent. Drivers must ensure
that this holds true. Before calling this function, drivers must make sure
to suspend fbdev emulation so that nothing can be using the device.

\textbf{Return}

A pointer to a copy of the state before suspend on success or an \code{ERR\_PTR()}-
encoded error code on failure. Drivers should store the returned atomic
state object and pass it to the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_resume]{\emph{\code{drm\_atomic\_helper\_resume()}}}} helper upon
resume.

See also:
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_duplicate_state]{\emph{\code{drm\_atomic\_helper\_duplicate\_state()}}}}, {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_disable_all]{\emph{\code{drm\_atomic\_helper\_disable\_all()}}}},
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_resume]{\emph{\code{drm\_atomic\_helper\_resume()}}}}, {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_commit_duplicated_state]{\emph{\code{drm\_atomic\_helper\_commit\_duplicated\_state()}}}}
\index{drm\_atomic\_helper\_commit\_duplicated\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_commit_duplicated_state}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_commit\_duplicated\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}}{}
commit duplicated state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
duplicated atomic state to commit

\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
pointer to acquire\_ctx to use for commit.

\end{description}

\textbf{Description}

The state returned by {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_duplicate_state]{\emph{\code{drm\_atomic\_helper\_duplicate\_state()}}}} and
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_suspend]{\emph{\code{drm\_atomic\_helper\_suspend()}}}} is partially invalid, and needs to
be fixed up before commit.

\textbf{Return}

0 on success or a negative error code on failure.

See also:
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_suspend]{\emph{\code{drm\_atomic\_helper\_suspend()}}}}
\index{drm\_atomic\_helper\_resume (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_resume}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_resume}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
subsystem-level resume helper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
atomic state to resume to

\end{description}

\textbf{Description}

Calls {\hyperref[gpu/drm\string-kms:c.drm_mode_config_reset]{\emph{\code{drm\_mode\_config\_reset()}}}} to synchronize hardware and software states,
grabs all modeset locks and commits the atomic state object. This can be
used in conjunction with the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_suspend]{\emph{\code{drm\_atomic\_helper\_suspend()}}}} helper to
implement suspend/resume for drivers that support atomic mode-setting.

\textbf{Return}

0 on success or a negative error code on failure.

See also:
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_suspend]{\emph{\code{drm\_atomic\_helper\_suspend()}}}}
\index{drm\_atomic\_helper\_page\_flip (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_page_flip}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_page\_flip}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, struct {\hyperref[gpu/drm\string-kms:c.drm_pending_vblank_event]{\emph{drm\_pending\_vblank\_event}}} *\emph{ event}, uint32\_t\emph{ flags}, struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}}{}
execute a legacy page flip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
DRM crtc

\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
DRM framebuffer

\item[{\code{struct drm\_pending\_vblank\_event * event}}] \leavevmode
optional DRM event to signal upon completion

\item[{\code{uint32\_t flags}}] \leavevmode
flip flags for non-vblank sync'ed updates

\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
lock acquisition context

\end{description}

\textbf{Description}

Provides a default {\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.page\_flip}}}} implementation
using the atomic driver interface.

\textbf{Return}

Returns 0 on success, negative errno numbers on failure.

See also:
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_page_flip_target]{\emph{\code{drm\_atomic\_helper\_page\_flip\_target()}}}}
\index{drm\_atomic\_helper\_page\_flip\_target (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_page_flip_target}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_page\_flip\_target}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, struct {\hyperref[gpu/drm\string-kms:c.drm_pending_vblank_event]{\emph{drm\_pending\_vblank\_event}}} *\emph{ event}, uint32\_t\emph{ flags}, uint32\_t\emph{ target}, struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}}{}
do page flip on target vblank period.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
DRM crtc

\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
DRM framebuffer

\item[{\code{struct drm\_pending\_vblank\_event * event}}] \leavevmode
optional DRM event to signal upon completion

\item[{\code{uint32\_t flags}}] \leavevmode
flip flags for non-vblank sync'ed updates

\item[{\code{uint32\_t target}}] \leavevmode
specifying the target vblank period when the flip to take effect

\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
lock acquisition context

\end{description}

\textbf{Description}

Provides a default {\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.page\_flip\_target}}}} implementation.
Similar to {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_page_flip]{\emph{\code{drm\_atomic\_helper\_page\_flip()}}}} with extra parameter to specify
target vblank period to flip.

\textbf{Return}

Returns 0 on success, negative errno numbers on failure.
\index{drm\_atomic\_helper\_best\_encoder (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_best_encoder}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{drm\_encoder}}} * \bfcode{drm\_atomic\_helper\_best\_encoder}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
Helper for {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_connector_helper_funcs]{\emph{\code{drm\_connector\_helper\_funcs.best\_encoder}}}} callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
Connector control structure

\end{description}

\textbf{Description}

This is a {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_connector_helper_funcs]{\emph{\code{drm\_connector\_helper\_funcs.best\_encoder}}}} callback helper for
connectors that support exactly 1 encoder, statically determined at driver
init time.
\index{drm\_atomic\_helper\_crtc\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_crtc_reset}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_crtc\_reset}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
default {\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.reset}}}} hook for CRTCs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
drm CRTC

\end{description}

\textbf{Description}

Resets the atomic state for \textbf{crtc} by freeing the state pointer (which might
be NULL, e.g. at driver load time) and allocating a new empty state object.
\index{\_\_drm\_atomic\_helper\_crtc\_duplicate\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.__drm_atomic_helper_crtc_duplicate_state}\pysiglinewithargsret{void \bfcode{\_\_drm\_atomic\_helper\_crtc\_duplicate\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{drm\_crtc\_state}}} *\emph{ state}}{}
copy atomic CRTC state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
CRTC object

\item[{\code{struct drm\_crtc\_state * state}}] \leavevmode
atomic CRTC state

\end{description}

\textbf{Description}

Copies atomic state from a CRTC's current state and resets inferred values.
This is useful for drivers that subclass the CRTC state.
\index{drm\_atomic\_helper\_crtc\_duplicate\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_crtc_duplicate_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{drm\_crtc\_state}}} * \bfcode{drm\_atomic\_helper\_crtc\_duplicate\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
default state duplicate hook

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
drm CRTC

\end{description}

\textbf{Description}

Default CRTC state duplicate hook for drivers which don't have their own
subclassed CRTC state structure.
\index{\_\_drm\_atomic\_helper\_crtc\_destroy\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.__drm_atomic_helper_crtc_destroy_state}\pysiglinewithargsret{void \bfcode{\_\_drm\_atomic\_helper\_crtc\_destroy\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{drm\_crtc\_state}}} *\emph{ state}}{}
release CRTC state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc\_state * state}}] \leavevmode
CRTC state object to release

\end{description}

\textbf{Description}

Releases all resources stored in the CRTC state without actually freeing
the memory of the CRTC state. This is useful for drivers that subclass the
CRTC state.
\index{drm\_atomic\_helper\_crtc\_destroy\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_crtc_destroy_state}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_crtc\_destroy\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{drm\_crtc\_state}}} *\emph{ state}}{}
default state destroy hook

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
drm CRTC

\item[{\code{struct drm\_crtc\_state * state}}] \leavevmode
CRTC state object to release

\end{description}

\textbf{Description}

Default CRTC state destroy hook for drivers which don't have their own
subclassed CRTC state structure.
\index{drm\_atomic\_helper\_plane\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_plane_reset}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_plane\_reset}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}}{}
default {\hyperref[gpu/drm\string-kms:c.drm_plane_funcs]{\emph{\code{drm\_plane\_funcs.reset}}}} hook for planes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
drm plane

\end{description}

\textbf{Description}

Resets the atomic state for \textbf{plane} by freeing the state pointer (which might
be NULL, e.g. at driver load time) and allocating a new empty state object.
\index{\_\_drm\_atomic\_helper\_plane\_duplicate\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.__drm_atomic_helper_plane_duplicate_state}\pysiglinewithargsret{void \bfcode{\_\_drm\_atomic\_helper\_plane\_duplicate\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} *\emph{ state}}{}
copy atomic plane state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane object

\item[{\code{struct drm\_plane\_state * state}}] \leavevmode
atomic plane state

\end{description}

\textbf{Description}

Copies atomic state from a plane's current state. This is useful for
drivers that subclass the plane state.
\index{drm\_atomic\_helper\_plane\_duplicate\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_plane_duplicate_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} * \bfcode{drm\_atomic\_helper\_plane\_duplicate\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}}{}
default state duplicate hook

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
drm plane

\end{description}

\textbf{Description}

Default plane state duplicate hook for drivers which don't have their own
subclassed plane state structure.
\index{\_\_drm\_atomic\_helper\_plane\_destroy\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.__drm_atomic_helper_plane_destroy_state}\pysiglinewithargsret{void \bfcode{\_\_drm\_atomic\_helper\_plane\_destroy\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} *\emph{ state}}{}
release plane state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane\_state * state}}] \leavevmode
plane state object to release

\end{description}

\textbf{Description}

Releases all resources stored in the plane state without actually freeing
the memory of the plane state. This is useful for drivers that subclass the
plane state.
\index{drm\_atomic\_helper\_plane\_destroy\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_plane_destroy_state}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_plane\_destroy\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} *\emph{ state}}{}
default state destroy hook

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
drm plane

\item[{\code{struct drm\_plane\_state * state}}] \leavevmode
plane state object to release

\end{description}

\textbf{Description}

Default plane state destroy hook for drivers which don't have their own
subclassed plane state structure.
\index{\_\_drm\_atomic\_helper\_connector\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.__drm_atomic_helper_connector_reset}\pysiglinewithargsret{void \bfcode{\_\_drm\_atomic\_helper\_connector\_reset}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, struct {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{drm\_connector\_state}}} *\emph{ conn\_state}}{}
reset state on connector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
drm connector

\item[{\code{struct drm\_connector\_state * conn\_state}}] \leavevmode
connector state to assign

\end{description}

\textbf{Description}

Initializes the newly allocated \textbf{conn\_state} and assigns it to
the \code{drm\_conector-\textgreater{}state} pointer of \textbf{connector}, usually required when
initializing the drivers or when called from the {\hyperref[gpu/drm\string-kms:c.drm_connector_funcs]{\emph{\code{drm\_connector\_funcs.reset}}}}
hook.

This is useful for drivers that subclass the connector state.
\index{drm\_atomic\_helper\_connector\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_connector_reset}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_connector\_reset}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
default {\hyperref[gpu/drm\string-kms:c.drm_connector_funcs]{\emph{\code{drm\_connector\_funcs.reset}}}} hook for connectors

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
drm connector

\end{description}

\textbf{Description}

Resets the atomic state for \textbf{connector} by freeing the state pointer (which
might be NULL, e.g. at driver load time) and allocating a new empty state
object.
\index{\_\_drm\_atomic\_helper\_connector\_duplicate\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.__drm_atomic_helper_connector_duplicate_state}\pysiglinewithargsret{void \bfcode{\_\_drm\_atomic\_helper\_connector\_duplicate\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, struct {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{drm\_connector\_state}}} *\emph{ state}}{}
copy atomic connector state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector object

\item[{\code{struct drm\_connector\_state * state}}] \leavevmode
atomic connector state

\end{description}

\textbf{Description}

Copies atomic state from a connector's current state. This is useful for
drivers that subclass the connector state.
\index{drm\_atomic\_helper\_connector\_duplicate\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_connector_duplicate_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{drm\_connector\_state}}} * \bfcode{drm\_atomic\_helper\_connector\_duplicate\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
default state duplicate hook

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
drm connector

\end{description}

\textbf{Description}

Default connector state duplicate hook for drivers which don't have their own
subclassed connector state structure.
\index{drm\_atomic\_helper\_duplicate\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_duplicate_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} * \bfcode{drm\_atomic\_helper\_duplicate\_state}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}}{}
duplicate an atomic state object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
lock acquisition context

\end{description}

\textbf{Description}

Makes a copy of the current atomic state by looping over all objects and
duplicating their respective states. This is used for example by suspend/
resume support code to save the state prior to suspend such that it can
be restored upon resume.

Note that this treats atomic state as persistent between save and restore.
Drivers must make sure that this is possible and won't result in confusion
or erroneous behaviour.

Note that if callers haven't already acquired all modeset locks this might
return -EDEADLK, which must be handled by calling {\hyperref[gpu/drm\string-kms:c.drm_modeset_backoff]{\emph{\code{drm\_modeset\_backoff()}}}}.

\textbf{Return}

A pointer to the copy of the atomic state object on success or an
\code{ERR\_PTR()}-encoded error code on failure.

See also:
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_suspend]{\emph{\code{drm\_atomic\_helper\_suspend()}}}}, {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_resume]{\emph{\code{drm\_atomic\_helper\_resume()}}}}
\index{\_\_drm\_atomic\_helper\_connector\_destroy\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.__drm_atomic_helper_connector_destroy_state}\pysiglinewithargsret{void \bfcode{\_\_drm\_atomic\_helper\_connector\_destroy\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{drm\_connector\_state}}} *\emph{ state}}{}
release connector state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector\_state * state}}] \leavevmode
connector state object to release

\end{description}

\textbf{Description}

Releases all resources stored in the connector state without actually
freeing the memory of the connector state. This is useful for drivers that
subclass the connector state.
\index{drm\_atomic\_helper\_connector\_destroy\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_connector_destroy_state}\pysiglinewithargsret{void \bfcode{drm\_atomic\_helper\_connector\_destroy\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, struct {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{drm\_connector\_state}}} *\emph{ state}}{}
default state destroy hook

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
drm connector

\item[{\code{struct drm\_connector\_state * state}}] \leavevmode
connector state object to release

\end{description}

\textbf{Description}

Default connector state destroy hook for drivers which don't have their own
subclassed connector state structure.
\index{drm\_atomic\_helper\_legacy\_gamma\_set (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_helper_legacy_gamma_set}\pysiglinewithargsret{int \bfcode{drm\_atomic\_helper\_legacy\_gamma\_set}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, u16 *\emph{ red}, u16 *\emph{ green}, u16 *\emph{ blue}, uint32\_t\emph{ size}, struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}}{}
set the legacy gamma correction table

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
CRTC object

\item[{\code{u16 * red}}] \leavevmode
red correction table

\item[{\code{u16 * green}}] \leavevmode
green correction table

\item[{\code{u16 * blue}}] \leavevmode
green correction table

\item[{\code{uint32\_t size}}] \leavevmode
size of the tables

\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
lock acquire context

\end{description}

\textbf{Description}

Implements support for legacy gamma correction table for drivers
that support color management through the DEGAMMA\_LUT/GAMMA\_LUT
properties. See {\hyperref[gpu/drm\string-kms:c.drm_crtc_enable_color_mgmt]{\emph{\code{drm\_crtc\_enable\_color\_mgmt()}}}} and the containing chapter for
how the atomic color management and gamma tables work.
\index{\_\_drm\_atomic\_helper\_private\_obj\_duplicate\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.__drm_atomic_helper_private_obj_duplicate_state}\pysiglinewithargsret{void \bfcode{\_\_drm\_atomic\_helper\_private\_obj\_duplicate\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_private_obj]{\emph{drm\_private\_obj}}} *\emph{ obj}, struct {\hyperref[gpu/drm\string-kms:c.drm_private_state]{\emph{drm\_private\_state}}} *\emph{ state}}{}
copy atomic private state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_private\_obj * obj}}] \leavevmode
CRTC object

\item[{\code{struct drm\_private\_state * state}}] \leavevmode
new private object state

\end{description}

\textbf{Description}

Copies atomic state from a private objects's current state and resets inferred values.
This is useful for drivers that subclass the private state.


\section{Simple KMS Helper Reference}
\label{gpu/drm-kms-helpers:simple-kms-helper-reference}
This helper library provides helpers for drivers for simple display
hardware.

{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe_init]{\emph{\code{drm\_simple\_display\_pipe\_init()}}}} initializes a simple display pipeline
which has only one full-screen scanout buffer feeding one output. The
pipeline is represented by {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe]{\emph{\code{struct drm\_simple\_display\_pipe}}}} and binds
together {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{\code{drm\_plane}}}}, {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{\code{drm\_crtc}}}} and {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{\code{drm\_encoder}}}} structures into one fixed
entity. Some flexibility for code reuse is provided through a separately
allocated {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector}}}} object and supporting optional {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{\code{drm\_bridge}}}}
encoder drivers.
\index{drm\_simple\_display\_pipe\_funcs (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_simple_display_pipe_funcs}\pysigline{struct \bfcode{drm\_simple\_display\_pipe\_funcs}}
helper operations for a simple display pipeline

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}simple\PYGZus{}display\PYGZus{}pipe\PYGZus{}funcs \PYGZob{}
  void (*enable)(struct drm\PYGZus{}simple\PYGZus{}display\PYGZus{}pipe *pipe, struct drm\PYGZus{}crtc\PYGZus{}state *crtc\PYGZus{}state);
  void (*disable)(struct drm\PYGZus{}simple\PYGZus{}display\PYGZus{}pipe *pipe);
  int (*check)(struct drm\PYGZus{}simple\PYGZus{}display\PYGZus{}pipe *pipe,struct drm\PYGZus{}plane\PYGZus{}state *plane\PYGZus{}state, struct drm\PYGZus{}crtc\PYGZus{}state *crtc\PYGZus{}state);
  void (*update)(struct drm\PYGZus{}simple\PYGZus{}display\PYGZus{}pipe *pipe, struct drm\PYGZus{}plane\PYGZus{}state *old\PYGZus{}plane\PYGZus{}state);
  int (*prepare\PYGZus{}fb)(struct drm\PYGZus{}simple\PYGZus{}display\PYGZus{}pipe *pipe, struct drm\PYGZus{}plane\PYGZus{}state *plane\PYGZus{}state);
  void (*cleanup\PYGZus{}fb)(struct drm\PYGZus{}simple\PYGZus{}display\PYGZus{}pipe *pipe, struct drm\PYGZus{}plane\PYGZus{}state *plane\PYGZus{}state);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{enable}}] \leavevmode
This function should be used to enable the pipeline.
It is called when the underlying crtc is enabled.
This hook is optional.

\item[{\code{disable}}] \leavevmode
This function should be used to disable the pipeline.
It is called when the underlying crtc is disabled.
This hook is optional.

\item[{\code{check}}] \leavevmode
This function is called in the check phase of an atomic update,
specifically when the underlying plane is checked.
The simple display pipeline helpers already check that the plane is
not scaled, fills the entire visible area and is always enabled
when the crtc is also enabled.
This hook is optional.

RETURNS:

0 on success, -EINVAL if the state or the transition can't be
supported, -ENOMEM on memory allocation failure and -EDEADLK if an
attempt to obtain another state object ran into a {\hyperref[gpu/drm\string-kms:c.drm_modeset_lock]{\emph{\code{drm\_modeset\_lock}}}}
deadlock.

\item[{\code{update}}] \leavevmode
This function is called when the underlying plane state is updated.
This hook is optional.

This is the function drivers should submit the
{\hyperref[gpu/drm\string-kms:c.drm_pending_vblank_event]{\emph{\code{drm\_pending\_vblank\_event}}}} from. Using either
{\hyperref[gpu/drm\string-kms:c.drm_crtc_arm_vblank_event]{\emph{\code{drm\_crtc\_arm\_vblank\_event()}}}}, when the driver supports vblank
interrupt handling, or {\hyperref[gpu/drm\string-kms:c.drm_crtc_send_vblank_event]{\emph{\code{drm\_crtc\_send\_vblank\_event()}}}} directly in case
the hardware lacks vblank support entirely.

\item[{\code{prepare\_fb}}] \leavevmode
Optional, called by {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_funcs]{\emph{\code{drm\_plane\_helper\_funcs.prepare\_fb}}}}.  Please read
the documentation for the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_funcs]{\emph{\code{drm\_plane\_helper\_funcs.prepare\_fb}}}} hook for
more details.

\item[{\code{cleanup\_fb}}] \leavevmode
Optional, called by {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_funcs]{\emph{\code{drm\_plane\_helper\_funcs.cleanup\_fb}}}}.  Please read
the documentation for the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_funcs]{\emph{\code{drm\_plane\_helper\_funcs.cleanup\_fb}}}} hook for
more details.

\end{description}
\index{drm\_simple\_display\_pipe (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_simple_display_pipe}\pysigline{struct \bfcode{drm\_simple\_display\_pipe}}
simple display pipeline

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}simple\PYGZus{}display\PYGZus{}pipe \PYGZob{}
  struct drm\PYGZus{}crtc crtc;
  struct drm\PYGZus{}plane plane;
  struct drm\PYGZus{}encoder encoder;
  struct drm\PYGZus{}connector *connector;
  const struct drm\PYGZus{}simple\PYGZus{}display\PYGZus{}pipe\PYGZus{}funcs *funcs;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{crtc}}] \leavevmode
CRTC control structure

\item[{\code{plane}}] \leavevmode
Plane control structure

\item[{\code{encoder}}] \leavevmode
Encoder control structure

\item[{\code{connector}}] \leavevmode
Connector control structure

\item[{\code{funcs}}] \leavevmode
Pipeline control functions (optional)

\end{description}

\textbf{Description}

Simple display pipeline with plane, crtc and encoder collapsed into one
entity. It should be initialized by calling {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe_init]{\emph{\code{drm\_simple\_display\_pipe\_init()}}}}.
\index{drm\_simple\_display\_pipe\_attach\_bridge (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_simple_display_pipe_attach_bridge}\pysiglinewithargsret{int \bfcode{drm\_simple\_display\_pipe\_attach\_bridge}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe]{\emph{drm\_simple\_display\_pipe}}} *\emph{ pipe}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{drm\_bridge}}} *\emph{ bridge}}{}
Attach a bridge to the display pipe

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_simple\_display\_pipe * pipe}}] \leavevmode
simple display pipe object

\item[{\code{struct drm\_bridge * bridge}}] \leavevmode
bridge to attach

\end{description}

\textbf{Description}

Makes it possible to still use the drm\_simple\_display\_pipe helpers when
a DRM bridge has to be used.

Note that you probably want to initialize the pipe by passing a NULL
connector to {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe_init]{\emph{\code{drm\_simple\_display\_pipe\_init()}}}}.

\textbf{Return}

Zero on success, negative error code on failure.
\index{drm\_simple\_display\_pipe\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_simple_display_pipe_init}\pysiglinewithargsret{int \bfcode{drm\_simple\_display\_pipe\_init}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe]{\emph{drm\_simple\_display\_pipe}}} *\emph{ pipe}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe_funcs]{\emph{drm\_simple\_display\_pipe\_funcs}}} *\emph{ funcs}, const uint32\_t *\emph{ formats}, unsigned int\emph{ format\_count}, const uint64\_t *\emph{ format\_modifiers}, struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
Initialize a simple display pipeline

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_simple\_display\_pipe * pipe}}] \leavevmode
simple display pipe object to initialize

\item[{\code{const struct drm\_simple\_display\_pipe\_funcs * funcs}}] \leavevmode
callbacks for the display pipe (optional)

\item[{\code{const uint32\_t * formats}}] \leavevmode
array of supported formats (DRM\_FORMAT\_*)

\item[{\code{unsigned int format\_count}}] \leavevmode
number of elements in \textbf{formats}

\item[{\code{const uint64\_t * format\_modifiers}}] \leavevmode
array of formats modifiers

\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector to attach and register (optional)

\end{description}

\textbf{Description}

Sets up a display pipeline which consist of a really simple
plane-crtc-encoder pipe.

If a connector is supplied, the pipe will be coupled with the provided
connector. You may supply a NULL connector when using drm bridges, that
handle connectors themselves (see {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe_attach_bridge]{\emph{\code{drm\_simple\_display\_pipe\_attach\_bridge()}}}}).

Teardown of a simple display pipe is all handled automatically by the drm
core through calling {\hyperref[gpu/drm\string-kms:c.drm_mode_config_cleanup]{\emph{\code{drm\_mode\_config\_cleanup()}}}}. Drivers afterwards need to
release the memory for the structure themselves.

\textbf{Return}

Zero on success, negative error code on failure.


\section{fbdev Helper Functions Reference}
\label{gpu/drm-kms-helpers:fbdev-helper-functions-reference}
The fb helper functions are useful to provide an fbdev on top of a drm kernel
mode setting driver. They can be used mostly independently from the crtc
helper functions used by many drivers to implement the kernel mode setting
interfaces.

Setup fbdev emulation by calling {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_fbdev_setup]{\emph{\code{drm\_fb\_helper\_fbdev\_setup()}}}} and tear it
down by calling {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_fbdev_teardown]{\emph{\code{drm\_fb\_helper\_fbdev\_teardown()}}}}.

Drivers that need to handle connector hotplugging (e.g. dp mst) can't use
the setup helper and will need to do the whole four-step setup process with
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_prepare]{\emph{\code{drm\_fb\_helper\_prepare()}}}}, {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_init]{\emph{\code{drm\_fb\_helper\_init()}}}},
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_single_add_all_connectors]{\emph{\code{drm\_fb\_helper\_single\_add\_all\_connectors()}}}}, enable hotplugging and
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_initial_config]{\emph{\code{drm\_fb\_helper\_initial\_config()}}}} to avoid a possible race window.

At runtime drivers should restore the fbdev console by using
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_lastclose]{\emph{\code{drm\_fb\_helper\_lastclose()}}}} as their {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.lastclose}}}} callback.
They should also notify the fb helper code from updates to the output
configuration by using {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_output_poll_changed]{\emph{\code{drm\_fb\_helper\_output\_poll\_changed()}}}} as their
{\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.output\_poll\_changed}}}} callback.

For suspend/resume consider using {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_mode_config_helper_suspend]{\emph{\code{drm\_mode\_config\_helper\_suspend()}}}} and
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_mode_config_helper_resume]{\emph{\code{drm\_mode\_config\_helper\_resume()}}}} which takes care of fbdev as well.

All other functions exported by the fb helper library can be used to
implement the fbdev driver interface by the driver.

It is possible, though perhaps somewhat tricky, to implement race-free
hotplug detection using the fbdev helpers. The {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_prepare]{\emph{\code{drm\_fb\_helper\_prepare()}}}}
helper must be called first to initialize the minimum required to make
hotplug detection work. Drivers also need to make sure to properly set up
the {\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.funcs}}}} member. After calling {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_kms_helper_poll_init]{\emph{\code{drm\_kms\_helper\_poll\_init()}}}}
it is safe to enable interrupts and start processing hotplug events. At the
same time, drivers should initialize all modeset objects such as CRTCs,
encoders and connectors. To finish up the fbdev helper initialization, the
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_init]{\emph{\code{drm\_fb\_helper\_init()}}}} function is called. To probe for all attached displays
and set up an initial configuration using the detected hardware, drivers
should call {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_single_add_all_connectors]{\emph{\code{drm\_fb\_helper\_single\_add\_all\_connectors()}}}} followed by
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_initial_config]{\emph{\code{drm\_fb\_helper\_initial\_config()}}}}.

If {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_funcs]{\emph{\code{drm\_framebuffer\_funcs.dirty}}}} is set, the
drm\_fb\_helper\_\{cfb,sys\}\_\{write,fillrect,copyarea,imageblit\} functions will
accumulate changes and schedule {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{\code{drm\_fb\_helper.dirty\_work}}}} to run right
away. This worker then calls the \code{dirty()} function ensuring that it will
always run in process context since the fb\_*() function could be running in
atomic context. If {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_deferred_io]{\emph{\code{drm\_fb\_helper\_deferred\_io()}}}} is used as the deferred\_io
callback it will also schedule dirty\_work with the damage collected from the
mmap page writes. Drivers can use {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_defio_init]{\emph{\code{drm\_fb\_helper\_defio\_init()}}}} to setup
deferred I/O (coupled with {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_fbdev_teardown]{\emph{\code{drm\_fb\_helper\_fbdev\_teardown()}}}}).
\index{drm\_fb\_helper\_surface\_size (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_surface_size}\pysigline{struct \bfcode{drm\_fb\_helper\_surface\_size}}
describes fbdev size and scanout surface size

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}fb\PYGZus{}helper\PYGZus{}surface\PYGZus{}size \PYGZob{}
  u32 fb\PYGZus{}width;
  u32 fb\PYGZus{}height;
  u32 surface\PYGZus{}width;
  u32 surface\PYGZus{}height;
  u32 surface\PYGZus{}bpp;
  u32 surface\PYGZus{}depth;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{fb\_width}}] \leavevmode
fbdev width

\item[{\code{fb\_height}}] \leavevmode
fbdev height

\item[{\code{surface\_width}}] \leavevmode
scanout buffer width

\item[{\code{surface\_height}}] \leavevmode
scanout buffer height

\item[{\code{surface\_bpp}}] \leavevmode
scanout buffer bpp

\item[{\code{surface\_depth}}] \leavevmode
scanout buffer depth

\end{description}

\textbf{Description}

Note that the scanout surface width/height may be larger than the fbdev
width/height.  In case of multiple displays, the scanout surface is sized
according to the largest width/height (so it is large enough for all CRTCs
to scanout).  But the fbdev width/height is sized to the minimum width/
height of all the displays.  This ensures that fbcon fits on the smallest
of the attached displays.

So what is passed to {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_fill_var]{\emph{\code{drm\_fb\_helper\_fill\_var()}}}} should be fb\_width/fb\_height,
rather than the surface size.
\index{drm\_fb\_helper\_funcs (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_funcs}\pysigline{struct \bfcode{drm\_fb\_helper\_funcs}}
driver callbacks for the fbdev emulation library

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}fb\PYGZus{}helper\PYGZus{}funcs \PYGZob{}
  int (*fb\PYGZus{}probe)(struct drm\PYGZus{}fb\PYGZus{}helper *helper, struct drm\PYGZus{}fb\PYGZus{}helper\PYGZus{}surface\PYGZus{}size *sizes);
  bool (*initial\PYGZus{}config)(struct drm\PYGZus{}fb\PYGZus{}helper *fb\PYGZus{}helper,struct drm\PYGZus{}fb\PYGZus{}helper\PYGZus{}crtc **crtcs,struct drm\PYGZus{}display\PYGZus{}mode **modes,struct drm\PYGZus{}fb\PYGZus{}offset *offsets, bool *enabled, int width, int height);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{fb\_probe}}] \leavevmode
Driver callback to allocate and initialize the fbdev info structure.
Furthermore it also needs to allocate the DRM framebuffer used to
back the fbdev.

This callback is mandatory.

RETURNS:

The driver should return 0 on success and a negative error code on
failure.

\item[{\code{initial\_config}}] \leavevmode
Driver callback to setup an initial fbdev display configuration.
Drivers can use this callback to tell the fbdev emulation what the
preferred initial configuration is. This is useful to implement
smooth booting where the fbdev (and subsequently all userspace) never
changes the mode, but always inherits the existing configuration.

This callback is optional.

RETURNS:

The driver should return true if a suitable initial configuration has
been filled out and false when the fbdev helper should fall back to
the default probing logic.

\end{description}

\textbf{Description}

Driver callbacks used by the fbdev emulation helper library.
\index{drm\_fb\_helper (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper}\pysigline{struct \bfcode{drm\_fb\_helper}}
main structure to emulate fbdev on top of KMS

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}fb\PYGZus{}helper \PYGZob{}
  struct drm\PYGZus{}framebuffer *fb;
  struct drm\PYGZus{}device *dev;
  int crtc\PYGZus{}count;
  struct drm\PYGZus{}fb\PYGZus{}helper\PYGZus{}crtc *crtc\PYGZus{}info;
  int connector\PYGZus{}count;
  int connector\PYGZus{}info\PYGZus{}alloc\PYGZus{}count;
  int sw\PYGZus{}rotations;
  struct drm\PYGZus{}fb\PYGZus{}helper\PYGZus{}connector **connector\PYGZus{}info;
  const struct drm\PYGZus{}fb\PYGZus{}helper\PYGZus{}funcs *funcs;
  struct fb\PYGZus{}info *fbdev;
  u32 pseudo\PYGZus{}palette[17];
  struct drm\PYGZus{}clip\PYGZus{}rect dirty\PYGZus{}clip;
  spinlock\PYGZus{}t dirty\PYGZus{}lock;
  struct work\PYGZus{}struct dirty\PYGZus{}work;
  struct work\PYGZus{}struct resume\PYGZus{}work;
  struct mutex lock;
  struct list\PYGZus{}head kernel\PYGZus{}fb\PYGZus{}list;
  bool delayed\PYGZus{}hotplug;
  bool deferred\PYGZus{}setup;
  int preferred\PYGZus{}bpp;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{fb}}] \leavevmode
Scanout framebuffer object

\item[{\code{dev}}] \leavevmode
DRM device

\item[{\code{crtc\_count}}] \leavevmode
number of possible CRTCs

\item[{\code{crtc\_info}}] \leavevmode
per-CRTC helper state (mode, x/y offset, etc)

\item[{\code{connector\_count}}] \leavevmode
number of connected connectors

\item[{\code{connector\_info\_alloc\_count}}] \leavevmode
size of connector\_info

\item[{\code{sw\_rotations}}] \leavevmode
Bitmask of all rotations requested for panel-orientation which
could not be handled in hardware. If only one bit is set
fbdev-\textgreater{}fbcon\_rotate\_hint gets set to the requested rotation.

\item[{\code{connector\_info}}] \leavevmode
Array of per-connector information. Do not iterate directly, but use
drm\_fb\_helper\_for\_each\_connector.

\item[{\code{funcs}}] \leavevmode
driver callbacks for fb helper

\item[{\code{fbdev}}] \leavevmode
emulated fbdev device info struct

\item[{\code{pseudo\_palette}}] \leavevmode
fake palette of 16 colors

\item[{\code{dirty\_clip}}] \leavevmode
clip rectangle used with deferred\_io to accumulate damage to
the screen buffer

\item[{\code{dirty\_lock}}] \leavevmode
spinlock protecting \textbf{dirty\_clip}

\item[{\code{dirty\_work}}] \leavevmode
worker used to flush the framebuffer

\item[{\code{resume\_work}}] \leavevmode
worker used during resume if the console lock is already taken

\item[{\code{lock}}] \leavevmode
Top-level FBDEV helper lock. This protects all internal data
structures and lists, such as \textbf{connector\_info} and \textbf{crtc\_info}.

FIXME: fbdev emulation locking is a mess and long term we want to
protect all helper internal state with this lock as well as reduce
core KMS locking as much as possible.

\item[{\code{kernel\_fb\_list}}] \leavevmode
Entry on the global kernel\_fb\_helper\_list, used for kgdb entry/exit.

\item[{\code{delayed\_hotplug}}] \leavevmode
A hotplug was received while fbdev wasn't in control of the DRM
device, i.e. another KMS master was active. The output configuration
needs to be reprobe when fbdev is in control again.

\item[{\code{deferred\_setup}}] \leavevmode
If no outputs are connected (disconnected or unknown) the FB helper
code will defer setup until at least one of the outputs shows up.
This field keeps track of the status so that setup can be retried
at every hotplug event until it succeeds eventually.

Protected by \textbf{lock}.

\item[{\code{preferred\_bpp}}] \leavevmode
Temporary storage for the driver's preferred BPP setting passed to
FB helper initialization. This needs to be tracked so that deferred
FB helper setup can pass this on.

See also: \textbf{deferred\_setup}

\end{description}

\textbf{Description}

This is the main structure used by the fbdev helpers. Drivers supporting
fbdev emulation should embedded this into their overall driver structure.
Drivers must also fill out a {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_funcs]{\emph{\code{struct drm\_fb\_helper\_funcs}}}} with a few
operations.
\index{DRM\_FB\_HELPER\_DEFAULT\_OPS (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.DRM_FB_HELPER_DEFAULT_OPS}\pysiglinewithargsret{\bfcode{DRM\_FB\_HELPER\_DEFAULT\_OPS}}{}{}
helper define for drm drivers

\end{fulllineitems}


\textbf{Parameters}

\textbf{Description}

Helper define to register default implementations of drm\_fb\_helper
functions. To be used in struct fb\_ops of drm drivers.
\index{drm\_fb\_helper\_single\_add\_all\_connectors (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_single_add_all_connectors}\pysiglinewithargsret{int \bfcode{drm\_fb\_helper\_single\_add\_all\_connectors}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{drm\_fb\_helper}}} *\emph{ fb\_helper}}{}
add all connectors to fbdev emulation helper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_fb\_helper * fb\_helper}}] \leavevmode
fbdev initialized with drm\_fb\_helper\_init, can be NULL

\end{description}

\textbf{Description}

This functions adds all the available connectors for use with the given
fb\_helper. This is a separate step to allow drivers to freely assign
connectors to the fbdev, e.g. if some are reserved for special purposes or
not adequate to be used for the fbcon.

This function is protected against concurrent connector hotadds/removals
using \code{drm\_fb\_helper\_add\_one\_connector()} and
\code{drm\_fb\_helper\_remove\_one\_connector()}.
\index{drm\_fb\_helper\_debug\_enter (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_debug_enter}\pysiglinewithargsret{int \bfcode{drm\_fb\_helper\_debug\_enter}}{struct fb\_info *\emph{ info}}{}
implementation for \code{fb\_ops.fb\_debug\_enter}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * info}}] \leavevmode
fbdev registered by the helper

\end{description}
\index{drm\_fb\_helper\_debug\_leave (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_debug_leave}\pysiglinewithargsret{int \bfcode{drm\_fb\_helper\_debug\_leave}}{struct fb\_info *\emph{ info}}{}
implementation for \code{fb\_ops.fb\_debug\_leave}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * info}}] \leavevmode
fbdev registered by the helper

\end{description}
\index{drm\_fb\_helper\_restore\_fbdev\_mode\_unlocked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_restore_fbdev_mode_unlocked}\pysiglinewithargsret{int \bfcode{drm\_fb\_helper\_restore\_fbdev\_mode\_unlocked}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{drm\_fb\_helper}}} *\emph{ fb\_helper}}{}
restore fbdev configuration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_fb\_helper * fb\_helper}}] \leavevmode
driver-allocated fbdev helper, can be NULL

\end{description}

\textbf{Description}

This should be called from driver's drm {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.lastclose}}}} callback
when implementing an fbcon on top of kms using this helper. This ensures that
the user isn't greeted with a black screen when e.g. X dies.

\textbf{Return}

Zero if everything went ok, negative error code otherwise.
\index{drm\_fb\_helper\_blank (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_blank}\pysiglinewithargsret{int \bfcode{drm\_fb\_helper\_blank}}{int\emph{ blank}, struct fb\_info *\emph{ info}}{}
implementation for \code{fb\_ops.fb\_blank}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int blank}}] \leavevmode
desired blanking state

\item[{\code{struct fb\_info * info}}] \leavevmode
fbdev registered by the helper

\end{description}
\index{drm\_fb\_helper\_prepare (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_prepare}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_prepare}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{drm\_fb\_helper}}} *\emph{ helper}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_funcs]{\emph{drm\_fb\_helper\_funcs}}} *\emph{ funcs}}{}
setup a drm\_fb\_helper structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_fb\_helper * helper}}] \leavevmode
driver-allocated fbdev helper structure to set up

\item[{\code{const struct drm\_fb\_helper\_funcs * funcs}}] \leavevmode
pointer to structure of functions associate with this helper

\end{description}

\textbf{Description}

Sets up the bare minimum to make the framebuffer helper usable. This is
useful to implement race-free initialization of the polling helpers.
\index{drm\_fb\_helper\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_init}\pysiglinewithargsret{int \bfcode{drm\_fb\_helper\_init}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{drm\_fb\_helper}}} *\emph{ fb\_helper}, int\emph{ max\_conn\_count}}{}
initialize a {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{\code{struct drm\_fb\_helper}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{struct drm\_fb\_helper * fb\_helper}}] \leavevmode
driver-allocated fbdev helper structure to initialize

\item[{\code{int max\_conn\_count}}] \leavevmode
max connector count

\end{description}

\textbf{Description}

This allocates the structures for the fbdev helper with the given limits.
Note that this won't yet touch the hardware (through the driver interfaces)
nor register the fbdev. This is only done in {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_initial_config]{\emph{\code{drm\_fb\_helper\_initial\_config()}}}}
to allow driver writes more control over the exact init sequence.

Drivers must call {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_prepare]{\emph{\code{drm\_fb\_helper\_prepare()}}}} before calling this function.

\textbf{Return}

Zero if everything went ok, nonzero otherwise.
\index{drm\_fb\_helper\_alloc\_fbi (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_alloc_fbi}\pysiglinewithargsret{struct fb\_info * \bfcode{drm\_fb\_helper\_alloc\_fbi}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{drm\_fb\_helper}}} *\emph{ fb\_helper}}{}
allocate fb\_info and some of its members

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_fb\_helper * fb\_helper}}] \leavevmode
driver-allocated fbdev helper

\end{description}

\textbf{Description}

A helper to alloc fb\_info and the members cmap and apertures. Called
by the driver within the fb\_probe fb\_helper callback function. Drivers do not
need to release the allocated fb\_info structure themselves, this is
automatically done when calling {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_fini]{\emph{\code{drm\_fb\_helper\_fini()}}}}.

\textbf{Return}

fb\_info pointer if things went okay, pointer containing error code
otherwise
\index{drm\_fb\_helper\_unregister\_fbi (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_unregister_fbi}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_unregister\_fbi}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{drm\_fb\_helper}}} *\emph{ fb\_helper}}{}
unregister fb\_info framebuffer device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_fb\_helper * fb\_helper}}] \leavevmode
driver-allocated fbdev helper, can be NULL

\end{description}

\textbf{Description}

A wrapper around unregister\_framebuffer, to release the fb\_info
framebuffer device. This must be called before releasing all resources for
\textbf{fb\_helper} by calling {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_fini]{\emph{\code{drm\_fb\_helper\_fini()}}}}.
\index{drm\_fb\_helper\_fini (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_fini}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_fini}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{drm\_fb\_helper}}} *\emph{ fb\_helper}}{}
finialize a {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{\code{struct drm\_fb\_helper}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_fb\_helper * fb\_helper}}] \leavevmode
driver-allocated fbdev helper, can be NULL

\end{description}

\textbf{Description}

This cleans up all remaining resources associated with \textbf{fb\_helper}. Must be
called after {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_unlink_fbi]{\emph{\code{drm\_fb\_helper\_unlink\_fbi()}}}} was called.
\index{drm\_fb\_helper\_unlink\_fbi (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_unlink_fbi}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_unlink\_fbi}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{drm\_fb\_helper}}} *\emph{ fb\_helper}}{}
wrapper around unlink\_framebuffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_fb\_helper * fb\_helper}}] \leavevmode
driver-allocated fbdev helper, can be NULL

\end{description}

\textbf{Description}

A wrapper around unlink\_framebuffer implemented by fbdev core
\index{drm\_fb\_helper\_deferred\_io (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_deferred_io}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_deferred\_io}}{struct fb\_info *\emph{ info}, struct list\_head *\emph{ pagelist}}{}
fbdev deferred\_io callback function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * info}}] \leavevmode
fb\_info struct pointer

\item[{\code{struct list\_head * pagelist}}] \leavevmode
list of dirty mmap framebuffer pages

\end{description}

\textbf{Description}

This function is used as the \code{fb\_deferred\_io.deferred\_io}
callback function for flushing the fbdev mmap writes.
\index{drm\_fb\_helper\_defio\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_defio_init}\pysiglinewithargsret{int \bfcode{drm\_fb\_helper\_defio\_init}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{drm\_fb\_helper}}} *\emph{ fb\_helper}}{}
fbdev deferred I/O initialization

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_fb\_helper * fb\_helper}}] \leavevmode
driver-allocated fbdev helper

\end{description}

\textbf{Description}

This function allocates \code{fb\_deferred\_io}, sets callback to
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_deferred_io]{\emph{\code{drm\_fb\_helper\_deferred\_io()}}}}, delay to 50ms and calls \code{fb\_deferred\_io\_init()}.
It should be called from the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_funcs]{\emph{\code{drm\_fb\_helper\_funcs-\textgreater{}fb\_probe}}}} callback.
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_fbdev_teardown]{\emph{\code{drm\_fb\_helper\_fbdev\_teardown()}}}} cleans up deferred I/O.

\textbf{NOTE}

A copy of \code{fb\_ops} is made and assigned to \code{info-\textgreater{}fbops}. This is done
because \code{fb\_deferred\_io\_cleanup()} clears \code{fbops-\textgreater{}fb\_mmap} and would thereby
affect other instances of that \code{fb\_ops}.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_fb\_helper\_sys\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_sys_read}\pysiglinewithargsret{ssize\_t \bfcode{drm\_fb\_helper\_sys\_read}}{struct fb\_info *\emph{ info}, char \_\_user *\emph{ buf}, size\_t\emph{ count}, loff\_t *\emph{ ppos}}{}
wrapper around fb\_sys\_read

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * info}}] \leavevmode
fb\_info struct pointer

\item[{\code{char \_\_user * buf}}] \leavevmode
userspace buffer to read from framebuffer memory

\item[{\code{size\_t count}}] \leavevmode
number of bytes to read from framebuffer memory

\item[{\code{loff\_t * ppos}}] \leavevmode
read offset within framebuffer memory

\end{description}

\textbf{Description}

A wrapper around fb\_sys\_read implemented by fbdev core
\index{drm\_fb\_helper\_sys\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_sys_write}\pysiglinewithargsret{ssize\_t \bfcode{drm\_fb\_helper\_sys\_write}}{struct fb\_info *\emph{ info}, const char \_\_user *\emph{ buf}, size\_t\emph{ count}, loff\_t *\emph{ ppos}}{}
wrapper around fb\_sys\_write

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * info}}] \leavevmode
fb\_info struct pointer

\item[{\code{const char \_\_user * buf}}] \leavevmode
userspace buffer to write to framebuffer memory

\item[{\code{size\_t count}}] \leavevmode
number of bytes to write to framebuffer memory

\item[{\code{loff\_t * ppos}}] \leavevmode
write offset within framebuffer memory

\end{description}

\textbf{Description}

A wrapper around fb\_sys\_write implemented by fbdev core
\index{drm\_fb\_helper\_sys\_fillrect (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_sys_fillrect}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_sys\_fillrect}}{struct fb\_info *\emph{ info}, const struct fb\_fillrect *\emph{ rect}}{}
wrapper around sys\_fillrect

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * info}}] \leavevmode
fbdev registered by the helper

\item[{\code{const struct fb\_fillrect * rect}}] \leavevmode
info about rectangle to fill

\end{description}

\textbf{Description}

A wrapper around sys\_fillrect implemented by fbdev core
\index{drm\_fb\_helper\_sys\_copyarea (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_sys_copyarea}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_sys\_copyarea}}{struct fb\_info *\emph{ info}, const struct fb\_copyarea *\emph{ area}}{}
wrapper around sys\_copyarea

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * info}}] \leavevmode
fbdev registered by the helper

\item[{\code{const struct fb\_copyarea * area}}] \leavevmode
info about area to copy

\end{description}

\textbf{Description}

A wrapper around sys\_copyarea implemented by fbdev core
\index{drm\_fb\_helper\_sys\_imageblit (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_sys_imageblit}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_sys\_imageblit}}{struct fb\_info *\emph{ info}, const struct fb\_image *\emph{ image}}{}
wrapper around sys\_imageblit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * info}}] \leavevmode
fbdev registered by the helper

\item[{\code{const struct fb\_image * image}}] \leavevmode
info about image to blit

\end{description}

\textbf{Description}

A wrapper around sys\_imageblit implemented by fbdev core
\index{drm\_fb\_helper\_cfb\_fillrect (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_cfb_fillrect}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_cfb\_fillrect}}{struct fb\_info *\emph{ info}, const struct fb\_fillrect *\emph{ rect}}{}
wrapper around cfb\_fillrect

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * info}}] \leavevmode
fbdev registered by the helper

\item[{\code{const struct fb\_fillrect * rect}}] \leavevmode
info about rectangle to fill

\end{description}

\textbf{Description}

A wrapper around cfb\_imageblit implemented by fbdev core
\index{drm\_fb\_helper\_cfb\_copyarea (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_cfb_copyarea}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_cfb\_copyarea}}{struct fb\_info *\emph{ info}, const struct fb\_copyarea *\emph{ area}}{}
wrapper around cfb\_copyarea

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * info}}] \leavevmode
fbdev registered by the helper

\item[{\code{const struct fb\_copyarea * area}}] \leavevmode
info about area to copy

\end{description}

\textbf{Description}

A wrapper around cfb\_copyarea implemented by fbdev core
\index{drm\_fb\_helper\_cfb\_imageblit (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_cfb_imageblit}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_cfb\_imageblit}}{struct fb\_info *\emph{ info}, const struct fb\_image *\emph{ image}}{}
wrapper around cfb\_imageblit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * info}}] \leavevmode
fbdev registered by the helper

\item[{\code{const struct fb\_image * image}}] \leavevmode
info about image to blit

\end{description}

\textbf{Description}

A wrapper around cfb\_imageblit implemented by fbdev core
\index{drm\_fb\_helper\_set\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_set_suspend}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_set\_suspend}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{drm\_fb\_helper}}} *\emph{ fb\_helper}, bool\emph{ suspend}}{}
wrapper around fb\_set\_suspend

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_fb\_helper * fb\_helper}}] \leavevmode
driver-allocated fbdev helper, can be NULL

\item[{\code{bool suspend}}] \leavevmode
whether to suspend or resume

\end{description}

\textbf{Description}

A wrapper around fb\_set\_suspend implemented by fbdev core.
Use {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_set_suspend_unlocked]{\emph{\code{drm\_fb\_helper\_set\_suspend\_unlocked()}}}} if you don't need to take
the lock yourself
\index{drm\_fb\_helper\_set\_suspend\_unlocked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_set_suspend_unlocked}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_set\_suspend\_unlocked}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{drm\_fb\_helper}}} *\emph{ fb\_helper}, bool\emph{ suspend}}{}
wrapper around fb\_set\_suspend that also takes the console lock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_fb\_helper * fb\_helper}}] \leavevmode
driver-allocated fbdev helper, can be NULL

\item[{\code{bool suspend}}] \leavevmode
whether to suspend or resume

\end{description}

\textbf{Description}

A wrapper around \code{fb\_set\_suspend()} that takes the console lock. If the lock
isn't available on resume, a worker is tasked with waiting for the lock
to become available. The console lock can be pretty contented on resume
due to all the printk activity.

This function can be called multiple times with the same state since
\code{fb\_info.state} is checked to see if fbdev is running or not before locking.

Use {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_set_suspend]{\emph{\code{drm\_fb\_helper\_set\_suspend()}}}} if you need to take the lock yourself.
\index{drm\_fb\_helper\_setcmap (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_setcmap}\pysiglinewithargsret{int \bfcode{drm\_fb\_helper\_setcmap}}{struct fb\_cmap *\emph{ cmap}, struct fb\_info *\emph{ info}}{}
implementation for \code{fb\_ops.fb\_setcmap}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_cmap * cmap}}] \leavevmode
cmap to set

\item[{\code{struct fb\_info * info}}] \leavevmode
fbdev registered by the helper

\end{description}
\index{drm\_fb\_helper\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_ioctl}\pysiglinewithargsret{int \bfcode{drm\_fb\_helper\_ioctl}}{struct fb\_info *\emph{ info}, unsigned int\emph{ cmd}, unsigned long\emph{ arg}}{}
legacy ioctl implementation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * info}}] \leavevmode
fbdev registered by the helper

\item[{\code{unsigned int cmd}}] \leavevmode
ioctl command

\item[{\code{unsigned long arg}}] \leavevmode
ioctl argument

\end{description}

\textbf{Description}

A helper to implement the standard fbdev ioctl. Only
FBIO\_WAITFORVSYNC is implemented for now.
\index{drm\_fb\_helper\_check\_var (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_check_var}\pysiglinewithargsret{int \bfcode{drm\_fb\_helper\_check\_var}}{struct fb\_var\_screeninfo *\emph{ var}, struct fb\_info *\emph{ info}}{}
implementation for \code{fb\_ops.fb\_check\_var}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_var\_screeninfo * var}}] \leavevmode
screeninfo to check

\item[{\code{struct fb\_info * info}}] \leavevmode
fbdev registered by the helper

\end{description}
\index{drm\_fb\_helper\_set\_par (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_set_par}\pysiglinewithargsret{int \bfcode{drm\_fb\_helper\_set\_par}}{struct fb\_info *\emph{ info}}{}
implementation for \code{fb\_ops.fb\_set\_par}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * info}}] \leavevmode
fbdev registered by the helper

\end{description}

\textbf{Description}

This will let fbcon do the mode init and is called at initialization time by
the fbdev core when registering the driver, and later on through the hotplug
callback.
\index{drm\_fb\_helper\_pan\_display (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_pan_display}\pysiglinewithargsret{int \bfcode{drm\_fb\_helper\_pan\_display}}{struct fb\_var\_screeninfo *\emph{ var}, struct fb\_info *\emph{ info}}{}
implementation for \code{fb\_ops.fb\_pan\_display}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_var\_screeninfo * var}}] \leavevmode
updated screen information

\item[{\code{struct fb\_info * info}}] \leavevmode
fbdev registered by the helper

\end{description}
\index{drm\_fb\_helper\_fill\_fix (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_fill_fix}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_fill\_fix}}{struct fb\_info *\emph{ info}, uint32\_t\emph{ pitch}, uint32\_t\emph{ depth}}{}
initializes fixed fbdev information

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * info}}] \leavevmode
fbdev registered by the helper

\item[{\code{uint32\_t pitch}}] \leavevmode
desired pitch

\item[{\code{uint32\_t depth}}] \leavevmode
desired depth

\end{description}

\textbf{Description}

Helper to fill in the fixed fbdev information useful for a non-accelerated
fbdev emulations. Drivers which support acceleration methods which impose
additional constraints need to set up their own limits.

Drivers should call this (or their equivalent setup code) from their
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_funcs]{\emph{\code{drm\_fb\_helper\_funcs.fb\_probe}}}} callback.
\index{drm\_fb\_helper\_fill\_var (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_fill_var}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_fill\_var}}{struct fb\_info *\emph{ info}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{drm\_fb\_helper}}} *\emph{ fb\_helper}, uint32\_t\emph{ fb\_width}, uint32\_t\emph{ fb\_height}}{}
initalizes variable fbdev information

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * info}}] \leavevmode
fbdev instance to set up

\item[{\code{struct drm\_fb\_helper * fb\_helper}}] \leavevmode
fb helper instance to use as template

\item[{\code{uint32\_t fb\_width}}] \leavevmode
desired fb width

\item[{\code{uint32\_t fb\_height}}] \leavevmode
desired fb height

\end{description}

\textbf{Description}

Sets up the variable fbdev metainformation from the given fb helper instance
and the drm framebuffer allocated in {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{\code{drm\_fb\_helper.fb}}}}.

Drivers should call this (or their equivalent setup code) from their
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_funcs]{\emph{\code{drm\_fb\_helper\_funcs.fb\_probe}}}} callback after having allocated the fbdev
backing storage framebuffer.
\index{drm\_fb\_helper\_initial\_config (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_initial_config}\pysiglinewithargsret{int \bfcode{drm\_fb\_helper\_initial\_config}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{drm\_fb\_helper}}} *\emph{ fb\_helper}, int\emph{ bpp\_sel}}{}
setup a sane initial connector configuration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_fb\_helper * fb\_helper}}] \leavevmode
fb\_helper device struct

\item[{\code{int bpp\_sel}}] \leavevmode
bpp value to use for the framebuffer configuration

\end{description}

\textbf{Description}

Scans the CRTCs and connectors and tries to put together an initial setup.
At the moment, this is a cloned configuration across all heads with
a new framebuffer object as the backing store.

Note that this also registers the fbdev and so allows userspace to call into
the driver through the fbdev interfaces.

This function will call down into the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_funcs]{\emph{\code{drm\_fb\_helper\_funcs.fb\_probe}}}} callback
to let the driver allocate and initialize the fbdev info structure and the
drm framebuffer used to back the fbdev. {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_fill_var]{\emph{\code{drm\_fb\_helper\_fill\_var()}}}} and
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_fill_fix]{\emph{\code{drm\_fb\_helper\_fill\_fix()}}}} are provided as helpers to setup simple default
values for the fbdev info structure.

HANG DEBUGGING:

When you have fbcon support built-in or already loaded, this function will do
a full modeset to setup the fbdev console. Due to locking misdesign in the
VT/fbdev subsystem that entire modeset sequence has to be done while holding
console\_lock. Until console\_unlock is called no dmesg lines will be sent out
to consoles, not even serial console. This means when your driver crashes,
you will see absolutely nothing else but a system stuck in this function,
with no further output. Any kind of \code{printk()} you place within your own driver
or in the drm core modeset code will also never show up.

Standard debug practice is to run the fbcon setup without taking the
console\_lock as a hack, to be able to see backtraces and crashes on the
serial line. This can be done by setting the fb.lockless\_register\_fb=1 kernel
cmdline option.

The other option is to just disable fbdev emulation since very likely the
first modeset from userspace will crash in the same way, and is even easier
to debug. This can be done by setting the drm\_kms\_helper.fbdev\_emulation=0
kernel cmdline option.

\textbf{Return}

Zero if everything went ok, nonzero otherwise.
\index{drm\_fb\_helper\_hotplug\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_hotplug_event}\pysiglinewithargsret{int \bfcode{drm\_fb\_helper\_hotplug\_event}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{drm\_fb\_helper}}} *\emph{ fb\_helper}}{}
respond to a hotplug notification by probing all the outputs attached to the fb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_fb\_helper * fb\_helper}}] \leavevmode
driver-allocated fbdev helper, can be NULL

\end{description}

\textbf{Description}

Scan the connectors attached to the fb\_helper and try to put together a
setup after notification of a change in output configuration.

Called at runtime, takes the mode config locks to be able to check/change the
modeset configuration. Must be run from process context (which usually means
either the output polling work or a work item launched from the driver's
hotplug interrupt).

Note that drivers may call this even before calling
drm\_fb\_helper\_initial\_config but only after drm\_fb\_helper\_init. This allows
for a race-free fbcon setup and will make sure that the fbdev emulation will
not miss any hotplug events.

\textbf{Return}

0 on success and a non-zero error code otherwise.
\index{drm\_fb\_helper\_fbdev\_setup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_fbdev_setup}\pysiglinewithargsret{int \bfcode{drm\_fb\_helper\_fbdev\_setup}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{drm\_fb\_helper}}} *\emph{ fb\_helper}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_funcs]{\emph{drm\_fb\_helper\_funcs}}} *\emph{ funcs}, unsigned int\emph{ preferred\_bpp}, unsigned int\emph{ max\_conn\_count}}{}
Setup fbdev emulation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_fb\_helper * fb\_helper}}] \leavevmode
fbdev helper structure to set up

\item[{\code{const struct drm\_fb\_helper\_funcs * funcs}}] \leavevmode
fbdev helper functions

\item[{\code{unsigned int preferred\_bpp}}] \leavevmode
Preferred bits per pixel for the device.
\textbf{dev}-\textgreater{}mode\_config.preferred\_depth is used if this is zero.

\item[{\code{unsigned int max\_conn\_count}}] \leavevmode
Maximum number of connectors.
\textbf{dev}-\textgreater{}mode\_config.num\_connector is used if this is zero.

\end{description}

\textbf{Description}

This function sets up fbdev emulation and registers fbdev for access by
userspace. If all connectors are disconnected, setup is deferred to the next
time {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_hotplug_event]{\emph{\code{drm\_fb\_helper\_hotplug\_event()}}}} is called.
The caller must to provide a {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_funcs]{\emph{\code{drm\_fb\_helper\_funcs-\textgreater{}fb\_probe}}}} callback
function.

See also: {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_initial_config]{\emph{\code{drm\_fb\_helper\_initial\_config()}}}}

\textbf{Return}

Zero on success or negative error code on failure.
\index{drm\_fb\_helper\_fbdev\_teardown (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_fbdev_teardown}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_fbdev\_teardown}}{struct drm\_device *\emph{ dev}}{}
Tear down fbdev emulation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

This function unregisters fbdev if not already done and cleans up the
associated resources including the {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}}.
The driver is responsible for freeing the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper]{\emph{\code{drm\_fb\_helper}}}} structure which is
stored in \code{drm\_device-\textgreater{}fb\_helper}. Do note that this pointer has been cleared
when this function returns.

In order to support device removal/unplug while file handles are still open,
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_unregister_fbi]{\emph{\code{drm\_fb\_helper\_unregister\_fbi()}}}} should be called on device removal and
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_fbdev_teardown]{\emph{\code{drm\_fb\_helper\_fbdev\_teardown()}}}} in the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver-\textgreater{}release}}}} callback when
file handles are closed.
\index{drm\_fb\_helper\_lastclose (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_lastclose}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_lastclose}}{struct drm\_device *\emph{ dev}}{}
DRM driver lastclose helper for fbdev emulation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

This function can be used as the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver-\textgreater{}lastclose}}}} callback for drivers
that only need to call {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_restore_fbdev_mode_unlocked]{\emph{\code{drm\_fb\_helper\_restore\_fbdev\_mode\_unlocked()}}}}.
\index{drm\_fb\_helper\_output\_poll\_changed (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_helper_output_poll_changed}\pysiglinewithargsret{void \bfcode{drm\_fb\_helper\_output\_poll\_changed}}{struct drm\_device *\emph{ dev}}{}
DRM mode config .output\_poll\_changed helper for fbdev emulation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

This function can be used as the
{\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.output\_poll\_changed}}}} callback for drivers that only
need to call {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_hotplug_event]{\emph{\code{drm\_fb\_helper\_hotplug\_event()}}}}.


\section{Framebuffer CMA Helper Functions Reference}
\label{gpu/drm-kms-helpers:framebuffer-cma-helper-functions-reference}
Provides helper functions for creating a cma (contiguous memory allocator)
backed framebuffer.

{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_gem_fb_create]{\emph{\code{drm\_gem\_fb\_create()}}}} is used in the {\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.fb\_create}}}}
callback function to create a cma backed framebuffer.

An fbdev framebuffer backed by cma is also available by calling
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_cma_fbdev_init]{\emph{\code{drm\_fb\_cma\_fbdev\_init()}}}}. {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_cma_fbdev_fini]{\emph{\code{drm\_fb\_cma\_fbdev\_fini()}}}} tears it down.
If the {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_funcs]{\emph{\code{drm\_framebuffer\_funcs.dirty}}}} callback is set, fb\_deferred\_io will be
set up automatically. {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_funcs]{\emph{\code{drm\_framebuffer\_funcs.dirty}}}} is called by
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_deferred_io]{\emph{\code{drm\_fb\_helper\_deferred\_io()}}}} in process context (\code{struct delayed\_work}).

Example fbdev deferred io code:

\begin{Verbatim}[commandchars=\\\{\}]
static int driver\PYGZus{}fb\PYGZus{}dirty(struct drm\PYGZus{}framebuffer *fb,
                           struct drm\PYGZus{}file *file\PYGZus{}priv,
                           unsigned flags, unsigned color,
                           struct drm\PYGZus{}clip\PYGZus{}rect *clips,
                           unsigned num\PYGZus{}clips)
\PYGZob{}
    struct drm\PYGZus{}gem\PYGZus{}cma\PYGZus{}object *cma = drm\PYGZus{}fb\PYGZus{}cma\PYGZus{}get\PYGZus{}gem\PYGZus{}obj(fb, 0);
    ... push changes ...
    return 0;
\PYGZcb{}

static struct drm\PYGZus{}framebuffer\PYGZus{}funcs driver\PYGZus{}fb\PYGZus{}funcs = \PYGZob{}
    .destroy       = drm\PYGZus{}gem\PYGZus{}fb\PYGZus{}destroy,
    .create\PYGZus{}handle = drm\PYGZus{}gem\PYGZus{}fb\PYGZus{}create\PYGZus{}handle,
    .dirty         = driver\PYGZus{}fb\PYGZus{}dirty,
\PYGZcb{};
\end{Verbatim}

Initialize:

\begin{Verbatim}[commandchars=\\\{\}]
fbdev = drm\PYGZus{}fb\PYGZus{}cma\PYGZus{}fbdev\PYGZus{}init\PYGZus{}with\PYGZus{}funcs(dev, 16,
                                      dev\PYGZhy{}\PYGZgt{}mode\PYGZus{}config.num\PYGZus{}crtc,
                                      dev\PYGZhy{}\PYGZgt{}mode\PYGZus{}config.num\PYGZus{}connector,
                                      :c:type:{}`driver\PYGZus{}fb\PYGZus{}funcs{}`);
\end{Verbatim}
\index{drm\_fb\_cma\_get\_gem\_obj (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_cma_get_gem_obj}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_cma_object]{\emph{drm\_gem\_cma\_object}}} * \bfcode{drm\_fb\_cma\_get\_gem\_obj}}{struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, unsigned int\emph{ plane}}{}
Get CMA GEM object for framebuffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
The framebuffer

\item[{\code{unsigned int plane}}] \leavevmode
Which plane

\end{description}

\textbf{Description}

Return the CMA GEM object for given framebuffer.

This function will usually be called from the CRTC callback functions.
\index{drm\_fb\_cma\_get\_gem\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_cma_get_gem_addr}\pysiglinewithargsret{dma\_addr\_t \bfcode{drm\_fb\_cma\_get\_gem\_addr}}{struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} *\emph{ state}, unsigned int\emph{ plane}}{}
Get physical address for framebuffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
The framebuffer

\item[{\code{struct drm\_plane\_state * state}}] \leavevmode
Which state of drm plane

\item[{\code{unsigned int plane}}] \leavevmode
Which plane
Return the CMA GEM address for given framebuffer.

\end{description}

\textbf{Description}

This function will usually be called from the PLANE callback functions.
\index{drm\_fb\_cma\_fbdev\_init\_with\_funcs (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_cma_fbdev_init_with_funcs}\pysiglinewithargsret{int \bfcode{drm\_fb\_cma\_fbdev\_init\_with\_funcs}}{struct drm\_device *\emph{ dev}, unsigned int\emph{ preferred\_bpp}, unsigned int\emph{ max\_conn\_count}, const struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_funcs]{\emph{drm\_framebuffer\_funcs}}} *\emph{ funcs}}{}
Allocate and initialize fbdev emulation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{unsigned int preferred\_bpp}}] \leavevmode
Preferred bits per pixel for the device.
\textbf{dev}-\textgreater{}mode\_config.preferred\_depth is used if this is zero.

\item[{\code{unsigned int max\_conn\_count}}] \leavevmode
Maximum number of connectors.
\textbf{dev}-\textgreater{}mode\_config.num\_connector is used if this is zero.

\item[{\code{const struct drm\_framebuffer\_funcs * funcs}}] \leavevmode
Framebuffer functions, in particular a custom \code{dirty()} callback.
Can be NULL.

\end{description}

\textbf{Return}

Zero on success or negative error code on failure.
\index{drm\_fb\_cma\_fbdev\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_cma_fbdev_init}\pysiglinewithargsret{int \bfcode{drm\_fb\_cma\_fbdev\_init}}{struct drm\_device *\emph{ dev}, unsigned int\emph{ preferred\_bpp}, unsigned int\emph{ max\_conn\_count}}{}
Allocate and initialize fbdev emulation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{unsigned int preferred\_bpp}}] \leavevmode
Preferred bits per pixel for the device.
\textbf{dev}-\textgreater{}mode\_config.preferred\_depth is used if this is zero.

\item[{\code{unsigned int max\_conn\_count}}] \leavevmode
Maximum number of connectors.
\textbf{dev}-\textgreater{}mode\_config.num\_connector is used if this is zero.

\end{description}

\textbf{Return}

Zero on success or negative error code on failure.
\index{drm\_fb\_cma\_fbdev\_fini (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fb_cma_fbdev_fini}\pysiglinewithargsret{void \bfcode{drm\_fb\_cma\_fbdev\_fini}}{struct drm\_device *\emph{ dev}}{}
Teardown fbdev emulation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}
\index{drm\_fbdev\_cma\_init\_with\_funcs (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fbdev_cma_init_with_funcs}\pysiglinewithargsret{struct drm\_fbdev\_cma * \bfcode{drm\_fbdev\_cma\_init\_with\_funcs}}{struct drm\_device *\emph{ dev}, unsigned int\emph{ preferred\_bpp}, unsigned int\emph{ max\_conn\_count}, const struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_funcs]{\emph{drm\_framebuffer\_funcs}}} *\emph{ funcs}}{}
Allocate and initializes a drm\_fbdev\_cma struct

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{unsigned int preferred\_bpp}}] \leavevmode
Preferred bits per pixel for the device

\item[{\code{unsigned int max\_conn\_count}}] \leavevmode
Maximum number of connectors

\item[{\code{const struct drm\_framebuffer\_funcs * funcs}}] \leavevmode
fb helper functions, in particular a custom \code{dirty()} callback

\end{description}

\textbf{Description}

Returns a newly allocated drm\_fbdev\_cma struct or a ERR\_PTR.
\index{drm\_fbdev\_cma\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fbdev_cma_init}\pysiglinewithargsret{struct drm\_fbdev\_cma * \bfcode{drm\_fbdev\_cma\_init}}{struct drm\_device *\emph{ dev}, unsigned int\emph{ preferred\_bpp}, unsigned int\emph{ max\_conn\_count}}{}
Allocate and initializes a drm\_fbdev\_cma struct

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{unsigned int preferred\_bpp}}] \leavevmode
Preferred bits per pixel for the device

\item[{\code{unsigned int max\_conn\_count}}] \leavevmode
Maximum number of connectors

\end{description}

\textbf{Description}

Returns a newly allocated drm\_fbdev\_cma struct or a ERR\_PTR.
\index{drm\_fbdev\_cma\_fini (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fbdev_cma_fini}\pysiglinewithargsret{void \bfcode{drm\_fbdev\_cma\_fini}}{struct drm\_fbdev\_cma *\emph{ fbdev\_cma}}{}
Free drm\_fbdev\_cma struct

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_fbdev\_cma * fbdev\_cma}}] \leavevmode
The drm\_fbdev\_cma struct

\end{description}
\index{drm\_fbdev\_cma\_restore\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fbdev_cma_restore_mode}\pysiglinewithargsret{void \bfcode{drm\_fbdev\_cma\_restore\_mode}}{struct drm\_fbdev\_cma *\emph{ fbdev\_cma}}{}
Restores initial framebuffer mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_fbdev\_cma * fbdev\_cma}}] \leavevmode
The drm\_fbdev\_cma struct, may be NULL

\end{description}

\textbf{Description}

This function is usually called from the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.lastclose}}}} callback.
\index{drm\_fbdev\_cma\_hotplug\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fbdev_cma_hotplug_event}\pysiglinewithargsret{void \bfcode{drm\_fbdev\_cma\_hotplug\_event}}{struct drm\_fbdev\_cma *\emph{ fbdev\_cma}}{}
Poll for hotpulug events

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_fbdev\_cma * fbdev\_cma}}] \leavevmode
The drm\_fbdev\_cma struct, may be NULL

\end{description}

\textbf{Description}

This function is usually called from the {\hyperref[gpu/drm\string-kms:c.drm_mode_config]{\emph{\code{drm\_mode\_config.output\_poll\_changed}}}}
callback.
\index{drm\_fbdev\_cma\_set\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fbdev_cma_set_suspend}\pysiglinewithargsret{void \bfcode{drm\_fbdev\_cma\_set\_suspend}}{struct drm\_fbdev\_cma *\emph{ fbdev\_cma}, bool\emph{ state}}{}
wrapper around drm\_fb\_helper\_set\_suspend

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_fbdev\_cma * fbdev\_cma}}] \leavevmode
The drm\_fbdev\_cma struct, may be NULL

\item[{\code{bool state}}] \leavevmode
desired state, zero to resume, non-zero to suspend

\end{description}

\textbf{Description}

Calls drm\_fb\_helper\_set\_suspend, which is a wrapper around
fb\_set\_suspend implemented by fbdev core.
\index{drm\_fbdev\_cma\_set\_suspend\_unlocked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_fbdev_cma_set_suspend_unlocked}\pysiglinewithargsret{void \bfcode{drm\_fbdev\_cma\_set\_suspend\_unlocked}}{struct drm\_fbdev\_cma *\emph{ fbdev\_cma}, bool\emph{ state}}{}
wrapper around drm\_fb\_helper\_set\_suspend\_unlocked

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_fbdev\_cma * fbdev\_cma}}] \leavevmode
The drm\_fbdev\_cma struct, may be NULL

\item[{\code{bool state}}] \leavevmode
desired state, zero to resume, non-zero to suspend

\end{description}

\textbf{Description}

Calls drm\_fb\_helper\_set\_suspend, which is a wrapper around
fb\_set\_suspend implemented by fbdev core.


\section{Bridges}
\label{gpu/drm-kms-helpers:bridges}\label{gpu/drm-kms-helpers:drm-bridges}

\subsection{Overview}
\label{gpu/drm-kms-helpers:id1}
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{\code{struct drm\_bridge}}}} represents a device that hangs on to an encoder. These are
handy when a regular {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{\code{drm\_encoder}}}} entity isn't enough to represent the entire
encoder chain.

A bridge is always attached to a single {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{\code{drm\_encoder}}}} at a time, but can be
either connected to it directly, or through an intermediate bridge:

\begin{Verbatim}[commandchars=\\\{\}]
encoder \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} bridge B \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} bridge A
\end{Verbatim}

Here, the output of the encoder feeds to bridge B, and that furthers feeds to
bridge A.

The driver using the bridge is responsible to make the associations between
the encoder and bridges. Once these links are made, the bridges will
participate along with encoder functions to perform mode\_set/enable/disable
through the ops provided in {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge_funcs]{\emph{\code{drm\_bridge\_funcs}}}}.

drm\_bridge, like drm\_panel, aren't drm\_mode\_object entities like planes,
CRTCs, encoders or connectors and hence are not visible to userspace. They
just provide additional hooks to get the desired output at the end of the
encoder chain.

Bridges can also be chained up using the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{\code{drm\_bridge.next}}}} pointer.

Both legacy CRTC helpers and the new atomic modeset helpers support bridges.


\subsection{Default bridge callback sequence}
\label{gpu/drm-kms-helpers:default-bridge-callback-sequence}
The {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge_funcs]{\emph{\code{drm\_bridge\_funcs}}}} ops are populated by the bridge driver. The DRM
internals (atomic and CRTC helpers) use the helpers defined in drm\_bridge.c
These helpers call a specific {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge_funcs]{\emph{\code{drm\_bridge\_funcs}}}} op for all the bridges
during encoder configuration.

For detailed specification of the bridge callbacks see {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge_funcs]{\emph{\code{drm\_bridge\_funcs}}}}.


\subsection{Bridge Helper Reference}
\label{gpu/drm-kms-helpers:bridge-helper-reference}\index{drm\_bridge\_funcs (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_bridge_funcs}\pysigline{struct \bfcode{drm\_bridge\_funcs}}
drm\_bridge control functions

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}bridge\PYGZus{}funcs \PYGZob{}
  int (*attach)(struct drm\PYGZus{}bridge *bridge);
  void (*detach)(struct drm\PYGZus{}bridge *bridge);
  enum drm\PYGZus{}mode\PYGZus{}status (*mode\PYGZus{}valid)(struct drm\PYGZus{}bridge *crtc, const struct drm\PYGZus{}display\PYGZus{}mode *mode);
  bool (*mode\PYGZus{}fixup)(struct drm\PYGZus{}bridge *bridge,const struct drm\PYGZus{}display\PYGZus{}mode *mode, struct drm\PYGZus{}display\PYGZus{}mode *adjusted\PYGZus{}mode);
  void (*disable)(struct drm\PYGZus{}bridge *bridge);
  void (*post\PYGZus{}disable)(struct drm\PYGZus{}bridge *bridge);
  void (*mode\PYGZus{}set)(struct drm\PYGZus{}bridge *bridge,struct drm\PYGZus{}display\PYGZus{}mode *mode, struct drm\PYGZus{}display\PYGZus{}mode *adjusted\PYGZus{}mode);
  void (*pre\PYGZus{}enable)(struct drm\PYGZus{}bridge *bridge);
  void (*enable)(struct drm\PYGZus{}bridge *bridge);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{attach}}] \leavevmode
This callback is invoked whenever our bridge is being attached to a
{\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{\code{drm\_encoder}}}}.

The attach callback is optional.

RETURNS:

Zero on success, error code on failure.

\item[{\code{detach}}] \leavevmode
This callback is invoked whenever our bridge is being detached from a
{\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{\code{drm\_encoder}}}}.

The detach callback is optional.

\item[{\code{mode\_valid}}] \leavevmode
This callback is used to check if a specific mode is valid in this
bridge. This should be implemented if the bridge has some sort of
restriction in the modes it can display. For example, a given bridge
may be responsible to set a clock value. If the clock can not
produce all the values for the available modes then this callback
can be used to restrict the number of modes to only the ones that
can be displayed.

This hook is used by the probe helpers to filter the mode list in
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_helper_probe_single_connector_modes]{\emph{\code{drm\_helper\_probe\_single\_connector\_modes()}}}}, and it is used by the
atomic helpers to validate modes supplied by userspace in
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_check_modeset]{\emph{\code{drm\_atomic\_helper\_check\_modeset()}}}}.

This function is optional.

NOTE:

Since this function is both called from the check phase of an atomic
commit, and the mode validation in the probe paths it is not allowed
to look at anything else but the passed-in mode, and validate it
against configuration-invariant hardward constraints. Any further
limits which depend upon the configuration can only be checked in
\textbf{mode\_fixup}.

RETURNS:

drm\_mode\_status Enum

\item[{\code{mode\_fixup}}] \leavevmode
This callback is used to validate and adjust a mode. The paramater
mode is the display mode that should be fed to the next element in
the display chain, either the final {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector}}}} or the next
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{\code{drm\_bridge}}}}. The parameter adjusted\_mode is the input mode the bridge
requires. It can be modified by this callback and does not need to
match mode. See also {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state.adjusted\_mode}}}} for more details.

This is the only hook that allows a bridge to reject a modeset. If
this function passes all other callbacks must succeed for this
configuration.

The mode\_fixup callback is optional.

NOTE:

This function is called in the check phase of atomic modesets, which
can be aborted for any reason (including on userspace's request to
just check whether a configuration would be possible). Drivers MUST
NOT touch any persistent state (hardware or software) or data
structures except the passed in \textbf{state} parameter.

Also beware that userspace can request its own custom modes, neither
core nor helpers filter modes to the list of probe modes reported by
the GETCONNECTOR IOCTL and stored in {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.modes}}}}. To ensure
that modes are filtered consistently put any bridge constraints and
limits checks into \textbf{mode\_valid}.

RETURNS:

True if an acceptable configuration is possible, false if the modeset
operation should be rejected.

\item[{\code{disable}}] \leavevmode
This callback should disable the bridge. It is called right before
the preceding element in the display pipe is disabled. If the
preceding element is a bridge this means it's called before that
bridge's \textbf{disable} vfunc. If the preceding element is a {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{\code{drm\_encoder}}}}
it's called right before the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.disable}}}},
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.prepare}}}} or {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.dpms}}}}
hook.

The bridge can assume that the display pipe (i.e. clocks and timing
signals) feeding it is still running when this callback is called.

The disable callback is optional.

\item[{\code{post\_disable}}] \leavevmode
This callback should disable the bridge. It is called right after the
preceding element in the display pipe is disabled. If the preceding
element is a bridge this means it's called after that bridge's
\textbf{post\_disable} function. If the preceding element is a {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{\code{drm\_encoder}}}}
it's called right after the encoder's
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.disable}}}}, {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.prepare}}}}
or {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.dpms}}}} hook.

The bridge must assume that the display pipe (i.e. clocks and timing
singals) feeding it is no longer running when this callback is
called.

The post\_disable callback is optional.

\item[{\code{mode\_set}}] \leavevmode
This callback should set the given mode on the bridge. It is called
after the \textbf{mode\_set} callback for the preceding element in the display
pipeline has been called already. If the bridge is the first element
then this would be {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.mode\_set}}}}. The display
pipe (i.e.  clocks and timing signals) is off when this function is
called.

\item[{\code{pre\_enable}}] \leavevmode
This callback should enable the bridge. It is called right before
the preceding element in the display pipe is enabled. If the
preceding element is a bridge this means it's called before that
bridge's \textbf{pre\_enable} function. If the preceding element is a
{\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{\code{drm\_encoder}}}} it's called right before the encoder's
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.enable}}}}, {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.commit}}}} or
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.dpms}}}} hook.

The display pipe (i.e. clocks and timing signals) feeding this bridge
will not yet be running when this callback is called. The bridge must
not enable the display link feeding the next bridge in the chain (if
there is one) when this callback is called.

The pre\_enable callback is optional.

\item[{\code{enable}}] \leavevmode
This callback should enable the bridge. It is called right after
the preceding element in the display pipe is enabled. If the
preceding element is a bridge this means it's called after that
bridge's \textbf{enable} function. If the preceding element is a
{\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{\code{drm\_encoder}}}} it's called right after the encoder's
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.enable}}}}, {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.commit}}}} or
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.dpms}}}} hook.

The bridge can assume that the display pipe (i.e. clocks and timing
signals) feeding it is running when this callback is called. This
callback must enable the display link feeding the next bridge in the
chain if there is one.

The enable callback is optional.

\end{description}
\index{drm\_bridge (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_bridge}\pysigline{struct \bfcode{drm\_bridge}}
central DRM bridge control structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}bridge \PYGZob{}
  struct drm\PYGZus{}device *dev;
  struct drm\PYGZus{}encoder *encoder;
  struct drm\PYGZus{}bridge *next;
\PYGZsh{}ifdef CONFIG\PYGZus{}OF;
  struct device\PYGZus{}node *of\PYGZus{}node;
\PYGZsh{}endif;
  struct list\PYGZus{}head list;
  const struct drm\PYGZus{}bridge\PYGZus{}funcs *funcs;
  void *driver\PYGZus{}private;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev}}] \leavevmode
DRM device this bridge belongs to

\item[{\code{encoder}}] \leavevmode
encoder to which this bridge is connected

\item[{\code{next}}] \leavevmode
the next bridge in the encoder chain

\item[{\code{of\_node}}] \leavevmode
device node pointer to the bridge

\item[{\code{list}}] \leavevmode
to keep track of all added bridges

\item[{\code{funcs}}] \leavevmode
control functions

\item[{\code{driver\_private}}] \leavevmode
pointer to the bridge driver's internal context

\end{description}
\index{drm\_bridge\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_bridge_add}\pysiglinewithargsret{void \bfcode{drm\_bridge\_add}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{drm\_bridge}}} *\emph{ bridge}}{}
add the given bridge to the global bridge list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_bridge * bridge}}] \leavevmode
bridge control structure

\end{description}
\index{drm\_bridge\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_bridge_remove}\pysiglinewithargsret{void \bfcode{drm\_bridge\_remove}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{drm\_bridge}}} *\emph{ bridge}}{}
remove the given bridge from the global bridge list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_bridge * bridge}}] \leavevmode
bridge control structure

\end{description}
\index{drm\_bridge\_attach (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_bridge_attach}\pysiglinewithargsret{int \bfcode{drm\_bridge\_attach}}{struct {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{drm\_encoder}}} *\emph{ encoder}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{drm\_bridge}}} *\emph{ bridge}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{drm\_bridge}}} *\emph{ previous}}{}
attach the bridge to an encoder's chain

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_encoder * encoder}}] \leavevmode
DRM encoder

\item[{\code{struct drm\_bridge * bridge}}] \leavevmode
bridge to attach

\item[{\code{struct drm\_bridge * previous}}] \leavevmode
previous bridge in the chain (optional)

\end{description}

\textbf{Description}

Called by a kms driver to link the bridge to an encoder's chain. The previous
argument specifies the previous bridge in the chain. If NULL, the bridge is
linked directly at the encoder's output. Otherwise it is linked at the
previous bridge's output.

If non-NULL the previous bridge must be already attached by a call to this
function.

\textbf{Return}

Zero on success, error code on failure
\index{drm\_bridge\_mode\_fixup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_bridge_mode_fixup}\pysiglinewithargsret{bool \bfcode{drm\_bridge\_mode\_fixup}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{drm\_bridge}}} *\emph{ bridge}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}, struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ adjusted\_mode}}{}
fixup proposed mode for all bridges in the encoder chain

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_bridge * bridge}}] \leavevmode
bridge control structure

\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
desired mode to be set for the bridge

\item[{\code{struct drm\_display\_mode * adjusted\_mode}}] \leavevmode
updated mode that works for this bridge

\end{description}

\textbf{Description}

Calls {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge_funcs]{\emph{\code{drm\_bridge\_funcs.mode\_fixup}}}} for all the bridges in the
encoder chain, starting from the first bridge to the last.

\textbf{Note}

the bridge passed should be the one closest to the encoder

\textbf{Return}

true on success, false on failure
\index{drm\_bridge\_mode\_valid (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_bridge_mode_valid}\pysiglinewithargsret{enum {\hyperref[gpu/drm\string-kms:c.drm_mode_status]{\emph{drm\_mode\_status}}} \bfcode{drm\_bridge\_mode\_valid}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{drm\_bridge}}} *\emph{ bridge}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
validate the mode against all bridges in the encoder chain.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_bridge * bridge}}] \leavevmode
bridge control structure

\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
desired mode to be validated

\end{description}

\textbf{Description}

Calls {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge_funcs]{\emph{\code{drm\_bridge\_funcs.mode\_valid}}}} for all the bridges in the encoder
chain, starting from the first bridge to the last. If at least one bridge
does not accept the mode the function returns the error code.

\textbf{Note}

the bridge passed should be the one closest to the encoder.

\textbf{Return}

MODE\_OK on success, drm\_mode\_status Enum error code on failure
\index{drm\_bridge\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_bridge_disable}\pysiglinewithargsret{void \bfcode{drm\_bridge\_disable}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{drm\_bridge}}} *\emph{ bridge}}{}
disables all bridges in the encoder chain

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_bridge * bridge}}] \leavevmode
bridge control structure

\end{description}

\textbf{Description}

Calls {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge_funcs]{\emph{\code{drm\_bridge\_funcs.disable}}}} op for all the bridges in the encoder
chain, starting from the last bridge to the first. These are called before
calling the encoder's prepare op.

\textbf{Note}

the bridge passed should be the one closest to the encoder
\index{drm\_bridge\_post\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_bridge_post_disable}\pysiglinewithargsret{void \bfcode{drm\_bridge\_post\_disable}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{drm\_bridge}}} *\emph{ bridge}}{}
cleans up after disabling all bridges in the encoder chain

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_bridge * bridge}}] \leavevmode
bridge control structure

\end{description}

\textbf{Description}

Calls {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge_funcs]{\emph{\code{drm\_bridge\_funcs.post\_disable}}}} op for all the bridges in the
encoder chain, starting from the first bridge to the last. These are called
after completing the encoder's prepare op.

\textbf{Note}

the bridge passed should be the one closest to the encoder
\index{drm\_bridge\_mode\_set (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_bridge_mode_set}\pysiglinewithargsret{void \bfcode{drm\_bridge\_mode\_set}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{drm\_bridge}}} *\emph{ bridge}, struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}, struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ adjusted\_mode}}{}
set proposed mode for all bridges in the encoder chain

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_bridge * bridge}}] \leavevmode
bridge control structure

\item[{\code{struct drm\_display\_mode * mode}}] \leavevmode
desired mode to be set for the bridge

\item[{\code{struct drm\_display\_mode * adjusted\_mode}}] \leavevmode
updated mode that works for this bridge

\end{description}

\textbf{Description}

Calls {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge_funcs]{\emph{\code{drm\_bridge\_funcs.mode\_set}}}} op for all the bridges in the
encoder chain, starting from the first bridge to the last.

\textbf{Note}

the bridge passed should be the one closest to the encoder
\index{drm\_bridge\_pre\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_bridge_pre_enable}\pysiglinewithargsret{void \bfcode{drm\_bridge\_pre\_enable}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{drm\_bridge}}} *\emph{ bridge}}{}
prepares for enabling all bridges in the encoder chain

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_bridge * bridge}}] \leavevmode
bridge control structure

\end{description}

\textbf{Description}

Calls {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge_funcs]{\emph{\code{drm\_bridge\_funcs.pre\_enable}}}} op for all the bridges in the encoder
chain, starting from the last bridge to the first. These are called
before calling the encoder's commit op.

\textbf{Note}

the bridge passed should be the one closest to the encoder
\index{drm\_bridge\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_bridge_enable}\pysiglinewithargsret{void \bfcode{drm\_bridge\_enable}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{drm\_bridge}}} *\emph{ bridge}}{}
enables all bridges in the encoder chain

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_bridge * bridge}}] \leavevmode
bridge control structure

\end{description}

\textbf{Description}

Calls {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge_funcs]{\emph{\code{drm\_bridge\_funcs.enable}}}} op for all the bridges in the encoder
chain, starting from the first bridge to the last. These are called
after completing the encoder's commit op.

Note that the bridge passed should be the one closest to the encoder
\index{of\_drm\_find\_bridge (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.of_drm_find_bridge}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{drm\_bridge}}} * \bfcode{of\_drm\_find\_bridge}}{struct device\_node *\emph{ np}}{}
find the bridge corresponding to the device node in the global bridge list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device\_node * np}}] \leavevmode
device node

\end{description}

\textbf{Return}

drm\_bridge control struct on success, NULL on failure


\subsection{Panel-Bridge Helper Reference}
\label{gpu/drm-kms-helpers:panel-bridge-helper-reference}\index{drm\_panel\_bridge\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_panel_bridge_add}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{drm\_bridge}}} * \bfcode{drm\_panel\_bridge\_add}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel]{\emph{drm\_panel}}} *\emph{ panel}, u32\emph{ connector\_type}}{}
Creates a drm\_bridge and drm\_connector that just calls the appropriate functions from drm\_panel.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_panel * panel}}] \leavevmode
The drm\_panel being wrapped.  Must be non-NULL.

\item[{\code{u32 connector\_type}}] \leavevmode
The DRM\_MODE\_CONNECTOR\_* for the connector to be
created.

\end{description}

\textbf{Description}

For drivers converting from directly using drm\_panel: The expected
usage pattern is that during either encoder module probe or DSI
host attach, a drm\_panel will be looked up through
\code{drm\_of\_find\_panel\_or\_bridge()}.  {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel_bridge_add]{\emph{\code{drm\_panel\_bridge\_add()}}}} is used to
wrap that panel in the new bridge, and the result can then be
passed to {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge_attach]{\emph{\code{drm\_bridge\_attach()}}}}.  The {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel_prepare]{\emph{\code{drm\_panel\_prepare()}}}} and related
functions can be dropped from the encoder driver (they're now
called by the KMS helpers before calling into the encoder), along
with connector creation.  When done with the bridge,
\code{drm\_bridge\_detach()} should be called as normal, then
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel_bridge_remove]{\emph{\code{drm\_panel\_bridge\_remove()}}}} to free it.
\index{drm\_panel\_bridge\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_panel_bridge_remove}\pysiglinewithargsret{void \bfcode{drm\_panel\_bridge\_remove}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge]{\emph{drm\_bridge}}} *\emph{ bridge}}{}
Unregisters and frees a drm\_bridge created by {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel_bridge_add]{\emph{\code{drm\_panel\_bridge\_add()}}}}.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_bridge * bridge}}] \leavevmode
The drm\_bridge being freed.

\end{description}


\section{Panel Helper Reference}
\label{gpu/drm-kms-helpers:drm-panel-helper}\label{gpu/drm-kms-helpers:panel-helper-reference}
The DRM panel helpers allow drivers to register panel objects with a
central registry and provide functions to retrieve those panels in display
drivers.
\index{drm\_panel\_funcs (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_panel_funcs}\pysigline{struct \bfcode{drm\_panel\_funcs}}
perform operations on a given panel

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}panel\PYGZus{}funcs \PYGZob{}
  int (*disable)(struct drm\PYGZus{}panel *panel);
  int (*unprepare)(struct drm\PYGZus{}panel *panel);
  int (*prepare)(struct drm\PYGZus{}panel *panel);
  int (*enable)(struct drm\PYGZus{}panel *panel);
  int (*get\PYGZus{}modes)(struct drm\PYGZus{}panel *panel);
  int (*get\PYGZus{}timings)(struct drm\PYGZus{}panel *panel, unsigned int num\PYGZus{}timings, struct display\PYGZus{}timing *timings);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{disable}}] \leavevmode
disable panel (turn off back light, etc.)

\item[{\code{unprepare}}] \leavevmode
turn off panel

\item[{\code{prepare}}] \leavevmode
turn on panel and perform set up

\item[{\code{enable}}] \leavevmode
enable panel (turn on back light, etc.)

\item[{\code{get\_modes}}] \leavevmode
add modes to the connector that the panel is attached to and
return the number of modes added

\item[{\code{get\_timings}}] \leavevmode
copy display timings into the provided array and return
the number of display timings available

\end{description}

\textbf{Description}

The .:c:func:\emph{prepare()} function is typically called before the display controller
starts to transmit video data. Panel drivers can use this to turn the panel
on and wait for it to become ready. If additional configuration is required
(via a control bus such as I2C, SPI or DSI for example) this is a good time
to do that.

After the display controller has started transmitting video data, it's safe
to call the .:c:func:\emph{enable()} function. This will typically enable the backlight to
make the image on screen visible. Some panels require a certain amount of
time or frames before the image is displayed. This function is responsible
for taking this into account before enabling the backlight to avoid visual
glitches.

Before stopping video transmission from the display controller it can be
necessary to turn off the panel to avoid visual glitches. This is done in
the .:c:func:\emph{disable()} function. Analogously to .:c:func:\emph{enable()} this typically involves
turning off the backlight and waiting for some time to make sure no image
is visible on the panel. It is then safe for the display controller to
cease transmission of video data.

To save power when no video data is transmitted, a driver can power down
the panel. This is the job of the .:c:func:\emph{unprepare()} function.
\index{drm\_panel (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_panel}\pysigline{struct \bfcode{drm\_panel}}
DRM panel object

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}panel \PYGZob{}
  struct drm\PYGZus{}device *drm;
  struct drm\PYGZus{}connector *connector;
  struct device *dev;
  const struct drm\PYGZus{}panel\PYGZus{}funcs *funcs;
  struct list\PYGZus{}head list;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{drm}}] \leavevmode
DRM device owning the panel

\item[{\code{connector}}] \leavevmode
DRM connector that the panel is attached to

\item[{\code{dev}}] \leavevmode
parent device of the panel

\item[{\code{funcs}}] \leavevmode
operations that can be performed on the panel

\item[{\code{list}}] \leavevmode
panel entry in registry

\end{description}
\index{drm\_panel\_unprepare (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_panel_unprepare}\pysiglinewithargsret{int \bfcode{drm\_panel\_unprepare}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel]{\emph{drm\_panel}}} *\emph{ panel}}{}
power off a panel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_panel * panel}}] \leavevmode
DRM panel

\end{description}

\textbf{Description}

Calling this function will completely power off a panel (assert the panel's
reset, turn off power supplies, ...). After this function has completed, it
is usually no longer possible to communicate with the panel until another
call to {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel_prepare]{\emph{\code{drm\_panel\_prepare()}}}}.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_panel\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_panel_disable}\pysiglinewithargsret{int \bfcode{drm\_panel\_disable}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel]{\emph{drm\_panel}}} *\emph{ panel}}{}
disable a panel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_panel * panel}}] \leavevmode
DRM panel

\end{description}

\textbf{Description}

This will typically turn off the panel's backlight or disable the display
drivers. For smart panels it should still be possible to communicate with
the integrated circuitry via any command bus after this call.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_panel\_prepare (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_panel_prepare}\pysiglinewithargsret{int \bfcode{drm\_panel\_prepare}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel]{\emph{drm\_panel}}} *\emph{ panel}}{}
power on a panel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_panel * panel}}] \leavevmode
DRM panel

\end{description}

\textbf{Description}

Calling this function will enable power and deassert any reset signals to
the panel. After this has completed it is possible to communicate with any
integrated circuitry via a command bus.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_panel\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_panel_enable}\pysiglinewithargsret{int \bfcode{drm\_panel\_enable}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel]{\emph{drm\_panel}}} *\emph{ panel}}{}
enable a panel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_panel * panel}}] \leavevmode
DRM panel

\end{description}

\textbf{Description}

Calling this function will cause the panel display drivers to be turned on
and the backlight to be enabled. Content will be visible on screen after
this call completes.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_panel\_get\_modes (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_panel_get_modes}\pysiglinewithargsret{int \bfcode{drm\_panel\_get\_modes}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel]{\emph{drm\_panel}}} *\emph{ panel}}{}
probe the available display modes of a panel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_panel * panel}}] \leavevmode
DRM panel

\end{description}

\textbf{Description}

The modes probed from the panel are automatically added to the connector
that the panel is attached to.

\textbf{Return}

The number of modes available from the panel on success or a
negative error code on failure.
\index{drm\_panel\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_panel_init}\pysiglinewithargsret{void \bfcode{drm\_panel\_init}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel]{\emph{drm\_panel}}} *\emph{ panel}}{}
initialize a panel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_panel * panel}}] \leavevmode
DRM panel

\end{description}

\textbf{Description}

Sets up internal fields of the panel so that it can subsequently be added
to the registry.
\index{drm\_panel\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_panel_add}\pysiglinewithargsret{int \bfcode{drm\_panel\_add}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel]{\emph{drm\_panel}}} *\emph{ panel}}{}
add a panel to the global registry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_panel * panel}}] \leavevmode
panel to add

\end{description}

\textbf{Description}

Add a panel to the global registry so that it can be looked up by display
drivers.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_panel\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_panel_remove}\pysiglinewithargsret{void \bfcode{drm\_panel\_remove}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel]{\emph{drm\_panel}}} *\emph{ panel}}{}
remove a panel from the global registry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_panel * panel}}] \leavevmode
DRM panel

\end{description}

\textbf{Description}

Removes a panel from the global registry.
\index{drm\_panel\_attach (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_panel_attach}\pysiglinewithargsret{int \bfcode{drm\_panel\_attach}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel]{\emph{drm\_panel}}} *\emph{ panel}, struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}}{}
attach a panel to a connector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_panel * panel}}] \leavevmode
DRM panel

\item[{\code{struct drm\_connector * connector}}] \leavevmode
DRM connector

\end{description}

\textbf{Description}

After obtaining a pointer to a DRM panel a display driver calls this
function to attach a panel to a connector.

An error is returned if the panel is already attached to another connector.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_panel\_detach (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_panel_detach}\pysiglinewithargsret{int \bfcode{drm\_panel\_detach}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel]{\emph{drm\_panel}}} *\emph{ panel}}{}
detach a panel from a connector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_panel * panel}}] \leavevmode
DRM panel

\end{description}

\textbf{Description}

Detaches a panel from the connector it is attached to. If a panel is not
attached to any connector this is effectively a no-op.

\textbf{Return}

0 on success or a negative error code on failure.
\index{of\_drm\_find\_panel (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.of_drm_find_panel}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_panel]{\emph{drm\_panel}}} * \bfcode{of\_drm\_find\_panel}}{const struct device\_node *\emph{ np}}{}
look up a panel using a device tree node

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct device\_node * np}}] \leavevmode
device tree node of the panel

\end{description}

\textbf{Description}

Searches the set of registered panels for one that matches the given device
tree node. If a matching panel is found, return a pointer to it.

\textbf{Return}

A pointer to the panel registered for the specified device tree
node or NULL if no panel matching the device tree node can be found.
\index{drm\_get\_panel\_orientation\_quirk (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_get_panel_orientation_quirk}\pysiglinewithargsret{int \bfcode{drm\_get\_panel\_orientation\_quirk}}{int\emph{ width}, int\emph{ height}}{}
Check for panel orientation quirks

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int width}}] \leavevmode
width in pixels of the panel

\item[{\code{int height}}] \leavevmode
height in pixels of the panel

\end{description}

\textbf{Description}

This function checks for platform specific (e.g. DMI based) quirks
providing info on panel\_orientation for systems where this cannot be
probed from the hard-/firm-ware. To avoid false-positive this function
takes the panel resolution as argument and checks that against the
resolution expected by the quirk-table entry.

Note this function is also used outside of the drm-subsys, by for example
the efifb code. Because of this this function gets compiled into its own
kernel-module when built as a module.

\textbf{Return}

A DRM\_MODE\_PANEL\_ORIENTATION\_* value if there is a quirk for this system,
or DRM\_MODE\_PANEL\_ORIENTATION\_UNKNOWN if there is no quirk.


\section{Display Port Helper Functions Reference}
\label{gpu/drm-kms-helpers:display-port-helper-functions-reference}
These functions contain some common logic and helpers at various abstraction
levels to deal with Display Port sink devices and related things like DP aux
channel transfers, EDID reading over DP aux channels, decoding certain DPCD
blocks, ...

The DisplayPort AUX channel is an abstraction to allow generic, driver-
independent access to AUX functionality. Drivers can take advantage of
this by filling in the fields of the drm\_dp\_aux structure.

Transactions are described using a hardware-independent drm\_dp\_aux\_msg
structure, which is passed into a driver's .:c:func:\emph{transfer()} implementation.
Both native and I2C-over-AUX transactions are supported.
\index{drm\_dp\_aux\_msg (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_aux_msg}\pysigline{struct \bfcode{drm\_dp\_aux\_msg}}
DisplayPort AUX channel transaction

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}dp\PYGZus{}aux\PYGZus{}msg \PYGZob{}
  unsigned int address;
  u8 request;
  u8 reply;
  void *buffer;
  size\PYGZus{}t size;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{address}}] \leavevmode
address of the (first) register to access

\item[{\code{request}}] \leavevmode
contains the type of transaction (see DP\_AUX\_* macros)

\item[{\code{reply}}] \leavevmode
upon completion, contains the reply type of the transaction

\item[{\code{buffer}}] \leavevmode
pointer to a transmission or reception buffer

\item[{\code{size}}] \leavevmode
size of \textbf{buffer}

\end{description}
\index{drm\_dp\_aux (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_aux}\pysigline{struct \bfcode{drm\_dp\_aux}}
DisplayPort AUX channel

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}dp\PYGZus{}aux \PYGZob{}
  const char *name;
  struct i2c\PYGZus{}adapter ddc;
  struct device *dev;
  struct drm\PYGZus{}crtc *crtc;
  struct mutex hw\PYGZus{}mutex;
  struct work\PYGZus{}struct crc\PYGZus{}work;
  u8 crc\PYGZus{}count;
  ssize\PYGZus{}t (*transfer)(struct drm\PYGZus{}dp\PYGZus{}aux *aux, struct drm\PYGZus{}dp\PYGZus{}aux\PYGZus{}msg *msg);
  unsigned i2c\PYGZus{}nack\PYGZus{}count;
  unsigned i2c\PYGZus{}defer\PYGZus{}count;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
user-visible name of this AUX channel and the I2C-over-AUX adapter

\item[{\code{ddc}}] \leavevmode
I2C adapter that can be used for I2C-over-AUX communication

\item[{\code{dev}}] \leavevmode
pointer to struct device that is the parent for this AUX channel

\item[{\code{crtc}}] \leavevmode
backpointer to the crtc that is currently using this AUX channel

\item[{\code{hw\_mutex}}] \leavevmode
internal mutex used for locking transfers

\item[{\code{crc\_work}}] \leavevmode
worker that captures CRCs for each frame

\item[{\code{crc\_count}}] \leavevmode
counter of captured frame CRCs

\item[{\code{transfer}}] \leavevmode
transfers a message representing a single AUX transaction

\item[{\code{i2c\_nack\_count}}] \leavevmode
Counts I2C NACKs, used for DP validation.

\item[{\code{i2c\_defer\_count}}] \leavevmode
Counts I2C DEFERs, used for DP validation.

\end{description}

\textbf{Description}

The .dev field should be set to a pointer to the device that implements
the AUX channel.

The .name field may be used to specify the name of the I2C adapter. If set to
NULL, \code{dev\_name()} of .dev will be used.

Drivers provide a hardware-specific implementation of how transactions
are executed via the .:c:func:\emph{transfer()} function. A pointer to a drm\_dp\_aux\_msg
structure describing the transaction is passed into this function. Upon
success, the implementation should return the number of payload bytes
that were transferred, or a negative error-code on failure. Helpers
propagate errors from the .:c:func:\emph{transfer()} function, with the exception of
the -EBUSY error, which causes a transaction to be retried. On a short,
helpers will return -EPROTO to make it simpler to check for failure.

An AUX channel can also be used to transport I2C messages to a sink. A
typical application of that is to access an EDID that's present in the
sink device. The .:c:func:\emph{transfer()} function can also be used to execute such
transactions. The {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux_register]{\emph{\code{drm\_dp\_aux\_register()}}}} function registers an I2C
adapter that can be passed to {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_probe_ddc]{\emph{\code{drm\_probe\_ddc()}}}}. Upon removal, drivers
should call {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux_unregister]{\emph{\code{drm\_dp\_aux\_unregister()}}}} to remove the I2C adapter.
The I2C adapter uses long transfers by default; if a partial response is
received, the adapter will drop down to the size given by the partial
response for this transaction only.

Note that the aux helper code assumes that the .:c:func:\emph{transfer()} function
only modifies the reply field of the drm\_dp\_aux\_msg structure.  The
retry logic and i2c helpers assume this is the case.
\index{drm\_dp\_dpcd\_readb (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_dpcd_readb}\pysiglinewithargsret{ssize\_t \bfcode{drm\_dp\_dpcd\_readb}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}, unsigned int\emph{ offset}, u8 *\emph{ valuep}}{}
read a single byte from the DPCD

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DisplayPort AUX channel

\item[{\code{unsigned int offset}}] \leavevmode
address of the register to read

\item[{\code{u8 * valuep}}] \leavevmode
location where the value of the register will be stored

\end{description}

\textbf{Description}

Returns the number of bytes transferred (1) on success, or a negative
error code on failure.
\index{drm\_dp\_dpcd\_writeb (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_dpcd_writeb}\pysiglinewithargsret{ssize\_t \bfcode{drm\_dp\_dpcd\_writeb}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}, unsigned int\emph{ offset}, u8\emph{ value}}{}
write a single byte to the DPCD

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DisplayPort AUX channel

\item[{\code{unsigned int offset}}] \leavevmode
address of the register to write

\item[{\code{u8 value}}] \leavevmode
value to write to the register

\end{description}

\textbf{Description}

Returns the number of bytes transferred (1) on success, or a negative
error code on failure.
\index{drm\_dp\_desc (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_desc}\pysigline{struct \bfcode{drm\_dp\_desc}}
DP branch/sink device descriptor

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}dp\PYGZus{}desc \PYGZob{}
  struct drm\PYGZus{}dp\PYGZus{}dpcd\PYGZus{}ident ident;
  u32 quirks;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{ident}}] \leavevmode
DP device identification from DPCD 0x400 (sink) or 0x500 (branch).

\item[{\code{quirks}}] \leavevmode
Quirks; use {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_has_quirk]{\emph{\code{drm\_dp\_has\_quirk()}}}} to query for the quirks.

\end{description}
\index{drm\_dp\_quirk (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_quirk}\pysigline{enum \bfcode{drm\_dp\_quirk}}
Display Port sink/branch device specific quirks

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{DP\_DPCD\_QUIRK\_LIMITED\_M\_N}}] \leavevmode
The device requires main link attributes Mvid and Nvid to be limited
to 16 bits.

\end{description}

\textbf{Description}

Display Port sink and branch devices in the wild have a variety of bugs, try
to collect them here. The quirks are shared, but it's up to the drivers to
implement workarounds for them.
\index{drm\_dp\_has\_quirk (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_has_quirk}\pysiglinewithargsret{bool \bfcode{drm\_dp\_has\_quirk}}{const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_desc]{\emph{drm\_dp\_desc}}} *\emph{ desc}, enum {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_quirk]{\emph{drm\_dp\_quirk}}}\emph{ quirk}}{}
does the DP device have a specific quirk

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_dp\_desc * desc}}] \leavevmode
Device decriptor filled by {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_read_desc]{\emph{\code{drm\_dp\_read\_desc()}}}}

\item[{\code{enum drm\_dp\_quirk quirk}}] \leavevmode
Quirk to query for

\end{description}

\textbf{Description}

Return true if DP device identified by \textbf{desc} has \textbf{quirk}.
\index{drm\_dp\_dpcd\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_dpcd_read}\pysiglinewithargsret{ssize\_t \bfcode{drm\_dp\_dpcd\_read}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}, unsigned int\emph{ offset}, void *\emph{ buffer}, size\_t\emph{ size}}{}
read a series of bytes from the DPCD

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DisplayPort AUX channel

\item[{\code{unsigned int offset}}] \leavevmode
address of the (first) register to read

\item[{\code{void * buffer}}] \leavevmode
buffer to store the register values

\item[{\code{size\_t size}}] \leavevmode
number of bytes in \textbf{buffer}

\end{description}

\textbf{Description}

Returns the number of bytes transferred on success, or a negative error
code on failure. -EIO is returned if the request was NAKed by the sink or
if the retry count was exceeded. If not all bytes were transferred, this
function returns -EPROTO. Errors from the underlying AUX channel transfer
function, with the exception of -EBUSY (which causes the transaction to
be retried), are propagated to the caller.
\index{drm\_dp\_dpcd\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_dpcd_write}\pysiglinewithargsret{ssize\_t \bfcode{drm\_dp\_dpcd\_write}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}, unsigned int\emph{ offset}, void *\emph{ buffer}, size\_t\emph{ size}}{}
write a series of bytes to the DPCD

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DisplayPort AUX channel

\item[{\code{unsigned int offset}}] \leavevmode
address of the (first) register to write

\item[{\code{void * buffer}}] \leavevmode
buffer containing the values to write

\item[{\code{size\_t size}}] \leavevmode
number of bytes in \textbf{buffer}

\end{description}

\textbf{Description}

Returns the number of bytes transferred on success, or a negative error
code on failure. -EIO is returned if the request was NAKed by the sink or
if the retry count was exceeded. If not all bytes were transferred, this
function returns -EPROTO. Errors from the underlying AUX channel transfer
function, with the exception of -EBUSY (which causes the transaction to
be retried), are propagated to the caller.
\index{drm\_dp\_dpcd\_read\_link\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_dpcd_read_link_status}\pysiglinewithargsret{int \bfcode{drm\_dp\_dpcd\_read\_link\_status}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}, u8\emph{ status}}{}
read DPCD link status (bytes 0x202-0x207)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DisplayPort AUX channel

\item[{\code{u8 status}}] \leavevmode
buffer to store the link status in (must be at least 6 bytes)

\end{description}

\textbf{Description}

Returns the number of bytes transferred on success or a negative error
code on failure.
\index{drm\_dp\_link\_probe (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_link_probe}\pysiglinewithargsret{int \bfcode{drm\_dp\_link\_probe}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}, struct drm\_dp\_link *\emph{ link}}{}
probe a DisplayPort link for capabilities

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DisplayPort AUX channel

\item[{\code{struct drm\_dp\_link * link}}] \leavevmode
pointer to structure in which to return link capabilities

\end{description}

\textbf{Description}

The structure filled in by this function can usually be passed directly
into {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_link_power_up]{\emph{\code{drm\_dp\_link\_power\_up()}}}} and {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_link_configure]{\emph{\code{drm\_dp\_link\_configure()}}}} to power up and
configure the link based on the link's capabilities.

Returns 0 on success or a negative error code on failure.
\index{drm\_dp\_link\_power\_up (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_link_power_up}\pysiglinewithargsret{int \bfcode{drm\_dp\_link\_power\_up}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}, struct drm\_dp\_link *\emph{ link}}{}
power up a DisplayPort link

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DisplayPort AUX channel

\item[{\code{struct drm\_dp\_link * link}}] \leavevmode
pointer to a structure containing the link configuration

\end{description}

\textbf{Description}

Returns 0 on success or a negative error code on failure.
\index{drm\_dp\_link\_power\_down (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_link_power_down}\pysiglinewithargsret{int \bfcode{drm\_dp\_link\_power\_down}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}, struct drm\_dp\_link *\emph{ link}}{}
power down a DisplayPort link

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DisplayPort AUX channel

\item[{\code{struct drm\_dp\_link * link}}] \leavevmode
pointer to a structure containing the link configuration

\end{description}

\textbf{Description}

Returns 0 on success or a negative error code on failure.
\index{drm\_dp\_link\_configure (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_link_configure}\pysiglinewithargsret{int \bfcode{drm\_dp\_link\_configure}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}, struct drm\_dp\_link *\emph{ link}}{}
configure a DisplayPort link

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DisplayPort AUX channel

\item[{\code{struct drm\_dp\_link * link}}] \leavevmode
pointer to a structure containing the link configuration

\end{description}

\textbf{Description}

Returns 0 on success or a negative error code on failure.
\index{drm\_dp\_downstream\_max\_clock (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_downstream_max_clock}\pysiglinewithargsret{int \bfcode{drm\_dp\_downstream\_max\_clock}}{const u8\emph{ dpcd}, const u8\emph{ port\_cap}}{}
extract branch device max pixel rate for legacy VGA converter or max TMDS clock rate for others

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 dpcd}}] \leavevmode
DisplayPort configuration data

\item[{\code{const u8 port\_cap}}] \leavevmode
port capabilities

\end{description}

\textbf{Description}

Returns max clock in kHz on success or 0 if max clock not defined
\index{drm\_dp\_downstream\_max\_bpc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_downstream_max_bpc}\pysiglinewithargsret{int \bfcode{drm\_dp\_downstream\_max\_bpc}}{const u8\emph{ dpcd}, const u8\emph{ port\_cap}}{}
extract branch device max bits per component

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 dpcd}}] \leavevmode
DisplayPort configuration data

\item[{\code{const u8 port\_cap}}] \leavevmode
port capabilities

\end{description}

\textbf{Description}

Returns max bpc on success or 0 if max bpc not defined
\index{drm\_dp\_downstream\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_downstream_id}\pysiglinewithargsret{int \bfcode{drm\_dp\_downstream\_id}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}, char\emph{ id}}{}
identify branch device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DisplayPort AUX channel

\item[{\code{char id}}] \leavevmode
DisplayPort branch device id

\end{description}

\textbf{Description}

Returns branch device id on success or NULL on failure
\index{drm\_dp\_downstream\_debug (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_downstream_debug}\pysiglinewithargsret{void \bfcode{drm\_dp\_downstream\_debug}}{struct seq\_file *\emph{ m}, const u8\emph{ dpcd}, const u8\emph{ port\_cap}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}}{}
debug DP branch devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct seq\_file * m}}] \leavevmode
pointer for debugfs file

\item[{\code{const u8 dpcd}}] \leavevmode
DisplayPort configuration data

\item[{\code{const u8 port\_cap}}] \leavevmode
port capabilities

\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DisplayPort AUX channel

\end{description}
\index{drm\_dp\_aux\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_aux_init}\pysiglinewithargsret{void \bfcode{drm\_dp\_aux\_init}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}}{}
minimally initialise an aux channel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DisplayPort AUX channel

\end{description}

\textbf{Description}

If you need to use the drm\_dp\_aux's i2c adapter prior to registering it
with the outside world, call {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux_init]{\emph{\code{drm\_dp\_aux\_init()}}}} first. You must still
call {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux_register]{\emph{\code{drm\_dp\_aux\_register()}}}} once the connector has been registered to
allow userspace access to the auxiliary DP channel.
\index{drm\_dp\_aux\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_aux_register}\pysiglinewithargsret{int \bfcode{drm\_dp\_aux\_register}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}}{}
initialise and register aux channel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DisplayPort AUX channel

\end{description}

\textbf{Description}

Automatically calls {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux_init]{\emph{\code{drm\_dp\_aux\_init()}}}} if this hasn't been done yet.

Returns 0 on success or a negative error code on failure.
\index{drm\_dp\_aux\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_aux_unregister}\pysiglinewithargsret{void \bfcode{drm\_dp\_aux\_unregister}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}}{}
unregister an AUX adapter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DisplayPort AUX channel

\end{description}
\index{drm\_dp\_psr\_setup\_time (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_psr_setup_time}\pysiglinewithargsret{int \bfcode{drm\_dp\_psr\_setup\_time}}{const u8\emph{ psr\_cap}}{}
PSR setup in time usec

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 psr\_cap}}] \leavevmode
PSR capabilities from DPCD

\end{description}

\textbf{Return}

PSR setup time for the panel in microseconds,  negative
error code on failure.
\index{drm\_dp\_start\_crc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_start_crc}\pysiglinewithargsret{int \bfcode{drm\_dp\_start\_crc}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
start capture of frame CRCs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DisplayPort AUX channel

\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
CRTC displaying the frames whose CRCs are to be captured

\end{description}

\textbf{Description}

Returns 0 on success or a negative error code on failure.
\index{drm\_dp\_stop\_crc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_stop_crc}\pysiglinewithargsret{int \bfcode{drm\_dp\_stop\_crc}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}}{}
stop capture of frame CRCs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DisplayPort AUX channel

\end{description}

\textbf{Description}

Returns 0 on success or a negative error code on failure.
\index{drm\_dp\_read\_desc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_read_desc}\pysiglinewithargsret{int \bfcode{drm\_dp\_read\_desc}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_desc]{\emph{drm\_dp\_desc}}} *\emph{ desc}, bool\emph{ is\_branch}}{}
read sink/branch descriptor from DPCD

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DisplayPort AUX channel

\item[{\code{struct drm\_dp\_desc * desc}}] \leavevmode
Device decriptor to fill from DPCD

\item[{\code{bool is\_branch}}] \leavevmode
true for branch devices, false for sink devices

\end{description}

\textbf{Description}

Read DPCD 0x400 (sink) or 0x500 (branch) into \textbf{desc}. Also debug log the
identification.

Returns 0 on success or a negative error code on failure.


\section{Display Port Dual Mode Adaptor Helper Functions Reference}
\label{gpu/drm-kms-helpers:display-port-dual-mode-adaptor-helper-functions-reference}
Helper functions to deal with DP dual mode (aka. DP++) adaptors.

Type 1:
Adaptor registers (if any) and the sink DDC bus may be accessed via I2C.

Type 2:
Adaptor registers and sink DDC bus can be accessed either via I2C or
I2C-over-AUX. Source devices may choose to implement either of these
access methods.
\index{drm\_lspcon\_mode (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_lspcon_mode}\pysigline{enum \bfcode{drm\_lspcon\_mode}}
\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{DRM\_LSPCON\_MODE\_INVALID}}] \leavevmode
No LSPCON.

\item[{\code{DRM\_LSPCON\_MODE\_LS}}] \leavevmode
Level shifter mode of LSPCON
which drives DP++ to HDMI 1.4 conversion.

\item[{\code{DRM\_LSPCON\_MODE\_PCON}}] \leavevmode
Protocol converter mode of LSPCON
which drives DP++ to HDMI 2.0 active conversion.

\end{description}
\index{drm\_dp\_dual\_mode\_type (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_dual_mode_type}\pysigline{enum \bfcode{drm\_dp\_dual\_mode\_type}}
Type of the DP dual mode adaptor

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{DRM\_DP\_DUAL\_MODE\_NONE}}] \leavevmode
No DP dual mode adaptor

\item[{\code{DRM\_DP\_DUAL\_MODE\_UNKNOWN}}] \leavevmode
Could be either none or type 1 DVI adaptor

\item[{\code{DRM\_DP\_DUAL\_MODE\_TYPE1\_DVI}}] \leavevmode
Type 1 DVI adaptor

\item[{\code{DRM\_DP\_DUAL\_MODE\_TYPE1\_HDMI}}] \leavevmode
Type 1 HDMI adaptor

\item[{\code{DRM\_DP\_DUAL\_MODE\_TYPE2\_DVI}}] \leavevmode
Type 2 DVI adaptor

\item[{\code{DRM\_DP\_DUAL\_MODE\_TYPE2\_HDMI}}] \leavevmode
Type 2 HDMI adaptor

\item[{\code{DRM\_DP\_DUAL\_MODE\_LSPCON}}] \leavevmode
Level shifter / protocol converter

\end{description}
\index{drm\_dp\_dual\_mode\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_dual_mode_read}\pysiglinewithargsret{ssize\_t \bfcode{drm\_dp\_dual\_mode\_read}}{struct i2c\_adapter *\emph{ adapter}, u8\emph{ offset}, void *\emph{ buffer}, size\_t\emph{ size}}{}
Read from the DP dual mode adaptor register(s)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C adapter for the DDC bus

\item[{\code{u8 offset}}] \leavevmode
register offset

\item[{\code{void * buffer}}] \leavevmode
buffer for return data

\item[{\code{size\_t size}}] \leavevmode
sizo of the buffer

\end{description}

\textbf{Description}

Reads \textbf{size} bytes from the DP dual mode adaptor registers
starting at \textbf{offset}.

\textbf{Return}

0 on success, negative error code on failure
\index{drm\_dp\_dual\_mode\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_dual_mode_write}\pysiglinewithargsret{ssize\_t \bfcode{drm\_dp\_dual\_mode\_write}}{struct i2c\_adapter *\emph{ adapter}, u8\emph{ offset}, const void *\emph{ buffer}, size\_t\emph{ size}}{}
Write to the DP dual mode adaptor register(s)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C adapter for the DDC bus

\item[{\code{u8 offset}}] \leavevmode
register offset

\item[{\code{const void * buffer}}] \leavevmode
buffer for write data

\item[{\code{size\_t size}}] \leavevmode
sizo of the buffer

\end{description}

\textbf{Description}

Writes \textbf{size} bytes to the DP dual mode adaptor registers
starting at \textbf{offset}.

\textbf{Return}

0 on success, negative error code on failure
\index{drm\_dp\_dual\_mode\_detect (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_dual_mode_detect}\pysiglinewithargsret{enum {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_dual_mode_type]{\emph{drm\_dp\_dual\_mode\_type}}} \bfcode{drm\_dp\_dual\_mode\_detect}}{struct i2c\_adapter *\emph{ adapter}}{}
Identify the DP dual mode adaptor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C adapter for the DDC bus

\end{description}

\textbf{Description}

Attempt to identify the type of the DP dual mode adaptor used.

Note that when the answer is \textbf{DRM\_DP\_DUAL\_MODE\_UNKNOWN} it's not
certain whether we're dealing with a native HDMI port or
a type 1 DVI dual mode adaptor. The driver will have to use
some other hardware/driver specific mechanism to make that
distinction.

\textbf{Return}

The type of the DP dual mode adaptor used
\index{drm\_dp\_dual\_mode\_max\_tmds\_clock (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_dual_mode_max_tmds_clock}\pysiglinewithargsret{int \bfcode{drm\_dp\_dual\_mode\_max\_tmds\_clock}}{enum {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_dual_mode_type]{\emph{drm\_dp\_dual\_mode\_type}}}\emph{ type}, struct i2c\_adapter *\emph{ adapter}}{}
Max TMDS clock for DP dual mode adaptor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{enum drm\_dp\_dual\_mode\_type type}}] \leavevmode
DP dual mode adaptor type

\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C adapter for the DDC bus

\end{description}

\textbf{Description}

Determine the max TMDS clock the adaptor supports based on the
type of the dual mode adaptor and the DP\_DUAL\_MODE\_MAX\_TMDS\_CLOCK
register (on type2 adaptors). As some type 1 adaptors have
problems with registers (see comments in {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_dual_mode_detect]{\emph{\code{drm\_dp\_dual\_mode\_detect()}}}})
we don't read the register on those, instead we simply assume
a 165 MHz limit based on the specification.

\textbf{Return}

Maximum supported TMDS clock rate for the DP dual mode adaptor in kHz.
\index{drm\_dp\_dual\_mode\_get\_tmds\_output (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_dual_mode_get_tmds_output}\pysiglinewithargsret{int \bfcode{drm\_dp\_dual\_mode\_get\_tmds\_output}}{enum {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_dual_mode_type]{\emph{drm\_dp\_dual\_mode\_type}}}\emph{ type}, struct i2c\_adapter *\emph{ adapter}, bool *\emph{ enabled}}{}
Get the state of the TMDS output buffers in the DP dual mode adaptor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{enum drm\_dp\_dual\_mode\_type type}}] \leavevmode
DP dual mode adaptor type

\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C adapter for the DDC bus

\item[{\code{bool * enabled}}] \leavevmode
current state of the TMDS output buffers

\end{description}

\textbf{Description}

Get the state of the TMDS output buffers in the adaptor. For
type2 adaptors this is queried from the DP\_DUAL\_MODE\_TMDS\_OEN
register. As some type 1 adaptors have problems with registers
(see comments in {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_dual_mode_detect]{\emph{\code{drm\_dp\_dual\_mode\_detect()}}}}) we don't read the
register on those, instead we simply assume that the buffers
are always enabled.

\textbf{Return}

0 on success, negative error code on failure
\index{drm\_dp\_dual\_mode\_set\_tmds\_output (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_dual_mode_set_tmds_output}\pysiglinewithargsret{int \bfcode{drm\_dp\_dual\_mode\_set\_tmds\_output}}{enum {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_dual_mode_type]{\emph{drm\_dp\_dual\_mode\_type}}}\emph{ type}, struct i2c\_adapter *\emph{ adapter}, bool\emph{ enable}}{}
Enable/disable TMDS output buffers in the DP dual mode adaptor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{enum drm\_dp\_dual\_mode\_type type}}] \leavevmode
DP dual mode adaptor type

\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C adapter for the DDC bus

\item[{\code{bool enable}}] \leavevmode
enable (as opposed to disable) the TMDS output buffers

\end{description}

\textbf{Description}

Set the state of the TMDS output buffers in the adaptor. For
type2 this is set via the DP\_DUAL\_MODE\_TMDS\_OEN register. As
some type 1 adaptors have problems with registers (see comments
in {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_dual_mode_detect]{\emph{\code{drm\_dp\_dual\_mode\_detect()}}}}) we avoid touching the register,
making this function a no-op on type 1 adaptors.

\textbf{Return}

0 on success, negative error code on failure
\index{drm\_dp\_get\_dual\_mode\_type\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_get_dual_mode_type_name}\pysiglinewithargsret{const char * \bfcode{drm\_dp\_get\_dual\_mode\_type\_name}}{enum {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_dual_mode_type]{\emph{drm\_dp\_dual\_mode\_type}}}\emph{ type}}{}
Get the name of the DP dual mode adaptor type as a string

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{enum drm\_dp\_dual\_mode\_type type}}] \leavevmode
DP dual mode adaptor type

\end{description}

\textbf{Return}

String representation of the DP dual mode adaptor type
\index{drm\_lspcon\_get\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_lspcon_get_mode}\pysiglinewithargsret{int \bfcode{drm\_lspcon\_get\_mode}}{struct i2c\_adapter *\emph{ adapter}, enum {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_lspcon_mode]{\emph{drm\_lspcon\_mode}}} *\emph{ mode}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C-over-aux adapter

\item[{\code{enum drm\_lspcon\_mode * mode}}] \leavevmode
current lspcon mode of operation output variable

\end{description}

\textbf{Description}

reading offset (0x80, 0x41)

\textbf{Return}

0 on success, sets the current\_mode value to appropriate mode
-error on failure
\index{drm\_lspcon\_set\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_lspcon_set_mode}\pysiglinewithargsret{int \bfcode{drm\_lspcon\_set\_mode}}{struct i2c\_adapter *\emph{ adapter}, enum {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_lspcon_mode]{\emph{drm\_lspcon\_mode}}}\emph{ mode}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C-over-aux adapter

\item[{\code{enum drm\_lspcon\_mode mode}}] \leavevmode
required mode of operation

\end{description}

\textbf{Description}

writing offset (0x80, 0x40)

\textbf{Return}

0 on success, -error on failure/timeout


\section{Display Port MST Helper Functions Reference}
\label{gpu/drm-kms-helpers:display-port-mst-helper-functions-reference}
These functions contain parts of the DisplayPort 1.2a MultiStream Transport
protocol. The helpers contain a topology manager and bandwidth manager.
The helpers encapsulate the sending and received of sideband msgs.
\index{drm\_dp\_vcpi (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_vcpi}\pysigline{struct \bfcode{drm\_dp\_vcpi}}
Virtual Channel Payload Identifier

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}dp\PYGZus{}vcpi \PYGZob{}
  int vcpi;
  int pbn;
  int aligned\PYGZus{}pbn;
  int num\PYGZus{}slots;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{vcpi}}] \leavevmode
Virtual channel ID.

\item[{\code{pbn}}] \leavevmode
Payload Bandwidth Number for this channel

\item[{\code{aligned\_pbn}}] \leavevmode
PBN aligned with slot size

\item[{\code{num\_slots}}] \leavevmode
number of slots for this PBN

\end{description}
\index{drm\_dp\_mst\_port (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_mst_port}\pysigline{struct \bfcode{drm\_dp\_mst\_port}}
MST port

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}dp\PYGZus{}mst\PYGZus{}port \PYGZob{}
  struct kref kref;
  u8 port\PYGZus{}num;
  bool input;
  bool mcs;
  bool ddps;
  u8 pdt;
  bool ldps;
  u8 dpcd\PYGZus{}rev;
  u8 num\PYGZus{}sdp\PYGZus{}streams;
  u8 num\PYGZus{}sdp\PYGZus{}stream\PYGZus{}sinks;
  uint16\PYGZus{}t available\PYGZus{}pbn;
  struct list\PYGZus{}head next;
  struct drm\PYGZus{}dp\PYGZus{}mst\PYGZus{}branch *mstb;
  struct drm\PYGZus{}dp\PYGZus{}aux aux;
  struct drm\PYGZus{}dp\PYGZus{}mst\PYGZus{}branch *parent;
  struct drm\PYGZus{}dp\PYGZus{}vcpi vcpi;
  struct drm\PYGZus{}connector *connector;
  struct drm\PYGZus{}dp\PYGZus{}mst\PYGZus{}topology\PYGZus{}mgr *mgr;
  struct edid *cached\PYGZus{}edid;
  bool has\PYGZus{}audio;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{kref}}] \leavevmode
reference count for this port.

\item[{\code{port\_num}}] \leavevmode
port number

\item[{\code{input}}] \leavevmode
if this port is an input port.

\item[{\code{mcs}}] \leavevmode
message capability status - DP 1.2 spec.

\item[{\code{ddps}}] \leavevmode
DisplayPort Device Plug Status - DP 1.2

\item[{\code{pdt}}] \leavevmode
Peer Device Type

\item[{\code{ldps}}] \leavevmode
Legacy Device Plug Status

\item[{\code{dpcd\_rev}}] \leavevmode
DPCD revision of device on this port

\item[{\code{num\_sdp\_streams}}] \leavevmode
Number of simultaneous streams

\item[{\code{num\_sdp\_stream\_sinks}}] \leavevmode
Number of stream sinks

\item[{\code{available\_pbn}}] \leavevmode
Available bandwidth for this port.

\item[{\code{next}}] \leavevmode
link to next port on this branch device

\item[{\code{mstb}}] \leavevmode
branch device attach below this port

\item[{\code{aux}}] \leavevmode
i2c aux transport to talk to device connected to this port.

\item[{\code{parent}}] \leavevmode
branch device parent of this port

\item[{\code{vcpi}}] \leavevmode
Virtual Channel Payload info for this port.

\item[{\code{connector}}] \leavevmode
DRM connector this port is connected to.

\item[{\code{mgr}}] \leavevmode
topology manager this port lives under.

\item[{\code{cached\_edid}}] \leavevmode
for DP logical ports - make tiling work by ensuring
that the EDID for all connectors is read immediately.

\item[{\code{has\_audio}}] \leavevmode
Tracks whether the sink connector to this port is
audio-capable.

\end{description}

\textbf{Description}

This structure represents an MST port endpoint on a device somewhere
in the MST topology.
\index{drm\_dp\_mst\_branch (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_mst_branch}\pysigline{struct \bfcode{drm\_dp\_mst\_branch}}
MST branch device.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}dp\PYGZus{}mst\PYGZus{}branch \PYGZob{}
  struct kref kref;
  u8 rad[8];
  u8 lct;
  int num\PYGZus{}ports;
  int msg\PYGZus{}slots;
  struct list\PYGZus{}head ports;
  struct drm\PYGZus{}dp\PYGZus{}mst\PYGZus{}port *port\PYGZus{}parent;
  struct drm\PYGZus{}dp\PYGZus{}mst\PYGZus{}topology\PYGZus{}mgr *mgr;
  struct drm\PYGZus{}dp\PYGZus{}sideband\PYGZus{}msg\PYGZus{}tx *tx\PYGZus{}slots[2];
  int last\PYGZus{}seqno;
  bool link\PYGZus{}address\PYGZus{}sent;
  u8 guid[16];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{kref}}] \leavevmode
reference count for this port.

\item[{\code{rad}}] \leavevmode
Relative Address to talk to this branch device.

\item[{\code{lct}}] \leavevmode
Link count total to talk to this branch device.

\item[{\code{num\_ports}}] \leavevmode
number of ports on the branch.

\item[{\code{msg\_slots}}] \leavevmode
one bit per transmitted msg slot.

\item[{\code{ports}}] \leavevmode
linked list of ports on this branch.

\item[{\code{port\_parent}}] \leavevmode
pointer to the port parent, NULL if toplevel.

\item[{\code{mgr}}] \leavevmode
topology manager for this branch device.

\item[{\code{tx\_slots}}] \leavevmode
transmission slots for this device.

\item[{\code{last\_seqno}}] \leavevmode
last sequence number used to talk to this.

\item[{\code{link\_address\_sent}}] \leavevmode
if a link address message has been sent to this device yet.

\item[{\code{guid}}] \leavevmode
guid for DP 1.2 branch device. port under this branch can be
identified by port \#.

\end{description}

\textbf{Description}

This structure represents an MST branch device, there is one
primary branch device at the root, along with any other branches connected
to downstream port of parent branches.
\index{drm\_dp\_mst\_topology\_mgr (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_mst_topology_mgr}\pysigline{struct \bfcode{drm\_dp\_mst\_topology\_mgr}}
DisplayPort MST manager

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}dp\PYGZus{}mst\PYGZus{}topology\PYGZus{}mgr \PYGZob{}
  struct drm\PYGZus{}private\PYGZus{}obj base;
  struct drm\PYGZus{}device *dev;
  const struct drm\PYGZus{}dp\PYGZus{}mst\PYGZus{}topology\PYGZus{}cbs *cbs;
  int max\PYGZus{}dpcd\PYGZus{}transaction\PYGZus{}bytes;
  struct drm\PYGZus{}dp\PYGZus{}aux *aux;
  int max\PYGZus{}payloads;
  int conn\PYGZus{}base\PYGZus{}id;
  struct drm\PYGZus{}dp\PYGZus{}sideband\PYGZus{}msg\PYGZus{}rx down\PYGZus{}rep\PYGZus{}recv;
  struct drm\PYGZus{}dp\PYGZus{}sideband\PYGZus{}msg\PYGZus{}rx up\PYGZus{}req\PYGZus{}recv;
  struct mutex lock;
  bool mst\PYGZus{}state;
  struct drm\PYGZus{}dp\PYGZus{}mst\PYGZus{}branch *mst\PYGZus{}primary;
  u8 dpcd[DP\PYGZus{}RECEIVER\PYGZus{}CAP\PYGZus{}SIZE];
  u8 sink\PYGZus{}count;
  int pbn\PYGZus{}div;
  struct drm\PYGZus{}dp\PYGZus{}mst\PYGZus{}topology\PYGZus{}state *state;
  const struct drm\PYGZus{}private\PYGZus{}state\PYGZus{}funcs *funcs;
  struct mutex qlock;
  struct list\PYGZus{}head tx\PYGZus{}msg\PYGZus{}downq;
  struct mutex payload\PYGZus{}lock;
  struct drm\PYGZus{}dp\PYGZus{}vcpi **proposed\PYGZus{}vcpis;
  struct drm\PYGZus{}dp\PYGZus{}payload *payloads;
  unsigned long payload\PYGZus{}mask;
  unsigned long vcpi\PYGZus{}mask;
  wait\PYGZus{}queue\PYGZus{}head\PYGZus{}t tx\PYGZus{}waitq;
  struct work\PYGZus{}struct work;
  struct work\PYGZus{}struct tx\PYGZus{}work;
  struct list\PYGZus{}head destroy\PYGZus{}connector\PYGZus{}list;
  struct mutex destroy\PYGZus{}connector\PYGZus{}lock;
  struct work\PYGZus{}struct destroy\PYGZus{}connector\PYGZus{}work;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{base}}] \leavevmode
Base private object for atomic

\item[{\code{dev}}] \leavevmode
device pointer for adding i2c devices etc.

\item[{\code{cbs}}] \leavevmode
callbacks for connector addition and destruction.

\item[{\code{max\_dpcd\_transaction\_bytes}}] \leavevmode
maximum number of bytes to read/write
in one go.

\item[{\code{aux}}] \leavevmode
AUX channel for the DP MST connector this topolgy mgr is
controlling.

\item[{\code{max\_payloads}}] \leavevmode
maximum number of payloads the GPU can generate.

\item[{\code{conn\_base\_id}}] \leavevmode
DRM connector ID this mgr is connected to. Only used
to build the MST connector path value.

\item[{\code{down\_rep\_recv}}] \leavevmode
Message receiver state for down replies. This and
\textbf{up\_req\_recv} are only ever access from the work item, which is
serialised.

\item[{\code{up\_req\_recv}}] \leavevmode
Message receiver state for up requests. This and
\textbf{down\_rep\_recv} are only ever access from the work item, which is
serialised.

\item[{\code{lock}}] \leavevmode
protects mst state, primary, dpcd.

\item[{\code{mst\_state}}] \leavevmode
If this manager is enabled for an MST capable port. False
if no MST sink/branch devices is connected.

\item[{\code{mst\_primary}}] \leavevmode
Pointer to the primary/first branch device.

\item[{\code{dpcd}}] \leavevmode
Cache of DPCD for primary port.

\item[{\code{sink\_count}}] \leavevmode
Sink count from DEVICE\_SERVICE\_IRQ\_VECTOR\_ESI0.

\item[{\code{pbn\_div}}] \leavevmode
PBN to slots divisor.

\item[{\code{state}}] \leavevmode
State information for topology manager

\item[{\code{funcs}}] \leavevmode
Atomic helper callbacks

\item[{\code{qlock}}] \leavevmode
protects \textbf{tx\_msg\_downq}, the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_branch]{\emph{\code{drm\_dp\_mst\_branch.txslost}}}} and
\code{drm\_dp\_sideband\_msg\_tx.state} once they are queued

\item[{\code{tx\_msg\_downq}}] \leavevmode
List of pending down replies.

\item[{\code{payload\_lock}}] \leavevmode
Protect payload information.

\item[{\code{proposed\_vcpis}}] \leavevmode
Array of pointers for the new VCPI allocation. The
VCPI structure itself is {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_port]{\emph{\code{drm\_dp\_mst\_port.vcpi}}}}.

\item[{\code{payloads}}] \leavevmode
Array of payloads.

\item[{\code{payload\_mask}}] \leavevmode
Elements of \textbf{payloads} actually in use. Since
reallocation of active outputs isn't possible gaps can be created by
disabling outputs out of order compared to how they've been enabled.

\item[{\code{vcpi\_mask}}] \leavevmode
Similar to \textbf{payload\_mask}, but for \textbf{proposed\_vcpis}.

\item[{\code{tx\_waitq}}] \leavevmode
Wait to queue stall for the tx worker.

\item[{\code{work}}] \leavevmode
Probe work.

\item[{\code{tx\_work}}] \leavevmode
Sideband transmit worker. This can nest within the main
\textbf{work} worker for each transaction \textbf{work} launches.

\item[{\code{destroy\_connector\_list}}] \leavevmode
List of to be destroyed connectors.

\item[{\code{destroy\_connector\_lock}}] \leavevmode
Protects \textbf{connector\_list}.

\item[{\code{destroy\_connector\_work}}] \leavevmode
Work item to destroy connectors. Needed to
avoid locking inversion.

\end{description}

\textbf{Description}

This struct represents the toplevel displayport MST topology manager.
There should be one instance of this for every MST capable DP connector
on the GPU.
\index{drm\_dp\_update\_payload\_part1 (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_update_payload_part1}\pysiglinewithargsret{int \bfcode{drm\_dp\_update\_payload\_part1}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}}{}
Execute payload update part 1

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
manager to use.

\end{description}

\textbf{Description}

This iterates over all proposed virtual channels, and tries to
allocate space in the link for them. For 0-\textgreater{}slots transitions,
this step just writes the VCPI to the MST device. For slots-\textgreater{}0
transitions, this writes the updated VCPIs and removes the
remote VC payloads.

after calling this the driver should generate ACT and payload
packets.
\index{drm\_dp\_update\_payload\_part2 (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_update_payload_part2}\pysiglinewithargsret{int \bfcode{drm\_dp\_update\_payload\_part2}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}}{}
Execute payload update part 2

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
manager to use.

\end{description}

\textbf{Description}

This iterates over all proposed virtual channels, and tries to
allocate space in the link for them. For 0-\textgreater{}slots transitions,
this step writes the remote VC payload commands. For slots-\textgreater{}0
this just resets some internal state.
\index{drm\_dp\_mst\_topology\_mgr\_set\_mst (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_mst_topology_mgr_set_mst}\pysiglinewithargsret{int \bfcode{drm\_dp\_mst\_topology\_mgr\_set\_mst}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}, bool\emph{ mst\_state}}{}
Set the MST state for a topology manager

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
manager to set state for

\item[{\code{bool mst\_state}}] \leavevmode
true to enable MST on this connector - false to disable.

\end{description}

\textbf{Description}

This is called by the driver when it detects an MST capable device plugged
into a DP MST capable port, or when a DP MST capable device is unplugged.
\index{drm\_dp\_mst\_topology\_mgr\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_mst_topology_mgr_suspend}\pysiglinewithargsret{void \bfcode{drm\_dp\_mst\_topology\_mgr\_suspend}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}}{}
suspend the MST manager

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
manager to suspend

\end{description}

\textbf{Description}

This function tells the MST device that we can't handle UP messages
anymore. This should stop it from sending any since we are suspended.
\index{drm\_dp\_mst\_topology\_mgr\_resume (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_mst_topology_mgr_resume}\pysiglinewithargsret{int \bfcode{drm\_dp\_mst\_topology\_mgr\_resume}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}}{}
resume the MST manager

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
manager to resume

\end{description}

\textbf{Description}

This will fetch DPCD and see if the device is still there,
if it is, it will rewrite the MSTM control bits, and return.

if the device fails this returns -1, and the driver should do
a full MST reprobe, in case we were undocked.
\index{drm\_dp\_mst\_hpd\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_mst_hpd_irq}\pysiglinewithargsret{int \bfcode{drm\_dp\_mst\_hpd\_irq}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}, u8 *\emph{ esi}, bool *\emph{ handled}}{}
MST hotplug IRQ notify

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
manager to notify irq for.

\item[{\code{u8 * esi}}] \leavevmode
4 bytes from SINK\_COUNT\_ESI

\item[{\code{bool * handled}}] \leavevmode
whether the hpd interrupt was consumed or not

\end{description}

\textbf{Description}

This should be called from the driver when it detects a short IRQ,
along with the value of the DEVICE\_SERVICE\_IRQ\_VECTOR\_ESI0. The
topology manager will process the sideband messages received as a result
of this.
\index{drm\_dp\_mst\_detect\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_mst_detect_port}\pysiglinewithargsret{enum {\hyperref[gpu/drm\string-kms:c.drm_connector_status]{\emph{drm\_connector\_status}}} \bfcode{drm\_dp\_mst\_detect\_port}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_port]{\emph{drm\_dp\_mst\_port}}} *\emph{ port}}{}
get connection status for an MST port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
DRM connector for this port

\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
manager for this port

\item[{\code{struct drm\_dp\_mst\_port * port}}] \leavevmode
unverified pointer to a port

\end{description}

\textbf{Description}

This returns the current connection state for a port. It validates the
port pointer still exists so the caller doesn't require a reference
\index{drm\_dp\_mst\_port\_has\_audio (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_mst_port_has_audio}\pysiglinewithargsret{bool \bfcode{drm\_dp\_mst\_port\_has\_audio}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_port]{\emph{drm\_dp\_mst\_port}}} *\emph{ port}}{}
Check whether port has audio capability or not

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
manager for this port

\item[{\code{struct drm\_dp\_mst\_port * port}}] \leavevmode
unverified pointer to a port.

\end{description}

\textbf{Description}

This returns whether the port supports audio or not.
\index{drm\_dp\_mst\_get\_edid (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_mst_get_edid}\pysiglinewithargsret{struct edid * \bfcode{drm\_dp\_mst\_get\_edid}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_port]{\emph{drm\_dp\_mst\_port}}} *\emph{ port}}{}
get EDID for an MST port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
toplevel connector to get EDID for

\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
manager for this port

\item[{\code{struct drm\_dp\_mst\_port * port}}] \leavevmode
unverified pointer to a port.

\end{description}

\textbf{Description}

This returns an EDID for the port connected to a connector,
It validates the pointer still exists so the caller doesn't require a
reference.
\index{drm\_dp\_find\_vcpi\_slots (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_find_vcpi_slots}\pysiglinewithargsret{int \bfcode{drm\_dp\_find\_vcpi\_slots}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}, int\emph{ pbn}}{}
find slots for this PBN value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
manager to use

\item[{\code{int pbn}}] \leavevmode
payload bandwidth to convert into slots.

\end{description}
\index{drm\_dp\_atomic\_find\_vcpi\_slots (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_atomic_find_vcpi_slots}\pysiglinewithargsret{int \bfcode{drm\_dp\_atomic\_find\_vcpi\_slots}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_port]{\emph{drm\_dp\_mst\_port}}} *\emph{ port}, int\emph{ pbn}}{}
Find and add vcpi slots to the state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
global atomic state

\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
MST topology manager for the port

\item[{\code{struct drm\_dp\_mst\_port * port}}] \leavevmode
port to find vcpi slots for

\item[{\code{int pbn}}] \leavevmode
bandwidth required for the mode in PBN

\end{description}

\textbf{Return}

Total slots in the atomic state assigned for this port or error
\index{drm\_dp\_atomic\_release\_vcpi\_slots (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_atomic_release_vcpi_slots}\pysiglinewithargsret{int \bfcode{drm\_dp\_atomic\_release\_vcpi\_slots}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}, int\emph{ slots}}{}
Release allocated vcpi slots

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
global atomic state

\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
MST topology manager for the port

\item[{\code{int slots}}] \leavevmode
number of vcpi slots to release

\end{description}

\textbf{Return}

0 if \textbf{slots} were added back to \code{drm\_dp\_mst\_topology\_state-\textgreater{}avail\_slots} or
negative error code
\index{drm\_dp\_mst\_allocate\_vcpi (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_mst_allocate_vcpi}\pysiglinewithargsret{bool \bfcode{drm\_dp\_mst\_allocate\_vcpi}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_port]{\emph{drm\_dp\_mst\_port}}} *\emph{ port}, int\emph{ pbn}, int\emph{ slots}}{}
Allocate a virtual channel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
manager for this port

\item[{\code{struct drm\_dp\_mst\_port * port}}] \leavevmode
port to allocate a virtual channel for.

\item[{\code{int pbn}}] \leavevmode
payload bandwidth number to request

\item[{\code{int slots}}] \leavevmode
returned number of slots for this PBN.

\end{description}
\index{drm\_dp\_mst\_reset\_vcpi\_slots (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_mst_reset_vcpi_slots}\pysiglinewithargsret{void \bfcode{drm\_dp\_mst\_reset\_vcpi\_slots}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_port]{\emph{drm\_dp\_mst\_port}}} *\emph{ port}}{}
Reset number of slots to 0 for VCPI

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
manager for this port

\item[{\code{struct drm\_dp\_mst\_port * port}}] \leavevmode
unverified pointer to a port.

\end{description}

\textbf{Description}

This just resets the number of slots for the ports VCPI for later programming.
\index{drm\_dp\_mst\_deallocate\_vcpi (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_mst_deallocate_vcpi}\pysiglinewithargsret{void \bfcode{drm\_dp\_mst\_deallocate\_vcpi}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_port]{\emph{drm\_dp\_mst\_port}}} *\emph{ port}}{}
deallocate a VCPI

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
manager for this port

\item[{\code{struct drm\_dp\_mst\_port * port}}] \leavevmode
unverified port to deallocate vcpi for

\end{description}
\index{drm\_dp\_check\_act\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_check_act_status}\pysiglinewithargsret{int \bfcode{drm\_dp\_check\_act\_status}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}}{}
Check ACT handled status.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
manager to use

\end{description}

\textbf{Description}

Check the payload status bits in the DPCD for ACT handled completion.
\index{drm\_dp\_calc\_pbn\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_calc_pbn_mode}\pysiglinewithargsret{int \bfcode{drm\_dp\_calc\_pbn\_mode}}{int\emph{ clock}, int\emph{ bpp}}{}
Calculate the PBN for a mode.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int clock}}] \leavevmode
dot clock for the mode

\item[{\code{int bpp}}] \leavevmode
bpp for the mode.

\end{description}

\textbf{Description}

This uses the formula in the spec to calculate the PBN value for a mode.
\index{drm\_dp\_mst\_dump\_topology (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_mst_dump_topology}\pysiglinewithargsret{void \bfcode{drm\_dp\_mst\_dump\_topology}}{struct seq\_file *\emph{ m}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct seq\_file * m}}] \leavevmode
seq\_file to dump output to

\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
manager to dump current topology for.

\end{description}

\textbf{Description}

helper to dump MST topology to a seq file for debugfs.
\index{drm\_atomic\_get\_mst\_topology\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_atomic_get_mst_topology_state}\pysiglinewithargsret{struct drm\_dp\_mst\_topology\_state * \bfcode{drm\_atomic\_get\_mst\_topology\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
global atomic state

\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
MST topology manager, also the private object in this case

\end{description}

\textbf{Description}

This function wraps \code{drm\_atomic\_get\_priv\_obj\_state()} passing in the MST atomic
state vtable so that the private object state returned is that of a MST
topology object. Also, {\hyperref[gpu/drm\string-kms:c.drm_atomic_get_private_obj_state]{\emph{\code{drm\_atomic\_get\_private\_obj\_state()}}}} expects the caller
to care of the locking, so warn if don't hold the connection\_mutex.

\textbf{Return}

The MST topology state or error pointer.
\index{drm\_dp\_mst\_topology\_mgr\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_mst_topology_mgr_init}\pysiglinewithargsret{int \bfcode{drm\_dp\_mst\_topology\_mgr\_init}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}, struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_aux]{\emph{drm\_dp\_aux}}} *\emph{ aux}, int\emph{ max\_dpcd\_transaction\_bytes}, int\emph{ max\_payloads}, int\emph{ conn\_base\_id}}{}
initialise a topology manager

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
manager struct to initialise

\item[{\code{struct drm\_device * dev}}] \leavevmode
device providing this structure - for i2c addition.

\item[{\code{struct drm\_dp\_aux * aux}}] \leavevmode
DP helper aux channel to talk to this device

\item[{\code{int max\_dpcd\_transaction\_bytes}}] \leavevmode
hw specific DPCD transaction limit

\item[{\code{int max\_payloads}}] \leavevmode
maximum number of payloads this GPU can source

\item[{\code{int conn\_base\_id}}] \leavevmode
the connector object ID the MST device is connected to.

\end{description}

\textbf{Description}

Return 0 for success, or negative error code on failure
\index{drm\_dp\_mst\_topology\_mgr\_destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_dp_mst_topology_mgr_destroy}\pysiglinewithargsret{void \bfcode{drm\_dp\_mst\_topology\_mgr\_destroy}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_dp_mst_topology_mgr]{\emph{drm\_dp\_mst\_topology\_mgr}}} *\emph{ mgr}}{}
destroy topology manager.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_dp\_mst\_topology\_mgr * mgr}}] \leavevmode
manager to destroy

\end{description}


\section{MIPI DSI Helper Functions Reference}
\label{gpu/drm-kms-helpers:mipi-dsi-helper-functions-reference}
These functions contain some common logic and helpers to deal with MIPI DSI
peripherals.

Helpers are provided for a number of standard MIPI DSI command as well as a
subset of the MIPI DCS command set.
\index{mipi\_dsi\_msg (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_msg}\pysigline{struct \bfcode{mipi\_dsi\_msg}}
read/write DSI buffer

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct mipi\PYGZus{}dsi\PYGZus{}msg \PYGZob{}
  u8 channel;
  u8 type;
  u16 flags;
  size\PYGZus{}t tx\PYGZus{}len;
  const void *tx\PYGZus{}buf;
  size\PYGZus{}t rx\PYGZus{}len;
  void *rx\PYGZus{}buf;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{channel}}] \leavevmode
virtual channel id

\item[{\code{type}}] \leavevmode
payload data type

\item[{\code{flags}}] \leavevmode
flags controlling this message transmission

\item[{\code{tx\_len}}] \leavevmode
length of \textbf{tx\_buf}

\item[{\code{tx\_buf}}] \leavevmode
data to be written

\item[{\code{rx\_len}}] \leavevmode
length of \textbf{rx\_buf}

\item[{\code{rx\_buf}}] \leavevmode
data to be read, or NULL

\end{description}
\index{mipi\_dsi\_packet (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_packet}\pysigline{struct \bfcode{mipi\_dsi\_packet}}
represents a MIPI DSI packet in protocol format

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct mipi\PYGZus{}dsi\PYGZus{}packet \PYGZob{}
  size\PYGZus{}t size;
  u8 header[4];
  size\PYGZus{}t payload\PYGZus{}length;
  const u8 *payload;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{size}}] \leavevmode
size (in bytes) of the packet

\item[{\code{header}}] \leavevmode
the four bytes that make up the header (Data ID, Word Count or
Packet Data, and ECC)

\item[{\code{payload\_length}}] \leavevmode
number of bytes in the payload

\item[{\code{payload}}] \leavevmode
a pointer to a buffer containing the payload, if any

\end{description}
\index{mipi\_dsi\_host\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_host_ops}\pysigline{struct \bfcode{mipi\_dsi\_host\_ops}}
DSI bus operations

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct mipi\PYGZus{}dsi\PYGZus{}host\PYGZus{}ops \PYGZob{}
  int (*attach)(struct mipi\PYGZus{}dsi\PYGZus{}host *host, struct mipi\PYGZus{}dsi\PYGZus{}device *dsi);
  int (*detach)(struct mipi\PYGZus{}dsi\PYGZus{}host *host, struct mipi\PYGZus{}dsi\PYGZus{}device *dsi);
  ssize\PYGZus{}t (*transfer)(struct mipi\PYGZus{}dsi\PYGZus{}host *host, const struct mipi\PYGZus{}dsi\PYGZus{}msg *msg);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{attach}}] \leavevmode
attach DSI device to DSI host

\item[{\code{detach}}] \leavevmode
detach DSI device from DSI host

\item[{\code{transfer}}] \leavevmode
transmit a DSI packet

\end{description}

\textbf{Description}

DSI packets transmitted by .:c:func:\emph{transfer()} are passed in as mipi\_dsi\_msg
structures. This structure contains information about the type of packet
being transmitted as well as the transmit and receive buffers. When an
error is encountered during transmission, this function will return a
negative error code. On success it shall return the number of bytes
transmitted for write packets or the number of bytes received for read
packets.

Note that typically DSI packet transmission is atomic, so the .:c:func:\emph{transfer()}
function will seldomly return anything other than the number of bytes
contained in the transmit buffer on success.
\index{mipi\_dsi\_host (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_host}\pysigline{struct \bfcode{mipi\_dsi\_host}}
DSI host device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct mipi\PYGZus{}dsi\PYGZus{}host \PYGZob{}
  struct device *dev;
  const struct mipi\PYGZus{}dsi\PYGZus{}host\PYGZus{}ops *ops;
  struct list\PYGZus{}head list;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev}}] \leavevmode
driver model device node for this DSI host

\item[{\code{ops}}] \leavevmode
DSI host operations

\item[{\code{list}}] \leavevmode
list management

\end{description}
\index{mipi\_dsi\_device\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_device_info}\pysigline{struct \bfcode{mipi\_dsi\_device\_info}}
template for creating a mipi\_dsi\_device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct mipi\PYGZus{}dsi\PYGZus{}device\PYGZus{}info \PYGZob{}
  char type[DSI\PYGZus{}DEV\PYGZus{}NAME\PYGZus{}SIZE];
  u32 channel;
  struct device\PYGZus{}node *node;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{type}}] \leavevmode
DSI peripheral chip type

\item[{\code{channel}}] \leavevmode
DSI virtual channel assigned to peripheral

\item[{\code{node}}] \leavevmode
pointer to OF device node or NULL

\end{description}

\textbf{Description}

This is populated and passed to mipi\_dsi\_device\_new to create a new
DSI device
\index{mipi\_dsi\_device (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_device}\pysigline{struct \bfcode{mipi\_dsi\_device}}
DSI peripheral device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct mipi\PYGZus{}dsi\PYGZus{}device \PYGZob{}
  struct mipi\PYGZus{}dsi\PYGZus{}host *host;
  struct device dev;
  char name[DSI\PYGZus{}DEV\PYGZus{}NAME\PYGZus{}SIZE];
  unsigned int channel;
  unsigned int lanes;
  enum mipi\PYGZus{}dsi\PYGZus{}pixel\PYGZus{}format format;
  unsigned long mode\PYGZus{}flags;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{host}}] \leavevmode
DSI host for this peripheral

\item[{\code{dev}}] \leavevmode
driver model device node for this peripheral

\item[{\code{name}}] \leavevmode
DSI peripheral chip type

\item[{\code{channel}}] \leavevmode
virtual channel assigned to the peripheral

\item[{\code{lanes}}] \leavevmode
number of active data lanes

\item[{\code{format}}] \leavevmode
pixel format for video mode

\item[{\code{mode\_flags}}] \leavevmode
DSI operation mode related flags

\end{description}
\index{mipi\_dsi\_pixel\_format\_to\_bpp (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_pixel_format_to_bpp}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_pixel\_format\_to\_bpp}}{enum mipi\_dsi\_pixel\_format\emph{ fmt}}{}
obtain the number of bits per pixel for any given pixel format defined by the MIPI DSI specification

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{enum mipi\_dsi\_pixel\_format fmt}}] \leavevmode
MIPI DSI pixel format

\end{description}

\textbf{Return}

The number of bits per pixel of the given pixel format.
\index{mipi\_dsi\_dcs\_tear\_mode (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_tear_mode}\pysigline{enum \bfcode{mipi\_dsi\_dcs\_tear\_mode}}
Tearing Effect Output Line mode

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{MIPI\_DSI\_DCS\_TEAR\_MODE\_VBLANK}}] \leavevmode
the TE output line consists of V-Blanking
information only

\item[{\code{MIPI\_DSI\_DCS\_TEAR\_MODE\_VHBLANK}}] \leavevmode
the TE output line consists of both
V-Blanking and H-Blanking information

\end{description}
\index{mipi\_dsi\_driver (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_driver}\pysigline{struct \bfcode{mipi\_dsi\_driver}}
DSI driver

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct mipi\PYGZus{}dsi\PYGZus{}driver \PYGZob{}
  struct device\PYGZus{}driver driver;
  int(*probe)(struct mipi\PYGZus{}dsi\PYGZus{}device *dsi);
  int(*remove)(struct mipi\PYGZus{}dsi\PYGZus{}device *dsi);
  void (*shutdown)(struct mipi\PYGZus{}dsi\PYGZus{}device *dsi);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{driver}}] \leavevmode
device driver model driver

\item[{\code{probe}}] \leavevmode
callback for device binding

\item[{\code{remove}}] \leavevmode
callback for device unbinding

\item[{\code{shutdown}}] \leavevmode
called at shutdown time to quiesce the device

\end{description}
\index{of\_find\_mipi\_dsi\_device\_by\_node (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.of_find_mipi_dsi_device_by_node}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} * \bfcode{of\_find\_mipi\_dsi\_device\_by\_node}}{struct device\_node *\emph{ np}}{}
find the MIPI DSI device matching a device tree node

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device\_node * np}}] \leavevmode
device tree node

\end{description}

\textbf{Return}
\begin{description}
\item[{A pointer to the MIPI DSI device corresponding to \textbf{np} or NULL if no}] \leavevmode
such device exists (or has not been registered yet).

\end{description}
\index{mipi\_dsi\_device\_register\_full (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_device_register_full}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} * \bfcode{mipi\_dsi\_device\_register\_full}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_host]{\emph{mipi\_dsi\_host}}} *\emph{ host}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device_info]{\emph{mipi\_dsi\_device\_info}}} *\emph{ info}}{}
create a MIPI DSI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_host * host}}] \leavevmode
DSI host to which this device is connected

\item[{\code{const struct mipi\_dsi\_device\_info * info}}] \leavevmode
pointer to template containing DSI device information

\end{description}

\textbf{Description}

Create a MIPI DSI device by using the device information provided by
mipi\_dsi\_device\_info template

\textbf{Return}

A pointer to the newly created MIPI DSI device, or, a pointer encoded
with an error
\index{mipi\_dsi\_device\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_device_unregister}\pysiglinewithargsret{void \bfcode{mipi\_dsi\_device\_unregister}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}}{}
unregister MIPI DSI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\end{description}
\index{of\_find\_mipi\_dsi\_host\_by\_node (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.of_find_mipi_dsi_host_by_node}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_host]{\emph{mipi\_dsi\_host}}} * \bfcode{of\_find\_mipi\_dsi\_host\_by\_node}}{struct device\_node *\emph{ node}}{}
find the MIPI DSI host matching a device tree node

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device\_node * node}}] \leavevmode
device tree node

\end{description}

\textbf{Return}

A pointer to the MIPI DSI host corresponding to \textbf{node} or NULL if no
such device exists (or has not been registered yet).
\index{mipi\_dsi\_attach (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_attach}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_attach}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}}{}
attach a DSI device to its DSI host

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral

\end{description}
\index{mipi\_dsi\_detach (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_detach}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_detach}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}}{}
detach a DSI device from its DSI host

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral

\end{description}
\index{mipi\_dsi\_packet\_format\_is\_short (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_packet_format_is_short}\pysiglinewithargsret{bool \bfcode{mipi\_dsi\_packet\_format\_is\_short}}{u8\emph{ type}}{}
check if a packet is of the short format

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 type}}] \leavevmode
MIPI DSI data type of the packet

\end{description}

\textbf{Return}

true if the packet for the given data type is a short packet, false
otherwise.
\index{mipi\_dsi\_packet\_format\_is\_long (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_packet_format_is_long}\pysiglinewithargsret{bool \bfcode{mipi\_dsi\_packet\_format\_is\_long}}{u8\emph{ type}}{}
check if a packet is of the long format

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 type}}] \leavevmode
MIPI DSI data type of the packet

\end{description}

\textbf{Return}

true if the packet for the given data type is a long packet, false
otherwise.
\index{mipi\_dsi\_create\_packet (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_create_packet}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_create\_packet}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_packet]{\emph{mipi\_dsi\_packet}}} *\emph{ packet}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_msg]{\emph{mipi\_dsi\_msg}}} *\emph{ msg}}{}
create a packet from a message according to the DSI protocol

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_packet * packet}}] \leavevmode
pointer to a DSI packet structure

\item[{\code{const struct mipi\_dsi\_msg * msg}}] \leavevmode
message to translate into a packet

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{mipi\_dsi\_shutdown\_peripheral (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_shutdown_peripheral}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_shutdown\_peripheral}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}}{}
sends a Shutdown Peripheral command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{mipi\_dsi\_turn\_on\_peripheral (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_turn_on_peripheral}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_turn\_on\_peripheral}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}}{}
sends a Turn On Peripheral command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{mipi\_dsi\_generic\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_generic_write}\pysiglinewithargsret{ssize\_t \bfcode{mipi\_dsi\_generic\_write}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}, const void *\emph{ payload}, size\_t\emph{ size}}{}
transmit data using a generic write packet

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\item[{\code{const void * payload}}] \leavevmode
buffer containing the payload

\item[{\code{size\_t size}}] \leavevmode
size of payload buffer

\end{description}

\textbf{Description}

This function will automatically choose the right data type depending on
the payload length.

\textbf{Return}

The number of bytes transmitted on success or a negative error code
on failure.
\index{mipi\_dsi\_generic\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_generic_read}\pysiglinewithargsret{ssize\_t \bfcode{mipi\_dsi\_generic\_read}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}, const void *\emph{ params}, size\_t\emph{ num\_params}, void *\emph{ data}, size\_t\emph{ size}}{}
receive data using a generic read packet

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\item[{\code{const void * params}}] \leavevmode
buffer containing the request parameters

\item[{\code{size\_t num\_params}}] \leavevmode
number of request parameters

\item[{\code{void * data}}] \leavevmode
buffer in which to return the received data

\item[{\code{size\_t size}}] \leavevmode
size of receive buffer

\end{description}

\textbf{Description}

This function will automatically choose the right data type depending on
the number of parameters passed in.

\textbf{Return}

The number of bytes successfully read or a negative error code on
failure.
\index{mipi\_dsi\_dcs\_write\_buffer (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_write_buffer}\pysiglinewithargsret{ssize\_t \bfcode{mipi\_dsi\_dcs\_write\_buffer}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}, const void *\emph{ data}, size\_t\emph{ len}}{}
transmit a DCS command with payload

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\item[{\code{const void * data}}] \leavevmode
buffer containing data to be transmitted

\item[{\code{size\_t len}}] \leavevmode
size of transmission buffer

\end{description}

\textbf{Description}

This function will automatically choose the right data type depending on
the command payload length.

\textbf{Return}

The number of bytes successfully transmitted or a negative error
code on failure.
\index{mipi\_dsi\_dcs\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_write}\pysiglinewithargsret{ssize\_t \bfcode{mipi\_dsi\_dcs\_write}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}, u8\emph{ cmd}, const void *\emph{ data}, size\_t\emph{ len}}{}
send DCS write command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\item[{\code{u8 cmd}}] \leavevmode
DCS command

\item[{\code{const void * data}}] \leavevmode
buffer containing the command payload

\item[{\code{size\_t len}}] \leavevmode
command payload length

\end{description}

\textbf{Description}

This function will automatically choose the right data type depending on
the command payload length.

\textbf{Return}

The number of bytes successfully transmitted or a negative error
code on failure.
\index{mipi\_dsi\_dcs\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_read}\pysiglinewithargsret{ssize\_t \bfcode{mipi\_dsi\_dcs\_read}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}, u8\emph{ cmd}, void *\emph{ data}, size\_t\emph{ len}}{}
send DCS read request command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\item[{\code{u8 cmd}}] \leavevmode
DCS command

\item[{\code{void * data}}] \leavevmode
buffer in which to receive data

\item[{\code{size\_t len}}] \leavevmode
size of receive buffer

\end{description}

\textbf{Return}

The number of bytes read or a negative error code on failure.
\index{mipi\_dsi\_dcs\_nop (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_nop}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_dcs\_nop}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}}{}
send DCS nop packet

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{mipi\_dsi\_dcs\_soft\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_soft_reset}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_dcs\_soft\_reset}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}}{}
perform a software reset of the display module

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{mipi\_dsi\_dcs\_get\_power\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_get_power_mode}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_dcs\_get\_power\_mode}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}, u8 *\emph{ mode}}{}
query the display module's current power mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\item[{\code{u8 * mode}}] \leavevmode
return location for the current power mode

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{mipi\_dsi\_dcs\_get\_pixel\_format (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_get_pixel_format}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_dcs\_get\_pixel\_format}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}, u8 *\emph{ format}}{}
gets the pixel format for the RGB image data used by the interface

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\item[{\code{u8 * format}}] \leavevmode
return location for the pixel format

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{mipi\_dsi\_dcs\_enter\_sleep\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_enter_sleep_mode}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_dcs\_enter\_sleep\_mode}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}}{}
disable all unnecessary blocks inside the display module except interface communication

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{mipi\_dsi\_dcs\_exit\_sleep\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_exit_sleep_mode}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_dcs\_exit\_sleep\_mode}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}}{}
enable all blocks inside the display module

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{mipi\_dsi\_dcs\_set\_display\_off (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_set_display_off}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_dcs\_set\_display\_off}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}}{}
stop displaying the image data on the display device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{mipi\_dsi\_dcs\_set\_display\_on (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_set_display_on}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_dcs\_set\_display\_on}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}}{}
start displaying the image data on the display device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\end{description}

\textbf{Return}

0 on success or a negative error code on failure
\index{mipi\_dsi\_dcs\_set\_column\_address (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_set_column_address}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_dcs\_set\_column\_address}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}, u16\emph{ start}, u16\emph{ end}}{}
define the column extent of the frame memory accessed by the host processor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\item[{\code{u16 start}}] \leavevmode
first column of frame memory

\item[{\code{u16 end}}] \leavevmode
last column of frame memory

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{mipi\_dsi\_dcs\_set\_page\_address (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_set_page_address}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_dcs\_set\_page\_address}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}, u16\emph{ start}, u16\emph{ end}}{}
define the page extent of the frame memory accessed by the host processor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\item[{\code{u16 start}}] \leavevmode
first page of frame memory

\item[{\code{u16 end}}] \leavevmode
last page of frame memory

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{mipi\_dsi\_dcs\_set\_tear\_off (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_set_tear_off}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_dcs\_set\_tear\_off}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}}{}
turn off the display module's Tearing Effect output signal on the TE signal line

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\end{description}

\textbf{Return}

0 on success or a negative error code on failure
\index{mipi\_dsi\_dcs\_set\_tear\_on (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_set_tear_on}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_dcs\_set\_tear\_on}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}, enum {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_dcs_tear_mode]{\emph{mipi\_dsi\_dcs\_tear\_mode}}}\emph{ mode}}{}
turn on the display module's Tearing Effect output signal on the TE signal line.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\item[{\code{enum mipi\_dsi\_dcs\_tear\_mode mode}}] \leavevmode
the Tearing Effect Output Line mode

\end{description}

\textbf{Return}

0 on success or a negative error code on failure
\index{mipi\_dsi\_dcs\_set\_pixel\_format (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_set_pixel_format}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_dcs\_set\_pixel\_format}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}, u8\emph{ format}}{}
sets the pixel format for the RGB image data used by the interface

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\item[{\code{u8 format}}] \leavevmode
pixel format

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{mipi\_dsi\_dcs\_set\_tear\_scanline (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_set_tear_scanline}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_dcs\_set\_tear\_scanline}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}, u16\emph{ scanline}}{}
set the scanline to use as trigger for the Tearing Effect output signal of the display module

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\item[{\code{u16 scanline}}] \leavevmode
scanline to use as trigger

\end{description}

\textbf{Return}

0 on success or a negative error code on failure
\index{mipi\_dsi\_dcs\_set\_display\_brightness (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_set_display_brightness}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_dcs\_set\_display\_brightness}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}, u16\emph{ brightness}}{}
sets the brightness value of the display

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\item[{\code{u16 brightness}}] \leavevmode
brightness value

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{mipi\_dsi\_dcs\_get\_display\_brightness (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_dcs_get_display_brightness}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_dcs\_get\_display\_brightness}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_device]{\emph{mipi\_dsi\_device}}} *\emph{ dsi}, u16 *\emph{ brightness}}{}
gets the current brightness value of the display

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_device * dsi}}] \leavevmode
DSI peripheral device

\item[{\code{u16 * brightness}}] \leavevmode
brightness value

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{mipi\_dsi\_driver\_register\_full (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_driver_register_full}\pysiglinewithargsret{int \bfcode{mipi\_dsi\_driver\_register\_full}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_driver]{\emph{mipi\_dsi\_driver}}} *\emph{ drv}, struct module *\emph{ owner}}{}
register a driver for DSI devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_driver * drv}}] \leavevmode
DSI driver structure

\item[{\code{struct module * owner}}] \leavevmode
owner module

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{mipi\_dsi\_driver\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.mipi_dsi_driver_unregister}\pysiglinewithargsret{void \bfcode{mipi\_dsi\_driver\_unregister}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.mipi_dsi_driver]{\emph{mipi\_dsi\_driver}}} *\emph{ drv}}{}
unregister a driver for DSI devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dsi\_driver * drv}}] \leavevmode
DSI driver structure

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.


\section{Output Probing Helper Functions Reference}
\label{gpu/drm-kms-helpers:output-probing-helper-functions-reference}
This library provides some helper code for output probing. It provides an
implementation of the core {\hyperref[gpu/drm\string-kms:c.drm_connector_funcs]{\emph{\code{drm\_connector\_funcs.fill\_modes}}}} interface with
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_helper_probe_single_connector_modes]{\emph{\code{drm\_helper\_probe\_single\_connector\_modes()}}}}.

It also provides support for polling connectors with a work item and for
generic hotplug interrupt handling where the driver doesn't or cannot keep
track of a per-connector hpd interrupt.

This helper library can be used independently of the modeset helper library.
Drivers can also overwrite different parts e.g. use their own hotplug
handling code to avoid probing unrelated outputs.

The probe helpers share the function table structures with other display
helper libraries. See {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_connector_helper_funcs]{\emph{\code{struct drm\_connector\_helper\_funcs}}}} for the details.
\index{drm\_kms\_helper\_poll\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_kms_helper_poll_enable}\pysiglinewithargsret{void \bfcode{drm\_kms\_helper\_poll\_enable}}{struct drm\_device *\emph{ dev}}{}
re-enable output polling.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm\_device

\end{description}

\textbf{Description}

This function re-enables the output polling work, after it has been
temporarily disabled using {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_kms_helper_poll_disable]{\emph{\code{drm\_kms\_helper\_poll\_disable()}}}}, for example over
suspend/resume.

Drivers can call this helper from their device resume implementation. It is
not an error to call this even when output polling isn't enabled.

Note that calls to enable and disable polling must be strictly ordered, which
is automatically the case when they're only call from suspend/resume
callbacks.
\index{drm\_helper\_probe\_detect (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_helper_probe_detect}\pysiglinewithargsret{int \bfcode{drm\_helper\_probe\_detect}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}, bool\emph{ force}}{}
probe connector status

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector to probe

\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
acquire\_ctx, or NULL to let this function handle locking.

\item[{\code{bool force}}] \leavevmode
Whether destructive probe operations should be performed.

\end{description}

\textbf{Description}

This function calls the detect callbacks of the connector.
This function returns {\hyperref[gpu/drm\string-kms:c.drm_connector_status]{\emph{\code{drm\_connector\_status}}}}, or
if \textbf{ctx} is set, it might also return -EDEADLK.
\index{drm\_helper\_probe\_single\_connector\_modes (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_helper_probe_single_connector_modes}\pysiglinewithargsret{int \bfcode{drm\_helper\_probe\_single\_connector\_modes}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, uint32\_t\emph{ maxX}, uint32\_t\emph{ maxY}}{}
get complete set of display modes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector to probe

\item[{\code{uint32\_t maxX}}] \leavevmode
max width for modes

\item[{\code{uint32\_t maxY}}] \leavevmode
max height for modes

\end{description}

\textbf{Description}

Based on the helper callbacks implemented by \textbf{connector} in struct
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_connector_helper_funcs]{\emph{\code{drm\_connector\_helper\_funcs}}}} try to detect all valid modes.  Modes will first
be added to the connector's probed\_modes list, then culled (based on validity
and the \textbf{maxX}, \textbf{maxY} parameters) and put into the normal modes list.

Intended to be used as a generic implementation of the
{\hyperref[gpu/drm\string-kms:c.drm_connector_funcs]{\emph{\code{drm\_connector\_funcs.fill\_modes()}}}} vfunc for drivers that use the CRTC helpers
for output mode filtering and detection.

The basic procedure is as follows
\begin{enumerate}
\item {} 
All modes currently on the connector's modes list are marked as stale

\item {} 
New modes are added to the connector's probed\_modes list with
{\hyperref[gpu/drm\string-kms:c.drm_mode_probed_add]{\emph{\code{drm\_mode\_probed\_add()}}}}. New modes start their life with status as OK.
Modes are added from a single source using the following priority order.
\begin{itemize}
\item {} 
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_connector_helper_funcs]{\emph{\code{drm\_connector\_helper\_funcs.get\_modes}}}} vfunc

\item {} 
if the connector status is connector\_status\_connected, standard
VESA DMT modes up to 1024x768 are automatically added
({\hyperref[gpu/drm\string-kms\string-helpers:c.drm_add_modes_noedid]{\emph{\code{drm\_add\_modes\_noedid()}}}})

\end{itemize}

Finally modes specified via the kernel command line (video=...) are
added in addition to what the earlier probes produced
(\code{drm\_helper\_probe\_add\_cmdline\_mode()}). These modes are generated
using the VESA GTF/CVT formulas.

\item {} 
Modes are moved from the probed\_modes list to the modes list. Potential
duplicates are merged together (see {\hyperref[gpu/drm\string-kms:c.drm_mode_connector_list_update]{\emph{\code{drm\_mode\_connector\_list\_update()}}}}).
After this step the probed\_modes list will be empty again.

\item {} 
Any non-stale mode on the modes list then undergoes validation
\begin{itemize}
\item {} 
{\hyperref[gpu/drm\string-kms:c.drm_mode_validate_basic]{\emph{\code{drm\_mode\_validate\_basic()}}}} performs basic sanity checks

\item {} 
{\hyperref[gpu/drm\string-kms:c.drm_mode_validate_size]{\emph{\code{drm\_mode\_validate\_size()}}}} filters out modes larger than \textbf{maxX} and \textbf{maxY}
(if specified)

\item {} 
\code{drm\_mode\_validate\_flag()} checks the modes against basic connector
capabilities (interlace\_allowed,doublescan\_allowed,stereo\_allowed)

\item {} 
the optional {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_connector_helper_funcs]{\emph{\code{drm\_connector\_helper\_funcs.mode\_valid}}}} helper can perform
driver and/or sink specific checks

\item {} 
the optional {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{\code{drm\_crtc\_helper\_funcs.mode\_valid}}}},
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_bridge_funcs]{\emph{\code{drm\_bridge\_funcs.mode\_valid}}}} and {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.mode\_valid}}}}
helpers can perform driver and/or source specific checks which are also
enforced by the modeset/atomic helpers

\end{itemize}

\item {} 
Any mode whose status is not OK is pruned from the connector's modes list,
accompanied by a debug message indicating the reason for the mode's
rejection (see {\hyperref[gpu/drm\string-kms:c.drm_mode_prune_invalid]{\emph{\code{drm\_mode\_prune\_invalid()}}}}).

\end{enumerate}

\textbf{Return}

The number of modes found on \textbf{connector}.
\index{drm\_kms\_helper\_hotplug\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_kms_helper_hotplug_event}\pysiglinewithargsret{void \bfcode{drm\_kms\_helper\_hotplug\_event}}{struct drm\_device *\emph{ dev}}{}
fire off KMS hotplug events

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm\_device whose connector state changed

\end{description}

\textbf{Description}

This function fires off the uevent for userspace and also calls the
output\_poll\_changed function, which is most commonly used to inform the fbdev
emulation code and allow it to update the fbcon output configuration.

Drivers should call this from their hotplug handling code when a change is
detected. Note that this function does not do any output detection of its
own, like {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_helper_hpd_irq_event]{\emph{\code{drm\_helper\_hpd\_irq\_event()}}}} does - this is assumed to be done by the
driver already.

This function must be called from process context with no mode
setting locks held.
\index{drm\_kms\_helper\_is\_poll\_worker (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_kms_helper_is_poll_worker}\pysiglinewithargsret{bool \bfcode{drm\_kms\_helper\_is\_poll\_worker}}{void}{}
is \code{current} task an output poll worker?

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Determine if \code{current} task is an output poll worker.  This can be used
to select distinct code paths for output polling versus other contexts.

One use case is to avoid a deadlock between the output poll worker and
the autosuspend worker wherein the latter waits for polling to finish
upon calling {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_kms_helper_poll_disable]{\emph{\code{drm\_kms\_helper\_poll\_disable()}}}}, while the former waits for
runtime suspend to finish upon calling \code{pm\_runtime\_get\_sync()} in a
connector -\textgreater{}detect hook.
\index{drm\_kms\_helper\_poll\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_kms_helper_poll_disable}\pysiglinewithargsret{void \bfcode{drm\_kms\_helper\_poll\_disable}}{struct drm\_device *\emph{ dev}}{}
disable output polling

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm\_device

\end{description}

\textbf{Description}

This function disables the output polling work.

Drivers can call this helper from their device suspend implementation. It is
not an error to call this even when output polling isn't enabled or already
disabled. Polling is re-enabled by calling {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_kms_helper_poll_enable]{\emph{\code{drm\_kms\_helper\_poll\_enable()}}}}.

Note that calls to enable and disable polling must be strictly ordered, which
is automatically the case when they're only call from suspend/resume
callbacks.
\index{drm\_kms\_helper\_poll\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_kms_helper_poll_init}\pysiglinewithargsret{void \bfcode{drm\_kms\_helper\_poll\_init}}{struct drm\_device *\emph{ dev}}{}
initialize and enable output polling

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm\_device

\end{description}

\textbf{Description}

This function intializes and then also enables output polling support for
\textbf{dev}. Drivers which do not have reliable hotplug support in hardware can use
this helper infrastructure to regularly poll such connectors for changes in
their connection state.

Drivers can control which connectors are polled by setting the
DRM\_CONNECTOR\_POLL\_CONNECT and DRM\_CONNECTOR\_POLL\_DISCONNECT flags. On
connectors where probing live outputs can result in visual distortion drivers
should not set the DRM\_CONNECTOR\_POLL\_DISCONNECT flag to avoid this.
Connectors which have no flag or only DRM\_CONNECTOR\_POLL\_HPD set are
completely ignored by the polling logic.

Note that a connector can be both polled and probed from the hotplug handler,
in case the hotplug interrupt is known to be unreliable.
\index{drm\_kms\_helper\_poll\_fini (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_kms_helper_poll_fini}\pysiglinewithargsret{void \bfcode{drm\_kms\_helper\_poll\_fini}}{struct drm\_device *\emph{ dev}}{}
disable output polling and clean it up

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm\_device

\end{description}
\index{drm\_helper\_hpd\_irq\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_helper_hpd_irq_event}\pysiglinewithargsret{bool \bfcode{drm\_helper\_hpd\_irq\_event}}{struct drm\_device *\emph{ dev}}{}
hotplug processing

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm\_device

\end{description}

\textbf{Description}

Drivers can use this helper function to run a detect cycle on all connectors
which have the DRM\_CONNECTOR\_POLL\_HPD flag set in their \code{polled} member. All
other connectors are ignored, which is useful to avoid reprobing fixed
panels.

This helper function is useful for drivers which can't or don't track hotplug
interrupts for each connector.

Drivers which support hotplug interrupts for each connector individually and
which have a more fine-grained detect logic should bypass this code and
directly call {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_kms_helper_hotplug_event]{\emph{\code{drm\_kms\_helper\_hotplug\_event()}}}} in case the connector state
changed.

This function must be called from process context with no mode
setting locks held.

Note that a connector can be both polled and probed from the hotplug handler,
in case the hotplug interrupt is known to be unreliable.


\section{EDID Helper Functions Reference}
\label{gpu/drm-kms-helpers:edid-helper-functions-reference}\index{drm\_eld\_mnl (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_eld_mnl}\pysiglinewithargsret{int \bfcode{drm\_eld\_mnl}}{const uint8\_t *\emph{ eld}}{}
Get ELD monitor name length in bytes.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const uint8\_t * eld}}] \leavevmode
pointer to an eld memory structure with mnl set

\end{description}
\index{drm\_eld\_sad (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_eld_sad}\pysiglinewithargsret{const uint8\_t * \bfcode{drm\_eld\_sad}}{const uint8\_t *\emph{ eld}}{}
Get ELD SAD structures.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const uint8\_t * eld}}] \leavevmode
pointer to an eld memory structure with sad\_count set

\end{description}
\index{drm\_eld\_sad\_count (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_eld_sad_count}\pysiglinewithargsret{int \bfcode{drm\_eld\_sad\_count}}{const uint8\_t *\emph{ eld}}{}
Get ELD SAD count.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const uint8\_t * eld}}] \leavevmode
pointer to an eld memory structure with sad\_count set

\end{description}
\index{drm\_eld\_calc\_baseline\_block\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_eld_calc_baseline_block_size}\pysiglinewithargsret{int \bfcode{drm\_eld\_calc\_baseline\_block\_size}}{const uint8\_t *\emph{ eld}}{}
Calculate baseline block size in bytes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const uint8\_t * eld}}] \leavevmode
pointer to an eld memory structure with mnl and sad\_count set

\end{description}

\textbf{Description}

This is a helper for determining the payload size of the baseline block, in
bytes, for e.g. setting the Baseline\_ELD\_Len field in the ELD header block.
\index{drm\_eld\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_eld_size}\pysiglinewithargsret{int \bfcode{drm\_eld\_size}}{const uint8\_t *\emph{ eld}}{}
Get ELD size in bytes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const uint8\_t * eld}}] \leavevmode
pointer to a complete eld memory structure

\end{description}

\textbf{Description}

The returned value does not include the vendor block. It's vendor specific,
and comprises of the remaining bytes in the ELD memory buffer after
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_eld_size]{\emph{\code{drm\_eld\_size()}}}} bytes of header and baseline block.

The returned value is guaranteed to be a multiple of 4.
\index{drm\_eld\_get\_spk\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_eld_get_spk_alloc}\pysiglinewithargsret{u8 \bfcode{drm\_eld\_get\_spk\_alloc}}{const uint8\_t *\emph{ eld}}{}
Get speaker allocation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const uint8\_t * eld}}] \leavevmode
pointer to an ELD memory structure

\end{description}

\textbf{Description}

The returned value is the speakers mask. User has to use \code{DRM\_ELD\_SPEAKER}
field definitions to identify speakers.
\index{drm\_eld\_get\_conn\_type (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_eld_get_conn_type}\pysiglinewithargsret{u8 \bfcode{drm\_eld\_get\_conn\_type}}{const uint8\_t *\emph{ eld}}{}
Get device type hdmi/dp connected

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const uint8\_t * eld}}] \leavevmode
pointer to an ELD memory structure

\end{description}

\textbf{Description}

The caller need to use \code{DRM\_ELD\_CONN\_TYPE\_HDMI} or \code{DRM\_ELD\_CONN\_TYPE\_DP} to
identify the display type connected.
\index{drm\_edid\_header\_is\_valid (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_edid_header_is_valid}\pysiglinewithargsret{int \bfcode{drm\_edid\_header\_is\_valid}}{const u8 *\emph{ raw\_edid}}{}
sanity check the header of the base EDID block

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * raw\_edid}}] \leavevmode
pointer to raw base EDID block

\end{description}

\textbf{Description}

Sanity check the header of the base EDID block.

\textbf{Return}

8 if the header is perfect, down to 0 if it's totally wrong.
\index{drm\_edid\_block\_valid (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_edid_block_valid}\pysiglinewithargsret{bool \bfcode{drm\_edid\_block\_valid}}{u8 *\emph{ raw\_edid}, int\emph{ block}, bool\emph{ print\_bad\_edid}, bool *\emph{ edid\_corrupt}}{}
Sanity check the EDID block (base or extension)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 * raw\_edid}}] \leavevmode
pointer to raw EDID block

\item[{\code{int block}}] \leavevmode
type of block to validate (0 for base, extension otherwise)

\item[{\code{bool print\_bad\_edid}}] \leavevmode
if true, dump bad EDID blocks to the console

\item[{\code{bool * edid\_corrupt}}] \leavevmode
if true, the header or checksum is invalid

\end{description}

\textbf{Description}

Validate a base or extension EDID block and optionally dump bad blocks to
the console.

\textbf{Return}

True if the block is valid, false otherwise.
\index{drm\_edid\_is\_valid (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_edid_is_valid}\pysiglinewithargsret{bool \bfcode{drm\_edid\_is\_valid}}{struct edid *\emph{ edid}}{}
sanity check EDID data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edid * edid}}] \leavevmode
EDID data

\end{description}

\textbf{Description}

Sanity-check an entire EDID record (including extensions)

\textbf{Return}

True if the EDID data is valid, false otherwise.
\index{drm\_do\_get\_edid (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_do_get_edid}\pysiglinewithargsret{struct edid * \bfcode{drm\_do\_get\_edid}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, int (*get\_edid\_block) (void\emph{ *data}, u8\emph{ *buf}, unsigned int\emph{ block}, size\_t\emph{ len}, void *\emph{ data}}{}
get EDID data using a custom EDID block read function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector we're probing

\item[{\code{int (*)(void *data, u8 *buf, unsigned int block, size\_t len) get\_edid\_block}}] \leavevmode
EDID block read function

\item[{\code{void * data}}] \leavevmode
private data passed to the block read function

\end{description}

\textbf{Description}

When the I2C adapter connected to the DDC bus is hidden behind a device that
exposes a different interface to read EDID blocks this function can be used
to get EDID data using a custom block read function.

As in the general case the DDC bus is accessible by the kernel at the I2C
level, drivers must make all reasonable efforts to expose it as an I2C
adapter and use {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_get_edid]{\emph{\code{drm\_get\_edid()}}}} instead of abusing this function.

The EDID may be overridden using debugfs override\_edid or firmare EDID
(\code{drm\_load\_edid\_firmware()} and drm.edid\_firmware parameter), in this priority
order. Having either of them bypasses actual EDID reads.

\textbf{Return}

Pointer to valid EDID or NULL if we couldn't find any.
\index{drm\_probe\_ddc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_probe_ddc}\pysiglinewithargsret{bool \bfcode{drm\_probe\_ddc}}{struct i2c\_adapter *\emph{ adapter}}{}
probe DDC presence

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C adapter to probe

\end{description}

\textbf{Return}

True on success, false on failure.
\index{drm\_get\_edid (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_get_edid}\pysiglinewithargsret{struct edid * \bfcode{drm\_get\_edid}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, struct i2c\_adapter *\emph{ adapter}}{}
get EDID data, if available

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector we're probing

\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C adapter to use for DDC

\end{description}

\textbf{Description}

Poke the given I2C channel to grab EDID data if possible.  If found,
attach it to the connector.

\textbf{Return}

Pointer to valid EDID or NULL if we couldn't find any.
\index{drm\_get\_edid\_switcheroo (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_get_edid_switcheroo}\pysiglinewithargsret{struct edid * \bfcode{drm\_get\_edid\_switcheroo}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, struct i2c\_adapter *\emph{ adapter}}{}
get EDID data for a vga\_switcheroo output

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector we're probing

\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C adapter to use for DDC

\end{description}

\textbf{Description}

Wrapper around {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_get_edid]{\emph{\code{drm\_get\_edid()}}}} for laptops with dual GPUs using one set of
outputs. The wrapper adds the requisite vga\_switcheroo calls to temporarily
switch DDC to the GPU which is retrieving EDID.

\textbf{Return}

Pointer to valid EDID or \code{NULL} if we couldn't find any.
\index{drm\_edid\_duplicate (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_edid_duplicate}\pysiglinewithargsret{struct edid * \bfcode{drm\_edid\_duplicate}}{const struct edid *\emph{ edid}}{}
duplicate an EDID and the extensions

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct edid * edid}}] \leavevmode
EDID to duplicate

\end{description}

\textbf{Return}

Pointer to duplicated EDID or NULL on allocation failure.
\index{drm\_match\_cea\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_match_cea_mode}\pysiglinewithargsret{u8 \bfcode{drm\_match\_cea\_mode}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ to\_match}}{}
look for a CEA mode matching given mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_display\_mode * to\_match}}] \leavevmode
display mode

\end{description}

\textbf{Return}

The CEA Video ID (VIC) of the mode or 0 if it isn't a CEA-861
mode.
\index{drm\_get\_cea\_aspect\_ratio (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_get_cea_aspect_ratio}\pysiglinewithargsret{enum hdmi\_picture\_aspect \bfcode{drm\_get\_cea\_aspect\_ratio}}{const u8\emph{ video\_code}}{}
get the picture aspect ratio corresponding to the input VIC from the CEA mode list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 video\_code}}] \leavevmode
ID given to each of the CEA modes

\end{description}

\textbf{Description}

Returns picture aspect ratio
\index{drm\_edid\_get\_monitor\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_edid_get_monitor_name}\pysiglinewithargsret{void \bfcode{drm\_edid\_get\_monitor\_name}}{struct edid *\emph{ edid}, char *\emph{ name}, int\emph{ bufsize}}{}
fetch the monitor name from the edid

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edid * edid}}] \leavevmode
monitor EDID information

\item[{\code{char * name}}] \leavevmode
pointer to a character array to hold the name of the monitor

\item[{\code{int bufsize}}] \leavevmode
The size of the name buffer (should be at least 14 chars.)

\end{description}
\index{drm\_edid\_to\_sad (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_edid_to_sad}\pysiglinewithargsret{int \bfcode{drm\_edid\_to\_sad}}{struct edid *\emph{ edid}, struct cea\_sad **\emph{ sads}}{}
extracts SADs from EDID

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edid * edid}}] \leavevmode
EDID to parse

\item[{\code{struct cea\_sad ** sads}}] \leavevmode
pointer that will be set to the extracted SADs

\end{description}

\textbf{Description}

Looks for CEA EDID block and extracts SADs (Short Audio Descriptors) from it.

\textbf{Note}

The returned pointer needs to be freed using \code{kfree()}.

\textbf{Return}

The number of found SADs or negative number on error.
\index{drm\_edid\_to\_speaker\_allocation (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_edid_to_speaker_allocation}\pysiglinewithargsret{int \bfcode{drm\_edid\_to\_speaker\_allocation}}{struct edid *\emph{ edid}, u8 **\emph{ sadb}}{}
extracts Speaker Allocation Data Blocks from EDID

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edid * edid}}] \leavevmode
EDID to parse

\item[{\code{u8 ** sadb}}] \leavevmode
pointer to the speaker block

\end{description}

\textbf{Description}

Looks for CEA EDID block and extracts the Speaker Allocation Data Block from it.

\textbf{Note}

The returned pointer needs to be freed using \code{kfree()}.

\textbf{Return}

The number of found Speaker Allocation Blocks or negative number on
error.
\index{drm\_av\_sync\_delay (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_av_sync_delay}\pysiglinewithargsret{int \bfcode{drm\_av\_sync\_delay}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
compute the HDMI/DP sink audio-video sync delay

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector associated with the HDMI/DP sink

\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
the display mode

\end{description}

\textbf{Return}

The HDMI/DP sink's audio-video sync delay in milliseconds or 0 if
the sink doesn't support audio or video.
\index{drm\_detect\_hdmi\_monitor (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_detect_hdmi_monitor}\pysiglinewithargsret{bool \bfcode{drm\_detect\_hdmi\_monitor}}{struct edid *\emph{ edid}}{}
detect whether monitor is HDMI

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edid * edid}}] \leavevmode
monitor EDID information

\end{description}

\textbf{Description}

Parse the CEA extension according to CEA-861-B.

\textbf{Return}

True if the monitor is HDMI, false if not or unknown.
\index{drm\_detect\_monitor\_audio (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_detect_monitor_audio}\pysiglinewithargsret{bool \bfcode{drm\_detect\_monitor\_audio}}{struct edid *\emph{ edid}}{}
check monitor audio capability

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edid * edid}}] \leavevmode
EDID block to scan

\end{description}

\textbf{Description}

Monitor should have CEA extension block.
If monitor has `basic audio', but no CEA audio blocks, it's `basic
audio' only. If there is any audio extension block and supported
audio format, assume at least `basic audio' support, even if `basic
audio' is not defined in EDID.

\textbf{Return}

True if the monitor supports audio, false otherwise.
\index{drm\_rgb\_quant\_range\_selectable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rgb_quant_range_selectable}\pysiglinewithargsret{bool \bfcode{drm\_rgb\_quant\_range\_selectable}}{struct edid *\emph{ edid}}{}
is RGB quantization range selectable?

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edid * edid}}] \leavevmode
EDID block to scan

\end{description}

\textbf{Description}

Check whether the monitor reports the RGB quantization range selection
as supported. The AVI infoframe can then be used to inform the monitor
which quantization range (full or limited) is used.

\textbf{Return}

True if the RGB quantization range is selectable, false otherwise.
\index{drm\_default\_rgb\_quant\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_default_rgb_quant_range}\pysiglinewithargsret{enum hdmi\_quantization\_range \bfcode{drm\_default\_rgb\_quant\_range}}{const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
default RGB quantization range

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
display mode

\end{description}

\textbf{Description}

Determine the default RGB quantization range for the mode,
as specified in CEA-861.

\textbf{Return}

The default RGB quantization range for the mode
\index{drm\_add\_edid\_modes (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_add_edid_modes}\pysiglinewithargsret{int \bfcode{drm\_add\_edid\_modes}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, struct edid *\emph{ edid}}{}
add modes from EDID data, if available

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector we're probing

\item[{\code{struct edid * edid}}] \leavevmode
EDID data

\end{description}

\textbf{Description}

Add the specified modes to the connector's mode list. Also fills out the
{\hyperref[gpu/drm\string-kms:c.drm_display_info]{\emph{\code{drm\_display\_info}}}} structure and ELD in \textbf{connector} with any information which
can be derived from the edid.

\textbf{Return}

The number of modes added or 0 if we couldn't find any.
\index{drm\_add\_modes\_noedid (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_add_modes_noedid}\pysiglinewithargsret{int \bfcode{drm\_add\_modes\_noedid}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, int\emph{ hdisplay}, int\emph{ vdisplay}}{}
add modes for the connectors without EDID

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector we're probing

\item[{\code{int hdisplay}}] \leavevmode
the horizontal display limit

\item[{\code{int vdisplay}}] \leavevmode
the vertical display limit

\end{description}

\textbf{Description}

Add the specified modes to the connector's mode list. Only when the
hdisplay/vdisplay is not beyond the given limit, it will be added.

\textbf{Return}

The number of modes added or 0 if we couldn't find any.
\index{drm\_set\_preferred\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_set_preferred_mode}\pysiglinewithargsret{void \bfcode{drm\_set\_preferred\_mode}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, int\emph{ hpref}, int\emph{ vpref}}{}
Sets the preferred mode of a connector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
connector whose mode list should be processed

\item[{\code{int hpref}}] \leavevmode
horizontal resolution of preferred mode

\item[{\code{int vpref}}] \leavevmode
vertical resolution of preferred mode

\end{description}

\textbf{Description}

Marks a mode as preferred if it matches the resolution specified by \textbf{hpref}
and \textbf{vpref}.
\index{drm\_hdmi\_avi\_infoframe\_from\_display\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_hdmi_avi_infoframe_from_display_mode}\pysiglinewithargsret{int \bfcode{drm\_hdmi\_avi\_infoframe\_from\_display\_mode}}{struct hdmi\_avi\_infoframe *\emph{ frame}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}, bool\emph{ is\_hdmi2\_sink}}{}
fill an HDMI AVI infoframe with data from a DRM display mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hdmi\_avi\_infoframe * frame}}] \leavevmode
HDMI AVI infoframe

\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
DRM display mode

\item[{\code{bool is\_hdmi2\_sink}}] \leavevmode
Sink is HDMI 2.0 compliant

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_hdmi\_avi\_infoframe\_quant\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_hdmi_avi_infoframe_quant_range}\pysiglinewithargsret{void \bfcode{drm\_hdmi\_avi\_infoframe\_quant\_range}}{struct hdmi\_avi\_infoframe *\emph{ frame}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}, enum hdmi\_quantization\_range\emph{ rgb\_quant\_range}, bool\emph{ rgb\_quant\_range\_selectable}, bool\emph{ is\_hdmi2\_sink}}{}
fill the HDMI AVI infoframe quantization range information

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hdmi\_avi\_infoframe * frame}}] \leavevmode
HDMI AVI infoframe

\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
DRM display mode

\item[{\code{enum hdmi\_quantization\_range rgb\_quant\_range}}] \leavevmode
RGB quantization range (Q)

\item[{\code{bool rgb\_quant\_range\_selectable}}] \leavevmode
Sink support selectable RGB quantization range (QS)

\item[{\code{bool is\_hdmi2\_sink}}] \leavevmode
HDMI 2.0 sink, which has different default recommendations

\end{description}

\textbf{Description}

Note that \textbf{is\_hdmi2\_sink} can be derived by looking at the
\code{drm\_scdc.supported} flag stored in {\hyperref[gpu/drm\string-kms:c.drm_hdmi_info]{\emph{\code{drm\_hdmi\_info.scdc}}}},
{\hyperref[gpu/drm\string-kms:c.drm_display_info]{\emph{\code{drm\_display\_info.hdmi}}}}, which can be found in {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.display\_info}}}}.
\index{drm\_hdmi\_vendor\_infoframe\_from\_display\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_hdmi_vendor_infoframe_from_display_mode}\pysiglinewithargsret{int \bfcode{drm\_hdmi\_vendor\_infoframe\_from\_display\_mode}}{struct hdmi\_vendor\_infoframe *\emph{ frame}, struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}}{}
fill an HDMI infoframe with data from a DRM display mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hdmi\_vendor\_infoframe * frame}}] \leavevmode
HDMI vendor infoframe

\item[{\code{struct drm\_connector * connector}}] \leavevmode
the connector

\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
DRM display mode

\end{description}

\textbf{Description}

Note that there's is a need to send HDMI vendor infoframes only when using a
4k or stereoscopic 3D mode. So when giving any other mode as input this
function will return -EINVAL, error that can be safely ignored.

\textbf{Return}

0 on success or a negative error code on failure.


\section{SCDC Helper Functions Reference}
\label{gpu/drm-kms-helpers:scdc-helper-functions-reference}
Status and Control Data Channel (SCDC) is a mechanism introduced by the
HDMI 2.0 specification. It is a point-to-point protocol that allows the
HDMI source and HDMI sink to exchange data. The same I2C interface that
is used to access EDID serves as the transport mechanism for SCDC.
\index{drm\_scdc\_readb (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_scdc_readb}\pysiglinewithargsret{int \bfcode{drm\_scdc\_readb}}{struct i2c\_adapter *\emph{ adapter}, u8\emph{ offset}, u8 *\emph{ value}}{}
read a single byte from SCDC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C adapter

\item[{\code{u8 offset}}] \leavevmode
offset of register to read

\item[{\code{u8 * value}}] \leavevmode
return location for the register value

\end{description}

\textbf{Description}

Reads a single byte from SCDC. This is a convenience wrapper around the
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_scdc_read]{\emph{\code{drm\_scdc\_read()}}}} function.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_scdc\_writeb (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_scdc_writeb}\pysiglinewithargsret{int \bfcode{drm\_scdc\_writeb}}{struct i2c\_adapter *\emph{ adapter}, u8\emph{ offset}, u8\emph{ value}}{}
write a single byte to SCDC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C adapter

\item[{\code{u8 offset}}] \leavevmode
offset of register to read

\item[{\code{u8 value}}] \leavevmode
return location for the register value

\end{description}

\textbf{Description}

Writes a single byte to SCDC. This is a convenience wrapper around the
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_scdc_write]{\emph{\code{drm\_scdc\_write()}}}} function.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_scdc\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_scdc_read}\pysiglinewithargsret{ssize\_t \bfcode{drm\_scdc\_read}}{struct i2c\_adapter *\emph{ adapter}, u8\emph{ offset}, void *\emph{ buffer}, size\_t\emph{ size}}{}
read a block of data from SCDC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C controller

\item[{\code{u8 offset}}] \leavevmode
start offset of block to read

\item[{\code{void * buffer}}] \leavevmode
return location for the block to read

\item[{\code{size\_t size}}] \leavevmode
size of the block to read

\end{description}

\textbf{Description}

Reads a block of data from SCDC, starting at a given offset.

\textbf{Return}

0 on success, negative error code on failure.
\index{drm\_scdc\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_scdc_write}\pysiglinewithargsret{ssize\_t \bfcode{drm\_scdc\_write}}{struct i2c\_adapter *\emph{ adapter}, u8\emph{ offset}, const void *\emph{ buffer}, size\_t\emph{ size}}{}
write a block of data to SCDC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C controller

\item[{\code{u8 offset}}] \leavevmode
start offset of block to write

\item[{\code{const void * buffer}}] \leavevmode
block of data to write

\item[{\code{size\_t size}}] \leavevmode
size of the block to write

\end{description}

\textbf{Description}

Writes a block of data to SCDC, starting at a given offset.

\textbf{Return}

0 on success, negative error code on failure.
\index{drm\_scdc\_get\_scrambling\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_scdc_get_scrambling_status}\pysiglinewithargsret{bool \bfcode{drm\_scdc\_get\_scrambling\_status}}{struct i2c\_adapter *\emph{ adapter}}{}
what is status of scrambling?

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C adapter for DDC channel

\end{description}

\textbf{Description}

Reads the scrambler status over SCDC, and checks the
scrambling status.

\textbf{Return}

True if the scrambling is enabled, false otherwise.
\index{drm\_scdc\_set\_scrambling (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_scdc_set_scrambling}\pysiglinewithargsret{bool \bfcode{drm\_scdc\_set\_scrambling}}{struct i2c\_adapter *\emph{ adapter}, bool\emph{ enable}}{}
enable scrambling

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C adapter for DDC channel

\item[{\code{bool enable}}] \leavevmode
bool to indicate if scrambling is to be enabled/disabled

\end{description}

\textbf{Description}

Writes the TMDS config register over SCDC channel, and:
enables scrambling when enable = 1
disables scrambling when enable = 0

\textbf{Return}

True if scrambling is set/reset successfully, false otherwise.
\index{drm\_scdc\_set\_high\_tmds\_clock\_ratio (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_scdc_set_high_tmds_clock_ratio}\pysiglinewithargsret{bool \bfcode{drm\_scdc\_set\_high\_tmds\_clock\_ratio}}{struct i2c\_adapter *\emph{ adapter}, bool\emph{ set}}{}
set TMDS clock ratio

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
I2C adapter for DDC channel

\item[{\code{bool set}}] \leavevmode
ret or reset the high clock ratio

\end{description}

\textbf{Description}
\begin{quote}
\begin{description}
\item[{TMDS clock ratio calculations go like this:}] \leavevmode
TMDS character = 10 bit TMDS encoded value

TMDS character rate = The rate at which TMDS characters are
transmitted (Mcsc)

TMDS bit rate = 10x TMDS character rate

\item[{As per the spec:}] \leavevmode
TMDS clock rate for pixel clock \textless{} 340 MHz = 1x the character
rate = 1/10 pixel clock rate

TMDS clock rate for pixel clock \textgreater{} 340 MHz = 0.25x the character
rate = 1/40 pixel clock rate

\item[{Writes to the TMDS config register over SCDC channel, and:}] \leavevmode
sets TMDS clock ratio to 1/40 when set = 1

sets TMDS clock ratio to 1/10 when set = 0

\end{description}
\end{quote}

\textbf{Return}

True if write is successful, false otherwise.


\section{Rectangle Utilities Reference}
\label{gpu/drm-kms-helpers:rectangle-utilities-reference}
Utility functions to help manage rectangular areas for
clipping, scaling, etc. calculations.
\index{drm\_rect (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rect}\pysigline{struct \bfcode{drm\_rect}}
two dimensional rectangle

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}rect \PYGZob{}
  int x1, y1, x2, y2;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{x1}}] \leavevmode
horizontal starting coordinate (inclusive)

\item[{\code{y1}}] \leavevmode
vertical starting coordinate (inclusive)

\item[{\code{x2}}] \leavevmode
horizontal ending coordinate (exclusive)

\item[{\code{y2}}] \leavevmode
vertical ending coordinate (exclusive)

\end{description}
\index{DRM\_RECT\_FMT (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.DRM_RECT_FMT}\pysiglinewithargsret{\bfcode{DRM\_RECT\_FMT}}{}{}
printf string for {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{\code{struct drm\_rect}}}}

\end{fulllineitems}


\textbf{Parameters}
\index{DRM\_RECT\_ARG (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.DRM_RECT_ARG}\pysiglinewithargsret{\bfcode{DRM\_RECT\_ARG}}{\emph{r}}{}
printf arguments for {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{\code{struct drm\_rect}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{r}}] \leavevmode
rectangle struct

\end{description}
\index{DRM\_RECT\_FP\_FMT (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.DRM_RECT_FP_FMT}\pysiglinewithargsret{\bfcode{DRM\_RECT\_FP\_FMT}}{}{}
printf string for {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{\code{struct drm\_rect}}}} in 16.16 fixed point

\end{fulllineitems}


\textbf{Parameters}
\index{DRM\_RECT\_FP\_ARG (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.DRM_RECT_FP_ARG}\pysiglinewithargsret{\bfcode{DRM\_RECT\_FP\_ARG}}{\emph{r}}{}
printf arguments for {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{\code{struct drm\_rect}}}} in 16.16 fixed point

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{r}}] \leavevmode
rectangle struct

\end{description}

\textbf{Description}

This is useful for e.g. printing plane source rectangles, which are in 16.16
fixed point.
\index{drm\_rect\_adjust\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rect_adjust_size}\pysiglinewithargsret{void \bfcode{drm\_rect\_adjust\_size}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ r}, int\emph{ dw}, int\emph{ dh}}{}
adjust the size of the rectangle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_rect * r}}] \leavevmode
rectangle to be adjusted

\item[{\code{int dw}}] \leavevmode
horizontal adjustment

\item[{\code{int dh}}] \leavevmode
vertical adjustment

\end{description}

\textbf{Description}

Change the size of rectangle \textbf{r} by \textbf{dw} in the horizontal direction,
and by \textbf{dh} in the vertical direction, while keeping the center
of \textbf{r} stationary.

Positive \textbf{dw} and \textbf{dh} increase the size, negative values decrease it.
\index{drm\_rect\_translate (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rect_translate}\pysiglinewithargsret{void \bfcode{drm\_rect\_translate}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ r}, int\emph{ dx}, int\emph{ dy}}{}
translate the rectangle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_rect * r}}] \leavevmode
rectangle to be tranlated

\item[{\code{int dx}}] \leavevmode
horizontal translation

\item[{\code{int dy}}] \leavevmode
vertical translation

\end{description}

\textbf{Description}

Move rectangle \textbf{r} by \textbf{dx} in the horizontal direction,
and by \textbf{dy} in the vertical direction.
\index{drm\_rect\_downscale (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rect_downscale}\pysiglinewithargsret{void \bfcode{drm\_rect\_downscale}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ r}, int\emph{ horz}, int\emph{ vert}}{}
downscale a rectangle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_rect * r}}] \leavevmode
rectangle to be downscaled

\item[{\code{int horz}}] \leavevmode
horizontal downscale factor

\item[{\code{int vert}}] \leavevmode
vertical downscale factor

\end{description}

\textbf{Description}

Divide the coordinates of rectangle \textbf{r} by \textbf{horz} and \textbf{vert}.
\index{drm\_rect\_width (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rect_width}\pysiglinewithargsret{int \bfcode{drm\_rect\_width}}{const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ r}}{}
determine the rectangle width

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_rect * r}}] \leavevmode
rectangle whose width is returned

\end{description}

\textbf{Return}

The width of the rectangle.
\index{drm\_rect\_height (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rect_height}\pysiglinewithargsret{int \bfcode{drm\_rect\_height}}{const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ r}}{}
determine the rectangle height

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_rect * r}}] \leavevmode
rectangle whose height is returned

\end{description}

\textbf{Return}

The height of the rectangle.
\index{drm\_rect\_visible (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rect_visible}\pysiglinewithargsret{bool \bfcode{drm\_rect\_visible}}{const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ r}}{}
determine if the the rectangle is visible

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_rect * r}}] \leavevmode
rectangle whose visibility is returned

\end{description}

\textbf{Return}

\code{true} if the rectangle is visible, \code{false} otherwise.
\index{drm\_rect\_equals (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rect_equals}\pysiglinewithargsret{bool \bfcode{drm\_rect\_equals}}{const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ r1}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ r2}}{}
determine if two rectangles are equal

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_rect * r1}}] \leavevmode
first rectangle

\item[{\code{const struct drm\_rect * r2}}] \leavevmode
second rectangle

\end{description}

\textbf{Return}

\code{true} if the rectangles are equal, \code{false} otherwise.
\index{drm\_rect\_intersect (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rect_intersect}\pysiglinewithargsret{bool \bfcode{drm\_rect\_intersect}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ r1}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ r2}}{}
intersect two rectangles

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_rect * r1}}] \leavevmode
first rectangle

\item[{\code{const struct drm\_rect * r2}}] \leavevmode
second rectangle

\end{description}

\textbf{Description}

Calculate the intersection of rectangles \textbf{r1} and \textbf{r2}.
\textbf{r1} will be overwritten with the intersection.

\textbf{Return}

\code{true} if rectangle \textbf{r1} is still visible after the operation,
\code{false} otherwise.
\index{drm\_rect\_clip\_scaled (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rect_clip_scaled}\pysiglinewithargsret{bool \bfcode{drm\_rect\_clip\_scaled}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ src}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ dst}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ clip}, int\emph{ hscale}, int\emph{ vscale}}{}
perform a scaled clip operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_rect * src}}] \leavevmode
source window rectangle

\item[{\code{struct drm\_rect * dst}}] \leavevmode
destination window rectangle

\item[{\code{const struct drm\_rect * clip}}] \leavevmode
clip rectangle

\item[{\code{int hscale}}] \leavevmode
horizontal scaling factor

\item[{\code{int vscale}}] \leavevmode
vertical scaling factor

\end{description}

\textbf{Description}

Clip rectangle \textbf{dst} by rectangle \textbf{clip}. Clip rectangle \textbf{src} by the
same amounts multiplied by \textbf{hscale} and \textbf{vscale}.

\textbf{Return}

\code{true} if rectangle \textbf{dst} is still visible after being clipped,
\code{false} otherwise
\index{drm\_rect\_calc\_hscale (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rect_calc_hscale}\pysiglinewithargsret{int \bfcode{drm\_rect\_calc\_hscale}}{const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ src}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ dst}, int\emph{ min\_hscale}, int\emph{ max\_hscale}}{}
calculate the horizontal scaling factor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_rect * src}}] \leavevmode
source window rectangle

\item[{\code{const struct drm\_rect * dst}}] \leavevmode
destination window rectangle

\item[{\code{int min\_hscale}}] \leavevmode
minimum allowed horizontal scaling factor

\item[{\code{int max\_hscale}}] \leavevmode
maximum allowed horizontal scaling factor

\end{description}

\textbf{Description}

Calculate the horizontal scaling factor as
(\textbf{src} width) / (\textbf{dst} width).

\textbf{Return}

The horizontal scaling factor, or errno of out of limits.
\index{drm\_rect\_calc\_vscale (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rect_calc_vscale}\pysiglinewithargsret{int \bfcode{drm\_rect\_calc\_vscale}}{const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ src}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ dst}, int\emph{ min\_vscale}, int\emph{ max\_vscale}}{}
calculate the vertical scaling factor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_rect * src}}] \leavevmode
source window rectangle

\item[{\code{const struct drm\_rect * dst}}] \leavevmode
destination window rectangle

\item[{\code{int min\_vscale}}] \leavevmode
minimum allowed vertical scaling factor

\item[{\code{int max\_vscale}}] \leavevmode
maximum allowed vertical scaling factor

\end{description}

\textbf{Description}

Calculate the vertical scaling factor as
(\textbf{src} height) / (\textbf{dst} height).

\textbf{Return}

The vertical scaling factor, or errno of out of limits.
\index{drm\_rect\_calc\_hscale\_relaxed (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rect_calc_hscale_relaxed}\pysiglinewithargsret{int \bfcode{drm\_rect\_calc\_hscale\_relaxed}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ src}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ dst}, int\emph{ min\_hscale}, int\emph{ max\_hscale}}{}
calculate the horizontal scaling factor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_rect * src}}] \leavevmode
source window rectangle

\item[{\code{struct drm\_rect * dst}}] \leavevmode
destination window rectangle

\item[{\code{int min\_hscale}}] \leavevmode
minimum allowed horizontal scaling factor

\item[{\code{int max\_hscale}}] \leavevmode
maximum allowed horizontal scaling factor

\end{description}

\textbf{Description}

Calculate the horizontal scaling factor as
(\textbf{src} width) / (\textbf{dst} width).

If the calculated scaling factor is below \textbf{min\_vscale},
decrease the height of rectangle \textbf{dst} to compensate.

If the calculated scaling factor is above \textbf{max\_vscale},
decrease the height of rectangle \textbf{src} to compensate.

\textbf{Return}

The horizontal scaling factor.
\index{drm\_rect\_calc\_vscale\_relaxed (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rect_calc_vscale_relaxed}\pysiglinewithargsret{int \bfcode{drm\_rect\_calc\_vscale\_relaxed}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ src}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ dst}, int\emph{ min\_vscale}, int\emph{ max\_vscale}}{}
calculate the vertical scaling factor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_rect * src}}] \leavevmode
source window rectangle

\item[{\code{struct drm\_rect * dst}}] \leavevmode
destination window rectangle

\item[{\code{int min\_vscale}}] \leavevmode
minimum allowed vertical scaling factor

\item[{\code{int max\_vscale}}] \leavevmode
maximum allowed vertical scaling factor

\end{description}

\textbf{Description}

Calculate the vertical scaling factor as
(\textbf{src} height) / (\textbf{dst} height).

If the calculated scaling factor is below \textbf{min\_vscale},
decrease the height of rectangle \textbf{dst} to compensate.

If the calculated scaling factor is above \textbf{max\_vscale},
decrease the height of rectangle \textbf{src} to compensate.

\textbf{Return}

The vertical scaling factor.
\index{drm\_rect\_debug\_print (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rect_debug_print}\pysiglinewithargsret{void \bfcode{drm\_rect\_debug\_print}}{const char *\emph{ prefix}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ r}, bool\emph{ fixed\_point}}{}
print the rectangle information

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * prefix}}] \leavevmode
prefix string

\item[{\code{const struct drm\_rect * r}}] \leavevmode
rectangle to print

\item[{\code{bool fixed\_point}}] \leavevmode
rectangle is in 16.16 fixed point format

\end{description}
\index{drm\_rect\_rotate (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rect_rotate}\pysiglinewithargsret{void \bfcode{drm\_rect\_rotate}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ r}, int\emph{ width}, int\emph{ height}, unsigned int\emph{ rotation}}{}
Rotate the rectangle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_rect * r}}] \leavevmode
rectangle to be rotated

\item[{\code{int width}}] \leavevmode
Width of the coordinate space

\item[{\code{int height}}] \leavevmode
Height of the coordinate space

\item[{\code{unsigned int rotation}}] \leavevmode
Transformation to be applied

\end{description}

\textbf{Description}

Apply \textbf{rotation} to the coordinates of rectangle \textbf{r}.

\textbf{width} and \textbf{height} combined with \textbf{rotation} define
the location of the new origin.

\textbf{width} correcsponds to the horizontal and \textbf{height}
to the vertical axis of the untransformed coordinate
space.
\index{drm\_rect\_rotate\_inv (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_rect_rotate_inv}\pysiglinewithargsret{void \bfcode{drm\_rect\_rotate\_inv}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ r}, int\emph{ width}, int\emph{ height}, unsigned int\emph{ rotation}}{}
Inverse rotate the rectangle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_rect * r}}] \leavevmode
rectangle to be rotated

\item[{\code{int width}}] \leavevmode
Width of the coordinate space

\item[{\code{int height}}] \leavevmode
Height of the coordinate space

\item[{\code{unsigned int rotation}}] \leavevmode
Transformation whose inverse is to be applied

\end{description}

\textbf{Description}

Apply the inverse of \textbf{rotation} to the coordinates
of rectangle \textbf{r}.

\textbf{width} and \textbf{height} combined with \textbf{rotation} define
the location of the new origin.

\textbf{width} correcsponds to the horizontal and \textbf{height}
to the vertical axis of the original untransformed
coordinate space, so that you never have to flip
them when doing a rotatation and its inverse.
That is, if you do

\begin{Verbatim}[commandchars=\\\{\}]
DRM\PYGZus{}MODE\PYGZus{}PROP\PYGZus{}ROTATE(:c:type:{}`r{}`, width, height, rotation);
DRM\PYGZus{}MODE\PYGZus{}ROTATE\PYGZus{}inv(:c:type:{}`r{}`, width, height, rotation);
\end{Verbatim}

you will always get back the original rectangle.


\section{HDMI Infoframes Helper Reference}
\label{gpu/drm-kms-helpers:hdmi-infoframes-helper-reference}
Strictly speaking this is not a DRM helper library but generally useable
by any driver interfacing with HDMI outputs like v4l or alsa drivers.
But it nicely fits into the overall topic of mode setting helper
libraries and hence is also included here.
\index{hdmi\_infoframe (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.hdmi_infoframe}\pysigline{union \bfcode{hdmi\_infoframe}}
overall union of all abstract infoframe representations

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
union hdmi\PYGZus{}infoframe \PYGZob{}
  struct hdmi\PYGZus{}any\PYGZus{}infoframe any;
  struct hdmi\PYGZus{}avi\PYGZus{}infoframe avi;
  struct hdmi\PYGZus{}spd\PYGZus{}infoframe spd;
  union hdmi\PYGZus{}vendor\PYGZus{}any\PYGZus{}infoframe vendor;
  struct hdmi\PYGZus{}audio\PYGZus{}infoframe audio;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{any}}] \leavevmode
generic infoframe

\item[{\code{avi}}] \leavevmode
avi infoframe

\item[{\code{spd}}] \leavevmode
spd infoframe

\item[{\code{vendor}}] \leavevmode
union of all vendor infoframes

\item[{\code{audio}}] \leavevmode
audio infoframe

\end{description}

\textbf{Description}

This is used by the generic pack function. This works since all infoframes
have the same header which also indicates which type of infoframe should be
packed.
\index{hdmi\_avi\_infoframe\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.hdmi_avi_infoframe_init}\pysiglinewithargsret{int \bfcode{hdmi\_avi\_infoframe\_init}}{struct hdmi\_avi\_infoframe *\emph{ frame}}{}
initialize an HDMI AVI infoframe

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hdmi\_avi\_infoframe * frame}}] \leavevmode
HDMI AVI infoframe

\end{description}

\textbf{Description}

Returns 0 on success or a negative error code on failure.
\index{hdmi\_avi\_infoframe\_pack (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.hdmi_avi_infoframe_pack}\pysiglinewithargsret{ssize\_t \bfcode{hdmi\_avi\_infoframe\_pack}}{struct hdmi\_avi\_infoframe *\emph{ frame}, void *\emph{ buffer}, size\_t\emph{ size}}{}
write HDMI AVI infoframe to binary buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hdmi\_avi\_infoframe * frame}}] \leavevmode
HDMI AVI infoframe

\item[{\code{void * buffer}}] \leavevmode
destination buffer

\item[{\code{size\_t size}}] \leavevmode
size of buffer

\end{description}

\textbf{Description}

Packs the information contained in the \textbf{frame} structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.

Returns the number of bytes packed into the binary buffer or a negative
error code on failure.
\index{hdmi\_spd\_infoframe\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.hdmi_spd_infoframe_init}\pysiglinewithargsret{int \bfcode{hdmi\_spd\_infoframe\_init}}{struct hdmi\_spd\_infoframe *\emph{ frame}, const char *\emph{ vendor}, const char *\emph{ product}}{}
initialize an HDMI SPD infoframe

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hdmi\_spd\_infoframe * frame}}] \leavevmode
HDMI SPD infoframe

\item[{\code{const char * vendor}}] \leavevmode
vendor string

\item[{\code{const char * product}}] \leavevmode
product string

\end{description}

\textbf{Description}

Returns 0 on success or a negative error code on failure.
\index{hdmi\_spd\_infoframe\_pack (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.hdmi_spd_infoframe_pack}\pysiglinewithargsret{ssize\_t \bfcode{hdmi\_spd\_infoframe\_pack}}{struct hdmi\_spd\_infoframe *\emph{ frame}, void *\emph{ buffer}, size\_t\emph{ size}}{}
write HDMI SPD infoframe to binary buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hdmi\_spd\_infoframe * frame}}] \leavevmode
HDMI SPD infoframe

\item[{\code{void * buffer}}] \leavevmode
destination buffer

\item[{\code{size\_t size}}] \leavevmode
size of buffer

\end{description}

\textbf{Description}

Packs the information contained in the \textbf{frame} structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.

Returns the number of bytes packed into the binary buffer or a negative
error code on failure.
\index{hdmi\_audio\_infoframe\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.hdmi_audio_infoframe_init}\pysiglinewithargsret{int \bfcode{hdmi\_audio\_infoframe\_init}}{struct hdmi\_audio\_infoframe *\emph{ frame}}{}
initialize an HDMI audio infoframe

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hdmi\_audio\_infoframe * frame}}] \leavevmode
HDMI audio infoframe

\end{description}

\textbf{Description}

Returns 0 on success or a negative error code on failure.
\index{hdmi\_audio\_infoframe\_pack (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.hdmi_audio_infoframe_pack}\pysiglinewithargsret{ssize\_t \bfcode{hdmi\_audio\_infoframe\_pack}}{struct hdmi\_audio\_infoframe *\emph{ frame}, void *\emph{ buffer}, size\_t\emph{ size}}{}
write HDMI audio infoframe to binary buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hdmi\_audio\_infoframe * frame}}] \leavevmode
HDMI audio infoframe

\item[{\code{void * buffer}}] \leavevmode
destination buffer

\item[{\code{size\_t size}}] \leavevmode
size of buffer

\end{description}

\textbf{Description}

Packs the information contained in the \textbf{frame} structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.

Returns the number of bytes packed into the binary buffer or a negative
error code on failure.
\index{hdmi\_vendor\_infoframe\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.hdmi_vendor_infoframe_init}\pysiglinewithargsret{int \bfcode{hdmi\_vendor\_infoframe\_init}}{struct hdmi\_vendor\_infoframe *\emph{ frame}}{}
initialize an HDMI vendor infoframe

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hdmi\_vendor\_infoframe * frame}}] \leavevmode
HDMI vendor infoframe

\end{description}

\textbf{Description}

Returns 0 on success or a negative error code on failure.
\index{hdmi\_vendor\_infoframe\_pack (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.hdmi_vendor_infoframe_pack}\pysiglinewithargsret{ssize\_t \bfcode{hdmi\_vendor\_infoframe\_pack}}{struct hdmi\_vendor\_infoframe *\emph{ frame}, void *\emph{ buffer}, size\_t\emph{ size}}{}
write a HDMI vendor infoframe to binary buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hdmi\_vendor\_infoframe * frame}}] \leavevmode
HDMI infoframe

\item[{\code{void * buffer}}] \leavevmode
destination buffer

\item[{\code{size\_t size}}] \leavevmode
size of buffer

\end{description}

\textbf{Description}

Packs the information contained in the \textbf{frame} structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.

Returns the number of bytes packed into the binary buffer or a negative
error code on failure.
\index{hdmi\_infoframe\_pack (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.hdmi_infoframe_pack}\pysiglinewithargsret{ssize\_t \bfcode{hdmi\_infoframe\_pack}}{union {\hyperref[gpu/drm\string-kms\string-helpers:c.hdmi_infoframe]{\emph{hdmi\_infoframe}}} *\emph{ frame}, void *\emph{ buffer}, size\_t\emph{ size}}{}
write a HDMI infoframe to binary buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{union hdmi\_infoframe * frame}}] \leavevmode
HDMI infoframe

\item[{\code{void * buffer}}] \leavevmode
destination buffer

\item[{\code{size\_t size}}] \leavevmode
size of buffer

\end{description}

\textbf{Description}

Packs the information contained in the \textbf{frame} structure into a binary
representation that can be written into the corresponding controller
registers. Also computes the checksum as required by section 5.3.5 of
the HDMI 1.4 specification.

Returns the number of bytes packed into the binary buffer or a negative
error code on failure.
\index{hdmi\_infoframe\_log (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.hdmi_infoframe_log}\pysiglinewithargsret{void \bfcode{hdmi\_infoframe\_log}}{const char *\emph{ level}, struct device *\emph{ dev}, union {\hyperref[gpu/drm\string-kms\string-helpers:c.hdmi_infoframe]{\emph{hdmi\_infoframe}}} *\emph{ frame}}{}
log info of HDMI infoframe

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * level}}] \leavevmode
logging level

\item[{\code{struct device * dev}}] \leavevmode
device

\item[{\code{union hdmi\_infoframe * frame}}] \leavevmode
HDMI infoframe

\end{description}
\index{hdmi\_infoframe\_unpack (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.hdmi_infoframe_unpack}\pysiglinewithargsret{int \bfcode{hdmi\_infoframe\_unpack}}{union {\hyperref[gpu/drm\string-kms\string-helpers:c.hdmi_infoframe]{\emph{hdmi\_infoframe}}} *\emph{ frame}, void *\emph{ buffer}}{}
unpack binary buffer to a HDMI infoframe

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{union hdmi\_infoframe * frame}}] \leavevmode
HDMI infoframe

\item[{\code{void * buffer}}] \leavevmode
source buffer

\end{description}

\textbf{Description}

Unpacks the information contained in binary buffer \textbf{buffer} into a structured
\textbf{frame} of a HDMI infoframe.
Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4
specification.

Returns 0 on success or a negative error code on failure.


\section{Flip-work Helper Reference}
\label{gpu/drm-kms-helpers:flip-work-helper-reference}
Util to queue up work to run from work-queue context after flip/vblank.
Typically this can be used to defer unref of framebuffer's, cursor
bo's, etc until after vblank.  The APIs are all thread-safe.
Moreover, drm\_flip\_work\_queue\_task and drm\_flip\_work\_queue can be called
in atomic context.
\index{drm\_flip\_task (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_flip_task}\pysigline{struct \bfcode{drm\_flip\_task}}
flip work task

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}flip\PYGZus{}task \PYGZob{}
  struct list\PYGZus{}head node;
  void *data;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{node}}] \leavevmode
list entry element

\item[{\code{data}}] \leavevmode
data to pass to {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_flip_work]{\emph{\code{drm\_flip\_work.func}}}}

\end{description}
\index{drm\_flip\_work (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_flip_work}\pysigline{struct \bfcode{drm\_flip\_work}}
flip work queue

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}flip\PYGZus{}work \PYGZob{}
  const char *name;
  drm\PYGZus{}flip\PYGZus{}func\PYGZus{}t func;
  struct work\PYGZus{}struct worker;
  struct list\PYGZus{}head queued;
  struct list\PYGZus{}head commited;
  spinlock\PYGZus{}t lock;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
debug name

\item[{\code{func}}] \leavevmode
callback fxn called for each committed item

\item[{\code{worker}}] \leavevmode
worker which calls \textbf{func}

\item[{\code{queued}}] \leavevmode
queued tasks

\item[{\code{commited}}] \leavevmode
commited tasks

\item[{\code{lock}}] \leavevmode
lock to access queued and commited lists

\end{description}
\index{drm\_flip\_work\_allocate\_task (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_flip_work_allocate_task}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_flip_task]{\emph{drm\_flip\_task}}} * \bfcode{drm\_flip\_work\_allocate\_task}}{void *\emph{ data}, gfp\_t\emph{ flags}}{}
allocate a flip-work task

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * data}}] \leavevmode
data associated to the task

\item[{\code{gfp\_t flags}}] \leavevmode
allocator flags

\end{description}

\textbf{Description}

Allocate a drm\_flip\_task object and attach private data to it.
\index{drm\_flip\_work\_queue\_task (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_flip_work_queue_task}\pysiglinewithargsret{void \bfcode{drm\_flip\_work\_queue\_task}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_flip_work]{\emph{drm\_flip\_work}}} *\emph{ work}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_flip_task]{\emph{drm\_flip\_task}}} *\emph{ task}}{}
queue a specific task

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_flip\_work * work}}] \leavevmode
the flip-work

\item[{\code{struct drm\_flip\_task * task}}] \leavevmode
the task to handle

\end{description}

\textbf{Description}

Queues task, that will later be run (passed back to drm\_flip\_func\_t
func) on a work queue after {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_flip_work_commit]{\emph{\code{drm\_flip\_work\_commit()}}}} is called.
\index{drm\_flip\_work\_queue (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_flip_work_queue}\pysiglinewithargsret{void \bfcode{drm\_flip\_work\_queue}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_flip_work]{\emph{drm\_flip\_work}}} *\emph{ work}, void *\emph{ val}}{}
queue work

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_flip\_work * work}}] \leavevmode
the flip-work

\item[{\code{void * val}}] \leavevmode
the value to queue

\end{description}

\textbf{Description}

Queues work, that will later be run (passed back to drm\_flip\_func\_t
func) on a work queue after {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_flip_work_commit]{\emph{\code{drm\_flip\_work\_commit()}}}} is called.
\index{drm\_flip\_work\_commit (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_flip_work_commit}\pysiglinewithargsret{void \bfcode{drm\_flip\_work\_commit}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_flip_work]{\emph{drm\_flip\_work}}} *\emph{ work}, struct workqueue\_struct *\emph{ wq}}{}
commit queued work

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_flip\_work * work}}] \leavevmode
the flip-work

\item[{\code{struct workqueue\_struct * wq}}] \leavevmode
the work-queue to run the queued work on

\end{description}

\textbf{Description}

Trigger work previously queued by {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_flip_work_queue]{\emph{\code{drm\_flip\_work\_queue()}}}} to run
on a workqueue.  The typical usage would be to queue work (via
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_flip_work_queue]{\emph{\code{drm\_flip\_work\_queue()}}}}) at any point (from vblank irq and/or
prior), and then from vblank irq commit the queued work.
\index{drm\_flip\_work\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_flip_work_init}\pysiglinewithargsret{void \bfcode{drm\_flip\_work\_init}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_flip_work]{\emph{drm\_flip\_work}}} *\emph{ work}, const char *\emph{ name}, drm\_flip\_func\_t\emph{ func}}{}
initialize flip-work

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_flip\_work * work}}] \leavevmode
the flip-work to initialize

\item[{\code{const char * name}}] \leavevmode
debug name

\item[{\code{drm\_flip\_func\_t func}}] \leavevmode
the callback work function

\end{description}

\textbf{Description}

Initializes/allocates resources for the flip-work
\index{drm\_flip\_work\_cleanup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_flip_work_cleanup}\pysiglinewithargsret{void \bfcode{drm\_flip\_work\_cleanup}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_flip_work]{\emph{drm\_flip\_work}}} *\emph{ work}}{}
cleans up flip-work

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_flip\_work * work}}] \leavevmode
the flip-work to cleanup

\end{description}

\textbf{Description}

Destroy resources allocated for the flip-work


\section{Auxiliary Modeset Helpers}
\label{gpu/drm-kms-helpers:auxiliary-modeset-helpers}
This helper library contains various one-off functions which don't really fit
anywhere else in the DRM modeset helper library.
\index{drm\_helper\_move\_panel\_connectors\_to\_head (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_helper_move_panel_connectors_to_head}\pysiglinewithargsret{void \bfcode{drm\_helper\_move\_panel\_connectors\_to\_head}}{struct drm\_device *\emph{ dev}}{}
move panels to the front in the connector list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device to operate on

\end{description}

\textbf{Description}

Some userspace presumes that the first connected connector is the main
display, where it's supposed to display e.g. the login screen. For
laptops, this should be the main panel. Use this function to sort all
(eDP/LVDS/DSI) panels to the front of the connector list, instead of
painstakingly trying to initialize them in the right order.
\index{drm\_helper\_mode\_fill\_fb\_struct (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_helper_mode_fill_fb_struct}\pysiglinewithargsret{void \bfcode{drm\_helper\_mode\_fill\_fb\_struct}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, const struct drm\_mode\_fb\_cmd2 *\emph{ mode\_cmd}}{}
fill out framebuffer metadata

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
drm\_framebuffer object to fill out

\item[{\code{const struct drm\_mode\_fb\_cmd2 * mode\_cmd}}] \leavevmode
metadata from the userspace fb creation request

\end{description}

\textbf{Description}

This helper can be used in a drivers fb\_create callback to pre-fill the fb's
metadata fields.
\index{drm\_crtc\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_crtc_init}\pysiglinewithargsret{int \bfcode{drm\_crtc\_init}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, const struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{drm\_crtc\_funcs}}} *\emph{ funcs}}{}
Legacy CRTC initialization function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
CRTC object to init

\item[{\code{const struct drm\_crtc\_funcs * funcs}}] \leavevmode
callbacks for the new CRTC

\end{description}

\textbf{Description}

Initialize a CRTC object with a default helper-provided primary plane and no
cursor plane.

\textbf{Return}

Zero on success, error code on failure.
\index{drm\_mode\_config\_helper\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_mode_config_helper_suspend}\pysiglinewithargsret{int \bfcode{drm\_mode\_config\_helper\_suspend}}{struct drm\_device *\emph{ dev}}{}
Modeset suspend helper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

This helper function takes care of suspending the modeset side. It disables
output polling if initialized, suspends fbdev if used and finally calls
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_suspend]{\emph{\code{drm\_atomic\_helper\_suspend()}}}}.
If suspending fails, fbdev and polling is re-enabled.

\textbf{Return}

Zero on success, negative error code on error.

See also:
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_kms_helper_poll_disable]{\emph{\code{drm\_kms\_helper\_poll\_disable()}}}} and {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_set_suspend_unlocked]{\emph{\code{drm\_fb\_helper\_set\_suspend\_unlocked()}}}}.
\index{drm\_mode\_config\_helper\_resume (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_mode_config_helper_resume}\pysiglinewithargsret{int \bfcode{drm\_mode\_config\_helper\_resume}}{struct drm\_device *\emph{ dev}}{}
Modeset resume helper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

This helper function takes care of resuming the modeset side. It calls
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_resume]{\emph{\code{drm\_atomic\_helper\_resume()}}}}, resumes fbdev if used and enables output polling
if initiaized.

\textbf{Return}

Zero on success, negative error code on error.

See also:
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_set_suspend_unlocked]{\emph{\code{drm\_fb\_helper\_set\_suspend\_unlocked()}}}} and {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_kms_helper_poll_enable]{\emph{\code{drm\_kms\_helper\_poll\_enable()}}}}.


\section{Framebuffer GEM Helper Reference}
\label{gpu/drm-kms-helpers:framebuffer-gem-helper-reference}
This library provides helpers for drivers that don't subclass
{\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}} and use {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{\code{drm\_gem\_object}}}} for their backing storage.

Drivers without additional needs to validate framebuffers can simply use
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_gem_fb_create]{\emph{\code{drm\_gem\_fb\_create()}}}} and everything is wired up automatically. Other drivers
can use all parts independently.
\index{drm\_gem\_fb\_get\_obj (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_gem_fb_get_obj}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} * \bfcode{drm\_gem\_fb\_get\_obj}}{struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, unsigned int\emph{ plane}}{}
Get GEM object backing the framebuffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
Framebuffer

\item[{\code{unsigned int plane}}] \leavevmode
Plane index

\end{description}

\textbf{Description}

No additional reference is taken beyond the one that the \code{drm\_frambuffer}
already holds.

\textbf{Return}

Pointer to {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{\code{drm\_gem\_object}}}} for the given framebuffer and plane index or NULL
if it does not exist.
\index{drm\_gem\_fb\_destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_gem_fb_destroy}\pysiglinewithargsret{void \bfcode{drm\_gem\_fb\_destroy}}{struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}}{}
Free GEM backed framebuffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
Framebuffer

\end{description}

\textbf{Description}

Frees a GEM backed framebuffer with its backing buffer(s) and the structure
itself. Drivers can use this as their {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_funcs]{\emph{\code{drm\_framebuffer\_funcs-\textgreater{}destroy}}}}
callback.
\index{drm\_gem\_fb\_create\_handle (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_gem_fb_create_handle}\pysiglinewithargsret{int \bfcode{drm\_gem\_fb\_create\_handle}}{struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file}, unsigned int *\emph{ handle}}{}
Create handle for GEM backed framebuffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
Framebuffer

\item[{\code{struct drm\_file * file}}] \leavevmode
DRM file to register the handle for

\item[{\code{unsigned int * handle}}] \leavevmode
Pointer to return the created handle

\end{description}

\textbf{Description}

This function creates a handle for the GEM object backing the framebuffer.
Drivers can use this as their {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_funcs]{\emph{\code{drm\_framebuffer\_funcs-\textgreater{}create\_handle}}}}
callback. The GETFB IOCTL calls into this callback.

\textbf{Return}

0 on success or a negative error code on failure.
\index{drm\_gem\_fb\_create\_with\_funcs (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_gem_fb_create_with_funcs}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} * \bfcode{drm\_gem\_fb\_create\_with\_funcs}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file}, const struct drm\_mode\_fb\_cmd2 *\emph{ mode\_cmd}, const struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_funcs]{\emph{drm\_framebuffer\_funcs}}} *\emph{ funcs}}{}
Helper function for the {\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.fb\_create}}}} callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_file * file}}] \leavevmode
DRM file that holds the GEM handle(s) backing the framebuffer

\item[{\code{const struct drm\_mode\_fb\_cmd2 * mode\_cmd}}] \leavevmode
Metadata from the userspace framebuffer creation request

\item[{\code{const struct drm\_framebuffer\_funcs * funcs}}] \leavevmode
vtable to be used for the new framebuffer object

\end{description}

\textbf{Description}

This can be used to set {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_funcs]{\emph{\code{drm\_framebuffer\_funcs}}}} for drivers that need the
{\hyperref[gpu/drm\string-kms:c.drm_framebuffer_funcs]{\emph{\code{drm\_framebuffer\_funcs.dirty}}}} callback. Use {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_gem_fb_create]{\emph{\code{drm\_gem\_fb\_create()}}}} if you don't
need to change {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_funcs]{\emph{\code{drm\_framebuffer\_funcs}}}}.
The function does buffer size validation.

\textbf{Return}

Pointer to a {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}} on success or an error pointer on failure.
\index{drm\_gem\_fb\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_gem_fb_create}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} * \bfcode{drm\_gem\_fb\_create}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file}, const struct drm\_mode\_fb\_cmd2 *\emph{ mode\_cmd}}{}
Helper function for the {\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.fb\_create}}}} callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_file * file}}] \leavevmode
DRM file that holds the GEM handle(s) backing the framebuffer

\item[{\code{const struct drm\_mode\_fb\_cmd2 * mode\_cmd}}] \leavevmode
Metadata from the userspace framebuffer creation request

\end{description}

\textbf{Description}

This function creates a new framebuffer object described by
\code{drm\_mode\_fb\_cmd2}. This description includes handles for the buffer(s)
backing the framebuffer.

If your hardware has special alignment or pitch requirements these should be
checked before calling this function. The function does buffer size
validation. Use {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_gem_fb_create_with_funcs]{\emph{\code{drm\_gem\_fb\_create\_with\_funcs()}}}} if you need to set
{\hyperref[gpu/drm\string-kms:c.drm_framebuffer_funcs]{\emph{\code{drm\_framebuffer\_funcs.dirty}}}}.

Drivers can use this as their {\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.fb\_create}}}} callback.
The ADDFB2 IOCTL calls into this callback.

\textbf{Return}

Pointer to a {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}} on success or an error pointer on failure.
\index{drm\_gem\_fb\_prepare\_fb (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_gem_fb_prepare_fb}\pysiglinewithargsret{int \bfcode{drm\_gem\_fb\_prepare\_fb}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} *\emph{ state}}{}
Prepare a GEM backed framebuffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
Plane

\item[{\code{struct drm\_plane\_state * state}}] \leavevmode
Plane state the fence will be attached to

\end{description}

\textbf{Description}

This function prepares a GEM backed framebuffer for scanout by checking if
the plane framebuffer has a DMA-BUF attached. If it does, it extracts the
exclusive fence and attaches it to the plane state for the atomic helper to
wait on. This function can be used as the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_funcs]{\emph{\code{drm\_plane\_helper\_funcs.prepare\_fb}}}}
callback.

There is no need for {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_funcs]{\emph{\code{drm\_plane\_helper\_funcs.cleanup\_fb}}}} hook for simple
gem based framebuffer drivers which have their buffers always pinned in
memory.
\index{drm\_gem\_fbdev\_fb\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_gem_fbdev_fb_create}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} * \bfcode{drm\_gem\_fbdev\_fb\_create}}{struct drm\_device *\emph{ dev}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_surface_size]{\emph{drm\_fb\_helper\_surface\_size}}} *\emph{ sizes}, unsigned int\emph{ pitch\_align}, struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ obj}, const struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_funcs]{\emph{drm\_framebuffer\_funcs}}} *\emph{ funcs}}{}
Create a GEM backed {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}} for fbdev emulation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{struct drm\_fb\_helper\_surface\_size * sizes}}] \leavevmode
fbdev size description

\item[{\code{unsigned int pitch\_align}}] \leavevmode
Optional pitch alignment

\item[{\code{struct drm\_gem\_object * obj}}] \leavevmode
GEM object backing the framebuffer

\item[{\code{const struct drm\_framebuffer\_funcs * funcs}}] \leavevmode
Optional vtable to be used for the new framebuffer object when the
dirty callback is needed.

\end{description}

\textbf{Description}

This function creates a framebuffer from a {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_surface_size]{\emph{\code{drm\_fb\_helper\_surface\_size}}}}
description for use in the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_fb_helper_funcs]{\emph{\code{drm\_fb\_helper\_funcs.fb\_probe}}}} callback.

\textbf{Return}

Pointer to a {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{\code{drm\_framebuffer}}}} on success or an error pointer on failure.


\section{Legacy Plane Helper Reference}
\label{gpu/drm-kms-helpers:legacy-plane-helper-reference}
This helper library has two parts. The first part has support to implement
primary plane support on top of the normal CRTC configuration interface.
Since the legacy {\hyperref[gpu/drm\string-kms:c.drm_mode_config_funcs]{\emph{\code{drm\_mode\_config\_funcs.set\_config}}}} interface ties the primary
plane together with the CRTC state this does not allow userspace to disable
the primary plane itself.  To avoid too much duplicated code use
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_check_update]{\emph{\code{drm\_plane\_helper\_check\_update()}}}} which can be used to enforce the same
restrictions as primary planes had thus. The default primary plane only
expose XRBG8888 and ARGB8888 as valid pixel formats for the attached
framebuffer.

Drivers are highly recommended to implement proper support for primary
planes, and newly merged drivers must not rely upon these transitional
helpers.

The second part also implements transitional helpers which allow drivers to
gradually switch to the atomic helper infrastructure for plane updates. Once
that switch is complete drivers shouldn't use these any longer, instead using
the proper legacy implementations for update and disable plane hooks provided
by the atomic helpers.

Again drivers are strongly urged to switch to the new interfaces.

The plane helpers share the function table structures with other helpers,
specifically also the atomic helpers. See {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_plane_helper_funcs]{\emph{\code{struct drm\_plane\_helper\_funcs}}}} for
the details.
\index{drm\_plane\_helper\_check\_update (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_plane_helper_check_update}\pysiglinewithargsret{int \bfcode{drm\_plane\_helper\_check\_update}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ src}, struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ dst}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_rect]{\emph{drm\_rect}}} *\emph{ clip}, unsigned int\emph{ rotation}, int\emph{ min\_scale}, int\emph{ max\_scale}, bool\emph{ can\_position}, bool\emph{ can\_update\_disabled}, bool *\emph{ visible}}{}
Check plane update for validity

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane object to update

\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
owning CRTC of owning plane

\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
framebuffer to flip onto plane

\item[{\code{struct drm\_rect * src}}] \leavevmode
source coordinates in 16.16 fixed point

\item[{\code{struct drm\_rect * dst}}] \leavevmode
integer destination coordinates

\item[{\code{const struct drm\_rect * clip}}] \leavevmode
integer clipping coordinates

\item[{\code{unsigned int rotation}}] \leavevmode
plane rotation

\item[{\code{int min\_scale}}] \leavevmode
minimum \textbf{src}:\textbf{dest} scaling factor in 16.16 fixed point

\item[{\code{int max\_scale}}] \leavevmode
maximum \textbf{src}:\textbf{dest} scaling factor in 16.16 fixed point

\item[{\code{bool can\_position}}] \leavevmode
is it legal to position the plane such that it
doesn't cover the entire crtc?  This will generally
only be false for primary planes.

\item[{\code{bool can\_update\_disabled}}] \leavevmode
can the plane be updated while the crtc
is disabled?

\item[{\code{bool * visible}}] \leavevmode
output parameter indicating whether plane is still visible after
clipping

\end{description}

\textbf{Description}

Checks that a desired plane update is valid.  Drivers that provide
their own plane handling rather than helper-provided implementations may
still wish to call this function to avoid duplication of error checking
code.

\textbf{Return}

Zero if update appears valid, error code on failure
\index{drm\_primary\_helper\_update (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_primary_helper_update}\pysiglinewithargsret{int \bfcode{drm\_primary\_helper\_update}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, int\emph{ crtc\_x}, int\emph{ crtc\_y}, unsigned int\emph{ crtc\_w}, unsigned int\emph{ crtc\_h}, uint32\_t\emph{ src\_x}, uint32\_t\emph{ src\_y}, uint32\_t\emph{ src\_w}, uint32\_t\emph{ src\_h}, struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}}{}
Helper for primary plane update

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane object to update

\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
owning CRTC of owning plane

\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
framebuffer to flip onto plane

\item[{\code{int crtc\_x}}] \leavevmode
x offset of primary plane on crtc

\item[{\code{int crtc\_y}}] \leavevmode
y offset of primary plane on crtc

\item[{\code{unsigned int crtc\_w}}] \leavevmode
width of primary plane rectangle on crtc

\item[{\code{unsigned int crtc\_h}}] \leavevmode
height of primary plane rectangle on crtc

\item[{\code{uint32\_t src\_x}}] \leavevmode
x offset of \textbf{fb} for panning

\item[{\code{uint32\_t src\_y}}] \leavevmode
y offset of \textbf{fb} for panning

\item[{\code{uint32\_t src\_w}}] \leavevmode
width of source rectangle in \textbf{fb}

\item[{\code{uint32\_t src\_h}}] \leavevmode
height of source rectangle in \textbf{fb}

\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
lock acquire context, not used here

\end{description}

\textbf{Description}

Provides a default plane update handler for primary planes.  This is handler
is called in response to a userspace SetPlane operation on the plane with a
non-NULL framebuffer.  We call the driver's modeset handler to update the
framebuffer.

\code{SetPlane()} on a primary plane of a disabled CRTC is not supported, and will
return an error.

Note that we make some assumptions about hardware limitations that may not be
true for all hardware --
\begin{enumerate}
\item {} 
Primary plane cannot be repositioned.

\item {} 
Primary plane cannot be scaled.

\item {} 
Primary plane must cover the entire CRTC.

\item {} 
Subpixel positioning is not supported.

\end{enumerate}

Drivers for hardware that don't have these restrictions can provide their
own implementation rather than using this helper.

\textbf{Return}

Zero on success, error code on failure
\index{drm\_primary\_helper\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_primary_helper_disable}\pysiglinewithargsret{int \bfcode{drm\_primary\_helper\_disable}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}}{}
Helper for primary plane disable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane to disable

\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
lock acquire context, not used here

\end{description}

\textbf{Description}

Provides a default plane disable handler for primary planes.  This is handler
is called in response to a userspace SetPlane operation on the plane with a
NULL framebuffer parameter.  It unconditionally fails the disable call with
-EINVAL the only way to disable the primary plane without driver support is
to disable the entire CRTC. Which does not match the plane
{\hyperref[gpu/drm\string-kms:c.drm_plane_funcs]{\emph{\code{drm\_plane\_funcs.disable\_plane}}}} hook.

Note that some hardware may be able to disable the primary plane without
disabling the whole CRTC.  Drivers for such hardware should provide their
own disable handler that disables just the primary plane (and they'll likely
need to provide their own update handler as well to properly re-enable a
disabled primary plane).

\textbf{Return}

Unconditionally returns -EINVAL.
\index{drm\_primary\_helper\_destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_primary_helper_destroy}\pysiglinewithargsret{void \bfcode{drm\_primary\_helper\_destroy}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}}{}
Helper for primary plane destruction

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane to destroy

\end{description}

\textbf{Description}

Provides a default plane destroy handler for primary planes.  This handler
is called during CRTC destruction.  We disable the primary plane, remove
it from the DRM plane list, and deallocate the plane structure.
\index{drm\_plane\_helper\_update (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_plane_helper_update}\pysiglinewithargsret{int \bfcode{drm\_plane\_helper\_update}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, int\emph{ crtc\_x}, int\emph{ crtc\_y}, unsigned int\emph{ crtc\_w}, unsigned int\emph{ crtc\_h}, uint32\_t\emph{ src\_x}, uint32\_t\emph{ src\_y}, uint32\_t\emph{ src\_w}, uint32\_t\emph{ src\_h}}{}
Transitional helper for plane update

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane object to update

\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
owning CRTC of owning plane

\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
framebuffer to flip onto plane

\item[{\code{int crtc\_x}}] \leavevmode
x offset of primary plane on crtc

\item[{\code{int crtc\_y}}] \leavevmode
y offset of primary plane on crtc

\item[{\code{unsigned int crtc\_w}}] \leavevmode
width of primary plane rectangle on crtc

\item[{\code{unsigned int crtc\_h}}] \leavevmode
height of primary plane rectangle on crtc

\item[{\code{uint32\_t src\_x}}] \leavevmode
x offset of \textbf{fb} for panning

\item[{\code{uint32\_t src\_y}}] \leavevmode
y offset of \textbf{fb} for panning

\item[{\code{uint32\_t src\_w}}] \leavevmode
width of source rectangle in \textbf{fb}

\item[{\code{uint32\_t src\_h}}] \leavevmode
height of source rectangle in \textbf{fb}

\end{description}

\textbf{Description}

Provides a default plane update handler using the atomic plane update
functions. It is fully left to the driver to check plane constraints and
handle corner-cases like a fully occluded or otherwise invisible plane.

This is useful for piecewise transitioning of a driver to the atomic helpers.

\textbf{Return}

Zero on success, error code on failure
\index{drm\_plane\_helper\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_plane_helper_disable}\pysiglinewithargsret{int \bfcode{drm\_plane\_helper\_disable}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}}{}
Transitional helper for plane disable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane to disable

\end{description}

\textbf{Description}

Provides a default plane disable handler using the atomic plane update
functions. It is fully left to the driver to check plane constraints and
handle corner-cases like a fully occluded or otherwise invisible plane.

This is useful for piecewise transitioning of a driver to the atomic helpers.

\textbf{Return}

Zero on success, error code on failure


\section{Legacy CRTC/Modeset Helper Functions Reference}
\label{gpu/drm-kms-helpers:legacy-crtc-modeset-helper-functions-reference}
The CRTC modeset helper library provides a default set\_config implementation
in {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_set_config]{\emph{\code{drm\_crtc\_helper\_set\_config()}}}}. Plus a few other convenience functions using
the same callbacks which drivers can use to e.g. restore the modeset
configuration on resume with {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_helper_resume_force_mode]{\emph{\code{drm\_helper\_resume\_force\_mode()}}}}.

Note that this helper library doesn't track the current power state of CRTCs
and encoders. It can call callbacks like {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.dpms}}}} even
though the hardware is already in the desired state. This deficiency has been
fixed in the atomic helpers.

The driver callbacks are mostly compatible with the atomic modeset helpers,
except for the handling of the primary plane: Atomic helpers require that the
primary plane is implemented as a real standalone plane and not directly tied
to the CRTC state. For easier transition this library provides functions to
implement the old semantics required by the CRTC helpers using the new plane
and atomic helper callbacks.

Drivers are strongly urged to convert to the atomic helpers (by way of first
converting to the plane helpers). New drivers must not use these functions
but need to implement the atomic interface instead, potentially using the
atomic helpers for that.

These legacy modeset helpers use the same function table structures as
all other modesetting helpers. See the documentation for struct
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{\code{drm\_crtc\_helper\_funcs}}}}, {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{struct drm\_encoder\_helper\_funcs}}}} and struct
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_connector_helper_funcs]{\emph{\code{drm\_connector\_helper\_funcs}}}}.
\index{drm\_helper\_encoder\_in\_use (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_helper_encoder_in_use}\pysiglinewithargsret{bool \bfcode{drm\_helper\_encoder\_in\_use}}{struct {\hyperref[gpu/drm\string-kms:c.drm_encoder]{\emph{drm\_encoder}}} *\emph{ encoder}}{}
check if a given encoder is in use

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_encoder * encoder}}] \leavevmode
encoder to check

\end{description}

\textbf{Description}

Checks whether \textbf{encoder} is with the current mode setting output configuration
in use by any connector. This doesn't mean that it is actually enabled since
the DPMS state is tracked separately.

\textbf{Return}

True if \textbf{encoder} is used, false otherwise.
\index{drm\_helper\_crtc\_in\_use (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_helper_crtc_in_use}\pysiglinewithargsret{bool \bfcode{drm\_helper\_crtc\_in\_use}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}}{}
check if a given CRTC is in a mode\_config

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
CRTC to check

\end{description}

\textbf{Description}

Checks whether \textbf{crtc} is with the current mode setting output configuration
in use by any connector. This doesn't mean that it is actually enabled since
the DPMS state is tracked separately.

\textbf{Return}

True if \textbf{crtc} is used, false otherwise.
\index{drm\_helper\_disable\_unused\_functions (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_helper_disable_unused_functions}\pysiglinewithargsret{void \bfcode{drm\_helper\_disable\_unused\_functions}}{struct drm\_device *\emph{ dev}}{}
disable unused objects

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

This function walks through the entire mode setting configuration of \textbf{dev}. It
will remove any CRTC links of unused encoders and encoder links of
disconnected connectors. Then it will disable all unused encoders and CRTCs
either by calling their disable callback if available or by calling their
dpms callback with DRM\_MODE\_DPMS\_OFF.

\textbf{NOTE}

This function is part of the legacy modeset helper library and will cause
major confusion with atomic drivers. This is because atomic helpers guarantee
to never call -\textgreater{}:c:func:\emph{disable()} hooks on a disabled function, or -\textgreater{}:c:func:\emph{enable()} hooks
on an enabled functions. {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_helper_disable_unused_functions]{\emph{\code{drm\_helper\_disable\_unused\_functions()}}}} on the other
hand throws such guarantees into the wind and calls disable hooks
unconditionally on unused functions.
\index{drm\_crtc\_helper\_set\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_crtc_helper_set_mode}\pysiglinewithargsret{bool \bfcode{drm\_crtc\_helper\_set\_mode}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}, int\emph{ x}, int\emph{ y}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ old\_fb}}{}
internal helper to set a mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
CRTC to program

\item[{\code{struct drm\_display\_mode * mode}}] \leavevmode
mode to use

\item[{\code{int x}}] \leavevmode
horizontal offset into the surface

\item[{\code{int y}}] \leavevmode
vertical offset into the surface

\item[{\code{struct drm\_framebuffer * old\_fb}}] \leavevmode
old framebuffer, for cleanup

\end{description}

\textbf{Description}

Try to set \textbf{mode} on \textbf{crtc}.  Give \textbf{crtc} and its associated connectors a chance
to fixup or reject the mode prior to trying to set it. This is an internal
helper that drivers could e.g. use to update properties that require the
entire output pipe to be disabled and re-enabled in a new configuration. For
example for changing whether audio is enabled on a hdmi link or for changing
panel fitter or dither attributes. It is also called by the
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_set_config]{\emph{\code{drm\_crtc\_helper\_set\_config()}}}} helper function to drive the mode setting
sequence.

\textbf{Return}

True if the mode was set successfully, false otherwise.
\index{drm\_crtc\_helper\_set\_config (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_crtc_helper_set_config}\pysiglinewithargsret{int \bfcode{drm\_crtc\_helper\_set\_config}}{struct {\hyperref[gpu/drm\string-kms:c.drm_mode_set]{\emph{drm\_mode\_set}}} *\emph{ set}, struct {\hyperref[gpu/drm\string-kms:c.drm_modeset_acquire_ctx]{\emph{drm\_modeset\_acquire\_ctx}}} *\emph{ ctx}}{}
set a new config from userspace

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_mode\_set * set}}] \leavevmode
mode set configuration

\item[{\code{struct drm\_modeset\_acquire\_ctx * ctx}}] \leavevmode
lock acquire context, not used here

\end{description}

\textbf{Description}

The {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_set_config]{\emph{\code{drm\_crtc\_helper\_set\_config()}}}} helper function implements the of
{\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.set\_config}}}} callback for drivers using the legacy CRTC
helpers.

It first tries to locate the best encoder for each connector by calling the
connector \textbf{drm\_connector\_helper\_funcs.best\_encoder} helper operation.

After locating the appropriate encoders, the helper function will call the
mode\_fixup encoder and CRTC helper operations to adjust the requested mode,
or reject it completely in which case an error will be returned to the
application. If the new configuration after mode adjustment is identical to
the current configuration the helper function will return without performing
any other operation.

If the adjusted mode is identical to the current mode but changes to the
frame buffer need to be applied, the {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_set_config]{\emph{\code{drm\_crtc\_helper\_set\_config()}}}} function
will call the CRTC {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{\code{drm\_crtc\_helper\_funcs.mode\_set\_base}}}} helper operation.

If the adjusted mode differs from the current mode, or if the
-\textgreater{}:c:func:\emph{mode\_set\_base()} helper operation is not provided, the helper function
performs a full mode set sequence by calling the -\textgreater{}:c:func:\emph{prepare()}, -\textgreater{}:c:func:\emph{mode\_set()}
and -\textgreater{}:c:func:\emph{commit()} CRTC and encoder helper operations, in that order.
Alternatively it can also use the dpms and disable helper operations. For
details see {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{\code{struct drm\_crtc\_helper\_funcs}}}} and struct
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs}}}}.

This function is deprecated.  New drivers must implement atomic modeset
support, for which this function is unsuitable. Instead drivers should use
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_set_config]{\emph{\code{drm\_atomic\_helper\_set\_config()}}}}.

\textbf{Return}

Returns 0 on success, negative errno numbers on failure.
\index{drm\_helper\_connector\_dpms (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_helper_connector_dpms}\pysiglinewithargsret{int \bfcode{drm\_helper\_connector\_dpms}}{struct {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{drm\_connector}}} *\emph{ connector}, int\emph{ mode}}{}
connector dpms helper implementation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_connector * connector}}] \leavevmode
affected connector

\item[{\code{int mode}}] \leavevmode
DPMS mode

\end{description}

\textbf{Description}

The {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_helper_connector_dpms]{\emph{\code{drm\_helper\_connector\_dpms()}}}} helper function implements the
{\hyperref[gpu/drm\string-kms:c.drm_connector_funcs]{\emph{\code{drm\_connector\_funcs.dpms}}}} callback for drivers using the legacy CRTC
helpers.

This is the main helper function provided by the CRTC helper framework for
implementing the DPMS connector attribute. It computes the new desired DPMS
state for all encoders and CRTCs in the output mesh and calls the
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_crtc_helper_funcs]{\emph{\code{drm\_crtc\_helper\_funcs.dpms}}}} and {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_encoder_helper_funcs]{\emph{\code{drm\_encoder\_helper\_funcs.dpms}}}} callbacks
provided by the driver.

This function is deprecated.  New drivers must implement atomic modeset
support, where DPMS is handled in the DRM core.

\textbf{Return}

Always returns 0.
\index{drm\_helper\_resume\_force\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_helper_resume_force_mode}\pysiglinewithargsret{void \bfcode{drm\_helper\_resume\_force\_mode}}{struct drm\_device *\emph{ dev}}{}
force-restore mode setting configuration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm\_device which should be restored

\end{description}

\textbf{Description}

Drivers which use the mode setting helpers can use this function to
force-restore the mode setting configuration e.g. on resume or when something
else might have trampled over the hw state (like some overzealous old BIOSen
tended to do).

This helper doesn't provide a error return value since restoring the old
config should never fail due to resource allocation issues since the driver
has successfully set the restored configuration already. Hence this should
boil down to the equivalent of a few dpms on calls, which also don't provide
an error code.

Drivers where simply restoring an old configuration again might fail (e.g.
due to slight differences in allocating shared resources when the
configuration is restored in a different order than when userspace set it up)
need to use their own restore logic.

This function is deprecated. New drivers should implement atomic mode-
setting and use the atomic suspend/resume helpers.

See also:
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_suspend]{\emph{\code{drm\_atomic\_helper\_suspend()}}}}, {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_resume]{\emph{\code{drm\_atomic\_helper\_resume()}}}}
\index{drm\_helper\_crtc\_mode\_set (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_helper_crtc_mode_set}\pysiglinewithargsret{int \bfcode{drm\_helper\_crtc\_mode\_set}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}, struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ adjusted\_mode}, int\emph{ x}, int\emph{ y}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ old\_fb}}{}
mode\_set implementation for atomic plane helpers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
DRM CRTC

\item[{\code{struct drm\_display\_mode * mode}}] \leavevmode
DRM display mode which userspace requested

\item[{\code{struct drm\_display\_mode * adjusted\_mode}}] \leavevmode
DRM display mode adjusted by -\textgreater{}mode\_fixup callbacks

\item[{\code{int x}}] \leavevmode
x offset of the CRTC scanout area on the underlying framebuffer

\item[{\code{int y}}] \leavevmode
y offset of the CRTC scanout area on the underlying framebuffer

\item[{\code{struct drm\_framebuffer * old\_fb}}] \leavevmode
previous framebuffer

\end{description}

\textbf{Description}

This function implements a callback useable as the -\textgreater{}mode\_set callback
required by the CRTC helpers. Besides the atomic plane helper functions for
the primary plane the driver must also provide the -\textgreater{}mode\_set\_nofb callback
to set up the CRTC.

This is a transitional helper useful for converting drivers to the atomic
interfaces.
\index{drm\_helper\_crtc\_mode\_set\_base (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-kms-helpers:c.drm_helper_crtc_mode_set_base}\pysiglinewithargsret{int \bfcode{drm\_helper\_crtc\_mode\_set\_base}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, int\emph{ x}, int\emph{ y}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ old\_fb}}{}
mode\_set\_base implementation for atomic plane helpers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
DRM CRTC

\item[{\code{int x}}] \leavevmode
x offset of the CRTC scanout area on the underlying framebuffer

\item[{\code{int y}}] \leavevmode
y offset of the CRTC scanout area on the underlying framebuffer

\item[{\code{struct drm\_framebuffer * old\_fb}}] \leavevmode
previous framebuffer

\end{description}

\textbf{Description}

This function implements a callback useable as the -\textgreater{}mode\_set\_base used
required by the CRTC helpers. The driver must provide the atomic plane helper
functions for the primary plane.

This is a transitional helper useful for converting drivers to the atomic
interfaces.


\chapter{Userland interfaces}
\label{gpu/drm-uapi:userland-interfaces}\label{gpu/drm-uapi::doc}
The DRM core exports several interfaces to applications, generally
intended to be used through corresponding libdrm wrapper functions. In
addition, drivers export device-specific interfaces for use by userspace
drivers \& device-aware applications through ioctls and sysfs files.

External interfaces include: memory mapping, context management, DMA
operations, AGP management, vblank control, fence management, memory
management, and output management.

Cover generic ioctls and sysfs layout here. We only need high-level
info, since man pages should cover the rest.


\section{libdrm Device Lookup}
\label{gpu/drm-uapi:libdrm-device-lookup}
BEWARE THE DRAGONS! MIND THE TRAPDOORS!

In an attempt to warn anyone else who's trying to figure out what's going
on here, I'll try to summarize the story. First things first, let's clear up
the names, because the kernel internals, libdrm and the ioctls are all named
differently:
\begin{itemize}
\item {} 
GET\_UNIQUE ioctl, implemented by drm\_getunique is wrapped up in libdrm
through the drmGetBusid function.

\item {} 
The libdrm drmSetBusid function is backed by the SET\_UNIQUE ioctl. All
that code is nerved in the kernel with {\hyperref[gpu/drm\string-uapi:c.drm_invalid_op]{\emph{\code{drm\_invalid\_op()}}}}.

\item {} 
The internal set\_busid kernel functions and driver callbacks are
exclusively use by the SET\_VERSION ioctl, because only drm 1.0 (which is
nerved) allowed userspace to set the busid through the above ioctl.

\item {} 
Other ioctls and functions involved are named consistently.

\end{itemize}

For anyone wondering what's the difference between drm 1.1 and 1.4: Correctly
handling pci domains in the busid on ppc. Doing this correctly was only
implemented in libdrm in 2010, hence can't be nerved yet. No one knows what's
special with drm 1.2 and 1.3.

Now the actual horror story of how device lookup in drm works. At large,
there's 2 different ways, either by busid, or by device driver name.

Opening by busid is fairly simple:
\begin{enumerate}
\item {} 
First call SET\_VERSION to make sure pci domains are handled properly. As a
side-effect this fills out the unique name in the master structure.

\item {} 
Call GET\_UNIQUE to read out the unique name from the master structure,
which matches the busid thanks to step 1. If it doesn't, proceed to try
the next device node.

\end{enumerate}

Opening by name is slightly different:
\begin{enumerate}
\item {} 
Directly call VERSION to get the version and to match against the driver
name returned by that ioctl. Note that SET\_VERSION is not called, which
means the the unique name for the master node just opening is \_not\_ filled
out. This despite that with current drm device nodes are always bound to
one device, and can't be runtime assigned like with drm 1.0.

\item {} 
Match driver name. If it mismatches, proceed to the next device node.

\item {} 
Call GET\_UNIQUE, and check whether the unique name has length zero (by
checking that the first byte in the string is 0). If that's not the case
libdrm skips and proceeds to the next device node. Probably this is just
copypasta from drm 1.0 times where a set unique name meant that the driver
was in use already, but that's just conjecture.

\end{enumerate}

Long story short: To keep the open by name logic working, GET\_UNIQUE must
\_not\_ return a unique string when SET\_VERSION hasn't been called yet,
otherwise libdrm breaks. Even when that unique string can't ever change, and
is totally irrelevant for actually opening the device because runtime
assignable device instances were only support in drm 1.0, which is long dead.
But the libdrm code in drmOpenByName somehow survived, hence this can't be
broken.


\section{Primary Nodes, DRM Master and Authentication}
\label{gpu/drm-uapi:drm-primary-node}\label{gpu/drm-uapi:primary-nodes-drm-master-and-authentication}
{\hyperref[gpu/drm\string-uapi:c.drm_master]{\emph{\code{struct drm\_master}}}} is used to track groups of clients with open
primary/legacy device nodes. For every {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{struct drm\_file}}}} which has had at
least once successfully became the device master (either through the
SET\_MASTER IOCTL, or implicitly through opening the primary device node when
no one else is the current master that time) there exists one {\hyperref[gpu/drm\string-uapi:c.drm_master]{\emph{\code{drm\_master}}}}.
This is noted in {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{\code{drm\_file.is\_master}}}}. All other clients have just a pointer
to the {\hyperref[gpu/drm\string-uapi:c.drm_master]{\emph{\code{drm\_master}}}} they are associated with.

In addition only one {\hyperref[gpu/drm\string-uapi:c.drm_master]{\emph{\code{drm\_master}}}} can be the current master for a \code{drm\_device}.
It can be switched through the DROP\_MASTER and SET\_MASTER IOCTL, or
implicitly through closing/openeing the primary device node. See also
{\hyperref[gpu/drm\string-uapi:c.drm_is_current_master]{\emph{\code{drm\_is\_current\_master()}}}}.

Clients can authenticate against the current master (if it matches their own)
using the GETMAGIC and AUTHMAGIC IOCTLs. Together with exchanging masters,
this allows controlled access to the device for an entire group of mutually
trusted clients.
\index{drm\_is\_current\_master (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_is_current_master}\pysiglinewithargsret{bool \bfcode{drm\_is\_current\_master}}{struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ fpriv}}{}
checks whether \textbf{priv} is the current master

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_file * fpriv}}] \leavevmode
DRM file private

\end{description}

\textbf{Description}

Checks whether \textbf{fpriv} is current master on its device. This decides whether a
client is allowed to run DRM\_MASTER IOCTLs.

Most of the modern IOCTL which require DRM\_MASTER are for kernel modesetting
- the current master is assumed to own the non-shareable display hardware.
\index{drm\_master\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_master_get}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-uapi:c.drm_master]{\emph{drm\_master}}} * \bfcode{drm\_master\_get}}{struct {\hyperref[gpu/drm\string-uapi:c.drm_master]{\emph{drm\_master}}} *\emph{ master}}{}
reference a master pointer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_master * master}}] \leavevmode
{\hyperref[gpu/drm\string-uapi:c.drm_master]{\emph{\code{struct drm\_master}}}}

\end{description}

\textbf{Description}

Increments the reference count of \textbf{master} and returns a pointer to \textbf{master}.
\index{drm\_master\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_master_put}\pysiglinewithargsret{void \bfcode{drm\_master\_put}}{struct {\hyperref[gpu/drm\string-uapi:c.drm_master]{\emph{drm\_master}}} **\emph{ master}}{}
unreference and clear a master pointer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_master ** master}}] \leavevmode
pointer to a pointer of {\hyperref[gpu/drm\string-uapi:c.drm_master]{\emph{\code{struct drm\_master}}}}

\end{description}

\textbf{Description}

This decrements the {\hyperref[gpu/drm\string-uapi:c.drm_master]{\emph{\code{drm\_master}}}} behind \textbf{master} and sets it to NULL.
\index{drm\_master (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_master}\pysigline{struct \bfcode{drm\_master}}
drm master structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}master \PYGZob{}
  struct kref refcount;
  struct drm\PYGZus{}device *dev;
  char *unique;
  int unique\PYGZus{}len;
  struct idr magic\PYGZus{}map;
  struct drm\PYGZus{}lock\PYGZus{}data lock;
  void *driver\PYGZus{}priv;
  struct drm\PYGZus{}master *lessor;
  int lessee\PYGZus{}id;
  struct list\PYGZus{}head lessee\PYGZus{}list;
  struct list\PYGZus{}head lessees;
  struct idr leases;
  struct idr lessee\PYGZus{}idr;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{refcount}}] \leavevmode
Refcount for this master object.

\item[{\code{dev}}] \leavevmode
Link back to the DRM device

\item[{\code{unique}}] \leavevmode
Unique identifier: e.g. busid. Protected by
\code{drm\_device.master\_mutex}.

\item[{\code{unique\_len}}] \leavevmode
Length of unique field. Protected by
\code{drm\_device.master\_mutex}.

\item[{\code{magic\_map}}] \leavevmode
Map of used authentication tokens. Protected by
\code{drm\_device.master\_mutex}.

\item[{\code{lock}}] \leavevmode
DRI1 lock information.

\item[{\code{driver\_priv}}] \leavevmode
Pointer to driver-private information.

\item[{\code{lessor}}] \leavevmode
Lease holder

\item[{\code{lessee\_id}}] \leavevmode
id for lessees. Owners always have id 0

\item[{\code{lessee\_list}}] \leavevmode
other lessees of the same master

\item[{\code{lessees}}] \leavevmode
drm\_masters leasing from this one

\item[{\code{leases}}] \leavevmode
Objects leased to this drm\_master.

\item[{\code{lessee\_idr}}] \leavevmode
All lessees under this owner (only used where lessor == NULL)

\end{description}

\textbf{Description}

Note that master structures are only relevant for the legacy/primary device
nodes, hence there can only be one per device, not one per drm\_minor.


\section{Open-Source Userspace Requirements}
\label{gpu/drm-uapi:open-source-userspace-requirements}
The DRM subsystem has stricter requirements than most other kernel subsystems on
what the userspace side for new uAPI needs to look like. This section here
explains what exactly those requirements are, and why they exist.

The short summary is that any addition of DRM uAPI requires corresponding
open-sourced userspace patches, and those patches must be reviewed and ready for
merging into a suitable and canonical upstream project.

GFX devices (both display and render/GPU side) are really complex bits of
hardware, with userspace and kernel by necessity having to work together really
closely.  The interfaces, for rendering and modesetting, must be extremely wide
and flexible, and therefore it is almost always impossible to precisely define
them for every possible corner case. This in turn makes it really practically
infeasible to differentiate between behaviour that's required by userspace, and
which must not be changed to avoid regressions, and behaviour which is only an
accidental artifact of the current implementation.

Without access to the full source code of all userspace users that means it
becomes impossible to change the implementation details, since userspace could
depend upon the accidental behaviour of the current implementation in minute
details. And debugging such regressions without access to source code is pretty
much impossible. As a consequence this means:
\begin{itemize}
\item {} 
The Linux kernel's ``no regression'' policy holds in practice only for
open-source userspace of the DRM subsystem. DRM developers are perfectly fine
if closed-source blob drivers in userspace use the same uAPI as the open
drivers, but they must do so in the exact same way as the open drivers.
Creative (ab)use of the interfaces will, and in the past routinely has, lead
to breakage.

\item {} 
Any new userspace interface must have an open-source implementation as
demonstration vehicle.

\end{itemize}

The other reason for requiring open-source userspace is uAPI review. Since the
kernel and userspace parts of a GFX stack must work together so closely, code
review can only assess whether a new interface achieves its goals by looking at
both sides. Making sure that the interface indeed covers the use-case fully
leads to a few additional requirements:
\begin{itemize}
\item {} 
The open-source userspace must not be a toy/test application, but the real
thing. Specifically it needs to handle all the usual error and corner cases.
These are often the places where new uAPI falls apart and hence essential to
assess the fitness of a proposed interface.

\item {} 
The userspace side must be fully reviewed and tested to the standards of that
userspace project. For e.g. mesa this means piglit testcases and review on the
mailing list. This is again to ensure that the new interface actually gets the
job done.

\item {} 
The userspace patches must be against the canonical upstream, not some vendor
fork. This is to make sure that no one cheats on the review and testing
requirements by doing a quick fork.

\item {} 
The kernel patch can only be merged after all the above requirements are met,
but it \textbf{must} be merged \textbf{before} the userspace patches land. uAPI always flows
from the kernel, doing things the other way round risks divergence of the uAPI
definitions and header files.

\end{itemize}

These are fairly steep requirements, but have grown out from years of shared
pain and experience with uAPI added hastily, and almost always regretted about
just as fast. GFX devices change really fast, requiring a paradigm shift and
entire new set of uAPI interfaces every few years at least. Together with the
Linux kernel's guarantee to keep existing userspace running for 10+ years this
is already rather painful for the DRM subsystem, with multiple different uAPIs
for the same thing co-existing. If we add a few more complete mistakes into the
mix every year it would be entirely unmanageable.


\section{Render nodes}
\label{gpu/drm-uapi:render-nodes}\label{gpu/drm-uapi:drm-render-node}
DRM core provides multiple character-devices for user-space to use.
Depending on which device is opened, user-space can perform a different
set of operations (mainly ioctls). The primary node is always created
and called card\textless{}num\textgreater{}. Additionally, a currently unused control node,
called controlD\textless{}num\textgreater{} is also created. The primary node provides all
legacy operations and historically was the only interface used by
userspace. With KMS, the control node was introduced. However, the
planned KMS control interface has never been written and so the control
node stays unused to date.

With the increased use of offscreen renderers and GPGPU applications,
clients no longer require running compositors or graphics servers to
make use of a GPU. But the DRM API required unprivileged clients to
authenticate to a DRM-Master prior to getting GPU access. To avoid this
step and to grant clients GPU access without authenticating, render
nodes were introduced. Render nodes solely serve render clients, that
is, no modesetting or privileged ioctls can be issued on render nodes.
Only non-global rendering commands are allowed. If a driver supports
render nodes, it must advertise it via the DRIVER\_RENDER DRM driver
capability. If not supported, the primary node must be used for render
clients together with the legacy drmAuth authentication procedure.

If a driver advertises render node support, DRM core will create a
separate render node called renderD\textless{}num\textgreater{}. There will be one render node
per device. No ioctls except PRIME-related ioctls will be allowed on
this node. Especially GEM\_OPEN will be explicitly prohibited. Render
nodes are designed to avoid the buffer-leaks, which occur if clients
guess the flink names or mmap offsets on the legacy interface.
Additionally to this basic interface, drivers must mark their
driver-dependent render-only ioctls as DRM\_RENDER\_ALLOW so render
clients can use them. Driver authors must be careful not to allow any
privileged ioctls on render nodes.

With render nodes, user-space can now control access to the render node
via basic file-system access-modes. A running graphics server which
authenticates clients on the privileged primary/legacy node is no longer
required. Instead, a client can open the render node and is immediately
granted GPU access. Communication between clients (or servers) is done
via PRIME. FLINK from render node to legacy node is not supported. New
clients must not use the insecure FLINK interface.

Besides dropping all modeset/global ioctls, render nodes also drop the
DRM-Master concept. There is no reason to associate render clients with
a DRM-Master as they are independent of any graphics server. Besides,
they must work without any running master, anyway. Drivers must be able
to run without a master object if they support render nodes. If, on the
other hand, a driver requires shared state between clients which is
visible to user-space and accessible beyond open-file boundaries, they
cannot support render nodes.


\section{IOCTL Support on Device Nodes}
\label{gpu/drm-uapi:ioctl-support-on-device-nodes}\label{gpu/drm-uapi:drm-driver-ioctl}
First things first, driver private IOCTLs should only be needed for drivers
supporting rendering. Kernel modesetting is all standardized, and extended
through properties. There are a few exceptions in some existing drivers,
which define IOCTL for use by the display DRM master, but they all predate
properties.

Now if you do have a render driver you always have to support it through
driver private properties. There's a few steps needed to wire all the things
up.

First you need to define the structure for your IOCTL in your driver private
UAPI header in \code{include/uapi/drm/my\_driver\_drm.h}:

\begin{Verbatim}[commandchars=\\\{\}]
struct my\PYGZus{}driver\PYGZus{}operation \PYGZob{}
        u32 some\PYGZus{}thing;
        u32 another\PYGZus{}thing;
\PYGZcb{};
\end{Verbatim}

Please make sure that you follow all the best practices from
\code{Documentation/ioctl/botching-up-ioctls.txt}. Note that {\hyperref[gpu/drm\string-uapi:c.drm_ioctl]{\emph{\code{drm\_ioctl()}}}}
automatically zero-extends structures, hence make sure you can add more stuff
at the end, i.e. don't put a variable sized array there.

Then you need to define your IOCTL number, using one of \code{DRM\_IO()}, \code{DRM\_IOR()},
\code{DRM\_IOW()} or \code{DRM\_IOWR()}. It must start with the DRM\_IOCTL\_ prefix:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}\PYGZsh{}define DRM\PYGZus{}IOCTL\PYGZus{}MY\PYGZus{}DRIVER\PYGZus{}OPERATION  *         DRM\PYGZus{}IOW(DRM\PYGZus{}COMMAND\PYGZus{}BASE, struct my\PYGZus{}driver\PYGZus{}operation)
\end{Verbatim}

DRM driver private IOCTL must be in the range from DRM\_COMMAND\_BASE to
DRM\_COMMAND\_END. Finally you need an array of {\hyperref[gpu/drm\string-uapi:c.drm_ioctl_desc]{\emph{\code{struct drm\_ioctl\_desc}}}} to wire
up the handlers and set the access rights:

\begin{Verbatim}[commandchars=\\\{\}]
static const struct drm\PYGZus{}ioctl\PYGZus{}desc my\PYGZus{}driver\PYGZus{}ioctls[] = \PYGZob{}
    DRM\PYGZus{}IOCTL\PYGZus{}DEF\PYGZus{}DRV(MY\PYGZus{}DRIVER\PYGZus{}OPERATION, my\PYGZus{}driver\PYGZus{}operation,
            DRM\PYGZus{}AUTH\textbar{}DRM\PYGZus{}RENDER\PYGZus{}ALLOW),
\PYGZcb{};
\end{Verbatim}

And then assign this to the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.ioctls}}}} field in your driver
structure.

See the separate chapter on {\hyperref[gpu/drm\string-internals:drm\string-driver\string-fops]{\emph{file operations}}} for how
the driver-specific IOCTLs are wired up.


\subsection{Recommended IOCTL Return Values}
\label{gpu/drm-uapi:recommended-ioctl-return-values}
In theory a driver's IOCTL callback is only allowed to return very few error
codes. In practice it's good to abuse a few more. This section documents common
practice within the DRM subsystem:
\begin{description}
\item[{ENOENT:}] \leavevmode
Strictly this should only be used when a file doesn't exist e.g. when
calling the open() syscall. We reuse that to signal any kind of object
lookup failure, e.g. for unknown GEM buffer object handles, unknown KMS
object handles and similar cases.

\item[{ENOSPC:}] \leavevmode
Some drivers use this to differentiate ``out of kernel memory'' from ``out
of VRAM''. Sometimes also applies to other limited gpu resources used for
rendering (e.g. when you have a special limited compression buffer).
Sometimes resource allocation/reservation issues in command submission
IOCTLs are also signalled through EDEADLK.

Simply running out of kernel/system memory is signalled through ENOMEM.

\item[{EPERM/EACCESS:}] \leavevmode
Returned for an operation that is valid, but needs more privileges.
E.g. root-only or much more common, DRM master-only operations return
this when when called by unpriviledged clients. There's no clear
difference between EACCESS and EPERM.

\item[{ENODEV:}] \leavevmode
Feature (like PRIME, modesetting, GEM) is not supported by the driver.

\item[{ENXIO:}] \leavevmode
Remote failure, either a hardware transaction (like i2c), but also used
when the exporting driver of a shared dma-buf or fence doesn't support a
feature needed.

\item[{EINTR:}] \leavevmode
DRM drivers assume that userspace restarts all IOCTLs. Any DRM IOCTL can
return EINTR and in such a case should be restarted with the IOCTL
parameters left unchanged.

\item[{EIO:}] \leavevmode
The GPU died and couldn't be resurrected through a reset. Modesetting
hardware failures are signalled through the ``link status'' connector
property.

\item[{EINVAL:}] \leavevmode
Catch-all for anything that is an invalid argument combination which
cannot work.

\end{description}

IOCTL also use other error codes like ETIME, EFAULT, EBUSY, ENOTTY but their
usage is in line with the common meanings. The above list tries to just document
DRM specific patterns. Note that ENOTTY has the slightly unintuitive meaning of
``this IOCTL does not exist'', and is used exactly as such in DRM.
\index{drm\_ioctl\_t (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_ioctl_t}\pysiglinewithargsret{typedef int \bfcode{drm\_ioctl\_t}}{struct drm\_device *\emph{ dev}, void *\emph{ data}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}}{}
DRM ioctl function type.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device inode

\item[{\code{void * data}}] \leavevmode
private pointer of the ioctl call

\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
DRM file this ioctl was made on

\end{description}

\textbf{Description}

This is the DRM ioctl typedef. Note that {\hyperref[gpu/drm\string-uapi:c.drm_ioctl]{\emph{\code{drm\_ioctl()}}}} has alrady copied \textbf{data}
into kernel-space, and will also copy it back, depending upon the read/write
settings in the ioctl command code.
\index{drm\_ioctl\_compat\_t (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_ioctl_compat_t}\pysiglinewithargsret{typedef int \bfcode{drm\_ioctl\_compat\_t}}{struct file *\emph{ filp}, unsigned int\emph{ cmd}, unsigned long\emph{ arg}}{}
compatibility DRM ioctl function type.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
file pointer

\item[{\code{unsigned int cmd}}] \leavevmode
ioctl command code

\item[{\code{unsigned long arg}}] \leavevmode
DRM file this ioctl was made on

\end{description}

\textbf{Description}

Just a typedef to make declaring an array of compatibility handlers easier.
New drivers shouldn't screw up the structure layout for their ioctl
structures and hence never need this.
\index{drm\_ioctl\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_ioctl_flags}\pysigline{enum \bfcode{drm\_ioctl\_flags}}
DRM ioctl flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{DRM\_AUTH}}] \leavevmode
This is for ioctl which are used for rendering, and require that the
file descriptor is either for a render node, or if it's a
legacy/primary node, then it must be authenticated.

\item[{\code{DRM\_MASTER}}] \leavevmode
This must be set for any ioctl which can change the modeset or
display state. Userspace must call the ioctl through a primary node,
while it is the active master.

Note that read-only modeset ioctl can also be called by
unauthenticated clients, or when a master is not the currently active
one.

\item[{\code{DRM\_ROOT\_ONLY}}] \leavevmode
Anything that could potentially wreak a master file descriptor needs
to have this flag set. Current that's only for the SETMASTER and
DROPMASTER ioctl, which e.g. logind can call to force a non-behaving
master (display compositor) into compliance.

This is equivalent to callers with the SYSADMIN capability.

\item[{\code{DRM\_CONTROL\_ALLOW}}] \leavevmode
Deprecated, do not use. Control nodes are in the process of getting
removed.

\item[{\code{DRM\_UNLOCKED}}] \leavevmode
Whether {\hyperref[gpu/drm\string-uapi:c.drm_ioctl_desc]{\emph{\code{drm\_ioctl\_desc.func}}}} should be called with the DRM BKL held
or not. Enforced as the default for all modern drivers, hence there
should never be a need to set this flag.

\item[{\code{DRM\_RENDER\_ALLOW}}] \leavevmode
This is used for all ioctl needed for rendering only, for drivers
which support render nodes. This should be all new render drivers,
and hence it should be always set for any ioctl with DRM\_AUTH set.
Note though that read-only query ioctl might have this set, but have
not set DRM\_AUTH because they do not require authentication.

\end{description}

\textbf{Description}

Various flags that can be set in {\hyperref[gpu/drm\string-uapi:c.drm_ioctl_desc]{\emph{\code{drm\_ioctl\_desc.flags}}}} to control how
userspace can use a given ioctl.
\index{drm\_ioctl\_desc (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_ioctl_desc}\pysigline{struct \bfcode{drm\_ioctl\_desc}}
DRM driver ioctl entry

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}ioctl\PYGZus{}desc \PYGZob{}
  unsigned int cmd;
  enum drm\PYGZus{}ioctl\PYGZus{}flags flags;
  drm\PYGZus{}ioctl\PYGZus{}t *func;
  const char *name;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{cmd}}] \leavevmode
ioctl command number, without flags

\item[{\code{flags}}] \leavevmode
a bitmask of {\hyperref[gpu/drm\string-uapi:c.drm_ioctl_flags]{\emph{\code{enum drm\_ioctl\_flags}}}}

\item[{\code{func}}] \leavevmode
handler for this ioctl

\item[{\code{name}}] \leavevmode
user-readable name for debug output

\end{description}

\textbf{Description}

For convenience it's easier to create these using the {\hyperref[gpu/drm\string-uapi:c.DRM_IOCTL_DEF_DRV]{\emph{\code{DRM\_IOCTL\_DEF\_DRV()}}}}
macro.
\index{DRM\_IOCTL\_DEF\_DRV (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.DRM_IOCTL_DEF_DRV}\pysiglinewithargsret{\bfcode{DRM\_IOCTL\_DEF\_DRV}}{\emph{ioctl}, \emph{\_func}, \emph{\_flags}}{}
helper macro to fill out a {\hyperref[gpu/drm\string-uapi:c.drm_ioctl_desc]{\emph{\code{struct drm\_ioctl\_desc}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{ioctl}}] \leavevmode
ioctl command suffix

\item[{\code{\_func}}] \leavevmode
handler for the ioctl

\item[{\code{\_flags}}] \leavevmode
a bitmask of {\hyperref[gpu/drm\string-uapi:c.drm_ioctl_flags]{\emph{\code{enum drm\_ioctl\_flags}}}}

\end{description}

\textbf{Description}

Small helper macro to create a {\hyperref[gpu/drm\string-uapi:c.drm_ioctl_desc]{\emph{\code{struct drm\_ioctl\_desc}}}} entry. The ioctl
command number is constructed by prepending \code{DRM\_IOCTL\textbackslash{}\_} and passing that
to \code{DRM\_IOCTL\_NR()}.
\index{drm\_noop (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_noop}\pysiglinewithargsret{int \bfcode{drm\_noop}}{struct drm\_device *\emph{ dev}, void *\emph{ data}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}}{}
DRM no-op ioctl implemntation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device for the ioctl

\item[{\code{void * data}}] \leavevmode
data pointer for the ioctl

\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
DRM file for the ioctl call

\end{description}

\textbf{Description}

This no-op implementation for drm ioctls is useful for deprecated
functionality where we can't return a failure code because existing userspace
checks the result of the ioctl, but doesn't care about the action.

Always returns successfully with 0.
\index{drm\_invalid\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_invalid_op}\pysiglinewithargsret{int \bfcode{drm\_invalid\_op}}{struct drm\_device *\emph{ dev}, void *\emph{ data}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}}{}
DRM invalid ioctl implemntation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device for the ioctl

\item[{\code{void * data}}] \leavevmode
data pointer for the ioctl

\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
DRM file for the ioctl call

\end{description}

\textbf{Description}

This no-op implementation for drm ioctls is useful for deprecated
functionality where we really don't want to allow userspace to call the ioctl
any more. This is the case for old ums interfaces for drivers that
transitioned to kms gradually and so kept the old legacy tables around. This
only applies to radeon and i915 kms drivers, other drivers shouldn't need to
use this function.

Always fails with a return value of -EINVAL.
\index{drm\_ioctl\_permit (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_ioctl_permit}\pysiglinewithargsret{int \bfcode{drm\_ioctl\_permit}}{u32\emph{ flags}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file\_priv}}{}
Check ioctl permissions against caller

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u32 flags}}] \leavevmode
ioctl permission flags.

\item[{\code{struct drm\_file * file\_priv}}] \leavevmode
Pointer to struct drm\_file identifying the caller.

\end{description}

\textbf{Description}

Checks whether the caller is allowed to run an ioctl with the
indicated permissions.

\textbf{Return}

Zero if allowed, -EACCES otherwise.
\index{drm\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_ioctl}\pysiglinewithargsret{long \bfcode{drm\_ioctl}}{struct file *\emph{ filp}, unsigned int\emph{ cmd}, unsigned long\emph{ arg}}{}
ioctl callback implementation for DRM drivers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
file this ioctl is called on

\item[{\code{unsigned int cmd}}] \leavevmode
ioctl cmd number

\item[{\code{unsigned long arg}}] \leavevmode
user argument

\end{description}

\textbf{Description}

Looks up the ioctl function in the DRM core and the driver dispatch table,
stored in {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver.ioctls}}}}. It checks for necessary permission by calling
{\hyperref[gpu/drm\string-uapi:c.drm_ioctl_permit]{\emph{\code{drm\_ioctl\_permit()}}}}, and dispatches to the respective function.

\textbf{Return}

Zero on success, negative error code on failure.
\index{drm\_ioctl\_flags (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{bool \bfcode{drm\_ioctl\_flags}}{unsigned int\emph{ nr}, unsigned int *\emph{ flags}}{}
Check for core ioctl and return ioctl permission flags

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int nr}}] \leavevmode
ioctl number

\item[{\code{unsigned int * flags}}] \leavevmode
where to return the ioctl permission flags

\end{description}

\textbf{Description}

This ioctl is only used by the vmwgfx driver to augment the access checks
done by the drm core and insofar a pretty decent layering violation. This
shouldn't be used by any drivers.

\textbf{Return}

True if the \textbf{nr} corresponds to a DRM core ioctl number, false otherwise.
\index{drm\_compat\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_compat_ioctl}\pysiglinewithargsret{long \bfcode{drm\_compat\_ioctl}}{struct file *\emph{ filp}, unsigned int\emph{ cmd}, unsigned long\emph{ arg}}{}
32bit IOCTL compatibility handler for DRM drivers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
file this ioctl is called on

\item[{\code{unsigned int cmd}}] \leavevmode
ioctl cmd number

\item[{\code{unsigned long arg}}] \leavevmode
user argument

\end{description}

\textbf{Description}

Compatibility handler for 32 bit userspace running on 64 kernels. All actual
IOCTL handling is forwarded to {\hyperref[gpu/drm\string-uapi:c.drm_ioctl]{\emph{\code{drm\_ioctl()}}}}, while marshalling structures as
appropriate. Note that this only handles DRM core IOCTLs, if the driver has
botched IOCTL itself, it must handle those by wrapping this function.

\textbf{Return}

Zero on success, negative error code on failure.


\section{Testing and validation}
\label{gpu/drm-uapi:testing-and-validation}

\subsection{Validating changes with IGT}
\label{gpu/drm-uapi:validating-changes-with-igt}
There's a collection of tests that aims to cover the whole functionality of
DRM drivers and that can be used to check that changes to DRM drivers or the
core don't regress existing functionality. This test suite is called IGT and
its code can be found in \href{https://cgit.freedesktop.org/drm/igt-gpu-tools/}{https://cgit.freedesktop.org/drm/igt-gpu-tools/}.

To build IGT, start by installing its build dependencies. In Debian-based
systems:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} apt\PYGZhy{}get build\PYGZhy{}dep intel\PYGZhy{}gpu\PYGZhy{}tools
\end{Verbatim}

And in Fedora-based systems:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} dnf builddep intel\PYGZhy{}gpu\PYGZhy{}tools
\end{Verbatim}

Then clone the repository:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} git clone git://anongit.freedesktop.org/drm/igt\PYGZhy{}gpu\PYGZhy{}tools
\end{Verbatim}

Configure the build system and start the build:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} cd igt\PYGZhy{}gpu\PYGZhy{}tools \PYGZam{}\PYGZam{} ./autogen.sh \PYGZam{}\PYGZam{} make \PYGZhy{}j6
\end{Verbatim}

Download the piglit dependency:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ./scripts/run\PYGZhy{}tests.sh \PYGZhy{}d
\end{Verbatim}

And run the tests:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ./scripts/run\PYGZhy{}tests.sh \PYGZhy{}t kms \PYGZhy{}t core \PYGZhy{}s
\end{Verbatim}

run-tests.sh is a wrapper around piglit that will execute the tests matching
the -t options. A report in HTML format will be available in
./results/html/index.html. Results can be compared with piglit.


\subsection{Display CRC Support}
\label{gpu/drm-uapi:display-crc-support}
DRM device drivers can provide to userspace CRC information of each frame as
it reached a given hardware component (a CRC sampling ``source'').

Userspace can control generation of CRCs in a given CRTC by writing to the
file dri/0/crtc-N/crc/control in debugfs, with N being the index of the CRTC.
Accepted values are source names (which are driver-specific) and the ``auto''
keyword, which will let the driver select a default source of frame CRCs
for this CRTC.

Once frame CRC generation is enabled, userspace can capture them by reading
the dri/0/crtc-N/crc/data file. Each line in that file contains the frame
number in the first field and then a number of unsigned integer fields
containing the CRC data. Fields are separated by a single space and the number
of CRC fields is source-specific.

Note that though in some cases the CRC is computed in a specified way and on
the frame contents as supplied by userspace (eDP 1.3), in general the CRC
computation is performed in an unspecified way and on frame contents that have
been already processed in also an unspecified way and thus userspace cannot
rely on being able to generate matching CRC values for the frame contents that
it submits. In this general case, the maximum userspace can do is to compare
the reported CRCs of frames that should have the same contents.

On the driver side the implementation effort is minimal, drivers only need to
implement {\hyperref[gpu/drm\string-kms:c.drm_crtc_funcs]{\emph{\code{drm\_crtc\_funcs.set\_crc\_source}}}}. The debugfs files are automatically
set up if that vfunc is set. CRC samples need to be captured in the driver by
calling {\hyperref[gpu/drm\string-uapi:c.drm_crtc_add_crc_entry]{\emph{\code{drm\_crtc\_add\_crc\_entry()}}}}.
\index{drm\_crtc\_add\_crc\_entry (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_crtc_add_crc_entry}\pysiglinewithargsret{int \bfcode{drm\_crtc\_add\_crc\_entry}}{struct {\hyperref[gpu/drm\string-kms:c.drm_crtc]{\emph{drm\_crtc}}} *\emph{ crtc}, bool\emph{ has\_frame}, uint32\_t\emph{ frame}, uint32\_t *\emph{ crcs}}{}
Add entry with CRC information for a frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_crtc * crtc}}] \leavevmode
CRTC to which the frame belongs

\item[{\code{bool has\_frame}}] \leavevmode
whether this entry has a frame number to go with

\item[{\code{uint32\_t frame}}] \leavevmode
number of the frame these CRCs are about

\item[{\code{uint32\_t * crcs}}] \leavevmode
array of CRC values, with length matching \#drm\_crtc\_crc.values\_cnt

\end{description}

\textbf{Description}

For each frame, the driver polls the source of CRCs for new data and calls
this function to add them to the buffer from where userspace reads.


\subsection{Debugfs Support}
\label{gpu/drm-uapi:debugfs-support}\index{drm\_info\_list (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_info_list}\pysigline{struct \bfcode{drm\_info\_list}}
debugfs info list entry

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}info\PYGZus{}list \PYGZob{}
  const char *name;
  int (*show)(struct seq\PYGZus{}file*, void*);
  u32 driver\PYGZus{}features;
  void *data;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
file name

\item[{\code{show}}] \leavevmode
Show callback. \code{seq\_file-\textgreater{}private} will be set to the {\hyperref[gpu/drm\string-uapi:c.drm_info_node]{\emph{\code{struct
drm\_info\_node}}}} corresponding to the instance of this info on a given
{\hyperref[gpu/drm\string-internals:c.drm_minor]{\emph{\code{struct drm\_minor}}}}.

\item[{\code{driver\_features}}] \leavevmode
Required driver features for this entry

\item[{\code{data}}] \leavevmode
Driver-private data, should not be device-specific.

\end{description}

\textbf{Description}

This structure represents a debugfs file to be created by the drm
core.
\index{drm\_info\_node (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_info_node}\pysigline{struct \bfcode{drm\_info\_node}}
Per-minor debugfs node structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct drm\PYGZus{}info\PYGZus{}node \PYGZob{}
  struct drm\PYGZus{}minor *minor;
  const struct drm\PYGZus{}info\PYGZus{}list *info\PYGZus{}ent;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{minor}}] \leavevmode
{\hyperref[gpu/drm\string-internals:c.drm_minor]{\emph{\code{struct drm\_minor}}}} for this node.

\item[{\code{info\_ent}}] \leavevmode
template for this node.

\end{description}

\textbf{Description}

This structure represents a debugfs file, as an instantiation of a {\hyperref[gpu/drm\string-uapi:c.drm_info_list]{\emph{\code{struct
drm\_info\_list}}}} on a {\hyperref[gpu/drm\string-internals:c.drm_minor]{\emph{\code{struct drm\_minor}}}}.

FIXME:

No it doesn't make a hole lot of sense that we duplicate debugfs entries for
both the render and the primary nodes, but that's how this has organically
grown. It should probably be fixed, with a compatibility link, if needed.
\index{drm\_debugfs\_create\_files (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_debugfs_create_files}\pysiglinewithargsret{int \bfcode{drm\_debugfs\_create\_files}}{const struct {\hyperref[gpu/drm\string-uapi:c.drm_info_list]{\emph{drm\_info\_list}}} *\emph{ files}, int\emph{ count}, struct dentry *\emph{ root}, struct {\hyperref[gpu/drm\string-internals:c.drm_minor]{\emph{drm\_minor}}} *\emph{ minor}}{}
Initialize a given set of debugfs files for DRM minor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct drm\_info\_list * files}}] \leavevmode
The array of files to create

\item[{\code{int count}}] \leavevmode
The number of files given

\item[{\code{struct dentry * root}}] \leavevmode
DRI debugfs dir entry.

\item[{\code{struct drm\_minor * minor}}] \leavevmode
device minor number

\end{description}

\textbf{Description}

Create a given set of debugfs files represented by an array of
{\hyperref[gpu/drm\string-uapi:c.drm_info_list]{\emph{\code{struct drm\_info\_list}}}} in the given root directory. These files will be removed
automatically on \code{drm\_debugfs\_cleanup()}.


\section{Sysfs Support}
\label{gpu/drm-uapi:sysfs-support}
DRM provides very little additional support to drivers for sysfs
interactions, beyond just all the standard stuff. Drivers who want to expose
additional sysfs properties and property groups can attach them at either
\code{drm\_device.dev} or {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector.kdev}}}}.

Registration is automatically handled when calling {\hyperref[gpu/drm\string-internals:c.drm_dev_register]{\emph{\code{drm\_dev\_register()}}}}, or
{\hyperref[gpu/drm\string-kms:c.drm_connector_register]{\emph{\code{drm\_connector\_register()}}}} in case of hot-plugged connectors. Unregistration is
also automatically handled by {\hyperref[gpu/drm\string-internals:c.drm_dev_unregister]{\emph{\code{drm\_dev\_unregister()}}}} and
{\hyperref[gpu/drm\string-kms:c.drm_connector_unregister]{\emph{\code{drm\_connector\_unregister()}}}}.
\index{drm\_sysfs\_hotplug\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_sysfs_hotplug_event}\pysiglinewithargsret{void \bfcode{drm\_sysfs\_hotplug\_event}}{struct drm\_device *\emph{ dev}}{}
generate a DRM uevent

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\end{description}

\textbf{Description}

Send a uevent for the DRM device specified by \textbf{dev}.  Currently we only
set HOTPLUG=1 in the uevent environment, but this could be expanded to
deal with other types of events.
\index{drm\_class\_device\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_class_device_register}\pysiglinewithargsret{int \bfcode{drm\_class\_device\_register}}{struct device *\emph{ dev}}{}
register new device with the DRM sysfs class

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device to register

\end{description}

\textbf{Description}

Registers a new \code{struct device} within the DRM sysfs class. Essentially only
used by ttm to have a place for its global settings. Drivers should never use
this.
\index{drm\_class\_device\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/drm-uapi:c.drm_class_device_unregister}\pysiglinewithargsret{void \bfcode{drm\_class\_device\_unregister}}{struct device *\emph{ dev}}{}
unregister device with the DRM sysfs class

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device to unregister

\end{description}

\textbf{Description}

Unregisters a \code{struct device} from the DRM sysfs class. Essentially only used
by ttm to have a place for its global settings. Drivers should never use
this.


\section{VBlank event handling}
\label{gpu/drm-uapi:vblank-event-handling}
The DRM core exposes two vertical blank related ioctls:
\begin{description}
\item[{DRM\_IOCTL\_WAIT\_VBLANK}] \leavevmode
This takes a struct drm\_wait\_vblank structure as its argument, and
it is used to block or request a signal when a specified vblank
event occurs.

\item[{DRM\_IOCTL\_MODESET\_CTL}] \leavevmode
This was only used for user-mode-settind drivers around modesetting
changes to allow the kernel to update the vblank interrupt after
mode setting, since on many devices the vertical blank counter is
reset to 0 at some point during modeset. Modern drivers should not
call this any more since with kernel mode setting it is a no-op.

\end{description}


\chapter{drm/i915 Intel GFX Driver}
\label{gpu/i915:drm-i915-intel-gfx-driver}\label{gpu/i915::doc}
The drm/i915 driver supports all (with the exception of some very early
models) integrated GFX chipsets with both Intel display and rendering
blocks. This excludes a set of SoC platforms with an SGX rendering unit,
those have basic support through the gma500 drm driver.


\section{Core Driver Infrastructure}
\label{gpu/i915:core-driver-infrastructure}
This section covers core driver infrastructure used by both the display
and the GEM parts of the driver.


\subsection{Runtime Power Management}
\label{gpu/i915:runtime-power-management}
The i915 driver supports dynamic enabling and disabling of entire hardware
blocks at runtime. This is especially important on the display side where
software is supposed to control many power gates manually on recent hardware,
since on the GT side a lot of the power management is done by the hardware.
But even there some manual control at the device level is required.

Since i915 supports a diverse set of platforms with a unified codebase and
hardware engineers just love to shuffle functionality around between power
domains there's a sizeable amount of indirection required. This file provides
generic functions to the driver for grabbing and releasing references for
abstract power domains. It then maps those to the actual power wells
present for a given platform.
\index{\_\_intel\_display\_power\_is\_enabled (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.__intel_display_power_is_enabled}\pysiglinewithargsret{bool \bfcode{\_\_intel\_display\_power\_is\_enabled}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum intel\_display\_power\_domain\emph{ domain}}{}
unlocked check for a power domain

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum intel\_display\_power\_domain domain}}] \leavevmode
power domain to check

\end{description}

\textbf{Description}

This is the unlocked version of {\hyperref[gpu/i915:c.intel_display_power_is_enabled]{\emph{\code{intel\_display\_power\_is\_enabled()}}}} and should
only be used from error capture and recovery code where deadlocks are
possible.

\textbf{Return}

True when the power domain is enabled, false otherwise.
\index{intel\_display\_power\_is\_enabled (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_display_power_is_enabled}\pysiglinewithargsret{bool \bfcode{intel\_display\_power\_is\_enabled}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum intel\_display\_power\_domain\emph{ domain}}{}
check for a power domain

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum intel\_display\_power\_domain domain}}] \leavevmode
power domain to check

\end{description}

\textbf{Description}

This function can be used to check the hw power domain state. It is mostly
used in hardware state readout functions. Everywhere else code should rely
upon explicit power domain reference counting to ensure that the hardware
block is powered up before accessing it.

Callers must hold the relevant modesetting locks to ensure that concurrent
threads can't disable the power well while the caller tries to read a few
registers.

\textbf{Return}

True when the power domain is enabled, false otherwise.
\index{intel\_display\_set\_init\_power (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_display_set_init_power}\pysiglinewithargsret{void \bfcode{intel\_display\_set\_init\_power}}{struct drm\_i915\_private *\emph{ dev\_priv}, bool\emph{ enable}}{}
set the initial power domain state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{bool enable}}] \leavevmode
whether to enable or disable the initial power domain state

\end{description}

\textbf{Description}

For simplicity our driver load/unload and system suspend/resume code assumes
that all power domains are always enabled. This functions controls the state
of this little hack. While the initial power domain state is enabled runtime
pm is effectively disabled.
\index{intel\_display\_power\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_display_power_get}\pysiglinewithargsret{void \bfcode{intel\_display\_power\_get}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum intel\_display\_power\_domain\emph{ domain}}{}
grab a power domain reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum intel\_display\_power\_domain domain}}] \leavevmode
power domain to reference

\end{description}

\textbf{Description}

This function grabs a power domain reference for \textbf{domain} and ensures that the
power domain and all its parents are powered up. Therefore users should only
grab a reference to the innermost power domain they need.

Any power domain reference obtained by this function must have a symmetric
call to {\hyperref[gpu/i915:c.intel_display_power_put]{\emph{\code{intel\_display\_power\_put()}}}} to release the reference again.
\index{intel\_display\_power\_get\_if\_enabled (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_display_power_get_if_enabled}\pysiglinewithargsret{bool \bfcode{intel\_display\_power\_get\_if\_enabled}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum intel\_display\_power\_domain\emph{ domain}}{}
grab a reference for an enabled display power domain

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum intel\_display\_power\_domain domain}}] \leavevmode
power domain to reference

\end{description}

\textbf{Description}

This function grabs a power domain reference for \textbf{domain} and ensures that the
power domain and all its parents are powered up. Therefore users should only
grab a reference to the innermost power domain they need.

Any power domain reference obtained by this function must have a symmetric
call to {\hyperref[gpu/i915:c.intel_display_power_put]{\emph{\code{intel\_display\_power\_put()}}}} to release the reference again.
\index{intel\_display\_power\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_display_power_put}\pysiglinewithargsret{void \bfcode{intel\_display\_power\_put}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum intel\_display\_power\_domain\emph{ domain}}{}
release a power domain reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum intel\_display\_power\_domain domain}}] \leavevmode
power domain to reference

\end{description}

\textbf{Description}

This function drops the power domain reference obtained by
{\hyperref[gpu/i915:c.intel_display_power_get]{\emph{\code{intel\_display\_power\_get()}}}} and might power down the corresponding hardware
block right away if this is the last reference.
\index{intel\_power\_domains\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_power_domains_init}\pysiglinewithargsret{int \bfcode{intel\_power\_domains\_init}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
initializes the power domain structures

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

Initializes the power domain structures for \textbf{dev\_priv} depending upon the
supported platform.
\index{intel\_power\_domains\_fini (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_power_domains_fini}\pysiglinewithargsret{void \bfcode{intel\_power\_domains\_fini}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
finalizes the power domain structures

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

Finalizes the power domain structures for \textbf{dev\_priv} depending upon the
supported platform. This function also disables runtime pm and ensures that
the device stays powered up so that the driver can be reloaded.
\index{intel\_power\_domains\_init\_hw (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_power_domains_init_hw}\pysiglinewithargsret{void \bfcode{intel\_power\_domains\_init\_hw}}{struct drm\_i915\_private *\emph{ dev\_priv}, bool\emph{ resume}}{}
initialize hardware power domain state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{bool resume}}] \leavevmode
Called from resume code paths or not

\end{description}

\textbf{Description}

This function initializes the hardware power domain state and enables all
power wells belonging to the INIT power domain. Power wells in other
domains (and not in the INIT domain) are referenced or disabled during the
modeset state HW readout. After that the reference count of each power well
must match its HW enabled state, see {\hyperref[gpu/i915:c.intel_power_domains_verify_state]{\emph{\code{intel\_power\_domains\_verify\_state()}}}}.
\index{intel\_power\_domains\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_power_domains_suspend}\pysiglinewithargsret{void \bfcode{intel\_power\_domains\_suspend}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
suspend power domain state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This function prepares the hardware power domain state before entering
system suspend. It must be paired with {\hyperref[gpu/i915:c.intel_power_domains_init_hw]{\emph{\code{intel\_power\_domains\_init\_hw()}}}}.
\index{intel\_power\_domains\_verify\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_power_domains_verify_state}\pysiglinewithargsret{void \bfcode{intel\_power\_domains\_verify\_state}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
verify the HW/SW state for all power wells

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

Verify if the reference count of each power well matches its HW enabled
state and the total refcount of the domains it belongs to. This must be
called after modeset HW state sanitization, which is responsible for
acquiring reference counts for any power wells in use and disabling the
ones left on by BIOS but not required by any active output.
\index{intel\_runtime\_pm\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_runtime_pm_get}\pysiglinewithargsret{void \bfcode{intel\_runtime\_pm\_get}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
grab a runtime pm reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This function grabs a device-level runtime pm reference (mostly used for GEM
code to ensure the GTT or GT is on) and ensures that it is powered up.

Any runtime pm reference obtained by this function must have a symmetric
call to {\hyperref[gpu/i915:c.intel_runtime_pm_put]{\emph{\code{intel\_runtime\_pm\_put()}}}} to release the reference again.
\index{intel\_runtime\_pm\_get\_if\_in\_use (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_runtime_pm_get_if_in_use}\pysiglinewithargsret{bool \bfcode{intel\_runtime\_pm\_get\_if\_in\_use}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
grab a runtime pm reference if device in use

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This function grabs a device-level runtime pm reference if the device is
already in use and ensures that it is powered up.

Any runtime pm reference obtained by this function must have a symmetric
call to {\hyperref[gpu/i915:c.intel_runtime_pm_put]{\emph{\code{intel\_runtime\_pm\_put()}}}} to release the reference again.
\index{intel\_runtime\_pm\_get\_noresume (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_runtime_pm_get_noresume}\pysiglinewithargsret{void \bfcode{intel\_runtime\_pm\_get\_noresume}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
grab a runtime pm reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This function grabs a device-level runtime pm reference (mostly used for GEM
code to ensure the GTT or GT is on).

It will \_not\_ power up the device but instead only check that it's powered
on.  Therefore it is only valid to call this functions from contexts where
the device is known to be powered up and where trying to power it up would
result in hilarity and deadlocks. That pretty much means only the system
suspend/resume code where this is used to grab runtime pm references for
delayed setup down in work items.

Any runtime pm reference obtained by this function must have a symmetric
call to {\hyperref[gpu/i915:c.intel_runtime_pm_put]{\emph{\code{intel\_runtime\_pm\_put()}}}} to release the reference again.
\index{intel\_runtime\_pm\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_runtime_pm_put}\pysiglinewithargsret{void \bfcode{intel\_runtime\_pm\_put}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
release a runtime pm reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This function drops the device-level runtime pm reference obtained by
{\hyperref[gpu/i915:c.intel_runtime_pm_get]{\emph{\code{intel\_runtime\_pm\_get()}}}} and might power down the corresponding
hardware block right away if this is the last reference.
\index{intel\_runtime\_pm\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_runtime_pm_enable}\pysiglinewithargsret{void \bfcode{intel\_runtime\_pm\_enable}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
enable runtime pm

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This function enables runtime pm at the end of the driver load sequence.

Note that this function does currently not enable runtime pm for the
subordinate display power domains. That is only done on the first modeset
using {\hyperref[gpu/i915:c.intel_display_set_init_power]{\emph{\code{intel\_display\_set\_init\_power()}}}}.
\index{intel\_uncore\_forcewake\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_uncore_forcewake_get}\pysiglinewithargsret{void \bfcode{intel\_uncore\_forcewake\_get}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum forcewake\_domains\emph{ fw\_domains}}{}
grab forcewake domain references

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum forcewake\_domains fw\_domains}}] \leavevmode
forcewake domains to get reference on

\end{description}

\textbf{Description}

This function can be used get GT's forcewake domain references.
Normal register access will handle the forcewake domains automatically.
However if some sequence requires the GT to not power down a particular
forcewake domains this function should be called at the beginning of the
sequence. And subsequently the reference should be dropped by symmetric
call to \code{intel\_unforce\_forcewake\_put()}. Usually caller wants all the domains
to be kept awake so the \textbf{fw\_domains} would be then FORCEWAKE\_ALL.
\index{intel\_uncore\_forcewake\_user\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_uncore_forcewake_user_get}\pysiglinewithargsret{void \bfcode{intel\_uncore\_forcewake\_user\_get}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
claim forcewake on behalf of userspace

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This function is a wrapper around {\hyperref[gpu/i915:c.intel_uncore_forcewake_get]{\emph{\code{intel\_uncore\_forcewake\_get()}}}} to acquire
the GT powerwell and in the process disable our debugging for the
duration of userspace's bypass.
\index{intel\_uncore\_forcewake\_user\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_uncore_forcewake_user_put}\pysiglinewithargsret{void \bfcode{intel\_uncore\_forcewake\_user\_put}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
release forcewake on behalf of userspace

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This function complements {\hyperref[gpu/i915:c.intel_uncore_forcewake_user_get]{\emph{\code{intel\_uncore\_forcewake\_user\_get()}}}} and releases
the GT powerwell taken on behalf of the userspace bypass.
\index{intel\_uncore\_forcewake\_get\_\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_uncore_forcewake_get__locked}\pysiglinewithargsret{void \bfcode{intel\_uncore\_forcewake\_get\_\_locked}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum forcewake\_domains\emph{ fw\_domains}}{}
grab forcewake domain references

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum forcewake\_domains fw\_domains}}] \leavevmode
forcewake domains to get reference on

\end{description}

\textbf{Description}

See {\hyperref[gpu/i915:c.intel_uncore_forcewake_get]{\emph{\code{intel\_uncore\_forcewake\_get()}}}}. This variant places the onus
on the caller to explicitly handle the dev\_priv-\textgreater{}uncore.lock spinlock.
\index{intel\_uncore\_forcewake\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_uncore_forcewake_put}\pysiglinewithargsret{void \bfcode{intel\_uncore\_forcewake\_put}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum forcewake\_domains\emph{ fw\_domains}}{}
release a forcewake domain reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum forcewake\_domains fw\_domains}}] \leavevmode
forcewake domains to put references

\end{description}

\textbf{Description}

This function drops the device-level forcewakes for specified
domains obtained by {\hyperref[gpu/i915:c.intel_uncore_forcewake_get]{\emph{\code{intel\_uncore\_forcewake\_get()}}}}.
\index{intel\_uncore\_forcewake\_put\_\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_uncore_forcewake_put__locked}\pysiglinewithargsret{void \bfcode{intel\_uncore\_forcewake\_put\_\_locked}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum forcewake\_domains\emph{ fw\_domains}}{}
grab forcewake domain references

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum forcewake\_domains fw\_domains}}] \leavevmode
forcewake domains to get reference on

\end{description}

\textbf{Description}

See {\hyperref[gpu/i915:c.intel_uncore_forcewake_put]{\emph{\code{intel\_uncore\_forcewake\_put()}}}}. This variant places the onus
on the caller to explicitly handle the dev\_priv-\textgreater{}uncore.lock spinlock.
\index{gen6\_reset\_engines (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.gen6_reset_engines}\pysiglinewithargsret{int \bfcode{gen6\_reset\_engines}}{struct drm\_i915\_private *\emph{ dev\_priv}, unsigned\emph{ engine\_mask}}{}
reset individual engines

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\item[{\code{unsigned engine\_mask}}] \leavevmode
mask of \code{intel\_ring\_flag()} engines or ALL\_ENGINES for full reset

\end{description}

\textbf{Description}

This function will reset the individual engines that are set in engine\_mask.
If you provide ALL\_ENGINES as mask, full global domain reset will be issued.

\textbf{Note}

It is responsibility of the caller to handle the difference between
asking full domain reset versus reset for all available individual engines.

Returns 0 on success, nonzero on error.
\index{\_\_intel\_wait\_for\_register\_fw (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.__intel_wait_for_register_fw}\pysiglinewithargsret{int \bfcode{\_\_intel\_wait\_for\_register\_fw}}{struct drm\_i915\_private *\emph{ dev\_priv}, i915\_reg\_t\emph{ reg}, u32\emph{ mask}, u32\emph{ value}, unsigned int\emph{ fast\_timeout\_us}, unsigned int\emph{ slow\_timeout\_ms}, u32 *\emph{ out\_value}}{}
wait until register matches expected state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
the i915 device

\item[{\code{i915\_reg\_t reg}}] \leavevmode
the register to read

\item[{\code{u32 mask}}] \leavevmode
mask to apply to register value

\item[{\code{u32 value}}] \leavevmode
expected value

\item[{\code{unsigned int fast\_timeout\_us}}] \leavevmode
fast timeout in microsecond for atomic/tight wait

\item[{\code{unsigned int slow\_timeout\_ms}}] \leavevmode
slow timeout in millisecond

\item[{\code{u32 * out\_value}}] \leavevmode
optional placeholder to hold registry value

\end{description}

\textbf{Description}

This routine waits until the target register \textbf{reg} contains the expected
\textbf{value} after applying the \textbf{mask}, i.e. it waits until

\begin{Verbatim}[commandchars=\\\{\}]
(I915\PYGZus{}READ\PYGZus{}FW(reg) \PYGZam{} mask) == value
\end{Verbatim}

Otherwise, the wait will timeout after \textbf{slow\_timeout\_ms} milliseconds.
For atomic context \textbf{slow\_timeout\_ms} must be zero and \textbf{fast\_timeout\_us}
must be not larger than 20,0000 microseconds.

Note that this routine assumes the caller holds forcewake asserted, it is
not suitable for very long waits. See {\hyperref[gpu/i915:c.intel_wait_for_register]{\emph{\code{intel\_wait\_for\_register()}}}} if you
wish to wait without holding forcewake for the duration (i.e. you expect
the wait to be slow).

Returns 0 if the register matches the desired condition, or -ETIMEOUT.
\index{intel\_wait\_for\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_wait_for_register}\pysiglinewithargsret{int \bfcode{intel\_wait\_for\_register}}{struct drm\_i915\_private *\emph{ dev\_priv}, i915\_reg\_t\emph{ reg}, u32\emph{ mask}, u32\emph{ value}, unsigned int\emph{ timeout\_ms}}{}
wait until register matches expected state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
the i915 device

\item[{\code{i915\_reg\_t reg}}] \leavevmode
the register to read

\item[{\code{u32 mask}}] \leavevmode
mask to apply to register value

\item[{\code{u32 value}}] \leavevmode
expected value

\item[{\code{unsigned int timeout\_ms}}] \leavevmode
timeout in millisecond

\end{description}

\textbf{Description}

This routine waits until the target register \textbf{reg} contains the expected
\textbf{value} after applying the \textbf{mask}, i.e. it waits until

\begin{Verbatim}[commandchars=\\\{\}]
(I915\PYGZus{}READ(reg) \PYGZam{} mask) == value
\end{Verbatim}

Otherwise, the wait will timeout after \textbf{timeout\_ms} milliseconds.

Returns 0 if the register matches the desired condition, or -ETIMEOUT.
\index{intel\_uncore\_forcewake\_for\_reg (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_uncore_forcewake_for_reg}\pysiglinewithargsret{enum forcewake\_domains \bfcode{intel\_uncore\_forcewake\_for\_reg}}{struct drm\_i915\_private *\emph{ dev\_priv}, i915\_reg\_t\emph{ reg}, unsigned int\emph{ op}}{}
which forcewake domains are needed to access a register

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
pointer to struct drm\_i915\_private

\item[{\code{i915\_reg\_t reg}}] \leavevmode
register in question

\item[{\code{unsigned int op}}] \leavevmode
operation bitmask of FW\_REG\_READ and/or FW\_REG\_WRITE

\end{description}

\textbf{Description}

Returns a set of forcewake domains required to be taken with for example
intel\_uncore\_forcewake\_get for the specified register to be accessible in the
specified mode (read, write or read/write) with raw mmio accessors.

\textbf{NOTE}

On Gen6 and Gen7 write forcewake domain (FORCEWAKE\_RENDER) requires the
callers to do FIFO management on their own or risk losing writes.


\subsection{Interrupt Handling}
\label{gpu/i915:interrupt-handling}
These functions provide the basic support for enabling and disabling the
interrupt handling support. There's a lot more functionality in i915\_irq.c
and related files, but that will be described in separate chapters.
\index{intel\_irq\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_irq_init}\pysiglinewithargsret{void \bfcode{intel\_irq\_init}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
initializes irq support

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This function initializes all the irq support including work items, timers
and all the vtables. It does not setup the interrupt itself though.
\index{intel\_runtime\_pm\_disable\_interrupts (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_runtime_pm_disable_interrupts}\pysiglinewithargsret{void \bfcode{intel\_runtime\_pm\_disable\_interrupts}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
runtime interrupt disabling

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This function is used to disable interrupts at runtime, both in the runtime
pm and the system suspend/resume code.
\index{intel\_runtime\_pm\_enable\_interrupts (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_runtime_pm_enable_interrupts}\pysiglinewithargsret{void \bfcode{intel\_runtime\_pm\_enable\_interrupts}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
runtime interrupt enabling

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This function is used to enable interrupts at runtime, both in the runtime
pm and the system suspend/resume code.


\subsection{Intel GVT-g Guest Support(vGPU)}
\label{gpu/i915:intel-gvt-g-guest-support-vgpu}
Intel GVT-g is a graphics virtualization technology which shares the
GPU among multiple virtual machines on a time-sharing basis. Each
virtual machine is presented a virtual GPU (vGPU), which has equivalent
features as the underlying physical GPU (pGPU), so i915 driver can run
seamlessly in a virtual machine. This file provides vGPU specific
optimizations when running in a virtual machine, to reduce the complexity
of vGPU emulation and to improve the overall performance.

A primary function introduced here is so-called ``address space ballooning''
technique. Intel GVT-g partitions global graphics memory among multiple VMs,
so each VM can directly access a portion of the memory without hypervisor's
intervention, e.g. filling textures or queuing commands. However with the
partitioning an unmodified i915 driver would assume a smaller graphics
memory starting from address ZERO, then requires vGPU emulation module to
translate the graphics address between `guest view' and `host view', for
all registers and command opcodes which contain a graphics memory address.
To reduce the complexity, Intel GVT-g introduces ``address space ballooning'',
by telling the exact partitioning knowledge to each guest i915 driver, which
then reserves and prevents non-allocated portions from allocation. Thus vGPU
emulation module only needs to scan and validate graphics addresses without
complexity of address translation.
\index{i915\_check\_vgpu (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_check_vgpu}\pysiglinewithargsret{void \bfcode{i915\_check\_vgpu}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
detect virtual GPU

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device private

\end{description}

\textbf{Description}

This function is called at the initialization stage, to detect whether
running on a vGPU.
\index{intel\_vgt\_deballoon (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_vgt_deballoon}\pysiglinewithargsret{void \bfcode{intel\_vgt\_deballoon}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
deballoon reserved graphics address trunks

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device private data

\end{description}

\textbf{Description}

This function is called to deallocate the ballooned-out graphic memory, when
driver is unloaded or when ballooning fails.
\index{intel\_vgt\_balloon (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_vgt_balloon}\pysiglinewithargsret{int \bfcode{intel\_vgt\_balloon}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
balloon out reserved graphics address trunks

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device private data

\end{description}

\textbf{Description}

This function is called at the initialization stage, to balloon out the
graphic address space allocated to other vGPUs, by marking these spaces as
reserved. The ballooning related knowledge(starting address and size of
the mappable/unmappable graphic memory) is described in the vgt\_if structure
in a reserved mmio range.

To give an example, the drawing below depicts one typical scenario after
ballooning. Here the vGPU1 has 2 pieces of graphic address spaces ballooned
out each for the mappable and the non-mappable part. From the vGPU1 point of
view, the total size is the same as the physical one, with the start address
of its graphic space being zero. Yet there are some portions ballooned out(
the shadow part, which are marked as reserved by drm allocator). From the
host point of view, the graphic address space is partitioned by multiple
vGPUs in different VMs.

\begin{Verbatim}[commandchars=\\\{\}]
                       vGPU1 view         Host view
            0 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
              \PYGZca{}       \textbar{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\textbar{}     \textbar{}   vGPU3   \textbar{}
              \textbar{}       \textbar{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\textbar{}     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
              \textbar{}       \textbar{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\textbar{}     \textbar{}   vGPU2   \textbar{}
              \textbar{}       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
       mappable GM    \textbar{} available \textbar{} ==\PYGZgt{} \textbar{}   vGPU1   \textbar{}
              \textbar{}       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
              \textbar{}       \textbar{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\textbar{}     \textbar{}           \textbar{}
              v       \textbar{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\textbar{}     \textbar{}   Host    \textbar{}
              +=======+===========+     +===========+
              \PYGZca{}       \textbar{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\textbar{}     \textbar{}   vGPU3   \textbar{}
              \textbar{}       \textbar{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\textbar{}     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
              \textbar{}       \textbar{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\textbar{}     \textbar{}   vGPU2   \textbar{}
              \textbar{}       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
     unmappable GM    \textbar{} available \textbar{} ==\PYGZgt{} \textbar{}   vGPU1   \textbar{}
              \textbar{}       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
              \textbar{}       \textbar{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\textbar{}     \textbar{}           \textbar{}
              \textbar{}       \textbar{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\textbar{}     \textbar{}   Host    \textbar{}
              v       \textbar{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\textbar{}     \textbar{}           \textbar{}
total GM size \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{Verbatim}

\textbf{Return}

zero on success, non-zero if configuration invalid or ballooning failed


\subsection{Intel GVT-g Host Support(vGPU device model)}
\label{gpu/i915:intel-gvt-g-host-support-vgpu-device-model}
Intel GVT-g is a graphics virtualization technology which shares the
GPU among multiple virtual machines on a time-sharing basis. Each
virtual machine is presented a virtual GPU (vGPU), which has equivalent
features as the underlying physical GPU (pGPU), so i915 driver can run
seamlessly in a virtual machine.

To virtualize GPU resources GVT-g driver depends on hypervisor technology
e.g KVM/VFIO/mdev, Xen, etc. to provide resource access trapping capability
and be virtualized within GVT-g device module. More architectural design
doc is available on \href{https://01.org/group/2230/documentation-list}{https://01.org/group/2230/documentation-list}.
\index{intel\_gvt\_sanitize\_options (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_gvt_sanitize_options}\pysiglinewithargsret{void \bfcode{intel\_gvt\_sanitize\_options}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
sanitize GVT related options

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
drm i915 private data

\end{description}

\textbf{Description}

This function is called at the i915 options sanitize stage.
\index{intel\_gvt\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_gvt_init}\pysiglinewithargsret{int \bfcode{intel\_gvt\_init}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
initialize GVT components

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
drm i915 private data

\end{description}

\textbf{Description}

This function is called at the initialization stage to create a GVT device.

\textbf{Return}

Zero on success, negative error code if failed.
\index{intel\_gvt\_cleanup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_gvt_cleanup}\pysiglinewithargsret{void \bfcode{intel\_gvt\_cleanup}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
cleanup GVT components when i915 driver is unloading

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
drm i915 private *

\end{description}

\textbf{Description}

This function is called at the i915 driver unloading stage, to shutdown
GVT components and release the related resources.


\section{Display Hardware Handling}
\label{gpu/i915:display-hardware-handling}
This section covers everything related to the display hardware including
the mode setting infrastructure, plane, sprite and cursor handling and
display, output probing and related topics.


\subsection{Mode Setting Infrastructure}
\label{gpu/i915:mode-setting-infrastructure}
The i915 driver is thus far the only DRM driver which doesn't use the
common DRM helper code to implement mode setting sequences. Thus it has
its own tailor-made infrastructure for executing a display configuration
change.


\subsection{Frontbuffer Tracking}
\label{gpu/i915:frontbuffer-tracking}
Many features require us to track changes to the currently active
frontbuffer, especially rendering targeted at the frontbuffer.

To be able to do so GEM tracks frontbuffers using a bitmask for all possible
frontbuffer slots through {\hyperref[gpu/i915:c.i915_gem_track_fb]{\emph{\code{i915\_gem\_track\_fb()}}}}. The function in this file are
then called when the contents of the frontbuffer are invalidated, when
frontbuffer rendering has stopped again to flush out all the changes and when
the frontbuffer is exchanged with a flip. Subsystems interested in
frontbuffer changes (e.g. PSR, FBC, DRRS) should directly put their callbacks
into the relevant places and filter for the frontbuffer slots that they are
interested int.

On a high level there are two types of powersaving features. The first one
work like a special cache (FBC and PSR) and are interested when they should
stop caching and when to restart caching. This is done by placing callbacks
into the invalidate and the flush functions: At invalidate the caching must
be stopped and at flush time it can be restarted. And maybe they need to know
when the frontbuffer changes (e.g. when the hw doesn't initiate an invalidate
and flush on its own) which can be achieved with placing callbacks into the
flip functions.

The other type of display power saving feature only cares about busyness
(e.g. DRRS). In that case all three (invalidate, flush and flip) indicate
busyness. There is no direct way to detect idleness. Instead an idle timer
work delayed work should be started from the flush and flip functions and
cancelled as soon as busyness is detected.

Note that there's also an older frontbuffer activity tracking scheme which
just tracks general activity. This is done by the various mark\_busy and
mark\_idle functions. For display power management features using these
functions is deprecated and should be avoided.
\index{intel\_fb\_obj\_invalidate (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_fb_obj_invalidate}\pysiglinewithargsret{bool \bfcode{intel\_fb\_obj\_invalidate}}{struct drm\_i915\_gem\_object *\emph{ obj}, enum fb\_op\_origin\emph{ origin}}{}
invalidate frontbuffer object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_gem\_object * obj}}] \leavevmode
GEM object to invalidate

\item[{\code{enum fb\_op\_origin origin}}] \leavevmode
which operation caused the invalidation

\end{description}

\textbf{Description}

This function gets called every time rendering on the given object starts and
frontbuffer caching (fbc, low refresh rate for DRRS, panel self refresh) must
be invalidated. For ORIGIN\_CS any subsequent invalidation will be delayed
until the rendering completes or a flip on this frontbuffer plane is
scheduled.
\index{intel\_fb\_obj\_flush (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_fb_obj_flush}\pysiglinewithargsret{void \bfcode{intel\_fb\_obj\_flush}}{struct drm\_i915\_gem\_object *\emph{ obj}, enum fb\_op\_origin\emph{ origin}}{}
flush frontbuffer object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_gem\_object * obj}}] \leavevmode
GEM object to flush

\item[{\code{enum fb\_op\_origin origin}}] \leavevmode
which operation caused the flush

\end{description}

\textbf{Description}

This function gets called every time rendering on the given object has
completed and frontbuffer caching can be started again.
\index{intel\_frontbuffer\_flush (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_frontbuffer_flush}\pysiglinewithargsret{void \bfcode{intel\_frontbuffer\_flush}}{struct drm\_i915\_private *\emph{ dev\_priv}, unsigned\emph{ frontbuffer\_bits}, enum fb\_op\_origin\emph{ origin}}{}
flush frontbuffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\item[{\code{unsigned frontbuffer\_bits}}] \leavevmode
frontbuffer plane tracking bits

\item[{\code{enum fb\_op\_origin origin}}] \leavevmode
which operation caused the flush

\end{description}

\textbf{Description}

This function gets called every time rendering on the given planes has
completed and frontbuffer caching can be started again. Flushes will get
delayed if they're blocked by some outstanding asynchronous rendering.

Can be called without any locks held.
\index{intel\_frontbuffer\_flip\_prepare (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_frontbuffer_flip_prepare}\pysiglinewithargsret{void \bfcode{intel\_frontbuffer\_flip\_prepare}}{struct drm\_i915\_private *\emph{ dev\_priv}, unsigned\emph{ frontbuffer\_bits}}{}
prepare asynchronous frontbuffer flip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\item[{\code{unsigned frontbuffer\_bits}}] \leavevmode
frontbuffer plane tracking bits

\end{description}

\textbf{Description}

This function gets called after scheduling a flip on \textbf{obj}. The actual
frontbuffer flushing will be delayed until completion is signalled with
intel\_frontbuffer\_flip\_complete. If an invalidate happens in between this
flush will be cancelled.

Can be called without any locks held.
\index{intel\_frontbuffer\_flip\_complete (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_frontbuffer_flip_complete}\pysiglinewithargsret{void \bfcode{intel\_frontbuffer\_flip\_complete}}{struct drm\_i915\_private *\emph{ dev\_priv}, unsigned\emph{ frontbuffer\_bits}}{}
complete asynchronous frontbuffer flip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\item[{\code{unsigned frontbuffer\_bits}}] \leavevmode
frontbuffer plane tracking bits

\end{description}

\textbf{Description}

This function gets called after the flip has been latched and will complete
on the next vblank. It will execute the flush if it hasn't been cancelled yet.

Can be called without any locks held.
\index{intel\_frontbuffer\_flip (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_frontbuffer_flip}\pysiglinewithargsret{void \bfcode{intel\_frontbuffer\_flip}}{struct drm\_i915\_private *\emph{ dev\_priv}, unsigned\emph{ frontbuffer\_bits}}{}
synchronous frontbuffer flip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\item[{\code{unsigned frontbuffer\_bits}}] \leavevmode
frontbuffer plane tracking bits

\end{description}

\textbf{Description}

This function gets called after scheduling a flip on \textbf{obj}. This is for
synchronous plane updates which will happen on the next vblank and which will
not get delayed by pending gpu rendering.

Can be called without any locks held.
\index{i915\_gem\_track\_fb (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_track_fb}\pysiglinewithargsret{void \bfcode{i915\_gem\_track\_fb}}{struct drm\_i915\_gem\_object *\emph{ old}, struct drm\_i915\_gem\_object *\emph{ new}, unsigned\emph{ frontbuffer\_bits}}{}
update frontbuffer tracking

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_gem\_object * old}}] \leavevmode
current GEM buffer for the frontbuffer slots

\item[{\code{struct drm\_i915\_gem\_object * new}}] \leavevmode
new GEM buffer for the frontbuffer slots

\item[{\code{unsigned frontbuffer\_bits}}] \leavevmode
bitmask of frontbuffer slots

\end{description}

\textbf{Description}

This updates the frontbuffer tracking bits \textbf{frontbuffer\_bits} by clearing them
from \textbf{old} and setting them in \textbf{new}. Both \textbf{old} and \textbf{new} can be NULL.


\subsection{Display FIFO Underrun Reporting}
\label{gpu/i915:display-fifo-underrun-reporting}
The i915 driver checks for display fifo underruns using the interrupt signals
provided by the hardware. This is enabled by default and fairly useful to
debug display issues, especially watermark settings.

If an underrun is detected this is logged into dmesg. To avoid flooding logs
and occupying the cpu underrun interrupts are disabled after the first
occurrence until the next modeset on a given pipe.

Note that underrun detection on gmch platforms is a bit more ugly since there
is no interrupt (despite that the signalling bit is in the PIPESTAT pipe
interrupt register). Also on some other platforms underrun interrupts are
shared, which means that if we detect an underrun we need to disable underrun
reporting on all pipes.

The code also supports underrun detection on the PCH transcoder.
\index{intel\_set\_cpu\_fifo\_underrun\_reporting (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_set_cpu_fifo_underrun_reporting}\pysiglinewithargsret{bool \bfcode{intel\_set\_cpu\_fifo\_underrun\_reporting}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum pipe\emph{ pipe}, bool\emph{ enable}}{}
set cpu fifo underrrun reporting state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum pipe pipe}}] \leavevmode
(CPU) pipe to set state for

\item[{\code{bool enable}}] \leavevmode
whether underruns should be reported or not

\end{description}

\textbf{Description}

This function sets the fifo underrun state for \textbf{pipe}. It is used in the
modeset code to avoid false positives since on many platforms underruns are
expected when disabling or enabling the pipe.

Notice that on some platforms disabling underrun reports for one pipe
disables for all due to shared interrupts. Actual reporting is still per-pipe
though.

Returns the previous state of underrun reporting.
\index{intel\_set\_pch\_fifo\_underrun\_reporting (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_set_pch_fifo_underrun_reporting}\pysiglinewithargsret{bool \bfcode{intel\_set\_pch\_fifo\_underrun\_reporting}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum pipe\emph{ pch\_transcoder}, bool\emph{ enable}}{}
set PCH fifo underrun reporting state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum pipe pch\_transcoder}}] \leavevmode
the PCH transcoder (same as pipe on IVB and older)

\item[{\code{bool enable}}] \leavevmode
whether underruns should be reported or not

\end{description}

\textbf{Description}

This function makes us disable or enable PCH fifo underruns for a specific
PCH transcoder. Notice that on some PCHs (e.g. CPT/PPT), disabling FIFO
underrun reporting for one transcoder may also disable all the other PCH
error interruts for the other transcoders, due to the fact that there's just
one interrupt mask/enable bit for all the transcoders.

Returns the previous state of underrun reporting.
\index{intel\_cpu\_fifo\_underrun\_irq\_handler (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_cpu_fifo_underrun_irq_handler}\pysiglinewithargsret{void \bfcode{intel\_cpu\_fifo\_underrun\_irq\_handler}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum pipe\emph{ pipe}}{}
handle CPU fifo underrun interrupt

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum pipe pipe}}] \leavevmode
(CPU) pipe to set state for

\end{description}

\textbf{Description}

This handles a CPU fifo underrun interrupt, generating an underrun warning
into dmesg if underrun reporting is enabled and then disables the underrun
interrupt to avoid an irq storm.
\index{intel\_pch\_fifo\_underrun\_irq\_handler (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_pch_fifo_underrun_irq_handler}\pysiglinewithargsret{void \bfcode{intel\_pch\_fifo\_underrun\_irq\_handler}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum pipe\emph{ pch\_transcoder}}{}
handle PCH fifo underrun interrupt

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum pipe pch\_transcoder}}] \leavevmode
the PCH transcoder (same as pipe on IVB and older)

\end{description}

\textbf{Description}

This handles a PCH fifo underrun interrupt, generating an underrun warning
into dmesg if underrun reporting is enabled and then disables the underrun
interrupt to avoid an irq storm.
\index{intel\_check\_cpu\_fifo\_underruns (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_check_cpu_fifo_underruns}\pysiglinewithargsret{void \bfcode{intel\_check\_cpu\_fifo\_underruns}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
check for CPU fifo underruns immediately

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

Check for CPU fifo underruns immediately. Useful on IVB/HSW where the shared
error interrupt may have been disabled, and so CPU fifo underruns won't
necessarily raise an interrupt, and on GMCH platforms where underruns never
raise an interrupt.
\index{intel\_check\_pch\_fifo\_underruns (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_check_pch_fifo_underruns}\pysiglinewithargsret{void \bfcode{intel\_check\_pch\_fifo\_underruns}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
check for PCH fifo underruns immediately

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

Check for PCH fifo underruns immediately. Useful on CPT/PPT where the shared
error interrupt may have been disabled, and so PCH fifo underruns won't
necessarily raise an interrupt.


\subsection{Plane Configuration}
\label{gpu/i915:plane-configuration}
This section covers plane configuration and composition with the primary
plane, sprites, cursors and overlays. This includes the infrastructure
to do atomic vsync'ed updates of all this state and also tightly coupled
topics like watermark setup and computation, framebuffer compression and
panel self refresh.


\subsection{Atomic Plane Helpers}
\label{gpu/i915:atomic-plane-helpers}
The functions here are used by the atomic plane helper functions to
implement legacy plane updates (i.e., drm\_plane-\textgreater{}:c:func:\emph{update\_plane()} and
drm\_plane-\textgreater{}:c:func:\emph{disable\_plane()}).  This allows plane updates to use the
atomic state infrastructure and perform plane updates as separate
prepare/check/commit/cleanup steps.
\index{intel\_create\_plane\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_create_plane_state}\pysiglinewithargsret{struct intel\_plane\_state * \bfcode{intel\_create\_plane\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}}{}
create plane state object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
drm plane

\end{description}

\textbf{Description}

Allocates a fresh plane state for the given plane and sets some of
the state values to sensible initial values.

\textbf{Return}

A newly allocated plane state, or NULL on failure
\index{intel\_plane\_duplicate\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_plane_duplicate_state}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} * \bfcode{intel\_plane\_duplicate\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}}{}
duplicate plane state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
drm plane

\end{description}

\textbf{Description}

Allocates and returns a copy of the plane state (both common and
Intel-specific) for the specified plane.

\textbf{Return}

The newly allocated plane state, or NULL on failure.
\index{intel\_plane\_destroy\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_plane_destroy_state}\pysiglinewithargsret{void \bfcode{intel\_plane\_destroy\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} *\emph{ state}}{}
destroy plane state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
drm plane

\item[{\code{struct drm\_plane\_state * state}}] \leavevmode
state object to destroy

\end{description}

\textbf{Description}

Destroys the plane state (both common and Intel-specific) for the
specified plane.
\index{intel\_plane\_atomic\_get\_property (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_plane_atomic_get_property}\pysiglinewithargsret{int \bfcode{intel\_plane\_atomic\_get\_property}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, const struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} *\emph{ property}, uint64\_t *\emph{ val}}{}
fetch plane property value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane to fetch property for

\item[{\code{const struct drm\_plane\_state * state}}] \leavevmode
state containing the property value

\item[{\code{struct drm\_property * property}}] \leavevmode
property to look up

\item[{\code{uint64\_t * val}}] \leavevmode
pointer to write property value into

\end{description}

\textbf{Description}

The DRM core does not store shadow copies of properties for
atomic-capable drivers.  This entrypoint is used to fetch
the current value of a driver-specific plane property.
\index{intel\_plane\_atomic\_set\_property (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_plane_atomic_set_property}\pysiglinewithargsret{int \bfcode{intel\_plane\_atomic\_set\_property}}{struct {\hyperref[gpu/drm\string-kms:c.drm_plane]{\emph{drm\_plane}}} *\emph{ plane}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} *\emph{ state}, struct {\hyperref[gpu/drm\string-kms:c.drm_property]{\emph{drm\_property}}} *\emph{ property}, uint64\_t\emph{ val}}{}
set plane property value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_plane * plane}}] \leavevmode
plane to set property for

\item[{\code{struct drm\_plane\_state * state}}] \leavevmode
state to update property value in

\item[{\code{struct drm\_property * property}}] \leavevmode
property to set

\item[{\code{uint64\_t val}}] \leavevmode
value to set property to

\end{description}

\textbf{Description}

Writes the specified property value for a plane into the provided atomic
state object.

Returns 0 on success, -EINVAL on unrecognized properties


\subsection{Output Probing}
\label{gpu/i915:output-probing}
This section covers output probing and related infrastructure like the
hotplug interrupt storm detection and mitigation code. Note that the
i915 driver still uses most of the common DRM helper code for output
probing, so those sections fully apply.


\subsection{Hotplug}
\label{gpu/i915:hotplug}
Simply put, hotplug occurs when a display is connected to or disconnected
from the system. However, there may be adapters and docking stations and
Display Port short pulses and MST devices involved, complicating matters.

Hotplug in i915 is handled in many different levels of abstraction.

The platform dependent interrupt handling code in i915\_irq.c enables,
disables, and does preliminary handling of the interrupts. The interrupt
handlers gather the hotplug detect (HPD) information from relevant registers
into a platform independent mask of hotplug pins that have fired.

The platform independent interrupt handler {\hyperref[gpu/i915:c.intel_hpd_irq_handler]{\emph{\code{intel\_hpd\_irq\_handler()}}}} in
intel\_hotplug.c does hotplug irq storm detection and mitigation, and passes
further processing to appropriate bottom halves (Display Port specific and
regular hotplug).

The Display Port work function \code{i915\_digport\_work\_func()} calls into
\code{intel\_dp\_hpd\_pulse()} via hooks, which handles DP short pulses and DP MST long
pulses, with failures and non-MST long pulses triggering regular hotplug
processing on the connector.

The regular hotplug work function \code{i915\_hotplug\_work\_func()} calls connector
detect hooks, and, if connector status changes, triggers sending of hotplug
uevent to userspace via {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_kms_helper_hotplug_event]{\emph{\code{drm\_kms\_helper\_hotplug\_event()}}}}.

Finally, the userspace is responsible for triggering a modeset upon receiving
the hotplug uevent, disabling or enabling the crtc as needed.

The hotplug interrupt storm detection and mitigation code keeps track of the
number of interrupts per hotplug pin per a period of time, and if the number
of interrupts exceeds a certain threshold, the interrupt is disabled for a
while before being re-enabled. The intention is to mitigate issues raising
from broken hardware triggering massive amounts of interrupts and grinding
the system to a halt.

Current implementation expects that hotplug interrupt storm will not be
seen when display port sink is connected, hence on platforms whose DP
callback is handled by i915\_digport\_work\_func reenabling of hpd is not
performed (it was never expected to be disabled in the first place ;) )
this is specific to DP sinks handled by this routine and any other display
such as HDMI or DVI enabled on the same port will have proper logic since
it will use i915\_hotplug\_work\_func where this logic is handled.
\index{intel\_hpd\_pin\_to\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_hpd_pin_to_port}\pysiglinewithargsret{enum port \bfcode{intel\_hpd\_pin\_to\_port}}{enum hpd\_pin\emph{ pin}}{}
return port hard associated with certain pin.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{enum hpd\_pin pin}}] \leavevmode
the hpd pin to get associated port

\end{description}

\textbf{Description}

Return port that is associatade with \textbf{pin} and PORT\_NONE if no port is
hard associated with that \textbf{pin}.
\index{intel\_hpd\_pin (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_hpd_pin}\pysiglinewithargsret{enum hpd\_pin \bfcode{intel\_hpd\_pin}}{enum port\emph{ port}}{}
return pin hard associated with certain port.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{enum port port}}] \leavevmode
the hpd port to get associated pin

\end{description}

\textbf{Description}

Return pin that is associatade with \textbf{port} and HDP\_NONE if no pin is
hard associated with that \textbf{port}.
\index{intel\_hpd\_irq\_storm\_detect (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_hpd_irq_storm_detect}\pysiglinewithargsret{bool \bfcode{intel\_hpd\_irq\_storm\_detect}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum hpd\_pin\emph{ pin}}{}
gather stats and detect HPD irq storm on a pin

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
private driver data pointer

\item[{\code{enum hpd\_pin pin}}] \leavevmode
the pin to gather stats on

\end{description}

\textbf{Description}

Gather stats about HPD irqs from the specified \textbf{pin}, and detect irq
storms. Only the pin specific stats and state are changed, the caller is
responsible for further action.

The number of irqs that are allowed within \textbf{HPD\_STORM\_DETECT\_PERIOD} is
stored in \textbf{dev\_priv}-\textgreater{}hotplug.hpd\_storm\_threshold which defaults to
\textbf{HPD\_STORM\_DEFAULT\_THRESHOLD}. If this threshold is exceeded, it's
considered an irq storm and the irq state is set to \textbf{HPD\_MARK\_DISABLED}.

The HPD threshold can be controlled through i915\_hpd\_storm\_ctl in debugfs,
and should only be adjusted for automated hotplug testing.

Return true if an irq storm was detected on \textbf{pin}.
\index{intel\_hpd\_irq\_handler (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_hpd_irq_handler}\pysiglinewithargsret{void \bfcode{intel\_hpd\_irq\_handler}}{struct drm\_i915\_private *\emph{ dev\_priv}, u32\emph{ pin\_mask}, u32\emph{ long\_mask}}{}
main hotplug irq handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
drm\_i915\_private

\item[{\code{u32 pin\_mask}}] \leavevmode
a mask of hpd pins that have triggered the irq

\item[{\code{u32 long\_mask}}] \leavevmode
a mask of hpd pins that may be long hpd pulses

\end{description}

\textbf{Description}

This is the main hotplug irq handler for all platforms. The platform specific
irq handlers call the platform specific hotplug irq handlers, which read and
decode the appropriate registers into bitmasks about hpd pins that have
triggered (\textbf{pin\_mask}), and which of those pins may be long pulses
(\textbf{long\_mask}). The \textbf{long\_mask} is ignored if the port corresponding to the pin
is not a digital port.

Here, we do hotplug irq storm detection and mitigation, and pass further
processing to appropriate bottom halves.
\index{intel\_hpd\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_hpd_init}\pysiglinewithargsret{void \bfcode{intel\_hpd\_init}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
initializes and enables hpd support

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This function enables the hotplug support. It requires that interrupts have
already been enabled with \code{intel\_irq\_init\_hw()}. From this point on hotplug and
poll request can run concurrently to other code, so locking rules must be
obeyed.

This is a separate step from interrupt enabling to simplify the locking rules
in the driver load and resume code.

Also see: {\hyperref[gpu/i915:c.intel_hpd_poll_init]{\emph{\code{intel\_hpd\_poll\_init()}}}}, which enables connector polling
\index{intel\_hpd\_poll\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_hpd_poll_init}\pysiglinewithargsret{void \bfcode{intel\_hpd\_poll\_init}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
enables/disables polling for connectors with hpd

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This function enables polling for all connectors, regardless of whether or
not they support hotplug detection. Under certain conditions HPD may not be
functional. On most Intel GPUs, this happens when we enter runtime suspend.
On Valleyview and Cherryview systems, this also happens when we shut off all
of the powerwells.

Since this function can get called in contexts where we're already holding
dev-\textgreater{}mode\_config.mutex, we do the actual hotplug enabling in a seperate
worker.

Also see: {\hyperref[gpu/i915:c.intel_hpd_init]{\emph{\code{intel\_hpd\_init()}}}}, which restores hpd handling.


\subsection{High Definition Audio}
\label{gpu/i915:high-definition-audio}
The graphics and audio drivers together support High Definition Audio over
HDMI and Display Port. The audio programming sequences are divided into audio
codec and controller enable and disable sequences. The graphics driver
handles the audio codec sequences, while the audio driver handles the audio
controller sequences.

The disable sequences must be performed before disabling the transcoder or
port. The enable sequences may only be performed after enabling the
transcoder and port, and after completed link training. Therefore the audio
enable/disable sequences are part of the modeset sequence.

The codec and controller sequences could be done either parallel or serial,
but generally the ELDV/PD change in the codec sequence indicates to the audio
driver that the controller sequence should start. Indeed, most of the
co-operation between the graphics and audio drivers is handled via audio
related registers. (The notable exception is the power management, not
covered here.)

The struct {\hyperref[gpu/i915:c.i915_audio_component]{\emph{\code{i915\_audio\_component}}}} is used to interact between the graphics
and audio drivers. The struct {\hyperref[gpu/i915:c.i915_audio_component_ops]{\emph{\code{i915\_audio\_component\_ops}}}} \textbf{ops} in it is
defined in graphics driver and called in audio driver. The
struct {\hyperref[gpu/i915:c.i915_audio_component_audio_ops]{\emph{\code{i915\_audio\_component\_audio\_ops}}}} \textbf{audio\_ops} is called from i915 driver.
\index{intel\_audio\_codec\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_audio_codec_enable}\pysiglinewithargsret{void \bfcode{intel\_audio\_codec\_enable}}{struct intel\_encoder *\emph{ encoder}, const struct intel\_crtc\_state *\emph{ crtc\_state}, const struct {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{drm\_connector\_state}}} *\emph{ conn\_state}}{}
Enable the audio codec for HD audio

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_encoder * encoder}}] \leavevmode
encoder on which to enable audio

\item[{\code{const struct intel\_crtc\_state * crtc\_state}}] \leavevmode
pointer to the current crtc state.

\item[{\code{const struct drm\_connector\_state * conn\_state}}] \leavevmode
pointer to the current connector state.

\end{description}

\textbf{Description}

The enable sequences may only be performed after enabling the transcoder and
port, and after completed link training.
\index{intel\_audio\_codec\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_audio_codec_disable}\pysiglinewithargsret{void \bfcode{intel\_audio\_codec\_disable}}{struct intel\_encoder *\emph{ encoder}, const struct intel\_crtc\_state *\emph{ old\_crtc\_state}, const struct {\hyperref[gpu/drm\string-kms:c.drm_connector_state]{\emph{drm\_connector\_state}}} *\emph{ old\_conn\_state}}{}
Disable the audio codec for HD audio

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_encoder * encoder}}] \leavevmode
encoder on which to disable audio

\item[{\code{const struct intel\_crtc\_state * old\_crtc\_state}}] \leavevmode
pointer to the old crtc state.

\item[{\code{const struct drm\_connector\_state * old\_conn\_state}}] \leavevmode
pointer to the old connector state.

\end{description}

\textbf{Description}

The disable sequences must be performed before disabling the transcoder or
port.
\index{intel\_init\_audio\_hooks (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_init_audio_hooks}\pysiglinewithargsret{void \bfcode{intel\_init\_audio\_hooks}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Set up chip specific audio hooks

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
device private

\end{description}
\index{i915\_audio\_component\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_audio_component_init}\pysiglinewithargsret{void \bfcode{i915\_audio\_component\_init}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
initialize and register the audio component

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This will register with the component framework a child component which
will bind dynamically to the snd\_hda\_intel driver's corresponding master
component when the latter is registered. During binding the child
initializes an instance of struct i915\_audio\_component which it receives
from the master. The master can then start to use the interface defined by
this struct. Each side can break the binding at any point by deregistering
its own component after which each side's component unbind callback is
called.

We ignore any error during registration and continue with reduced
functionality (i.e. without HDMI audio).
\index{i915\_audio\_component\_cleanup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_audio_component_cleanup}\pysiglinewithargsret{void \bfcode{i915\_audio\_component\_cleanup}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
deregister the audio component

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

Deregisters the audio component, breaking any existing binding to the
corresponding snd\_hda\_intel driver's master component.
\index{intel\_audio\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_audio_init}\pysiglinewithargsret{void \bfcode{intel\_audio\_init}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Initialize the audio driver either using component framework or using lpe audio bridge

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
the i915 drm device private data

\end{description}
\index{intel\_audio\_deinit (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_audio_deinit}\pysiglinewithargsret{void \bfcode{intel\_audio\_deinit}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
deinitialize the audio driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
the i915 drm device private data

\end{description}
\index{i915\_audio\_component\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_audio_component_ops}\pysigline{struct \bfcode{i915\_audio\_component\_ops}}
Ops implemented by i915 driver, called by hda driver

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct i915\PYGZus{}audio\PYGZus{}component\PYGZus{}ops \PYGZob{}
  struct module *owner;
  void (*get\PYGZus{}power)(struct device *);
  void (*put\PYGZus{}power)(struct device *);
  void (*codec\PYGZus{}wake\PYGZus{}override)(struct device *, bool enable);
  int (*get\PYGZus{}cdclk\PYGZus{}freq)(struct device *);
  int (*sync\PYGZus{}audio\PYGZus{}rate)(struct device *, int port, int pipe, int rate);
  int (*get\PYGZus{}eld)(struct device *, int port, int pipe, bool *enabled, unsigned char *buf, int max\PYGZus{}bytes);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{owner}}] \leavevmode
i915 module

\item[{\code{get\_power}}] \leavevmode
get the POWER\_DOMAIN\_AUDIO power well

Request the power well to be turned on.

\item[{\code{put\_power}}] \leavevmode
put the POWER\_DOMAIN\_AUDIO power well

Allow the power well to be turned off.

\item[{\code{codec\_wake\_override}}] \leavevmode
Enable/disable codec wake signal

\item[{\code{get\_cdclk\_freq}}] \leavevmode
Get the Core Display Clock in kHz

\item[{\code{sync\_audio\_rate}}] \leavevmode
set n/cts based on the sample rate

Called from audio driver. After audio driver sets the
sample rate, it will call this function to set n/cts

\item[{\code{get\_eld}}] \leavevmode
fill the audio state and ELD bytes for the given port

Called from audio driver to get the HDMI/DP audio state of the given
digital port, and also fetch ELD bytes to the given pointer.

It returns the byte size of the original ELD (not the actually
copied size), zero for an invalid ELD, or a negative error code.

Note that the returned size may be over \textbf{max\_bytes}.  Then it
implies that only a part of ELD has been copied to the buffer.

\end{description}
\index{i915\_audio\_component\_audio\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_audio_component_audio_ops}\pysigline{struct \bfcode{i915\_audio\_component\_audio\_ops}}
Ops implemented by hda driver, called by i915 driver

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct i915\PYGZus{}audio\PYGZus{}component\PYGZus{}audio\PYGZus{}ops \PYGZob{}
  void *audio\PYGZus{}ptr;
  void (*pin\PYGZus{}eld\PYGZus{}notify)(void *audio\PYGZus{}ptr, int port, int pipe);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{audio\_ptr}}] \leavevmode
Pointer to be used in call to pin\_eld\_notify

\item[{\code{pin\_eld\_notify}}] \leavevmode
Notify the HDA driver that pin sense and/or ELD information has changed

Called when the i915 driver has set up audio pipeline or has just
begun to tear it down. This allows the HDA driver to update its
status accordingly (even when the HDA controller is in power save
mode).

\end{description}
\index{i915\_audio\_component (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_audio_component}\pysigline{struct \bfcode{i915\_audio\_component}}
Used for direct communication between i915 and hda drivers

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct i915\PYGZus{}audio\PYGZus{}component \PYGZob{}
  struct device *dev;
  int aud\PYGZus{}sample\PYGZus{}rate[MAX\PYGZus{}PORTS];
  const struct i915\PYGZus{}audio\PYGZus{}component\PYGZus{}ops *ops;
  const struct i915\PYGZus{}audio\PYGZus{}component\PYGZus{}audio\PYGZus{}ops *audio\PYGZus{}ops;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev}}] \leavevmode
i915 device, used as parameter for ops

\item[{\code{aud\_sample\_rate}}] \leavevmode
the array of audio sample rate per port

\item[{\code{ops}}] \leavevmode
Ops implemented by i915 driver, called by hda driver

\item[{\code{audio\_ops}}] \leavevmode
Ops implemented by hda driver, called by i915 driver

\end{description}


\subsection{Intel HDMI LPE Audio Support}
\label{gpu/i915:intel-hdmi-lpe-audio-support}
Motivation:
Atom platforms (e.g. valleyview and cherryTrail) integrates a DMA-based
interface as an alternative to the traditional HDaudio path. While this
mode is unrelated to the LPE aka SST audio engine, the documentation refers
to this mode as LPE so we keep this notation for the sake of consistency.

The interface is handled by a separate standalone driver maintained in the
ALSA subsystem for simplicity. To minimize the interaction between the two
subsystems, a bridge is setup between the hdmi-lpe-audio and i915:
1. Create a platform device to share MMIO/IRQ resources
2. Make the platform device child of i915 device for runtime PM.
3. Create IRQ chip to forward the LPE audio irqs.
the hdmi-lpe-audio driver probes the lpe audio device and creates a new
sound card

Threats:
Due to the restriction in Linux platform device model, user need manually
uninstall the hdmi-lpe-audio driver before uninstalling i915 module,
otherwise we might run into use-after-free issues after i915 removes the
platform device: even though hdmi-lpe-audio driver is released, the modules
is still in ``installed'' status.

Implementation:
The MMIO/REG platform resources are created according to the registers
specification.
When forwarding LPE audio irqs, the flow control handler selection depends
on the platform, for example on valleyview handle\_simple\_irq is enough.
\index{intel\_lpe\_audio\_irq\_handler (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_lpe_audio_irq_handler}\pysiglinewithargsret{void \bfcode{intel\_lpe\_audio\_irq\_handler}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
forwards the LPE audio irq

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
the i915 drm device private data

\end{description}

\textbf{Description}

the LPE Audio irq is forwarded to the irq handler registered by LPE audio
driver.
\index{intel\_lpe\_audio\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_lpe_audio_init}\pysiglinewithargsret{int \bfcode{intel\_lpe\_audio\_init}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
detect and setup the bridge between HDMI LPE Audio driver and i915

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
the i915 drm device private data

\end{description}

\textbf{Return}

0 if successful. non-zero if detection or
llocation/initialization fails
\index{intel\_lpe\_audio\_teardown (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_lpe_audio_teardown}\pysiglinewithargsret{void \bfcode{intel\_lpe\_audio\_teardown}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
destroy the bridge between HDMI LPE audio driver and i915

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
the i915 drm device private data

\end{description}

\textbf{Description}

release all the resources for LPE audio \textless{}-\textgreater{} i915 bridge.
\index{intel\_lpe\_audio\_notify (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_lpe_audio_notify}\pysiglinewithargsret{void \bfcode{intel\_lpe\_audio\_notify}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum pipe\emph{ pipe}, enum port\emph{ port}, const void *\emph{ eld}, int\emph{ ls\_clock}, bool\emph{ dp\_output}}{}
notify lpe audio event audio driver and i915

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
the i915 drm device private data

\item[{\code{enum pipe pipe}}] \leavevmode
pipe

\item[{\code{enum port port}}] \leavevmode
port

\item[{\code{const void * eld}}] \leavevmode
ELD data

\item[{\code{int ls\_clock}}] \leavevmode
Link symbol clock in kHz

\item[{\code{bool dp\_output}}] \leavevmode
Driving a DP output?

\end{description}

\textbf{Description}

Notify lpe audio driver of eld change.


\subsection{Panel Self Refresh PSR (PSR/SRD)}
\label{gpu/i915:panel-self-refresh-psr-psr-srd}
Since Haswell Display controller supports Panel Self-Refresh on display
panels witch have a remote frame buffer (RFB) implemented according to PSR
spec in eDP1.3. PSR feature allows the display to go to lower standby states
when system is idle but display is on as it eliminates display refresh
request to DDR memory completely as long as the frame buffer for that
display is unchanged.

Panel Self Refresh must be supported by both Hardware (source) and
Panel (sink).

PSR saves power by caching the framebuffer in the panel RFB, which allows us
to power down the link and memory controller. For DSI panels the same idea
is called ``manual mode''.

The implementation uses the hardware-based PSR support which automatically
enters/exits self-refresh mode. The hardware takes care of sending the
required DP aux message and could even retrain the link (that part isn't
enabled yet though). The hardware also keeps track of any frontbuffer
changes to know when to exit self-refresh mode again. Unfortunately that
part doesn't work too well, hence why the i915 PSR support uses the
software frontbuffer tracking to make sure it doesn't miss a screen
update. For this integration {\hyperref[gpu/i915:c.intel_psr_invalidate]{\emph{\code{intel\_psr\_invalidate()}}}} and {\hyperref[gpu/i915:c.intel_psr_flush]{\emph{\code{intel\_psr\_flush()}}}}
get called by the frontbuffer tracking code. Note that because of locking
issues the self-refresh re-enable code is done from a work queue, which
must be correctly synchronized/cancelled when shutting down the pipe.''
\index{intel\_psr\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_psr_enable}\pysiglinewithargsret{void \bfcode{intel\_psr\_enable}}{struct intel\_dp *\emph{ intel\_dp}, const struct intel\_crtc\_state *\emph{ crtc\_state}}{}
Enable PSR

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_dp * intel\_dp}}] \leavevmode
Intel DP

\item[{\code{const struct intel\_crtc\_state * crtc\_state}}] \leavevmode
new CRTC state

\end{description}

\textbf{Description}

This function can only be called after the pipe is fully trained and enabled.
\index{intel\_psr\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_psr_disable}\pysiglinewithargsret{void \bfcode{intel\_psr\_disable}}{struct intel\_dp *\emph{ intel\_dp}, const struct intel\_crtc\_state *\emph{ old\_crtc\_state}}{}
Disable PSR

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_dp * intel\_dp}}] \leavevmode
Intel DP

\item[{\code{const struct intel\_crtc\_state * old\_crtc\_state}}] \leavevmode
old CRTC state

\end{description}

\textbf{Description}

This function needs to be called before disabling pipe.
\index{intel\_psr\_single\_frame\_update (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_psr_single_frame_update}\pysiglinewithargsret{void \bfcode{intel\_psr\_single\_frame\_update}}{struct drm\_i915\_private *\emph{ dev\_priv}, unsigned\emph{ frontbuffer\_bits}}{}
Single Frame Update

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\item[{\code{unsigned frontbuffer\_bits}}] \leavevmode
frontbuffer plane tracking bits

\end{description}

\textbf{Description}

Some platforms support a single frame update feature that is used to
send and update only one frame on Remote Frame Buffer.
So far it is only implemented for Valleyview and Cherryview because
hardware requires this to be done before a page flip.
\index{intel\_psr\_invalidate (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_psr_invalidate}\pysiglinewithargsret{void \bfcode{intel\_psr\_invalidate}}{struct drm\_i915\_private *\emph{ dev\_priv}, unsigned\emph{ frontbuffer\_bits}}{}
Invalidade PSR

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\item[{\code{unsigned frontbuffer\_bits}}] \leavevmode
frontbuffer plane tracking bits

\end{description}

\textbf{Description}

Since the hardware frontbuffer tracking has gaps we need to integrate
with the software frontbuffer tracking. This function gets called every
time frontbuffer rendering starts and a buffer gets dirtied. PSR must be
disabled if the frontbuffer mask contains a buffer relevant to PSR.

Dirty frontbuffers relevant to PSR are tracked in busy\_frontbuffer\_bits.''
\index{intel\_psr\_flush (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_psr_flush}\pysiglinewithargsret{void \bfcode{intel\_psr\_flush}}{struct drm\_i915\_private *\emph{ dev\_priv}, unsigned\emph{ frontbuffer\_bits}, enum fb\_op\_origin\emph{ origin}}{}
Flush PSR

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\item[{\code{unsigned frontbuffer\_bits}}] \leavevmode
frontbuffer plane tracking bits

\item[{\code{enum fb\_op\_origin origin}}] \leavevmode
which operation caused the flush

\end{description}

\textbf{Description}

Since the hardware frontbuffer tracking has gaps we need to integrate
with the software frontbuffer tracking. This function gets called every
time frontbuffer rendering has completed and flushed out to memory. PSR
can be enabled again if no other frontbuffer relevant to PSR is dirty.

Dirty frontbuffers relevant to PSR are tracked in busy\_frontbuffer\_bits.
\index{intel\_psr\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_psr_init}\pysiglinewithargsret{void \bfcode{intel\_psr\_init}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Init basic PSR work and mutex.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device private

\end{description}

\textbf{Description}

This function is  called only once at driver load to initialize basic
PSR stuff.


\subsection{Frame Buffer Compression (FBC)}
\label{gpu/i915:frame-buffer-compression-fbc}
FBC tries to save memory bandwidth (and so power consumption) by
compressing the amount of memory used by the display. It is total
transparent to user space and completely handled in the kernel.

The benefits of FBC are mostly visible with solid backgrounds and
variation-less patterns. It comes from keeping the memory footprint small
and having fewer memory pages opened and accessed for refreshing the display.

i915 is responsible to reserve stolen memory for FBC and configure its
offset on proper registers. The hardware takes care of all
compress/decompress. However there are many known cases where we have to
forcibly disable it to allow proper screen updates.
\index{intel\_fbc\_is\_active (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_fbc_is_active}\pysiglinewithargsret{bool \bfcode{intel\_fbc\_is\_active}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Is FBC active?

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This function is used to verify the current state of FBC.

FIXME: This should be tracked in the plane config eventually
instead of queried at runtime for most callers.
\index{intel\_fbc\_choose\_crtc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_fbc_choose_crtc}\pysiglinewithargsret{void \bfcode{intel\_fbc\_choose\_crtc}}{struct drm\_i915\_private *\emph{ dev\_priv}, struct intel\_atomic\_state *\emph{ state}}{}
select a CRTC to enable FBC on

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{struct intel\_atomic\_state * state}}] \leavevmode
the atomic state structure

\end{description}

\textbf{Description}

This function looks at the proposed state for CRTCs and planes, then chooses
which pipe is going to have FBC by setting intel\_crtc\_state-\textgreater{}enable\_fbc to
true.

Later, intel\_fbc\_enable is going to look for state-\textgreater{}enable\_fbc and then maybe
enable FBC for the chosen CRTC. If it does, it will set dev\_priv-\textgreater{}fbc.crtc.
\index{intel\_fbc\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_fbc_enable}\pysiglinewithargsret{void \bfcode{intel\_fbc\_enable}}{struct intel\_crtc *\emph{ crtc}, struct intel\_crtc\_state *\emph{ crtc\_state}, struct intel\_plane\_state *\emph{ plane\_state}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_crtc * crtc}}] \leavevmode
the CRTC

\item[{\code{struct intel\_crtc\_state * crtc\_state}}] \leavevmode
corresponding {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{\code{drm\_crtc\_state}}}} for \textbf{crtc}

\item[{\code{struct intel\_plane\_state * plane\_state}}] \leavevmode
corresponding {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{\code{drm\_plane\_state}}}} for the primary plane of \textbf{crtc}

\end{description}

\textbf{Description}

This function checks if the given CRTC was chosen for FBC, then enables it if
possible. Notice that it doesn't activate FBC. It is valid to call
intel\_fbc\_enable multiple times for the same pipe without an
intel\_fbc\_disable in the middle, as long as it is deactivated.
\index{\_\_intel\_fbc\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.__intel_fbc_disable}\pysiglinewithargsret{void \bfcode{\_\_intel\_fbc\_disable}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
disable FBC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This is the low level function that actually disables FBC. Callers should
grab the FBC lock.
\index{intel\_fbc\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_fbc_disable}\pysiglinewithargsret{void \bfcode{intel\_fbc\_disable}}{struct intel\_crtc *\emph{ crtc}}{}
disable FBC if it's associated with crtc

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_crtc * crtc}}] \leavevmode
the CRTC

\end{description}

\textbf{Description}

This function disables FBC if it's associated with the provided CRTC.
\index{intel\_fbc\_global\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_fbc_global_disable}\pysiglinewithargsret{void \bfcode{intel\_fbc\_global\_disable}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
globally disable FBC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This function disables FBC regardless of which CRTC is associated with it.
\index{intel\_fbc\_handle\_fifo\_underrun\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_fbc_handle_fifo_underrun_irq}\pysiglinewithargsret{void \bfcode{intel\_fbc\_handle\_fifo\_underrun\_irq}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
disable FBC when we get a FIFO underrun

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

Without FBC, most underruns are harmless and don't really cause too many
problems, except for an annoying message on dmesg. With FBC, underruns can
become black screens or even worse, especially when paired with bad
watermarks. So in order for us to be on the safe side, completely disable FBC
in case we ever detect a FIFO underrun on any pipe. An underrun on any pipe
already suggests that watermarks may be bad, so try to be as safe as
possible.

This function is called from the IRQ handler.
\index{intel\_fbc\_init\_pipe\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_fbc_init_pipe_state}\pysiglinewithargsret{void \bfcode{intel\_fbc\_init\_pipe\_state}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
initialize FBC's CRTC visibility tracking

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

The FBC code needs to track CRTC visibility since the older platforms can't
have FBC enabled while multiple pipes are used. This function does the
initial setup at driver load to make sure FBC is matching the real hardware.
\index{intel\_fbc\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_fbc_init}\pysiglinewithargsret{void \bfcode{intel\_fbc\_init}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Initialize FBC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
the i915 device

\end{description}

\textbf{Description}

This function might be called during PM init process.


\subsection{Display Refresh Rate Switching (DRRS)}
\label{gpu/i915:display-refresh-rate-switching-drrs}
Display Refresh Rate Switching (DRRS) is a power conservation feature
which enables swtching between low and high refresh rates,
dynamically, based on the usage scenario. This feature is applicable
for internal panels.

Indication that the panel supports DRRS is given by the panel EDID, which
would list multiple refresh rates for one resolution.

DRRS is of 2 types - static and seamless.
Static DRRS involves changing refresh rate (RR) by doing a full modeset
(may appear as a blink on screen) and is used in dock-undock scenario.
Seamless DRRS involves changing RR without any visual effect to the user
and can be used during normal system usage. This is done by programming
certain registers.

Support for static/seamless DRRS may be indicated in the VBT based on
inputs from the panel spec.

DRRS saves power by switching to low RR based on usage scenarios.

The implementation is based on frontbuffer tracking implementation.  When
there is a disturbance on the screen triggered by user activity or a periodic
system activity, DRRS is disabled (RR is changed to high RR).  When there is
no movement on screen, after a timeout of 1 second, a switch to low RR is
made.

For integration with frontbuffer tracking code, {\hyperref[gpu/i915:c.intel_edp_drrs_invalidate]{\emph{\code{intel\_edp\_drrs\_invalidate()}}}}
and {\hyperref[gpu/i915:c.intel_edp_drrs_flush]{\emph{\code{intel\_edp\_drrs\_flush()}}}} are called.

DRRS can be further extended to support other internal panels and also
the scenario of video playback wherein RR is set based on the rate
requested by userspace.
\index{intel\_dp\_set\_drrs\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_dp_set_drrs_state}\pysiglinewithargsret{void \bfcode{intel\_dp\_set\_drrs\_state}}{struct drm\_i915\_private *\emph{ dev\_priv}, const struct intel\_crtc\_state *\emph{ crtc\_state}, int\emph{ refresh\_rate}}{}
program registers for RR switch to take effect

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\item[{\code{const struct intel\_crtc\_state * crtc\_state}}] \leavevmode
a pointer to the active intel\_crtc\_state

\item[{\code{int refresh\_rate}}] \leavevmode
RR to be programmed

\end{description}

\textbf{Description}

This function gets called when refresh rate (RR) has to be changed from
one frequency to another. Switches can be between high and low RR
supported by the panel or to any other RR based on media playback (in
this case, RR value needs to be passed from user space).

The caller of this function needs to take a lock on dev\_priv-\textgreater{}drrs.
\index{intel\_edp\_drrs\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_edp_drrs_enable}\pysiglinewithargsret{void \bfcode{intel\_edp\_drrs\_enable}}{struct intel\_dp *\emph{ intel\_dp}, const struct intel\_crtc\_state *\emph{ crtc\_state}}{}
init drrs struct if supported

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_dp * intel\_dp}}] \leavevmode
DP struct

\item[{\code{const struct intel\_crtc\_state * crtc\_state}}] \leavevmode
A pointer to the active crtc state.

\end{description}

\textbf{Description}

Initializes frontbuffer\_bits and drrs.dp
\index{intel\_edp\_drrs\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_edp_drrs_disable}\pysiglinewithargsret{void \bfcode{intel\_edp\_drrs\_disable}}{struct intel\_dp *\emph{ intel\_dp}, const struct intel\_crtc\_state *\emph{ old\_crtc\_state}}{}
Disable DRRS

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_dp * intel\_dp}}] \leavevmode
DP struct

\item[{\code{const struct intel\_crtc\_state * old\_crtc\_state}}] \leavevmode
Pointer to old crtc\_state.

\end{description}
\index{intel\_edp\_drrs\_invalidate (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_edp_drrs_invalidate}\pysiglinewithargsret{void \bfcode{intel\_edp\_drrs\_invalidate}}{struct drm\_i915\_private *\emph{ dev\_priv}, unsigned int\emph{ frontbuffer\_bits}}{}
Disable Idleness DRRS

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\item[{\code{unsigned int frontbuffer\_bits}}] \leavevmode
frontbuffer plane tracking bits

\end{description}

\textbf{Description}

This function gets called everytime rendering on the given planes start.
Hence DRRS needs to be Upclocked, i.e. (LOW\_RR -\textgreater{} HIGH\_RR).

Dirty frontbuffers relevant to DRRS are tracked in busy\_frontbuffer\_bits.
\index{intel\_edp\_drrs\_flush (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_edp_drrs_flush}\pysiglinewithargsret{void \bfcode{intel\_edp\_drrs\_flush}}{struct drm\_i915\_private *\emph{ dev\_priv}, unsigned int\emph{ frontbuffer\_bits}}{}
Restart Idleness DRRS

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\item[{\code{unsigned int frontbuffer\_bits}}] \leavevmode
frontbuffer plane tracking bits

\end{description}

\textbf{Description}

This function gets called every time rendering on the given planes has
completed or flip on a crtc is completed. So DRRS should be upclocked
(LOW\_RR -\textgreater{} HIGH\_RR). And also Idleness detection should be started again,
if no other planes are dirty.

Dirty frontbuffers relevant to DRRS are tracked in busy\_frontbuffer\_bits.
\index{intel\_dp\_drrs\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_dp_drrs_init}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} * \bfcode{intel\_dp\_drrs\_init}}{struct intel\_connector *\emph{ connector}, struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ fixed\_mode}}{}
Init basic DRRS work and mutex.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_connector * connector}}] \leavevmode
eDP connector

\item[{\code{struct drm\_display\_mode * fixed\_mode}}] \leavevmode
preferred mode of panel

\end{description}

\textbf{Description}

This function is  called only once at driver load to initialize basic
DRRS stuff.

\textbf{Return}

Downclock mode if panel supports it, else return NULL.
DRRS support is determined by the presence of downclock mode (apart
from VBT setting).


\subsection{DPIO}
\label{gpu/i915:dpio}
VLV, CHV and BXT have slightly peculiar display PHYs for driving DP/HDMI
ports. DPIO is the name given to such a display PHY. These PHYs
don't follow the standard programming model using direct MMIO
registers, and instead their registers must be accessed trough IOSF
sideband. VLV has one such PHY for driving ports B and C, and CHV
adds another PHY for driving port D. Each PHY responds to specific
IOSF-SB port.

Each display PHY is made up of one or two channels. Each channel
houses a common lane part which contains the PLL and other common
logic. CH0 common lane also contains the IOSF-SB logic for the
Common Register Interface (CRI) ie. the DPIO registers. CRI clock
must be running when any DPIO registers are accessed.

In addition to having their own registers, the PHYs are also
controlled through some dedicated signals from the display
controller. These include PLL reference clock enable, PLL enable,
and CRI clock selection, for example.

Eeach channel also has two splines (also called data lanes), and
each spline is made up of one Physical Access Coding Sub-Layer
(PCS) block and two TX lanes. So each channel has two PCS blocks
and four TX lanes. The TX lanes are used as DP lanes or TMDS
data/clock pairs depending on the output type.

Additionally the PHY also contains an AUX lane with AUX blocks
for each channel. This is used for DP AUX communication, but
this fact isn't really relevant for the driver since AUX is
controlled from the display controller side. No DPIO registers
need to be accessed during AUX communication,

Generally on VLV/CHV the common lane corresponds to the pipe and
the spline (PCS/TX) corresponds to the port.

For dual channel PHY (VLV/CHV):
\begin{quote}

pipe A == CMN/PLL/REF CH0

pipe B == CMN/PLL/REF CH1

port B == PCS/TX CH0

port C == PCS/TX CH1
\end{quote}

This is especially important when we cross the streams
ie. drive port B with pipe B, or port C with pipe A.

For single channel PHY (CHV):
\begin{quote}

pipe C == CMN/PLL/REF CH0

port D == PCS/TX CH0
\end{quote}

On BXT the entire PHY channel corresponds to the port. That means
the PLL is also now associated with the port rather than the pipe,
and so the clock needs to be routed to the appropriate transcoder.
Port A PLL is directly connected to transcoder EDP and port B/C
PLLs can be routed to any transcoder A/B/C.

Note: DDI0 is digital port B, DD1 is digital port C, and DDI2 is
digital port D (CHV) or port A (BXT).

\begin{Verbatim}[commandchars=\\\{\}]
Dual channel PHY (VLV/CHV/BXT)
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\textbar{}      CH0      \textbar{}      CH1      \textbar{}
\textbar{}  CMN/PLL/REF  \textbar{}  CMN/PLL/REF  \textbar{}
\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{} Display PHY
\textbar{} PCS01 \textbar{} PCS23 \textbar{} PCS01 \textbar{} PCS23 \textbar{}
\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
\textbar{}TX0\textbar{}TX1\textbar{}TX2\textbar{}TX3\textbar{}TX0\textbar{}TX1\textbar{}TX2\textbar{}TX3\textbar{}
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\textbar{}     DDI0      \textbar{}     DDI1      \textbar{} DP/HDMI ports
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}

Single channel PHY (CHV/BXT)
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\textbar{}      CH0      \textbar{}
\textbar{}  CMN/PLL/REF  \textbar{}
\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{} Display PHY
\textbar{} PCS01 \textbar{} PCS23 \textbar{}
\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
\textbar{}TX0\textbar{}TX1\textbar{}TX2\textbar{}TX3\textbar{}
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\textbar{}     DDI2      \textbar{} DP/HDMI port
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\end{Verbatim}


\subsection{CSR firmware support for DMC}
\label{gpu/i915:csr-firmware-support-for-dmc}
Display Context Save and Restore (CSR) firmware support added from gen9
onwards to drive newly added DMC (Display microcontroller) in display
engine to save and restore the state of display engine when it enter into
low-power state and comes back to normal.
\index{intel\_csr\_load\_program (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_csr_load_program}\pysiglinewithargsret{void \bfcode{intel\_csr\_load\_program}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
write the firmware from memory to register.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 drm device.

\end{description}

\textbf{Description}

CSR firmware is read from a .bin file and kept in internal memory one time.
Everytime display comes back from low power state this function is called to
copy the firmware from internal memory to registers.
\index{intel\_csr\_ucode\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_csr_ucode_init}\pysiglinewithargsret{void \bfcode{intel\_csr\_ucode\_init}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
initialize the firmware loading.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 drm device.

\end{description}

\textbf{Description}

This function is called at the time of loading the display driver to read
firmware from a .bin file and copied into a internal memory.
\index{intel\_csr\_ucode\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_csr_ucode_suspend}\pysiglinewithargsret{void \bfcode{intel\_csr\_ucode\_suspend}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
prepare CSR firmware before system suspend

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 drm device

\end{description}

\textbf{Description}

Prepare the DMC firmware before entering system suspend. This includes
flushing pending work items and releasing any resources acquired during
init.
\index{intel\_csr\_ucode\_resume (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_csr_ucode_resume}\pysiglinewithargsret{void \bfcode{intel\_csr\_ucode\_resume}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
init CSR firmware during system resume

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 drm device

\end{description}

\textbf{Description}

Reinitialize the DMC firmware during system resume, reacquiring any
resources released in {\hyperref[gpu/i915:c.intel_csr_ucode_suspend]{\emph{\code{intel\_csr\_ucode\_suspend()}}}}.
\index{intel\_csr\_ucode\_fini (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_csr_ucode_fini}\pysiglinewithargsret{void \bfcode{intel\_csr\_ucode\_fini}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
unload the CSR firmware.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 drm device.

\end{description}

\textbf{Description}

Firmmware unloading includes freeing the internal memory and reset the
firmware loading status.


\subsection{Video BIOS Table (VBT)}
\label{gpu/i915:video-bios-table-vbt}
The Video BIOS Table, or VBT, provides platform and board specific
configuration information to the driver that is not discoverable or available
through other means. The configuration is mostly related to display
hardware. The VBT is available via the ACPI OpRegion or, on older systems, in
the PCI ROM.

The VBT consists of a VBT Header (defined as {\hyperref[gpu/i915:c.vbt_header]{\emph{\code{struct vbt\_header}}}}), a BDB
Header ({\hyperref[gpu/i915:c.bdb_header]{\emph{\code{struct bdb\_header}}}}), and a number of BIOS Data Blocks (BDB) that
contain the actual configuration information. The VBT Header, and thus the
VBT, begins with ``\$VBT'' signature. The VBT Header contains the offset of the
BDB Header. The data blocks are concatenated after the BDB Header. The data
blocks have a 1-byte Block ID, 2-byte Block Size, and Block Size bytes of
data. (Block 53, the MIPI Sequence Block is an exception.)

The driver parses the VBT during load. The relevant information is stored in
driver private data for ease of use, and the actual VBT is not read after
that.
\index{intel\_bios\_is\_valid\_vbt (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_bios_is_valid_vbt}\pysiglinewithargsret{bool \bfcode{intel\_bios\_is\_valid\_vbt}}{const void *\emph{ buf}, size\_t\emph{ size}}{}
does the given buffer contain a valid VBT

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const void * buf}}] \leavevmode
pointer to a buffer to validate

\item[{\code{size\_t size}}] \leavevmode
size of the buffer

\end{description}

\textbf{Description}

Returns true on valid VBT.
\index{intel\_bios\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_bios_init}\pysiglinewithargsret{void \bfcode{intel\_bios\_init}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
find VBT and initialize settings from the BIOS

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

Parse and initialize settings from the Video BIOS Tables (VBT). If the VBT
was not found in ACPI OpRegion, try to find it in PCI ROM first. Also
initialize some defaults if the VBT is not present at all.
\index{intel\_bios\_cleanup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_bios_cleanup}\pysiglinewithargsret{void \bfcode{intel\_bios\_cleanup}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Free any resources allocated by {\hyperref[gpu/i915:c.intel_bios_init]{\emph{\code{intel\_bios\_init()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}
\index{intel\_bios\_is\_tv\_present (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_bios_is_tv_present}\pysiglinewithargsret{bool \bfcode{intel\_bios\_is\_tv\_present}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
is integrated TV present in VBT

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

Return true if TV is present. If no child devices were parsed from VBT,
assume TV is present.
\index{intel\_bios\_is\_lvds\_present (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_bios_is_lvds_present}\pysiglinewithargsret{bool \bfcode{intel\_bios\_is\_lvds\_present}}{struct drm\_i915\_private *\emph{ dev\_priv}, u8 *\emph{ i2c\_pin}}{}
is LVDS present in VBT

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{u8 * i2c\_pin}}] \leavevmode
i2c pin for LVDS if present

\end{description}

\textbf{Description}

Return true if LVDS is present. If no child devices were parsed from VBT,
assume LVDS is present.
\index{intel\_bios\_is\_port\_present (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_bios_is_port_present}\pysiglinewithargsret{bool \bfcode{intel\_bios\_is\_port\_present}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum port\emph{ port}}{}
is the specified digital port present

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum port port}}] \leavevmode
port to check

\end{description}

\textbf{Description}

Return true if the device in \code{port} is present.
\index{intel\_bios\_is\_port\_edp (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_bios_is_port_edp}\pysiglinewithargsret{bool \bfcode{intel\_bios\_is\_port\_edp}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum port\emph{ port}}{}
is the device in given port eDP

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum port port}}] \leavevmode
port to check

\end{description}

\textbf{Description}

Return true if the device in \code{port} is eDP.
\index{intel\_bios\_is\_dsi\_present (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_bios_is_dsi_present}\pysiglinewithargsret{bool \bfcode{intel\_bios\_is\_dsi\_present}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum port *\emph{ port}}{}
is DSI present in VBT

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum port * port}}] \leavevmode
port for DSI if present

\end{description}

\textbf{Description}

Return true if DSI is present, and return the port in \code{port}.
\index{intel\_bios\_is\_port\_hpd\_inverted (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_bios_is_port_hpd_inverted}\pysiglinewithargsret{bool \bfcode{intel\_bios\_is\_port\_hpd\_inverted}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum port\emph{ port}}{}
is HPD inverted for \code{port}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum port port}}] \leavevmode
port to check

\end{description}

\textbf{Description}

Return true if HPD should be inverted for \code{port}.
\index{intel\_bios\_is\_lspcon\_present (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_bios_is_lspcon_present}\pysiglinewithargsret{bool \bfcode{intel\_bios\_is\_lspcon\_present}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum port\emph{ port}}{}
if LSPCON is attached on \code{port}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum port port}}] \leavevmode
port to check

\end{description}

\textbf{Description}

Return true if LSPCON is present on this port
\index{vbt\_header (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.vbt_header}\pysigline{struct \bfcode{vbt\_header}}
VBT Header structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct vbt\PYGZus{}header \PYGZob{}
  u8 signature[20];
  u16 version;
  u16 header\PYGZus{}size;
  u16 vbt\PYGZus{}size;
  u8 vbt\PYGZus{}checksum;
  u8 reserved0;
  u32 bdb\PYGZus{}offset;
  u32 aim\PYGZus{}offset[4];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{signature}}] \leavevmode
VBT signature, always starts with ``\$VBT''

\item[{\code{version}}] \leavevmode
Version of this structure

\item[{\code{header\_size}}] \leavevmode
Size of this structure

\item[{\code{vbt\_size}}] \leavevmode
Size of VBT (VBT Header, BDB Header and data blocks)

\item[{\code{vbt\_checksum}}] \leavevmode
Checksum

\item[{\code{reserved0}}] \leavevmode
Reserved

\item[{\code{bdb\_offset}}] \leavevmode
Offset of {\hyperref[gpu/i915:c.bdb_header]{\emph{\code{struct bdb\_header}}}} from beginning of VBT

\item[{\code{aim\_offset}}] \leavevmode
Offsets of add-in data blocks from beginning of VBT

\end{description}
\index{bdb\_header (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.bdb_header}\pysigline{struct \bfcode{bdb\_header}}
BDB Header structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct bdb\PYGZus{}header \PYGZob{}
  u8 signature[16];
  u16 version;
  u16 header\PYGZus{}size;
  u16 bdb\PYGZus{}size;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{signature}}] \leavevmode
BDB signature ``BIOS\_DATA\_BLOCK''

\item[{\code{version}}] \leavevmode
Version of the data block definitions

\item[{\code{header\_size}}] \leavevmode
Size of this structure

\item[{\code{bdb\_size}}] \leavevmode
Size of BDB (BDB Header and data blocks)

\end{description}


\subsection{Display clocks}
\label{gpu/i915:display-clocks}
The display engine uses several different clocks to do its work. There
are two main clocks involved that aren't directly related to the actual
pixel clock or any symbol/bit clock of the actual output port. These
are the core display clock (CDCLK) and RAWCLK.

CDCLK clocks most of the display pipe logic, and thus its frequency
must be high enough to support the rate at which pixels are flowing
through the pipes. Downscaling must also be accounted as that increases
the effective pixel rate.

On several platforms the CDCLK frequency can be changed dynamically
to minimize power consumption for a given display configuration.
Typically changes to the CDCLK frequency require all the display pipes
to be shut down while the frequency is being changed.

On SKL+ the DMC will toggle the CDCLK off/on during DC5/6 entry/exit.
DMC will not change the active CDCLK frequency however, so that part
will still be performed by the driver directly.

RAWCLK is a fixed frequency clock, often used by various auxiliary
blocks such as AUX CH or backlight PWM. Hence the only thing we
really need to know about RAWCLK is its frequency so that various
dividers can be programmed correctly.
\index{skl\_init\_cdclk (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.skl_init_cdclk}\pysiglinewithargsret{void \bfcode{skl\_init\_cdclk}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Initialize CDCLK on SKL

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\end{description}

\textbf{Description}

Initialize CDCLK for SKL and derivatives. This is generally
done only during the display core initialization sequence,
after which the DMC will take care of turning CDCLK off/on
as needed.
\index{skl\_uninit\_cdclk (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.skl_uninit_cdclk}\pysiglinewithargsret{void \bfcode{skl\_uninit\_cdclk}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Uninitialize CDCLK on SKL

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\end{description}

\textbf{Description}

Uninitialize CDCLK for SKL and derivatives. This is done only
during the display core uninitialization sequence.
\index{bxt\_init\_cdclk (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.bxt_init_cdclk}\pysiglinewithargsret{void \bfcode{bxt\_init\_cdclk}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Initialize CDCLK on BXT

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\end{description}

\textbf{Description}

Initialize CDCLK for BXT and derivatives. This is generally
done only during the display core initialization sequence,
after which the DMC will take care of turning CDCLK off/on
as needed.
\index{bxt\_uninit\_cdclk (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.bxt_uninit_cdclk}\pysiglinewithargsret{void \bfcode{bxt\_uninit\_cdclk}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Uninitialize CDCLK on BXT

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\end{description}

\textbf{Description}

Uninitialize CDCLK for BXT and derivatives. This is done only
during the display core uninitialization sequence.
\index{cnl\_init\_cdclk (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.cnl_init_cdclk}\pysiglinewithargsret{void \bfcode{cnl\_init\_cdclk}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Initialize CDCLK on CNL

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\end{description}

\textbf{Description}

Initialize CDCLK for CNL. This is generally
done only during the display core initialization sequence,
after which the DMC will take care of turning CDCLK off/on
as needed.
\index{cnl\_uninit\_cdclk (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.cnl_uninit_cdclk}\pysiglinewithargsret{void \bfcode{cnl\_uninit\_cdclk}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Uninitialize CDCLK on CNL

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\end{description}

\textbf{Description}

Uninitialize CDCLK for CNL. This is done only
during the display core uninitialization sequence.
\index{intel\_cdclk\_needs\_modeset (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_cdclk_needs_modeset}\pysiglinewithargsret{bool \bfcode{intel\_cdclk\_needs\_modeset}}{const struct intel\_cdclk\_state *\emph{ a}, const struct intel\_cdclk\_state *\emph{ b}}{}
Determine if two CDCLK states require a modeset on all pipes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct intel\_cdclk\_state * a}}] \leavevmode
first CDCLK state

\item[{\code{const struct intel\_cdclk\_state * b}}] \leavevmode
second CDCLK state

\end{description}

\textbf{Return}

True if the CDCLK states require pipes to be off during reprogramming, false if not.
\index{intel\_cdclk\_changed (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_cdclk_changed}\pysiglinewithargsret{bool \bfcode{intel\_cdclk\_changed}}{const struct intel\_cdclk\_state *\emph{ a}, const struct intel\_cdclk\_state *\emph{ b}}{}
Determine if two CDCLK states are different

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct intel\_cdclk\_state * a}}] \leavevmode
first CDCLK state

\item[{\code{const struct intel\_cdclk\_state * b}}] \leavevmode
second CDCLK state

\end{description}

\textbf{Return}

True if the CDCLK states don't match, false if they do.
\index{intel\_set\_cdclk (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_set_cdclk}\pysiglinewithargsret{void \bfcode{intel\_set\_cdclk}}{struct drm\_i915\_private *\emph{ dev\_priv}, const struct intel\_cdclk\_state *\emph{ cdclk\_state}}{}
Push the CDCLK state to the hardware

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\item[{\code{const struct intel\_cdclk\_state * cdclk\_state}}] \leavevmode
new CDCLK state

\end{description}

\textbf{Description}

Program the hardware based on the passed in CDCLK state,
if necessary.
\index{intel\_update\_max\_cdclk (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_update_max_cdclk}\pysiglinewithargsret{void \bfcode{intel\_update\_max\_cdclk}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Determine the maximum support CDCLK frequency

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\end{description}

\textbf{Description}

Determine the maximum CDCLK frequency the platform supports, and also
derive the maximum dot clock frequency the maximum CDCLK frequency
allows.
\index{intel\_update\_cdclk (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_update_cdclk}\pysiglinewithargsret{void \bfcode{intel\_update\_cdclk}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Determine the current CDCLK frequency

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\end{description}

\textbf{Description}

Determine the current CDCLK frequency.
\index{intel\_update\_rawclk (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_update_rawclk}\pysiglinewithargsret{void \bfcode{intel\_update\_rawclk}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Determine the current RAWCLK frequency

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\end{description}

\textbf{Description}

Determine the current RAWCLK frequency. RAWCLK is a fixed
frequency clock so this needs to done only once.
\index{intel\_init\_cdclk\_hooks (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_init_cdclk_hooks}\pysiglinewithargsret{void \bfcode{intel\_init\_cdclk\_hooks}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Initialize CDCLK related modesetting hooks

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\end{description}


\subsection{Display PLLs}
\label{gpu/i915:display-plls}
Display PLLs used for driving outputs vary by platform. While some have
per-pipe or per-encoder dedicated PLLs, others allow the use of any PLL
from a pool. In the latter scenario, it is possible that multiple pipes
share a PLL if their configurations match.

This file provides an abstraction over display PLLs. The function
{\hyperref[gpu/i915:c.intel_shared_dpll_init]{\emph{\code{intel\_shared\_dpll\_init()}}}} initializes the PLLs for the given platform.  The
users of a PLL are tracked and that tracking is integrated with the atomic
modest interface. During an atomic operation, a PLL can be requested for a
given CRTC and encoder configuration by calling {\hyperref[gpu/i915:c.intel_get_shared_dpll]{\emph{\code{intel\_get\_shared\_dpll()}}}} and
a previously used PLL can be released with {\hyperref[gpu/i915:c.intel_release_shared_dpll]{\emph{\code{intel\_release\_shared\_dpll()}}}}.
Changes to the users are first staged in the atomic state, and then made
effective by calling {\hyperref[gpu/i915:c.intel_shared_dpll_swap_state]{\emph{\code{intel\_shared\_dpll\_swap\_state()}}}} during the atomic
commit phase.
\index{intel\_get\_shared\_dpll\_by\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_get_shared_dpll_by_id}\pysiglinewithargsret{struct {\hyperref[gpu/i915:c.intel_shared_dpll]{\emph{intel\_shared\_dpll}}} * \bfcode{intel\_get\_shared\_dpll\_by\_id}}{struct drm\_i915\_private *\emph{ dev\_priv}, enum {\hyperref[gpu/i915:c.intel_dpll_id]{\emph{intel\_dpll\_id}}}\emph{ id}}{}
get a DPLL given its id

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{enum intel\_dpll\_id id}}] \leavevmode
pll id

\end{description}

\textbf{Return}

A pointer to the DPLL with \textbf{id}
\index{intel\_get\_shared\_dpll\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_get_shared_dpll_id}\pysiglinewithargsret{enum {\hyperref[gpu/i915:c.intel_dpll_id]{\emph{intel\_dpll\_id}}} \bfcode{intel\_get\_shared\_dpll\_id}}{struct drm\_i915\_private *\emph{ dev\_priv}, struct {\hyperref[gpu/i915:c.intel_shared_dpll]{\emph{intel\_shared\_dpll}}} *\emph{ pll}}{}
get the id of a DPLL

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{struct intel\_shared\_dpll * pll}}] \leavevmode
the DPLL

\end{description}

\textbf{Return}

The id of \textbf{pll}
\index{intel\_prepare\_shared\_dpll (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_prepare_shared_dpll}\pysiglinewithargsret{void \bfcode{intel\_prepare\_shared\_dpll}}{struct intel\_crtc *\emph{ crtc}}{}
call a dpll's prepare hook

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_crtc * crtc}}] \leavevmode
CRTC which has a shared dpll

\end{description}

\textbf{Description}

This calls the PLL's prepare hook if it has one and if the PLL is not
already enabled. The prepare hook is platform specific.
\index{intel\_enable\_shared\_dpll (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_enable_shared_dpll}\pysiglinewithargsret{void \bfcode{intel\_enable\_shared\_dpll}}{struct intel\_crtc *\emph{ crtc}}{}
enable a CRTC's shared DPLL

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_crtc * crtc}}] \leavevmode
CRTC which has a shared DPLL

\end{description}

\textbf{Description}

Enable the shared DPLL used by \textbf{crtc}.
\index{intel\_disable\_shared\_dpll (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_disable_shared_dpll}\pysiglinewithargsret{void \bfcode{intel\_disable\_shared\_dpll}}{struct intel\_crtc *\emph{ crtc}}{}
disable a CRTC's shared DPLL

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_crtc * crtc}}] \leavevmode
CRTC which has a shared DPLL

\end{description}

\textbf{Description}

Disable the shared DPLL used by \textbf{crtc}.
\index{intel\_shared\_dpll\_swap\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_shared_dpll_swap_state}\pysiglinewithargsret{void \bfcode{intel\_shared\_dpll\_swap\_state}}{struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
make atomic DPLL configuration effective

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
atomic state

\end{description}

\textbf{Description}

This is the dpll version of {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_atomic_helper_swap_state]{\emph{\code{drm\_atomic\_helper\_swap\_state()}}}} since the
helper does not handle driver-specific global state.

For consistency with atomic helpers this function does a complete swap,
i.e. it also puts the current state into \textbf{state}, even though there is no
need for that at this moment.
\index{intel\_shared\_dpll\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_shared_dpll_init}\pysiglinewithargsret{void \bfcode{intel\_shared\_dpll\_init}}{struct drm\_device *\emph{ dev}}{}
Initialize shared DPLLs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\end{description}

\textbf{Description}

Initialize shared DPLLs for \textbf{dev}.
\index{intel\_get\_shared\_dpll (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_get_shared_dpll}\pysiglinewithargsret{struct {\hyperref[gpu/i915:c.intel_shared_dpll]{\emph{intel\_shared\_dpll}}} * \bfcode{intel\_get\_shared\_dpll}}{struct intel\_crtc *\emph{ crtc}, struct intel\_crtc\_state *\emph{ crtc\_state}, struct intel\_encoder *\emph{ encoder}}{}
get a shared DPLL for CRTC and encoder combination

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_crtc * crtc}}] \leavevmode
CRTC

\item[{\code{struct intel\_crtc\_state * crtc\_state}}] \leavevmode
atomic state for \textbf{crtc}

\item[{\code{struct intel\_encoder * encoder}}] \leavevmode
encoder

\end{description}

\textbf{Description}

Find an appropriate DPLL for the given CRTC and encoder combination. A
reference from the \textbf{crtc} to the returned pll is registered in the atomic
state. That configuration is made effective by calling
{\hyperref[gpu/i915:c.intel_shared_dpll_swap_state]{\emph{\code{intel\_shared\_dpll\_swap\_state()}}}}. The reference should be released by calling
{\hyperref[gpu/i915:c.intel_release_shared_dpll]{\emph{\code{intel\_release\_shared\_dpll()}}}}.

\textbf{Return}

A shared DPLL to be used by \textbf{crtc} and \textbf{encoder} with the given \textbf{crtc\_state}.
\index{intel\_release\_shared\_dpll (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_release_shared_dpll}\pysiglinewithargsret{void \bfcode{intel\_release\_shared\_dpll}}{struct {\hyperref[gpu/i915:c.intel_shared_dpll]{\emph{intel\_shared\_dpll}}} *\emph{ dpll}, struct intel\_crtc *\emph{ crtc}, struct {\hyperref[gpu/drm\string-kms:c.drm_atomic_state]{\emph{drm\_atomic\_state}}} *\emph{ state}}{}
end use of DPLL by CRTC in atomic state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_shared\_dpll * dpll}}] \leavevmode
dpll in use by \textbf{crtc}

\item[{\code{struct intel\_crtc * crtc}}] \leavevmode
crtc

\item[{\code{struct drm\_atomic\_state * state}}] \leavevmode
atomic state

\end{description}

\textbf{Description}

This function releases the reference from \textbf{crtc} to \textbf{dpll} from the
atomic \textbf{state}. The new configuration is made effective by calling
{\hyperref[gpu/i915:c.intel_shared_dpll_swap_state]{\emph{\code{intel\_shared\_dpll\_swap\_state()}}}}.
\index{intel\_dpll\_dump\_hw\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_dpll_dump_hw_state}\pysiglinewithargsret{void \bfcode{intel\_dpll\_dump\_hw\_state}}{struct drm\_i915\_private *\emph{ dev\_priv}, struct intel\_dpll\_hw\_state *\emph{ hw\_state}}{}
write hw\_state to dmesg

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 drm device

\item[{\code{struct intel\_dpll\_hw\_state * hw\_state}}] \leavevmode
hw state to be written to the log

\end{description}

\textbf{Description}

Write the relevant values in \textbf{hw\_state} to dmesg using DRM\_DEBUG\_KMS.
\index{intel\_dpll\_id (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_dpll_id}\pysigline{enum \bfcode{intel\_dpll\_id}}
possible DPLL ids

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{DPLL\_ID\_PRIVATE}}] \leavevmode
non-shared dpll in use

\item[{\code{DPLL\_ID\_PCH\_PLL\_A}}] \leavevmode
DPLL A in ILK, SNB and IVB

\item[{\code{DPLL\_ID\_PCH\_PLL\_B}}] \leavevmode
DPLL B in ILK, SNB and IVB

\item[{\code{DPLL\_ID\_WRPLL1}}] \leavevmode
HSW and BDW WRPLL1

\item[{\code{DPLL\_ID\_WRPLL2}}] \leavevmode
HSW and BDW WRPLL2

\item[{\code{DPLL\_ID\_SPLL}}] \leavevmode
HSW and BDW SPLL

\item[{\code{DPLL\_ID\_LCPLL\_810}}] \leavevmode
HSW and BDW 0.81 GHz LCPLL

\item[{\code{DPLL\_ID\_LCPLL\_1350}}] \leavevmode
HSW and BDW 1.35 GHz LCPLL

\item[{\code{DPLL\_ID\_LCPLL\_2700}}] \leavevmode
HSW and BDW 2.7 GHz LCPLL

\item[{\code{DPLL\_ID\_SKL\_DPLL0}}] \leavevmode
SKL and later DPLL0

\item[{\code{DPLL\_ID\_SKL\_DPLL1}}] \leavevmode
SKL and later DPLL1

\item[{\code{DPLL\_ID\_SKL\_DPLL2}}] \leavevmode
SKL and later DPLL2

\item[{\code{DPLL\_ID\_SKL\_DPLL3}}] \leavevmode
SKL and later DPLL3

\end{description}

\textbf{Description}

Enumeration of possible IDs for a DPLL. Real shared dpll ids must be \textgreater{}= 0.
\index{intel\_shared\_dpll\_state (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_shared_dpll_state}\pysigline{struct \bfcode{intel\_shared\_dpll\_state}}
hold the DPLL atomic state

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct intel\PYGZus{}shared\PYGZus{}dpll\PYGZus{}state \PYGZob{}
  unsigned crtc\PYGZus{}mask;
  struct intel\PYGZus{}dpll\PYGZus{}hw\PYGZus{}state hw\PYGZus{}state;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{crtc\_mask}}] \leavevmode
mask of CRTC using this DPLL, active or not

\item[{\code{hw\_state}}] \leavevmode
hardware configuration for the DPLL stored in
struct \code{intel\_dpll\_hw\_state}.

\end{description}

\textbf{Description}

This structure holds an atomic state for the DPLL, that can represent
either its current state (in struct {\hyperref[gpu/i915:c.intel_shared_dpll]{\emph{\code{intel\_shared\_dpll}}}}) or a desired
future state which would be applied by an atomic mode set (stored in
a struct \code{intel\_atomic\_state}).

See also {\hyperref[gpu/i915:c.intel_get_shared_dpll]{\emph{\code{intel\_get\_shared\_dpll()}}}} and {\hyperref[gpu/i915:c.intel_release_shared_dpll]{\emph{\code{intel\_release\_shared\_dpll()}}}}.
\index{intel\_shared\_dpll\_funcs (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_shared_dpll_funcs}\pysigline{struct \bfcode{intel\_shared\_dpll\_funcs}}
platform specific hooks for managing DPLLs

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct intel\PYGZus{}shared\PYGZus{}dpll\PYGZus{}funcs \PYGZob{}
  void (*prepare)(struct drm\PYGZus{}i915\PYGZus{}private *dev\PYGZus{}priv, struct intel\PYGZus{}shared\PYGZus{}dpll *pll);
  void (*enable)(struct drm\PYGZus{}i915\PYGZus{}private *dev\PYGZus{}priv, struct intel\PYGZus{}shared\PYGZus{}dpll *pll);
  void (*disable)(struct drm\PYGZus{}i915\PYGZus{}private *dev\PYGZus{}priv, struct intel\PYGZus{}shared\PYGZus{}dpll *pll);
  bool (*get\PYGZus{}hw\PYGZus{}state)(struct drm\PYGZus{}i915\PYGZus{}private *dev\PYGZus{}priv,struct intel\PYGZus{}shared\PYGZus{}dpll *pll, struct intel\PYGZus{}dpll\PYGZus{}hw\PYGZus{}state *hw\PYGZus{}state);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{prepare}}] \leavevmode
Optional hook to perform operations prior to enabling the PLL.
Called from {\hyperref[gpu/i915:c.intel_prepare_shared_dpll]{\emph{\code{intel\_prepare\_shared\_dpll()}}}} function unless the PLL
is already enabled.

\item[{\code{enable}}] \leavevmode
Hook for enabling the pll, called from {\hyperref[gpu/i915:c.intel_enable_shared_dpll]{\emph{\code{intel\_enable\_shared\_dpll()}}}}
if the pll is not already enabled.

\item[{\code{disable}}] \leavevmode
Hook for disabling the pll, called from {\hyperref[gpu/i915:c.intel_disable_shared_dpll]{\emph{\code{intel\_disable\_shared\_dpll()}}}}
only when it is safe to disable the pll, i.e., there are no more
tracked users for it.

\item[{\code{get\_hw\_state}}] \leavevmode
Hook for reading the values currently programmed to the DPLL
registers. This is used for initial hw state readout and state
verification after a mode set.

\end{description}
\index{intel\_shared\_dpll (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_shared_dpll}\pysigline{struct \bfcode{intel\_shared\_dpll}}
display PLL with tracked state and users

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct intel\PYGZus{}shared\PYGZus{}dpll \PYGZob{}
  struct intel\PYGZus{}shared\PYGZus{}dpll\PYGZus{}state state;
  unsigned active\PYGZus{}mask;
  bool on;
  const char *name;
  enum intel\PYGZus{}dpll\PYGZus{}id id;
  struct intel\PYGZus{}shared\PYGZus{}dpll\PYGZus{}funcs funcs;
\PYGZsh{}define INTEL\PYGZus{}DPLL\PYGZus{}ALWAYS\PYGZus{}ON    (1 \PYGZlt{}\PYGZlt{} 0);
  uint32\PYGZus{}t flags;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{state}}] \leavevmode
Store the state for the pll, including the its hw state
and CRTCs using it.

\item[{\code{active\_mask}}] \leavevmode
mask of active CRTCs (i.e. DPMS on) using this DPLL

\item[{\code{on}}] \leavevmode
is the PLL actually active? Disabled during modeset

\item[{\code{name}}] \leavevmode
DPLL name; used for logging

\item[{\code{id}}] \leavevmode
unique indentifier for this DPLL; should match the index in the
dev\_priv-\textgreater{}shared\_dplls array

\item[{\code{funcs}}] \leavevmode
platform specific hooks

\item[{\code{flags}}] \leavevmode\begin{description}
\item[{INTEL\_DPLL\_ALWAYS\_ON}] \leavevmode
Inform the state checker that the DPLL is kept enabled even if
not in use by any CRTC.

\end{description}

\end{description}


\section{Memory Management and Command Submission}
\label{gpu/i915:memory-management-and-command-submission}
This sections covers all things related to the GEM implementation in the
i915 driver.


\subsection{Batchbuffer Parsing}
\label{gpu/i915:batchbuffer-parsing}
Motivation:
Certain OpenGL features (e.g. transform feedback, performance monitoring)
require userspace code to submit batches containing commands such as
MI\_LOAD\_REGISTER\_IMM to access various registers. Unfortunately, some
generations of the hardware will noop these commands in ``unsecure'' batches
(which includes all userspace batches submitted via i915) even though the
commands may be safe and represent the intended programming model of the
device.

The software command parser is similar in operation to the command parsing
done in hardware for unsecure batches. However, the software parser allows
some operations that would be noop'd by hardware, if the parser determines
the operation is safe, and submits the batch as ``secure'' to prevent hardware
parsing.

Threats:
At a high level, the hardware (and software) checks attempt to prevent
granting userspace undue privileges. There are three categories of privilege.

First, commands which are explicitly defined as privileged or which should
only be used by the kernel driver. The parser generally rejects such
commands, though it may allow some from the drm master process.

Second, commands which access registers. To support correct/enhanced
userspace functionality, particularly certain OpenGL extensions, the parser
provides a whitelist of registers which userspace may safely access (for both
normal and drm master processes).

Third, commands which access privileged memory (i.e. GGTT, HWS page, etc).
The parser always rejects such commands.

The majority of the problematic commands fall in the MI\_* range, with only a
few specific commands on each engine (e.g. PIPE\_CONTROL and MI\_FLUSH\_DW).

Implementation:
Each engine maintains tables of commands and registers which the parser
uses in scanning batch buffers submitted to that engine.

Since the set of commands that the parser must check for is significantly
smaller than the number of commands supported, the parser tables contain only
those commands required by the parser. This generally works because command
opcode ranges have standard command length encodings. So for commands that
the parser does not need to check, it can easily skip them. This is
implemented via a per-engine length decoding vfunc.

Unfortunately, there are a number of commands that do not follow the standard
length encoding for their opcode range, primarily amongst the MI\_* commands.
To handle this, the parser provides a way to define explicit ``skip'' entries
in the per-engine command tables.

Other command table entries map fairly directly to high level categories
mentioned above: rejected, master-only, register whitelist. The parser
implements a number of checks, including the privileged memory checks, via a
general bitmasking mechanism.
\index{intel\_engine\_init\_cmd\_parser (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_engine_init_cmd_parser}\pysiglinewithargsret{void \bfcode{intel\_engine\_init\_cmd\_parser}}{struct intel\_engine\_cs *\emph{ engine}}{}
set cmd parser related fields for an engine

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_engine\_cs * engine}}] \leavevmode
the engine to initialize

\end{description}

\textbf{Description}

Optionally initializes fields related to batch buffer command parsing in the
struct intel\_engine\_cs based on whether the platform requires software
command parsing.
\index{intel\_engine\_cleanup\_cmd\_parser (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_engine_cleanup_cmd_parser}\pysiglinewithargsret{void \bfcode{intel\_engine\_cleanup\_cmd\_parser}}{struct intel\_engine\_cs *\emph{ engine}}{}
clean up cmd parser related fields

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_engine\_cs * engine}}] \leavevmode
the engine to clean up

\end{description}

\textbf{Description}

Releases any resources related to command parsing that may have been
initialized for the specified engine.
\index{intel\_engine\_cmd\_parser (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_engine_cmd_parser}\pysiglinewithargsret{int \bfcode{intel\_engine\_cmd\_parser}}{struct intel\_engine\_cs *\emph{ engine}, struct drm\_i915\_gem\_object *\emph{ batch\_obj}, struct drm\_i915\_gem\_object *\emph{ shadow\_batch\_obj}, u32\emph{ batch\_start\_offset}, u32\emph{ batch\_len}, bool\emph{ is\_master}}{}
parse a submitted batch buffer for privilege violations

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_engine\_cs * engine}}] \leavevmode
the engine on which the batch is to execute

\item[{\code{struct drm\_i915\_gem\_object * batch\_obj}}] \leavevmode
the batch buffer in question

\item[{\code{struct drm\_i915\_gem\_object * shadow\_batch\_obj}}] \leavevmode
copy of the batch buffer in question

\item[{\code{u32 batch\_start\_offset}}] \leavevmode
byte offset in the batch at which execution starts

\item[{\code{u32 batch\_len}}] \leavevmode
length of the commands in batch\_obj

\item[{\code{bool is\_master}}] \leavevmode
is the submitting process the drm master?

\end{description}

\textbf{Description}

Parses the specified batch buffer looking for privilege violations as
described in the overview.

\textbf{Return}

non-zero if the parser finds violations or otherwise fails; -EACCES
if the batch appears legal but should use hardware parsing
\index{i915\_cmd\_parser\_get\_version (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_cmd_parser_get_version}\pysiglinewithargsret{int \bfcode{i915\_cmd\_parser\_get\_version}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
get the cmd parser version number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device private

\end{description}

\textbf{Description}

The cmd parser maintains a simple increasing integer version number suitable
for passing to userspace clients to determine what operations are permitted.

\textbf{Return}

the current version number of the cmd parser


\subsection{Batchbuffer Pools}
\label{gpu/i915:batchbuffer-pools}
In order to submit batch buffers as `secure', the software command parser
must ensure that a batch buffer cannot be modified after parsing. It does
this by copying the user provided batch buffer contents to a kernel owned
buffer from which the hardware will actually execute, and by carefully
managing the address space bindings for such buffers.

The batch pool framework provides a mechanism for the driver to manage a
set of scratch buffers to use for this purpose. The framework can be
extended to support other uses cases should they arise.
\index{i915\_gem\_batch\_pool\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_batch_pool_init}\pysiglinewithargsret{void \bfcode{i915\_gem\_batch\_pool\_init}}{struct intel\_engine\_cs *\emph{ engine}, struct i915\_gem\_batch\_pool *\emph{ pool}}{}
initialize a batch buffer pool

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_engine\_cs * engine}}] \leavevmode
the associated request submission engine

\item[{\code{struct i915\_gem\_batch\_pool * pool}}] \leavevmode
the batch buffer pool

\end{description}
\index{i915\_gem\_batch\_pool\_fini (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_batch_pool_fini}\pysiglinewithargsret{void \bfcode{i915\_gem\_batch\_pool\_fini}}{struct i915\_gem\_batch\_pool *\emph{ pool}}{}
clean up a batch buffer pool

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_gem\_batch\_pool * pool}}] \leavevmode
the pool to clean up

\end{description}

\textbf{Note}

Callers must hold the struct\_mutex.
\index{i915\_gem\_batch\_pool\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_batch_pool_get}\pysiglinewithargsret{struct drm\_i915\_gem\_object * \bfcode{i915\_gem\_batch\_pool\_get}}{struct i915\_gem\_batch\_pool *\emph{ pool}, size\_t\emph{ size}}{}
allocate a buffer from the pool

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_gem\_batch\_pool * pool}}] \leavevmode
the batch buffer pool

\item[{\code{size\_t size}}] \leavevmode
the minimum desired size of the returned buffer

\end{description}

\textbf{Description}

Returns an inactive buffer from \textbf{pool} with at least \textbf{size} bytes,
with the pages pinned. The caller must \code{i915\_gem\_object\_unpin\_pages()}
on the returned object.

\textbf{Note}

Callers must hold the struct\_mutex

\textbf{Return}

the buffer object or an error pointer


\subsection{Logical Rings, Logical Ring Contexts and Execlists}
\label{gpu/i915:logical-rings-logical-ring-contexts-and-execlists}
Motivation:
GEN8 brings an expansion of the HW contexts: ``Logical Ring Contexts''.
These expanded contexts enable a number of new abilities, especially
``Execlists'' (also implemented in this file).

One of the main differences with the legacy HW contexts is that logical
ring contexts incorporate many more things to the context's state, like
PDPs or ringbuffer control registers:

The reason why PDPs are included in the context is straightforward: as
PPGTTs (per-process GTTs) are actually per-context, having the PDPs
contained there mean you don't need to do a ppgtt-\textgreater{}switch\_mm yourself,
instead, the GPU will do it for you on the context switch.

But, what about the ringbuffer control registers (head, tail, etc..)?
shouldn't we just need a set of those per engine command streamer? This is
where the name ``Logical Rings'' starts to make sense: by virtualizing the
rings, the engine cs shifts to a new ``ring buffer'' with every context
switch. When you want to submit a workload to the GPU you: A) choose your
context, B) find its appropriate virtualized ring, C) write commands to it
and then, finally, D) tell the GPU to switch to that context.

Instead of the legacy MI\_SET\_CONTEXT, the way you tell the GPU to switch
to a contexts is via a context execution list, ergo ``Execlists''.

LRC implementation:
Regarding the creation of contexts, we have:
\begin{itemize}
\item {} 
One global default context.

\item {} 
One local default context for each opened fd.

\item {} 
One local extra context for each context create ioctl call.

\end{itemize}

Now that ringbuffers belong per-context (and not per-engine, like before)
and that contexts are uniquely tied to a given engine (and not reusable,
like before) we need:
\begin{itemize}
\item {} 
One ringbuffer per-engine inside each context.

\item {} 
One backing object per-engine inside each context.

\end{itemize}

The global default context starts its life with these new objects fully
allocated and populated. The local default context for each opened fd is
more complex, because we don't know at creation time which engine is going
to use them. To handle this, we have implemented a deferred creation of LR
contexts:

The local context starts its life as a hollow or blank holder, that only
gets populated for a given engine once we receive an execbuffer. If later
on we receive another execbuffer ioctl for the same context but a different
engine, we allocate/populate a new ringbuffer and context backing object and
so on.

Finally, regarding local contexts created using the ioctl call: as they are
only allowed with the render ring, we can allocate \& populate them right
away (no need to defer anything, at least for now).

Execlists implementation:
Execlists are the new method by which, on gen8+ hardware, workloads are
submitted for execution (as opposed to the legacy, ringbuffer-based, method).
This method works as follows:

When a request is committed, its commands (the BB start and any leading or
trailing commands, like the seqno breadcrumbs) are placed in the ringbuffer
for the appropriate context. The tail pointer in the hardware context is not
updated at this time, but instead, kept by the driver in the ringbuffer
structure. A structure representing this request is added to a request queue
for the appropriate engine: this structure contains a copy of the context's
tail after the request was written to the ring buffer and a pointer to the
context itself.

If the engine's request queue was empty before the request was added, the
queue is processed immediately. Otherwise the queue will be processed during
a context switch interrupt. In any case, elements on the queue will get sent
(in pairs) to the GPU's ExecLists Submit Port (ELSP, for short) with a
globally unique 20-bits submission ID.

When execution of a request completes, the GPU updates the context status
buffer with a context complete event and generates a context switch interrupt.
During the interrupt handling, the driver examines the events in the buffer:
for each context complete event, if the announced ID matches that on the head
of the request queue, then that request is retired and removed from the queue.

After processing, if any requests were retired and the queue is not empty
then a new execution list can be submitted. The two requests at the front of
the queue are next to be submitted but since a context may not occur twice in
an execution list, if subsequent requests have the same ID as the first then
the two requests must be combined. This is done simply by discarding requests
at the head of the queue until either only one requests is left (in which case
we use a NULL second context) or the first two requests have unique IDs.

By always executing the first two requests in the queue the driver ensures
that the GPU is kept as busy as possible. In the case where a single context
completes but a second context is still executing, the request for this second
context will be at the head of the queue when we remove the first one. This
request will then be resubmitted along with a new request for a different context,
which will cause the hardware to continue executing the second request and queue
the new request (the GPU detects the condition of a context getting preempted
with the same context and optimizes the context switch flow by not doing
preemption, but just sampling the new tail pointer).
\index{intel\_lr\_context\_descriptor\_update (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_lr_context_descriptor_update}\pysiglinewithargsret{void \bfcode{intel\_lr\_context\_descriptor\_update}}{struct i915\_gem\_context *\emph{ ctx}, struct intel\_engine\_cs *\emph{ engine}}{}
calculate \& cache the descriptor descriptor for a pinned context

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_gem\_context * ctx}}] \leavevmode
Context to work on

\item[{\code{struct intel\_engine\_cs * engine}}] \leavevmode
Engine the descriptor will be used with

\end{description}

\textbf{Description}

The context descriptor encodes various attributes of a context,
including its GTT address and some flags. Because it's fairly
expensive to calculate, we'll just do it once and cache the result,
which remains valid until the context is unpinned.

This is what a descriptor looks like, from LSB to MSB:

\begin{Verbatim}[commandchars=\\\{\}]
bits  0\PYGZhy{}11:    flags, GEN8\PYGZus{}CTX\PYGZus{}* (cached in ctx\PYGZhy{}\PYGZgt{}desc\PYGZus{}template)
bits 12\PYGZhy{}31:    LRCA, GTT address of (the HWSP of) this context
bits 32\PYGZhy{}52:    ctx ID, a globally unique tag
bits 53\PYGZhy{}54:    mbz, reserved for use by hardware
bits 55\PYGZhy{}63:    group ID, currently unused and set to 0
\end{Verbatim}
\index{intel\_logical\_ring\_cleanup (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_logical_ring_cleanup}\pysiglinewithargsret{void \bfcode{intel\_logical\_ring\_cleanup}}{struct intel\_engine\_cs *\emph{ engine}}{}
deallocate the Engine Command Streamer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_engine\_cs * engine}}] \leavevmode
Engine Command Streamer.

\end{description}


\subsection{Global GTT views}
\label{gpu/i915:global-gtt-views}
Background and previous state

Historically objects could exists (be bound) in global GTT space only as
singular instances with a view representing all of the object's backing pages
in a linear fashion. This view will be called a normal view.

To support multiple views of the same object, where the number of mapped
pages is not equal to the backing store, or where the layout of the pages
is not linear, concept of a GGTT view was added.

One example of an alternative view is a stereo display driven by a single
image. In this case we would have a framebuffer looking like this
(2x2 pages):
\begin{quote}

12
34
\end{quote}

Above would represent a normal GGTT view as normally mapped for GPU or CPU
rendering. In contrast, fed to the display engine would be an alternative
view which could look something like this:
\begin{quote}

1212
3434
\end{quote}

In this example both the size and layout of pages in the alternative view is
different from the normal view.

Implementation and usage

GGTT views are implemented using VMAs and are distinguished via enum
i915\_ggtt\_view\_type and struct i915\_ggtt\_view.

A new flavour of core GEM functions which work with GGTT bound objects were
added with the \_ggtt\_ infix, and sometimes with \_view postfix to avoid
renaming  in large amounts of code. They take the struct i915\_ggtt\_view
parameter encapsulating all metadata required to implement a view.

As a helper for callers which are only interested in the normal view,
globally const i915\_ggtt\_view\_normal singleton instance exists. All old core
GEM API functions, the ones not taking the view parameter, are operating on,
or with the normal GGTT view.

Code wanting to add or use a new GGTT view needs to:
\begin{enumerate}
\item {} 
Add a new enum with a suitable name.

\item {} 
Extend the metadata in the i915\_ggtt\_view structure if required.

\item {} 
Add support to \code{i915\_get\_vma\_pages()}.

\end{enumerate}

New views are required to build a scatter-gather table from within the
i915\_get\_vma\_pages function. This table is stored in the vma.ggtt\_view and
exists for the lifetime of an VMA.

Core API is designed to have copy semantics which means that passed in
struct i915\_ggtt\_view does not need to be persistent (left around after
calling the core API functions).
\index{i915\_ggtt\_cleanup\_hw (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_ggtt_cleanup_hw}\pysiglinewithargsret{void \bfcode{i915\_ggtt\_cleanup\_hw}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Clean up GGTT hardware initialization

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\end{description}
\index{intel\_ppat\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_ppat_get}\pysiglinewithargsret{const struct intel\_ppat\_entry * \bfcode{intel\_ppat\_get}}{struct drm\_i915\_private *\emph{ i915}, u8\emph{ value}}{}
get a usable PPAT entry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * i915}}] \leavevmode
i915 device instance

\item[{\code{u8 value}}] \leavevmode
the PPAT value required by the caller

\end{description}

\textbf{Description}

The function tries to search if there is an existing PPAT entry which
matches with the required value. If perfectly matched, the existing PPAT
entry will be used. If only partially matched, it will try to check if
there is any available PPAT index. If yes, it will allocate a new PPAT
index for the required entry and update the HW. If not, the partially
matched entry will be used.
\index{intel\_ppat\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_ppat_put}\pysiglinewithargsret{void \bfcode{intel\_ppat\_put}}{const struct intel\_ppat\_entry *\emph{ entry}}{}
put back the PPAT entry got from {\hyperref[gpu/i915:c.intel_ppat_get]{\emph{\code{intel\_ppat\_get()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct intel\_ppat\_entry * entry}}] \leavevmode
an intel PPAT entry

\end{description}

\textbf{Description}

Put back the PPAT entry got from {\hyperref[gpu/i915:c.intel_ppat_get]{\emph{\code{intel\_ppat\_get()}}}}. If the PPAT index of the
entry is dynamically allocated, its reference count will be decreased. Once
the reference count becomes into zero, the PPAT index becomes free again.
\index{i915\_ggtt\_probe\_hw (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_ggtt_probe_hw}\pysiglinewithargsret{int \bfcode{i915\_ggtt\_probe\_hw}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Probe GGTT hardware location

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\end{description}
\index{i915\_ggtt\_init\_hw (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_ggtt_init_hw}\pysiglinewithargsret{int \bfcode{i915\_ggtt\_init\_hw}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Initialize GGTT hardware

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device

\end{description}
\index{i915\_gem\_gtt\_reserve (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_gtt_reserve}\pysiglinewithargsret{int \bfcode{i915\_gem\_gtt\_reserve}}{struct i915\_address\_space *\emph{ vm}, struct {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{drm\_mm\_node}}} *\emph{ node}, u64\emph{ size}, u64\emph{ offset}, unsigned long\emph{ color}, unsigned int\emph{ flags}}{}
reserve a node in an address\_space (GTT)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_address\_space * vm}}] \leavevmode
the \code{struct i915\_address\_space}

\item[{\code{struct drm\_mm\_node * node}}] \leavevmode
the {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{\code{struct drm\_mm\_node}}}} (typically i915\_vma.mode)

\item[{\code{u64 size}}] \leavevmode
how much space to allocate inside the GTT,
must be \#I915\_GTT\_PAGE\_SIZE aligned

\item[{\code{u64 offset}}] \leavevmode
where to insert inside the GTT,
must be \#I915\_GTT\_MIN\_ALIGNMENT aligned, and the node
(\textbf{offset} + \textbf{size}) must fit within the address space

\item[{\code{unsigned long color}}] \leavevmode
color to apply to node, if this node is not from a VMA,
color must be \#I915\_COLOR\_UNEVICTABLE

\item[{\code{unsigned int flags}}] \leavevmode
control search and eviction behaviour

\end{description}

\textbf{Description}

{\hyperref[gpu/i915:c.i915_gem_gtt_reserve]{\emph{\code{i915\_gem\_gtt\_reserve()}}}} tries to insert the \textbf{node} at the exact \textbf{offset} inside
the address space (using \textbf{size} and \textbf{color}). If the \textbf{node} does not fit, it
tries to evict any overlapping nodes from the GTT, including any
neighbouring nodes if the colors do not match (to ensure guard pages between
differing domains). See {\hyperref[gpu/i915:c.i915_gem_evict_for_node]{\emph{\code{i915\_gem\_evict\_for\_node()}}}} for the gory details
on the eviction algorithm. \#PIN\_NONBLOCK may used to prevent waiting on
evicting active overlapping objects, and any overlapping node that is pinned
or marked as unevictable will also result in failure.

\textbf{Return}

0 on success, -ENOSPC if no suitable hole is found, -EINTR if
asked to wait for eviction and interrupted.
\index{i915\_gem\_gtt\_insert (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_gtt_insert}\pysiglinewithargsret{int \bfcode{i915\_gem\_gtt\_insert}}{struct i915\_address\_space *\emph{ vm}, struct {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{drm\_mm\_node}}} *\emph{ node}, u64\emph{ size}, u64\emph{ alignment}, unsigned long\emph{ color}, u64\emph{ start}, u64\emph{ end}, unsigned int\emph{ flags}}{}
insert a node into an address\_space (GTT)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_address\_space * vm}}] \leavevmode
the \code{struct i915\_address\_space}

\item[{\code{struct drm\_mm\_node * node}}] \leavevmode
the {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{\code{struct drm\_mm\_node}}}} (typically i915\_vma.node)

\item[{\code{u64 size}}] \leavevmode
how much space to allocate inside the GTT,
must be \#I915\_GTT\_PAGE\_SIZE aligned

\item[{\code{u64 alignment}}] \leavevmode
required alignment of starting offset, may be 0 but
if specified, this must be a power-of-two and at least
\#I915\_GTT\_MIN\_ALIGNMENT

\item[{\code{unsigned long color}}] \leavevmode
color to apply to node

\item[{\code{u64 start}}] \leavevmode
start of any range restriction inside GTT (0 for all),
must be \#I915\_GTT\_PAGE\_SIZE aligned

\item[{\code{u64 end}}] \leavevmode
end of any range restriction inside GTT (U64\_MAX for all),
must be \#I915\_GTT\_PAGE\_SIZE aligned if not U64\_MAX

\item[{\code{unsigned int flags}}] \leavevmode
control search and eviction behaviour

\end{description}

\textbf{Description}

{\hyperref[gpu/i915:c.i915_gem_gtt_insert]{\emph{\code{i915\_gem\_gtt\_insert()}}}} first searches for an available hole into which
is can insert the node. The hole address is aligned to \textbf{alignment} and
its \textbf{size} must then fit entirely within the {[}\textbf{start}, \textbf{end}{]} bounds. The
nodes on either side of the hole must match \textbf{color}, or else a guard page
will be inserted between the two nodes (or the node evicted). If no
suitable hole is found, first a victim is randomly selected and tested
for eviction, otherwise then the LRU list of objects within the GTT
is scanned to find the first set of replacement nodes to create the hole.
Those old overlapping nodes are evicted from the GTT (and so must be
rebound before any future use). Any node that is currently pinned cannot
be evicted (see \code{i915\_vma\_pin()}). Similar if the node's VMA is currently
active and \#PIN\_NONBLOCK is specified, that node is also skipped when
searching for an eviction candidate. See {\hyperref[gpu/i915:c.i915_gem_evict_something]{\emph{\code{i915\_gem\_evict\_something()}}}} for
the gory details on the eviction algorithm.

\textbf{Return}

0 on success, -ENOSPC if no suitable hole is found, -EINTR if
asked to wait for eviction and interrupted.


\subsection{GTT Fences and Swizzling}
\label{gpu/i915:gtt-fences-and-swizzling}\index{i915\_vma\_put\_fence (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_vma_put_fence}\pysiglinewithargsret{int \bfcode{i915\_vma\_put\_fence}}{struct i915\_vma *\emph{ vma}}{}
force-remove fence for a VMA

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_vma * vma}}] \leavevmode
vma to map linearly (not through a fence reg)

\end{description}

\textbf{Description}

This function force-removes any fence from the given object, which is useful
if the kernel wants to do untiled GTT access.

\textbf{Return}

0 on success, negative error code on failure.
\index{i915\_vma\_pin\_fence (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_vma_pin_fence}\pysiglinewithargsret{int \bfcode{i915\_vma\_pin\_fence}}{struct i915\_vma *\emph{ vma}}{}
set up fencing for a vma

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_vma * vma}}] \leavevmode
vma to map through a fence reg

\end{description}

\textbf{Description}

When mapping objects through the GTT, userspace wants to be able to write
to them without having to worry about swizzling if the object is tiled.
This function walks the fence regs looking for a free one for \textbf{obj},
stealing one if it can't find any.

It then sets up the reg based on the object's properties: address, pitch
and tiling format.

For an untiled surface, this removes any existing fence.

\textbf{Return}

0 on success, negative error code on failure.
\index{i915\_reserve\_fence (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_reserve_fence}\pysiglinewithargsret{struct drm\_i915\_fence\_reg * \bfcode{i915\_reserve\_fence}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Reserve a fence for vGPU

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device private

\end{description}

\textbf{Description}

This function walks the fence regs looking for a free one and remove
it from the fence\_list. It is used to reserve fence for vGPU to use.
\index{i915\_unreserve\_fence (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_unreserve_fence}\pysiglinewithargsret{void \bfcode{i915\_unreserve\_fence}}{struct drm\_i915\_fence\_reg *\emph{ fence}}{}
Reclaim a reserved fence

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_fence\_reg * fence}}] \leavevmode
the fence reg

\end{description}

\textbf{Description}

This function add a reserved fence register from vGPU to the fence\_list.
\index{i915\_gem\_revoke\_fences (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_revoke_fences}\pysiglinewithargsret{void \bfcode{i915\_gem\_revoke\_fences}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
revoke fence state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device private

\end{description}

\textbf{Description}

Removes all GTT mmappings via the fence registers. This forces any user
of the fence to reacquire that fence before continuing with their access.
One use is during GPU reset where the fence register is lost and we need to
revoke concurrent userspace access via GTT mmaps until the hardware has been
reset and the fence registers have been restored.
\index{i915\_gem\_restore\_fences (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_restore_fences}\pysiglinewithargsret{void \bfcode{i915\_gem\_restore\_fences}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
restore fence state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device private

\end{description}

\textbf{Description}

Restore the hw fence state to match the software tracking again, to be called
after a gpu reset and on resume. Note that on runtime suspend we only cancel
the fences, to be reacquired by the user later.
\index{i915\_gem\_detect\_bit\_6\_swizzle (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_detect_bit_6_swizzle}\pysiglinewithargsret{void \bfcode{i915\_gem\_detect\_bit\_6\_swizzle}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
detect bit 6 swizzling pattern

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device private

\end{description}

\textbf{Description}

Detects bit 6 swizzling of address lookup between IGD access and CPU
access through main memory.
\index{i915\_gem\_object\_do\_bit\_17\_swizzle (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_object_do_bit_17_swizzle}\pysiglinewithargsret{void \bfcode{i915\_gem\_object\_do\_bit\_17\_swizzle}}{struct drm\_i915\_gem\_object *\emph{ obj}, struct sg\_table *\emph{ pages}}{}
fixup bit 17 swizzling

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_gem\_object * obj}}] \leavevmode
i915 GEM buffer object

\item[{\code{struct sg\_table * pages}}] \leavevmode
the scattergather list of physical pages

\end{description}

\textbf{Description}

This function fixes up the swizzling in case any page frame number for this
object has changed in bit 17 since that state has been saved with
{\hyperref[gpu/i915:c.i915_gem_object_save_bit_17_swizzle]{\emph{\code{i915\_gem\_object\_save\_bit\_17\_swizzle()}}}}.

This is called when pinning backing storage again, since the kernel is free
to move unpinned backing storage around (either by directly moving pages or
by swapping them out and back in again).
\index{i915\_gem\_object\_save\_bit\_17\_swizzle (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_object_save_bit_17_swizzle}\pysiglinewithargsret{void \bfcode{i915\_gem\_object\_save\_bit\_17\_swizzle}}{struct drm\_i915\_gem\_object *\emph{ obj}, struct sg\_table *\emph{ pages}}{}
save bit 17 swizzling

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_gem\_object * obj}}] \leavevmode
i915 GEM buffer object

\item[{\code{struct sg\_table * pages}}] \leavevmode
the scattergather list of physical pages

\end{description}

\textbf{Description}

This function saves the bit 17 of each page frame number so that swizzling
can be fixed up later on with {\hyperref[gpu/i915:c.i915_gem_object_do_bit_17_swizzle]{\emph{\code{i915\_gem\_object\_do\_bit\_17\_swizzle()}}}}. This must
be called before the backing storage can be unpinned.


\subsubsection{Global GTT Fence Handling}
\label{gpu/i915:global-gtt-fence-handling}
Important to avoid confusions: ``fences'' in the i915 driver are not execution
fences used to track command completion but hardware detiler objects which
wrap a given range of the global GTT. Each platform has only a fairly limited
set of these objects.

Fences are used to detile GTT memory mappings. They're also connected to the
hardware frontbuffer render tracking and hence interact with frontbuffer
compression. Furthermore on older platforms fences are required for tiled
objects used by the display engine. They can also be used by the render
engine - they're required for blitter commands and are optional for render
commands. But on gen4+ both display (with the exception of fbc) and rendering
have their own tiling state bits and don't need fences.

Also note that fences only support X and Y tiling and hence can't be used for
the fancier new tiling formats like W, Ys and Yf.

Finally note that because fences are such a restricted resource they're
dynamically associated with objects. Furthermore fence state is committed to
the hardware lazily to avoid unnecessary stalls on gen2/3. Therefore code must
explicitly call \code{i915\_gem\_object\_get\_fence()} to synchronize fencing status
for cpu access. Also note that some code wants an unfenced view, for those
cases the fence can be removed forcefully with \code{i915\_gem\_object\_put\_fence()}.

Internally these functions will synchronize with userspace access by removing
CPU ptes into GTT mmaps (not the GTT ptes themselves) as needed.


\subsubsection{Hardware Tiling and Swizzling Details}
\label{gpu/i915:hardware-tiling-and-swizzling-details}
The idea behind tiling is to increase cache hit rates by rearranging
pixel data so that a group of pixel accesses are in the same cacheline.
Performance improvement from doing this on the back/depth buffer are on
the order of 30\%.

Intel architectures make this somewhat more complicated, though, by
adjustments made to addressing of data when the memory is in interleaved
mode (matched pairs of DIMMS) to improve memory bandwidth.
For interleaved memory, the CPU sends every sequential 64 bytes
to an alternate memory channel so it can get the bandwidth from both.

The GPU also rearranges its accesses for increased bandwidth to interleaved
memory, and it matches what the CPU does for non-tiled.  However, when tiled
it does it a little differently, since one walks addresses not just in the
X direction but also Y.  So, along with alternating channels when bit
6 of the address flips, it also alternates when other bits flip --  Bits 9
(every 512 bytes, an X tile scanline) and 10 (every two X tile scanlines)
are common to both the 915 and 965-class hardware.

The CPU also sometimes XORs in higher bits as well, to improve
bandwidth doing strided access like we do so frequently in graphics.  This
is called ``Channel XOR Randomization'' in the MCH documentation.  The result
is that the CPU is XORing in either bit 11 or bit 17 to bit 6 of its address
decode.

All of this bit 6 XORing has an effect on our memory management,
as we need to make sure that the 3d driver can correctly address object
contents.

If we don't have interleaved memory, all tiling is safe and no swizzling is
required.

When bit 17 is XORed in, we simply refuse to tile at all.  Bit
17 is not just a page offset, so as we page an object out and back in,
individual pages in it will have different bit 17 addresses, resulting in
each 64 bytes being swapped with its neighbor!

Otherwise, if interleaved, we have to tell the 3d driver what the address
swizzling it needs to do is, since it's writing with the CPU to the pages
(bit 6 and potentially bit 11 XORed in), and the GPU is reading from the
pages (bit 6, 9, and 10 XORed in), resulting in a cumulative bit swizzling
required by the CPU of XORing in bit 6, 9, 10, and potentially 11, in order
to match what the GPU expects.


\subsection{Object Tiling IOCTLs}
\label{gpu/i915:object-tiling-ioctls}\index{i915\_gem\_fence\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_fence_size}\pysiglinewithargsret{u32 \bfcode{i915\_gem\_fence\_size}}{struct drm\_i915\_private *\emph{ i915}, u32\emph{ size}, unsigned int\emph{ tiling}, unsigned int\emph{ stride}}{}
required global GTT size for a fence

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * i915}}] \leavevmode
i915 device

\item[{\code{u32 size}}] \leavevmode
object size

\item[{\code{unsigned int tiling}}] \leavevmode
tiling mode

\item[{\code{unsigned int stride}}] \leavevmode
tiling stride

\end{description}

\textbf{Description}

Return the required global GTT size for a fence (view of a tiled object),
taking into account potential fence register mapping.
\index{i915\_gem\_fence\_alignment (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_fence_alignment}\pysiglinewithargsret{u32 \bfcode{i915\_gem\_fence\_alignment}}{struct drm\_i915\_private *\emph{ i915}, u32\emph{ size}, unsigned int\emph{ tiling}, unsigned int\emph{ stride}}{}
required global GTT alignment for a fence

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * i915}}] \leavevmode
i915 device

\item[{\code{u32 size}}] \leavevmode
object size

\item[{\code{unsigned int tiling}}] \leavevmode
tiling mode

\item[{\code{unsigned int stride}}] \leavevmode
tiling stride

\end{description}

\textbf{Description}

Return the required global GTT alignment for a fence (a view of a tiled
object), taking into account potential fence register mapping.
\index{i915\_gem\_set\_tiling\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_set_tiling_ioctl}\pysiglinewithargsret{int \bfcode{i915\_gem\_set\_tiling\_ioctl}}{struct drm\_device *\emph{ dev}, void *\emph{ data}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file}}{}
IOCTL handler to set tiling mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{void * data}}] \leavevmode
data pointer for the ioctl

\item[{\code{struct drm\_file * file}}] \leavevmode
DRM file for the ioctl call

\end{description}

\textbf{Description}

Sets the tiling mode of an object, returning the required swizzling of
bit 6 of addresses in the object.

Called by the user via ioctl.

\textbf{Return}

Zero on success, negative errno on failure.
\index{i915\_gem\_get\_tiling\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_get_tiling_ioctl}\pysiglinewithargsret{int \bfcode{i915\_gem\_get\_tiling\_ioctl}}{struct drm\_device *\emph{ dev}, void *\emph{ data}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file}}{}
IOCTL handler to get tiling mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
DRM device

\item[{\code{void * data}}] \leavevmode
data pointer for the ioctl

\item[{\code{struct drm\_file * file}}] \leavevmode
DRM file for the ioctl call

\end{description}

\textbf{Description}

Returns the current tiling mode and required bit 6 swizzling for the object.

Called by the user via ioctl.

\textbf{Return}

Zero on success, negative errno on failure.

{\hyperref[gpu/i915:c.i915_gem_set_tiling_ioctl]{\emph{\code{i915\_gem\_set\_tiling\_ioctl()}}}} and {\hyperref[gpu/i915:c.i915_gem_get_tiling_ioctl]{\emph{\code{i915\_gem\_get\_tiling\_ioctl()}}}} is the userspace
interface to declare fence register requirements.

In principle GEM doesn't care at all about the internal data layout of an
object, and hence it also doesn't care about tiling or swizzling. There's two
exceptions:
\begin{itemize}
\item {} 
For X and Y tiling the hardware provides detilers for CPU access, so called
fences. Since there's only a limited amount of them the kernel must manage
these, and therefore userspace must tell the kernel the object tiling if it
wants to use fences for detiling.

\item {} 
On gen3 and gen4 platforms have a swizzling pattern for tiled objects which
depends upon the physical page frame number. When swapping such objects the
page frame number might change and the kernel must be able to fix this up
and hence now the tiling. Note that on a subset of platforms with
asymmetric memory channel population the swizzling pattern changes in an
unknown way, and for those the kernel simply forbids swapping completely.

\end{itemize}

Since neither of this applies for new tiling layouts on modern platforms like
W, Ys and Yf tiling GEM only allows object tiling to be set to X or Y tiled.
Anything else can be handled in userspace entirely without the kernel's
invovlement.


\subsection{Buffer Object Eviction}
\label{gpu/i915:buffer-object-eviction}
This section documents the interface functions for evicting buffer
objects to make space available in the virtual gpu address spaces. Note
that this is mostly orthogonal to shrinking buffer objects caches, which
has the goal to make main memory (shared with the gpu through the
unified memory architecture) available.
\index{i915\_gem\_evict\_something (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_evict_something}\pysiglinewithargsret{int \bfcode{i915\_gem\_evict\_something}}{struct i915\_address\_space *\emph{ vm}, u64\emph{ min\_size}, u64\emph{ alignment}, unsigned\emph{ cache\_level}, u64\emph{ start}, u64\emph{ end}, unsigned\emph{ flags}}{}
Evict vmas to make room for binding a new one

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_address\_space * vm}}] \leavevmode
address space to evict from

\item[{\code{u64 min\_size}}] \leavevmode
size of the desired free space

\item[{\code{u64 alignment}}] \leavevmode
alignment constraint of the desired free space

\item[{\code{unsigned cache\_level}}] \leavevmode
cache\_level for the desired space

\item[{\code{u64 start}}] \leavevmode
start (inclusive) of the range from which to evict objects

\item[{\code{u64 end}}] \leavevmode
end (exclusive) of the range from which to evict objects

\item[{\code{unsigned flags}}] \leavevmode
additional flags to control the eviction algorithm

\end{description}

\textbf{Description}

This function will try to evict vmas until a free space satisfying the
requirements is found. Callers must check first whether any such hole exists
already before calling this function.

This function is used by the object/vma binding code.

Since this function is only used to free up virtual address space it only
ignores pinned vmas, and not object where the backing storage itself is
pinned. Hence obj-\textgreater{}pages\_pin\_count does not protect against eviction.

To clarify: This is for freeing up virtual address space, not for freeing
memory in e.g. the shrinker.
\index{i915\_gem\_evict\_for\_node (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_evict_for_node}\pysiglinewithargsret{int \bfcode{i915\_gem\_evict\_for\_node}}{struct i915\_address\_space *\emph{ vm}, struct {\hyperref[gpu/drm\string-mm:c.drm_mm_node]{\emph{drm\_mm\_node}}} *\emph{ target}, unsigned int\emph{ flags}}{}
Evict vmas to make room for binding a new one

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_address\_space * vm}}] \leavevmode
address space to evict from

\item[{\code{struct drm\_mm\_node * target}}] \leavevmode
range (and color) to evict for

\item[{\code{unsigned int flags}}] \leavevmode
additional flags to control the eviction algorithm

\end{description}

\textbf{Description}

This function will try to evict vmas that overlap the target node.

To clarify: This is for freeing up virtual address space, not for freeing
memory in e.g. the shrinker.
\index{i915\_gem\_evict\_vm (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_evict_vm}\pysiglinewithargsret{int \bfcode{i915\_gem\_evict\_vm}}{struct i915\_address\_space *\emph{ vm}}{}
Evict all idle vmas from a vm

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_address\_space * vm}}] \leavevmode
Address space to cleanse

\end{description}

\textbf{Description}

This function evicts all vmas from a vm.

This is used by the execbuf code as a last-ditch effort to defragment the
address space.

To clarify: This is for freeing up virtual address space, not for freeing
memory in e.g. the shrinker.


\subsection{Buffer Object Memory Shrinking}
\label{gpu/i915:buffer-object-memory-shrinking}
This section documents the interface function for shrinking memory usage
of buffer object caches. Shrinking is used to make main memory
available. Note that this is mostly orthogonal to evicting buffer
objects, which has the goal to make space in gpu virtual address spaces.
\index{i915\_gem\_shrink (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_shrink}\pysiglinewithargsret{unsigned long \bfcode{i915\_gem\_shrink}}{struct drm\_i915\_private *\emph{ i915}, unsigned long\emph{ target}, unsigned long *\emph{ nr\_scanned}, unsigned\emph{ flags}}{}
Shrink buffer object caches

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * i915}}] \leavevmode
i915 device

\item[{\code{unsigned long target}}] \leavevmode
amount of memory to make available, in pages

\item[{\code{unsigned long * nr\_scanned}}] \leavevmode
optional output for number of pages scanned (incremental)

\item[{\code{unsigned flags}}] \leavevmode
control flags for selecting cache types

\end{description}

\textbf{Description}

This function is the main interface to the shrinker. It will try to release
up to \textbf{target} pages of main memory backing storage from buffer objects.
Selection of the specific caches can be done with \textbf{flags}. This is e.g. useful
when purgeable objects should be removed from caches preferentially.

Note that it's not guaranteed that released amount is actually available as
free system memory - the pages might still be in-used to due to other reasons
(like cpu mmaps) or the mm core has reused them before we could grab them.
Therefore code that needs to explicitly shrink buffer objects caches (e.g. to
avoid deadlocks in memory reclaim) must fall back to {\hyperref[gpu/i915:c.i915_gem_shrink_all]{\emph{\code{i915\_gem\_shrink\_all()}}}}.

Also note that any kind of pinning (both per-vma address space pins and
backing storage pins at the buffer object level) result in the shrinker code
having to skip the object.

\textbf{Return}

The number of pages of backing storage actually released.
\index{i915\_gem\_shrink\_all (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_shrink_all}\pysiglinewithargsret{unsigned long \bfcode{i915\_gem\_shrink\_all}}{struct drm\_i915\_private *\emph{ i915}}{}
Shrink buffer object caches completely

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * i915}}] \leavevmode
i915 device

\end{description}

\textbf{Description}

This is a simple wraper around {\hyperref[gpu/i915:c.i915_gem_shrink]{\emph{\code{i915\_gem\_shrink()}}}} to aggressively shrink all
caches completely. It also first waits for and retires all outstanding
requests to also be able to release backing storage for active objects.

This should only be used in code to intentionally quiescent the gpu or as a
last-ditch effort when memory seems to have run out.

\textbf{Return}

The number of pages of backing storage actually released.
\index{i915\_gem\_shrinker\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_shrinker_register}\pysiglinewithargsret{void \bfcode{i915\_gem\_shrinker\_register}}{struct drm\_i915\_private *\emph{ i915}}{}
Register the i915 shrinker

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * i915}}] \leavevmode
i915 device

\end{description}

\textbf{Description}

This function registers and sets up the i915 shrinker and OOM handler.
\index{i915\_gem\_shrinker\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_gem_shrinker_unregister}\pysiglinewithargsret{void \bfcode{i915\_gem\_shrinker\_unregister}}{struct drm\_i915\_private *\emph{ i915}}{}
Unregisters the i915 shrinker

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * i915}}] \leavevmode
i915 device

\end{description}

\textbf{Description}

This function unregisters the i915 shrinker and OOM handler.


\section{GuC}
\label{gpu/i915:guc}

\subsection{GuC-specific firmware loader}
\label{gpu/i915:guc-specific-firmware-loader}\index{intel\_guc\_fw\_init\_early (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_guc_fw_init_early}\pysiglinewithargsret{void \bfcode{intel\_guc\_fw\_init\_early}}{struct intel\_guc *\emph{ guc}}{}
initializes GuC firmware struct

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_guc * guc}}] \leavevmode
intel\_guc struct

\end{description}

\textbf{Description}

On platforms with GuC selects firmware for uploading
\index{intel\_guc\_fw\_upload (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.intel_guc_fw_upload}\pysiglinewithargsret{int \bfcode{intel\_guc\_fw\_upload}}{struct intel\_guc *\emph{ guc}}{}
finish preparing the GuC for activity

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_guc * guc}}] \leavevmode
intel\_guc structure

\end{description}

\textbf{Description}

Called during driver loading and also after a GPU reset.

The main action required here it to load the GuC uCode into the device.
The firmware image should have already been fetched into memory by the
earlier call to \code{intel\_guc\_init()}, so here we need only check that
worked, and then transfer the image to the h/w.

\textbf{Return}

non-zero code on error


\subsection{GuC-based command submission}
\label{gpu/i915:guc-based-command-submission}
GuC client:
A intel\_guc\_client refers to a submission path through GuC. Currently, there
are two clients. One of them (the execbuf\_client) is charged with all
submissions to the GuC, the other one (preempt\_client) is responsible for
preempting the execbuf\_client. This struct is the owner of a doorbell, a
process descriptor and a workqueue (all of them inside a single gem object
that contains all required pages for these elements).

GuC stage descriptor:
During initialization, the driver allocates a static pool of 1024 such
descriptors, and shares them with the GuC.
Currently, there exists a 1:1 mapping between a intel\_guc\_client and a
guc\_stage\_desc (via the client's stage\_id), so effectively only one
gets used. This stage descriptor lets the GuC know about the doorbell,
workqueue and process descriptor. Theoretically, it also lets the GuC
know about our HW contexts (context ID, etc...), but we actually
employ a kind of submission where the GuC uses the LRCA sent via the work
item instead (the single guc\_stage\_desc associated to execbuf client
contains information about the default kernel context only, but this is
essentially unused). This is called a ``proxy'' submission.

The Scratch registers:
There are 16 MMIO-based registers start from 0xC180. The kernel driver writes
a value to the action register (SOFT\_SCRATCH\_0) along with any data. It then
triggers an interrupt on the GuC via another register write (0xC4C8).
Firmware writes a success/fail code back to the action register after
processes the request. The kernel driver polls waiting for this update and
then proceeds.
See \code{intel\_guc\_send()}

Doorbells:
Doorbells are interrupts to uKernel. A doorbell is a single cache line (QW)
mapped into process space.

Work Items:
There are several types of work items that the host may place into a
workqueue, each with its own requirements and limitations. Currently only
WQ\_TYPE\_INORDER is needed to support legacy submission via GuC, which
represents in-order queue. The kernel driver packs ring tail pointer and an
ELSP context descriptor dword into Work Item.
See \code{guc\_add\_request()}

ADS:
The Additional Data Struct (ADS) has pointers for different buffers used by
the GuC. One single gem object contains the ADS struct itself (guc\_ads), the
scheduling policies (guc\_policies), a structure describing a collection of
register sets (guc\_mmio\_reg\_state) and some extra pages for the GuC to save
its internal state for sleep.
\index{guc\_submit (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.guc_submit}\pysiglinewithargsret{void \bfcode{guc\_submit}}{struct intel\_engine\_cs *\emph{ engine}}{}
Submit commands through GuC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct intel\_engine\_cs * engine}}] \leavevmode
engine associated with the commands

\end{description}

\textbf{Description}

The only error here arises if the doorbell hardware isn't functioning
as expected, which really shouln't happen.
\index{guc\_client\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.guc_client_alloc}\pysiglinewithargsret{struct intel\_guc\_client * \bfcode{guc\_client\_alloc}}{struct drm\_i915\_private *\emph{ dev\_priv}, u32\emph{ engines}, u32\emph{ priority}, struct i915\_gem\_context *\emph{ ctx}}{}
Allocate an intel\_guc\_client

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
driver private data structure

\item[{\code{u32 engines}}] \leavevmode
The set of engines to enable for this client

\item[{\code{u32 priority}}] \leavevmode
four levels priority \_CRITICAL, \_HIGH, \_NORMAL and \_LOW
The kernel client to replace ExecList submission is created with
NORMAL priority. Priority of a client for scheduler can be HIGH,
while a preemption context can use CRITICAL.

\item[{\code{struct i915\_gem\_context * ctx}}] \leavevmode
the context that owns the client (we use the default render
context)

\end{description}

\textbf{Return}

An intel\_guc\_client object if success, else NULL.


\subsection{GuC Firmware Layout}
\label{gpu/i915:guc-firmware-layout}
The GuC firmware layout looks like this:
\begin{quote}

\begin{tabular}{|p{0.950\linewidth}|}
\hline
\begin{quote}

uc\_css\_header
\end{quote}

contains major/minor version
\\
\hline
uCode
\\
\hline
RSA signature
\\
\hline
modulus key
\\
\hline
exponent val
\\
\hline\end{tabular}

\end{quote}

The firmware may or may not have modulus key and exponent data. The header,
uCode and RSA signature are must-have components that will be used by driver.
Length of each components, which is all in dwords, can be found in header.
In the case that modulus and exponent are not present in fw, a.k.a truncated
image, the length value still appears in header.

Driver will do some basic fw size validation based on the following rules:
\begin{enumerate}
\item {} 
Header, uCode and RSA are must-have components.

\item {} 
All firmware components, if they present, are in the sequence illustrated
in the layout table above.

\item {} 
Length info of each component can be found in header, in dwords.

\item {} 
Modulus and exponent key are not required by driver. They may not appear
in fw. So driver will load a truncated firmware in this case.

\end{enumerate}

HuC firmware layout is same as GuC firmware.

HuC firmware css header is different. However, the only difference is where
the version information is saved. The uc\_css\_header is unified to support
both. Driver should get HuC version from uc\_css\_header.huc\_sw\_version, while
uc\_css\_header.guc\_sw\_version for GuC.


\section{Tracing}
\label{gpu/i915:tracing}
This sections covers all things related to the tracepoints implemented
in the i915 driver.


\subsection{i915\_ppgtt\_create and i915\_ppgtt\_release}
\label{gpu/i915:i915-ppgtt-create-and-i915-ppgtt-release}
With full ppgtt enabled each process using drm will allocate at least one
translation table. With these traces it is possible to keep track of the
allocation and of the lifetime of the tables; this can be used during
testing/debug to verify that we are not leaking ppgtts.
These traces identify the ppgtt through the vm pointer, which is also printed
by the i915\_vma\_bind and i915\_vma\_unbind tracepoints.


\subsection{i915\_context\_create and i915\_context\_free}
\label{gpu/i915:i915-context-create-and-i915-context-free}
These tracepoints are used to track creation and deletion of contexts.
If full ppgtt is enabled, they also print the address of the vm assigned to
the context.


\subsection{switch\_mm}
\label{gpu/i915:switch-mm}
This tracepoint allows tracking of the mm switch, which is an important point
in the lifetime of the vm in the legacy submission path. This tracepoint is
called only if full ppgtt is enabled.


\section{Perf}
\label{gpu/i915:perf}

\subsection{Overview}
\label{gpu/i915:overview}
Gen graphics supports a large number of performance counters that can help
driver and application developers understand and optimize their use of the
GPU.

This i915 perf interface enables userspace to configure and open a file
descriptor representing a stream of GPU metrics which can then be \code{read()} as
a stream of sample records.

The interface is particularly suited to exposing buffered metrics that are
captured by DMA from the GPU, unsynchronized with and unrelated to the CPU.

Streams representing a single context are accessible to applications with a
corresponding drm file descriptor, such that OpenGL can use the interface
without special privileges. Access to system-wide metrics requires root
privileges by default, unless changed via the dev.i915.perf\_event\_paranoid
sysctl option.


\subsection{Comparison with Core Perf}
\label{gpu/i915:comparison-with-core-perf}
The interface was initially inspired by the core Perf infrastructure but
some notable differences are:

i915 perf file descriptors represent a ``stream'' instead of an ``event''; where
a perf event primarily corresponds to a single 64bit value, while a stream
might sample sets of tightly-coupled counters, depending on the
configuration.  For example the Gen OA unit isn't designed to support
orthogonal configurations of individual counters; it's configured for a set
of related counters. Samples for an i915 perf stream capturing OA metrics
will include a set of counter values packed in a compact HW specific format.
The OA unit supports a number of different packing formats which can be
selected by the user opening the stream. Perf has support for grouping
events, but each event in the group is configured, validated and
authenticated individually with separate system calls.

i915 perf stream configurations are provided as an array of u64 (key,value)
pairs, instead of a fixed struct with multiple miscellaneous config members,
interleaved with event-type specific members.

i915 perf doesn't support exposing metrics via an mmap'd circular buffer.
The supported metrics are being written to memory by the GPU unsynchronized
with the CPU, using HW specific packing formats for counter sets. Sometimes
the constraints on HW configuration require reports to be filtered before it
would be acceptable to expose them to unprivileged applications - to hide
the metrics of other processes/contexts. For these use cases a \code{read()} based
interface is a good fit, and provides an opportunity to filter data as it
gets copied from the GPU mapped buffers to userspace buffers.


\subsubsection{Issues hit with first prototype based on Core Perf}
\label{gpu/i915:issues-hit-with-first-prototype-based-on-core-perf}
The first prototype of this driver was based on the core perf
infrastructure, and while we did make that mostly work, with some changes to
perf, we found we were breaking or working around too many assumptions baked
into perf's currently cpu centric design.

In the end we didn't see a clear benefit to making perf's implementation and
interface more complex by changing design assumptions while we knew we still
wouldn't be able to use any existing perf based userspace tools.

Also considering the Gen specific nature of the Observability hardware and
how userspace will sometimes need to combine i915 perf OA metrics with
side-band OA data captured via MI\_REPORT\_PERF\_COUNT commands; we're
expecting the interface to be used by a platform specific userspace such as
OpenGL or tools. This is to say; we aren't inherently missing out on having
a standard vendor/architecture agnostic interface by not using perf.

For posterity, in case we might re-visit trying to adapt core perf to be
better suited to exposing i915 metrics these were the main pain points we
hit:
\begin{itemize}
\item {} 
The perf based OA PMU driver broke some significant design assumptions:

Existing perf pmus are used for profiling work on a cpu and we were
introducing the idea of \_IS\_DEVICE pmus with different security
implications, the need to fake cpu-related data (such as user/kernel
registers) to fit with perf's current design, and adding \_DEVICE records
as a way to forward device-specific status records.

The OA unit writes reports of counters into a circular buffer, without
involvement from the CPU, making our PMU driver the first of a kind.

Given the way we were periodically forward data from the GPU-mapped, OA
buffer to perf's buffer, those bursts of sample writes looked to perf like
we were sampling too fast and so we had to subvert its throttling checks.

Perf supports groups of counters and allows those to be read via
transactions internally but transactions currently seem designed to be
explicitly initiated from the cpu (say in response to a userspace \code{read()})
and while we could pull a report out of the OA buffer we can't
trigger a report from the cpu on demand.

Related to being report based; the OA counters are configured in HW as a
set while perf generally expects counter configurations to be orthogonal.
Although counters can be associated with a group leader as they are
opened, there's no clear precedent for being able to provide group-wide
configuration attributes (for example we want to let userspace choose the
OA unit report format used to capture all counters in a set, or specify a
GPU context to filter metrics on). We avoided using perf's grouping
feature and forwarded OA reports to userspace via perf's `raw' sample
field. This suited our userspace well considering how coupled the counters
are when dealing with normalizing. It would be inconvenient to split
counters up into separate events, only to require userspace to recombine
them. For Mesa it's also convenient to be forwarded raw, periodic reports
for combining with the side-band raw reports it captures using
MI\_REPORT\_PERF\_COUNT commands.
\begin{itemize}
\item {} 
As a side note on perf's grouping feature; there was also some concern
that using PERF\_FORMAT\_GROUP as a way to pack together counter values
would quite drastically inflate our sample sizes, which would likely
lower the effective sampling resolutions we could use when the available
memory bandwidth is limited.

With the OA unit's report formats, counters are packed together as 32
or 40bit values, with the largest report size being 256 bytes.

PERF\_FORMAT\_GROUP values are 64bit, but there doesn't appear to be a
documented ordering to the values, implying PERF\_FORMAT\_ID must also be
used to add a 64bit ID before each value; giving 16 bytes per counter.

\end{itemize}

Related to counter orthogonality; we can't time share the OA unit, while
event scheduling is a central design idea within perf for allowing
userspace to open + enable more events than can be configured in HW at any
one time.  The OA unit is not designed to allow re-configuration while in
use. We can't reconfigure the OA unit without losing internal OA unit
state which we can't access explicitly to save and restore. Reconfiguring
the OA unit is also relatively slow, involving \textasciitilde{}100 register writes. From
userspace Mesa also depends on a stable OA configuration when emitting
MI\_REPORT\_PERF\_COUNT commands and importantly the OA unit can't be
disabled while there are outstanding MI\_RPC commands lest we hang the
command streamer.

The contents of sample records aren't extensible by device drivers (i.e.
the sample\_type bits). As an example; Sourab Gupta had been looking to
attach GPU timestamps to our OA samples. We were shoehorning OA reports
into sample records by using the `raw' field, but it's tricky to pack more
than one thing into this field because events/core.c currently only lets a
pmu give a single raw data pointer plus len which will be copied into the
ring buffer. To include more than the OA report we'd have to copy the
report into an intermediate larger buffer. I'd been considering allowing a
vector of data+len values to be specified for copying the raw data, but
it felt like a kludge to being using the raw field for this purpose.

\item {} 
It felt like our perf based PMU was making some technical compromises
just for the sake of using perf:

\code{perf\_event\_open()} requires events to either relate to a pid or a specific
cpu core, while our device pmu related to neither.  Events opened with a
pid will be automatically enabled/disabled according to the scheduling of
that process - so not appropriate for us. When an event is related to a
cpu id, perf ensures pmu methods will be invoked via an inter process
interrupt on that core. To avoid invasive changes our userspace opened OA
perf events for a specific cpu. This was workable but it meant the
majority of the OA driver ran in atomic context, including all OA report
forwarding, which wasn't really necessary in our case and seems to make
our locking requirements somewhat complex as we handled the interaction
with the rest of the i915 driver.

\end{itemize}


\subsection{i915 Driver Entry Points}
\label{gpu/i915:i915-driver-entry-points}
This section covers the entrypoints exported outside of i915\_perf.c to
integrate with drm/i915 and to handle the \emph{DRM\_I915\_PERF\_OPEN} ioctl.
\index{i915\_perf\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_init}\pysiglinewithargsret{void \bfcode{i915\_perf\_init}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
initialize i915-perf state on module load

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

Initializes i915-perf state without exposing anything to userspace.

\textbf{Note}

i915-perf initialization is split into an `init' and `register'
phase with the {\hyperref[gpu/i915:c.i915_perf_register]{\emph{\code{i915\_perf\_register()}}}} exposing state to userspace.
\index{i915\_perf\_fini (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_fini}\pysiglinewithargsret{void \bfcode{i915\_perf\_fini}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Counter part to {\hyperref[gpu/i915:c.i915_perf_init]{\emph{\code{i915\_perf\_init()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}
\index{i915\_perf\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_register}\pysiglinewithargsret{void \bfcode{i915\_perf\_register}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
exposes i915-perf to userspace

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

In particular OA metric sets are advertised under a sysfs metrics/
directory allowing userspace to enumerate valid IDs that can be
used to open an i915-perf stream.
\index{i915\_perf\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_unregister}\pysiglinewithargsret{void \bfcode{i915\_perf\_unregister}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
hide i915-perf from userspace

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

i915-perf state cleanup is split up into an `unregister' and
`deinit' phase where the interface is first hidden from
userspace by {\hyperref[gpu/i915:c.i915_perf_unregister]{\emph{\code{i915\_perf\_unregister()}}}} before cleaning up
remaining state in {\hyperref[gpu/i915:c.i915_perf_fini]{\emph{\code{i915\_perf\_fini()}}}}.
\index{i915\_perf\_open\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_open_ioctl}\pysiglinewithargsret{int \bfcode{i915\_perf\_open\_ioctl}}{struct drm\_device *\emph{ dev}, void *\emph{ data}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file}}{}
DRM \code{ioctl()} for userspace to open a stream FD

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{void * data}}] \leavevmode
ioctl data copied from userspace (unvalidated)

\item[{\code{struct drm\_file * file}}] \leavevmode
drm file

\end{description}

\textbf{Description}

Validates the stream open parameters given by userspace including flags
and an array of u64 key, value pair properties.

Very little is assumed up front about the nature of the stream being
opened (for instance we don't assume it's for periodic OA unit metrics). An
i915-perf stream is expected to be a suitable interface for other forms of
buffered data written by the GPU besides periodic OA metrics.

Note we copy the properties from userspace outside of the i915 perf
mutex to avoid an awkward lockdep with mmap\_sem.

Most of the implementation details are handled by
{\hyperref[gpu/i915:c.i915_perf_open_ioctl_locked]{\emph{\code{i915\_perf\_open\_ioctl\_locked()}}}} after taking the \code{drm\_i915\_private-\textgreater{}perf}.lock
mutex for serializing with any non-file-operation driver hooks.

\textbf{Return}

A newly opened i915 Perf stream file descriptor or negative
error code on failure.
\index{i915\_perf\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_release}\pysiglinewithargsret{int \bfcode{i915\_perf\_release}}{struct inode *\emph{ inode}, struct file *\emph{ file}}{}
handles userspace \code{close()} of a stream file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
anonymous inode associated with file

\item[{\code{struct file * file}}] \leavevmode
An i915 perf stream file

\end{description}

\textbf{Description}

Cleans up any resources associated with an open i915 perf stream file.

NB: \code{close()} can't really fail from the userspace point of view.

\textbf{Return}

zero on success or a negative error code.
\index{i915\_perf\_add\_config\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_add_config_ioctl}\pysiglinewithargsret{int \bfcode{i915\_perf\_add\_config\_ioctl}}{struct drm\_device *\emph{ dev}, void *\emph{ data}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file}}{}
DRM \code{ioctl()} for userspace to add a new OA config

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{void * data}}] \leavevmode
ioctl data (pointer to struct drm\_i915\_perf\_oa\_config) copied from
userspace (unvalidated)

\item[{\code{struct drm\_file * file}}] \leavevmode
drm file

\end{description}

\textbf{Description}

Validates the submitted OA register to be saved into a new OA config that
can then be used for programming the OA unit and its NOA network.

\textbf{Return}

A new allocated config number to be used with the perf open ioctl
or a negative error code on failure.
\index{i915\_perf\_remove\_config\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_remove_config_ioctl}\pysiglinewithargsret{int \bfcode{i915\_perf\_remove\_config\_ioctl}}{struct drm\_device *\emph{ dev}, void *\emph{ data}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file}}{}
DRM \code{ioctl()} for userspace to remove an OA config

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{void * data}}] \leavevmode
ioctl data (pointer to u64 integer) copied from userspace

\item[{\code{struct drm\_file * file}}] \leavevmode
drm file

\end{description}

\textbf{Description}

Configs can be removed while being used, the will stop appearing in sysfs
and their content will be freed when the stream using the config is closed.

\textbf{Return}

0 on success or a negative error code on failure.


\subsection{i915 Perf Stream}
\label{gpu/i915:i915-perf-stream}
This section covers the stream-semantics-agnostic structures and functions
for representing an i915 perf stream FD and associated file operations.
\index{i915\_perf\_stream (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_stream}\pysigline{struct \bfcode{i915\_perf\_stream}}
state for a single open stream FD

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct i915\PYGZus{}perf\PYGZus{}stream \PYGZob{}
  struct drm\PYGZus{}i915\PYGZus{}private *dev\PYGZus{}priv;
  struct list\PYGZus{}head link;
  u32 sample\PYGZus{}flags;
  int sample\PYGZus{}size;
  struct i915\PYGZus{}gem\PYGZus{}context *ctx;
  bool enabled;
  const struct i915\PYGZus{}perf\PYGZus{}stream\PYGZus{}ops *ops;
  struct i915\PYGZus{}oa\PYGZus{}config *oa\PYGZus{}config;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev\_priv}}] \leavevmode
i915 drm device

\item[{\code{link}}] \leavevmode
Links the stream into \code{:c:type:{}`drm\_i915\_private-\textgreater{}streams \textless{}drm\_i915\_private\textgreater{}{}`}

\item[{\code{sample\_flags}}] \leavevmode
Flags representing the \emph{DRM\_I915\_PERF\_PROP\_SAMPLE\_*}
properties given when opening a stream, representing the contents
of a single sample as \code{read()} by userspace.

\item[{\code{sample\_size}}] \leavevmode
Considering the configured contents of a sample
combined with the required header size, this is the total size
of a single sample record.

\item[{\code{ctx}}] \leavevmode
\code{NULL} if measuring system-wide across all contexts or a
specific context that is being monitored.

\item[{\code{enabled}}] \leavevmode
Whether the stream is currently enabled, considering
whether the stream was opened in a disabled state and based
on \emph{I915\_PERF\_IOCTL\_ENABLE} and \emph{I915\_PERF\_IOCTL\_DISABLE} calls.

\item[{\code{ops}}] \leavevmode
The callbacks providing the implementation of this specific
type of configured stream.

\item[{\code{oa\_config}}] \leavevmode
The OA configuration used by the stream.

\end{description}
\index{i915\_perf\_stream\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_stream_ops}\pysigline{struct \bfcode{i915\_perf\_stream\_ops}}
the OPs to support a specific stream type

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct i915\PYGZus{}perf\PYGZus{}stream\PYGZus{}ops \PYGZob{}
  void (*enable)(struct i915\PYGZus{}perf\PYGZus{}stream *stream);
  void (*disable)(struct i915\PYGZus{}perf\PYGZus{}stream *stream);
  void (*poll\PYGZus{}wait)(struct i915\PYGZus{}perf\PYGZus{}stream *stream,struct file *file, poll\PYGZus{}table *wait);
  int (*wait\PYGZus{}unlocked)(struct i915\PYGZus{}perf\PYGZus{}stream *stream);
  int (*read)(struct i915\PYGZus{}perf\PYGZus{}stream *stream,char \PYGZus{}\PYGZus{}user *buf,size\PYGZus{}t count, size\PYGZus{}t *offset);
  void (*destroy)(struct i915\PYGZus{}perf\PYGZus{}stream *stream);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{enable}}] \leavevmode
Enables the collection of HW samples, either in response to
\emph{I915\_PERF\_IOCTL\_ENABLE} or implicitly called when stream is opened
without \emph{I915\_PERF\_FLAG\_DISABLED}.

\item[{\code{disable}}] \leavevmode
Disables the collection of HW samples, either in response
to \emph{I915\_PERF\_IOCTL\_DISABLE} or implicitly called before destroying
the stream.

\item[{\code{poll\_wait}}] \leavevmode
Call poll\_wait, passing a wait queue that will be woken
once there is something ready to \code{read()} for the stream

\item[{\code{wait\_unlocked}}] \leavevmode
For handling a blocking read, wait until there is
something to ready to \code{read()} for the stream. E.g. wait on the same
wait queue that would be passed to \code{poll\_wait()}.

\item[{\code{read}}] \leavevmode
Copy buffered metrics as records to userspace
\textbf{buf}: the userspace, destination buffer
\textbf{count}: the number of bytes to copy, requested by userspace
\textbf{offset}: zero at the start of the read, updated as the read
proceeds, it represents how many bytes have been copied so far and
the buffer offset for copying the next record.

Copy as many buffered i915 perf samples and records for this stream
to userspace as will fit in the given buffer.

Only write complete records; returning -\code{ENOSPC} if there isn't room
for a complete record.

Return any error condition that results in a short read such as
-\code{ENOSPC} or -\code{EFAULT}, even though these may be squashed before
returning to userspace.

\item[{\code{destroy}}] \leavevmode
Cleanup any stream specific resources.

The stream will always be disabled before this is called.

\end{description}
\index{read\_properties\_unlocked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.read_properties_unlocked}\pysiglinewithargsret{int \bfcode{read\_properties\_unlocked}}{struct drm\_i915\_private *\emph{ dev\_priv}, u64 \_\_user *\emph{ uprops}, u32\emph{ n\_props}, struct {\hyperref[gpu/i915:c.perf_open_properties]{\emph{perf\_open\_properties}}} *\emph{ props}}{}
validate + copy userspace stream open properties

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{u64 \_\_user * uprops}}] \leavevmode
The array of u64 key value pairs given by userspace

\item[{\code{u32 n\_props}}] \leavevmode
The number of key value pairs expected in \textbf{uprops}

\item[{\code{struct perf\_open\_properties * props}}] \leavevmode
The stream configuration built up while validating properties

\end{description}

\textbf{Description}

Note this function only validates properties in isolation it doesn't
validate that the combination of properties makes sense or that all
properties necessary for a particular kind of stream have been set.

Note that there currently aren't any ordering requirements for properties so
we shouldn't validate or assume anything about ordering here. This doesn't
rule out defining new properties with ordering requirements in the future.
\index{i915\_perf\_open\_ioctl\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_open_ioctl_locked}\pysiglinewithargsret{int \bfcode{i915\_perf\_open\_ioctl\_locked}}{struct drm\_i915\_private *\emph{ dev\_priv}, struct drm\_i915\_perf\_open\_param *\emph{ param}, struct {\hyperref[gpu/i915:c.perf_open_properties]{\emph{perf\_open\_properties}}} *\emph{ props}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file}}{}
DRM \code{ioctl()} for userspace to open a stream FD

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{struct drm\_i915\_perf\_open\_param * param}}] \leavevmode
The open parameters passed to `DRM\_I915\_PERF\_OPEN{}`

\item[{\code{struct perf\_open\_properties * props}}] \leavevmode
individually validated u64 property value pairs

\item[{\code{struct drm\_file * file}}] \leavevmode
drm file

\end{description}

\textbf{Description}

See \code{i915\_perf\_ioctl\_open()} for interface details.

Implements further stream config validation and stream initialization on
behalf of {\hyperref[gpu/i915:c.i915_perf_open_ioctl]{\emph{\code{i915\_perf\_open\_ioctl()}}}} with the \code{drm\_i915\_private-\textgreater{}perf}.lock mutex
taken to serialize with any non-file-operation driver hooks.

\textbf{Note}

at this point the \textbf{props} have only been validated in isolation and
it's still necessary to validate that the combination of properties makes
sense.

In the case where userspace is interested in OA unit metrics then further
config validation and stream initialization details will be handled by
{\hyperref[gpu/i915:c.i915_oa_stream_init]{\emph{\code{i915\_oa\_stream\_init()}}}}. The code here should only validate config state that
will be relevant to all stream types / backends.

\textbf{Return}

zero on success or a negative error code.
\index{i915\_perf\_destroy\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_destroy_locked}\pysiglinewithargsret{void \bfcode{i915\_perf\_destroy\_locked}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}}{}
destroy an i915 perf stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915 perf stream

\end{description}

\textbf{Description}

Frees all resources associated with the given i915 perf \textbf{stream}, disabling
any associated data capture in the process.

\textbf{Note}

The \code{drm\_i915\_private-\textgreater{}perf}.lock mutex has been taken to serialize
with any non-file-operation driver hooks.
\index{i915\_perf\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_read}\pysiglinewithargsret{ssize\_t \bfcode{i915\_perf\_read}}{struct file *\emph{ file}, char \_\_user *\emph{ buf}, size\_t\emph{ count}, loff\_t *\emph{ ppos}}{}
handles \code{read()} FOP for i915 perf stream FDs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * file}}] \leavevmode
An i915 perf stream file

\item[{\code{char \_\_user * buf}}] \leavevmode
destination buffer given by userspace

\item[{\code{size\_t count}}] \leavevmode
the number of bytes userspace wants to read

\item[{\code{loff\_t * ppos}}] \leavevmode
(inout) file seek position (unused)

\end{description}

\textbf{Description}

The entry point for handling a \code{read()} on a stream file descriptor from
userspace. Most of the work is left to the {\hyperref[gpu/i915:c.i915_perf_read_locked]{\emph{\code{i915\_perf\_read\_locked()}}}} and
{\hyperref[gpu/i915:c.i915_perf_stream_ops]{\emph{\code{i915\_perf\_stream\_ops-\textgreater{}read}}}} but to save having stream implementations (of
which we might have multiple later) we handle blocking read here.

We can also consistently treat trying to read from a disabled stream
as an IO error so implementations can assume the stream is enabled
while reading.

\textbf{Return}

The number of bytes copied or a negative error code on failure.
\index{i915\_perf\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_ioctl}\pysiglinewithargsret{long \bfcode{i915\_perf\_ioctl}}{struct file *\emph{ file}, unsigned int\emph{ cmd}, unsigned long\emph{ arg}}{}
support \code{ioctl()} usage with i915 perf stream FDs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * file}}] \leavevmode
An i915 perf stream file

\item[{\code{unsigned int cmd}}] \leavevmode
the ioctl request

\item[{\code{unsigned long arg}}] \leavevmode
the ioctl data

\end{description}

\textbf{Description}

Implementation deferred to {\hyperref[gpu/i915:c.i915_perf_ioctl_locked]{\emph{\code{i915\_perf\_ioctl\_locked()}}}}.

\textbf{Return}

zero on success or a negative error code. Returns -EINVAL for
an unknown ioctl request.
\index{i915\_perf\_enable\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_enable_locked}\pysiglinewithargsret{void \bfcode{i915\_perf\_enable\_locked}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}}{}
handle \emph{I915\_PERF\_IOCTL\_ENABLE} ioctl

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
A disabled i915 perf stream

\end{description}

\textbf{Description}

{[}Re{]}enables the associated capture of data for this stream.

If a stream was previously enabled then there's currently no intention
to provide userspace any guarantee about the preservation of previously
buffered data.
\index{i915\_perf\_disable\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_disable_locked}\pysiglinewithargsret{void \bfcode{i915\_perf\_disable\_locked}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}}{}
handle \emph{I915\_PERF\_IOCTL\_DISABLE} ioctl

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An enabled i915 perf stream

\end{description}

\textbf{Description}

Disables the associated capture of data for this stream.

The intention is that disabling an re-enabling a stream will ideally be
cheaper than destroying and re-opening a stream with the same configuration,
though there are no formal guarantees about what state or buffered data
must be retained between disabling and re-enabling a stream.

\textbf{Note}

while a stream is disabled it's considered an error for userspace
to attempt to read from the stream (-EIO).
\index{i915\_perf\_poll (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_poll}\pysiglinewithargsret{\_\_poll\_t \bfcode{i915\_perf\_poll}}{struct file *\emph{ file}, poll\_table *\emph{ wait}}{}
call \code{poll\_wait()} with a suitable wait queue for stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * file}}] \leavevmode
An i915 perf stream file

\item[{\code{poll\_table * wait}}] \leavevmode
\code{poll()} state table

\end{description}

\textbf{Description}

For handling userspace polling on an i915 perf stream, this ensures
\code{poll\_wait()} gets called with a wait queue that will be woken for new stream
data.

\textbf{Note}

Implementation deferred to {\hyperref[gpu/i915:c.i915_perf_poll_locked]{\emph{\code{i915\_perf\_poll\_locked()}}}}

\textbf{Return}

any poll events that are ready without sleeping
\index{i915\_perf\_poll\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_poll_locked}\pysiglinewithargsret{\_\_poll\_t \bfcode{i915\_perf\_poll\_locked}}{struct drm\_i915\_private *\emph{ dev\_priv}, struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}, struct file *\emph{ file}, poll\_table *\emph{ wait}}{}
\code{poll\_wait()} with a suitable wait queue for stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915 perf stream

\item[{\code{struct file * file}}] \leavevmode
An i915 perf stream file

\item[{\code{poll\_table * wait}}] \leavevmode
\code{poll()} state table

\end{description}

\textbf{Description}

For handling userspace polling on an i915 perf stream, this calls through to
{\hyperref[gpu/i915:c.i915_perf_stream_ops]{\emph{\code{i915\_perf\_stream\_ops-\textgreater{}poll\_wait}}}} to call \code{poll\_wait()} with a wait queue that
will be woken for new stream data.

\textbf{Note}

The \code{drm\_i915\_private-\textgreater{}perf}.lock mutex has been taken to serialize
with any non-file-operation driver hooks.

\textbf{Return}

any poll events that are ready without sleeping


\subsection{i915 Perf Observation Architecture Stream}
\label{gpu/i915:i915-perf-observation-architecture-stream}\index{i915\_oa\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_oa_ops}\pysigline{struct \bfcode{i915\_oa\_ops}}
Gen specific implementation of an OA unit stream

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct i915\PYGZus{}oa\PYGZus{}ops \PYGZob{}
  bool (*is\PYGZus{}valid\PYGZus{}b\PYGZus{}counter\PYGZus{}reg)(struct drm\PYGZus{}i915\PYGZus{}private *dev\PYGZus{}priv, u32 addr);
  bool (*is\PYGZus{}valid\PYGZus{}mux\PYGZus{}reg)(struct drm\PYGZus{}i915\PYGZus{}private *dev\PYGZus{}priv, u32 addr);
  bool (*is\PYGZus{}valid\PYGZus{}flex\PYGZus{}reg)(struct drm\PYGZus{}i915\PYGZus{}private *dev\PYGZus{}priv, u32 addr);
  void (*init\PYGZus{}oa\PYGZus{}buffer)(struct drm\PYGZus{}i915\PYGZus{}private *dev\PYGZus{}priv);
  int (*enable\PYGZus{}metric\PYGZus{}set)(struct drm\PYGZus{}i915\PYGZus{}private *dev\PYGZus{}priv, const struct i915\PYGZus{}oa\PYGZus{}config *oa\PYGZus{}config);
  void (*disable\PYGZus{}metric\PYGZus{}set)(struct drm\PYGZus{}i915\PYGZus{}private *dev\PYGZus{}priv);
  void (*oa\PYGZus{}enable)(struct drm\PYGZus{}i915\PYGZus{}private *dev\PYGZus{}priv);
  void (*oa\PYGZus{}disable)(struct drm\PYGZus{}i915\PYGZus{}private *dev\PYGZus{}priv);
  int (*read)(struct i915\PYGZus{}perf\PYGZus{}stream *stream,char \PYGZus{}\PYGZus{}user *buf,size\PYGZus{}t count, size\PYGZus{}t *offset);
  u32 (*oa\PYGZus{}hw\PYGZus{}tail\PYGZus{}read)(struct drm\PYGZus{}i915\PYGZus{}private *dev\PYGZus{}priv);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{is\_valid\_b\_counter\_reg}}] \leavevmode
Validates register's address for
programming boolean counters for a particular platform.

\item[{\code{is\_valid\_mux\_reg}}] \leavevmode
Validates register's address for programming mux
for a particular platform.

\item[{\code{is\_valid\_flex\_reg}}] \leavevmode
Validates register's address for programming
flex EU filtering for a particular platform.

\item[{\code{init\_oa\_buffer}}] \leavevmode
Resets the head and tail pointers of the
circular buffer for periodic OA reports.

Called when first opening a stream for OA metrics, but also may be
called in response to an OA buffer overflow or other error
condition.

Note it may be necessary to clear the full OA buffer here as part of
maintaining the invariable that new reports must be written to
zeroed memory for us to be able to reliable detect if an expected
report has not yet landed in memory.  (At least on Haswell the OA
buffer tail pointer is not synchronized with reports being visible
to the CPU)

\item[{\code{enable\_metric\_set}}] \leavevmode
Selects and applies any MUX configuration to set
up the Boolean and Custom (B/C) counters that are part of the
counter reports being sampled. May apply system constraints such as
disabling EU clock gating as required.

\item[{\code{disable\_metric\_set}}] \leavevmode
Remove system constraints associated with using
the OA unit.

\item[{\code{oa\_enable}}] \leavevmode
Enable periodic sampling

\item[{\code{oa\_disable}}] \leavevmode
Disable periodic sampling

\item[{\code{read}}] \leavevmode
Copy data from the circular OA buffer into a given userspace
buffer.

\item[{\code{oa\_hw\_tail\_read}}] \leavevmode
read the OA tail pointer register

In particular this enables us to share all the fiddly code for
handling the OA unit tail pointer race that affects multiple
generations.

\end{description}
\index{i915\_oa\_stream\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_oa_stream_init}\pysiglinewithargsret{int \bfcode{i915\_oa\_stream\_init}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}, struct drm\_i915\_perf\_open\_param *\emph{ param}, struct {\hyperref[gpu/i915:c.perf_open_properties]{\emph{perf\_open\_properties}}} *\emph{ props}}{}
validate combined props for OA stream and init

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915 perf stream

\item[{\code{struct drm\_i915\_perf\_open\_param * param}}] \leavevmode
The open parameters passed to \emph{DRM\_I915\_PERF\_OPEN}

\item[{\code{struct perf\_open\_properties * props}}] \leavevmode
The property state that configures stream (individually validated)

\end{description}

\textbf{Description}

While {\hyperref[gpu/i915:c.read_properties_unlocked]{\emph{\code{read\_properties\_unlocked()}}}} validates properties in isolation it
doesn't ensure that the combination necessarily makes sense.

At this point it has been determined that userspace wants a stream of
OA metrics, but still we need to further validate the combined
properties are OK.

If the configuration makes sense then we can allocate memory for
a circular OA buffer and apply the requested metric set configuration.

\textbf{Return}

zero on success or a negative error code.
\index{i915\_oa\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_oa_read}\pysiglinewithargsret{int \bfcode{i915\_oa\_read}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}, char \_\_user *\emph{ buf}, size\_t\emph{ count}, size\_t *\emph{ offset}}{}
just calls through to {\hyperref[gpu/i915:c.i915_oa_ops]{\emph{\code{i915\_oa\_ops-\textgreater{}read}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915-perf stream opened for OA metrics

\item[{\code{char \_\_user * buf}}] \leavevmode
destination buffer given by userspace

\item[{\code{size\_t count}}] \leavevmode
the number of bytes userspace wants to read

\item[{\code{size\_t * offset}}] \leavevmode
(inout): the current position for writing into \textbf{buf}

\end{description}

\textbf{Description}

Updates \textbf{offset} according to the number of bytes successfully copied into
the userspace buffer.

\textbf{Return}

zero on success or a negative error code
\index{i915\_oa\_stream\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_oa_stream_enable}\pysiglinewithargsret{void \bfcode{i915\_oa\_stream\_enable}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}}{}
handle \emph{I915\_PERF\_IOCTL\_ENABLE} for OA stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915 perf stream opened for OA metrics

\end{description}

\textbf{Description}

{[}Re{]}enables hardware periodic sampling according to the period configured
when opening the stream. This also starts a hrtimer that will periodically
check for data in the circular OA buffer for notifying userspace (e.g.
during a \code{read()} or \code{poll()}).
\index{i915\_oa\_stream\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_oa_stream_disable}\pysiglinewithargsret{void \bfcode{i915\_oa\_stream\_disable}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}}{}
handle \emph{I915\_PERF\_IOCTL\_DISABLE} for OA stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915 perf stream opened for OA metrics

\end{description}

\textbf{Description}

Stops the OA unit from periodically writing counter reports into the
circular OA buffer. This also stops the hrtimer that periodically checks for
data in the circular OA buffer, for notifying userspace.
\index{i915\_oa\_wait\_unlocked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_oa_wait_unlocked}\pysiglinewithargsret{int \bfcode{i915\_oa\_wait\_unlocked}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}}{}
handles blocking IO until OA data available

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915-perf stream opened for OA metrics

\end{description}

\textbf{Description}

Called when userspace tries to \code{read()} from a blocking stream FD opened
for OA metrics. It waits until the hrtimer callback finds a non-empty
OA buffer and wakes us.

\textbf{Note}

it's acceptable to have this return with some false positives
since any subsequent read handling will return -EAGAIN if there isn't
really data ready for userspace yet.

\textbf{Return}

zero on success or a negative error code
\index{i915\_oa\_poll\_wait (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_oa_poll_wait}\pysiglinewithargsret{void \bfcode{i915\_oa\_poll\_wait}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}, struct file *\emph{ file}, poll\_table *\emph{ wait}}{}
call \code{poll\_wait()} for an OA stream \code{poll()}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915-perf stream opened for OA metrics

\item[{\code{struct file * file}}] \leavevmode
An i915 perf stream file

\item[{\code{poll\_table * wait}}] \leavevmode
\code{poll()} state table

\end{description}

\textbf{Description}

For handling userspace polling on an i915 perf stream opened for OA metrics,
this starts a poll\_wait with the wait queue that our hrtimer callback wakes
when it sees data ready to read in the circular OA buffer.


\subsection{All i915 Perf Internals}
\label{gpu/i915:all-i915-perf-internals}
This section simply includes all currently documented i915 perf internals, in
no particular order, but may include some more minor utilities or platform
specific details than found in the more high-level sections.
\index{perf\_open\_properties (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.perf_open_properties}\pysigline{struct \bfcode{perf\_open\_properties}}
for validated properties given to open a stream

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct perf\PYGZus{}open\PYGZus{}properties \PYGZob{}
  u32 sample\PYGZus{}flags;
  u64 single\PYGZus{}context:1;
  u64 ctx\PYGZus{}handle;
  int metrics\PYGZus{}set;
  int oa\PYGZus{}format;
  bool oa\PYGZus{}periodic;
  int oa\PYGZus{}period\PYGZus{}exponent;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{sample\_flags}}] \leavevmode
\emph{DRM\_I915\_PERF\_PROP\_SAMPLE\_*} properties are tracked as flags

\item[{\code{single\_context}}] \leavevmode
Whether a single or all gpu contexts should be monitored

\item[{\code{ctx\_handle}}] \leavevmode
A gem ctx handle for use with \textbf{single\_context}

\item[{\code{metrics\_set}}] \leavevmode
An ID for an OA unit metric set advertised via sysfs

\item[{\code{oa\_format}}] \leavevmode
An OA unit HW report format

\item[{\code{oa\_periodic}}] \leavevmode
Whether to enable periodic OA unit sampling

\item[{\code{oa\_period\_exponent}}] \leavevmode
The OA unit sampling period is derived from this

\end{description}

\textbf{Description}

As {\hyperref[gpu/i915:c.read_properties_unlocked]{\emph{\code{read\_properties\_unlocked()}}}} enumerates and validates the properties given
to open a stream of metrics the configuration is built up in the structure
which starts out zero initialized.
\index{oa\_buffer\_check\_unlocked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.oa_buffer_check_unlocked}\pysiglinewithargsret{bool \bfcode{oa\_buffer\_check\_unlocked}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
check for data and update tail ptr state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

This is either called via fops (for blocking reads in user ctx) or the poll
check hrtimer (atomic ctx) to check the OA buffer tail pointer and check
if there is data available for userspace to read.

This function is central to providing a workaround for the OA unit tail
pointer having a race with respect to what data is visible to the CPU.
It is responsible for reading tail pointers from the hardware and giving
the pointers time to `age' before they are made available for reading.
(See description of OA\_TAIL\_MARGIN\_NSEC above for further details.)

Besides returning true when there is data available to \code{read()} this function
also has the side effect of updating the oa\_buffer.tails{[}{]}, .aging\_timestamp
and .aged\_tail\_idx state used for reading.

\textbf{Note}

It's safe to read OA config state here unlocked, assuming that this is
only called while the stream is enabled, while the global OA configuration
can't be modified.

\textbf{Return}

\code{true} if the OA buffer contains data, else \code{false}
\index{append\_oa\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.append_oa_status}\pysiglinewithargsret{int \bfcode{append\_oa\_status}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}, char \_\_user *\emph{ buf}, size\_t\emph{ count}, size\_t *\emph{ offset}, enum drm\_i915\_perf\_record\_type\emph{ type}}{}
Appends a status record to a userspace \code{read()} buffer.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915-perf stream opened for OA metrics

\item[{\code{char \_\_user * buf}}] \leavevmode
destination buffer given by userspace

\item[{\code{size\_t count}}] \leavevmode
the number of bytes userspace wants to read

\item[{\code{size\_t * offset}}] \leavevmode
(inout): the current position for writing into \textbf{buf}

\item[{\code{enum drm\_i915\_perf\_record\_type type}}] \leavevmode
The kind of status to report to userspace

\end{description}

\textbf{Description}

Writes a status record (such as \emph{DRM\_I915\_PERF\_RECORD\_OA\_REPORT\_LOST})
into the userspace \code{read()} buffer.

The \textbf{buf} \textbf{offset} will only be updated on success.

\textbf{Return}

0 on success, negative error code on failure.
\index{append\_oa\_sample (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.append_oa_sample}\pysiglinewithargsret{int \bfcode{append\_oa\_sample}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}, char \_\_user *\emph{ buf}, size\_t\emph{ count}, size\_t *\emph{ offset}, const u8 *\emph{ report}}{}
Copies single OA report into userspace \code{read()} buffer.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915-perf stream opened for OA metrics

\item[{\code{char \_\_user * buf}}] \leavevmode
destination buffer given by userspace

\item[{\code{size\_t count}}] \leavevmode
the number of bytes userspace wants to read

\item[{\code{size\_t * offset}}] \leavevmode
(inout): the current position for writing into \textbf{buf}

\item[{\code{const u8 * report}}] \leavevmode
A single OA report to (optionally) include as part of the sample

\end{description}

\textbf{Description}

The contents of a sample are configured through \emph{DRM\_I915\_PERF\_PROP\_SAMPLE\_*}
properties when opening a stream, tracked as \emph{stream-\textgreater{}sample\_flags}. This
function copies the requested components of a single sample to the given
\code{read()} \textbf{buf}.

The \textbf{buf} \textbf{offset} will only be updated on success.

\textbf{Return}

0 on success, negative error code on failure.
\index{gen8\_append\_oa\_reports (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.gen8_append_oa_reports}\pysiglinewithargsret{int \bfcode{gen8\_append\_oa\_reports}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}, char \_\_user *\emph{ buf}, size\_t\emph{ count}, size\_t *\emph{ offset}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915-perf stream opened for OA metrics

\item[{\code{char \_\_user * buf}}] \leavevmode
destination buffer given by userspace

\item[{\code{size\_t count}}] \leavevmode
the number of bytes userspace wants to read

\item[{\code{size\_t * offset}}] \leavevmode
(inout): the current position for writing into \textbf{buf}

\end{description}

\textbf{Description}

Notably any error condition resulting in a short read (-\code{ENOSPC} or
-\code{EFAULT}) will be returned even though one or more records may
have been successfully copied. In this case it's up to the caller
to decide if the error should be squashed before returning to
userspace.

\textbf{Note}

reports are consumed from the head, and appended to the
tail, so the tail chases the head?... If you think that's mad
and back-to-front you're not alone, but this follows the
Gen PRM naming convention.

\textbf{Return}

0 on success, negative error code on failure.
\index{gen8\_oa\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.gen8_oa_read}\pysiglinewithargsret{int \bfcode{gen8\_oa\_read}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}, char \_\_user *\emph{ buf}, size\_t\emph{ count}, size\_t *\emph{ offset}}{}
copy status records then buffered OA reports

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915-perf stream opened for OA metrics

\item[{\code{char \_\_user * buf}}] \leavevmode
destination buffer given by userspace

\item[{\code{size\_t count}}] \leavevmode
the number of bytes userspace wants to read

\item[{\code{size\_t * offset}}] \leavevmode
(inout): the current position for writing into \textbf{buf}

\end{description}

\textbf{Description}

Checks OA unit status registers and if necessary appends corresponding
status records for userspace (such as for a buffer full condition) and then
initiate appending any buffered OA reports.

Updates \textbf{offset} according to the number of bytes successfully copied into
the userspace buffer.

NB: some data may be successfully copied to the userspace buffer
even if an error is returned, and this is reflected in the
updated \textbf{offset}.

\textbf{Return}

zero on success or a negative error code
\index{gen7\_append\_oa\_reports (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.gen7_append_oa_reports}\pysiglinewithargsret{int \bfcode{gen7\_append\_oa\_reports}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}, char \_\_user *\emph{ buf}, size\_t\emph{ count}, size\_t *\emph{ offset}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915-perf stream opened for OA metrics

\item[{\code{char \_\_user * buf}}] \leavevmode
destination buffer given by userspace

\item[{\code{size\_t count}}] \leavevmode
the number of bytes userspace wants to read

\item[{\code{size\_t * offset}}] \leavevmode
(inout): the current position for writing into \textbf{buf}

\end{description}

\textbf{Description}

Notably any error condition resulting in a short read (-\code{ENOSPC} or
-\code{EFAULT}) will be returned even though one or more records may
have been successfully copied. In this case it's up to the caller
to decide if the error should be squashed before returning to
userspace.

\textbf{Note}

reports are consumed from the head, and appended to the
tail, so the tail chases the head?... If you think that's mad
and back-to-front you're not alone, but this follows the
Gen PRM naming convention.

\textbf{Return}

0 on success, negative error code on failure.
\index{gen7\_oa\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.gen7_oa_read}\pysiglinewithargsret{int \bfcode{gen7\_oa\_read}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}, char \_\_user *\emph{ buf}, size\_t\emph{ count}, size\_t *\emph{ offset}}{}
copy status records then buffered OA reports

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915-perf stream opened for OA metrics

\item[{\code{char \_\_user * buf}}] \leavevmode
destination buffer given by userspace

\item[{\code{size\_t count}}] \leavevmode
the number of bytes userspace wants to read

\item[{\code{size\_t * offset}}] \leavevmode
(inout): the current position for writing into \textbf{buf}

\end{description}

\textbf{Description}

Checks Gen 7 specific OA unit status registers and if necessary appends
corresponding status records for userspace (such as for a buffer full
condition) and then initiate appending any buffered OA reports.

Updates \textbf{offset} according to the number of bytes successfully copied into
the userspace buffer.

\textbf{Return}

zero on success or a negative error code
\index{i915\_oa\_wait\_unlocked (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{int \bfcode{i915\_oa\_wait\_unlocked}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}}{}
handles blocking IO until OA data available

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915-perf stream opened for OA metrics

\end{description}

\textbf{Description}

Called when userspace tries to \code{read()} from a blocking stream FD opened
for OA metrics. It waits until the hrtimer callback finds a non-empty
OA buffer and wakes us.

\textbf{Note}

it's acceptable to have this return with some false positives
since any subsequent read handling will return -EAGAIN if there isn't
really data ready for userspace yet.

\textbf{Return}

zero on success or a negative error code
\index{i915\_oa\_poll\_wait (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{void \bfcode{i915\_oa\_poll\_wait}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}, struct file *\emph{ file}, poll\_table *\emph{ wait}}{}
call \code{poll\_wait()} for an OA stream \code{poll()}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915-perf stream opened for OA metrics

\item[{\code{struct file * file}}] \leavevmode
An i915 perf stream file

\item[{\code{poll\_table * wait}}] \leavevmode
\code{poll()} state table

\end{description}

\textbf{Description}

For handling userspace polling on an i915 perf stream opened for OA metrics,
this starts a poll\_wait with the wait queue that our hrtimer callback wakes
when it sees data ready to read in the circular OA buffer.
\index{i915\_oa\_read (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{int \bfcode{i915\_oa\_read}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}, char \_\_user *\emph{ buf}, size\_t\emph{ count}, size\_t *\emph{ offset}}{}
just calls through to {\hyperref[gpu/i915:c.i915_oa_ops]{\emph{\code{i915\_oa\_ops-\textgreater{}read}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915-perf stream opened for OA metrics

\item[{\code{char \_\_user * buf}}] \leavevmode
destination buffer given by userspace

\item[{\code{size\_t count}}] \leavevmode
the number of bytes userspace wants to read

\item[{\code{size\_t * offset}}] \leavevmode
(inout): the current position for writing into \textbf{buf}

\end{description}

\textbf{Description}

Updates \textbf{offset} according to the number of bytes successfully copied into
the userspace buffer.

\textbf{Return}

zero on success or a negative error code
\index{oa\_get\_render\_ctx\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.oa_get_render_ctx_id}\pysiglinewithargsret{int \bfcode{oa\_get\_render\_ctx\_id}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}}{}
determine and hold ctx hw id

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915-perf stream opened for OA metrics

\end{description}

\textbf{Description}

Determine the render context hw id, and ensure it remains fixed for the
lifetime of the stream. This ensures that we don't have to worry about
updating the context ID in OACONTROL on the fly.

\textbf{Return}

zero on success or a negative error code
\index{oa\_put\_render\_ctx\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.oa_put_render_ctx_id}\pysiglinewithargsret{void \bfcode{oa\_put\_render\_ctx\_id}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}}{}
counterpart to oa\_get\_render\_ctx\_id releases hold

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915-perf stream opened for OA metrics

\end{description}

\textbf{Description}

In case anything needed doing to ensure the context HW ID would remain valid
for the lifetime of the stream, then that can be undone here.
\index{i915\_oa\_stream\_enable (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{void \bfcode{i915\_oa\_stream\_enable}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}}{}
handle \emph{I915\_PERF\_IOCTL\_ENABLE} for OA stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915 perf stream opened for OA metrics

\end{description}

\textbf{Description}

{[}Re{]}enables hardware periodic sampling according to the period configured
when opening the stream. This also starts a hrtimer that will periodically
check for data in the circular OA buffer for notifying userspace (e.g.
during a \code{read()} or \code{poll()}).
\index{i915\_oa\_stream\_disable (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{void \bfcode{i915\_oa\_stream\_disable}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}}{}
handle \emph{I915\_PERF\_IOCTL\_DISABLE} for OA stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915 perf stream opened for OA metrics

\end{description}

\textbf{Description}

Stops the OA unit from periodically writing counter reports into the
circular OA buffer. This also stops the hrtimer that periodically checks for
data in the circular OA buffer, for notifying userspace.
\index{i915\_oa\_stream\_init (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{int \bfcode{i915\_oa\_stream\_init}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}, struct drm\_i915\_perf\_open\_param *\emph{ param}, struct {\hyperref[gpu/i915:c.perf_open_properties]{\emph{perf\_open\_properties}}} *\emph{ props}}{}
validate combined props for OA stream and init

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915 perf stream

\item[{\code{struct drm\_i915\_perf\_open\_param * param}}] \leavevmode
The open parameters passed to \emph{DRM\_I915\_PERF\_OPEN}

\item[{\code{struct perf\_open\_properties * props}}] \leavevmode
The property state that configures stream (individually validated)

\end{description}

\textbf{Description}

While {\hyperref[gpu/i915:c.read_properties_unlocked]{\emph{\code{read\_properties\_unlocked()}}}} validates properties in isolation it
doesn't ensure that the combination necessarily makes sense.

At this point it has been determined that userspace wants a stream of
OA metrics, but still we need to further validate the combined
properties are OK.

If the configuration makes sense then we can allocate memory for
a circular OA buffer and apply the requested metric set configuration.

\textbf{Return}

zero on success or a negative error code.
\index{i915\_perf\_read\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_read_locked}\pysiglinewithargsret{ssize\_t \bfcode{i915\_perf\_read\_locked}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}, struct file *\emph{ file}, char \_\_user *\emph{ buf}, size\_t\emph{ count}, loff\_t *\emph{ ppos}}{}
{\hyperref[gpu/i915:c.i915_perf_stream_ops]{\emph{\code{i915\_perf\_stream\_ops-\textgreater{}read}}}} with error normalisation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915 perf stream

\item[{\code{struct file * file}}] \leavevmode
An i915 perf stream file

\item[{\code{char \_\_user * buf}}] \leavevmode
destination buffer given by userspace

\item[{\code{size\_t count}}] \leavevmode
the number of bytes userspace wants to read

\item[{\code{loff\_t * ppos}}] \leavevmode
(inout) file seek position (unused)

\end{description}

\textbf{Description}

Besides wrapping {\hyperref[gpu/i915:c.i915_perf_stream_ops]{\emph{\code{i915\_perf\_stream\_ops-\textgreater{}read}}}} this provides a common place to
ensure that if we've successfully copied any data then reporting that takes
precedence over any internal error status, so the data isn't lost.

For example ret will be -ENOSPC whenever there is more buffered data than
can be copied to userspace, but that's only interesting if we weren't able
to copy some data because it implies the userspace buffer is too small to
receive a single record (and we never split records).

Another case with ret == -EFAULT is more of a grey area since it would seem
like bad form for userspace to ask us to overrun its buffer, but the user
knows best:
\begin{quote}

\href{http://yarchive.net/comp/linux/partial\_reads\_writes.html}{http://yarchive.net/comp/linux/partial\_reads\_writes.html}
\end{quote}

\textbf{Return}

The number of bytes copied or a negative error code on failure.
\index{i915\_perf\_read (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{ssize\_t \bfcode{i915\_perf\_read}}{struct file *\emph{ file}, char \_\_user *\emph{ buf}, size\_t\emph{ count}, loff\_t *\emph{ ppos}}{}
handles \code{read()} FOP for i915 perf stream FDs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * file}}] \leavevmode
An i915 perf stream file

\item[{\code{char \_\_user * buf}}] \leavevmode
destination buffer given by userspace

\item[{\code{size\_t count}}] \leavevmode
the number of bytes userspace wants to read

\item[{\code{loff\_t * ppos}}] \leavevmode
(inout) file seek position (unused)

\end{description}

\textbf{Description}

The entry point for handling a \code{read()} on a stream file descriptor from
userspace. Most of the work is left to the {\hyperref[gpu/i915:c.i915_perf_read_locked]{\emph{\code{i915\_perf\_read\_locked()}}}} and
{\hyperref[gpu/i915:c.i915_perf_stream_ops]{\emph{\code{i915\_perf\_stream\_ops-\textgreater{}read}}}} but to save having stream implementations (of
which we might have multiple later) we handle blocking read here.

We can also consistently treat trying to read from a disabled stream
as an IO error so implementations can assume the stream is enabled
while reading.

\textbf{Return}

The number of bytes copied or a negative error code on failure.
\index{i915\_perf\_poll\_locked (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{\_\_poll\_t \bfcode{i915\_perf\_poll\_locked}}{struct drm\_i915\_private *\emph{ dev\_priv}, struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}, struct file *\emph{ file}, poll\_table *\emph{ wait}}{}
\code{poll\_wait()} with a suitable wait queue for stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915 perf stream

\item[{\code{struct file * file}}] \leavevmode
An i915 perf stream file

\item[{\code{poll\_table * wait}}] \leavevmode
\code{poll()} state table

\end{description}

\textbf{Description}

For handling userspace polling on an i915 perf stream, this calls through to
{\hyperref[gpu/i915:c.i915_perf_stream_ops]{\emph{\code{i915\_perf\_stream\_ops-\textgreater{}poll\_wait}}}} to call \code{poll\_wait()} with a wait queue that
will be woken for new stream data.

\textbf{Note}

The \code{drm\_i915\_private-\textgreater{}perf}.lock mutex has been taken to serialize
with any non-file-operation driver hooks.

\textbf{Return}

any poll events that are ready without sleeping
\index{i915\_perf\_poll (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{\_\_poll\_t \bfcode{i915\_perf\_poll}}{struct file *\emph{ file}, poll\_table *\emph{ wait}}{}
call \code{poll\_wait()} with a suitable wait queue for stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * file}}] \leavevmode
An i915 perf stream file

\item[{\code{poll\_table * wait}}] \leavevmode
\code{poll()} state table

\end{description}

\textbf{Description}

For handling userspace polling on an i915 perf stream, this ensures
\code{poll\_wait()} gets called with a wait queue that will be woken for new stream
data.

\textbf{Note}

Implementation deferred to {\hyperref[gpu/i915:c.i915_perf_poll_locked]{\emph{\code{i915\_perf\_poll\_locked()}}}}

\textbf{Return}

any poll events that are ready without sleeping
\index{i915\_perf\_enable\_locked (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{void \bfcode{i915\_perf\_enable\_locked}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}}{}
handle \emph{I915\_PERF\_IOCTL\_ENABLE} ioctl

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
A disabled i915 perf stream

\end{description}

\textbf{Description}

{[}Re{]}enables the associated capture of data for this stream.

If a stream was previously enabled then there's currently no intention
to provide userspace any guarantee about the preservation of previously
buffered data.
\index{i915\_perf\_disable\_locked (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{void \bfcode{i915\_perf\_disable\_locked}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}}{}
handle \emph{I915\_PERF\_IOCTL\_DISABLE} ioctl

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An enabled i915 perf stream

\end{description}

\textbf{Description}

Disables the associated capture of data for this stream.

The intention is that disabling an re-enabling a stream will ideally be
cheaper than destroying and re-opening a stream with the same configuration,
though there are no formal guarantees about what state or buffered data
must be retained between disabling and re-enabling a stream.

\textbf{Note}

while a stream is disabled it's considered an error for userspace
to attempt to read from the stream (-EIO).
\index{i915\_perf\_ioctl\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/i915:c.i915_perf_ioctl_locked}\pysiglinewithargsret{long \bfcode{i915\_perf\_ioctl\_locked}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}, unsigned int\emph{ cmd}, unsigned long\emph{ arg}}{}
support \code{ioctl()} usage with i915 perf stream FDs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915 perf stream

\item[{\code{unsigned int cmd}}] \leavevmode
the ioctl request

\item[{\code{unsigned long arg}}] \leavevmode
the ioctl data

\end{description}

\textbf{Note}

The \code{drm\_i915\_private-\textgreater{}perf}.lock mutex has been taken to serialize
with any non-file-operation driver hooks.

\textbf{Return}

zero on success or a negative error code. Returns -EINVAL for
an unknown ioctl request.
\index{i915\_perf\_ioctl (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{long \bfcode{i915\_perf\_ioctl}}{struct file *\emph{ file}, unsigned int\emph{ cmd}, unsigned long\emph{ arg}}{}
support \code{ioctl()} usage with i915 perf stream FDs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * file}}] \leavevmode
An i915 perf stream file

\item[{\code{unsigned int cmd}}] \leavevmode
the ioctl request

\item[{\code{unsigned long arg}}] \leavevmode
the ioctl data

\end{description}

\textbf{Description}

Implementation deferred to {\hyperref[gpu/i915:c.i915_perf_ioctl_locked]{\emph{\code{i915\_perf\_ioctl\_locked()}}}}.

\textbf{Return}

zero on success or a negative error code. Returns -EINVAL for
an unknown ioctl request.
\index{i915\_perf\_destroy\_locked (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{void \bfcode{i915\_perf\_destroy\_locked}}{struct {\hyperref[gpu/i915:c.i915_perf_stream]{\emph{i915\_perf\_stream}}} *\emph{ stream}}{}
destroy an i915 perf stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i915\_perf\_stream * stream}}] \leavevmode
An i915 perf stream

\end{description}

\textbf{Description}

Frees all resources associated with the given i915 perf \textbf{stream}, disabling
any associated data capture in the process.

\textbf{Note}

The \code{drm\_i915\_private-\textgreater{}perf}.lock mutex has been taken to serialize
with any non-file-operation driver hooks.
\index{i915\_perf\_release (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{int \bfcode{i915\_perf\_release}}{struct inode *\emph{ inode}, struct file *\emph{ file}}{}
handles userspace \code{close()} of a stream file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
anonymous inode associated with file

\item[{\code{struct file * file}}] \leavevmode
An i915 perf stream file

\end{description}

\textbf{Description}

Cleans up any resources associated with an open i915 perf stream file.

NB: \code{close()} can't really fail from the userspace point of view.

\textbf{Return}

zero on success or a negative error code.
\index{i915\_perf\_open\_ioctl\_locked (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{int \bfcode{i915\_perf\_open\_ioctl\_locked}}{struct drm\_i915\_private *\emph{ dev\_priv}, struct drm\_i915\_perf\_open\_param *\emph{ param}, struct {\hyperref[gpu/i915:c.perf_open_properties]{\emph{perf\_open\_properties}}} *\emph{ props}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file}}{}
DRM \code{ioctl()} for userspace to open a stream FD

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{struct drm\_i915\_perf\_open\_param * param}}] \leavevmode
The open parameters passed to `DRM\_I915\_PERF\_OPEN{}`

\item[{\code{struct perf\_open\_properties * props}}] \leavevmode
individually validated u64 property value pairs

\item[{\code{struct drm\_file * file}}] \leavevmode
drm file

\end{description}

\textbf{Description}

See \code{i915\_perf\_ioctl\_open()} for interface details.

Implements further stream config validation and stream initialization on
behalf of {\hyperref[gpu/i915:c.i915_perf_open_ioctl]{\emph{\code{i915\_perf\_open\_ioctl()}}}} with the \code{drm\_i915\_private-\textgreater{}perf}.lock mutex
taken to serialize with any non-file-operation driver hooks.

\textbf{Note}

at this point the \textbf{props} have only been validated in isolation and
it's still necessary to validate that the combination of properties makes
sense.

In the case where userspace is interested in OA unit metrics then further
config validation and stream initialization details will be handled by
{\hyperref[gpu/i915:c.i915_oa_stream_init]{\emph{\code{i915\_oa\_stream\_init()}}}}. The code here should only validate config state that
will be relevant to all stream types / backends.

\textbf{Return}

zero on success or a negative error code.
\index{read\_properties\_unlocked (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{int \bfcode{read\_properties\_unlocked}}{struct drm\_i915\_private *\emph{ dev\_priv}, u64 \_\_user *\emph{ uprops}, u32\emph{ n\_props}, struct {\hyperref[gpu/i915:c.perf_open_properties]{\emph{perf\_open\_properties}}} *\emph{ props}}{}
validate + copy userspace stream open properties

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\item[{\code{u64 \_\_user * uprops}}] \leavevmode
The array of u64 key value pairs given by userspace

\item[{\code{u32 n\_props}}] \leavevmode
The number of key value pairs expected in \textbf{uprops}

\item[{\code{struct perf\_open\_properties * props}}] \leavevmode
The stream configuration built up while validating properties

\end{description}

\textbf{Description}

Note this function only validates properties in isolation it doesn't
validate that the combination of properties makes sense or that all
properties necessary for a particular kind of stream have been set.

Note that there currently aren't any ordering requirements for properties so
we shouldn't validate or assume anything about ordering here. This doesn't
rule out defining new properties with ordering requirements in the future.
\index{i915\_perf\_open\_ioctl (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{int \bfcode{i915\_perf\_open\_ioctl}}{struct drm\_device *\emph{ dev}, void *\emph{ data}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file}}{}
DRM \code{ioctl()} for userspace to open a stream FD

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{void * data}}] \leavevmode
ioctl data copied from userspace (unvalidated)

\item[{\code{struct drm\_file * file}}] \leavevmode
drm file

\end{description}

\textbf{Description}

Validates the stream open parameters given by userspace including flags
and an array of u64 key, value pair properties.

Very little is assumed up front about the nature of the stream being
opened (for instance we don't assume it's for periodic OA unit metrics). An
i915-perf stream is expected to be a suitable interface for other forms of
buffered data written by the GPU besides periodic OA metrics.

Note we copy the properties from userspace outside of the i915 perf
mutex to avoid an awkward lockdep with mmap\_sem.

Most of the implementation details are handled by
{\hyperref[gpu/i915:c.i915_perf_open_ioctl_locked]{\emph{\code{i915\_perf\_open\_ioctl\_locked()}}}} after taking the \code{drm\_i915\_private-\textgreater{}perf}.lock
mutex for serializing with any non-file-operation driver hooks.

\textbf{Return}

A newly opened i915 Perf stream file descriptor or negative
error code on failure.
\index{i915\_perf\_register (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{void \bfcode{i915\_perf\_register}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
exposes i915-perf to userspace

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

In particular OA metric sets are advertised under a sysfs metrics/
directory allowing userspace to enumerate valid IDs that can be
used to open an i915-perf stream.
\index{i915\_perf\_unregister (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{void \bfcode{i915\_perf\_unregister}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
hide i915-perf from userspace

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

i915-perf state cleanup is split up into an `unregister' and
`deinit' phase where the interface is first hidden from
userspace by {\hyperref[gpu/i915:c.i915_perf_unregister]{\emph{\code{i915\_perf\_unregister()}}}} before cleaning up
remaining state in {\hyperref[gpu/i915:c.i915_perf_fini]{\emph{\code{i915\_perf\_fini()}}}}.
\index{i915\_perf\_add\_config\_ioctl (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{int \bfcode{i915\_perf\_add\_config\_ioctl}}{struct drm\_device *\emph{ dev}, void *\emph{ data}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file}}{}
DRM \code{ioctl()} for userspace to add a new OA config

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{void * data}}] \leavevmode
ioctl data (pointer to struct drm\_i915\_perf\_oa\_config) copied from
userspace (unvalidated)

\item[{\code{struct drm\_file * file}}] \leavevmode
drm file

\end{description}

\textbf{Description}

Validates the submitted OA register to be saved into a new OA config that
can then be used for programming the OA unit and its NOA network.

\textbf{Return}

A new allocated config number to be used with the perf open ioctl
or a negative error code on failure.
\index{i915\_perf\_remove\_config\_ioctl (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{int \bfcode{i915\_perf\_remove\_config\_ioctl}}{struct drm\_device *\emph{ dev}, void *\emph{ data}, struct {\hyperref[gpu/drm\string-internals:c.drm_file]{\emph{drm\_file}}} *\emph{ file}}{}
DRM \code{ioctl()} for userspace to remove an OA config

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * dev}}] \leavevmode
drm device

\item[{\code{void * data}}] \leavevmode
ioctl data (pointer to u64 integer) copied from userspace

\item[{\code{struct drm\_file * file}}] \leavevmode
drm file

\end{description}

\textbf{Description}

Configs can be removed while being used, the will stop appearing in sysfs
and their content will be freed when the stream using the config is closed.

\textbf{Return}

0 on success or a negative error code on failure.
\index{i915\_perf\_init (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{void \bfcode{i915\_perf\_init}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
initialize i915-perf state on module load

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}

\textbf{Description}

Initializes i915-perf state without exposing anything to userspace.

\textbf{Note}

i915-perf initialization is split into an `init' and `register'
phase with the {\hyperref[gpu/i915:c.i915_perf_register]{\emph{\code{i915\_perf\_register()}}}} exposing state to userspace.
\index{i915\_perf\_fini (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{void \bfcode{i915\_perf\_fini}}{struct drm\_i915\_private *\emph{ dev\_priv}}{}
Counter part to {\hyperref[gpu/i915:c.i915_perf_init]{\emph{\code{i915\_perf\_init()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_i915\_private * dev\_priv}}] \leavevmode
i915 device instance

\end{description}


\section{Style}
\label{gpu/i915:style}
The drm/i915 driver codebase has some style rules in addition to (and, in some
cases, deviating from) the kernel coding style.


\subsection{Register macro definition style}
\label{gpu/i915:register-macro-definition-style}
The style guide for \code{i915\_reg.h}.

Follow the style described here for new macros, and while changing existing
macros. Do \textbf{not} mass change existing definitions just to update the style.


\subsubsection{Layout}
\label{gpu/i915:layout}
Keep helper macros near the top. For example, \code{\_PIPE()} and friends.

Prefix macros that generally should not be used outside of this file with
underscore `\_'. For example, \code{\_PIPE()} and friends, single instances of
registers that are defined solely for the use by function-like macros.

Avoid using the underscore prefixed macros outside of this file. There are
exceptions, but keep them to a minimum.

There are two basic types of register definitions: Single registers and
register groups. Register groups are registers which have two or more
instances, for example one per pipe, port, transcoder, etc. Register groups
should be defined using function-like macros.

For single registers, define the register offset first, followed by register
contents.

For register groups, define the register instance offsets first, prefixed
with underscore, followed by a function-like macro choosing the right
instance based on the parameter, followed by register contents.

Define the register contents (i.e. bit and bit field macros) from most
significant to least significant bit. Indent the register content macros
using two extra spaces between \code{\#define} and the macro name.

For bit fields, define a \code{\_MASK} and a \code{\_SHIFT} macro. Define bit field
contents so that they are already shifted in place, and can be directly
OR'd. For convenience, function-like macros may be used to define bit fields,
but do note that the macros may be needed to read as well as write the
register contents.

Define bits using \code{(1 \textless{}\textless{} N)} instead of \code{BIT(N)}. We may change this in
the future, but this is the prevailing style. Do \textbf{not} add \code{\_BIT} suffix
to the name.

Group the register and its contents together without blank lines, separate
from other registers and their contents with one blank line.

Indent macro values from macro names using TABs. Align values vertically. Use
braces in macro values as needed to avoid unintended precedence after macro
substitution. Use spaces in macro values according to kernel coding
style. Use lower case in hexadecimal values.


\subsubsection{Naming}
\label{gpu/i915:naming}
Try to name registers according to the specs. If the register name changes in
the specs from platform to another, stick to the original name.

Try to re-use existing register macro definitions. Only add new macros for
new register offsets, or when the register contents have changed enough to
warrant a full redefinition.

When a register macro changes for a new platform, prefix the new macro using
the platform acronym or generation. For example, \code{SKL\_} or \code{GEN8\_}. The
prefix signifies the start platform/generation using the register.

When a bit (field) macro changes or gets added for a new platform, while
retaining the existing register macro, add a platform acronym or generation
suffix to the name. For example, \code{\_SKL} or \code{\_GEN8}.


\subsubsection{Examples}
\label{gpu/i915:examples}
(Note that the values in the example are indented using spaces instead of
TABs to avoid misalignment in generated documentation. Use TABs in the
definitions.):

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}define \PYGZus{}FOO\PYGZus{}A                      0xf000
\PYGZsh{}define \PYGZus{}FOO\PYGZus{}B                      0xf001
\PYGZsh{}define FOO(pipe)                   \PYGZus{}MMIO\PYGZus{}PIPE(pipe, \PYGZus{}FOO\PYGZus{}A, \PYGZus{}FOO\PYGZus{}B)
\PYGZsh{}define   FOO\PYGZus{}ENABLE                (1 \PYGZlt{}\PYGZlt{} 31)
\PYGZsh{}define   FOO\PYGZus{}MODE\PYGZus{}MASK             (0xf \PYGZlt{}\PYGZlt{} 16)
\PYGZsh{}define   FOO\PYGZus{}MODE\PYGZus{}SHIFT            16
\PYGZsh{}define   FOO\PYGZus{}MODE\PYGZus{}BAR              (0 \PYGZlt{}\PYGZlt{} 16)
\PYGZsh{}define   FOO\PYGZus{}MODE\PYGZus{}BAZ              (1 \PYGZlt{}\PYGZlt{} 16)
\PYGZsh{}define   FOO\PYGZus{}MODE\PYGZus{}QUX\PYGZus{}SNB          (2 \PYGZlt{}\PYGZlt{} 16)

\PYGZsh{}define BAR                         \PYGZus{}MMIO(0xb000)
\PYGZsh{}define GEN8\PYGZus{}BAR                    \PYGZus{}MMIO(0xb888)
\end{Verbatim}


\chapter{drm/meson AmLogic Meson Video Processing Unit}
\label{gpu/meson:drm-meson-amlogic-meson-video-processing-unit}\label{gpu/meson::doc}
VPU Handles the Global Video Processing, it includes management of the
clocks gates, blocks reset lines and power domains.

What is missing :
\begin{itemize}
\item {} 
Full reset of entire video processing HW blocks

\item {} 
Scaling and setup of the VPU clock

\item {} 
Bus clock gates

\item {} 
Powering up video processing HW blocks

\item {} 
Powering Up HDMI controller and PHY

\end{itemize}


\section{Video Processing Unit}
\label{gpu/meson:video-processing-unit}
The Amlogic Meson Display controller is composed of several components
that are going to be documented below:

\begin{Verbatim}[commandchars=\\\{\}]
DMC\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}VPU (Video Processing Unit)\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}HHI\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
   \textbar{} vd1   \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}     \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}    \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}     \textbar{}               \textbar{}
D  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}      \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}            \textbar{}   \textbar{}                \textbar{}    \textbar{}   HDMI PLL    \textbar{}
D  \textbar{} vd2   \textbar{} VIU  \textbar{}    \textbar{} Video Post \textbar{}   \textbar{} Video Encoders \textbar{}\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}VCLK      \textbar{}
R  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}      \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{} Processing \textbar{}   \textbar{}                \textbar{}    \textbar{}               \textbar{}
   \textbar{} osd2  \textbar{}      \textbar{}    \textbar{}            \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{} Enci \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}VDAC\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
R  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{} CSC  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{} Scalers    \textbar{}   \textbar{} Encp \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}HDMI\PYGZhy{}TX\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
A  \textbar{} osd1  \textbar{}      \textbar{}    \textbar{} Blenders   \textbar{}   \textbar{} Encl \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
M  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}   \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}    \textbar{}               \textbar{}
\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}
\end{Verbatim}


\section{Video Input Unit}
\label{gpu/meson:video-input-unit}
VIU Handles the Pixel scanout and the basic Colorspace conversions
We handle the following features :
\begin{itemize}
\item {} 
OSD1 RGB565/RGB888/xRGB8888 scanout

\item {} 
RGB conversion to x/cb/cr

\item {} 
Progressive or Interlace buffer scanout

\item {} 
OSD1 Commit on Vsync

\item {} 
HDR OSD matrix for GXL/GXM

\end{itemize}

What is missing :
\begin{itemize}
\item {} 
BGR888/xBGR8888/BGRx8888/BGRx8888 modes

\item {} 
YUV4:2:2 Y0CbY1Cr scanout

\item {} 
Conversion to YUV 4:4:4 from 4:2:2 input

\item {} 
Colorkey Alpha matching

\item {} 
Big endian scanout

\item {} 
X/Y reverse scanout

\item {} 
Global alpha setup

\item {} 
OSD2 support, would need interlace switching on vsync

\item {} 
OSD1 full scaling to support TV overscan

\end{itemize}


\section{Video Post Processing}
\label{gpu/meson:video-post-processing}
VPP Handles all the Post Processing after the Scanout from the VIU
We handle the following post processings :
\begin{itemize}
\item {} \begin{description}
\item[{Postblend, Blends the OSD1 only}] \leavevmode
We exclude OSD2, VS1, VS1 and Preblend output

\end{description}

\item {} \begin{description}
\item[{Vertical OSD Scaler for OSD1 only, we disable vertical scaler and}] \leavevmode
use it only for interlace scanout

\end{description}

\item {} 
Intermediate FIFO with default Amlogic values

\end{itemize}

What is missing :
\begin{itemize}
\item {} 
Preblend for video overlay pre-scaling

\item {} 
OSD2 support for cursor framebuffer

\item {} 
Video pre-scaling before postblend

\item {} 
Full Vertical/Horizontal OSD scaling to support TV overscan

\item {} 
HDR conversion

\end{itemize}


\section{Video Encoder}
\label{gpu/meson:video-encoder}
VENC Handle the pixels encoding to the output formats.
We handle the following encodings :
\begin{itemize}
\item {} 
CVBS Encoding via the ENCI encoder and VDAC digital to analog converter

\item {} 
TMDS/HDMI Encoding via ENCI\_DIV and ENCP

\item {} 
Setup of more clock rates for HDMI modes

\end{itemize}

What is missing :
\begin{itemize}
\item {} 
LCD Panel encoding via ENCL

\item {} 
TV Panel encoding via ENCT

\end{itemize}

VENC paths :

\begin{Verbatim}[commandchars=\\\{\}]
       \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}   \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}   \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
vd1\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\textbar{}     \textbar{} \textbar{} VENC     /\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}VDAC
vd2\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{} VIU \textbar{}\PYGZhy{}\textbar{} VPP \textbar{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}ENCI/\PYGZhy{}ENCI\PYGZus{}DVI\PYGZhy{}\textbar{}\PYGZhy{}\textbar{}
osd1\PYGZhy{}\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\textbar{}     \textbar{} \textbar{} \PYGZbs{}                  \textbar{} X\PYGZhy{}\PYGZhy{}HDMI\PYGZhy{}TX
osd2\PYGZhy{}\PYGZhy{}\textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}\PYGZhy{}\textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{} \textbar{}  \textbar{}\PYGZbs{}\PYGZhy{}ENCP\PYGZhy{}\PYGZhy{}ENCP\PYGZus{}DVI\PYGZhy{}\textbar{}\PYGZhy{}\textbar{}
                      \textbar{}  \textbar{}                 \textbar{}
                      \textbar{}  \PYGZbs{}\PYGZhy{}\PYGZhy{}ENCL\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}LVDS
                      \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}
\end{Verbatim}

The ENCI is designed for PAl or NTSC encoding and can go through the VDAC
directly for CVBS encoding or through the ENCI\_DVI encoder for HDMI.
The ENCP is designed for Progressive encoding but can also generate
1080i interlaced pixels, and was initialy desined to encode pixels for
VDAC to output RGB ou YUV analog outputs.
It's output is only used through the ENCP\_DVI encoder for HDMI.
The ENCL LVDS encoder is not implemented.

The ENCI and ENCP encoders needs specially defined parameters for each
supported mode and thus cannot be determined from standard video timings.

The ENCI end ENCP DVI encoders are more generic and can generate any timings
from the pixel data generated by ENCI or ENCP, so can use the standard video
timings are source for HW parameters.


\section{Video Canvas Management}
\label{gpu/meson:video-canvas-management}
CANVAS is a memory zone where physical memory frames information
are stored for the VIU to scanout.


\section{Video Clocks}
\label{gpu/meson:video-clocks}
VCLK is the ``Pixel Clock'' frequency generator from a dedicated PLL.
We handle the following encodings :
\begin{itemize}
\item {} 
CVBS 27MHz generator via the VCLK2 to the VENCI and VDAC blocks

\item {} 
HDMI Pixel Clocks generation

\end{itemize}

What is missing :
\begin{itemize}
\item {} 
Genenate Pixel clocks for 2K/4K 10bit formats

\end{itemize}

Clock generator scheme :

\begin{Verbatim}[commandchars=\\\{\}]
 \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}   \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}            \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
\textbar{}          \textbar{} \textbar{}         \textbar{}          \textbar{}     \textbar{}\PYGZhy{}\PYGZhy{}ENCI
\textbar{} HDMI PLL \textbar{}\PYGZhy{}\textbar{} PLL\PYGZus{}DIV \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{} VCLK\PYGZhy{}\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\PYGZhy{}ENCL
\textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{} \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{} \PYGZbs{}        \textbar{} MUX \textbar{}\PYGZhy{}\PYGZhy{}ENCP
                          \PYGZhy{}\PYGZhy{}VCLK2\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\PYGZhy{}VDAC
                                  \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}\PYGZhy{}\PYGZhy{}HDMI\PYGZhy{}TX
\end{Verbatim}

Final clocks can take input for either VCLK or VCLK2, but
VCLK is the preferred path for HDMI clocking and VCLK2 is the
preferred path for CVBS VDAC clocking.

VCLK and VCLK2 have fixed divided clocks paths for /1, /2, /4, /6 or /12.

The PLL\_DIV can achieve an additional fractional dividing like
1.5, 3.5, 3.75... to generate special 2K and 4K 10bit clocks.


\section{HDMI Video Output}
\label{gpu/meson:hdmi-video-output}
HDMI Output is composed of :
\begin{itemize}
\item {} 
A Synopsys DesignWare HDMI Controller IP

\item {} 
A TOP control block controlling the Clocks and PHY

\item {} 
A custom HDMI PHY in order convert video to TMDS signal

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
 \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
\textbar{}            HDMI TOP               \textbar{}\PYGZlt{}= HPD
\textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}
\textbar{}                  \textbar{}                \textbar{}
\textbar{}  Synopsys HDMI   \textbar{}   HDMI PHY     \textbar{}=\PYGZgt{} TMDS
\textbar{}    Controller    \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}
\textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}\PYGZlt{}=\PYGZgt{} DDC
\end{Verbatim}

The HDMI TOP block only supports HPD sensing.
The Synopsys HDMI Controller interrupt is routed
through the TOP Block interrupt.
Communication to the TOP Block and the Synopsys
HDMI Controller is done a pair of addr+read/write
registers.
The HDMI PHY is configured by registers in the
HHI register block.

Pixel data arrives in 4:4:4 format from the VENC
block and the VPU HDMI mux selects either the ENCI
encoder for the 576i or 480i formats or the ENCP
encoder for all the other formats including
interlaced HD formats.
The VENC uses a DVI encoder on top of the ENCI
or ENCP encoders to generate DVI timings for the
HDMI controller.

GXBB, GXL and GXM embeds the Synopsys DesignWare
HDMI TX IP version 2.01a with HDCP and I2C \& S/PDIF
audio source interfaces.

We handle the following features :
\begin{itemize}
\item {} 
HPD Rise \& Fall interrupt

\item {} 
HDMI Controller Interrupt

\item {} 
HDMI PHY Init for 480i to 1080p60

\item {} 
VENC \& HDMI Clock setup for 480i to 1080p60

\item {} 
VENC Mode setup for 480i to 1080p60

\end{itemize}

What is missing :
\begin{itemize}
\item {} 
PHY, Clock and Mode setup for 2k \&\& 4k modes

\item {} 
SDDC Scrambling mode for HDMI 2.0a

\item {} 
HDCP Setup

\item {} 
CEC Management

\end{itemize}


\chapter{drm/pl111 ARM PrimeCell PL111 CLCD Driver}
\label{gpu/pl111::doc}\label{gpu/pl111:drm-pl111-arm-primecell-pl111-clcd-driver}
The PL111 is a simple LCD controller that can support TFT and STN
displays.  This driver exposes a standard KMS interface for them.

This driver uses the same Device Tree binding as the fbdev CLCD
driver.  While the fbdev driver supports panels that may be
connected to the CLCD internally to the CLCD driver, in DRM the
panels get split out to drivers/gpu/drm/panels/.  This means that,
in converting from using fbdev to using DRM, you also need to write
a panel driver (which may be as simple as an entry in
panel-simple.c).

The driver currently doesn't expose the cursor.  The DRM API for
cursors requires support for 64x64 ARGB8888 cursor images, while
the hardware can only support 64x64 monochrome with masking
cursors.  While one could imagine trying to hack something together
to look at the ARGB8888 and program reasonable in monochrome, we
just don't expose the cursor at all instead, and leave cursor
support to the X11 software cursor layer.

TODO:
\begin{itemize}
\item {} 
Fix race between setting plane base address and getting IRQ for
vsync firing the pageflip completion.

\item {} 
Use the ``max-memory-bandwidth'' DT property to filter the
supported formats.

\item {} 
Read back hardware state at boot to skip reprogramming the
hardware when doing a no-op modeset.

\item {} 
Use the CLKSEL bit to support switching between the two external
clock parents.

\end{itemize}


\chapter{drm/tegra NVIDIA Tegra GPU and display driver}
\label{gpu/tegra::doc}\label{gpu/tegra:drm-tegra-nvidia-tegra-gpu-and-display-driver}
NVIDIA Tegra SoCs support a set of display, graphics and video functions via
the host1x controller. host1x supplies command streams, gathered from a push
buffer provided directly by the CPU, to its clients via channels. Software,
or blocks amongst themselves, can use syncpoints for synchronization.

Up until, but not including, Tegra124 (aka Tegra K1) the drm/tegra driver
supports the built-in GPU, comprised of the gr2d and gr3d engines. Starting
with Tegra124 the GPU is based on the NVIDIA desktop GPU architecture and
supported by the drm/nouveau driver.

The drm/tegra driver supports NVIDIA Tegra SoC generations since Tegra20. It
has three parts:
\begin{itemize}
\item {} 
A host1x driver that provides infrastructure and access to the host1x
services.

\item {} 
A KMS driver that supports the display controllers as well as a number of
outputs, such as RGB, HDMI, DSI, and DisplayPort.

\item {} 
A set of custom userspace IOCTLs that can be used to submit jobs to the
GPU and video engines via host1x.

\end{itemize}


\section{Driver Infrastructure}
\label{gpu/tegra:driver-infrastructure}
The various host1x clients need to be bound together into a logical device in
order to expose their functionality to users. The infrastructure that supports
this is implemented in the host1x driver. When a driver is registered with the
infrastructure it provides a list of compatible strings specifying the devices
that it needs. The infrastructure creates a logical device and scan the device
tree for matching device nodes, adding the required clients to a list. Drivers
for individual clients register with the infrastructure as well and are added
to the logical host1x device.

Once all clients are available, the infrastructure will initialize the logical
device using a driver-provided function which will set up the bits specific to
the subsystem and in turn initialize each of its clients.

Similarly, when one of the clients is unregistered, the infrastructure will
destroy the logical device by calling back into the driver, which ensures that
the subsystem specific bits are torn down and the clients destroyed in turn.


\subsection{Host1x Infrastructure Reference}
\label{gpu/tegra:host1x-infrastructure-reference}\index{host1x\_client\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_client_ops}\pysigline{struct \bfcode{host1x\_client\_ops}}
host1x client operations

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct host1x\PYGZus{}client\PYGZus{}ops \PYGZob{}
  int (*init)(struct host1x\PYGZus{}client *client);
  int (*exit)(struct host1x\PYGZus{}client *client);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{init}}] \leavevmode
host1x client initialization code

\item[{\code{exit}}] \leavevmode
host1x client tear down code

\end{description}
\index{host1x\_client (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_client}\pysigline{struct \bfcode{host1x\_client}}
host1x client structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct host1x\PYGZus{}client \PYGZob{}
  struct list\PYGZus{}head list;
  struct device *parent;
  struct device *dev;
  const struct host1x\PYGZus{}client\PYGZus{}ops *ops;
  enum host1x\PYGZus{}class class;
  struct host1x\PYGZus{}channel *channel;
  struct host1x\PYGZus{}syncpt **syncpts;
  unsigned int num\PYGZus{}syncpts;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{list}}] \leavevmode
list node for the host1x client

\item[{\code{parent}}] \leavevmode
pointer to struct device representing the host1x controller

\item[{\code{dev}}] \leavevmode
pointer to struct device backing this host1x client

\item[{\code{ops}}] \leavevmode
host1x client operations

\item[{\code{class}}] \leavevmode
host1x class represented by this client

\item[{\code{channel}}] \leavevmode
host1x channel associated with this client

\item[{\code{syncpts}}] \leavevmode
array of syncpoints requested for this client

\item[{\code{num\_syncpts}}] \leavevmode
number of syncpoints requested for this client

\end{description}
\index{host1x\_driver (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_driver}\pysigline{struct \bfcode{host1x\_driver}}
host1x logical device driver

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct host1x\PYGZus{}driver \PYGZob{}
  struct device\PYGZus{}driver driver;
  const struct of\PYGZus{}device\PYGZus{}id *subdevs;
  struct list\PYGZus{}head list;
  int (*probe)(struct host1x\PYGZus{}device *device);
  int (*remove)(struct host1x\PYGZus{}device *device);
  void (*shutdown)(struct host1x\PYGZus{}device *device);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{driver}}] \leavevmode
core driver

\item[{\code{subdevs}}] \leavevmode
table of OF device IDs matching subdevices for this driver

\item[{\code{list}}] \leavevmode
list node for the driver

\item[{\code{probe}}] \leavevmode
called when the host1x logical device is probed

\item[{\code{remove}}] \leavevmode
called when the host1x logical device is removed

\item[{\code{shutdown}}] \leavevmode
called when the host1x logical device is shut down

\end{description}
\index{host1x\_device\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_device_init}\pysiglinewithargsret{int \bfcode{host1x\_device\_init}}{struct host1x\_device *\emph{ device}}{}
initialize a host1x logical device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x\_device * device}}] \leavevmode
host1x logical device

\end{description}

\textbf{Description}

The driver for the host1x logical device can call this during execution of
its {\hyperref[gpu/tegra:c.host1x_driver]{\emph{\code{host1x\_driver.probe}}}} implementation to initialize each of its clients.
The client drivers access the subsystem specific driver data using the
{\hyperref[gpu/tegra:c.host1x_client]{\emph{\code{host1x\_client.parent}}}} field and driver data associated with it (usually by
calling \code{dev\_get\_drvdata()}).
\index{host1x\_device\_exit (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_device_exit}\pysiglinewithargsret{int \bfcode{host1x\_device\_exit}}{struct host1x\_device *\emph{ device}}{}
uninitialize host1x logical device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x\_device * device}}] \leavevmode
host1x logical device

\end{description}

\textbf{Description}

When the driver for a host1x logical device is unloaded, it can call this
function to tear down each of its clients. Typically this is done after a
subsystem-specific data structure is removed and the functionality can no
longer be used.
\index{host1x\_driver\_register\_full (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_driver_register_full}\pysiglinewithargsret{int \bfcode{host1x\_driver\_register\_full}}{struct {\hyperref[gpu/tegra:c.host1x_driver]{\emph{host1x\_driver}}} *\emph{ driver}, struct module *\emph{ owner}}{}
register a host1x driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x\_driver * driver}}] \leavevmode
host1x driver

\item[{\code{struct module * owner}}] \leavevmode
owner module

\end{description}

\textbf{Description}

Drivers for host1x logical devices call this function to register a driver
with the infrastructure. Note that since these drive logical devices, the
registration of the driver actually triggers tho logical device creation.
A logical device will be created for each host1x instance.
\index{host1x\_driver\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_driver_unregister}\pysiglinewithargsret{void \bfcode{host1x\_driver\_unregister}}{struct {\hyperref[gpu/tegra:c.host1x_driver]{\emph{host1x\_driver}}} *\emph{ driver}}{}
unregister a host1x driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x\_driver * driver}}] \leavevmode
host1x driver

\end{description}

\textbf{Description}

Unbinds the driver from each of the host1x logical devices that it is
bound to, effectively removing the subsystem devices that they represent.
\index{host1x\_client\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_client_register}\pysiglinewithargsret{int \bfcode{host1x\_client\_register}}{struct {\hyperref[gpu/tegra:c.host1x_client]{\emph{host1x\_client}}} *\emph{ client}}{}
register a host1x client

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x\_client * client}}] \leavevmode
host1x client

\end{description}

\textbf{Description}

Registers a host1x client with each host1x controller instance. Note that
each client will only match their parent host1x controller and will only be
associated with that instance. Once all clients have been registered with
their parent host1x controller, the infrastructure will set up the logical
device and call {\hyperref[gpu/tegra:c.host1x_device_init]{\emph{\code{host1x\_device\_init()}}}}, which will in turn call each client's
{\hyperref[gpu/tegra:c.host1x_client_ops]{\emph{\code{host1x\_client\_ops.init}}}} implementation.
\index{host1x\_client\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_client_unregister}\pysiglinewithargsret{int \bfcode{host1x\_client\_unregister}}{struct {\hyperref[gpu/tegra:c.host1x_client]{\emph{host1x\_client}}} *\emph{ client}}{}
unregister a host1x client

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x\_client * client}}] \leavevmode
host1x client

\end{description}

\textbf{Description}

Removes a host1x client from its host1x controller instance. If a logical
device has already been initialized, it will be torn down.


\subsection{Host1x Syncpoint Reference}
\label{gpu/tegra:host1x-syncpoint-reference}\index{host1x\_syncpt\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_syncpt_id}\pysiglinewithargsret{u32 \bfcode{host1x\_syncpt\_id}}{struct host1x\_syncpt *\emph{ sp}}{}
retrieve syncpoint ID

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x\_syncpt * sp}}] \leavevmode
host1x syncpoint

\end{description}

\textbf{Description}

Given a pointer to a struct host1x\_syncpt, retrieves its ID. This ID is
often used as a value to program into registers that control how hardware
blocks interact with syncpoints.
\index{host1x\_syncpt\_incr\_max (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_syncpt_incr_max}\pysiglinewithargsret{u32 \bfcode{host1x\_syncpt\_incr\_max}}{struct host1x\_syncpt *\emph{ sp}, u32\emph{ incrs}}{}
update the value sent to hardware

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x\_syncpt * sp}}] \leavevmode
host1x syncpoint

\item[{\code{u32 incrs}}] \leavevmode
number of increments

\end{description}
\index{host1x\_syncpt\_incr (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_syncpt_incr}\pysiglinewithargsret{int \bfcode{host1x\_syncpt\_incr}}{struct host1x\_syncpt *\emph{ sp}}{}
increment syncpoint value from CPU, updating cache

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x\_syncpt * sp}}] \leavevmode
host1x syncpoint

\end{description}
\index{host1x\_syncpt\_wait (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_syncpt_wait}\pysiglinewithargsret{int \bfcode{host1x\_syncpt\_wait}}{struct host1x\_syncpt *\emph{ sp}, u32\emph{ thresh}, long\emph{ timeout}, u32 *\emph{ value}}{}
wait for a syncpoint to reach a given value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x\_syncpt * sp}}] \leavevmode
host1x syncpoint

\item[{\code{u32 thresh}}] \leavevmode
threshold

\item[{\code{long timeout}}] \leavevmode
maximum time to wait for the syncpoint to reach the given value

\item[{\code{u32 * value}}] \leavevmode
return location for the syncpoint value

\end{description}
\index{host1x\_syncpt\_request (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_syncpt_request}\pysiglinewithargsret{struct host1x\_syncpt * \bfcode{host1x\_syncpt\_request}}{struct {\hyperref[gpu/tegra:c.host1x_client]{\emph{host1x\_client}}} *\emph{ client}, unsigned long\emph{ flags}}{}
request a syncpoint

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x\_client * client}}] \leavevmode
client requesting the syncpoint

\item[{\code{unsigned long flags}}] \leavevmode
flags

\end{description}

\textbf{Description}

host1x client drivers can use this function to allocate a syncpoint for
subsequent use. A syncpoint returned by this function will be reserved for
use by the client exclusively. When no longer using a syncpoint, a host1x
client driver needs to release it using {\hyperref[gpu/tegra:c.host1x_syncpt_free]{\emph{\code{host1x\_syncpt\_free()}}}}.
\index{host1x\_syncpt\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_syncpt_free}\pysiglinewithargsret{void \bfcode{host1x\_syncpt\_free}}{struct host1x\_syncpt *\emph{ sp}}{}
free a requested syncpoint

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x\_syncpt * sp}}] \leavevmode
host1x syncpoint

\end{description}

\textbf{Description}

Release a syncpoint previously allocated using {\hyperref[gpu/tegra:c.host1x_syncpt_request]{\emph{\code{host1x\_syncpt\_request()}}}}. A
host1x client driver should call this when the syncpoint is no longer in
use. Note that client drivers must ensure that the syncpoint doesn't remain
under the control of hardware after calling this function, otherwise two
clients may end up trying to access the same syncpoint concurrently.
\index{host1x\_syncpt\_read\_max (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_syncpt_read_max}\pysiglinewithargsret{u32 \bfcode{host1x\_syncpt\_read\_max}}{struct host1x\_syncpt *\emph{ sp}}{}
read maximum syncpoint value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x\_syncpt * sp}}] \leavevmode
host1x syncpoint

\end{description}

\textbf{Description}

The maximum syncpoint value indicates how many operations there are in
queue, either in channel or in a software thread.
\index{host1x\_syncpt\_read\_min (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_syncpt_read_min}\pysiglinewithargsret{u32 \bfcode{host1x\_syncpt\_read\_min}}{struct host1x\_syncpt *\emph{ sp}}{}
read minimum syncpoint value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x\_syncpt * sp}}] \leavevmode
host1x syncpoint

\end{description}

\textbf{Description}

The minimum syncpoint value is a shadow of the current sync point value in
hardware.
\index{host1x\_syncpt\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_syncpt_read}\pysiglinewithargsret{u32 \bfcode{host1x\_syncpt\_read}}{struct host1x\_syncpt *\emph{ sp}}{}
read the current syncpoint value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x\_syncpt * sp}}] \leavevmode
host1x syncpoint

\end{description}
\index{host1x\_syncpt\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_syncpt_get}\pysiglinewithargsret{struct host1x\_syncpt * \bfcode{host1x\_syncpt\_get}}{struct host1x *\emph{ host}, unsigned int\emph{ id}}{}
obtain a syncpoint by ID

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x * host}}] \leavevmode
host1x controller

\item[{\code{unsigned int id}}] \leavevmode
syncpoint ID

\end{description}
\index{host1x\_syncpt\_get\_base (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_syncpt_get_base}\pysiglinewithargsret{struct host1x\_syncpt\_base * \bfcode{host1x\_syncpt\_get\_base}}{struct host1x\_syncpt *\emph{ sp}}{}
obtain the wait base associated with a syncpoint

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x\_syncpt * sp}}] \leavevmode
host1x syncpoint

\end{description}
\index{host1x\_syncpt\_base\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tegra:c.host1x_syncpt_base_id}\pysiglinewithargsret{u32 \bfcode{host1x\_syncpt\_base\_id}}{struct host1x\_syncpt\_base *\emph{ base}}{}
retrieve the ID of a syncpoint wait base

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct host1x\_syncpt\_base * base}}] \leavevmode
host1x syncpoint wait base

\end{description}


\section{KMS driver}
\label{gpu/tegra:kms-driver}
The display hardware has remained mostly backwards compatible over the various
Tegra SoC generations, up until Tegra186 which introduces several changes that
make it difficult to support with a parameterized driver.


\subsection{Display Controllers}
\label{gpu/tegra:display-controllers}
Tegra SoCs have two display controllers, each of which can be associated with
zero or more outputs. Outputs can also share a single display controller, but
only if they run with compatible display timings. Two display controllers can
also share a single framebuffer, allowing cloned configurations even if modes
on two outputs don't match. A display controller is modelled as a CRTC in KMS
terms.

On Tegra186, the number of display controllers has been increased to three. A
display controller can no longer drive all of the outputs. While two of these
controllers can drive both DSI outputs and both SOR outputs, the third cannot
drive any DSI.


\subsubsection{Windows}
\label{gpu/tegra:windows}
A display controller controls a set of windows that can be used to composite
multiple buffers onto the screen. While it is possible to assign arbitrary Z
ordering to individual windows (by programming the corresponding blending
registers), this is currently not supported by the driver. Instead, it will
assume a fixed Z ordering of the windows (window A is the root window, that
is, the lowest, while windows B and C are overlaid on top of window A). The
overlay windows support multiple pixel formats and can automatically convert
from YUV to RGB at scanout time. This makes them useful for displaying video
content. In KMS, each window is modelled as a plane. Each display controller
has a hardware cursor that is exposed as a cursor plane.


\subsection{Outputs}
\label{gpu/tegra:outputs}
The type and number of supported outputs varies between Tegra SoC generations.
All generations support at least HDMI. While earlier generations supported the
very simple RGB interfaces (one per display controller), recent generations no
longer do and instead provide standard interfaces such as DSI and eDP/DP.

Outputs are modelled as a composite encoder/connector pair.


\subsubsection{RGB/LVDS}
\label{gpu/tegra:rgb-lvds}
This interface is no longer available since Tegra124. It has been replaced by
the more standard DSI and eDP interfaces.


\subsubsection{HDMI}
\label{gpu/tegra:hdmi}
HDMI is supported on all Tegra SoCs. Starting with Tegra210, HDMI is provided
by the versatile SOR output, which supports eDP, DP and HDMI. The SOR is able
to support HDMI 2.0, though support for this is currently not merged.


\subsubsection{DSI}
\label{gpu/tegra:dsi}
Although Tegra has supported DSI since Tegra30, the controller has changed in
several ways in Tegra114. Since none of the publicly available development
boards prior to Dalmore (Tegra114) have made use of DSI, only Tegra114 and
later are supported by the drm/tegra driver.


\subsubsection{eDP/DP}
\label{gpu/tegra:edp-dp}
eDP was first introduced in Tegra124 where it was used to drive the display
panel for notebook form factors. Tegra210 added support for full DisplayPort
support, though this is currently not implemented in the drm/tegra driver.


\section{Userspace Interface}
\label{gpu/tegra:userspace-interface}
The userspace interface provided by drm/tegra allows applications to create
GEM buffers, access and control syncpoints as well as submit command streams
to host1x.


\subsection{GEM Buffers}
\label{gpu/tegra:gem-buffers}
The \code{DRM\_IOCTL\_TEGRA\_GEM\_CREATE} IOCTL is used to create a GEM buffer object
with Tegra-specific flags. This is useful for buffers that should be tiled, or
that are to be scanned out upside down (useful for 3D content).

After a GEM buffer object has been created, its memory can be mapped by an
application using the mmap offset returned by the \code{DRM\_IOCTL\_TEGRA\_GEM\_MMAP}
IOCTL.


\subsection{Syncpoints}
\label{gpu/tegra:syncpoints}
The current value of a syncpoint can be obtained by executing the
\code{DRM\_IOCTL\_TEGRA\_SYNCPT\_READ} IOCTL. Incrementing the syncpoint is achieved
using the \code{DRM\_IOCTL\_TEGRA\_SYNCPT\_INCR} IOCTL.

Userspace can also request blocking on a syncpoint. To do so, it needs to
execute the \code{DRM\_IOCTL\_TEGRA\_SYNCPT\_WAIT} IOCTL, specifying the value of
the syncpoint to wait for. The kernel will release the application when the
syncpoint reaches that value or after a specified timeout.


\subsection{Command Stream Submission}
\label{gpu/tegra:command-stream-submission}
Before an application can submit command streams to host1x it needs to open a
channel to an engine using the \code{DRM\_IOCTL\_TEGRA\_OPEN\_CHANNEL} IOCTL. Client
IDs are used to identify the target of the channel. When a channel is no
longer needed, it can be closed using the \code{DRM\_IOCTL\_TEGRA\_CLOSE\_CHANNEL}
IOCTL. To retrieve the syncpoint associated with a channel, an application
can use the \code{DRM\_IOCTL\_TEGRA\_GET\_SYNCPT}.

After opening a channel, submitting command streams is easy. The application
writes commands into the memory backing a GEM buffer object and passes these
to the \code{DRM\_IOCTL\_TEGRA\_SUBMIT} IOCTL along with various other parameters,
such as the syncpoints or relocations used in the job submission.


\chapter{drm/tinydrm Driver library}
\label{gpu/tinydrm:drm-tinydrm-driver-library}\label{gpu/tinydrm::doc}
This library provides driver helpers for very simple display hardware.

It is based on {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe]{\emph{\code{drm\_simple\_display\_pipe}}}} coupled with a {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector}}}} which
has only one fixed {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{\code{drm\_display\_mode}}}}. The framebuffers are backed by the
cma helper and have support for framebuffer flushing (dirty).
fbdev support is also included.


\section{Core functionality}
\label{gpu/tinydrm:core-functionality}
The driver allocates {\hyperref[gpu/tinydrm:c.tinydrm_device]{\emph{\code{tinydrm\_device}}}}, initializes it using
{\hyperref[gpu/tinydrm:c.devm_tinydrm_init]{\emph{\code{devm\_tinydrm\_init()}}}}, sets up the pipeline using {\hyperref[gpu/tinydrm:c.tinydrm_display_pipe_init]{\emph{\code{tinydrm\_display\_pipe\_init()}}}}
and registers the DRM device using {\hyperref[gpu/tinydrm:c.devm_tinydrm_register]{\emph{\code{devm\_tinydrm\_register()}}}}.
\index{tinydrm\_device (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_device}\pysigline{struct \bfcode{tinydrm\_device}}
tinydrm device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct tinydrm\PYGZus{}device \PYGZob{}
  struct drm\PYGZus{}device *drm;
  struct drm\PYGZus{}simple\PYGZus{}display\PYGZus{}pipe pipe;
  struct mutex dirty\PYGZus{}lock;
  const struct drm\PYGZus{}framebuffer\PYGZus{}funcs *fb\PYGZus{}funcs;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{drm}}] \leavevmode
DRM device

\item[{\code{pipe}}] \leavevmode
Display pipe structure

\item[{\code{dirty\_lock}}] \leavevmode
Serializes framebuffer flushing

\item[{\code{fb\_funcs}}] \leavevmode
Framebuffer functions used when creating framebuffers

\end{description}
\index{TINYDRM\_GEM\_DRIVER\_OPS (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.TINYDRM_GEM_DRIVER_OPS}\pysiglinewithargsret{\bfcode{TINYDRM\_GEM\_DRIVER\_OPS}}{}{}
default tinydrm gem operations

\end{fulllineitems}


\textbf{Parameters}

\textbf{Description}

This macro provides a shortcut for setting the tinydrm GEM operations in
the {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver}}}} structure.
\index{TINYDRM\_MODE (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.TINYDRM_MODE}\pysiglinewithargsret{\bfcode{TINYDRM\_MODE}}{\emph{hd}, \emph{vd}, \emph{hd\_mm}, \emph{vd\_mm}}{}
tinydrm display mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{hd}}] \leavevmode
Horizontal resolution, width

\item[{\code{vd}}] \leavevmode
Vertical resolution, height

\item[{\code{hd\_mm}}] \leavevmode
Display width in millimeters

\item[{\code{vd\_mm}}] \leavevmode
Display height in millimeters

\end{description}

\textbf{Description}

This macro creates a {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{\code{drm\_display\_mode}}}} for use with tinydrm.
\index{tinydrm\_gem\_cma\_prime\_import\_sg\_table (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_gem_cma_prime_import_sg_table}\pysiglinewithargsret{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} * \bfcode{tinydrm\_gem\_cma\_prime\_import\_sg\_table}}{struct drm\_device *\emph{ drm}, struct dma\_buf\_attachment *\emph{ attach}, struct sg\_table *\emph{ sgt}}{}
Produce a CMA GEM object from another driver's scatter/gather table of pinned pages

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_device * drm}}] \leavevmode
DRM device to import into

\item[{\code{struct dma\_buf\_attachment * attach}}] \leavevmode
DMA-BUF attachment

\item[{\code{struct sg\_table * sgt}}] \leavevmode
Scatter/gather table of pinned pages

\end{description}

\textbf{Description}

This function imports a scatter/gather table exported via DMA-BUF by
another driver using {\hyperref[gpu/drm\string-mm:c.drm_gem_cma_prime_import_sg_table]{\emph{\code{drm\_gem\_cma\_prime\_import\_sg\_table()}}}}. It sets the
kernel virtual address on the CMA object. Drivers should use this as their
{\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver-\textgreater{}gem\_prime\_import\_sg\_table}}}} callback if they need the virtual
address. {\hyperref[gpu/tinydrm:c.tinydrm_gem_cma_free_object]{\emph{\code{tinydrm\_gem\_cma\_free\_object()}}}} should be used in combination with
this function.

\textbf{Return}

A pointer to a newly created GEM object or an ERR\_PTR-encoded negative
error code on failure.
\index{tinydrm\_gem\_cma\_free\_object (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_gem_cma_free_object}\pysiglinewithargsret{void \bfcode{tinydrm\_gem\_cma\_free\_object}}{struct {\hyperref[gpu/drm\string-mm:c.drm_gem_object]{\emph{drm\_gem\_object}}} *\emph{ gem\_obj}}{}
Free resources associated with a CMA GEM object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_gem\_object * gem\_obj}}] \leavevmode
GEM object to free

\end{description}

\textbf{Description}

This function frees the backing memory of the CMA GEM object, cleans up the
GEM object state and frees the memory used to store the object itself using
{\hyperref[gpu/drm\string-mm:c.drm_gem_cma_free_object]{\emph{\code{drm\_gem\_cma\_free\_object()}}}}. It also handles PRIME buffers which has the kernel
virtual address set by {\hyperref[gpu/tinydrm:c.tinydrm_gem_cma_prime_import_sg_table]{\emph{\code{tinydrm\_gem\_cma\_prime\_import\_sg\_table()}}}}. Drivers
can use this as their {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver-\textgreater{}gem\_free\_object}}}} callback.
\index{devm\_tinydrm\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.devm_tinydrm_init}\pysiglinewithargsret{int \bfcode{devm\_tinydrm\_init}}{struct device *\emph{ parent}, struct {\hyperref[gpu/tinydrm:c.tinydrm_device]{\emph{tinydrm\_device}}} *\emph{ tdev}, const struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer_funcs]{\emph{drm\_framebuffer\_funcs}}} *\emph{ fb\_funcs}, struct {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{drm\_driver}}} *\emph{ driver}}{}
Initialize tinydrm device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * parent}}] \leavevmode
Parent device object

\item[{\code{struct tinydrm\_device * tdev}}] \leavevmode
tinydrm device

\item[{\code{const struct drm\_framebuffer\_funcs * fb\_funcs}}] \leavevmode
Framebuffer functions

\item[{\code{struct drm\_driver * driver}}] \leavevmode
DRM driver

\end{description}

\textbf{Description}

This function initializes \textbf{tdev}, the underlying DRM device and it's
mode\_config. Resources will be automatically freed on driver detach (devres)
using {\hyperref[gpu/drm\string-kms:c.drm_mode_config_cleanup]{\emph{\code{drm\_mode\_config\_cleanup()}}}} and {\hyperref[gpu/drm\string-internals:c.drm_dev_unref]{\emph{\code{drm\_dev\_unref()}}}}.

\textbf{Return}

Zero on success, negative error code on failure.
\index{devm\_tinydrm\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.devm_tinydrm_register}\pysiglinewithargsret{int \bfcode{devm\_tinydrm\_register}}{struct {\hyperref[gpu/tinydrm:c.tinydrm_device]{\emph{tinydrm\_device}}} *\emph{ tdev}}{}
Register tinydrm device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct tinydrm\_device * tdev}}] \leavevmode
tinydrm device

\end{description}

\textbf{Description}

This function registers the underlying DRM device and fbdev.
These resources will be automatically unregistered on driver detach (devres)
and the display pipeline will be disabled.

\textbf{Return}

Zero on success, negative error code on failure.
\index{tinydrm\_shutdown (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_shutdown}\pysiglinewithargsret{void \bfcode{tinydrm\_shutdown}}{struct {\hyperref[gpu/tinydrm:c.tinydrm_device]{\emph{tinydrm\_device}}} *\emph{ tdev}}{}
Shutdown tinydrm

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct tinydrm\_device * tdev}}] \leavevmode
tinydrm device

\end{description}

\textbf{Description}

This function makes sure that the display pipeline is disabled.
Used by drivers in their shutdown callback to turn off the display
on machine shutdown and reboot.
\index{tinydrm\_display\_pipe\_update (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_display_pipe_update}\pysiglinewithargsret{void \bfcode{tinydrm\_display\_pipe\_update}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe]{\emph{drm\_simple\_display\_pipe}}} *\emph{ pipe}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} *\emph{ old\_state}}{}
Display pipe update helper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_simple\_display\_pipe * pipe}}] \leavevmode
Simple display pipe

\item[{\code{struct drm\_plane\_state * old\_state}}] \leavevmode
Old plane state

\end{description}

\textbf{Description}

This function does a full framebuffer flush if the plane framebuffer
has changed. It also handles vblank events. Drivers can use this as their
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe_funcs]{\emph{\code{drm\_simple\_display\_pipe\_funcs-\textgreater{}update}}}} callback.
\index{tinydrm\_display\_pipe\_prepare\_fb (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_display_pipe_prepare_fb}\pysiglinewithargsret{int \bfcode{tinydrm\_display\_pipe\_prepare\_fb}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe]{\emph{drm\_simple\_display\_pipe}}} *\emph{ pipe}, struct {\hyperref[gpu/drm\string-kms:c.drm_plane_state]{\emph{drm\_plane\_state}}} *\emph{ plane\_state}}{}
Display pipe prepare\_fb helper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_simple\_display\_pipe * pipe}}] \leavevmode
Simple display pipe

\item[{\code{struct drm\_plane\_state * plane\_state}}] \leavevmode
Plane state

\end{description}

\textbf{Description}

This function uses {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_gem_fb_prepare_fb]{\emph{\code{drm\_gem\_fb\_prepare\_fb()}}}} to check if the plane FB has an
dma-buf attached, extracts the exclusive fence and attaches it to plane
state for the atomic helper to wait on. Drivers can use this as their
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe_funcs]{\emph{\code{drm\_simple\_display\_pipe\_funcs-\textgreater{}prepare\_fb}}}} callback.
\index{tinydrm\_display\_pipe\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_display_pipe_init}\pysiglinewithargsret{int \bfcode{tinydrm\_display\_pipe\_init}}{struct {\hyperref[gpu/tinydrm:c.tinydrm_device]{\emph{tinydrm\_device}}} *\emph{ tdev}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe_funcs]{\emph{drm\_simple\_display\_pipe\_funcs}}} *\emph{ funcs}, int\emph{ connector\_type}, const uint32\_t *\emph{ formats}, unsigned int\emph{ format\_count}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}, unsigned int\emph{ rotation}}{}
Initialize display pipe

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct tinydrm\_device * tdev}}] \leavevmode
tinydrm device

\item[{\code{const struct drm\_simple\_display\_pipe\_funcs * funcs}}] \leavevmode
Display pipe functions

\item[{\code{int connector\_type}}] \leavevmode
Connector type

\item[{\code{const uint32\_t * formats}}] \leavevmode
Array of supported formats (DRM\_FORMAT\_*)

\item[{\code{unsigned int format\_count}}] \leavevmode
Number of elements in \textbf{formats}

\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
Supported mode

\item[{\code{unsigned int rotation}}] \leavevmode
Initial \textbf{mode} rotation in degrees Counter Clock Wise

\end{description}

\textbf{Description}

This function sets up a {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe]{\emph{\code{drm\_simple\_display\_pipe}}}} with a {\hyperref[gpu/drm\string-kms:c.drm_connector]{\emph{\code{drm\_connector}}}} that
has one fixed {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{\code{drm\_display\_mode}}}} which is rotated according to \textbf{rotation}.

\textbf{Return}

Zero on success, negative error code on failure.


\section{Additional helpers}
\label{gpu/tinydrm:additional-helpers}\index{tinydrm\_machine\_little\_endian (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_machine_little_endian}\pysiglinewithargsret{bool \bfcode{tinydrm\_machine\_little\_endian}}{void}{}
Machine is little endian

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Return}

true if \emph{defined(\_\_LITTLE\_ENDIAN)}, false otherwise
\index{tinydrm\_dbg\_spi\_message (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_dbg_spi_message}\pysiglinewithargsret{void \bfcode{tinydrm\_dbg\_spi\_message}}{struct spi\_device *\emph{ spi}, struct spi\_message *\emph{ m}}{}
Dump SPI message

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
SPI device

\item[{\code{struct spi\_message * m}}] \leavevmode
SPI message

\end{description}

\textbf{Description}

Dumps info about the transfers in a SPI message including buffer content.
DEBUG has to be defined for this function to be enabled alongside setting
the DRM\_UT\_DRIVER bit of \code{drm\_debug}.
\index{tinydrm\_merge\_clips (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_merge_clips}\pysiglinewithargsret{bool \bfcode{tinydrm\_merge\_clips}}{struct drm\_clip\_rect *\emph{ dst}, struct drm\_clip\_rect *\emph{ src}, unsigned int\emph{ num\_clips}, unsigned int\emph{ flags}, u32\emph{ max\_width}, u32\emph{ max\_height}}{}
Merge clip rectangles

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_clip\_rect * dst}}] \leavevmode
Destination clip rectangle

\item[{\code{struct drm\_clip\_rect * src}}] \leavevmode
Source clip rectangle(s)

\item[{\code{unsigned int num\_clips}}] \leavevmode
Number of \textbf{src} clip rectangles

\item[{\code{unsigned int flags}}] \leavevmode
Dirty fb ioctl flags

\item[{\code{u32 max\_width}}] \leavevmode
Maximum width of \textbf{dst}

\item[{\code{u32 max\_height}}] \leavevmode
Maximum height of \textbf{dst}

\end{description}

\textbf{Description}

This function merges \textbf{src} clip rectangle(s) into \textbf{dst}. If \textbf{src} is NULL,
\textbf{max\_width} and \textbf{min\_width} is used to set a full \textbf{dst} clip rectangle.

\textbf{Return}

true if it's a full clip, false otherwise
\index{tinydrm\_memcpy (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_memcpy}\pysiglinewithargsret{void \bfcode{tinydrm\_memcpy}}{void *\emph{ dst}, void *\emph{ vaddr}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, struct drm\_clip\_rect *\emph{ clip}}{}
Copy clip buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * dst}}] \leavevmode
Destination buffer

\item[{\code{void * vaddr}}] \leavevmode
Source buffer

\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
DRM framebuffer

\item[{\code{struct drm\_clip\_rect * clip}}] \leavevmode
Clip rectangle area to copy

\end{description}
\index{tinydrm\_swab16 (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_swab16}\pysiglinewithargsret{void \bfcode{tinydrm\_swab16}}{u16 *\emph{ dst}, void *\emph{ vaddr}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, struct drm\_clip\_rect *\emph{ clip}}{}
Swap bytes into clip buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u16 * dst}}] \leavevmode
RGB565 destination buffer

\item[{\code{void * vaddr}}] \leavevmode
RGB565 source buffer

\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
DRM framebuffer

\item[{\code{struct drm\_clip\_rect * clip}}] \leavevmode
Clip rectangle area to copy

\end{description}
\index{tinydrm\_xrgb8888\_to\_rgb565 (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_xrgb8888_to_rgb565}\pysiglinewithargsret{void \bfcode{tinydrm\_xrgb8888\_to\_rgb565}}{u16 *\emph{ dst}, void *\emph{ vaddr}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, struct drm\_clip\_rect *\emph{ clip}, bool\emph{ swap}}{}
Convert XRGB8888 to RGB565 clip buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u16 * dst}}] \leavevmode
RGB565 destination buffer

\item[{\code{void * vaddr}}] \leavevmode
XRGB8888 source buffer

\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
DRM framebuffer

\item[{\code{struct drm\_clip\_rect * clip}}] \leavevmode
Clip rectangle area to copy

\item[{\code{bool swap}}] \leavevmode
Swap bytes

\end{description}

\textbf{Description}

Drivers can use this function for RGB565 devices that don't natively
support XRGB8888.
\index{tinydrm\_xrgb8888\_to\_gray8 (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_xrgb8888_to_gray8}\pysiglinewithargsret{void \bfcode{tinydrm\_xrgb8888\_to\_gray8}}{u8 *\emph{ dst}, void *\emph{ vaddr}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, struct drm\_clip\_rect *\emph{ clip}}{}
Convert XRGB8888 to grayscale

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 * dst}}] \leavevmode
8-bit grayscale destination buffer

\item[{\code{void * vaddr}}] \leavevmode
XRGB8888 source buffer

\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
DRM framebuffer

\item[{\code{struct drm\_clip\_rect * clip}}] \leavevmode
Clip rectangle area to copy

\end{description}

\textbf{Description}

Drm doesn't have native monochrome or grayscale support.
Such drivers can announce the commonly supported XR24 format to userspace
and use this function to convert to the native format.

Monochrome drivers will use the most significant bit,
where 1 means foreground color and 0 background color.

ITU BT.601 is used for the RGB -\textgreater{} luma (brightness) conversion.
\index{tinydrm\_of\_find\_backlight (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_of_find_backlight}\pysiglinewithargsret{struct backlight\_device * \bfcode{tinydrm\_of\_find\_backlight}}{struct device *\emph{ dev}}{}
Find backlight device in device-tree

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device

\end{description}

\textbf{Description}

This function looks for a DT node pointed to by a property named `backlight'
and uses \code{of\_find\_backlight\_by\_node()} to get the backlight device.
Additionally if the brightness property is zero, it is set to
max\_brightness.

\textbf{Return}

NULL if there's no backlight property.
Error pointer -EPROBE\_DEFER if the DT node is found, but no backlight device
is found.
If the backlight device is found, a pointer to the structure is returned.
\index{tinydrm\_enable\_backlight (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_enable_backlight}\pysiglinewithargsret{int \bfcode{tinydrm\_enable\_backlight}}{struct backlight\_device *\emph{ backlight}}{}
Enable backlight helper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct backlight\_device * backlight}}] \leavevmode
Backlight device

\end{description}

\textbf{Return}

Zero on success, negative error code on failure.
\index{tinydrm\_disable\_backlight (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_disable_backlight}\pysiglinewithargsret{int \bfcode{tinydrm\_disable\_backlight}}{struct backlight\_device *\emph{ backlight}}{}
Disable backlight helper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct backlight\_device * backlight}}] \leavevmode
Backlight device

\end{description}

\textbf{Return}

Zero on success, negative error code on failure.
\index{tinydrm\_spi\_max\_transfer\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_spi_max_transfer_size}\pysiglinewithargsret{size\_t \bfcode{tinydrm\_spi\_max\_transfer\_size}}{struct spi\_device *\emph{ spi}, size\_t\emph{ max\_len}}{}
Determine max SPI transfer size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
SPI device

\item[{\code{size\_t max\_len}}] \leavevmode
Maximum buffer size needed (optional)

\end{description}

\textbf{Description}

This function returns the maximum size to use for SPI transfers. It checks
the SPI master, the optional \textbf{max\_len} and the module parameter spi\_max and
returns the smallest.

\textbf{Return}

Maximum size for SPI transfers
\index{tinydrm\_spi\_bpw\_supported (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_spi_bpw_supported}\pysiglinewithargsret{bool \bfcode{tinydrm\_spi\_bpw\_supported}}{struct spi\_device *\emph{ spi}, u8\emph{ bpw}}{}
Check if bits per word is supported

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
SPI device

\item[{\code{u8 bpw}}] \leavevmode
Bits per word

\end{description}

\textbf{Description}

This function checks to see if the SPI master driver supports \textbf{bpw}.

\textbf{Return}

True if \textbf{bpw} is supported, false otherwise.
\index{tinydrm\_spi\_transfer (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.tinydrm_spi_transfer}\pysiglinewithargsret{int \bfcode{tinydrm\_spi\_transfer}}{struct spi\_device *\emph{ spi}, u32\emph{ speed\_hz}, struct spi\_transfer *\emph{ header}, u8\emph{ bpw}, const void *\emph{ buf}, size\_t\emph{ len}}{}
SPI transfer helper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
SPI device

\item[{\code{u32 speed\_hz}}] \leavevmode
Override speed (optional)

\item[{\code{struct spi\_transfer * header}}] \leavevmode
Optional header transfer

\item[{\code{u8 bpw}}] \leavevmode
Bits per word

\item[{\code{const void * buf}}] \leavevmode
Buffer to transfer

\item[{\code{size\_t len}}] \leavevmode
Buffer length

\end{description}

\textbf{Description}

This SPI transfer helper breaks up the transfer of \textbf{buf} into chunks which
the SPI master driver can handle. If the machine is Little Endian and the
SPI master driver doesn't support 16 bits per word, it swaps the bytes and
does a 8-bit transfer.
If \textbf{header} is set, it is prepended to each SPI message.

\textbf{Return}

Zero on success, negative error code on failure.


\section{MIPI DBI Compatible Controllers}
\label{gpu/tinydrm:mipi-dbi-compatible-controllers}
This library provides helpers for MIPI Display Bus Interface (DBI)
compatible display controllers.

Many controllers for tiny lcd displays are MIPI compliant and can use this
library. If a controller uses registers 0x2A and 0x2B to set the area to
update and uses register 0x2C to write to frame memory, it is most likely
MIPI compliant.

Only MIPI Type 1 displays are supported since a full frame memory is needed.

There are 3 MIPI DBI implementation types:
\begin{enumerate}
\item {} 
Motorola 6800 type parallel bus

\item {} 
Intel 8080 type parallel bus

\item {} 
SPI type with 3 options:
\begin{enumerate}
\item {} 
9-bit with the Data/Command signal as the ninth bit

\item {} 
Same as above except it's sent as 16 bits

\item {} 
8-bit with the Data/Command signal as a separate D/CX pin

\end{enumerate}

\end{enumerate}

Currently mipi\_dbi only supports Type C options 1 and 3 with
{\hyperref[gpu/tinydrm:c.mipi_dbi_spi_init]{\emph{\code{mipi\_dbi\_spi\_init()}}}}.
\index{mipi\_dbi (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.mipi_dbi}\pysigline{struct \bfcode{mipi\_dbi}}
MIPI DBI controller

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct mipi\PYGZus{}dbi \PYGZob{}
  struct tinydrm\PYGZus{}device tinydrm;
  struct spi\PYGZus{}device *spi;
  bool enabled;
  struct mutex cmdlock;
  int (*command)(struct mipi\PYGZus{}dbi *mipi, u8 cmd, u8 *param, size\PYGZus{}t num);
  const u8 *read\PYGZus{}commands;
  struct gpio\PYGZus{}desc *dc;
  u16 *tx\PYGZus{}buf;
  void *tx\PYGZus{}buf9;
  size\PYGZus{}t tx\PYGZus{}buf9\PYGZus{}len;
  bool swap\PYGZus{}bytes;
  struct gpio\PYGZus{}desc *reset;
  unsigned int rotation;
  struct backlight\PYGZus{}device *backlight;
  struct regulator *regulator;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{tinydrm}}] \leavevmode
tinydrm base

\item[{\code{spi}}] \leavevmode
SPI device

\item[{\code{enabled}}] \leavevmode
Pipeline is enabled

\item[{\code{cmdlock}}] \leavevmode
Command lock

\item[{\code{command}}] \leavevmode
Bus specific callback executing commands.

\item[{\code{read\_commands}}] \leavevmode
Array of read commands terminated by a zero entry.
Reading is disabled if this is NULL.

\item[{\code{dc}}] \leavevmode
Optional D/C gpio.

\item[{\code{tx\_buf}}] \leavevmode
Buffer used for transfer (copy clip rect area)

\item[{\code{tx\_buf9}}] \leavevmode
Buffer used for Option 1 9-bit conversion

\item[{\code{tx\_buf9\_len}}] \leavevmode
Size of tx\_buf9.

\item[{\code{swap\_bytes}}] \leavevmode
Swap bytes in buffer before transfer

\item[{\code{reset}}] \leavevmode
Optional reset gpio

\item[{\code{rotation}}] \leavevmode
initial rotation in degrees Counter Clock Wise

\item[{\code{backlight}}] \leavevmode
backlight device (optional)

\item[{\code{regulator}}] \leavevmode
power regulator (optional)

\end{description}
\index{mipi\_dbi\_command (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.mipi_dbi_command}\pysiglinewithargsret{\bfcode{mipi\_dbi\_command}}{\emph{mipi}, \emph{cmd}, \emph{seq...}}{}
MIPI DCS command with optional parameter(s)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{mipi}}] \leavevmode
MIPI structure

\item[{\code{cmd}}] \leavevmode
Command

\item[{\code{seq...}}] \leavevmode
Optional parameter(s)

\end{description}

\textbf{Description}

Send MIPI DCS command to the controller. Use {\hyperref[gpu/tinydrm:c.mipi_dbi_command_read]{\emph{\code{mipi\_dbi\_command\_read()}}}} for
get/read.

\textbf{Return}

Zero on success, negative error code on failure.
\index{mipi\_dbi\_command\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.mipi_dbi_command_read}\pysiglinewithargsret{int \bfcode{mipi\_dbi\_command\_read}}{struct {\hyperref[gpu/tinydrm:c.mipi_dbi]{\emph{mipi\_dbi}}} *\emph{ mipi}, u8\emph{ cmd}, u8 *\emph{ val}}{}
MIPI DCS read command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dbi * mipi}}] \leavevmode
MIPI structure

\item[{\code{u8 cmd}}] \leavevmode
Command

\item[{\code{u8 * val}}] \leavevmode
Value read

\end{description}

\textbf{Description}

Send MIPI DCS read command to the controller.

\textbf{Return}

Zero on success, negative error code on failure.
\index{mipi\_dbi\_command\_buf (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.mipi_dbi_command_buf}\pysiglinewithargsret{int \bfcode{mipi\_dbi\_command\_buf}}{struct {\hyperref[gpu/tinydrm:c.mipi_dbi]{\emph{mipi\_dbi}}} *\emph{ mipi}, u8\emph{ cmd}, u8 *\emph{ data}, size\_t\emph{ len}}{}
MIPI DCS command with parameter(s) in an array

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dbi * mipi}}] \leavevmode
MIPI structure

\item[{\code{u8 cmd}}] \leavevmode
Command

\item[{\code{u8 * data}}] \leavevmode
Parameter buffer

\item[{\code{size\_t len}}] \leavevmode
Buffer length

\end{description}

\textbf{Return}

Zero on success, negative error code on failure.
\index{mipi\_dbi\_buf\_copy (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.mipi_dbi_buf_copy}\pysiglinewithargsret{int \bfcode{mipi\_dbi\_buf\_copy}}{void *\emph{ dst}, struct {\hyperref[gpu/drm\string-kms:c.drm_framebuffer]{\emph{drm\_framebuffer}}} *\emph{ fb}, struct drm\_clip\_rect *\emph{ clip}, bool\emph{ swap}}{}
Copy a framebuffer, transforming it if necessary

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * dst}}] \leavevmode
The destination buffer

\item[{\code{struct drm\_framebuffer * fb}}] \leavevmode
The source framebuffer

\item[{\code{struct drm\_clip\_rect * clip}}] \leavevmode
Clipping rectangle of the area to be copied

\item[{\code{bool swap}}] \leavevmode
When true, swap MSB/LSB of 16-bit values

\end{description}

\textbf{Return}

Zero on success, negative error code on failure.
\index{mipi\_dbi\_pipe\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.mipi_dbi_pipe_enable}\pysiglinewithargsret{void \bfcode{mipi\_dbi\_pipe\_enable}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe]{\emph{drm\_simple\_display\_pipe}}} *\emph{ pipe}, struct {\hyperref[gpu/drm\string-kms:c.drm_crtc_state]{\emph{drm\_crtc\_state}}} *\emph{ crtc\_state}}{}
MIPI DBI pipe enable helper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_simple\_display\_pipe * pipe}}] \leavevmode
Display pipe

\item[{\code{struct drm\_crtc\_state * crtc\_state}}] \leavevmode
CRTC state

\end{description}

\textbf{Description}

This function enables backlight. Drivers can use this as their
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe_funcs]{\emph{\code{drm\_simple\_display\_pipe\_funcs-\textgreater{}enable}}}} callback.
\index{mipi\_dbi\_pipe\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.mipi_dbi_pipe_disable}\pysiglinewithargsret{void \bfcode{mipi\_dbi\_pipe\_disable}}{struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe]{\emph{drm\_simple\_display\_pipe}}} *\emph{ pipe}}{}
MIPI DBI pipe disable helper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_simple\_display\_pipe * pipe}}] \leavevmode
Display pipe

\end{description}

\textbf{Description}

This function disables backlight if present or if not the
display memory is blanked. Drivers can use this as their
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe_funcs]{\emph{\code{drm\_simple\_display\_pipe\_funcs-\textgreater{}disable}}}} callback.
\index{mipi\_dbi\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.mipi_dbi_init}\pysiglinewithargsret{int \bfcode{mipi\_dbi\_init}}{struct device *\emph{ dev}, struct {\hyperref[gpu/tinydrm:c.mipi_dbi]{\emph{mipi\_dbi}}} *\emph{ mipi}, const struct {\hyperref[gpu/drm\string-kms\string-helpers:c.drm_simple_display_pipe_funcs]{\emph{drm\_simple\_display\_pipe\_funcs}}} *\emph{ pipe\_funcs}, struct {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{drm\_driver}}} *\emph{ driver}, const struct {\hyperref[gpu/drm\string-kms:c.drm_display_mode]{\emph{drm\_display\_mode}}} *\emph{ mode}, unsigned int\emph{ rotation}}{}
MIPI DBI initialization

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Parent device

\item[{\code{struct mipi\_dbi * mipi}}] \leavevmode
{\hyperref[gpu/tinydrm:c.mipi_dbi]{\emph{\code{mipi\_dbi}}}} structure to initialize

\item[{\code{const struct drm\_simple\_display\_pipe\_funcs * pipe\_funcs}}] \leavevmode
Display pipe functions

\item[{\code{struct drm\_driver * driver}}] \leavevmode
DRM driver

\item[{\code{const struct drm\_display\_mode * mode}}] \leavevmode
Display mode

\item[{\code{unsigned int rotation}}] \leavevmode
Initial rotation in degrees Counter Clock Wise

\end{description}

\textbf{Description}

This function initializes a {\hyperref[gpu/tinydrm:c.mipi_dbi]{\emph{\code{mipi\_dbi}}}} structure and it's underlying
\textbf{tinydrm\_device}. It also sets up the display pipeline.

Supported formats: Native RGB565 and emulated XRGB8888.

Objects created by this function will be automatically freed on driver
detach (devres).

\textbf{Return}

Zero on success, negative error code on failure.
\index{mipi\_dbi\_hw\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.mipi_dbi_hw_reset}\pysiglinewithargsret{void \bfcode{mipi\_dbi\_hw\_reset}}{struct {\hyperref[gpu/tinydrm:c.mipi_dbi]{\emph{mipi\_dbi}}} *\emph{ mipi}}{}
Hardware reset of controller

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dbi * mipi}}] \leavevmode
MIPI DBI structure

\end{description}

\textbf{Description}

Reset controller if the {\hyperref[gpu/tinydrm:c.mipi_dbi]{\emph{\code{mipi\_dbi-\textgreater{}reset}}}} gpio is set.
\index{mipi\_dbi\_display\_is\_on (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.mipi_dbi_display_is_on}\pysiglinewithargsret{bool \bfcode{mipi\_dbi\_display\_is\_on}}{struct {\hyperref[gpu/tinydrm:c.mipi_dbi]{\emph{mipi\_dbi}}} *\emph{ mipi}}{}
Check if display is on

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mipi\_dbi * mipi}}] \leavevmode
MIPI DBI structure

\end{description}

\textbf{Description}

This function checks the Power Mode register (if readable) to see if
display output is turned on. This can be used to see if the bootloader
has already turned on the display avoiding flicker when the pipeline is
enabled.

\textbf{Return}

true if the display can be verified to be on, false otherwise.
\index{mipi\_dbi\_spi\_cmd\_max\_speed (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.mipi_dbi_spi_cmd_max_speed}\pysiglinewithargsret{u32 \bfcode{mipi\_dbi\_spi\_cmd\_max\_speed}}{struct spi\_device *\emph{ spi}, size\_t\emph{ len}}{}
get the maximum SPI bus speed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
SPI device

\item[{\code{size\_t len}}] \leavevmode
The transfer buffer length.

\end{description}

\textbf{Description}

Many controllers have a max speed of 10MHz, but can be pushed way beyond
that. Increase reliability by running pixel data at max speed and the rest
at 10MHz, preventing transfer glitches from messing up the init settings.
\index{mipi\_dbi\_spi\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.mipi_dbi_spi_init}\pysiglinewithargsret{int \bfcode{mipi\_dbi\_spi\_init}}{struct spi\_device *\emph{ spi}, struct {\hyperref[gpu/tinydrm:c.mipi_dbi]{\emph{mipi\_dbi}}} *\emph{ mipi}, struct gpio\_desc *\emph{ dc}}{}
Initialize MIPI DBI SPI interfaced controller

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
SPI device

\item[{\code{struct mipi\_dbi * mipi}}] \leavevmode
{\hyperref[gpu/tinydrm:c.mipi_dbi]{\emph{\code{mipi\_dbi}}}} structure to initialize

\item[{\code{struct gpio\_desc * dc}}] \leavevmode
D/C gpio (optional)

\end{description}

\textbf{Description}

This function sets {\hyperref[gpu/tinydrm:c.mipi_dbi]{\emph{\code{mipi\_dbi-\textgreater{}command}}}}, enables \code{mipi-\textgreater{}read\_commands} for the
usual read commands. It should be followed by a call to {\hyperref[gpu/tinydrm:c.mipi_dbi_init]{\emph{\code{mipi\_dbi\_init()}}}} or
a driver-specific init.

If \textbf{dc} is set, a Type C Option 3 interface is assumed, if not
Type C Option 1.

If the SPI master driver doesn't support the necessary bits per word,
the following transformation is used:
\begin{itemize}
\item {} 
9-bit: reorder buffer as 9x 8-bit words, padded with no-op command.

\item {} 
16-bit: if big endian send as 8-bit, if little endian swap bytes

\end{itemize}

\textbf{Return}

Zero on success, negative error code on failure.
\index{mipi\_dbi\_debugfs\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/tinydrm:c.mipi_dbi_debugfs_init}\pysiglinewithargsret{int \bfcode{mipi\_dbi\_debugfs\_init}}{struct {\hyperref[gpu/drm\string-internals:c.drm_minor]{\emph{drm\_minor}}} *\emph{ minor}}{}
Create debugfs entries

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct drm\_minor * minor}}] \leavevmode
DRM minor

\end{description}

\textbf{Description}

This function creates a `command' debugfs file for sending commands to the
controller or getting the read command values.
Drivers can use this as their {\hyperref[gpu/drm\string-internals:c.drm_driver]{\emph{\code{drm\_driver-\textgreater{}debugfs\_init}}}} callback.

\textbf{Return}

Zero on success, negative error code on failure.


\chapter{drm/tve200 Faraday TV Encoder 200}
\label{gpu/tve200:drm-tve200-faraday-tv-encoder-200}\label{gpu/tve200::doc}
The Faraday TV Encoder TVE200 is also known as the Gemini TV Interface
Controller (TVC) and is found in the Gemini Chipset from Storlink
Semiconductor (later Storm Semiconductor, later Cortina Systems)
but also in the Grain Media GM8180 chipset. On the Gemini the module
is connected to 8 data lines and a single clock line, comprising an
8-bit BT.656 interface.

This is a very basic YUV display driver. The datasheet specifies that
it supports the ITU BT.656 standard. It requires a 27 MHz clock which is
the hallmark of any TV encoder supporting both PAL and NTSC.

This driver exposes a standard KMS interface for this TV encoder.


\chapter{drm/vc4 Broadcom VC4 Graphics Driver}
\label{gpu/vc4:drm-vc4-broadcom-vc4-graphics-driver}\label{gpu/vc4::doc}
The Broadcom VideoCore 4 (present in the Raspberry Pi) contains a
OpenGL ES 2.0-compatible 3D engine called V3D, and a highly
configurable display output pipeline that supports HDMI, DSI, DPI,
and Composite TV output.

The 3D engine also has an interface for submitting arbitrary
compute shader-style jobs using the same shader processor as is
used for vertex and fragment shaders in GLES 2.0.  However, given
that the hardware isn't able to expose any standard interfaces like
OpenGL compute shaders or OpenCL, it isn't supported by this
driver.


\section{Display Hardware Handling}
\label{gpu/vc4:display-hardware-handling}
This section covers everything related to the display hardware including
the mode setting infrastructure, plane, sprite and cursor handling and
display, output probing and related topics.


\subsection{Pixel Valve (DRM CRTC)}
\label{gpu/vc4:pixel-valve-drm-crtc}
In VC4, the Pixel Valve is what most closely corresponds to the
DRM's concept of a CRTC.  The PV generates video timings from the
encoder's clock plus its configuration.  It pulls scaled pixels from
the HVS at that timing, and feeds it to the encoder.

However, the DRM CRTC also collects the configuration of all the
DRM planes attached to it.  As a result, the CRTC is also
responsible for writing the display list for the HVS channel that
the CRTC will use.

The 2835 has 3 different pixel valves.  pv0 in the audio power
domain feeds DSI0 or DPI, while pv1 feeds DS1 or SMI.  pv2 in the
image domain can feed either HDMI or the SDTV controller.  The
pixel valve chooses from the CPRMAN clocks (HSM for HDMI, VEC for
SDTV, etc.) according to which output type is chosen in the mux.

For power management, the pixel valve's registers are all clocked
by the AXI clock, while the timings and FIFOs make use of the
output-specific clock.  Since the encoders also directly consume
the CPRMAN clocks, and know what timings they need, they are the
ones that set the clock.


\subsection{HVS}
\label{gpu/vc4:hvs}
The Hardware Video Scaler (HVS) is the piece of hardware that does
translation, scaling, colorspace conversion, and compositing of
pixels stored in framebuffers into a FIFO of pixels going out to
the Pixel Valve (CRTC).  It operates at the system clock rate (the
system audio clock gate, specifically), which is much higher than
the pixel clock rate.

There is a single global HVS, with multiple output FIFOs that can
be consumed by the PVs.  This file just manages the resources for
the HVS, while the vc4\_crtc.c code actually drives HVS setup for
each CRTC.


\subsection{HVS planes}
\label{gpu/vc4:hvs-planes}
Each DRM plane is a layer of pixels being scanned out by the HVS.

At atomic modeset check time, we compute the HVS display element
state that would be necessary for displaying the plane (giving us a
chance to figure out if a plane configuration is invalid), then at
atomic flush time the CRTC will ask us to write our element state
into the region of the HVS that it has allocated for us.


\subsection{HDMI encoder}
\label{gpu/vc4:hdmi-encoder}
The HDMI core has a state machine and a PHY.  On BCM2835, most of
the unit operates off of the HSM clock from CPRMAN.  It also
internally uses the PLLH\_PIX clock for the PHY.

HDMI infoframes are kept within a small packet ram, where each
packet can be individually enabled for including in a frame.

HDMI audio is implemented entirely within the HDMI IP block.  A
register in the HDMI encoder takes SPDIF frames from the DMA engine
and transfers them over an internal MAI (multi-channel audio
interconnect) bus to the encoder side for insertion into the video
blank regions.

The driver's HDMI encoder does not yet support power management.
The HDMI encoder's power domain and the HSM/pixel clocks are kept
continuously running, and only the HDMI logic and packet ram are
powered off/on at disable/enable time.

The driver does not yet support CEC control, though the HDMI
encoder block has CEC support.


\subsection{DSI encoder}
\label{gpu/vc4:dsi-encoder}
BCM2835 contains two DSI modules, DSI0 and DSI1.  DSI0 is a
single-lane DSI controller, while DSI1 is a more modern 4-lane DSI
controller.

Most Raspberry Pi boards expose DSI1 as their ``DISPLAY'' connector,
while the compute module brings both DSI0 and DSI1 out.

This driver has been tested for DSI1 video-mode display only
currently, with most of the information necessary for DSI0
hopefully present.


\subsection{DPI encoder}
\label{gpu/vc4:dpi-encoder}
The VC4 DPI hardware supports MIPI DPI type 4 and Nokia ViSSI
signals.  On BCM2835, these can be routed out to GPIO0-27 with the
ALT2 function.


\subsection{VEC (Composite TV out) encoder}
\label{gpu/vc4:vec-composite-tv-out-encoder}
The VEC encoder generates PAL or NTSC composite video output.

TV mode selection is done by an atomic property on the encoder,
because a drm\_mode\_modeinfo is insufficient to distinguish between
PAL and PAL-M or NTSC and NTSC-J.


\section{Memory Management and 3D Command Submission}
\label{gpu/vc4:memory-management-and-3d-command-submission}
This section covers the GEM implementation in the vc4 driver.


\subsection{GPU buffer object (BO) management}
\label{gpu/vc4:gpu-buffer-object-bo-management}
The VC4 GPU architecture (both scanout and rendering) has direct
access to system memory with no MMU in between.  To support it, we
use the GEM CMA helper functions to allocate contiguous ranges of
physical memory for our BOs.

Since the CMA allocator is very slow, we keep a cache of recently
freed BOs around so that the kernel's allocation of objects for 3D
rendering can return quickly.


\subsection{V3D binner command list (BCL) validation}
\label{gpu/vc4:v3d-binner-command-list-bcl-validation}
Since the VC4 has no IOMMU between it and system memory, a user
with access to execute command lists could escalate privilege by
overwriting system memory (drawing to it as a framebuffer) or
reading system memory it shouldn't (reading it as a vertex buffer
or index buffer)

We validate binner command lists to ensure that all accesses are
within the bounds of the GEM objects referenced by the submitted
job.  It explicitly whitelists packets, and looks at the offsets in
any address fields to make sure they're contained within the BOs
they reference.

Note that because CL validation is already reading the
user-submitted CL and writing the validated copy out to the memory
that the GPU will actually read, this is also where GEM relocation
processing (turning BO references into actual addresses for the GPU
to use) happens.


\subsection{V3D render command list (RCL) generation}
\label{gpu/vc4:v3d-render-command-list-rcl-generation}
In the V3D hardware, render command lists are what load and store
tiles of a framebuffer and optionally call out to binner-generated
command lists to do the 3D drawing for that tile.

In the VC4 driver, render command list generation is performed by the
kernel instead of userspace.  We do this because validating a
user-submitted command list is hard to get right and has high CPU overhead,
while the number of valid configurations for render command lists is
actually fairly low.


\subsection{Shader validator for VC4}
\label{gpu/vc4:shader-validator-for-vc4}
Since the VC4 has no IOMMU between it and system memory, a user
with access to execute shaders could escalate privilege by
overwriting system memory (using the VPM write address register in
the general-purpose DMA mode) or reading system memory it shouldn't
(reading it as a texture, uniform data, or direct-addressed TMU
lookup).

The shader validator walks over a shader's BO, ensuring that its
accesses are appropriately bounded, and recording where texture
accesses are made so that we can do relocations for them in the
uniform stream.

Shader BO are immutable for their lifetimes (enforced by not
allowing mmaps, GEM prime export, or rendering to from a CL), so
this validation is only performed at BO creation time.


\subsection{V3D Interrupts}
\label{gpu/vc4:v3d-interrupts}
We have an interrupt status register (V3D\_INTCTL) which reports
interrupts, and where writing 1 bits clears those interrupts.
There are also a pair of interrupt registers
(V3D\_INTENA/V3D\_INTDIS) where writing a 1 to their bits enables or
disables that specific interrupt, and 0s written are ignored
(reading either one returns the set of enabled interrupts).

When we take a binning flush done interrupt, we need to submit the
next frame for binning and move the finished frame to the render
thread.

When we take a render frame interrupt, we need to wake the
processes waiting for some frame to be done, and get the next frame
submitted ASAP (so the hardware doesn't sit idle when there's work
to do).

When we take the binner out of memory interrupt, we need to
allocate some new memory and pass it to the binner so that the
current job can make progress.


\chapter{VGA Switcheroo}
\label{gpu/vga-switcheroo::doc}\label{gpu/vga-switcheroo:vga-switcheroo}\label{gpu/vga-switcheroo:id1}
vga\_switcheroo is the Linux subsystem for laptop hybrid graphics.
These come in two flavors:
\begin{itemize}
\item {} 
muxed: Dual GPUs with a multiplexer chip to switch outputs between GPUs.

\item {} 
muxless: Dual GPUs but only one of them is connected to outputs.
The other one is merely used to offload rendering, its results
are copied over PCIe into the framebuffer. On Linux this is
supported with DRI PRIME.

\end{itemize}

Hybrid graphics started to appear in the late Naughties and were initially
all muxed. Newer laptops moved to a muxless architecture for cost reasons.
A notable exception is the MacBook Pro which continues to use a mux.
Muxes come with varying capabilities: Some switch only the panel, others
can also switch external displays. Some switch all display pins at once
while others can switch just the DDC lines. (To allow EDID probing
for the inactive GPU.) Also, muxes are often used to cut power to the
discrete GPU while it is not used.

DRM drivers register GPUs with vga\_switcheroo, these are henceforth called
clients. The mux is called the handler. Muxless machines also register a
handler to control the power state of the discrete GPU, its -\textgreater{}switchto
callback is a no-op for obvious reasons. The discrete GPU is often equipped
with an HDA controller for the HDMI/DP audio signal, this will also
register as a client so that vga\_switcheroo can take care of the correct
suspend/resume order when changing the discrete GPU's power state. In total
there can thus be up to three clients: Two vga clients (GPUs) and one audio
client (on the discrete GPU). The code is mostly prepared to support
machines with more than two GPUs should they become available.

The GPU to which the outputs are currently switched is called the
active client in vga\_switcheroo parlance. The GPU not in use is the
inactive client. When the inactive client's DRM driver is loaded,
it will be unable to probe the panel's EDID and hence depends on
VBIOS to provide its display modes. If the VBIOS modes are bogus or
if there is no VBIOS at all (which is common on the MacBook Pro),
a client may alternatively request that the DDC lines are temporarily
switched to it, provided that the handler supports this. Switching
only the DDC lines and not the entire output avoids unnecessary
flickering.


\section{Modes of Use}
\label{gpu/vga-switcheroo:modes-of-use}

\subsection{Manual switching and manual power control}
\label{gpu/vga-switcheroo:manual-switching-and-manual-power-control}
In this mode of use, the file /sys/kernel/debug/vgaswitcheroo/switch
can be read to retrieve the current vga\_switcheroo state and commands
can be written to it to change the state. The file appears as soon as
two GPU drivers and one handler have registered with vga\_switcheroo.
The following commands are understood:
\begin{itemize}
\item {} 
OFF: Power off the device not in use.

\item {} 
ON: Power on the device not in use.

\item {} 
IGD: Switch to the integrated graphics device.
Power on the integrated GPU if necessary, power off the discrete GPU.
Prerequisite is that no user space processes (e.g. Xorg, alsactl)
have opened device files of the GPUs or the audio client. If the
switch fails, the user may invoke lsof(8) or fuser(1) on /dev/dri/
and /dev/snd/controlC1 to identify processes blocking the switch.

\item {} 
DIS: Switch to the discrete graphics device.

\item {} 
DIGD: Delayed switch to the integrated graphics device.
This will perform the switch once the last user space process has
closed the device files of the GPUs and the audio client.

\item {} 
DDIS: Delayed switch to the discrete graphics device.

\item {} 
MIGD: Mux-only switch to the integrated graphics device.
Does not remap console or change the power state of either gpu.
If the integrated GPU is currently off, the screen will turn black.
If it is on, the screen will show whatever happens to be in VRAM.
Either way, the user has to blindly enter the command to switch back.

\item {} 
MDIS: Mux-only switch to the discrete graphics device.

\end{itemize}

For GPUs whose power state is controlled by the driver's runtime pm,
the ON and OFF commands are a no-op (see next section).

For muxless machines, the IGD/DIS, DIGD/DDIS and MIGD/MDIS commands
should not be used.


\subsection{Driver power control}
\label{gpu/vga-switcheroo:driver-power-control}
In this mode of use, the discrete GPU automatically powers up and down at
the discretion of the driver's runtime pm. On muxed machines, the user may
still influence the muxer state by way of the debugfs interface, however
the ON and OFF commands become a no-op for the discrete GPU.

This mode is the default on Nvidia HybridPower/Optimus and ATI PowerXpress.
Specifying nouveau.runpm=0, radeon.runpm=0 or amdgpu.runpm=0 on the kernel
command line disables it.

When the driver decides to power up or down, it notifies vga\_switcheroo
thereof so that it can (a) power the audio device on the GPU up or down,
and (b) update its internal power state representation for the device.
This is achieved by {\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_set_dynamic_switch]{\emph{\code{vga\_switcheroo\_set\_dynamic\_switch()}}}}.

After the GPU has been suspended, the handler needs to be called to cut
power to the GPU. Likewise it needs to reinstate power before the GPU
can resume. This is achieved by {\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_init_domain_pm_ops]{\emph{\code{vga\_switcheroo\_init\_domain\_pm\_ops()}}}},
which augments the GPU's suspend/resume functions by the requisite
calls to the handler.

When the audio device resumes, the GPU needs to be woken. This is achieved
by {\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_init_domain_pm_optimus_hdmi_audio]{\emph{\code{vga\_switcheroo\_init\_domain\_pm\_optimus\_hdmi\_audio()}}}}, which augments the
audio device's resume function.

On muxed machines, if the mux is initially switched to the discrete GPU,
the user ends up with a black screen when the GPU powers down after boot.
As a workaround, the mux is forced to the integrated GPU on runtime suspend,
cf. \href{https://bugs.freedesktop.org/show\_bug.cgi?id=75917}{https://bugs.freedesktop.org/show\_bug.cgi?id=75917}


\section{API}
\label{gpu/vga-switcheroo:api}

\subsection{Public functions}
\label{gpu/vga-switcheroo:public-functions}\index{vga\_switcheroo\_register\_handler (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_register_handler}\pysiglinewithargsret{int \bfcode{vga\_switcheroo\_register\_handler}}{const struct {\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_handler]{\emph{vga\_switcheroo\_handler}}} *\emph{ handler}, enum {\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_handler_flags_t]{\emph{vga\_switcheroo\_handler\_flags\_t}}}\emph{ handler\_flags}}{}
register handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct vga\_switcheroo\_handler * handler}}] \leavevmode
handler callbacks

\item[{\code{enum vga\_switcheroo\_handler\_flags\_t handler\_flags}}] \leavevmode
handler flags

\end{description}

\textbf{Description}

Register handler. Enable vga\_switcheroo if two vga clients have already
registered.

\textbf{Return}

0 on success, -EINVAL if a handler was already registered.
\index{vga\_switcheroo\_unregister\_handler (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_unregister_handler}\pysiglinewithargsret{void \bfcode{vga\_switcheroo\_unregister\_handler}}{void}{}
unregister handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Unregister handler. Disable vga\_switcheroo.
\index{vga\_switcheroo\_handler\_flags (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_handler_flags}\pysiglinewithargsret{enum {\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_handler_flags_t]{\emph{vga\_switcheroo\_handler\_flags\_t}}} \bfcode{vga\_switcheroo\_handler\_flags}}{void}{}
obtain handler flags

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Helper for clients to obtain the handler flags bitmask.

\textbf{Return}

Handler flags. A value of 0 means that no handler is registered
or that the handler has no special capabilities.
\index{vga\_switcheroo\_register\_client (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_register_client}\pysiglinewithargsret{int \bfcode{vga\_switcheroo\_register\_client}}{struct pci\_dev *\emph{ pdev}, const struct {\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_client_ops]{\emph{vga\_switcheroo\_client\_ops}}} *\emph{ ops}, bool\emph{ driver\_power\_control}}{}
register vga client

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
client pci device

\item[{\code{const struct vga\_switcheroo\_client\_ops * ops}}] \leavevmode
client callbacks

\item[{\code{bool driver\_power\_control}}] \leavevmode
whether power state is controlled by the driver's
runtime pm

\end{description}

\textbf{Description}

Register vga client (GPU). Enable vga\_switcheroo if another GPU and a
handler have already registered. The power state of the client is assumed
to be ON. Beforehand, {\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_client_probe_defer]{\emph{\code{vga\_switcheroo\_client\_probe\_defer()}}}} shall be called
to ensure that all prerequisites are met.

\textbf{Return}

0 on success, -ENOMEM on memory allocation error.
\index{vga\_switcheroo\_register\_audio\_client (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_register_audio_client}\pysiglinewithargsret{int \bfcode{vga\_switcheroo\_register\_audio\_client}}{struct pci\_dev *\emph{ pdev}, const struct {\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_client_ops]{\emph{vga\_switcheroo\_client\_ops}}} *\emph{ ops}, enum {\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_client_id]{\emph{vga\_switcheroo\_client\_id}}}\emph{ id}}{}
register audio client

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
client pci device

\item[{\code{const struct vga\_switcheroo\_client\_ops * ops}}] \leavevmode
client callbacks

\item[{\code{enum vga\_switcheroo\_client\_id id}}] \leavevmode
client identifier

\end{description}

\textbf{Description}

Register audio client (audio device on a GPU). The power state of the
client is assumed to be ON. Beforehand, {\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_client_probe_defer]{\emph{\code{vga\_switcheroo\_client\_probe\_defer()}}}}
shall be called to ensure that all prerequisites are met.

\textbf{Return}

0 on success, -ENOMEM on memory allocation error.
\index{vga\_switcheroo\_client\_probe\_defer (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_client_probe_defer}\pysiglinewithargsret{bool \bfcode{vga\_switcheroo\_client\_probe\_defer}}{struct pci\_dev *\emph{ pdev}}{}
whether to defer probing a given client

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
client pci device

\end{description}

\textbf{Description}

Determine whether any prerequisites are not fulfilled to probe a given
client. Drivers shall invoke this early on in their -\textgreater{}probe callback
and return \code{-EPROBE\_DEFER} if it evaluates to \code{true}. Thou shalt not
register the client ere thou hast called this.

\textbf{Return}

\code{true} if probing should be deferred, otherwise \code{false}.
\index{vga\_switcheroo\_get\_client\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_get_client_state}\pysiglinewithargsret{enum {\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_state]{\emph{vga\_switcheroo\_state}}} \bfcode{vga\_switcheroo\_get\_client\_state}}{struct pci\_dev *\emph{ pdev}}{}
obtain power state of a given client

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
client pci device

\end{description}

\textbf{Description}

Obtain power state of a given client as seen from vga\_switcheroo.
The function is only called from hda\_intel.c.

\textbf{Return}

Power state.
\index{vga\_switcheroo\_unregister\_client (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_unregister_client}\pysiglinewithargsret{void \bfcode{vga\_switcheroo\_unregister\_client}}{struct pci\_dev *\emph{ pdev}}{}
unregister client

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
client pci device

\end{description}

\textbf{Description}

Unregister client. Disable vga\_switcheroo if this is a vga client (GPU).
\index{vga\_switcheroo\_client\_fb\_set (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_client_fb_set}\pysiglinewithargsret{void \bfcode{vga\_switcheroo\_client\_fb\_set}}{struct pci\_dev *\emph{ pdev}, struct fb\_info *\emph{ info}}{}
set framebuffer of a given client

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
client pci device

\item[{\code{struct fb\_info * info}}] \leavevmode
framebuffer

\end{description}

\textbf{Description}

Set framebuffer of a given client. The console will be remapped to this
on switching.
\index{vga\_switcheroo\_lock\_ddc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_lock_ddc}\pysiglinewithargsret{int \bfcode{vga\_switcheroo\_lock\_ddc}}{struct pci\_dev *\emph{ pdev}}{}
temporarily switch DDC lines to a given client

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
client pci device

\end{description}

\textbf{Description}

Temporarily switch DDC lines to the client identified by \textbf{pdev}
(but leave the outputs otherwise switched to where they are).
This allows the inactive client to probe EDID. The DDC lines must
afterwards be switched back by calling {\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_unlock_ddc]{\emph{\code{vga\_switcheroo\_unlock\_ddc()}}}},
even if this function returns an error.

\textbf{Return}

Previous DDC owner on success or a negative int on error.
Specifically, \code{-ENODEV} if no handler has registered or if the handler
does not support switching the DDC lines. Also, a negative value
returned by the handler is propagated back to the caller.
The return value has merely an informational purpose for any caller
which might be interested in it. It is acceptable to ignore the return
value and simply rely on the result of the subsequent EDID probe,
which will be \code{NULL} if DDC switching failed.
\index{vga\_switcheroo\_unlock\_ddc (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_unlock_ddc}\pysiglinewithargsret{int \bfcode{vga\_switcheroo\_unlock\_ddc}}{struct pci\_dev *\emph{ pdev}}{}
switch DDC lines back to previous owner

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
client pci device

\end{description}

\textbf{Description}

Switch DDC lines back to the previous owner after calling
{\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_lock_ddc]{\emph{\code{vga\_switcheroo\_lock\_ddc()}}}}. This must be called even if
{\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_lock_ddc]{\emph{\code{vga\_switcheroo\_lock\_ddc()}}}} returned an error.

\textbf{Return}

Previous DDC owner on success (i.e. the client identifier of \textbf{pdev})
or a negative int on error.
Specifically, \code{-ENODEV} if no handler has registered or if the handler
does not support switching the DDC lines. Also, a negative value
returned by the handler is propagated back to the caller.
Finally, invoking this function without calling {\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_lock_ddc]{\emph{\code{vga\_switcheroo\_lock\_ddc()}}}}
first is not allowed and will result in \code{-EINVAL}.
\index{vga\_switcheroo\_process\_delayed\_switch (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_process_delayed_switch}\pysiglinewithargsret{int \bfcode{vga\_switcheroo\_process\_delayed\_switch}}{void}{}
helper for delayed switching

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Process a delayed switch if one is pending. DRM drivers should call this
from their -\textgreater{}lastclose callback.

\textbf{Return}

0 on success. -EINVAL if no delayed switch is pending, if the client
has unregistered in the meantime or if there are other clients blocking the
switch. If the actual switch fails, an error is reported and 0 is returned.
\index{vga\_switcheroo\_set\_dynamic\_switch (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_set_dynamic_switch}\pysiglinewithargsret{void \bfcode{vga\_switcheroo\_set\_dynamic\_switch}}{struct pci\_dev *\emph{ pdev}, enum {\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_state]{\emph{vga\_switcheroo\_state}}}\emph{ dynamic}}{}
helper for driver power control

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
client pci device

\item[{\code{enum vga\_switcheroo\_state dynamic}}] \leavevmode
new power state

\end{description}

\textbf{Description}

Helper for GPUs whose power state is controlled by the driver's runtime pm.
When the driver decides to power up or down, it notifies vga\_switcheroo
thereof using this helper so that it can (a) power the audio device on
the GPU up or down, and (b) update its internal power state representation
for the device.
\index{vga\_switcheroo\_init\_domain\_pm\_ops (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_init_domain_pm_ops}\pysiglinewithargsret{int \bfcode{vga\_switcheroo\_init\_domain\_pm\_ops}}{struct device *\emph{ dev}, struct dev\_pm\_domain *\emph{ domain}}{}
helper for driver power control

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
vga client device

\item[{\code{struct dev\_pm\_domain * domain}}] \leavevmode
power domain

\end{description}

\textbf{Description}

Helper for GPUs whose power state is controlled by the driver's runtime pm.
After the GPU has been suspended, the handler needs to be called to cut
power to the GPU. Likewise it needs to reinstate power before the GPU
can resume. To this end, this helper augments the suspend/resume functions
by the requisite calls to the handler. It needs only be called on platforms
where the power switch is separate to the device being powered down.
\index{vga\_switcheroo\_init\_domain\_pm\_optimus\_hdmi\_audio (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_init_domain_pm_optimus_hdmi_audio}\pysiglinewithargsret{int \bfcode{vga\_switcheroo\_init\_domain\_pm\_optimus\_hdmi\_audio}}{struct device *\emph{ dev}, struct dev\_pm\_domain *\emph{ domain}}{}
helper for driver power control

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
audio client device

\item[{\code{struct dev\_pm\_domain * domain}}] \leavevmode
power domain

\end{description}

\textbf{Description}

Helper for GPUs whose power state is controlled by the driver's runtime pm.
When the audio device resumes, the GPU needs to be woken. This helper
augments the audio device's resume function to do that.

\textbf{Return}

0 on success, -EINVAL if no power management operations are
defined for this device.


\subsection{Public structures}
\label{gpu/vga-switcheroo:public-structures}\index{vga\_switcheroo\_handler (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_handler}\pysigline{struct \bfcode{vga\_switcheroo\_handler}}
handler callbacks

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct vga\PYGZus{}switcheroo\PYGZus{}handler \PYGZob{}
  int (*init)(void);
  int (*switchto)(enum vga\PYGZus{}switcheroo\PYGZus{}client\PYGZus{}id id);
  int (*switch\PYGZus{}ddc)(enum vga\PYGZus{}switcheroo\PYGZus{}client\PYGZus{}id id);
  int (*power\PYGZus{}state)(enum vga\PYGZus{}switcheroo\PYGZus{}client\PYGZus{}id id, enum vga\PYGZus{}switcheroo\PYGZus{}state state);
  enum vga\PYGZus{}switcheroo\PYGZus{}client\PYGZus{}id (*get\PYGZus{}client\PYGZus{}id)(struct pci\PYGZus{}dev *pdev);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{init}}] \leavevmode
initialize handler.
Optional. This gets called when vga\_switcheroo is enabled, i.e. when
two vga clients have registered. It allows the handler to perform
some delayed initialization that depends on the existence of the
vga clients. Currently only the radeon and amdgpu drivers use this.
The return value is ignored

\item[{\code{switchto}}] \leavevmode
switch outputs to given client.
Mandatory. For muxless machines this should be a no-op. Returning 0
denotes success, anything else failure (in which case the switch is
aborted)

\item[{\code{switch\_ddc}}] \leavevmode
switch DDC lines to given client.
Optional. Should return the previous DDC owner on success or a
negative int on failure

\item[{\code{power\_state}}] \leavevmode
cut or reinstate power of given client.
Optional. The return value is ignored

\item[{\code{get\_client\_id}}] \leavevmode
determine if given pci device is integrated or discrete GPU.
Mandatory

\end{description}

\textbf{Description}

Handler callbacks. The multiplexer itself. The \textbf{switchto} and \textbf{get\_client\_id}
methods are mandatory, all others may be set to NULL.
\index{vga\_switcheroo\_client\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_client_ops}\pysigline{struct \bfcode{vga\_switcheroo\_client\_ops}}
client callbacks

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct vga\PYGZus{}switcheroo\PYGZus{}client\PYGZus{}ops \PYGZob{}
  void (*set\PYGZus{}gpu\PYGZus{}state)(struct pci\PYGZus{}dev *dev, enum vga\PYGZus{}switcheroo\PYGZus{}state);
  void (*reprobe)(struct pci\PYGZus{}dev *dev);
  bool (*can\PYGZus{}switch)(struct pci\PYGZus{}dev *dev);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{set\_gpu\_state}}] \leavevmode
do the equivalent of suspend/resume for the card.
Mandatory. This should not cut power to the discrete GPU,
which is the job of the handler

\item[{\code{reprobe}}] \leavevmode
poll outputs.
Optional. This gets called after waking the GPU and switching
the outputs to it

\item[{\code{can\_switch}}] \leavevmode
check if the device is in a position to switch now.
Mandatory. The client should return false if a user space process
has one of its device files open

\end{description}

\textbf{Description}

Client callbacks. A client can be either a GPU or an audio device on a GPU.
The \textbf{set\_gpu\_state} and \textbf{can\_switch} methods are mandatory, \textbf{reprobe} may be
set to NULL. For audio clients, the \textbf{reprobe} member is bogus.


\subsection{Public constants}
\label{gpu/vga-switcheroo:public-constants}\index{vga\_switcheroo\_handler\_flags\_t (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_handler_flags_t}\pysigline{enum \bfcode{vga\_switcheroo\_handler\_flags\_t}}
handler flags bitmask

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{VGA\_SWITCHEROO\_CAN\_SWITCH\_DDC}}] \leavevmode
whether the handler is able to switch the
DDC lines separately. This signals to clients that they should call
{\hyperref[gpu/drm\string-kms\string-helpers:c.drm_get_edid_switcheroo]{\emph{\code{drm\_get\_edid\_switcheroo()}}}} to probe the EDID

\item[{\code{VGA\_SWITCHEROO\_NEEDS\_EDP\_CONFIG}}] \leavevmode
whether the handler is unable to switch
the AUX channel separately. This signals to clients that the active
GPU needs to train the link and communicate the link parameters to the
inactive GPU (mediated by vga\_switcheroo). The inactive GPU may then
skip the AUX handshake and set up its output with these pre-calibrated
values (DisplayPort specification v1.1a, section 2.5.3.3)

\end{description}

\textbf{Description}

Handler flags bitmask. Used by handlers to declare their capabilities upon
registering with vga\_switcheroo.
\index{vga\_switcheroo\_client\_id (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_client_id}\pysigline{enum \bfcode{vga\_switcheroo\_client\_id}}
client identifier

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{VGA\_SWITCHEROO\_UNKNOWN\_ID}}] \leavevmode
initial identifier assigned to vga clients.
Determining the id requires the handler, so GPUs are given their
true id in a delayed fashion in \code{vga\_switcheroo\_enable()}

\item[{\code{VGA\_SWITCHEROO\_IGD}}] \leavevmode
integrated graphics device

\item[{\code{VGA\_SWITCHEROO\_DIS}}] \leavevmode
discrete graphics device

\item[{\code{VGA\_SWITCHEROO\_MAX\_CLIENTS}}] \leavevmode
currently no more than two GPUs are supported

\end{description}

\textbf{Description}

Client identifier. Audio clients use the same identifier \& 0x100.
\index{vga\_switcheroo\_state (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_state}\pysigline{enum \bfcode{vga\_switcheroo\_state}}
client power state

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{VGA\_SWITCHEROO\_OFF}}] \leavevmode
off

\item[{\code{VGA\_SWITCHEROO\_ON}}] \leavevmode
on

\item[{\code{VGA\_SWITCHEROO\_NOT\_FOUND}}] \leavevmode
client has not registered with vga\_switcheroo.
Only used in {\hyperref[gpu/vga\string-switcheroo:c.vga_switcheroo_get_client_state]{\emph{\code{vga\_switcheroo\_get\_client\_state()}}}} which in turn is only
called from hda\_intel.c

\end{description}

\textbf{Description}

Client power state.


\subsection{Private structures}
\label{gpu/vga-switcheroo:private-structures}\index{vgasr\_priv (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vgasr_priv}\pysigline{struct \bfcode{vgasr\_priv}}
vga\_switcheroo private data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct vgasr\PYGZus{}priv \PYGZob{}
  bool active;
  bool delayed\PYGZus{}switch\PYGZus{}active;
  enum vga\PYGZus{}switcheroo\PYGZus{}client\PYGZus{}id delayed\PYGZus{}client\PYGZus{}id;
  struct dentry *debugfs\PYGZus{}root;
  struct dentry *switch\PYGZus{}file;
  int registered\PYGZus{}clients;
  struct list\PYGZus{}head clients;
  const struct vga\PYGZus{}switcheroo\PYGZus{}handler *handler;
  enum vga\PYGZus{}switcheroo\PYGZus{}handler\PYGZus{}flags\PYGZus{}t handler\PYGZus{}flags;
  struct mutex mux\PYGZus{}hw\PYGZus{}lock;
  int old\PYGZus{}ddc\PYGZus{}owner;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{active}}] \leavevmode
whether vga\_switcheroo is enabled.
Prerequisite is the registration of two GPUs and a handler

\item[{\code{delayed\_switch\_active}}] \leavevmode
whether a delayed switch is pending

\item[{\code{delayed\_client\_id}}] \leavevmode
client to which a delayed switch is pending

\item[{\code{debugfs\_root}}] \leavevmode
directory for vga\_switcheroo debugfs interface

\item[{\code{switch\_file}}] \leavevmode
file for vga\_switcheroo debugfs interface

\item[{\code{registered\_clients}}] \leavevmode
number of registered GPUs
(counting only vga clients, not audio clients)

\item[{\code{clients}}] \leavevmode
list of registered clients

\item[{\code{handler}}] \leavevmode
registered handler

\item[{\code{handler\_flags}}] \leavevmode
flags of registered handler

\item[{\code{mux\_hw\_lock}}] \leavevmode
protects mux state
(in particular while DDC lines are temporarily switched)

\item[{\code{old\_ddc\_owner}}] \leavevmode
client to which DDC lines will be switched back on unlock

\end{description}

\textbf{Description}

vga\_switcheroo private data. Currently only one vga\_switcheroo instance
per system is supported.
\index{vga\_switcheroo\_client (C type)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.vga_switcheroo_client}\pysigline{struct \bfcode{vga\_switcheroo\_client}}
registered client

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct vga\PYGZus{}switcheroo\PYGZus{}client \PYGZob{}
  struct pci\PYGZus{}dev *pdev;
  struct fb\PYGZus{}info *fb\PYGZus{}info;
  enum vga\PYGZus{}switcheroo\PYGZus{}state pwr\PYGZus{}state;
  const struct vga\PYGZus{}switcheroo\PYGZus{}client\PYGZus{}ops *ops;
  enum vga\PYGZus{}switcheroo\PYGZus{}client\PYGZus{}id id;
  bool active;
  bool driver\PYGZus{}power\PYGZus{}control;
  struct list\PYGZus{}head list;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{pdev}}] \leavevmode
client pci device

\item[{\code{fb\_info}}] \leavevmode
framebuffer to which console is remapped on switching

\item[{\code{pwr\_state}}] \leavevmode
current power state

\item[{\code{ops}}] \leavevmode
client callbacks

\item[{\code{id}}] \leavevmode
client identifier. Determining the id requires the handler,
so gpus are initially assigned VGA\_SWITCHEROO\_UNKNOWN\_ID
and later given their true id in \code{vga\_switcheroo\_enable()}

\item[{\code{active}}] \leavevmode
whether the outputs are currently switched to this client

\item[{\code{driver\_power\_control}}] \leavevmode
whether power state is controlled by the driver's
runtime pm. If true, writing ON and OFF to the vga\_switcheroo debugfs
interface is a no-op so as not to interfere with runtime pm

\item[{\code{list}}] \leavevmode
client list

\end{description}

\textbf{Description}

Registered client. A client can be either a GPU or an audio device on a GPU.
For audio clients, the \textbf{fb\_info}, \textbf{active} and \textbf{driver\_power\_control} members
are bogus.


\section{Handlers}
\label{gpu/vga-switcheroo:handlers}

\subsection{apple-gmux Handler}
\label{gpu/vga-switcheroo:apple-gmux-handler}
gmux is a microcontroller built into the MacBook Pro to support dual GPUs:
A \href{http://www.latticesemi.com/en/Products/FPGAandCPLD/LatticeXP2.aspx}{Lattice XP2} on pre-retinas, a \href{http://www.renesas.com/products/mpumcu/h8s/h8s2100/h8s2113/index.jsp}{Renesas R4F2113} on retinas.

(The MacPro6,1 2013 also has a gmux, however it is unclear why since it has
dual GPUs but no built-in display.)

gmux is connected to the LPC bus of the southbridge. Its I/O ports are
accessed differently depending on the microcontroller: Driver functions
to access a pre-retina gmux are infixed \code{\_pio\_}, those for a retina gmux
are infixed \code{\_index\_}.

gmux is also connected to a GPIO pin of the southbridge and thereby is able
to trigger an ACPI GPE. On the MBP5 2008/09 it's GPIO pin 22 of the Nvidia
MCP79, on all following generations it's GPIO pin 6 of the Intel PCH.
The GPE merely signals that an interrupt occurred, the actual type of event
is identified by reading a gmux register.


\subsubsection{Graphics mux}
\label{gpu/vga-switcheroo:graphics-mux}
On pre-retinas, the LVDS outputs of both GPUs feed into gmux which muxes
either of them to the panel. One of the tricks gmux has up its sleeve is
to lengthen the blanking interval of its output during a switch to
synchronize it with the GPU switched to. This allows for a flicker-free
switch that is imperceptible by the user (\href{http://pimg-fpiw.uspto.gov/fdd/07/870/086/0.pdf}{US 8,687,007 B2}).

On retinas, muxing is no longer done by gmux itself, but by a separate
chip which is controlled by gmux. The chip is triple sourced, it is
either an \href{http://www.nxp.com/documents/data\_sheet/CBTL06141.pdf}{NXP CBTL06142}, \href{http://www.ti.com/lit/ds/symlink/hd3ss212.pdf}{TI HD3SS212} or \href{https://www.pericom.com/assets/Datasheets/PI3VDP12412.pdf}{Pericom PI3VDP12412}.
The panel is driven with eDP instead of LVDS since the pixel clock
required for retina resolution exceeds LVDS' limits.

Pre-retinas are able to switch the panel's DDC pins separately.
This is handled by a \href{http://www.ti.com/lit/ds/symlink/sn74lv4066a.pdf}{TI SN74LV4066A} which is controlled by gmux.
The inactive GPU can thus probe the panel's EDID without switching over
the entire panel. Retinas lack this functionality as the chips used for
eDP muxing are incapable of switching the AUX channel separately (see
the linked data sheets, Pericom would be capable but this is unused).
However the retina panel has the NO\_AUX\_HANDSHAKE\_LINK\_TRAINING bit set
in its DPCD, allowing the inactive GPU to skip the AUX handshake and
set up the output with link parameters pre-calibrated by the active GPU.

The external DP port is only fully switchable on the first two unibody
MacBook Pro generations, MBP5 2008/09 and MBP6 2010. This is done by an
\href{http://www.nxp.com/documents/data\_sheet/CBTL06141.pdf}{NXP CBTL06141} which is controlled by gmux. It's the predecessor of the
eDP mux on retinas, the difference being support for 2.7 versus 5.4 Gbit/s.

The following MacBook Pro generations replaced the external DP port with a
combined DP/Thunderbolt port and lost the ability to switch it between GPUs,
connecting it either to the discrete GPU or the Thunderbolt controller.
Oddly enough, while the full port is no longer switchable, AUX and HPD
are still switchable by way of an \href{http://pdf.datasheetarchive.com/indexerfiles/Datasheets-SW16/DSASW00308511.pdf}{NXP CBTL03062} (on pre-retinas
MBP8 2011 and MBP9 2012) or two \href{http://www.ti.com/lit/ds/symlink/ts3ds10224.pdf}{TI TS3DS10224} (on retinas) under the
control of gmux. Since the integrated GPU is missing the main link,
external displays appear to it as phantoms which fail to link-train.

gmux receives the HPD signal of all display connectors and sends an
interrupt on hotplug. On generations which cannot switch external ports,
the discrete GPU can then be woken to drive the newly connected display.
The ability to switch AUX on these generations could be used to improve
reliability of hotplug detection by having the integrated GPU poll the
ports while the discrete GPU is asleep, but currently we do not make use
of this feature.

Our switching policy for the external port is that on those generations
which are able to switch it fully, the port is switched together with the
panel when IGD / DIS commands are issued to vga\_switcheroo. It is thus
possible to drive e.g. a beamer on battery power with the integrated GPU.
The user may manually switch to the discrete GPU if more performance is
needed.

On all newer generations, the external port can only be driven by the
discrete GPU. If a display is plugged in while the panel is switched to
the integrated GPU, \emph{both} GPUs will be in use for maximum performance.
To decrease power consumption, the user may manually switch to the
discrete GPU, thereby suspending the integrated GPU.

gmux' initial switch state on bootup is user configurable via the EFI
variable \code{gpu-power-prefs-fa4ce28d-b62f-4c99-9cc3-6815686e30f9} (5th byte,
1 = IGD, 0 = DIS). Based on this setting, the EFI firmware tells gmux to
switch the panel and the external DP connector and allocates a framebuffer
for the selected GPU.


\subsubsection{Power control}
\label{gpu/vga-switcheroo:ti-ts3ds10224}\label{gpu/vga-switcheroo:power-control}
gmux is able to cut power to the discrete GPU. It automatically takes care
of the correct sequence to tear down and bring up the power rails for
core voltage, VRAM and PCIe.


\subsubsection{Backlight control}
\label{gpu/vga-switcheroo:backlight-control}
On single GPU MacBooks, the PWM signal for the backlight is generated by
the GPU. On dual GPU MacBook Pros by contrast, either GPU may be suspended
to conserve energy. Hence the PWM signal needs to be generated by a separate
backlight driver which is controlled by gmux. The earliest generation
MBP5 2008/09 uses a \href{http://www.ti.com/lit/ds/symlink/lp8543.pdf}{TI LP8543} backlight driver. All newer models
use a \href{http://www.ti.com/lit/ds/symlink/lp8545.pdf}{TI LP8545}.


\subsubsection{Public functions}
\label{gpu/vga-switcheroo:ti-lp8545}\label{gpu/vga-switcheroo:id2}\index{apple\_gmux\_present (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vga-switcheroo:c.apple_gmux_present}\pysiglinewithargsret{bool \bfcode{apple\_gmux\_present}}{void}{}
detect if gmux is built into the machine

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Drivers may use this to activate quirks specific to dual GPU MacBook Pros
and Mac Pros, e.g. for deferred probing, runtime pm and backlight.

\textbf{Return}

\code{true} if gmux is present and the kernel was configured
with CONFIG\_APPLE\_GMUX, \code{false} otherwise.


\chapter{VGA Arbiter}
\label{gpu/vgaarbiter:vga-arbiter}\label{gpu/vgaarbiter::doc}
Graphic devices are accessed through ranges in I/O or memory space. While most
modern devices allow relocation of such ranges, some ``Legacy'' VGA devices
implemented on PCI will typically have the same ``hard-decoded'' addresses as
they did on ISA. For more details see ``PCI Bus Binding to IEEE Std 1275-1994
Standard for Boot (Initialization Configuration) Firmware Revision 2.1''
Section 7, Legacy Devices.

The Resource Access Control (RAC) module inside the X server {[}0{]} existed for
the legacy VGA arbitration task (besides other bus management tasks) when more
than one legacy device co-exists on the same machine. But the problem happens
when these devices are trying to be accessed by different userspace clients
(e.g. two server in parallel). Their address assignments conflict. Moreover,
ideally, being a userspace application, it is not the role of the X server to
control bus resources. Therefore an arbitration scheme outside of the X server
is needed to control the sharing of these resources. This document introduces
the operation of the VGA arbiter implemented for the Linux kernel.


\section{vgaarb kernel/userspace ABI}
\label{gpu/vgaarbiter:vgaarb-kernel-userspace-abi}
The vgaarb is a module of the Linux Kernel. When it is initially loaded, it
scans all PCI devices and adds the VGA ones inside the arbitration. The
arbiter then enables/disables the decoding on different devices of the VGA
legacy instructions. Devices which do not want/need to use the arbiter may
explicitly tell it by calling vga\_set\_legacy\_decoding().

The kernel exports a char device interface (/dev/vga\_arbiter) to the clients,
which has the following semantics:
\begin{description}
\item[{open}] \leavevmode
Opens a user instance of the arbiter. By default, it's attached to the
default VGA device of the system.

\item[{close}] \leavevmode
Close a user instance. Release locks made by the user

\item[{read}] \leavevmode
Return a string indicating the status of the target like:

``\textless{}card\_ID\textgreater{},decodes=\textless{}io\_state\textgreater{},owns=\textless{}io\_state\textgreater{},locks=\textless{}io\_state\textgreater{} (ic,mc)''

An IO state string is of the form \{io,mem,io+mem,none\}, mc and
ic are respectively mem and io lock counts (for debugging/
diagnostic only). ``decodes'' indicate what the card currently
decodes, ``owns'' indicates what is currently enabled on it, and
``locks'' indicates what is locked by this card. If the card is
unplugged, we get ``invalid'' then for card\_ID and an -ENODEV
error is returned for any command until a new card is targeted.

\item[{write}] \leavevmode
Write a command to the arbiter. List of commands:
\begin{description}
\item[{target \textless{}card\_ID\textgreater{}}] \leavevmode
switch target to card \textless{}card\_ID\textgreater{} (see below)

\item[{lock \textless{}io\_state\textgreater{}}] \leavevmode
acquires locks on target (``none'' is an invalid io\_state)

\item[{trylock \textless{}io\_state\textgreater{}}] \leavevmode
non-blocking acquire locks on target (returns EBUSY if
unsuccessful)

\item[{unlock \textless{}io\_state\textgreater{}}] \leavevmode
release locks on target

\item[{unlock all}] \leavevmode
release all locks on target held by this user (not implemented
yet)

\item[{decodes \textless{}io\_state\textgreater{}}] \leavevmode
set the legacy decoding attributes for the card

\item[{poll}] \leavevmode
event if something changes on any card (not just the target)

\end{description}

card\_ID is of the form ``PCI:domain:bus:dev.fn''. It can be set to ``default''
to go back to the system default card (TODO: not implemented yet). Currently,
only PCI is supported as a prefix, but the userland API may support other bus
types in the future, even if the current kernel implementation doesn't.

\end{description}

Note about locks:

The driver keeps track of which user has which locks on which card. It
supports stacking, like the kernel one. This complexifies the implementation
a bit, but makes the arbiter more tolerant to user space problems and able
to properly cleanup in all cases when a process dies.
Currently, a max of 16 cards can have locks simultaneously issued from
user space for a given user (file descriptor instance) of the arbiter.

In the case of devices hot-\{un,\}plugged, there is a hook - pci\_notify() - to
notify them being added/removed in the system and automatically added/removed
in the arbiter.

There is also an in-kernel API of the arbiter in case DRM, vgacon, or other
drivers want to use it.


\section{In-kernel interface}
\label{gpu/vgaarbiter:in-kernel-interface}\index{vga\_set\_legacy\_decoding (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vgaarbiter:c.vga_set_legacy_decoding}\pysiglinewithargsret{void \bfcode{vga\_set\_legacy\_decoding}}{struct pci\_dev *\emph{ pdev}, unsigned int\emph{ decodes}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
pci device of the VGA card

\item[{\code{unsigned int decodes}}] \leavevmode
bit mask of what legacy regions the card decodes

\end{description}

\textbf{Description}
\begin{quote}

Indicates to the arbiter if the card decodes legacy VGA IOs,
legacy VGA Memory, both, or none. All cards default to both,
the card driver (fbdev for example) should tell the arbiter
if it has disabled legacy decoding, so the card can be left
out of the arbitration process (and can be safe to take
interrupts at any time.
\end{quote}
\index{vga\_get\_interruptible (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vgaarbiter:c.vga_get_interruptible}\pysiglinewithargsret{int \bfcode{vga\_get\_interruptible}}{struct pci\_dev *\emph{ pdev}, unsigned int\emph{ rsrc}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
pci device of the VGA card or NULL for the system default

\item[{\code{unsigned int rsrc}}] \leavevmode
bit mask of resources to acquire and lock

\end{description}

\textbf{Description}

Shortcut to vga\_get with interruptible set to true.

On success, release the VGA resource again with {\hyperref[gpu/vgaarbiter:c.vga_put]{\emph{\code{vga\_put()}}}}.
\index{vga\_get\_uninterruptible (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vgaarbiter:c.vga_get_uninterruptible}\pysiglinewithargsret{int \bfcode{vga\_get\_uninterruptible}}{struct pci\_dev *\emph{ pdev}, unsigned int\emph{ rsrc}}{}
shortcut to {\hyperref[gpu/vgaarbiter:c.vga_get]{\emph{\code{vga\_get()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
pci device of the VGA card or NULL for the system default

\item[{\code{unsigned int rsrc}}] \leavevmode
bit mask of resources to acquire and lock

\end{description}

\textbf{Description}

Shortcut to vga\_get with interruptible set to false.

On success, release the VGA resource again with {\hyperref[gpu/vgaarbiter:c.vga_put]{\emph{\code{vga\_put()}}}}.
\index{vga\_default\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vgaarbiter:c.vga_default_device}\pysiglinewithargsret{struct pci\_dev * \bfcode{vga\_default\_device}}{void}{}
return the default VGA device, for vgacon

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

This can be defined by the platform. The default implementation
is rather dumb and will probably only work properly on single
vga card setups and/or x86 platforms.

If your VGA default device is not PCI, you'll have to return
NULL here. In this case, I assume it will not conflict with
any PCI card. If this is not true, I'll have to define two archs
hooks for enabling/disabling the VGA default device if that is
possible. This may be a problem with real \_ISA\_ VGA cards, in
addition to a PCI one. I don't know at this point how to deal
with that card. Can theirs IOs be disabled at all ? If not, then
I suppose it's a matter of having the proper arch hook telling
us about it, so we basically never allow anybody to succeed a
{\hyperref[gpu/vgaarbiter:c.vga_get]{\emph{\code{vga\_get()}}}}...
\index{vga\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vgaarbiter:c.vga_get}\pysiglinewithargsret{int \bfcode{vga\_get}}{struct pci\_dev *\emph{ pdev}, unsigned int\emph{ rsrc}, int\emph{ interruptible}}{}
acquire \& locks VGA resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
pci device of the VGA card or NULL for the system default

\item[{\code{unsigned int rsrc}}] \leavevmode
bit mask of resources to acquire and lock

\item[{\code{int interruptible}}] \leavevmode
blocking should be interruptible by signals ?

\end{description}

\textbf{Description}

This function acquires VGA resources for the given card and mark those
resources locked. If the resource requested are ``normal'' (and not legacy)
resources, the arbiter will first check whether the card is doing legacy
decoding for that type of resource. If yes, the lock is ``converted'' into a
legacy resource lock.

The arbiter will first look for all VGA cards that might conflict and disable
their IOs and/or Memory access, including VGA forwarding on P2P bridges if
necessary, so that the requested resources can be used. Then, the card is
marked as locking these resources and the IO and/or Memory accesses are
enabled on the card (including VGA forwarding on parent P2P bridges if any).

This function will block if some conflicting card is already locking one of
the required resources (or any resource on a different bus segment, since P2P
bridges don't differentiate VGA memory and IO afaik). You can indicate
whether this blocking should be interruptible by a signal (for userland
interface) or not.

Must not be called at interrupt time or in atomic context.  If the card
already owns the resources, the function succeeds.  Nested calls are
supported (a per-resource counter is maintained)

On success, release the VGA resource again with {\hyperref[gpu/vgaarbiter:c.vga_put]{\emph{\code{vga\_put()}}}}.

\textbf{Return}

0 on success, negative error code on failure.
\index{vga\_tryget (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vgaarbiter:c.vga_tryget}\pysiglinewithargsret{int \bfcode{vga\_tryget}}{struct pci\_dev *\emph{ pdev}, unsigned int\emph{ rsrc}}{}
try to acquire \& lock legacy VGA resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
pci devivce of VGA card or NULL for system default

\item[{\code{unsigned int rsrc}}] \leavevmode
bit mask of resources to acquire and lock

\end{description}

\textbf{Description}

This function performs the same operation as {\hyperref[gpu/vgaarbiter:c.vga_get]{\emph{\code{vga\_get()}}}}, but will return an
error (-EBUSY) instead of blocking if the resources are already locked by
another card. It can be called in any context

On success, release the VGA resource again with {\hyperref[gpu/vgaarbiter:c.vga_put]{\emph{\code{vga\_put()}}}}.

\textbf{Return}

0 on success, negative error code on failure.
\index{vga\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vgaarbiter:c.vga_put}\pysiglinewithargsret{void \bfcode{vga\_put}}{struct pci\_dev *\emph{ pdev}, unsigned int\emph{ rsrc}}{}
release lock on legacy VGA resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
pci device of VGA card or NULL for system default

\item[{\code{unsigned int rsrc}}] \leavevmode
but mask of resource to release

\end{description}

\textbf{Description}

This fuction releases resources previously locked by {\hyperref[gpu/vgaarbiter:c.vga_get]{\emph{\code{vga\_get()}}}} or
{\hyperref[gpu/vgaarbiter:c.vga_tryget]{\emph{\code{vga\_tryget()}}}}. The resources aren't disabled right away, so that a subsequence
{\hyperref[gpu/vgaarbiter:c.vga_get]{\emph{\code{vga\_get()}}}} on the same card will succeed immediately. Resources have a
counter, so locks are only released if the counter reaches 0.
\index{vga\_client\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{gpu/vgaarbiter:c.vga_client_register}\pysiglinewithargsret{int \bfcode{vga\_client\_register}}{struct pci\_dev *\emph{ pdev}, void *\emph{ cookie}, void (*irq\_set\_state) (void\emph{ *cookie}, bool\emph{ state}, unsigned int (*set\_vga\_decode) (void\emph{ *cookie}, bool\emph{ decode}}{}
register or unregister a VGA arbitration client

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
pci device of the VGA client

\item[{\code{void * cookie}}] \leavevmode
client cookie to be used in callbacks

\item[{\code{void (*)(void *cookie, bool state) irq\_set\_state}}] \leavevmode
irq state change callback

\item[{\code{unsigned int (*)(void *cookie, bool decode) set\_vga\_decode}}] \leavevmode
vga decode change callback

\end{description}

\textbf{Description}

Clients have two callback mechanisms they can use.

\textbf{irq\_set\_state} callback: If a client can't disable its GPUs VGA
resources, then we need to be able to ask it to turn off its irqs when we
turn off its mem and io decoding.

\textbf{set\_vga\_decode} callback: If a client can disable its GPU VGA resource, it
will get a callback from this to set the encode/decode state.

Rationale: we cannot disable VGA decode resources unconditionally some single
GPU laptops seem to require ACPI or BIOS access to the VGA registers to
control things like backlights etc.  Hopefully newer multi-GPU laptops do
something saner, and desktops won't have any special ACPI for this. The
driver will get a callback when VGA arbitration is first used by userspace
since some older X servers have issues.

This function does not check whether a client for \textbf{pdev} has been registered
already.

To unregister just call this function with \textbf{irq\_set\_state} and \textbf{set\_vga\_decode}
both set to NULL for the same \textbf{pdev} as originally used to register them.

\textbf{Return}

0 on success, -1 on failure


\section{libpciaccess}
\label{gpu/vgaarbiter:libpciaccess}
To use the vga arbiter char device it was implemented an API inside the
libpciaccess library. One field was added to struct pci\_device (each device
on the system):

\begin{Verbatim}[commandchars=\\\{\}]
/* the type of resource decoded by the device */
int vgaarb\PYGZus{}rsrc;
\end{Verbatim}

Besides it, in pci\_system were added:

\begin{Verbatim}[commandchars=\\\{\}]
int vgaarb\PYGZus{}fd;
int vga\PYGZus{}count;
struct pci\PYGZus{}device *vga\PYGZus{}target;
struct pci\PYGZus{}device *vga\PYGZus{}default\PYGZus{}dev;
\end{Verbatim}

The vga\_count is used to track how many cards are being arbitrated, so for
instance, if there is only one card, then it can completely escape arbitration.

These functions below acquire VGA resources for the given card and mark those
resources as locked. If the resources requested are ``normal'' (and not legacy)
resources, the arbiter will first check whether the card is doing legacy
decoding for that type of resource. If yes, the lock is ``converted'' into a
legacy resource lock. The arbiter will first look for all VGA cards that
might conflict and disable their IOs and/or Memory access, including VGA
forwarding on P2P bridges if necessary, so that the requested resources can
be used. Then, the card is marked as locking these resources and the IO and/or
Memory access is enabled on the card (including VGA forwarding on parent
P2P bridges if any). In the case of vga\_arb\_lock(), the function will block
if some conflicting card is already locking one of the required resources (or
any resource on a different bus segment, since P2P bridges don't differentiate
VGA memory and IO afaik). If the card already owns the resources, the function
succeeds.  vga\_arb\_trylock() will return (-EBUSY) instead of blocking. Nested
calls are supported (a per-resource counter is maintained).

Set the target device of this client.

\begin{Verbatim}[commandchars=\\\{\}]
int  pci\PYGZus{}device\PYGZus{}vgaarb\PYGZus{}set\PYGZus{}target   (struct pci\PYGZus{}device *dev);
\end{Verbatim}

For instance, in x86 if two devices on the same bus want to lock different
resources, both will succeed (lock). If devices are in different buses and
trying to lock different resources, only the first who tried succeeds.

\begin{Verbatim}[commandchars=\\\{\}]
int  pci\PYGZus{}device\PYGZus{}vgaarb\PYGZus{}lock         (void);
int  pci\PYGZus{}device\PYGZus{}vgaarb\PYGZus{}trylock      (void);
\end{Verbatim}

Unlock resources of device.

\begin{Verbatim}[commandchars=\\\{\}]
int  pci\PYGZus{}device\PYGZus{}vgaarb\PYGZus{}unlock       (void);
\end{Verbatim}

Indicates to the arbiter if the card decodes legacy VGA IOs, legacy VGA
Memory, both, or none. All cards default to both, the card driver (fbdev for
example) should tell the arbiter if it has disabled legacy decoding, so the
card can be left out of the arbitration process (and can be safe to take
interrupts at any time.

\begin{Verbatim}[commandchars=\\\{\}]
int  pci\PYGZus{}device\PYGZus{}vgaarb\PYGZus{}decodes      (int new\PYGZus{}vgaarb\PYGZus{}rsrc);
\end{Verbatim}

Connects to the arbiter device, allocates the struct

\begin{Verbatim}[commandchars=\\\{\}]
int  pci\PYGZus{}device\PYGZus{}vgaarb\PYGZus{}init         (void);
\end{Verbatim}

Close the connection

\begin{Verbatim}[commandchars=\\\{\}]
void pci\PYGZus{}device\PYGZus{}vgaarb\PYGZus{}fini         (void);
\end{Verbatim}


\section{xf86VGAArbiter (X server implementation)}
\label{gpu/vgaarbiter:xf86vgaarbiter-x-server-implementation}
X server basically wraps all the functions that touch VGA registers somehow.


\section{References}
\label{gpu/vgaarbiter:references}
Benjamin Herrenschmidt (IBM?) started this work when he discussed such design
with the Xorg community in 2005 {[}1, 2{]}. In the end of 2007, Paulo Zanoni and
Tiago Vignatti (both of C3SL/Federal University of Paraná) proceeded his work
enhancing the kernel code to adapt as a kernel module and also did the
implementation of the user space side {[}3{]}. Now (2009) Tiago Vignatti and Dave
Airlie finally put this work in shape and queued to Jesse Barnes' PCI tree.
\begin{enumerate}
\setcounter{enumi}{-1}
\item {} 
\href{http://cgit.freedesktop.org/xorg/xserver/commit/?id=4b42448a2388d40f257774fbffdccaea87bd0347}{http://cgit.freedesktop.org/xorg/xserver/commit/?id=4b42448a2388d40f257774fbffdccaea87bd0347}

\item {} 
\href{http://lists.freedesktop.org/archives/xorg/2005-March/006663.html}{http://lists.freedesktop.org/archives/xorg/2005-March/006663.html}

\item {} 
\href{http://lists.freedesktop.org/archives/xorg/2005-March/006745.html}{http://lists.freedesktop.org/archives/xorg/2005-March/006745.html}

\item {} 
\href{http://lists.freedesktop.org/archives/xorg/2007-October/029507.html}{http://lists.freedesktop.org/archives/xorg/2007-October/029507.html}

\end{enumerate}


\chapter{drm/bridge/dw-hdmi Synopsys DesignWare HDMI Controller}
\label{gpu/bridge/dw-hdmi:drm-bridge-dw-hdmi-synopsys-designware-hdmi-controller}\label{gpu/bridge/dw-hdmi::doc}

\section{Synopsys DesignWare HDMI Controller}
\label{gpu/bridge/dw-hdmi:synopsys-designware-hdmi-controller}
This section covers everything related to the Synopsys DesignWare HDMI
Controller implemented as a DRM bridge.


\subsection{Supported Input Formats and Encodings}
\label{gpu/bridge/dw-hdmi:supported-input-formats-and-encodings}
Depending on the Hardware configuration of the Controller IP, it supports
a subset of the following input formats and encodings on its internal
48bit bus.

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline

Format Name
 & 
Format Code
 & 
Encodings
\\
\hline
RGB 4:4:4 8bit
 & 
\code{MEDIA\_BUS\_FMT\_RGB888\_1X24}
 & 
\code{V4L2\_YCBCR\_ENC\_DEFAULT}
\\
\hline
RGB 4:4:4 10bits
 & 
\code{MEDIA\_BUS\_FMT\_RGB101010\_1X30}
 & 
\code{V4L2\_YCBCR\_ENC\_DEFAULT}
\\
\hline
RGB 4:4:4 12bits
 & 
\code{MEDIA\_BUS\_FMT\_RGB121212\_1X36}
 & 
\code{V4L2\_YCBCR\_ENC\_DEFAULT}
\\
\hline
RGB 4:4:4 16bits
 & 
\code{MEDIA\_BUS\_FMT\_RGB161616\_1X48}
 & 
\code{V4L2\_YCBCR\_ENC\_DEFAULT}
\\
\hline
YCbCr 4:4:4 8bit
 & 
\code{MEDIA\_BUS\_FMT\_YUV8\_1X24}
 & 
\code{V4L2\_YCBCR\_ENC\_601}
or \code{V4L2\_YCBCR\_ENC\_709}
or \code{V4L2\_YCBCR\_ENC\_XV601}
or \code{V4L2\_YCBCR\_ENC\_XV709}
\\
\hline
YCbCr 4:4:4 10bits
 & 
\code{MEDIA\_BUS\_FMT\_YUV10\_1X30}
 & 
\code{V4L2\_YCBCR\_ENC\_601}
or \code{V4L2\_YCBCR\_ENC\_709}
or \code{V4L2\_YCBCR\_ENC\_XV601}
or \code{V4L2\_YCBCR\_ENC\_XV709}
\\
\hline
YCbCr 4:4:4 12bits
 & 
\code{MEDIA\_BUS\_FMT\_YUV12\_1X36}
 & 
\code{V4L2\_YCBCR\_ENC\_601}
or \code{V4L2\_YCBCR\_ENC\_709}
or \code{V4L2\_YCBCR\_ENC\_XV601}
or \code{V4L2\_YCBCR\_ENC\_XV709}
\\
\hline
YCbCr 4:4:4 16bits
 & 
\code{MEDIA\_BUS\_FMT\_YUV16\_1X48}
 & 
\code{V4L2\_YCBCR\_ENC\_601}
or \code{V4L2\_YCBCR\_ENC\_709}
or \code{V4L2\_YCBCR\_ENC\_XV601}
or \code{V4L2\_YCBCR\_ENC\_XV709}
\\
\hline
YCbCr 4:2:2 8bit
 & 
\code{MEDIA\_BUS\_FMT\_UYVY8\_1X16}
 & 
\code{V4L2\_YCBCR\_ENC\_601}
or \code{V4L2\_YCBCR\_ENC\_709}
\\
\hline
YCbCr 4:2:2 10bits
 & 
\code{MEDIA\_BUS\_FMT\_UYVY10\_1X20}
 & 
\code{V4L2\_YCBCR\_ENC\_601}
or \code{V4L2\_YCBCR\_ENC\_709}
\\
\hline
YCbCr 4:2:2 12bits
 & 
\code{MEDIA\_BUS\_FMT\_UYVY12\_1X24}
 & 
\code{V4L2\_YCBCR\_ENC\_601}
or \code{V4L2\_YCBCR\_ENC\_709}
\\
\hline
YCbCr 4:2:0 8bit
 & 
\code{MEDIA\_BUS\_FMT\_UYYVYY8\_0\_5X24}
 & 
\code{V4L2\_YCBCR\_ENC\_601}
or \code{V4L2\_YCBCR\_ENC\_709}
\\
\hline
YCbCr 4:2:0 10bits
 & 
\code{MEDIA\_BUS\_FMT\_UYYVYY10\_0\_5X30}
 & 
\code{V4L2\_YCBCR\_ENC\_601}
or \code{V4L2\_YCBCR\_ENC\_709}
\\
\hline
YCbCr 4:2:0 12bits
 & 
\code{MEDIA\_BUS\_FMT\_UYYVYY12\_0\_5X36}
 & 
\code{V4L2\_YCBCR\_ENC\_601}
or \code{V4L2\_YCBCR\_ENC\_709}
\\
\hline
YCbCr 4:2:0 16bits
 & 
\code{MEDIA\_BUS\_FMT\_UYYVYY16\_0\_5X48}
 & 
\code{V4L2\_YCBCR\_ENC\_601}
or \code{V4L2\_YCBCR\_ENC\_709}
\\
\hline\end{tabulary}



\chapter{TODO list}
\label{gpu/todo:todo}\label{gpu/todo:todo-list}\label{gpu/todo::doc}
This section contains a list of smaller janitorial tasks in the kernel DRM
graphics subsystem useful as newbie projects. Or for slow rainy days.


\section{Subsystem-wide refactorings}
\label{gpu/todo:subsystem-wide-refactorings}

\subsection{De-midlayer drivers}
\label{gpu/todo:de-midlayer-drivers}
With the recent \code{drm\_bus} cleanup patches for 3.17 it is no longer required
to have a \code{drm\_bus} structure set up. Drivers can directly set up the
\code{drm\_device} structure instead of relying on bus methods in \code{drm\_usb.c}
and \code{drm\_pci.c}. The goal is to get rid of the driver's \code{-\textgreater{}load} /
\code{-\textgreater{}unload} callbacks and open-code the load/unload sequence properly, using
the new two-stage \code{drm\_device} setup/teardown.

Once all existing drivers are converted we can also remove those bus support
files for USB and platform devices.

All you need is a GPU for a non-converted driver (currently almost all of
them, but also all the virtual ones used by KVM, so everyone qualifies).

Contact: Daniel Vetter, Thierry Reding, respective driver maintainers


\subsection{Switch from reference/unreference to get/put}
\label{gpu/todo:switch-from-reference-unreference-to-get-put}
For some reason DRM core uses \code{reference}/\code{unreference} suffixes for
refcounting functions, but kernel uses \code{get}/\code{put} (e.g.
\code{kref\_get}/\code{put()}). It would be good to switch over for consistency, and
it's shorter. Needs to be done in 3 steps for each pair of functions:
\begin{itemize}
\item {} 
Create new \code{get}/\code{put} functions, define the old names as compatibility
wrappers

\item {} 
Switch over each file/driver using a cocci-generated spatch.

\item {} 
Once all users of the old names are gone, remove them.

\end{itemize}

This way drivers/patches in the progress of getting merged won't break.

Contact: Daniel Vetter


\subsection{Convert existing KMS drivers to atomic modesetting}
\label{gpu/todo:convert-existing-kms-drivers-to-atomic-modesetting}
3.19 has the atomic modeset interfaces and helpers, so drivers can now be
converted over. Modern compositors like Wayland or Surfaceflinger on Android
really want an atomic modeset interface, so this is all about the bright
future.

There is a conversion guide for atomic and all you need is a GPU for a
non-converted driver (again virtual HW drivers for KVM are still all
suitable).

As part of this drivers also need to convert to universal plane (which means
exposing primary \& cursor as proper plane objects). But that's much easier to
do by directly using the new atomic helper driver callbacks.

Contact: Daniel Vetter, respective driver maintainers


\subsection{Clean up the clipped coordination confusion around planes}
\label{gpu/todo:clean-up-the-clipped-coordination-confusion-around-planes}
We have a helper to get this right with drm\_plane\_helper\_check\_update(), but
it's not consistently used. This should be fixed, preferrably in the atomic
helpers (and drivers then moved over to clipped coordinates). Probably the
helper should also be moved from drm\_plane\_helper.c to the atomic helpers, to
avoid confusion - the other helpers in that file are all deprecated legacy
helpers.

Contact: Ville Syrjälä, Daniel Vetter, driver maintainers


\subsection{Convert early atomic drivers to async commit helpers}
\label{gpu/todo:convert-early-atomic-drivers-to-async-commit-helpers}
For the first year the atomic modeset helpers didn't support asynchronous /
nonblocking commits, and every driver had to hand-roll them. This is fixed
now, but there's still a pile of existing drivers that easily could be
converted over to the new infrastructure.

One issue with the helpers is that they require that drivers handle completion
events for atomic commits correctly. But fixing these bugs is good anyway.

Contact: Daniel Vetter, respective driver maintainers


\subsection{Better manual-upload support for atomic}
\label{gpu/todo:better-manual-upload-support-for-atomic}
This would be especially useful for tinydrm:
\begin{itemize}
\item {} 
Add a struct drm\_rect dirty\_clip to drm\_crtc\_state. When duplicating the
crtc state, clear that to the max values, x/y = 0 and w/h = MAX\_INT, in
\_\_drm\_atomic\_helper\_crtc\_duplicate\_state().

\item {} 
Move tinydrm\_merge\_clips into drm\_framebuffer.c, dropping the tinydrm\_
prefix ofc and using drm\_fb\_. drm\_framebuffer.c makes sense since this
is a function useful to implement the fb-\textgreater{}dirty function.

\item {} 
Create a new drm\_fb\_dirty function which does essentially what e.g.
mipi\_dbi\_fb\_dirty does. You can use e.g. drm\_atomic\_helper\_update\_plane as the
template. But instead of doing a simple full-screen plane update, this new
helper also sets crtc\_state-\textgreater{}dirty\_clip to the right coordinates. And of
course it needs to check whether the fb is actually active (and maybe where),
so there's some book-keeping involved. There's also some good fun involved in
scaling things appropriately. For that case we might simply give up and
declare the entire area covered by the plane as dirty.

\end{itemize}

Contact: Noralf Trønnes, Daniel Vetter


\subsection{Fallout from atomic KMS}
\label{gpu/todo:fallout-from-atomic-kms}
\code{drm\_atomic\_helper.c} provides a batch of functions which implement legacy
IOCTLs on top of the new atomic driver interface. Which is really nice for
gradual conversion of drivers, but unfortunately the semantic mismatches are
a bit too severe. So there's some follow-up work to adjust the function
interfaces to fix these issues:
\begin{itemize}
\item {} 
atomic needs the lock acquire context. At the moment that's passed around
implicitly with some horrible hacks, and it's also allocate with
\code{GFP\_NOFAIL} behind the scenes. All legacy paths need to start allocating
the acquire context explicitly on stack and then also pass it down into
drivers explicitly so that the legacy-on-atomic functions can use them.

Except for some driver code this is done.

\item {} 
A bunch of the vtable hooks are now in the wrong place: DRM has a split
between core vfunc tables (named \code{drm\_foo\_funcs}), which are used to
implement the userspace ABI. And then there's the optional hooks for the
helper libraries (name \code{drm\_foo\_helper\_funcs}), which are purely for
internal use. Some of these hooks should be move from \code{\_funcs} to
\code{\_helper\_funcs} since they are not part of the core ABI. There's a
\code{FIXME} comment in the kerneldoc for each such case in \code{drm\_crtc.h}.

\item {} 
There's a new helper \code{drm\_atomic\_helper\_best\_encoder()} which could be
used by all atomic drivers which don't select the encoder for a given
connector at runtime. That's almost all of them, and would allow us to get
rid of a lot of \code{best\_encoder} boilerplate in drivers.

This was almost done, but new drivers added a few more cases again.

\end{itemize}

Contact: Daniel Vetter


\subsection{Get rid of dev-\textgreater{}struct\_mutex from GEM drivers}
\label{gpu/todo:get-rid-of-dev-struct-mutex-from-gem-drivers}
\code{dev-\textgreater{}struct\_mutex} is the Big DRM Lock from legacy days and infested
everything. Nowadays in modern drivers the only bit where it's mandatory is
serializing GEM buffer object destruction. Which unfortunately means drivers
have to keep track of that lock and either call \code{unreference} or
\code{unreference\_locked} depending upon context.

Core GEM doesn't have a need for \code{struct\_mutex} any more since kernel 4.8,
and there's a \code{gem\_free\_object\_unlocked} callback for any drivers which are
entirely \code{struct\_mutex} free.

For drivers that need \code{struct\_mutex} it should be replaced with a driver-
private lock. The tricky part is the BO free functions, since those can't
reliably take that lock any more. Instead state needs to be protected with
suitable subordinate locks or some cleanup work pushed to a worker thread. For
performance-critical drivers it might also be better to go with a more
fine-grained per-buffer object and per-context lockings scheme. Currently the
following drivers still use \code{struct\_mutex}: \code{msm}, \code{omapdrm} and
\code{udl}.

Contact: Daniel Vetter, respective driver maintainers


\subsection{Convert instances of dev\_info/dev\_err/dev\_warn to their DRM\_DEV\_* equivalent}
\label{gpu/todo:convert-instances-of-dev-info-dev-err-dev-warn-to-their-drm-dev-equivalent}
For drivers which could have multiple instances, it is necessary to
differentiate between which is which in the logs. Since DRM\_INFO/WARN/ERROR
don't do this, drivers used dev\_info/warn/err to make this differentiation. We
now have DRM\_DEV\_* variants of the drm print macros, so we can start to convert
those drivers back to using drm-formwatted specific log messages.

Before you start this conversion please contact the relevant maintainers to make
sure your work will be merged - not everyone agrees that the DRM dmesg macros
are better.

Contact: Sean Paul, Maintainer of the driver you plan to convert


\subsection{Convert drivers to use simple modeset suspend/resume}
\label{gpu/todo:convert-drivers-to-use-simple-modeset-suspend-resume}
Most drivers (except i915 and nouveau) that use
drm\_atomic\_helper\_suspend/resume() can probably be converted to use
drm\_mode\_config\_helper\_suspend/resume().

Contact: Maintainer of the driver you plan to convert


\subsection{Convert drivers to use drm\_fb\_helper\_fbdev\_setup/teardown()}
\label{gpu/todo:convert-drivers-to-use-drm-fb-helper-fbdev-setup-teardown}
Most drivers can use drm\_fb\_helper\_fbdev\_setup() except maybe:
\begin{itemize}
\item {} 
amdgpu which has special logic to decide whether to call
drm\_helper\_disable\_unused\_functions()

\item {} 
armada which isn't atomic and doesn't call
drm\_helper\_disable\_unused\_functions()

\item {} 
i915 which calls drm\_fb\_helper\_initial\_config() in a worker

\end{itemize}

Drivers that use drm\_framebuffer\_remove() to clean up the fbdev framebuffer can
probably use drm\_fb\_helper\_fbdev\_teardown().

Contact: Maintainer of the driver you plan to convert


\section{Core refactorings}
\label{gpu/todo:core-refactorings}

\subsection{Clean up the DRM header mess}
\label{gpu/todo:clean-up-the-drm-header-mess}
Currently the DRM subsystem has only one global header, \code{drmP.h}. This is
used both for functions exported to helper libraries and drivers and functions
only used internally in the \code{drm.ko} module. The goal would be to move all
header declarations not needed outside of \code{drm.ko} into
\code{drivers/gpu/drm/drm\_*\_internal.h} header files. \code{EXPORT\_SYMBOL} also
needs to be dropped for these functions.

This would nicely tie in with the below task to create kerneldoc after the API
is cleaned up. Or with the ``hide legacy cruft better'' task.

Note that this is well in progress, but \code{drmP.h} is still huge. The updated
plan is to switch to per-file driver API headers, which will also structure
the kerneldoc better. This should also allow more fine-grained \code{\#include}
directives.

In the end no .c file should need to include \code{drmP.h} anymore.

Contact: Daniel Vetter


\subsection{Add missing kerneldoc for exported functions}
\label{gpu/todo:add-missing-kerneldoc-for-exported-functions}
The DRM reference documentation is still lacking kerneldoc in a few areas. The
task would be to clean up interfaces like moving functions around between
files to better group them and improving the interfaces like dropping return
values for functions that never fail. Then write kerneldoc for all exported
functions and an overview section and integrate it all into the drm book.

See \href{https://dri.freedesktop.org/docs/drm/}{https://dri.freedesktop.org/docs/drm/} for what's there already.

Contact: Daniel Vetter


\subsection{Hide legacy cruft better}
\label{gpu/todo:hide-legacy-cruft-better}
Way back DRM supported only drivers which shadow-attached to PCI devices with
userspace or fbdev drivers setting up outputs. Modern DRM drivers take charge
of the entire device, you can spot them with the DRIVER\_MODESET flag.

Unfortunately there's still large piles of legacy code around which needs to
be hidden so that driver writers don't accidentally end up using it. And to
prevent security issues in those legacy IOCTLs from being exploited on modern
drivers. This has multiple possible subtasks:
\begin{itemize}
\item {} 
Extract support code for legacy features into a \code{drm-legacy.ko} kernel
module and compile it only when one of the legacy drivers is enabled.

\end{itemize}

This is mostly done, the only thing left is to split up \code{drm\_irq.c} into
legacy cruft and the parts needed by modern KMS drivers.

Contact: Daniel Vetter


\subsection{Make panic handling work}
\label{gpu/todo:make-panic-handling-work}
This is a really varied tasks with lots of little bits and pieces:
\begin{itemize}
\item {} 
The panic path can't be tested currently, leading to constant breaking. The
main issue here is that panics can be triggered from hardirq contexts and
hence all panic related callback can run in hardirq context. It would be
awesome if we could test at least the fbdev helper code and driver code by
e.g. trigger calls through drm debugfs files. hardirq context could be
achieved by using an IPI to the local processor.

\item {} 
There's a massive confusion of different panic handlers. DRM fbdev emulation
helpers have one, but on top of that the fbcon code itself also has one. We
need to make sure that they stop fighting over each another.

\item {} 
\code{drm\_can\_sleep()} is a mess. It hides real bugs in normal operations and
isn't a full solution for panic paths. We need to make sure that it only
returns true if there's a panic going on for real, and fix up all the
fallout.

\item {} 
The panic handler must never sleep, which also means it can't ever
\code{mutex\_lock()}. Also it can't grab any other lock unconditionally, not
even spinlocks (because NMI and hardirq can panic too). We need to either
make sure to not call such paths, or trylock everything. Really tricky.

\item {} 
For the above locking troubles reasons it's pretty much impossible to
attempt a synchronous modeset from panic handlers. The only thing we could
try to achive is an atomic \code{set\_base} of the primary plane, and hope that
it shows up. Everything else probably needs to be delayed to some worker or
something else which happens later on. Otherwise it just kills the box
harder, prevent the panic from going out on e.g. netconsole.

\item {} 
There's also proposal for a simplied DRM console instead of the full-blown
fbcon and DRM fbdev emulation. Any kind of panic handling tricks should
obviously work for both console, in case we ever get kmslog merged.

\end{itemize}

Contact: Daniel Vetter


\subsection{Clean up the debugfs support}
\label{gpu/todo:clean-up-the-debugfs-support}
There's a bunch of issues with it:
\begin{itemize}
\item {} 
The drm\_info\_list -\textgreater{}show() function doesn't even bother to cast to the drm
structure for you. This is lazy.

\item {} 
We probably want to have some support for debugfs files on crtc/connectors and
maybe other kms objects directly in core. There's even drm\_print support in
the funcs for these objects to dump kms state, so it's all there. And then the
-\textgreater{}show() functions should obviously give you a pointer to the right object.

\item {} 
The drm\_info\_list stuff is centered on drm\_minor instead of drm\_device. For
anything we want to print drm\_device (or maybe drm\_file) is the right thing.

\item {} 
The drm\_driver-\textgreater{}debugfs\_init hooks we have is just an artifact of the old
midlayered load sequence. DRM debugfs should work more like sysfs, where you
can create properties/files for an object anytime you want, and the core
takes care of publishing/unpuplishing all the files at register/unregister
time. Drivers shouldn't need to worry about these technicalities, and fixing
this (together with the drm\_minor-\textgreater{}drm\_device move) would allow us to remove
debugfs\_init.

\end{itemize}

Contact: Daniel Vetter


\subsection{KMS cleanups}
\label{gpu/todo:kms-cleanups}
Some of these date from the very introduction of KMS in 2008 ...
\begin{itemize}
\item {} 
drm\_mode\_config.crtc\_idr is misnamed, since it contains all KMS object. Should
be renamed to drm\_mode\_config.object\_idr.

\item {} 
drm\_display\_mode doesn't need to be derived from drm\_mode\_object. That's
leftovers from older (never merged into upstream) KMS designs where modes
where set using their ID, including support to add/remove modes.

\end{itemize}


\section{Better Testing}
\label{gpu/todo:better-testing}

\subsection{Enable trinity for DRM}
\label{gpu/todo:enable-trinity-for-drm}
And fix up the fallout. Should be really interesting ...


\subsection{Make KMS tests in i-g-t generic}
\label{gpu/todo:make-kms-tests-in-i-g-t-generic}
The i915 driver team maintains an extensive testsuite for the i915 DRM driver,
including tons of testcases for corner-cases in the modesetting API. It would
be awesome if those tests (at least the ones not relying on Intel-specific GEM
features) could be made to run on any KMS driver.

Basic work to run i-g-t tests on non-i915 is done, what's now missing is mass-
converting things over. For modeset tests we also first need a bit of
infrastructure to use dumb buffers for untiled buffers, to be able to run all
the non-i915 specific modeset tests.

Contact: Daniel Vetter


\subsection{Create a virtual KMS driver for testing (vkms)}
\label{gpu/todo:create-a-virtual-kms-driver-for-testing-vkms}
With all the latest helpers it should be fairly simple to create a virtual KMS
driver useful for testing, or for running X or similar on headless machines
(to be able to still use the GPU). This would be similar to vgem, but aimed at
the modeset side.

Once the basics are there there's tons of possibilities to extend it.

Contact: Daniel Vetter


\section{Driver Specific}
\label{gpu/todo:driver-specific}

\subsection{tinydrm}
\label{gpu/todo:tinydrm}
Tinydrm is the helper driver for really simple fb drivers. The goal is to make
those drivers as simple as possible, so lots of room for refactoring:
\begin{itemize}
\item {} 
backlight helpers, probably best to put them into a new drm\_backlight.c.
This is because drivers/video is de-facto unmaintained. We could also
move drivers/video/backlight to drivers/gpu/backlight and take it all
over within drm-misc, but that's more work. Backlight helpers require a fair
bit of reworking and refactoring. A simple example is the enabling of a backlight.
Tinydrm has helpers for this. It would be good if other drivers can also use the
helper. However, there are various cases we need to consider i.e different
drivers seem to have different ways of enabling/disabling a backlight.
We also need to consider the backlight drivers (like gpio\_backlight). The situation
is further complicated by the fact that the backlight is tied to fbdev
via fb\_notifier\_callback() which has complicated logic. For further details, refer
to the following discussion thread:
\href{https://groups.google.com/forum/\#!topic/outreachy-kernel/8rBe30lwtdA}{https://groups.google.com/forum/\#!topic/outreachy-kernel/8rBe30lwtdA}

\item {} 
spi helpers, probably best put into spi core/helper code. Thierry said
the spi maintainer is fast\&reactive, so shouldn't be a big issue.

\item {} 
extract the mipi-dbi helper (well, the non-tinydrm specific parts at
least) into a separate helper, like we have for mipi-dsi already. Or follow
one of the ideas for having a shared dsi/dbi helper, abstracting away the
transport details more.

\item {} 
tinydrm\_gem\_cma\_prime\_import\_sg\_table should probably go into the cma
helpers, as a \_vmapped variant (since not every driver needs the vmap).
And tinydrm\_gem\_cma\_free\_object could the be merged into
drm\_gem\_cma\_free\_object().

\item {} 
tinydrm\_fb\_create we could move into drm\_simple\_pipe, only need to add
the fb\_create hook to drm\_simple\_pipe\_funcs, which would again simplify a
bunch of things (since it gives you a one-stop vfunc for simple drivers).

\item {} 
Quick aside: The unregister devm stuff is kinda getting the lifetimes of
a drm\_device wrong. Doesn't matter, since everyone else gets it wrong
too :-)

\item {} 
also rework the drm\_framebuffer\_funcs-\textgreater{}dirty hook wire-up, see above.

\end{itemize}

Contact: Noralf Trønnes, Daniel Vetter


\subsection{AMD DC Display Driver}
\label{gpu/todo:amd-dc-display-driver}
AMD DC is the display driver for AMD devices starting with Vega. There has been
a bunch of progress cleaning it up but there's still plenty of work to be done.

See drivers/gpu/drm/amd/display/TODO for tasks.

Contact: Harry Wentland, Alex Deucher


\section{Outside DRM}
\label{gpu/todo:outside-drm}


\renewcommand{\indexname}{Index}
\printindex
\end{document}
