% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,8pt,english]{sphinxmanual}


\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }


	% Use some font with UTF-8 support with XeLaTeX
        \usepackage{fontspec}
        \setsansfont{DejaVu Serif}
        \setromanfont{DejaVu Sans}
        \setmonofont{DejaVu Sans Mono}

     \usepackage[margin=0.5in, top=1in, bottom=1in]{geometry}
        \usepackage{ifthen}

        % Put notes in color and let them be inside a table
	\definecolor{NoteColor}{RGB}{204,255,255}
	\definecolor{WarningColor}{RGB}{255,204,204}
	\definecolor{AttentionColor}{RGB}{255,255,204}
	\definecolor{ImportantColor}{RGB}{192,255,204}
	\definecolor{OtherColor}{RGB}{204,204,204}
        \newlength{\mynoticelength}
        \makeatletter\newenvironment{coloredbox}[1]{%
	   \setlength{\fboxrule}{1pt}
	   \setlength{\fboxsep}{7pt}
	   \setlength{\mynoticelength}{\linewidth}
	   \addtolength{\mynoticelength}{-2\fboxsep}
	   \addtolength{\mynoticelength}{-2\fboxrule}
           \begin{lrbox}{\@tempboxa}\begin{minipage}{\mynoticelength}}{\end{minipage}\end{lrbox}%
	   \ifthenelse%
	      {\equal{\py@noticetype}{note}}%
	      {\colorbox{NoteColor}{\usebox{\@tempboxa}}}%
	      {%
	         \ifthenelse%
	         {\equal{\py@noticetype}{warning}}%
	         {\colorbox{WarningColor}{\usebox{\@tempboxa}}}%
		 {%
	            \ifthenelse%
	            {\equal{\py@noticetype}{attention}}%
	            {\colorbox{AttentionColor}{\usebox{\@tempboxa}}}%
		    {%
	               \ifthenelse%
	               {\equal{\py@noticetype}{important}}%
	               {\colorbox{ImportantColor}{\usebox{\@tempboxa}}}%
	               {\colorbox{OtherColor}{\usebox{\@tempboxa}}}%
		    }%
		 }%
	      }%
        }\makeatother

        \makeatletter
        \renewenvironment{notice}[2]{%
          \def\py@noticetype{#1}
          \begin{coloredbox}{#1}
          \bf\it
          \par\strong{#2}
          \csname py@noticestart@#1\endcsname
        }
	{
          \csname py@noticeend@\py@noticetype\endcsname
          \end{coloredbox}
        }
	\makeatother

     

\title{Development tools for the Kernel}
\date{March 08, 2018}
\release{4.16.0-rc4+}
\author{The kernel development community}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\setcounter{tocdepth}{1}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{dev-tools/index::doc}


This document is a collection of documents about development tools that can
be used to work on the kernel.  For now, the documents have been pulled
together without any significant effot to integrate them into a coherent
whole; patches welcome!

Table of contents


\chapter{Coccinelle}
\label{dev-tools/coccinelle:development-tools-for-the-kernel}\label{dev-tools/coccinelle::doc}\label{dev-tools/coccinelle:coccinelle}
Coccinelle is a tool for pattern matching and text transformation that has
many uses in kernel development, including the application of complex,
tree-wide patches and detection of problematic programming patterns.


\section{Getting Coccinelle}
\label{dev-tools/coccinelle:getting-coccinelle}
The semantic patches included in the kernel use features and options
which are provided by Coccinelle version 1.0.0-rc11 and above.
Using earlier versions will fail as the option names used by
the Coccinelle files and coccicheck have been updated.

Coccinelle is available through the package manager
of many distributions, e.g. :
\begin{itemize}
\item {} 
Debian

\item {} 
Fedora

\item {} 
Ubuntu

\item {} 
OpenSUSE

\item {} 
Arch Linux

\item {} 
NetBSD

\item {} 
FreeBSD

\end{itemize}

You can get the latest version released from the Coccinelle homepage at
\href{http://coccinelle.lip6.fr/}{http://coccinelle.lip6.fr/}

Once you have it, run the following command:

\begin{Verbatim}[commandchars=\\\{\}]
./configure
make
\end{Verbatim}

as a regular user, and install it with:

\begin{Verbatim}[commandchars=\\\{\}]
sudo make install
\end{Verbatim}


\section{Supplemental documentation}
\label{dev-tools/coccinelle:supplemental-documentation}
For supplemental documentation refer to the wiki:

\href{https://bottest.wiki.kernel.org/coccicheck}{https://bottest.wiki.kernel.org/coccicheck}

The wiki documentation always refers to the linux-next version of the script.


\section{Using Coccinelle on the Linux kernel}
\label{dev-tools/coccinelle:using-coccinelle-on-the-linux-kernel}
A Coccinelle-specific target is defined in the top level
Makefile. This target is named \code{coccicheck} and calls the \code{coccicheck}
front-end in the \code{scripts} directory.

Four basic modes are defined: \code{patch}, \code{report}, \code{context}, and
\code{org}. The mode to use is specified by setting the MODE variable with
\code{MODE=\textless{}mode\textgreater{}}.
\begin{itemize}
\item {} 
\code{patch} proposes a fix, when possible.

\item {} 
\code{report} generates a list in the following format:
file:line:column-column: message

\item {} 
\code{context} highlights lines of interest and their context in a
diff-like style.Lines of interest are indicated with \code{-}.

\item {} 
\code{org} generates a report in the Org mode format of Emacs.

\end{itemize}

Note that not all semantic patches implement all modes. For easy use
of Coccinelle, the default mode is ``report''.

Two other modes provide some common combinations of these modes.
\begin{itemize}
\item {} 
\code{chain} tries the previous modes in the order above until one succeeds.

\item {} 
\code{rep+ctxt} runs successively the report mode and the context mode.
It should be used with the C option (described later)
which checks the code on a file basis.

\end{itemize}


\subsection{Examples}
\label{dev-tools/coccinelle:examples}
To make a report for every semantic patch, run the following command:

\begin{Verbatim}[commandchars=\\\{\}]
make coccicheck MODE=report
\end{Verbatim}

To produce patches, run:

\begin{Verbatim}[commandchars=\\\{\}]
make coccicheck MODE=patch
\end{Verbatim}

The coccicheck target applies every semantic patch available in the
sub-directories of \code{scripts/coccinelle} to the entire Linux kernel.

For each semantic patch, a commit message is proposed.  It gives a
description of the problem being checked by the semantic patch, and
includes a reference to Coccinelle.

As any static code analyzer, Coccinelle produces false
positives. Thus, reports must be carefully checked, and patches
reviewed.

To enable verbose messages set the V= variable, for example:

\begin{Verbatim}[commandchars=\\\{\}]
make coccicheck MODE=report V=1
\end{Verbatim}


\section{Coccinelle parallelization}
\label{dev-tools/coccinelle:coccinelle-parallelization}
By default, coccicheck tries to run as parallel as possible. To change
the parallelism, set the J= variable. For example, to run across 4 CPUs:

\begin{Verbatim}[commandchars=\\\{\}]
make coccicheck MODE=report J=4
\end{Verbatim}

As of Coccinelle 1.0.2 Coccinelle uses Ocaml parmap for parallelization,
if support for this is detected you will benefit from parmap parallelization.

When parmap is enabled coccicheck will enable dynamic load balancing by using
\code{-{-}chunksize 1} argument, this ensures we keep feeding threads with work
one by one, so that we avoid the situation where most work gets done by only
a few threads. With dynamic load balancing, if a thread finishes early we keep
feeding it more work.

When parmap is enabled, if an error occurs in Coccinelle, this error
value is propagated back, the return value of the \code{make coccicheck}
captures this return value.


\section{Using Coccinelle with a single semantic patch}
\label{dev-tools/coccinelle:using-coccinelle-with-a-single-semantic-patch}
The optional make variable COCCI can be used to check a single
semantic patch. In that case, the variable must be initialized with
the name of the semantic patch to apply.

For instance:

\begin{Verbatim}[commandchars=\\\{\}]
make coccicheck COCCI=\PYGZlt{}my\PYGZus{}SP.cocci\PYGZgt{} MODE=patch
\end{Verbatim}

or:

\begin{Verbatim}[commandchars=\\\{\}]
make coccicheck COCCI=\PYGZlt{}my\PYGZus{}SP.cocci\PYGZgt{} MODE=report
\end{Verbatim}


\section{Controlling Which Files are Processed by Coccinelle}
\label{dev-tools/coccinelle:controlling-which-files-are-processed-by-coccinelle}
By default the entire kernel source tree is checked.

To apply Coccinelle to a specific directory, \code{M=} can be used.
For example, to check drivers/net/wireless/ one may write:

\begin{Verbatim}[commandchars=\\\{\}]
make coccicheck M=drivers/net/wireless/
\end{Verbatim}

To apply Coccinelle on a file basis, instead of a directory basis, the
following command may be used:

\begin{Verbatim}[commandchars=\\\{\}]
make C=1 CHECK=\PYGZdq{}scripts/coccicheck\PYGZdq{}
\end{Verbatim}

To check only newly edited code, use the value 2 for the C flag, i.e.:

\begin{Verbatim}[commandchars=\\\{\}]
make C=2 CHECK=\PYGZdq{}scripts/coccicheck\PYGZdq{}
\end{Verbatim}

In these modes, which works on a file basis, there is no information
about semantic patches displayed, and no commit message proposed.

This runs every semantic patch in scripts/coccinelle by default. The
COCCI variable may additionally be used to only apply a single
semantic patch as shown in the previous section.

The ``report'' mode is the default. You can select another one with the
MODE variable explained above.


\section{Debugging Coccinelle SmPL patches}
\label{dev-tools/coccinelle:debugging-coccinelle-smpl-patches}
Using coccicheck is best as it provides in the spatch command line
include options matching the options used when we compile the kernel.
You can learn what these options are by using V=1, you could then
manually run Coccinelle with debug options added.

Alternatively you can debug running Coccinelle against SmPL patches
by asking for stderr to be redirected to stderr, by default stderr
is redirected to /dev/null, if you'd like to capture stderr you
can specify the \code{DEBUG\_FILE="file.txt"} option to coccicheck. For
instance:

\begin{Verbatim}[commandchars=\\\{\}]
rm \PYGZhy{}f cocci.err
make coccicheck COCCI=scripts/coccinelle/free/kfree.cocci MODE=report DEBUG\PYGZus{}FILE=cocci.err
cat cocci.err
\end{Verbatim}

You can use SPFLAGS to add debugging flags, for instance you may want to
add both --profile --show-trying to SPFLAGS when debugging. For instance
you may want to use:

\begin{Verbatim}[commandchars=\\\{\}]
rm \PYGZhy{}f err.log
export COCCI=scripts/coccinelle/misc/irqf\PYGZus{}oneshot.cocci
make coccicheck DEBUG\PYGZus{}FILE=\PYGZdq{}err.log\PYGZdq{} MODE=report SPFLAGS=\PYGZdq{}\PYGZhy{}\PYGZhy{}profile \PYGZhy{}\PYGZhy{}show\PYGZhy{}trying\PYGZdq{} M=./drivers/mfd/arizona\PYGZhy{}irq.c
\end{Verbatim}

err.log will now have the profiling information, while stdout will
provide some progress information as Coccinelle moves forward with
work.

DEBUG\_FILE support is only supported when using coccinelle \textgreater{}= 1.0.2.


\section{.cocciconfig support}
\label{dev-tools/coccinelle:cocciconfig-support}
Coccinelle supports reading .cocciconfig for default Coccinelle options that
should be used every time spatch is spawned, the order of precedence for
variables for .cocciconfig is as follows:
\begin{itemize}
\item {} 
Your current user's home directory is processed first

\item {} 
Your directory from which spatch is called is processed next

\item {} 
The directory provided with the --dir option is processed last, if used

\end{itemize}

Since coccicheck runs through make, it naturally runs from the kernel
proper dir, as such the second rule above would be implied for picking up a
.cocciconfig when using \code{make coccicheck}.

\code{make coccicheck} also supports using M= targets.If you do not supply
any M= target, it is assumed you want to target the entire kernel.
The kernel coccicheck script has:

\begin{Verbatim}[commandchars=\\\{\}]
if [ \PYGZdq{}\PYGZdl{}KBUILD\PYGZus{}EXTMOD\PYGZdq{} = \PYGZdq{}\PYGZdq{} ] ; then
    OPTIONS=\PYGZdq{}\PYGZhy{}\PYGZhy{}dir \PYGZdl{}srctree \PYGZdl{}COCCIINCLUDE\PYGZdq{}
else
    OPTIONS=\PYGZdq{}\PYGZhy{}\PYGZhy{}dir \PYGZdl{}KBUILD\PYGZus{}EXTMOD \PYGZdl{}COCCIINCLUDE\PYGZdq{}
fi
\end{Verbatim}

KBUILD\_EXTMOD is set when an explicit target with M= is used. For both cases
the spatch --dir argument is used, as such third rule applies when whether M=
is used or not, and when M= is used the target directory can have its own
.cocciconfig file. When M= is not passed as an argument to coccicheck the
target directory is the same as the directory from where spatch was called.

If not using the kernel's coccicheck target, keep the above precedence
order logic of .cocciconfig reading. If using the kernel's coccicheck target,
override any of the kernel's .coccicheck's settings using SPFLAGS.

We help Coccinelle when used against Linux with a set of sensible defaults
options for Linux with our own Linux .cocciconfig. This hints to coccinelle
git can be used for \code{git grep} queries over coccigrep. A timeout of 200
seconds should suffice for now.

The options picked up by coccinelle when reading a .cocciconfig do not appear
as arguments to spatch processes running on your system, to confirm what
options will be used by Coccinelle run:

\begin{Verbatim}[commandchars=\\\{\}]
spatch \PYGZhy{}\PYGZhy{}print\PYGZhy{}options\PYGZhy{}only
\end{Verbatim}

You can override with your own preferred index option by using SPFLAGS. Take
note that when there are conflicting options Coccinelle takes precedence for
the last options passed. Using .cocciconfig is possible to use idutils, however
given the order of precedence followed by Coccinelle, since the kernel now
carries its own .cocciconfig, you will need to use SPFLAGS to use idutils if
desired. See below section ``Additional flags'' for more details on how to use
idutils.


\section{Additional flags}
\label{dev-tools/coccinelle:additional-flags}
Additional flags can be passed to spatch through the SPFLAGS
variable. This works as Coccinelle respects the last flags
given to it when options are in conflict.

\begin{Verbatim}[commandchars=\\\{\}]
make SPFLAGS=\PYGZhy{}\PYGZhy{}use\PYGZhy{}glimpse coccicheck
\end{Verbatim}

Coccinelle supports idutils as well but requires coccinelle \textgreater{}= 1.0.6.
When no ID file is specified coccinelle assumes your ID database file
is in the file .id-utils.index on the top level of the kernel, coccinelle
carries a script scripts/idutils\_index.sh which creates the database with:

\begin{Verbatim}[commandchars=\\\{\}]
mkid \PYGZhy{}i C \PYGZhy{}\PYGZhy{}output .id\PYGZhy{}utils.index
\end{Verbatim}

If you have another database filename you can also just symlink with this
name.

\begin{Verbatim}[commandchars=\\\{\}]
make SPFLAGS=\PYGZhy{}\PYGZhy{}use\PYGZhy{}idutils coccicheck
\end{Verbatim}

Alternatively you can specify the database filename explicitly, for
instance:

\begin{Verbatim}[commandchars=\\\{\}]
make SPFLAGS=\PYGZdq{}\PYGZhy{}\PYGZhy{}use\PYGZhy{}idutils /full\PYGZhy{}path/to/ID\PYGZdq{} coccicheck
\end{Verbatim}

See \code{spatch -{-}help} to learn more about spatch options.

Note that the \code{-{-}use-glimpse} and \code{-{-}use-idutils} options
require external tools for indexing the code. None of them is
thus active by default. However, by indexing the code with
one of these tools, and according to the cocci file used,
spatch could proceed the entire code base more quickly.


\section{SmPL patch specific options}
\label{dev-tools/coccinelle:smpl-patch-specific-options}
SmPL patches can have their own requirements for options passed
to Coccinelle. SmPL patch specific options can be provided by
providing them at the top of the SmPL patch, for instance:

\begin{Verbatim}[commandchars=\\\{\}]
// Options: \PYGZhy{}\PYGZhy{}no\PYGZhy{}includes \PYGZhy{}\PYGZhy{}include\PYGZhy{}headers
\end{Verbatim}


\section{SmPL patch Coccinelle requirements}
\label{dev-tools/coccinelle:smpl-patch-coccinelle-requirements}
As Coccinelle features get added some more advanced SmPL patches
may require newer versions of Coccinelle. If an SmPL patch requires
at least a version of Coccinelle, this can be specified as follows,
as an example if requiring at least Coccinelle \textgreater{}= 1.0.5:

\begin{Verbatim}[commandchars=\\\{\}]
// Requires: 1.0.5
\end{Verbatim}


\section{Proposing new semantic patches}
\label{dev-tools/coccinelle:proposing-new-semantic-patches}
New semantic patches can be proposed and submitted by kernel
developers. For sake of clarity, they should be organized in the
sub-directories of \code{scripts/coccinelle/}.


\section{Detailed description of the \texttt{report} mode}
\label{dev-tools/coccinelle:detailed-description-of-the-report-mode}
\code{report} generates a list in the following format:

\begin{Verbatim}[commandchars=\\\{\}]
file:line:column\PYGZhy{}column: message
\end{Verbatim}


\subsection{Example}
\label{dev-tools/coccinelle:example}
Running:

\begin{Verbatim}[commandchars=\\\{\}]
make coccicheck MODE=report COCCI=scripts/coccinelle/api/err\PYGZus{}cast.cocci
\end{Verbatim}

will execute the following part of the SmPL script:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}smpl\PYGZgt{}
@r depends on !context \PYGZam{}\PYGZam{} !patch \PYGZam{}\PYGZam{} (org \textbar{}\textbar{} report)@
expression x;
position p;
@@

  ERR\PYGZus{}PTR@p(PTR\PYGZus{}ERR(x))

@script:python depends on report@
p \PYGZlt{}\PYGZlt{} r.p;
x \PYGZlt{}\PYGZlt{} r.x;
@@

msg=\PYGZdq{}ERR\PYGZus{}CAST can be used with \PYGZpc{}s\PYGZdq{} \PYGZpc{} (x)
coccilib.report.print\PYGZus{}report(p[0], msg)
\PYGZlt{}/smpl\PYGZgt{}
\end{Verbatim}

This SmPL excerpt generates entries on the standard output, as
illustrated below:

\begin{Verbatim}[commandchars=\\\{\}]
/home/user/linux/crypto/ctr.c:188:9\PYGZhy{}16: ERR\PYGZus{}CAST can be used with alg
/home/user/linux/crypto/authenc.c:619:9\PYGZhy{}16: ERR\PYGZus{}CAST can be used with auth
/home/user/linux/crypto/xts.c:227:9\PYGZhy{}16: ERR\PYGZus{}CAST can be used with alg
\end{Verbatim}


\section{Detailed description of the \texttt{patch} mode}
\label{dev-tools/coccinelle:detailed-description-of-the-patch-mode}
When the \code{patch} mode is available, it proposes a fix for each problem
identified.


\subsection{Example}
\label{dev-tools/coccinelle:id1}
Running:

\begin{Verbatim}[commandchars=\\\{\}]
make coccicheck MODE=patch COCCI=scripts/coccinelle/api/err\PYGZus{}cast.cocci
\end{Verbatim}

will execute the following part of the SmPL script:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}smpl\PYGZgt{}
@ depends on !context \PYGZam{}\PYGZam{} patch \PYGZam{}\PYGZam{} !org \PYGZam{}\PYGZam{} !report @
expression x;
@@

\PYGZhy{} ERR\PYGZus{}PTR(PTR\PYGZus{}ERR(x))
+ ERR\PYGZus{}CAST(x)
\PYGZlt{}/smpl\PYGZgt{}
\end{Verbatim}

This SmPL excerpt generates patch hunks on the standard output, as
illustrated below:

\begin{Verbatim}[commandchars=\\\{\}]
diff \PYGZhy{}u \PYGZhy{}p a/crypto/ctr.c b/crypto/ctr.c
\PYGZhy{}\PYGZhy{}\PYGZhy{} a/crypto/ctr.c 2010\PYGZhy{}05\PYGZhy{}26 10:49:38.000000000 +0200
+++ b/crypto/ctr.c 2010\PYGZhy{}06\PYGZhy{}03 23:44:49.000000000 +0200
@@ \PYGZhy{}185,7 +185,7 @@ static struct crypto\PYGZus{}instance *crypto\PYGZus{}ct
    alg = crypto\PYGZus{}attr\PYGZus{}alg(tb[1], CRYPTO\PYGZus{}ALG\PYGZus{}TYPE\PYGZus{}CIPHER,
                              CRYPTO\PYGZus{}ALG\PYGZus{}TYPE\PYGZus{}MASK);
    if (IS\PYGZus{}ERR(alg))
\PYGZhy{}           return ERR\PYGZus{}PTR(PTR\PYGZus{}ERR(alg));
+           return ERR\PYGZus{}CAST(alg);

    /* Block size must be \PYGZgt{}= 4 bytes. */
    err = \PYGZhy{}EINVAL;
\end{Verbatim}


\section{Detailed description of the \texttt{context} mode}
\label{dev-tools/coccinelle:detailed-description-of-the-context-mode}
\code{context} highlights lines of interest and their context
in a diff-like style.
\begin{quote}

\textbf{NOTE}: The diff-like output generated is NOT an applicable patch. The
intent of the \code{context} mode is to highlight the important lines
(annotated with minus, \code{-}) and gives some surrounding context
lines around. This output can be used with the diff mode of
Emacs to review the code.
\end{quote}


\subsection{Example}
\label{dev-tools/coccinelle:id2}
Running:

\begin{Verbatim}[commandchars=\\\{\}]
make coccicheck MODE=context COCCI=scripts/coccinelle/api/err\PYGZus{}cast.cocci
\end{Verbatim}

will execute the following part of the SmPL script:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}smpl\PYGZgt{}
@ depends on context \PYGZam{}\PYGZam{} !patch \PYGZam{}\PYGZam{} !org \PYGZam{}\PYGZam{} !report@
expression x;
@@

* ERR\PYGZus{}PTR(PTR\PYGZus{}ERR(x))
\PYGZlt{}/smpl\PYGZgt{}
\end{Verbatim}

This SmPL excerpt generates diff hunks on the standard output, as
illustrated below:

\begin{Verbatim}[commandchars=\\\{\}]
diff \PYGZhy{}u \PYGZhy{}p /home/user/linux/crypto/ctr.c /tmp/nothing
\PYGZhy{}\PYGZhy{}\PYGZhy{} /home/user/linux/crypto/ctr.c   2010\PYGZhy{}05\PYGZhy{}26 10:49:38.000000000 +0200
+++ /tmp/nothing
@@ \PYGZhy{}185,7 +185,6 @@ static struct crypto\PYGZus{}instance *crypto\PYGZus{}ct
    alg = crypto\PYGZus{}attr\PYGZus{}alg(tb[1], CRYPTO\PYGZus{}ALG\PYGZus{}TYPE\PYGZus{}CIPHER,
                              CRYPTO\PYGZus{}ALG\PYGZus{}TYPE\PYGZus{}MASK);
    if (IS\PYGZus{}ERR(alg))
\PYGZhy{}           return ERR\PYGZus{}PTR(PTR\PYGZus{}ERR(alg));

    /* Block size must be \PYGZgt{}= 4 bytes. */
    err = \PYGZhy{}EINVAL;
\end{Verbatim}


\section{Detailed description of the \texttt{org} mode}
\label{dev-tools/coccinelle:detailed-description-of-the-org-mode}
\code{org} generates a report in the Org mode format of Emacs.


\subsection{Example}
\label{dev-tools/coccinelle:id3}
Running:

\begin{Verbatim}[commandchars=\\\{\}]
make coccicheck MODE=org COCCI=scripts/coccinelle/api/err\PYGZus{}cast.cocci
\end{Verbatim}

will execute the following part of the SmPL script:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}smpl\PYGZgt{}
@r depends on !context \PYGZam{}\PYGZam{} !patch \PYGZam{}\PYGZam{} (org \textbar{}\textbar{} report)@
expression x;
position p;
@@

  ERR\PYGZus{}PTR@p(PTR\PYGZus{}ERR(x))

@script:python depends on org@
p \PYGZlt{}\PYGZlt{} r.p;
x \PYGZlt{}\PYGZlt{} r.x;
@@

msg=\PYGZdq{}ERR\PYGZus{}CAST can be used with \PYGZpc{}s\PYGZdq{} \PYGZpc{} (x)
msg\PYGZus{}safe=msg.replace(\PYGZdq{}[\PYGZdq{},\PYGZdq{}@(\PYGZdq{}).replace(\PYGZdq{}]\PYGZdq{},\PYGZdq{})\PYGZdq{})
coccilib.org.print\PYGZus{}todo(p[0], msg\PYGZus{}safe)
\PYGZlt{}/smpl\PYGZgt{}
\end{Verbatim}

This SmPL excerpt generates Org entries on the standard output, as
illustrated below:

\begin{Verbatim}[commandchars=\\\{\}]
* TODO [[view:/home/user/linux/crypto/ctr.c::face=ovl\PYGZhy{}face1::linb=188::colb=9::cole=16][ERR\PYGZus{}CAST can be used with alg]]
* TODO [[view:/home/user/linux/crypto/authenc.c::face=ovl\PYGZhy{}face1::linb=619::colb=9::cole=16][ERR\PYGZus{}CAST can be used with auth]]
* TODO [[view:/home/user/linux/crypto/xts.c::face=ovl\PYGZhy{}face1::linb=227::colb=9::cole=16][ERR\PYGZus{}CAST can be used with alg]]
\end{Verbatim}


\chapter{Sparse}
\label{dev-tools/sparse::doc}\label{dev-tools/sparse:sparse}
Sparse is a semantic checker for C programs; it can be used to find a
number of potential problems with kernel code.  See
\href{https://lwn.net/Articles/689907/}{https://lwn.net/Articles/689907/} for an overview of sparse; this document
contains some kernel-specific sparse information.


\section{Using sparse for typechecking}
\label{dev-tools/sparse:using-sparse-for-typechecking}
``\_\_bitwise'' is a type attribute, so you have to do something like this:

\begin{Verbatim}[commandchars=\\\{\}]
typedef int \PYGZus{}\PYGZus{}bitwise pm\PYGZus{}request\PYGZus{}t;

enum pm\PYGZus{}request \PYGZob{}
        PM\PYGZus{}SUSPEND = (\PYGZus{}\PYGZus{}force pm\PYGZus{}request\PYGZus{}t) 1,
        PM\PYGZus{}RESUME = (\PYGZus{}\PYGZus{}force pm\PYGZus{}request\PYGZus{}t) 2
\PYGZcb{};
\end{Verbatim}

which makes PM\_SUSPEND and PM\_RESUME ``bitwise'' integers (the ``\_\_force'' is
there because sparse will complain about casting to/from a bitwise type,
but in this case we really \_do\_ want to force the conversion). And because
the enum values are all the same type, now ``enum pm\_request'' will be that
type too.

And with gcc, all the ``\_\_bitwise''/''\_\_force stuff'' goes away, and it all
ends up looking just like integers to gcc.

Quite frankly, you don't need the enum there. The above all really just
boils down to one special ``int \_\_bitwise'' type.

So the simpler way is to just do:

\begin{Verbatim}[commandchars=\\\{\}]
typedef int \PYGZus{}\PYGZus{}bitwise pm\PYGZus{}request\PYGZus{}t;

\PYGZsh{}define PM\PYGZus{}SUSPEND ((\PYGZus{}\PYGZus{}force pm\PYGZus{}request\PYGZus{}t) 1)
\PYGZsh{}define PM\PYGZus{}RESUME ((\PYGZus{}\PYGZus{}force pm\PYGZus{}request\PYGZus{}t) 2)
\end{Verbatim}

and you now have all the infrastructure needed for strict typechecking.

One small note: the constant integer ``0'' is special. You can use a
constant zero as a bitwise integer type without sparse ever complaining.
This is because ``bitwise'' (as the name implies) was designed for making
sure that bitwise types don't get mixed up (little-endian vs big-endian
vs cpu-endian vs whatever), and there the constant ``0'' really \_is\_
special.


\section{Using sparse for lock checking}
\label{dev-tools/sparse:using-sparse-for-lock-checking}
The following macros are undefined for gcc and defined during a sparse
run to use the ``context'' tracking feature of sparse, applied to
locking.  These annotations tell sparse when a lock is held, with
regard to the annotated function's entry and exit.

\_\_must\_hold - The specified lock is held on function entry and exit.

\_\_acquires - The specified lock is held on function exit, but not entry.

\_\_releases - The specified lock is held on function entry, but not exit.

If the function enters and exits without the lock held, acquiring and
releasing the lock inside the function in a balanced way, no
annotation is needed.  The tree annotations above are for cases where
sparse would otherwise report a context imbalance.


\section{Getting sparse}
\label{dev-tools/sparse:getting-sparse}
You can get latest released versions from the Sparse homepage at
\href{https://sparse.wiki.kernel.org/index.php/Main\_Page}{https://sparse.wiki.kernel.org/index.php/Main\_Page}

Alternatively, you can get snapshots of the latest development version
of sparse using git to clone:

\begin{Verbatim}[commandchars=\\\{\}]
git://git.kernel.org/pub/scm/devel/sparse/sparse.git
\end{Verbatim}

DaveJ has hourly generated tarballs of the git tree available at:

\begin{Verbatim}[commandchars=\\\{\}]
http://www.codemonkey.org.uk/projects/git\PYGZhy{}snapshots/sparse/
\end{Verbatim}

Once you have it, just do:

\begin{Verbatim}[commandchars=\\\{\}]
make
make install
\end{Verbatim}

as a regular user, and it will install sparse in your \textasciitilde{}/bin directory.


\section{Using sparse}
\label{dev-tools/sparse:using-sparse}
Do a kernel make with ``make C=1'' to run sparse on all the C files that get
recompiled, or use ``make C=2'' to run sparse on the files whether they need to
be recompiled or not.  The latter is a fast way to check the whole tree if you
have already built it.

The optional make variable CF can be used to pass arguments to sparse.  The
build system passes -Wbitwise to sparse automatically.


\chapter{kcov: code coverage for fuzzing}
\label{dev-tools/kcov::doc}\label{dev-tools/kcov:kcov-code-coverage-for-fuzzing}
kcov exposes kernel code coverage information in a form suitable for coverage-
guided fuzzing (randomized testing). Coverage data of a running kernel is
exported via the ``kcov'' debugfs file. Coverage collection is enabled on a task
basis, and thus it can capture precise coverage of a single system call.

Note that kcov does not aim to collect as much coverage as possible. It aims
to collect more or less stable coverage that is function of syscall inputs.
To achieve this goal it does not collect coverage in soft/hard interrupts
and instrumentation of some inherently non-deterministic parts of kernel is
disabled (e.g. scheduler, locking).

kcov is also able to collect comparison operands from the instrumented code
(this feature currently requires that the kernel is compiled with clang).


\section{Prerequisites}
\label{dev-tools/kcov:prerequisites}
Configure the kernel with:

\begin{Verbatim}[commandchars=\\\{\}]
CONFIG\PYGZus{}KCOV=y
\end{Verbatim}

CONFIG\_KCOV requires gcc built on revision 231296 or later.

If the comparison operands need to be collected, set:

\begin{Verbatim}[commandchars=\\\{\}]
CONFIG\PYGZus{}KCOV\PYGZus{}ENABLE\PYGZus{}COMPARISONS=y
\end{Verbatim}

Profiling data will only become accessible once debugfs has been mounted:

\begin{Verbatim}[commandchars=\\\{\}]
mount \PYGZhy{}t debugfs none /sys/kernel/debug
\end{Verbatim}


\section{Coverage collection}
\label{dev-tools/kcov:coverage-collection}
The following program demonstrates coverage collection from within a test
program using kcov:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stddef.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdint.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sys/types.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sys/stat.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sys/ioctl.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sys/mman.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}unistd.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}fcntl.h\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define KCOV\PYGZus{}INIT\PYGZus{}TRACE                     \PYGZus{}IOR(\PYGZsq{}c\PYGZsq{}, 1, unsigned long)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define KCOV\PYGZus{}ENABLE                 \PYGZus{}IO(\PYGZsq{}c\PYGZsq{}, 100)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define KCOV\PYGZus{}DISABLE                        \PYGZus{}IO(\PYGZsq{}c\PYGZsq{}, 101)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define COVER\PYGZus{}SIZE                  (64\PYGZlt{}\PYGZlt{}10)}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define KCOV\PYGZus{}TRACE\PYGZus{}PC  0}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define KCOV\PYGZus{}TRACE\PYGZus{}CMP 1}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*}\PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{fd}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{o}{*}\PYG{n}{cover}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{n}{i}\PYG{p}{;}

    \PYG{c+cm}{/* A single fd descriptor allows coverage collection on a single}
\PYG{c+cm}{     * thread.}
\PYG{c+cm}{     */}
    \PYG{n}{fd} \PYG{o}{=} \PYG{n}{open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/sys/kernel/debug/kcov}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{O\PYGZus{}RDWR}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{fd} \PYG{o}{=}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{n}{perror}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{open}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/* Setup trace mode and trace size. */}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{KCOV\PYGZus{}INIT\PYGZus{}TRACE}\PYG{p}{,} \PYG{n}{COVER\PYGZus{}SIZE}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{perror}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ioctl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/* Mmap buffer shared between kernel\PYGZhy{} and user\PYGZhy{}space. */}
    \PYG{n}{cover} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{o}{*}\PYG{p}{)}\PYG{n}{mmap}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n}{COVER\PYGZus{}SIZE} \PYG{o}{*} \PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{p}{,}
                                 \PYG{n}{PROT\PYGZus{}READ} \PYG{o}{\textbar{}} \PYG{n}{PROT\PYGZus{}WRITE}\PYG{p}{,} \PYG{n}{MAP\PYGZus{}SHARED}\PYG{p}{,} \PYG{n}{fd}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{)}\PYG{n}{cover} \PYG{o}{=}\PYG{o}{=} \PYG{n}{MAP\PYGZus{}FAILED}\PYG{p}{)}
            \PYG{n}{perror}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mmap}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/* Enable coverage collection on the current thread. */}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{KCOV\PYGZus{}ENABLE}\PYG{p}{,} \PYG{n}{KCOV\PYGZus{}TRACE\PYGZus{}PC}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{perror}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ioctl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/* Reset coverage from the tail of the ioctl() call. */}
    \PYG{n}{\PYGZus{}\PYGZus{}atomic\PYGZus{}store\PYGZus{}n}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{cover}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{\PYGZus{}\PYGZus{}ATOMIC\PYGZus{}RELAXED}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/* That\PYGZsq{}s the target syscal call. */}
    \PYG{n}{read}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/* Read number of PCs collected. */}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{\PYGZus{}\PYGZus{}atomic\PYGZus{}load\PYGZus{}n}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{cover}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{\PYGZus{}\PYGZus{}ATOMIC\PYGZus{}RELAXED}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0x\PYGZpc{}lx}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{cover}\PYG{p}{[}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/* Disable coverage collection for the current thread. After this call}
\PYG{c+cm}{     * coverage can be enabled for a different thread.}
\PYG{c+cm}{     */}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{KCOV\PYGZus{}DISABLE}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{perror}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ioctl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/* Free resources. */}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{munmap}\PYG{p}{(}\PYG{n}{cover}\PYG{p}{,} \PYG{n}{COVER\PYGZus{}SIZE} \PYG{o}{*} \PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{perror}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{munmap}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{close}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{perror}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{close}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

After piping through addr2line output of the program looks as follows:

\begin{Verbatim}[commandchars=\\\{\}]
SyS\PYGZus{}read
fs/read\PYGZus{}write.c:562
\PYGZus{}\PYGZus{}fdget\PYGZus{}pos
fs/file.c:774
\PYGZus{}\PYGZus{}fget\PYGZus{}light
fs/file.c:746
\PYGZus{}\PYGZus{}fget\PYGZus{}light
fs/file.c:750
\PYGZus{}\PYGZus{}fget\PYGZus{}light
fs/file.c:760
\PYGZus{}\PYGZus{}fdget\PYGZus{}pos
fs/file.c:784
SyS\PYGZus{}read
fs/read\PYGZus{}write.c:562
\end{Verbatim}

If a program needs to collect coverage from several threads (independently),
it needs to open /sys/kernel/debug/kcov in each thread separately.

The interface is fine-grained to allow efficient forking of test processes.
That is, a parent process opens /sys/kernel/debug/kcov, enables trace mode,
mmaps coverage buffer and then forks child processes in a loop. Child processes
only need to enable coverage (disable happens automatically on thread end).


\section{Comparison operands collection}
\label{dev-tools/kcov:comparison-operands-collection}
Comparison operands collection is similar to coverage collection:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Same includes and defines as above. */}

\PYG{c+cm}{/* Number of 64\PYGZhy{}bit words per record. */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define KCOV\PYGZus{}WORDS\PYGZus{}PER\PYGZus{}CMP 4}

\PYG{c+cm}{/*}
\PYG{c+cm}{ * The format for the types of collected comparisons.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * Bit 0 shows whether one of the arguments is a compile\PYGZhy{}time constant.}
\PYG{c+cm}{ * Bits 1 \PYGZam{} 2 contain log2 of the argument size, up to 8 bytes.}
\PYG{c+cm}{ */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define KCOV\PYGZus{}CMP\PYGZus{}CONST          (1 \PYGZlt{}\PYGZlt{} 0)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define KCOV\PYGZus{}CMP\PYGZus{}SIZE(n)        ((n) \PYGZlt{}\PYGZlt{} 1)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define KCOV\PYGZus{}CMP\PYGZus{}MASK           KCOV\PYGZus{}CMP\PYGZus{}SIZE(3)}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*}\PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{fd}\PYG{p}{;}
    \PYG{k+kt}{uint64\PYGZus{}t} \PYG{o}{*}\PYG{n}{cover}\PYG{p}{,} \PYG{n}{type}\PYG{p}{,} \PYG{n}{arg1}\PYG{p}{,} \PYG{n}{arg2}\PYG{p}{,} \PYG{n}{is\PYGZus{}const}\PYG{p}{,} \PYG{n}{size}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{n}\PYG{p}{,} \PYG{n}{i}\PYG{p}{;}

    \PYG{n}{fd} \PYG{o}{=} \PYG{n}{open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/sys/kernel/debug/kcov}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{O\PYGZus{}RDWR}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{fd} \PYG{o}{=}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{n}{perror}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{open}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{KCOV\PYGZus{}INIT\PYGZus{}TRACE}\PYG{p}{,} \PYG{n}{COVER\PYGZus{}SIZE}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{perror}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ioctl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/*}
\PYG{c+cm}{    * Note that the buffer pointer is of type uint64\PYGZus{}t*, because all}
\PYG{c+cm}{    * the comparison operands are promoted to uint64\PYGZus{}t.}
\PYG{c+cm}{    */}
    \PYG{n}{cover} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{uint64\PYGZus{}t} \PYG{o}{*}\PYG{p}{)}\PYG{n}{mmap}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n}{COVER\PYGZus{}SIZE} \PYG{o}{*} \PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{p}{,}
                                 \PYG{n}{PROT\PYGZus{}READ} \PYG{o}{\textbar{}} \PYG{n}{PROT\PYGZus{}WRITE}\PYG{p}{,} \PYG{n}{MAP\PYGZus{}SHARED}\PYG{p}{,} \PYG{n}{fd}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{)}\PYG{n}{cover} \PYG{o}{=}\PYG{o}{=} \PYG{n}{MAP\PYGZus{}FAILED}\PYG{p}{)}
            \PYG{n}{perror}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mmap}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/* Note KCOV\PYGZus{}TRACE\PYGZus{}CMP instead of KCOV\PYGZus{}TRACE\PYGZus{}PC. */}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{KCOV\PYGZus{}ENABLE}\PYG{p}{,} \PYG{n}{KCOV\PYGZus{}TRACE\PYGZus{}CMP}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{perror}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ioctl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{\PYGZus{}\PYGZus{}atomic\PYGZus{}store\PYGZus{}n}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{cover}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{\PYGZus{}\PYGZus{}ATOMIC\PYGZus{}RELAXED}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{read}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/* Read number of comparisons collected. */}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{\PYGZus{}\PYGZus{}atomic\PYGZus{}load\PYGZus{}n}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{cover}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{\PYGZus{}\PYGZus{}ATOMIC\PYGZus{}RELAXED}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{type} \PYG{o}{=} \PYG{n}{cover}\PYG{p}{[}\PYG{n}{i} \PYG{o}{*} \PYG{n}{KCOV\PYGZus{}WORDS\PYGZus{}PER\PYGZus{}CMP} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
            \PYG{c+cm}{/* arg1 and arg2 \PYGZhy{} operands of the comparison. */}
            \PYG{n}{arg1} \PYG{o}{=} \PYG{n}{cover}\PYG{p}{[}\PYG{n}{i} \PYG{o}{*} \PYG{n}{KCOV\PYGZus{}WORDS\PYGZus{}PER\PYGZus{}CMP} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{arg2} \PYG{o}{=} \PYG{n}{cover}\PYG{p}{[}\PYG{n}{i} \PYG{o}{*} \PYG{n}{KCOV\PYGZus{}WORDS\PYGZus{}PER\PYGZus{}CMP} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
            \PYG{c+cm}{/* ip \PYGZhy{} caller address. */}
            \PYG{n}{ip} \PYG{o}{=} \PYG{n}{cover}\PYG{p}{[}\PYG{n}{i} \PYG{o}{*} \PYG{n}{KCOV\PYGZus{}WORDS\PYGZus{}PER\PYGZus{}CMP} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
            \PYG{c+cm}{/* size of the operands. */}
            \PYG{n}{size} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{p}{(}\PYG{n}{type} \PYG{o}{\PYGZam{}} \PYG{n}{KCOV\PYGZus{}CMP\PYGZus{}MASK}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{c+cm}{/* is\PYGZus{}const \PYGZhy{} true if either operand is a compile\PYGZhy{}time constant.*/}
            \PYG{n}{is\PYGZus{}const} \PYG{o}{=} \PYG{n}{type} \PYG{o}{\PYGZam{}} \PYG{n}{KCOV\PYGZus{}CMP\PYGZus{}CONST}\PYG{p}{;}
            \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ip: 0x\PYGZpc{}lx type: 0x\PYGZpc{}lx, arg1: 0x\PYGZpc{}lx, arg2: 0x\PYGZpc{}lx, }\PYG{l+s}{\PYGZdq{}}
                    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{size: \PYGZpc{}lu, \PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                    \PYG{n}{ip}\PYG{p}{,} \PYG{n}{type}\PYG{p}{,} \PYG{n}{arg1}\PYG{p}{,} \PYG{n}{arg2}\PYG{p}{,} \PYG{n}{size}\PYG{p}{,}
            \PYG{n}{is\PYGZus{}const} \PYG{o}{?} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{const}\PYG{l+s}{\PYGZdq{}} \PYG{o}{:} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{non\PYGZhy{}const}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{KCOV\PYGZus{}DISABLE}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{perror}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ioctl}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/* Free resources. */}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{munmap}\PYG{p}{(}\PYG{n}{cover}\PYG{p}{,} \PYG{n}{COVER\PYGZus{}SIZE} \PYG{o}{*} \PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{perror}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{munmap}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{close}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{perror}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{close}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Note that the kcov modes (coverage collection or comparison operands) are
mutually exclusive.


\chapter{Using gcov with the Linux kernel}
\label{dev-tools/gcov:using-gcov-with-the-linux-kernel}\label{dev-tools/gcov::doc}
gcov profiling kernel support enables the use of GCC's coverage testing
tool \href{http://gcc.gnu.org/onlinedocs/gcc/Gcov.html}{gcov} with the Linux kernel. Coverage data of a running kernel
is exported in gcov-compatible format via the ``gcov'' debugfs directory.
To get coverage data for a specific file, change to the kernel build
directory and use gcov with the \code{-o} option as follows (requires root):

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} cd /tmp/linux\PYGZhy{}out
\PYGZsh{} gcov \PYGZhy{}o /sys/kernel/debug/gcov/tmp/linux\PYGZhy{}out/kernel spinlock.c
\end{Verbatim}

This will create source code files annotated with execution counts
in the current directory. In addition, graphical gcov front-ends such
as \href{http://ltp.sourceforge.net/coverage/lcov.php}{lcov} can be used to automate the process of collecting data
for the entire kernel and provide coverage overviews in HTML format.

Possible uses:
\begin{itemize}
\item {} 
debugging (has this line been reached at all?)

\item {} 
test improvement (how do I change my test to cover these lines?)

\item {} 
minimizing kernel configurations (do I need this option if the
associated code is never run?)

\end{itemize}


\section{Preparation}
\label{dev-tools/gcov:preparation}\label{dev-tools/gcov:lcov}
Configure the kernel with:

\begin{Verbatim}[commandchars=\\\{\}]
CONFIG\PYGZus{}DEBUG\PYGZus{}FS=y
CONFIG\PYGZus{}GCOV\PYGZus{}KERNEL=y
\end{Verbatim}

select the gcc's gcov format, default is autodetect based on gcc version:

\begin{Verbatim}[commandchars=\\\{\}]
CONFIG\PYGZus{}GCOV\PYGZus{}FORMAT\PYGZus{}AUTODETECT=y
\end{Verbatim}

and to get coverage data for the entire kernel:

\begin{Verbatim}[commandchars=\\\{\}]
CONFIG\PYGZus{}GCOV\PYGZus{}PROFILE\PYGZus{}ALL=y
\end{Verbatim}

Note that kernels compiled with profiling flags will be significantly
larger and run slower. Also CONFIG\_GCOV\_PROFILE\_ALL may not be supported
on all architectures.

Profiling data will only become accessible once debugfs has been
mounted:

\begin{Verbatim}[commandchars=\\\{\}]
mount \PYGZhy{}t debugfs none /sys/kernel/debug
\end{Verbatim}


\section{Customization}
\label{dev-tools/gcov:customization}
To enable profiling for specific files or directories, add a line
similar to the following to the respective kernel Makefile:
\begin{itemize}
\item {} 
For a single file (e.g. main.o):

\begin{Verbatim}[commandchars=\\\{\}]
GCOV\PYGZus{}PROFILE\PYGZus{}main.o := y
\end{Verbatim}

\item {} 
For all files in one directory:

\begin{Verbatim}[commandchars=\\\{\}]
GCOV\PYGZus{}PROFILE := y
\end{Verbatim}

\end{itemize}

To exclude files from being profiled even when CONFIG\_GCOV\_PROFILE\_ALL
is specified, use:

\begin{Verbatim}[commandchars=\\\{\}]
GCOV\PYGZus{}PROFILE\PYGZus{}main.o := n
\end{Verbatim}

and:

\begin{Verbatim}[commandchars=\\\{\}]
GCOV\PYGZus{}PROFILE := n
\end{Verbatim}

Only files which are linked to the main kernel image or are compiled as
kernel modules are supported by this mechanism.


\section{Files}
\label{dev-tools/gcov:files}
The gcov kernel support creates the following files in debugfs:
\begin{description}
\item[{\code{/sys/kernel/debug/gcov}}] \leavevmode
Parent directory for all gcov-related files.

\item[{\code{/sys/kernel/debug/gcov/reset}}] \leavevmode
Global reset file: resets all coverage data to zero when
written to.

\item[{\code{/sys/kernel/debug/gcov/path/to/compile/dir/file.gcda}}] \leavevmode
The actual gcov data file as understood by the gcov
tool. Resets file coverage data to zero when written to.

\item[{\code{/sys/kernel/debug/gcov/path/to/compile/dir/file.gcno}}] \leavevmode
Symbolic link to a static data file required by the gcov
tool. This file is generated by gcc when compiling with
option \code{-ftest-coverage}.

\end{description}


\section{Modules}
\label{dev-tools/gcov:modules}
Kernel modules may contain cleanup code which is only run during
module unload time. The gcov mechanism provides a means to collect
coverage data for such code by keeping a copy of the data associated
with the unloaded module. This data remains available through debugfs.
Once the module is loaded again, the associated coverage counters are
initialized with the data from its previous instantiation.

This behavior can be deactivated by specifying the gcov\_persist kernel
parameter:

\begin{Verbatim}[commandchars=\\\{\}]
gcov\PYGZus{}persist=0
\end{Verbatim}

At run-time, a user can also choose to discard data for an unloaded
module by writing to its data file or the global reset file.


\section{Separated build and test machines}
\label{dev-tools/gcov:separated-build-and-test-machines}
The gcov kernel profiling infrastructure is designed to work out-of-the
box for setups where kernels are built and run on the same machine. In
cases where the kernel runs on a separate machine, special preparations
must be made, depending on where the gcov tool is used:
\begin{enumerate}
\item {} 
gcov is run on the TEST machine
\begin{quote}

The gcov tool version on the test machine must be compatible with the
gcc version used for kernel build. Also the following files need to be
copied from build to test machine:
\begin{description}
\item[{from the source tree:}] \leavevmode\begin{itemize}
\item {} 
all C source files + headers

\end{itemize}

\item[{from the build tree:}] \leavevmode\begin{itemize}
\item {} 
all C source files + headers

\item {} 
all .gcda and .gcno files

\item {} 
all links to directories

\end{itemize}

\end{description}

It is important to note that these files need to be placed into the
exact same file system location on the test machine as on the build
machine. If any of the path components is symbolic link, the actual
directory needs to be used instead (due to make's CURDIR handling).
\end{quote}

\item {} 
gcov is run on the BUILD machine
\begin{quote}

The following files need to be copied after each test case from test
to build machine:
\begin{description}
\item[{from the gcov directory in sysfs:}] \leavevmode\begin{itemize}
\item {} 
all .gcda files

\item {} 
all links to .gcno files

\end{itemize}

\end{description}

These files can be copied to any location on the build machine. gcov
must then be called with the -o option pointing to that directory.

Example directory setup on the build machine:

\begin{Verbatim}[commandchars=\\\{\}]
/tmp/linux:    kernel source tree
/tmp/out:      kernel build directory as specified by make O=
/tmp/coverage: location of the files copied from the test machine

[user@build] cd /tmp/out
[user@build] gcov \PYGZhy{}o /tmp/coverage/tmp/out/init main.c
\end{Verbatim}
\end{quote}

\end{enumerate}


\section{Troubleshooting}
\label{dev-tools/gcov:troubleshooting}\begin{description}
\item[{Problem}] \leavevmode
Compilation aborts during linker step.

\item[{Cause}] \leavevmode
Profiling flags are specified for source files which are not
linked to the main kernel or which are linked by a custom
linker procedure.

\item[{Solution}] \leavevmode
Exclude affected source files from profiling by specifying
\code{GCOV\_PROFILE := n} or \code{GCOV\_PROFILE\_basename.o := n} in the
corresponding Makefile.

\item[{Problem}] \leavevmode
Files copied from sysfs appear empty or incomplete.

\item[{Cause}] \leavevmode
Due to the way seq\_file works, some tools such as cp or tar
may not correctly copy files from sysfs.

\item[{Solution}] \leavevmode
Use \code{cat}` to read \code{.gcda} files and \code{cp -d} to copy links.
Alternatively use the mechanism shown in Appendix B.

\end{description}


\section{Appendix A: gather\_on\_build.sh}
\label{dev-tools/gcov:appendix-a-gather-on-build-sh}
Sample script to gather coverage meta files on the build machine
(see 6a):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}

\PYG{n+nv}{KSRC}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}1}
\PYG{n+nv}{KOBJ}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}2}
\PYG{n+nv}{DEST}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}3}

\PYG{k}{if} \PYG{o}{[} \PYGZhy{}z \PYG{l+s+s2}{\PYGZdq{}}\PYGZdl{}\PYG{l+s+s2}{KSRC}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{]} \PYG{o}{\textbar{}\textbar{}} \PYG{o}{[} \PYGZhy{}z \PYG{l+s+s2}{\PYGZdq{}}\PYGZdl{}\PYG{l+s+s2}{KOBJ}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{]} \PYG{o}{\textbar{}\textbar{}} \PYG{o}{[} \PYGZhy{}z \PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}DE}\PYG{l+s+s2}{ST}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{]}\PYG{p}{;} \PYG{k}{then}
  \PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Usage: }\PYG{n+nv}{\PYGZdl{}0}\PYG{l+s+s2}{ \PYGZlt{}ksrc directory\PYGZgt{} \PYGZlt{}kobj directory\PYGZgt{} \PYGZlt{}output.tar.gz\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}} \PYGZgt{}\PYG{p}{\PYGZam{}}2
  \PYG{n+nb}{exit} 1
\PYG{k}{fi}

\PYG{n+nv}{KSRC}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}\PYG{n+nb}{cd} \PYGZdl{}KSRC\PYG{p}{;} \PYG{n+nb}{printf} \PYG{l+s+s2}{\PYGZdq{}all:\PYGZbs{}n\PYGZbs{}t@echo \PYGZbs{}\PYGZdl{}\PYGZob{}CURDIR\PYGZcb{}\PYGZbs{}n\PYGZdq{}} \PYG{p}{\textbar{}} make \PYGZhy{}f \PYGZhy{}\PYG{k}{)}
\PYG{n+nv}{KOBJ}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}\PYG{n+nb}{cd} \PYGZdl{}KOBJ\PYG{p}{;} \PYG{n+nb}{printf} \PYG{l+s+s2}{\PYGZdq{}all:\PYGZbs{}n\PYGZbs{}t@echo \PYGZbs{}\PYGZdl{}\PYGZob{}CURDIR\PYGZcb{}\PYGZbs{}n\PYGZdq{}} \PYG{p}{\textbar{}} make \PYGZhy{}f \PYGZhy{}\PYG{k}{)}

find \PYGZdl{}KSRC \PYGZdl{}KOBJ \PYG{l+s+se}{\PYGZbs{}(} \PYGZhy{}name \PYG{l+s+s1}{\PYGZsq{}*.gcno\PYGZsq{}} \PYGZhy{}o \PYGZhy{}name \PYG{l+s+s1}{\PYGZsq{}*.[ch]\PYGZsq{}} \PYGZhy{}o \PYGZhy{}type l \PYG{l+s+se}{\PYGZbs{})} \PYGZhy{}a \PYG{l+s+se}{\PYGZbs{}}
                 \PYGZhy{}perm /u+r,g+r \PYG{p}{\textbar{}} tar cfz \PYG{n+nv}{\PYGZdl{}DE}ST \PYGZhy{}P \PYGZhy{}T \PYGZhy{}

\PYG{k}{if} \PYG{o}{[} \PYG{n+nv}{\PYGZdl{}?} \PYGZhy{}eq \PYG{l+m}{0} \PYG{o}{]} \PYG{p}{;} \PYG{k}{then}
  \PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}DE}\PYG{l+s+s2}{ST successfully created, copy to test system and unpack with:}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{  tar xfz }\PYG{n+nv}{\PYGZdl{}DE}\PYG{l+s+s2}{ST \PYGZhy{}P}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{else}
  \PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Could not create file }\PYG{n+nv}{\PYGZdl{}DE}\PYG{l+s+s2}{ST}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{fi}
\end{Verbatim}


\section{Appendix B: gather\_on\_test.sh}
\label{dev-tools/gcov:appendix-b-gather-on-test-sh}
Sample script to gather coverage data files on the test machine
(see 6b):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash \PYGZhy{}e}

\PYG{n+nv}{DEST}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}1}
\PYG{n+nv}{GCDA}\PYG{o}{=}/sys/kernel/debug/gcov

\PYG{k}{if} \PYG{o}{[} \PYGZhy{}z \PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}DE}\PYG{l+s+s2}{ST}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{]} \PYG{p}{;} \PYG{k}{then}
  \PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Usage: }\PYG{n+nv}{\PYGZdl{}0}\PYG{l+s+s2}{ \PYGZlt{}output.tar.gz\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}} \PYGZgt{}\PYG{p}{\PYGZam{}}2
  \PYG{n+nb}{exit} 1
\PYG{k}{fi}

\PYG{n+nv}{TEMPDIR}\PYG{o}{=}\PYG{k}{\PYGZdl{}(}mktemp \PYGZhy{}d\PYG{k}{)}
\PYG{n+nb}{echo} Collecting data..
find \PYGZdl{}GCDA \PYGZhy{}type d \PYGZhy{}exec mkdir \PYGZhy{}p \PYGZdl{}TEMPDIR/\PYG{l+s+se}{\PYGZbs{}\PYGZob{}}\PYG{l+s+se}{\PYGZbs{}\PYGZcb{}} \PYG{l+s+se}{\PYGZbs{};}
find \PYGZdl{}GCDA \PYGZhy{}name \PYG{l+s+s1}{\PYGZsq{}*.gcda\PYGZsq{}} \PYGZhy{}exec sh \PYGZhy{}c \PYG{l+s+s1}{\PYGZsq{}cat \PYGZlt{} \PYGZdl{}0 \PYGZgt{} \PYGZsq{}}\PYGZdl{}TEMPDIR\PYG{l+s+s1}{\PYGZsq{}/\PYGZdl{}0\PYGZsq{}} \PYG{o}{\PYGZob{}}\PYG{o}{\PYGZcb{}} \PYG{l+s+se}{\PYGZbs{};}
find \PYGZdl{}GCDA \PYGZhy{}name \PYG{l+s+s1}{\PYGZsq{}*.gcno\PYGZsq{}} \PYGZhy{}exec sh \PYGZhy{}c \PYG{l+s+s1}{\PYGZsq{}cp \PYGZhy{}d \PYGZdl{}0 \PYGZsq{}}\PYGZdl{}TEMPDIR\PYG{l+s+s1}{\PYGZsq{}/\PYGZdl{}0\PYGZsq{}} \PYG{o}{\PYGZob{}}\PYG{o}{\PYGZcb{}} \PYG{l+s+se}{\PYGZbs{};}
tar czf \PYG{n+nv}{\PYGZdl{}DE}ST \PYGZhy{}C \PYGZdl{}TEMPDIR sys
rm \PYGZhy{}rf \PYGZdl{}TEMPDIR

\PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}DE}\PYG{l+s+s2}{ST successfully created, copy to build system and unpack with:}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{  tar xfz }\PYG{n+nv}{\PYGZdl{}DE}\PYG{l+s+s2}{ST}\PYG{l+s+s2}{\PYGZdq{}}
\end{Verbatim}


\chapter{The Kernel Address Sanitizer (KASAN)}
\label{dev-tools/kasan:the-kernel-address-sanitizer-kasan}\label{dev-tools/kasan::doc}

\section{Overview}
\label{dev-tools/kasan:overview}
KernelAddressSANitizer (KASAN) is a dynamic memory error detector. It provides
a fast and comprehensive solution for finding use-after-free and out-of-bounds
bugs.

KASAN uses compile-time instrumentation for checking every memory access,
therefore you will need a GCC version 4.9.2 or later. GCC 5.0 or later is
required for detection of out-of-bounds accesses to stack or global variables.

Currently KASAN is supported only for the x86\_64 and arm64 architectures.


\section{Usage}
\label{dev-tools/kasan:usage}
To enable KASAN configure kernel with:

\begin{Verbatim}[commandchars=\\\{\}]
CONFIG\PYGZus{}KASAN = y
\end{Verbatim}

and choose between CONFIG\_KASAN\_OUTLINE and CONFIG\_KASAN\_INLINE. Outline and
inline are compiler instrumentation types. The former produces smaller binary
the latter is 1.1 - 2 times faster. Inline instrumentation requires a GCC
version 5.0 or later.

KASAN works with both SLUB and SLAB memory allocators.
For better bug detection and nicer reporting, enable CONFIG\_STACKTRACE.

To disable instrumentation for specific files or directories, add a line
similar to the following to the respective kernel Makefile:
\begin{itemize}
\item {} 
For a single file (e.g. main.o):

\begin{Verbatim}[commandchars=\\\{\}]
KASAN\PYGZus{}SANITIZE\PYGZus{}main.o := n
\end{Verbatim}

\item {} 
For all files in one directory:

\begin{Verbatim}[commandchars=\\\{\}]
KASAN\PYGZus{}SANITIZE := n
\end{Verbatim}

\end{itemize}


\subsection{Error reports}
\label{dev-tools/kasan:error-reports}
A typical out of bounds access report looks like this:

\begin{Verbatim}[commandchars=\\\{\}]
==================================================================
BUG: AddressSanitizer: out of bounds access in kmalloc\PYGZus{}oob\PYGZus{}right+0x65/0x75 [test\PYGZus{}kasan] at addr ffff8800693bc5d3
Write of size 1 by task modprobe/1689
=============================================================================
BUG kmalloc\PYGZhy{}128 (Not tainted): kasan error
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}

Disabling lock debugging due to kernel taint
INFO: Allocated in kmalloc\PYGZus{}oob\PYGZus{}right+0x3d/0x75 [test\PYGZus{}kasan] age=0 cpu=0 pid=1689
 \PYGZus{}\PYGZus{}slab\PYGZus{}alloc+0x4b4/0x4f0
 kmem\PYGZus{}cache\PYGZus{}alloc\PYGZus{}trace+0x10b/0x190
 kmalloc\PYGZus{}oob\PYGZus{}right+0x3d/0x75 [test\PYGZus{}kasan]
 init\PYGZus{}module+0x9/0x47 [test\PYGZus{}kasan]
 do\PYGZus{}one\PYGZus{}initcall+0x99/0x200
 load\PYGZus{}module+0x2cb3/0x3b20
 SyS\PYGZus{}finit\PYGZus{}module+0x76/0x80
 system\PYGZus{}call\PYGZus{}fastpath+0x12/0x17
INFO: Slab 0xffffea0001a4ef00 objects=17 used=7 fp=0xffff8800693bd728 flags=0x100000000004080
INFO: Object 0xffff8800693bc558 @offset=1368 fp=0xffff8800693bc720

Bytes b4 ffff8800693bc548: 00 00 00 00 00 00 00 00 5a 5a 5a 5a 5a 5a 5a 5a  ........ZZZZZZZZ
Object ffff8800693bc558: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
Object ffff8800693bc568: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
Object ffff8800693bc578: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
Object ffff8800693bc588: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
Object ffff8800693bc598: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
Object ffff8800693bc5a8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
Object ffff8800693bc5b8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
Object ffff8800693bc5c8: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b a5  kkkkkkkkkkkkkkk.
Redzone ffff8800693bc5d8: cc cc cc cc cc cc cc cc                          ........
Padding ffff8800693bc718: 5a 5a 5a 5a 5a 5a 5a 5a                          ZZZZZZZZ
CPU: 0 PID: 1689 Comm: modprobe Tainted: G    B          3.18.0\PYGZhy{}rc1\PYGZhy{}mm1+ \PYGZsh{}98
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel\PYGZhy{}1.7.5\PYGZhy{}0\PYGZhy{}ge51488c\PYGZhy{}20140602\PYGZus{}164612\PYGZhy{}nilsson.home.kraxel.org 04/01/2014
 ffff8800693bc000 0000000000000000 ffff8800693bc558 ffff88006923bb78
 ffffffff81cc68ae 00000000000000f3 ffff88006d407600 ffff88006923bba8
 ffffffff811fd848 ffff88006d407600 ffffea0001a4ef00 ffff8800693bc558
Call Trace:
 [\PYGZlt{}ffffffff81cc68ae\PYGZgt{}] dump\PYGZus{}stack+0x46/0x58
 [\PYGZlt{}ffffffff811fd848\PYGZgt{}] print\PYGZus{}trailer+0xf8/0x160
 [\PYGZlt{}ffffffffa00026a7\PYGZgt{}] ? kmem\PYGZus{}cache\PYGZus{}oob+0xc3/0xc3 [test\PYGZus{}kasan]
 [\PYGZlt{}ffffffff811ff0f5\PYGZgt{}] object\PYGZus{}err+0x35/0x40
 [\PYGZlt{}ffffffffa0002065\PYGZgt{}] ? kmalloc\PYGZus{}oob\PYGZus{}right+0x65/0x75 [test\PYGZus{}kasan]
 [\PYGZlt{}ffffffff8120b9fa\PYGZgt{}] kasan\PYGZus{}report\PYGZus{}error+0x38a/0x3f0
 [\PYGZlt{}ffffffff8120a79f\PYGZgt{}] ? kasan\PYGZus{}poison\PYGZus{}shadow+0x2f/0x40
 [\PYGZlt{}ffffffff8120b344\PYGZgt{}] ? kasan\PYGZus{}unpoison\PYGZus{}shadow+0x14/0x40
 [\PYGZlt{}ffffffff8120a79f\PYGZgt{}] ? kasan\PYGZus{}poison\PYGZus{}shadow+0x2f/0x40
 [\PYGZlt{}ffffffffa00026a7\PYGZgt{}] ? kmem\PYGZus{}cache\PYGZus{}oob+0xc3/0xc3 [test\PYGZus{}kasan]
 [\PYGZlt{}ffffffff8120a995\PYGZgt{}] \PYGZus{}\PYGZus{}asan\PYGZus{}store1+0x75/0xb0
 [\PYGZlt{}ffffffffa0002601\PYGZgt{}] ? kmem\PYGZus{}cache\PYGZus{}oob+0x1d/0xc3 [test\PYGZus{}kasan]
 [\PYGZlt{}ffffffffa0002065\PYGZgt{}] ? kmalloc\PYGZus{}oob\PYGZus{}right+0x65/0x75 [test\PYGZus{}kasan]
 [\PYGZlt{}ffffffffa0002065\PYGZgt{}] kmalloc\PYGZus{}oob\PYGZus{}right+0x65/0x75 [test\PYGZus{}kasan]
 [\PYGZlt{}ffffffffa00026b0\PYGZgt{}] init\PYGZus{}module+0x9/0x47 [test\PYGZus{}kasan]
 [\PYGZlt{}ffffffff810002d9\PYGZgt{}] do\PYGZus{}one\PYGZus{}initcall+0x99/0x200
 [\PYGZlt{}ffffffff811e4e5c\PYGZgt{}] ? \PYGZus{}\PYGZus{}vunmap+0xec/0x160
 [\PYGZlt{}ffffffff81114f63\PYGZgt{}] load\PYGZus{}module+0x2cb3/0x3b20
 [\PYGZlt{}ffffffff8110fd70\PYGZgt{}] ? m\PYGZus{}show+0x240/0x240
 [\PYGZlt{}ffffffff81115f06\PYGZgt{}] SyS\PYGZus{}finit\PYGZus{}module+0x76/0x80
 [\PYGZlt{}ffffffff81cd3129\PYGZgt{}] system\PYGZus{}call\PYGZus{}fastpath+0x12/0x17
Memory state around the buggy address:
 ffff8800693bc300: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff8800693bc380: fc fc 00 00 00 00 00 00 00 00 00 00 00 00 00 fc
 ffff8800693bc400: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff8800693bc480: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff8800693bc500: fc fc fc fc fc fc fc fc fc fc fc 00 00 00 00 00
\PYGZgt{}ffff8800693bc580: 00 00 00 00 00 00 00 00 00 00 03 fc fc fc fc fc
                                             \PYGZca{}
 ffff8800693bc600: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff8800693bc680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff8800693bc700: fc fc fc fc fb fb fb fb fb fb fb fb fb fb fb fb
 ffff8800693bc780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff8800693bc800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
==================================================================
\end{Verbatim}

The header of the report discribe what kind of bug happened and what kind of
access caused it. It's followed by the description of the accessed slub object
(see `SLUB Debug output' section in Documentation/vm/slub.txt for details) and
the description of the accessed memory page.

In the last section the report shows memory state around the accessed address.
Reading this part requires some understanding of how KASAN works.

The state of each 8 aligned bytes of memory is encoded in one shadow byte.
Those 8 bytes can be accessible, partially accessible, freed or be a redzone.
We use the following encoding for each shadow byte: 0 means that all 8 bytes
of the corresponding memory region are accessible; number N (1 \textless{}= N \textless{}= 7) means
that the first N bytes are accessible, and other (8 - N) bytes are not;
any negative value indicates that the entire 8-byte word is inaccessible.
We use different negative values to distinguish between different kinds of
inaccessible memory like redzones or freed memory (see mm/kasan/kasan.h).

In the report above the arrows point to the shadow byte 03, which means that
the accessed address is partially accessible.


\section{Implementation details}
\label{dev-tools/kasan:implementation-details}
From a high level, our approach to memory error detection is similar to that
of kmemcheck: use shadow memory to record whether each byte of memory is safe
to access, and use compile-time instrumentation to check shadow memory on each
memory access.

AddressSanitizer dedicates 1/8 of kernel memory to its shadow memory
(e.g. 16TB to cover 128TB on x86\_64) and uses direct mapping with a scale and
offset to translate a memory address to its corresponding shadow address.

Here is the function which translates an address to its corresponding shadow
address:

\begin{Verbatim}[commandchars=\\\{\}]
static inline void *kasan\PYGZus{}mem\PYGZus{}to\PYGZus{}shadow(const void *addr)
\PYGZob{}
    return ((unsigned long)addr \PYGZgt{}\PYGZgt{} KASAN\PYGZus{}SHADOW\PYGZus{}SCALE\PYGZus{}SHIFT)
            + KASAN\PYGZus{}SHADOW\PYGZus{}OFFSET;
\PYGZcb{}
\end{Verbatim}

where \code{KASAN\_SHADOW\_SCALE\_SHIFT = 3}.

Compile-time instrumentation used for checking memory accesses. Compiler inserts
function calls (\_\_asan\_load*(addr), \_\_asan\_store*(addr)) before each memory
access of size 1, 2, 4, 8 or 16. These functions check whether memory access is
valid or not by checking corresponding shadow memory.

GCC 5.0 has possibility to perform inline instrumentation. Instead of making
function calls GCC directly inserts the code to check the shadow memory.
This option significantly enlarges kernel but it gives x1.1-x2 performance
boost over outline instrumented kernel.


\chapter{The Undefined Behavior Sanitizer - UBSAN}
\label{dev-tools/ubsan::doc}\label{dev-tools/ubsan:the-undefined-behavior-sanitizer-ubsan}
UBSAN is a runtime undefined behaviour checker.

UBSAN uses compile-time instrumentation to catch undefined behavior (UB).
Compiler inserts code that perform certain kinds of checks before operations
that may cause UB. If check fails (i.e. UB detected) \_\_ubsan\_handle\_*
function called to print error message.

GCC has that feature since 4.9.x {[}\href{https://gcc.gnu.org/onlinedocs/gcc-4.9.0/gcc/Debugging-Options.html}{1}{]} (see \code{-fsanitize=undefined} option and
its suboptions). GCC 5.x has more checkers implemented {[}\href{https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html}{2}{]}.


\section{Report example}
\label{dev-tools/ubsan:report-example}
\begin{Verbatim}[commandchars=\\\{\}]
================================================================================
UBSAN: Undefined behaviour in ../include/linux/bitops.h:110:33
shift exponent 32 is to large for 32\PYGZhy{}bit type \PYGZsq{}unsigned int\PYGZsq{}
CPU: 0 PID: 0 Comm: swapper Not tainted 4.4.0\PYGZhy{}rc1+ \PYGZsh{}26
 0000000000000000 ffffffff82403cc8 ffffffff815e6cd6 0000000000000001
 ffffffff82403cf8 ffffffff82403ce0 ffffffff8163a5ed 0000000000000020
 ffffffff82403d78 ffffffff8163ac2b ffffffff815f0001 0000000000000002
Call Trace:
 [\PYGZlt{}ffffffff815e6cd6\PYGZgt{}] dump\PYGZus{}stack+0x45/0x5f
 [\PYGZlt{}ffffffff8163a5ed\PYGZgt{}] ubsan\PYGZus{}epilogue+0xd/0x40
 [\PYGZlt{}ffffffff8163ac2b\PYGZgt{}] \PYGZus{}\PYGZus{}ubsan\PYGZus{}handle\PYGZus{}shift\PYGZus{}out\PYGZus{}of\PYGZus{}bounds+0xeb/0x130
 [\PYGZlt{}ffffffff815f0001\PYGZgt{}] ? radix\PYGZus{}tree\PYGZus{}gang\PYGZus{}lookup\PYGZus{}slot+0x51/0x150
 [\PYGZlt{}ffffffff8173c586\PYGZgt{}] \PYGZus{}mix\PYGZus{}pool\PYGZus{}bytes+0x1e6/0x480
 [\PYGZlt{}ffffffff83105653\PYGZgt{}] ? dmi\PYGZus{}walk\PYGZus{}early+0x48/0x5c
 [\PYGZlt{}ffffffff8173c881\PYGZgt{}] add\PYGZus{}device\PYGZus{}randomness+0x61/0x130
 [\PYGZlt{}ffffffff83105b35\PYGZgt{}] ? dmi\PYGZus{}save\PYGZus{}one\PYGZus{}device+0xaa/0xaa
 [\PYGZlt{}ffffffff83105653\PYGZgt{}] dmi\PYGZus{}walk\PYGZus{}early+0x48/0x5c
 [\PYGZlt{}ffffffff831066ae\PYGZgt{}] dmi\PYGZus{}scan\PYGZus{}machine+0x278/0x4b4
 [\PYGZlt{}ffffffff8111d58a\PYGZgt{}] ? vprintk\PYGZus{}default+0x1a/0x20
 [\PYGZlt{}ffffffff830ad120\PYGZgt{}] ? early\PYGZus{}idt\PYGZus{}handler\PYGZus{}array+0x120/0x120
 [\PYGZlt{}ffffffff830b2240\PYGZgt{}] setup\PYGZus{}arch+0x405/0xc2c
 [\PYGZlt{}ffffffff830ad120\PYGZgt{}] ? early\PYGZus{}idt\PYGZus{}handler\PYGZus{}array+0x120/0x120
 [\PYGZlt{}ffffffff830ae053\PYGZgt{}] start\PYGZus{}kernel+0x83/0x49a
 [\PYGZlt{}ffffffff830ad120\PYGZgt{}] ? early\PYGZus{}idt\PYGZus{}handler\PYGZus{}array+0x120/0x120
 [\PYGZlt{}ffffffff830ad386\PYGZgt{}] x86\PYGZus{}64\PYGZus{}start\PYGZus{}reservations+0x2a/0x2c
 [\PYGZlt{}ffffffff830ad4f3\PYGZgt{}] x86\PYGZus{}64\PYGZus{}start\PYGZus{}kernel+0x16b/0x17a
================================================================================
\end{Verbatim}


\section{Usage}
\label{dev-tools/ubsan:usage}
To enable UBSAN configure kernel with:

\begin{Verbatim}[commandchars=\\\{\}]
CONFIG\PYGZus{}UBSAN=y
\end{Verbatim}

and to check the entire kernel:

\begin{Verbatim}[commandchars=\\\{\}]
CONFIG\PYGZus{}UBSAN\PYGZus{}SANITIZE\PYGZus{}ALL=y
\end{Verbatim}

To enable instrumentation for specific files or directories, add a line
similar to the following to the respective kernel Makefile:
\begin{itemize}
\item {} 
For a single file (e.g. main.o):

\begin{Verbatim}[commandchars=\\\{\}]
UBSAN\PYGZus{}SANITIZE\PYGZus{}main.o := y
\end{Verbatim}

\item {} 
For all files in one directory:

\begin{Verbatim}[commandchars=\\\{\}]
UBSAN\PYGZus{}SANITIZE := y
\end{Verbatim}

\end{itemize}

To exclude files from being instrumented even if
\code{CONFIG\_UBSAN\_SANITIZE\_ALL=y}, use:

\begin{Verbatim}[commandchars=\\\{\}]
UBSAN\PYGZus{}SANITIZE\PYGZus{}main.o := n
\end{Verbatim}

and:

\begin{Verbatim}[commandchars=\\\{\}]
UBSAN\PYGZus{}SANITIZE := n
\end{Verbatim}

Detection of unaligned accesses controlled through the separate option -
CONFIG\_UBSAN\_ALIGNMENT. It's off by default on architectures that support
unaligned accesses (CONFIG\_HAVE\_EFFICIENT\_UNALIGNED\_ACCESS=y). One could
still enable it in config, just note that it will produce a lot of UBSAN
reports.


\section{References}
\label{dev-tools/ubsan:references}

\chapter{Kernel Memory Leak Detector}
\label{dev-tools/kmemleak::doc}\label{dev-tools/kmemleak:id2}\label{dev-tools/kmemleak:kernel-memory-leak-detector}
Kmemleak provides a way of detecting possible kernel memory leaks in a
way similar to a tracing garbage collector
(\href{https://en.wikipedia.org/wiki/Garbage\_collection\_\%28computer\_science\%29\#Tracing\_garbage\_collectors}{https://en.wikipedia.org/wiki/Garbage\_collection\_\%28computer\_science\%29\#Tracing\_garbage\_collectors}),
with the difference that the orphan objects are not freed but only
reported via /sys/kernel/debug/kmemleak. A similar method is used by the
Valgrind tool (\code{memcheck -{-}leak-check}) to detect the memory leaks in
user-space applications.
Kmemleak is supported on x86, arm, powerpc, sparc, sh, microblaze, ppc, mips, s390, metag and tile.


\section{Usage}
\label{dev-tools/kmemleak:usage}
CONFIG\_DEBUG\_KMEMLEAK in ``Kernel hacking'' has to be enabled. A kernel
thread scans the memory every 10 minutes (by default) and prints the
number of new unreferenced objects found. To display the details of all
the possible memory leaks:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} mount \PYGZhy{}t debugfs nodev /sys/kernel/debug/
\PYGZsh{} cat /sys/kernel/debug/kmemleak
\end{Verbatim}

To trigger an intermediate memory scan:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} echo scan \PYGZgt{} /sys/kernel/debug/kmemleak
\end{Verbatim}

To clear the list of all current possible memory leaks:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} echo clear \PYGZgt{} /sys/kernel/debug/kmemleak
\end{Verbatim}

New leaks will then come up upon reading \code{/sys/kernel/debug/kmemleak}
again.

Note that the orphan objects are listed in the order they were allocated
and one object at the beginning of the list may cause other subsequent
objects to be reported as orphan.

Memory scanning parameters can be modified at run-time by writing to the
\code{/sys/kernel/debug/kmemleak} file. The following parameters are supported:
\begin{itemize}
\item {} \begin{description}
\item[{off}] \leavevmode
disable kmemleak (irreversible)

\end{description}

\item {} \begin{description}
\item[{stack=on}] \leavevmode
enable the task stacks scanning (default)

\end{description}

\item {} \begin{description}
\item[{stack=off}] \leavevmode
disable the tasks stacks scanning

\end{description}

\item {} \begin{description}
\item[{scan=on}] \leavevmode
start the automatic memory scanning thread (default)

\end{description}

\item {} \begin{description}
\item[{scan=off}] \leavevmode
stop the automatic memory scanning thread

\end{description}

\item {} \begin{description}
\item[{scan=\textless{}secs\textgreater{}}] \leavevmode
set the automatic memory scanning period in seconds
(default 600, 0 to stop the automatic scanning)

\end{description}

\item {} \begin{description}
\item[{scan}] \leavevmode
trigger a memory scan

\end{description}

\item {} \begin{description}
\item[{clear}] \leavevmode
clear list of current memory leak suspects, done by
marking all current reported unreferenced objects grey,
or free all kmemleak objects if kmemleak has been disabled.

\end{description}

\item {} \begin{description}
\item[{dump=\textless{}addr\textgreater{}}] \leavevmode
dump information about the object found at \textless{}addr\textgreater{}

\end{description}

\end{itemize}

Kmemleak can also be disabled at boot-time by passing \code{kmemleak=off} on
the kernel command line.

Memory may be allocated or freed before kmemleak is initialised and
these actions are stored in an early log buffer. The size of this buffer
is configured via the CONFIG\_DEBUG\_KMEMLEAK\_EARLY\_LOG\_SIZE option.

If CONFIG\_DEBUG\_KMEMLEAK\_DEFAULT\_OFF are enabled, the kmemleak is
disabled by default. Passing \code{kmemleak=on} on the kernel command
line enables the function.


\section{Basic Algorithm}
\label{dev-tools/kmemleak:basic-algorithm}
The memory allocations via \code{kmalloc()}, \code{vmalloc()},
\code{kmem\_cache\_alloc()} and
friends are traced and the pointers, together with additional
information like size and stack trace, are stored in a rbtree.
The corresponding freeing function calls are tracked and the pointers
removed from the kmemleak data structures.

An allocated block of memory is considered orphan if no pointer to its
start address or to any location inside the block can be found by
scanning the memory (including saved registers). This means that there
might be no way for the kernel to pass the address of the allocated
block to a freeing function and therefore the block is considered a
memory leak.

The scanning algorithm steps:
\begin{enumerate}
\item {} 
mark all objects as white (remaining white objects will later be
considered orphan)

\item {} 
scan the memory starting with the data section and stacks, checking
the values against the addresses stored in the rbtree. If
a pointer to a white object is found, the object is added to the
gray list

\item {} 
scan the gray objects for matching addresses (some white objects
can become gray and added at the end of the gray list) until the
gray set is finished

\item {} 
the remaining white objects are considered orphan and reported via
/sys/kernel/debug/kmemleak

\end{enumerate}

Some allocated memory blocks have pointers stored in the kernel's
internal data structures and they cannot be detected as orphans. To
avoid this, kmemleak can also store the number of values pointing to an
address inside the block address range that need to be found so that the
block is not considered a leak. One example is \_\_vmalloc().


\section{Testing specific sections with kmemleak}
\label{dev-tools/kmemleak:testing-specific-sections-with-kmemleak}
Upon initial bootup your /sys/kernel/debug/kmemleak output page may be
quite extensive. This can also be the case if you have very buggy code
when doing development. To work around these situations you can use the
`clear' command to clear all reported unreferenced objects from the
/sys/kernel/debug/kmemleak output. By issuing a `scan' after a `clear'
you can find new unreferenced objects; this should help with testing
specific sections of code.

To test a critical section on demand with a clean kmemleak do:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} echo clear \PYGZgt{} /sys/kernel/debug/kmemleak
... test your kernel or modules ...
\PYGZsh{} echo scan \PYGZgt{} /sys/kernel/debug/kmemleak
\end{Verbatim}

Then as usual to get your report with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} cat /sys/kernel/debug/kmemleak
\end{Verbatim}


\section{Freeing kmemleak internal objects}
\label{dev-tools/kmemleak:freeing-kmemleak-internal-objects}
To allow access to previously found memory leaks after kmemleak has been
disabled by the user or due to an fatal error, internal kmemleak objects
won't be freed when kmemleak is disabled, and those objects may occupy
a large part of physical memory.

In this situation, you may reclaim memory with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} echo clear \PYGZgt{} /sys/kernel/debug/kmemleak
\end{Verbatim}


\section{Kmemleak API}
\label{dev-tools/kmemleak:kmemleak-api}
See the include/linux/kmemleak.h header for the functions prototype.
\begin{itemize}
\item {} 
\code{kmemleak\_init}              - initialize kmemleak

\item {} 
\code{kmemleak\_alloc}             - notify of a memory block allocation

\item {} 
\code{kmemleak\_alloc\_percpu}      - notify of a percpu memory block allocation

\item {} 
\code{kmemleak\_vmalloc}           - notify of a vmalloc() memory allocation

\item {} 
\code{kmemleak\_free}              - notify of a memory block freeing

\item {} 
\code{kmemleak\_free\_part}         - notify of a partial memory block freeing

\item {} 
\code{kmemleak\_free\_percpu}       - notify of a percpu memory block freeing

\item {} 
\code{kmemleak\_update\_trace}      - update object allocation stack trace

\item {} 
\code{kmemleak\_not\_leak}  - mark an object as not a leak

\item {} 
\code{kmemleak\_ignore}            - do not scan or report an object as leak

\item {} 
\code{kmemleak\_scan\_area}         - add scan areas inside a memory block

\item {} 
\code{kmemleak\_no\_scan}   - do not scan a memory block

\item {} 
\code{kmemleak\_erase}             - erase an old value in a pointer variable

\item {} 
\code{kmemleak\_alloc\_recursive} - as kmemleak\_alloc but checks the recursiveness

\item {} 
\code{kmemleak\_free\_recursive}    - as kmemleak\_free but checks the recursiveness

\end{itemize}

The following functions take a physical address as the object pointer
and only perform the corresponding action if the address has a lowmem
mapping:
\begin{itemize}
\item {} 
\code{kmemleak\_alloc\_phys}

\item {} 
\code{kmemleak\_free\_part\_phys}

\item {} 
\code{kmemleak\_not\_leak\_phys}

\item {} 
\code{kmemleak\_ignore\_phys}

\end{itemize}


\section{Dealing with false positives/negatives}
\label{dev-tools/kmemleak:dealing-with-false-positives-negatives}
The false negatives are real memory leaks (orphan objects) but not
reported by kmemleak because values found during the memory scanning
point to such objects. To reduce the number of false negatives, kmemleak
provides the kmemleak\_ignore, kmemleak\_scan\_area, kmemleak\_no\_scan and
kmemleak\_erase functions (see above). The task stacks also increase the
amount of false negatives and their scanning is not enabled by default.

The false positives are objects wrongly reported as being memory leaks
(orphan). For objects known not to be leaks, kmemleak provides the
kmemleak\_not\_leak function. The kmemleak\_ignore could also be used if
the memory block is known not to contain other pointers and it will no
longer be scanned.

Some of the reported leaks are only transient, especially on SMP
systems, because of pointers temporarily stored in CPU registers or
stacks. Kmemleak defines MSECS\_MIN\_AGE (defaulting to 1000) representing
the minimum age of an object to be reported as a memory leak.


\section{Limitations and Drawbacks}
\label{dev-tools/kmemleak:limitations-and-drawbacks}
The main drawback is the reduced performance of memory allocation and
freeing. To avoid other penalties, the memory scanning is only performed
when the /sys/kernel/debug/kmemleak file is read. Anyway, this tool is
intended for debugging purposes where the performance might not be the
most important requirement.

To keep the algorithm simple, kmemleak scans for values pointing to any
address inside a block's address range. This may lead to an increased
number of false negatives. However, it is likely that a real memory leak
will eventually become visible.

Another source of false negatives is the data stored in non-pointer
values. In a future version, kmemleak could only scan the pointer
members in the allocated structures. This feature would solve many of
the false negative cases described above.

The tool can report false positives. These are cases where an allocated
block doesn't need to be freed (some cases in the init\_call functions),
the pointer is calculated by other methods than the usual container\_of
macro or the pointer is stored in a location not scanned by kmemleak.

Page allocations and ioremap are not tracked.


\chapter{Debugging kernel and modules via gdb}
\label{dev-tools/gdb-kernel-debugging::doc}\label{dev-tools/gdb-kernel-debugging:debugging-kernel-and-modules-via-gdb}
The kernel debugger kgdb, hypervisors like QEMU or JTAG-based hardware
interfaces allow to debug the Linux kernel and its modules during runtime
using gdb. Gdb comes with a powerful scripting interface for python. The
kernel provides a collection of helper scripts that can simplify typical
kernel debugging steps. This is a short tutorial about how to enable and use
them. It focuses on QEMU/KVM virtual machines as target, but the examples can
be transferred to the other gdb stubs as well.


\section{Requirements}
\label{dev-tools/gdb-kernel-debugging:requirements}\begin{itemize}
\item {} 
gdb 7.2+ (recommended: 7.4+) with python support enabled (typically true
for distributions)

\end{itemize}


\section{Setup}
\label{dev-tools/gdb-kernel-debugging:setup}\begin{itemize}
\item {} 
Create a virtual Linux machine for QEMU/KVM (see www.linux-kvm.org and
www.qemu.org for more details). For cross-development,
\href{http://landley.net/aboriginal/bin}{http://landley.net/aboriginal/bin} keeps a pool of machine images and
toolchains that can be helpful to start from.

\item {} 
Build the kernel with CONFIG\_GDB\_SCRIPTS enabled, but leave
CONFIG\_DEBUG\_INFO\_REDUCED off. If your architecture supports
CONFIG\_FRAME\_POINTER, keep it enabled.

\item {} 
Install that kernel on the guest, turn off KASLR if necessary by adding
``nokaslr'' to the kernel command line.
Alternatively, QEMU allows to boot the kernel directly using -kernel,
-append, -initrd command line switches. This is generally only useful if
you do not depend on modules. See QEMU documentation for more details on
this mode. In this case, you should build the kernel with
CONFIG\_RANDOMIZE\_BASE disabled if the architecture supports KASLR.

\item {} 
Enable the gdb stub of QEMU/KVM, either
\begin{itemize}
\item {} 
at VM startup time by appending ``-s'' to the QEMU command line

\end{itemize}

or
\begin{itemize}
\item {} 
during runtime by issuing ``gdbserver'' from the QEMU monitor
console

\end{itemize}

\item {} 
cd /path/to/linux-build

\item {} 
Start gdb: gdb vmlinux

Note: Some distros may restrict auto-loading of gdb scripts to known safe
directories. In case gdb reports to refuse loading vmlinux-gdb.py, add:

\begin{Verbatim}[commandchars=\\\{\}]
add\PYGZhy{}auto\PYGZhy{}load\PYGZhy{}safe\PYGZhy{}path /path/to/linux\PYGZhy{}build
\end{Verbatim}

to \textasciitilde{}/.gdbinit. See gdb help for more details.

\item {} 
Attach to the booted guest:

\begin{Verbatim}[commandchars=\\\{\}]
(gdb) target remote :1234
\end{Verbatim}

\end{itemize}


\section{Examples of using the Linux-provided gdb helpers}
\label{dev-tools/gdb-kernel-debugging:examples-of-using-the-linux-provided-gdb-helpers}\begin{itemize}
\item {} 
Load module (and main kernel) symbols:

\begin{Verbatim}[commandchars=\\\{\}]
(gdb) lx\PYGZhy{}symbols
loading vmlinux
scanning for modules in /home/user/linux/build
loading @0xffffffffa0020000: /home/user/linux/build/net/netfilter/xt\PYGZus{}tcpudp.ko
loading @0xffffffffa0016000: /home/user/linux/build/net/netfilter/xt\PYGZus{}pkttype.ko
loading @0xffffffffa0002000: /home/user/linux/build/net/netfilter/xt\PYGZus{}limit.ko
loading @0xffffffffa00ca000: /home/user/linux/build/net/packet/af\PYGZus{}packet.ko
loading @0xffffffffa003c000: /home/user/linux/build/fs/fuse/fuse.ko
...
loading @0xffffffffa0000000: /home/user/linux/build/drivers/ata/ata\PYGZus{}generic.ko
\end{Verbatim}

\item {} 
Set a breakpoint on some not yet loaded module function, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
(gdb) b btrfs\PYGZus{}init\PYGZus{}sysfs
Function \PYGZdq{}btrfs\PYGZus{}init\PYGZus{}sysfs\PYGZdq{} not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 1 (btrfs\PYGZus{}init\PYGZus{}sysfs) pending.
\end{Verbatim}

\item {} 
Continue the target:

\begin{Verbatim}[commandchars=\\\{\}]
(gdb) c
\end{Verbatim}

\item {} 
Load the module on the target and watch the symbols being loaded as well as
the breakpoint hit:

\begin{Verbatim}[commandchars=\\\{\}]
loading @0xffffffffa0034000: /home/user/linux/build/lib/libcrc32c.ko
loading @0xffffffffa0050000: /home/user/linux/build/lib/lzo/lzo\PYGZus{}compress.ko
loading @0xffffffffa006e000: /home/user/linux/build/lib/zlib\PYGZus{}deflate/zlib\PYGZus{}deflate.ko
loading @0xffffffffa01b1000: /home/user/linux/build/fs/btrfs/btrfs.ko

Breakpoint 1, btrfs\PYGZus{}init\PYGZus{}sysfs () at /home/user/linux/fs/btrfs/sysfs.c:36
36              btrfs\PYGZus{}kset = kset\PYGZus{}create\PYGZus{}and\PYGZus{}add(\PYGZdq{}btrfs\PYGZdq{}, NULL, fs\PYGZus{}kobj);
\end{Verbatim}

\item {} 
Dump the log buffer of the target kernel:

\begin{Verbatim}[commandchars=\\\{\}]
(gdb) lx\PYGZhy{}dmesg
[     0.000000] Initializing cgroup subsys cpuset
[     0.000000] Initializing cgroup subsys cpu
[     0.000000] Linux version 3.8.0\PYGZhy{}rc4\PYGZhy{}dbg+ (...
[     0.000000] Command line: root=/dev/sda2 resume=/dev/sda1 vga=0x314
[     0.000000] e820: BIOS\PYGZhy{}provided physical RAM map:
[     0.000000] BIOS\PYGZhy{}e820: [mem 0x0000000000000000\PYGZhy{}0x000000000009fbff] usable
[     0.000000] BIOS\PYGZhy{}e820: [mem 0x000000000009fc00\PYGZhy{}0x000000000009ffff] reserved
....
\end{Verbatim}

\item {} 
Examine fields of the current task struct:

\begin{Verbatim}[commandchars=\\\{\}]
(gdb) p \PYGZdl{}lx\PYGZus{}current().pid
\PYGZdl{}1 = 4998
(gdb) p \PYGZdl{}lx\PYGZus{}current().comm
\PYGZdl{}2 = \PYGZdq{}modprobe\PYGZbs{}000\PYGZbs{}000\PYGZbs{}000\PYGZbs{}000\PYGZbs{}000\PYGZbs{}000\PYGZbs{}000\PYGZdq{}
\end{Verbatim}

\item {} 
Make use of the per-cpu function for the current or a specified CPU:

\begin{Verbatim}[commandchars=\\\{\}]
(gdb) p \PYGZdl{}lx\PYGZus{}per\PYGZus{}cpu(\PYGZdq{}runqueues\PYGZdq{}).nr\PYGZus{}running
\PYGZdl{}3 = 1
(gdb) p \PYGZdl{}lx\PYGZus{}per\PYGZus{}cpu(\PYGZdq{}runqueues\PYGZdq{}, 2).nr\PYGZus{}running
\PYGZdl{}4 = 0
\end{Verbatim}

\item {} 
Dig into hrtimers using the container\_of helper:

\begin{Verbatim}[commandchars=\\\{\}]
(gdb) set \PYGZdl{}next = \PYGZdl{}lx\PYGZus{}per\PYGZus{}cpu(\PYGZdq{}hrtimer\PYGZus{}bases\PYGZdq{}).clock\PYGZus{}base[0].active.next
(gdb) p *\PYGZdl{}container\PYGZus{}of(\PYGZdl{}next, \PYGZdq{}struct hrtimer\PYGZdq{}, \PYGZdq{}node\PYGZdq{})
\PYGZdl{}5 = \PYGZob{}
  node = \PYGZob{}
    node = \PYGZob{}
      \PYGZus{}\PYGZus{}rb\PYGZus{}parent\PYGZus{}color = 18446612133355256072,
      rb\PYGZus{}right = 0x0 \PYGZlt{}irq\PYGZus{}stack\PYGZus{}union\PYGZgt{},
      rb\PYGZus{}left = 0x0 \PYGZlt{}irq\PYGZus{}stack\PYGZus{}union\PYGZgt{}
    \PYGZcb{},
    expires = \PYGZob{}
      tv64 = 1835268000000
    \PYGZcb{}
  \PYGZcb{},
  \PYGZus{}softexpires = \PYGZob{}
    tv64 = 1835268000000
  \PYGZcb{},
  function = 0xffffffff81078232 \PYGZlt{}tick\PYGZus{}sched\PYGZus{}timer\PYGZgt{},
  base = 0xffff88003fd0d6f0,
  state = 1,
  start\PYGZus{}pid = 0,
  start\PYGZus{}site = 0xffffffff81055c1f \PYGZlt{}hrtimer\PYGZus{}start\PYGZus{}range\PYGZus{}ns+20\PYGZgt{},
  start\PYGZus{}comm = \PYGZdq{}swapper/2\PYGZbs{}000\PYGZbs{}000\PYGZbs{}000\PYGZbs{}000\PYGZbs{}000\PYGZbs{}000\PYGZdq{}
\PYGZcb{}
\end{Verbatim}

\end{itemize}


\section{List of commands and functions}
\label{dev-tools/gdb-kernel-debugging:list-of-commands-and-functions}
The number of commands and convenience functions may evolve over the time,
this is just a snapshot of the initial version:

\begin{Verbatim}[commandchars=\\\{\}]
(gdb) apropos lx
function lx\PYGZus{}current \PYGZhy{}\PYGZhy{} Return current task
function lx\PYGZus{}module \PYGZhy{}\PYGZhy{} Find module by name and return the module variable
function lx\PYGZus{}per\PYGZus{}cpu \PYGZhy{}\PYGZhy{} Return per\PYGZhy{}cpu variable
function lx\PYGZus{}task\PYGZus{}by\PYGZus{}pid \PYGZhy{}\PYGZhy{} Find Linux task by PID and return the task\PYGZus{}struct variable
function lx\PYGZus{}thread\PYGZus{}info \PYGZhy{}\PYGZhy{} Calculate Linux thread\PYGZus{}info from task variable
lx\PYGZhy{}dmesg \PYGZhy{}\PYGZhy{} Print Linux kernel log buffer
lx\PYGZhy{}lsmod \PYGZhy{}\PYGZhy{} List currently loaded modules
lx\PYGZhy{}symbols \PYGZhy{}\PYGZhy{} (Re\PYGZhy{})load symbols of Linux kernel and currently loaded modules
\end{Verbatim}

Detailed help can be obtained via ``help \textless{}command-name\textgreater{}'' for commands and ``help
function \textless{}function-name\textgreater{}'' for convenience functions.


\chapter{Using kgdb, kdb and the kernel debugger internals}
\label{dev-tools/kgdb:using-kgdb-kdb-and-the-kernel-debugger-internals}\label{dev-tools/kgdb::doc}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Jason Wessel

\end{description}\end{quote}


\section{Introduction}
\label{dev-tools/kgdb:introduction}
The kernel has two different debugger front ends (kdb and kgdb) which
interface to the debug core. It is possible to use either of the
debugger front ends and dynamically transition between them if you
configure the kernel properly at compile and runtime.

Kdb is simplistic shell-style interface which you can use on a system
console with a keyboard or serial console. You can use it to inspect
memory, registers, process lists, dmesg, and even set breakpoints to
stop in a certain location. Kdb is not a source level debugger, although
you can set breakpoints and execute some basic kernel run control. Kdb
is mainly aimed at doing some analysis to aid in development or
diagnosing kernel problems. You can access some symbols by name in
kernel built-ins or in kernel modules if the code was built with
\code{CONFIG\_KALLSYMS}.

Kgdb is intended to be used as a source level debugger for the Linux
kernel. It is used along with gdb to debug a Linux kernel. The
expectation is that gdb can be used to ``break in'' to the kernel to
inspect memory, variables and look through call stack information
similar to the way an application developer would use gdb to debug an
application. It is possible to place breakpoints in kernel code and
perform some limited execution stepping.

Two machines are required for using kgdb. One of these machines is a
development machine and the other is the target machine. The kernel to
be debugged runs on the target machine. The development machine runs an
instance of gdb against the vmlinux file which contains the symbols (not
a boot image such as bzImage, zImage, uImage...). In gdb the developer
specifies the connection parameters and connects to kgdb. The type of
connection a developer makes with gdb depends on the availability of
kgdb I/O modules compiled as built-ins or loadable kernel modules in the
test machine's kernel.


\section{Compiling a kernel}
\label{dev-tools/kgdb:compiling-a-kernel}\begin{itemize}
\item {} 
In order to enable compilation of kdb, you must first enable kgdb.

\item {} 
The kgdb test compile options are described in the kgdb test suite
chapter.

\end{itemize}


\subsection{Kernel config options for kgdb}
\label{dev-tools/kgdb:kernel-config-options-for-kgdb}
To enable \code{CONFIG\_KGDB} you should look under
\emph{Kernel hacking \(\rightarrow\) Kernel debugging} and select
\emph{KGDB: kernel debugger}.

While it is not a hard requirement that you have symbols in your vmlinux
file, gdb tends not to be very useful without the symbolic data, so you
will want to turn on \code{CONFIG\_DEBUG\_INFO} which is called
\emph{Compile the kernel with debug info} in the config menu.

It is advised, but not required, that you turn on the
\code{CONFIG\_FRAME\_POINTER} kernel option which is called \emph{Compile
the kernel with frame pointers} in the config menu. This option inserts code
to into the compiled executable which saves the frame information in
registers or on the stack at different points which allows a debugger
such as gdb to more accurately construct stack back traces while
debugging the kernel.

If the architecture that you are using supports the kernel option
\code{CONFIG\_STRICT\_KERNEL\_RWX}, you should consider turning it off. This
option will prevent the use of software breakpoints because it marks
certain regions of the kernel's memory space as read-only. If kgdb
supports it for the architecture you are using, you can use hardware
breakpoints if you desire to run with the \code{CONFIG\_STRICT\_KERNEL\_RWX}
option turned on, else you need to turn off this option.

Next you should choose one of more I/O drivers to interconnect debugging
host and debugged target. Early boot debugging requires a KGDB I/O
driver that supports early debugging and the driver must be built into
the kernel directly. Kgdb I/O driver configuration takes place via
kernel or module parameters which you can learn more about in the in the
section that describes the parameter kgdboc.

Here is an example set of \code{.config} symbols to enable or disable for kgdb:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} CONFIG\PYGZus{}STRICT\PYGZus{}KERNEL\PYGZus{}RWX is not set
CONFIG\PYGZus{}FRAME\PYGZus{}POINTER=y
CONFIG\PYGZus{}KGDB=y
CONFIG\PYGZus{}KGDB\PYGZus{}SERIAL\PYGZus{}CONSOLE=y
\end{Verbatim}


\subsection{Kernel config options for kdb}
\label{dev-tools/kgdb:kernel-config-options-for-kdb}
Kdb is quite a bit more complex than the simple gdbstub sitting on top
of the kernel's debug core. Kdb must implement a shell, and also adds
some helper functions in other parts of the kernel, responsible for
printing out interesting data such as what you would see if you ran
\code{lsmod}, or \code{ps}. In order to build kdb into the kernel you follow the
same steps as you would for kgdb.

The main config option for kdb is \code{CONFIG\_KGDB\_KDB} which is called
\emph{KGDB\_KDB: include kdb frontend for kgdb} in the config menu.
In theory you would have already also selected an I/O driver such as the
\code{CONFIG\_KGDB\_SERIAL\_CONSOLE} interface if you plan on using kdb on a
serial port, when you were configuring kgdb.

If you want to use a PS/2-style keyboard with kdb, you would select
\code{CONFIG\_KDB\_KEYBOARD} which is called \emph{KGDB\_KDB: keyboard as
input device} in the config menu. The \code{CONFIG\_KDB\_KEYBOARD} option is not
used for anything in the gdb interface to kgdb. The \code{CONFIG\_KDB\_KEYBOARD}
option only works with kdb.

Here is an example set of \code{.config} symbols to enable/disable kdb:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} CONFIG\PYGZus{}STRICT\PYGZus{}KERNEL\PYGZus{}RWX is not set
CONFIG\PYGZus{}FRAME\PYGZus{}POINTER=y
CONFIG\PYGZus{}KGDB=y
CONFIG\PYGZus{}KGDB\PYGZus{}SERIAL\PYGZus{}CONSOLE=y
CONFIG\PYGZus{}KGDB\PYGZus{}KDB=y
CONFIG\PYGZus{}KDB\PYGZus{}KEYBOARD=y
\end{Verbatim}


\section{Kernel Debugger Boot Arguments}
\label{dev-tools/kgdb:kernel-debugger-boot-arguments}
This section describes the various runtime kernel parameters that affect
the configuration of the kernel debugger. The following chapter covers
using kdb and kgdb as well as providing some examples of the
configuration parameters.


\subsection{Kernel parameter: kgdboc}
\label{dev-tools/kgdb:kernel-parameter-kgdboc}
The kgdboc driver was originally an abbreviation meant to stand for
``kgdb over console''. Today it is the primary mechanism to configure how
to communicate from gdb to kgdb as well as the devices you want to use
to interact with the kdb shell.

For kgdb/gdb, kgdboc is designed to work with a single serial port. It
is intended to cover the circumstance where you want to use a serial
console as your primary console as well as using it to perform kernel
debugging. It is also possible to use kgdb on a serial port which is not
designated as a system console. Kgdboc may be configured as a kernel
built-in or a kernel loadable module. You can only make use of
\code{kgdbwait} and early debugging if you build kgdboc into the kernel as
a built-in.

Optionally you can elect to activate kms (Kernel Mode Setting)
integration. When you use kms with kgdboc and you have a video driver
that has atomic mode setting hooks, it is possible to enter the debugger
on the graphics console. When the kernel execution is resumed, the
previous graphics mode will be restored. This integration can serve as a
useful tool to aid in diagnosing crashes or doing analysis of memory
with kdb while allowing the full graphics console applications to run.


\subsubsection{kgdboc arguments}
\label{dev-tools/kgdb:kgdboc-arguments}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
kgdboc=[kms][[,]kbd][[,]serial\PYGZus{}device][,baud]
\end{Verbatim}

The order listed above must be observed if you use any of the optional
configurations together.

Abbreviations:
\begin{itemize}
\item {} 
kms = Kernel Mode Setting

\item {} 
kbd = Keyboard

\end{itemize}

You can configure kgdboc to use the keyboard, and/or a serial device
depending on if you are using kdb and/or kgdb, in one of the following
scenarios. The order listed above must be observed if you use any of the
optional configurations together. Using kms + only gdb is generally not
a useful combination.


\paragraph{Using loadable module or built-in}
\label{dev-tools/kgdb:using-loadable-module-or-built-in}\begin{enumerate}
\item {} 
As a kernel built-in:

Use the kernel boot argument:

\begin{Verbatim}[commandchars=\\\{\}]
kgdboc=\PYGZlt{}tty\PYGZhy{}device\PYGZgt{},[baud]
\end{Verbatim}

\item {} 
As a kernel loadable module:

Use the command:

\begin{Verbatim}[commandchars=\\\{\}]
modprobe kgdboc kgdboc=\PYGZlt{}tty\PYGZhy{}device\PYGZgt{},[baud]
\end{Verbatim}

Here are two examples of how you might format the kgdboc string. The
first is for an x86 target using the first serial port. The second
example is for the ARM Versatile AB using the second serial port.
\begin{enumerate}
\item {} 
\code{kgdboc=ttyS0,115200}

\item {} 
\code{kgdboc=ttyAMA1,115200}

\end{enumerate}

\end{enumerate}


\paragraph{Configure kgdboc at runtime with sysfs}
\label{dev-tools/kgdb:configure-kgdboc-at-runtime-with-sysfs}
At run time you can enable or disable kgdboc by echoing a parameters
into the sysfs. Here are two examples:
\begin{enumerate}
\item {} 
Enable kgdboc on ttyS0:

\begin{Verbatim}[commandchars=\\\{\}]
echo ttyS0 \PYGZgt{} /sys/module/kgdboc/parameters/kgdboc
\end{Verbatim}

\item {} 
Disable kgdboc:

\begin{Verbatim}[commandchars=\\\{\}]
echo \PYGZdq{}\PYGZdq{} \PYGZgt{} /sys/module/kgdboc/parameters/kgdboc
\end{Verbatim}

\end{enumerate}

\begin{notice}{note}{Note:}
You do not need to specify the baud if you are configuring the
console on tty which is already configured or open.
\end{notice}


\paragraph{More examples}
\label{dev-tools/kgdb:more-examples}
You can configure kgdboc to use the keyboard, and/or a serial device
depending on if you are using kdb and/or kgdb, in one of the following
scenarios.
\begin{enumerate}
\item {} 
kdb and kgdb over only a serial port:

\begin{Verbatim}[commandchars=\\\{\}]
kgdboc=\PYGZlt{}serial\PYGZus{}device\PYGZgt{}[,baud]
\end{Verbatim}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
kgdboc=ttyS0,115200
\end{Verbatim}

\item {} 
kdb and kgdb with keyboard and a serial port:

\begin{Verbatim}[commandchars=\\\{\}]
kgdboc=kbd,\PYGZlt{}serial\PYGZus{}device\PYGZgt{}[,baud]
\end{Verbatim}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
kgdboc=kbd,ttyS0,115200
\end{Verbatim}

\item {} 
kdb with a keyboard:

\begin{Verbatim}[commandchars=\\\{\}]
kgdboc=kbd
\end{Verbatim}

\item {} 
kdb with kernel mode setting:

\begin{Verbatim}[commandchars=\\\{\}]
kgdboc=kms,kbd
\end{Verbatim}

\item {} 
kdb with kernel mode setting and kgdb over a serial port:

\begin{Verbatim}[commandchars=\\\{\}]
kgdboc=kms,kbd,ttyS0,115200
\end{Verbatim}

\end{enumerate}

\begin{notice}{note}{Note:}
Kgdboc does not support interrupting the target via the gdb remote
protocol. You must manually send a \code{SysRq-G} unless you have a proxy
that splits console output to a terminal program. A console proxy has a
separate TCP port for the debugger and a separate TCP port for the
``human'' console. The proxy can take care of sending the \code{SysRq-G}
for you.
\end{notice}

When using kgdboc with no debugger proxy, you can end up connecting the
debugger at one of two entry points. If an exception occurs after you
have loaded kgdboc, a message should print on the console stating it is
waiting for the debugger. In this case you disconnect your terminal
program and then connect the debugger in its place. If you want to
interrupt the target system and forcibly enter a debug session you have
to issue a \code{Sysrq} sequence and then type the letter \code{g}. Then you
disconnect the terminal session and connect gdb. Your options if you
don't like this are to hack gdb to send the \code{SysRq-G} for you as well as
on the initial connect, or to use a debugger proxy that allows an
unmodified gdb to do the debugging.


\subsection{Kernel parameter: \texttt{kgdbwait}}
\label{dev-tools/kgdb:kernel-parameter-kgdbwait}
The Kernel command line option \code{kgdbwait} makes kgdb wait for a
debugger connection during booting of a kernel. You can only use this
option if you compiled a kgdb I/O driver into the kernel and you
specified the I/O driver configuration as a kernel command line option.
The kgdbwait parameter should always follow the configuration parameter
for the kgdb I/O driver in the kernel command line else the I/O driver
will not be configured prior to asking the kernel to use it to wait.

The kernel will stop and wait as early as the I/O driver and
architecture allows when you use this option. If you build the kgdb I/O
driver as a loadable kernel module kgdbwait will not do anything.


\subsection{Kernel parameter: \texttt{kgdbcon}}
\label{dev-tools/kgdb:kernel-parameter-kgdbcon}
The \code{kgdbcon} feature allows you to see \code{printk()} messages inside gdb
while gdb is connected to the kernel. Kdb does not make use of the kgdbcon
feature.

Kgdb supports using the gdb serial protocol to send console messages to
the debugger when the debugger is connected and running. There are two
ways to activate this feature.
\begin{enumerate}
\item {} 
Activate with the kernel command line option:

\begin{Verbatim}[commandchars=\\\{\}]
kgdbcon
\end{Verbatim}

\item {} 
Use sysfs before configuring an I/O driver:

\begin{Verbatim}[commandchars=\\\{\}]
echo 1 \PYGZgt{} /sys/module/kgdb/parameters/kgdb\PYGZus{}use\PYGZus{}con
\end{Verbatim}

\end{enumerate}

\begin{notice}{note}{Note:}
If you do this after you configure the kgdb I/O driver, the
setting will not take effect until the next point the I/O is
reconfigured.
\end{notice}

\begin{notice}{important}{Important:}
You cannot use kgdboc + kgdbcon on a tty that is an
active system console. An example of incorrect usage is:

\begin{Verbatim}[commandchars=\\\{\}]
console=ttyS0,115200 kgdboc=ttyS0 kgdbcon
\end{Verbatim}
\end{notice}

It is possible to use this option with kgdboc on a tty that is not a
system console.


\subsection{Run time parameter: \texttt{kgdbreboot}}
\label{dev-tools/kgdb:run-time-parameter-kgdbreboot}
The kgdbreboot feature allows you to change how the debugger deals with
the reboot notification. You have 3 choices for the behavior. The
default behavior is always set to 0.

\begin{tabulary}{\linewidth}{|p{0.4cm}|p{11.5cm}|p{5.6cm}|}
\hline

1
 & 
\code{echo -1 \textgreater{} /sys/module/debug\_core/parameters/kgdbreboot}
 & 
Ignore the reboot notification entirely.
\\
\hline
2
 & 
\code{echo 0 \textgreater{} /sys/module/debug\_core/parameters/kgdbreboot}
 & 
Send the detach message to any attached debugger client.
\\
\hline
3
 & 
\code{echo 1 \textgreater{} /sys/module/debug\_core/parameters/kgdbreboot}
 & 
Enter the debugger on reboot notify.
\\
\hline\end{tabulary}



\subsection{Kernel parameter: \texttt{nokaslr}}
\label{dev-tools/kgdb:kernel-parameter-nokaslr}
If the architecture that you are using enable KASLR by default,
you should consider turning it off.  KASLR randomizes the
virtual address where the kernel image is mapped and confuse
gdb which resolve kernel symbol address from symbol table
of vmlinux.


\section{Using kdb}
\label{dev-tools/kgdb:using-kdb}

\subsection{Quick start for kdb on a serial port}
\label{dev-tools/kgdb:quick-start-for-kdb-on-a-serial-port}
This is a quick example of how to use kdb.
\begin{enumerate}
\item {} 
Configure kgdboc at boot using kernel parameters:

\begin{Verbatim}[commandchars=\\\{\}]
console=ttyS0,115200 kgdboc=ttyS0,115200 nokaslr
\end{Verbatim}

OR

Configure kgdboc after the kernel has booted; assuming you are using
a serial port console:

\begin{Verbatim}[commandchars=\\\{\}]
echo ttyS0 \PYGZgt{} /sys/module/kgdboc/parameters/kgdboc
\end{Verbatim}

\item {} 
Enter the kernel debugger manually or by waiting for an oops or
fault. There are several ways you can enter the kernel debugger
manually; all involve using the \code{SysRq-G}, which means you must have
enabled \code{CONFIG\_MAGIC\_SysRq=y} in your kernel config.
\begin{itemize}
\item {} 
When logged in as root or with a super user session you can run:

\begin{Verbatim}[commandchars=\\\{\}]
echo g \PYGZgt{} /proc/sysrq\PYGZhy{}trigger
\end{Verbatim}

\item {} 
Example using minicom 2.2

Press: \code{CTRL-A} \code{f} \code{g}

\item {} 
When you have telneted to a terminal server that supports sending
a remote break

Press: \code{CTRL-{]}}

Type in: \code{send break}

Press: \code{Enter} \code{g}

\end{itemize}

\item {} 
From the kdb prompt you can run the \code{help} command to see a complete
list of the commands that are available.

Some useful commands in kdb include:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

\code{lsmod}
 & 
Shows where kernel modules are loaded
\\
\hline
\code{ps}
 & 
Displays only the active processes
\\
\hline
\code{ps A}
 & 
Shows all the processes
\\
\hline
\code{summary}
 & 
Shows kernel version info and memory usage
\\
\hline
\code{bt}
 & 
Get a backtrace of the current process using \code{dump\_stack()}
\\
\hline
\code{dmesg}
 & 
View the kernel syslog buffer
\\
\hline
\code{go}
 & 
Continue the system
\\
\hline\end{tabulary}


\item {} 
When you are done using kdb you need to consider rebooting the system
or using the \code{go} command to resuming normal kernel execution. If you
have paused the kernel for a lengthy period of time, applications
that rely on timely networking or anything to do with real wall clock
time could be adversely affected, so you should take this into
consideration when using the kernel debugger.

\end{enumerate}


\subsection{Quick start for kdb using a keyboard connected console}
\label{dev-tools/kgdb:quick-start-for-kdb-using-a-keyboard-connected-console}
This is a quick example of how to use kdb with a keyboard.
\begin{enumerate}
\item {} 
Configure kgdboc at boot using kernel parameters:

\begin{Verbatim}[commandchars=\\\{\}]
kgdboc=kbd
\end{Verbatim}

OR

Configure kgdboc after the kernel has booted:

\begin{Verbatim}[commandchars=\\\{\}]
echo kbd \PYGZgt{} /sys/module/kgdboc/parameters/kgdboc
\end{Verbatim}

\item {} 
Enter the kernel debugger manually or by waiting for an oops or
fault. There are several ways you can enter the kernel debugger
manually; all involve using the \code{SysRq-G}, which means you must have
enabled \code{CONFIG\_MAGIC\_SysRq=y} in your kernel config.
\begin{itemize}
\item {} 
When logged in as root or with a super user session you can run:

\begin{Verbatim}[commandchars=\\\{\}]
echo g \PYGZgt{} /proc/sysrq\PYGZhy{}trigger
\end{Verbatim}

\item {} 
Example using a laptop keyboard:

Press and hold down: \code{Alt}

Press and hold down: \code{Fn}

Press and release the key with the label: \code{SysRq}

Release: \code{Fn}

Press and release: \code{g}

Release: \code{Alt}

\item {} 
Example using a PS/2 101-key keyboard

Press and hold down: \code{Alt}

Press and release the key with the label: \code{SysRq}

Press and release: \code{g}

Release: \code{Alt}

\end{itemize}

\item {} 
Now type in a kdb command such as \code{help}, \code{dmesg}, \code{bt} or \code{go} to
continue kernel execution.

\end{enumerate}


\section{Using kgdb / gdb}
\label{dev-tools/kgdb:using-kgdb-gdb}
In order to use kgdb you must activate it by passing configuration
information to one of the kgdb I/O drivers. If you do not pass any
configuration information kgdb will not do anything at all. Kgdb will
only actively hook up to the kernel trap hooks if a kgdb I/O driver is
loaded and configured. If you unconfigure a kgdb I/O driver, kgdb will
unregister all the kernel hook points.

All kgdb I/O drivers can be reconfigured at run time, if
\code{CONFIG\_SYSFS} and \code{CONFIG\_MODULES} are enabled, by echo'ing a new
config string to \code{/sys/module/\textless{}driver\textgreater{}/parameter/\textless{}option\textgreater{}}. The driver
can be unconfigured by passing an empty string. You cannot change the
configuration while the debugger is attached. Make sure to detach the
debugger with the \code{detach} command prior to trying to unconfigure a
kgdb I/O driver.


\subsection{Connecting with gdb to a serial port}
\label{dev-tools/kgdb:connecting-with-gdb-to-a-serial-port}\begin{enumerate}
\item {} 
Configure kgdboc

Configure kgdboc at boot using kernel parameters:

\begin{Verbatim}[commandchars=\\\{\}]
kgdboc=ttyS0,115200
\end{Verbatim}

OR

Configure kgdboc after the kernel has booted:

\begin{Verbatim}[commandchars=\\\{\}]
echo ttyS0 \PYGZgt{} /sys/module/kgdboc/parameters/kgdboc
\end{Verbatim}

\item {} 
Stop kernel execution (break into the debugger)

In order to connect to gdb via kgdboc, the kernel must first be
stopped. There are several ways to stop the kernel which include
using kgdbwait as a boot argument, via a \code{SysRq-G}, or running the
kernel until it takes an exception where it waits for the debugger to
attach.
\begin{itemize}
\item {} 
When logged in as root or with a super user session you can run:

\begin{Verbatim}[commandchars=\\\{\}]
echo g \PYGZgt{} /proc/sysrq\PYGZhy{}trigger
\end{Verbatim}

\item {} 
Example using minicom 2.2

Press: \code{CTRL-A} \code{f} \code{g}

\item {} 
When you have telneted to a terminal server that supports sending
a remote break

Press: \code{CTRL-{]}}

Type in: \code{send break}

Press: \code{Enter} \code{g}

\end{itemize}

\item {} 
Connect from gdb

Example (using a directly connected port):

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} gdb ./vmlinux
(gdb) set remotebaud 115200
(gdb) target remote /dev/ttyS0
\end{Verbatim}

Example (kgdb to a terminal server on TCP port 2012):

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} gdb ./vmlinux
(gdb) target remote 192.168.2.2:2012
\end{Verbatim}

Once connected, you can debug a kernel the way you would debug an
application program.

If you are having problems connecting or something is going seriously
wrong while debugging, it will most often be the case that you want
to enable gdb to be verbose about its target communications. You do
this prior to issuing the \code{target remote} command by typing in:

\begin{Verbatim}[commandchars=\\\{\}]
set debug remote 1
\end{Verbatim}

\end{enumerate}

Remember if you continue in gdb, and need to ``break in'' again, you need
to issue an other \code{SysRq-G}. It is easy to create a simple entry point by
putting a breakpoint at \code{sys\_sync} and then you can run \code{sync} from a
shell or script to break into the debugger.


\section{kgdb and kdb interoperability}
\label{dev-tools/kgdb:kgdb-and-kdb-interoperability}
It is possible to transition between kdb and kgdb dynamically. The debug
core will remember which you used the last time and automatically start
in the same mode.


\subsection{Switching between kdb and kgdb}
\label{dev-tools/kgdb:switching-between-kdb-and-kgdb}

\subsubsection{Switching from kgdb to kdb}
\label{dev-tools/kgdb:switching-from-kgdb-to-kdb}
There are two ways to switch from kgdb to kdb: you can use gdb to issue
a maintenance packet, or you can blindly type the command \code{\$3\#33}.
Whenever the kernel debugger stops in kgdb mode it will print the
message \code{KGDB or \$3\#33 for KDB}. It is important to note that you have
to type the sequence correctly in one pass. You cannot type a backspace
or delete because kgdb will interpret that as part of the debug stream.
\begin{enumerate}
\item {} 
Change from kgdb to kdb by blindly typing:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}3\PYGZsh{}33
\end{Verbatim}

\item {} 
Change from kgdb to kdb with gdb:

\begin{Verbatim}[commandchars=\\\{\}]
maintenance packet 3
\end{Verbatim}

\begin{notice}{note}{Note:}
Now you must kill gdb. Typically you press \code{CTRL-Z} and issue
the command:

\begin{Verbatim}[commandchars=\\\{\}]
kill \PYGZhy{}9 \PYGZpc{}
\end{Verbatim}
\end{notice}

\end{enumerate}


\subsubsection{Change from kdb to kgdb}
\label{dev-tools/kgdb:change-from-kdb-to-kgdb}
There are two ways you can change from kdb to kgdb. You can manually
enter kgdb mode by issuing the kgdb command from the kdb shell prompt,
or you can connect gdb while the kdb shell prompt is active. The kdb
shell looks for the typical first commands that gdb would issue with the
gdb remote protocol and if it sees one of those commands it
automatically changes into kgdb mode.
\begin{enumerate}
\item {} 
From kdb issue the command:

\begin{Verbatim}[commandchars=\\\{\}]
kgdb
\end{Verbatim}

Now disconnect your terminal program and connect gdb in its place

\item {} 
At the kdb prompt, disconnect the terminal program and connect gdb in
its place.

\end{enumerate}


\subsection{Running kdb commands from gdb}
\label{dev-tools/kgdb:running-kdb-commands-from-gdb}
It is possible to run a limited set of kdb commands from gdb, using the
gdb monitor command. You don't want to execute any of the run control or
breakpoint operations, because it can disrupt the state of the kernel
debugger. You should be using gdb for breakpoints and run control
operations if you have gdb connected. The more useful commands to run
are things like lsmod, dmesg, ps or possibly some of the memory
information commands. To see all the kdb commands you can run
\code{monitor help}.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
(gdb) monitor ps
1 idle process (state I) and
27 sleeping system daemon (state M) processes suppressed,
use \PYGZsq{}ps A\PYGZsq{} to see all.
Task Addr       Pid   Parent [*] cpu State Thread     Command

0xc78291d0        1        0  0    0   S  0xc7829404  init
0xc7954150      942        1  0    0   S  0xc7954384  dropbear
0xc78789c0      944        1  0    0   S  0xc7878bf4  sh
(gdb)
\end{Verbatim}


\section{kgdb Test Suite}
\label{dev-tools/kgdb:kgdb-test-suite}
When kgdb is enabled in the kernel config you can also elect to enable
the config parameter \code{KGDB\_TESTS}. Turning this on will enable a special
kgdb I/O module which is designed to test the kgdb internal functions.

The kgdb tests are mainly intended for developers to test the kgdb
internals as well as a tool for developing a new kgdb architecture
specific implementation. These tests are not really for end users of the
Linux kernel. The primary source of documentation would be to look in
the \code{drivers/misc/kgdbts.c} file.

The kgdb test suite can also be configured at compile time to run the
core set of tests by setting the kernel config parameter
\code{KGDB\_TESTS\_ON\_BOOT}. This particular option is aimed at automated
regression testing and does not require modifying the kernel boot config
arguments. If this is turned on, the kgdb test suite can be disabled by
specifying \code{kgdbts=} as a kernel boot argument.


\section{Kernel Debugger Internals}
\label{dev-tools/kgdb:kernel-debugger-internals}

\subsection{Architecture Specifics}
\label{dev-tools/kgdb:architecture-specifics}
The kernel debugger is organized into a number of components:
\begin{enumerate}
\item {} 
The debug core

The debug core is found in \code{kernel/debugger/debug\_core.c}. It
contains:
\begin{itemize}
\item {} 
A generic OS exception handler which includes sync'ing the
processors into a stopped state on an multi-CPU system.

\item {} 
The API to talk to the kgdb I/O drivers

\item {} 
The API to make calls to the arch-specific kgdb implementation

\item {} 
The logic to perform safe memory reads and writes to memory while
using the debugger

\item {} 
A full implementation for software breakpoints unless overridden
by the arch

\item {} 
The API to invoke either the kdb or kgdb frontend to the debug
core.

\item {} 
The structures and callback API for atomic kernel mode setting.

\begin{notice}{note}{Note:}
kgdboc is where the kms callbacks are invoked.
\end{notice}

\end{itemize}

\item {} 
kgdb arch-specific implementation

This implementation is generally found in \code{arch/*/kernel/kgdb.c}. As
an example, \code{arch/x86/kernel/kgdb.c} contains the specifics to
implement HW breakpoint as well as the initialization to dynamically
register and unregister for the trap handlers on this architecture.
The arch-specific portion implements:
\begin{itemize}
\item {} 
contains an arch-specific trap catcher which invokes
\code{kgdb\_handle\_exception()} to start kgdb about doing its work

\item {} 
translation to and from gdb specific packet format to \code{pt\_regs}

\item {} 
Registration and unregistration of architecture specific trap
hooks

\item {} 
Any special exception handling and cleanup

\item {} 
NMI exception handling and cleanup

\item {} 
(optional) HW breakpoints

\end{itemize}

\item {} 
gdbstub frontend (aka kgdb)

The gdbstub is located in \code{kernel/debug/gdbstub.c}. It contains:
\begin{itemize}
\item {} 
All the logic to implement the gdb serial protocol

\end{itemize}

\item {} 
kdb frontend

The kdb debugger shell is broken down into a number of components.
The kdb core is located in kernel/debug/kdb. There are a number of
helper functions in some of the other kernel components to make it
possible for kdb to examine and report information about the kernel
without taking locks that could cause a kernel deadlock. The kdb core
contains implements the following functionality.
\begin{itemize}
\item {} 
A simple shell

\item {} 
The kdb core command set

\item {} 
A registration API to register additional kdb shell commands.
\begin{itemize}
\item {} 
A good example of a self-contained kdb module is the \code{ftdump}
command for dumping the ftrace buffer. See:
\code{kernel/trace/trace\_kdb.c}

\item {} 
For an example of how to dynamically register a new kdb command
you can build the kdb\_hello.ko kernel module from
\code{samples/kdb/kdb\_hello.c}. To build this example you can set
\code{CONFIG\_SAMPLES=y} and \code{CONFIG\_SAMPLE\_KDB=m} in your kernel
config. Later run \code{modprobe kdb\_hello} and the next time you
enter the kdb shell, you can run the \code{hello} command.

\end{itemize}

\item {} 
The implementation for \code{kdb\_printf()} which emits messages directly
to I/O drivers, bypassing the kernel log.

\item {} 
SW / HW breakpoint management for the kdb shell

\end{itemize}

\item {} 
kgdb I/O driver

Each kgdb I/O driver has to provide an implementation for the
following:
\begin{itemize}
\item {} 
configuration via built-in or module

\item {} 
dynamic configuration and kgdb hook registration calls

\item {} 
read and write character interface

\item {} 
A cleanup handler for unconfiguring from the kgdb core

\item {} 
(optional) Early debug methodology

\end{itemize}

Any given kgdb I/O driver has to operate very closely with the
hardware and must do it in such a way that does not enable interrupts
or change other parts of the system context without completely
restoring them. The kgdb core will repeatedly ``poll'' a kgdb I/O
driver for characters when it needs input. The I/O driver is expected
to return immediately if there is no data available. Doing so allows
for the future possibility to touch watchdog hardware in such a way
as to have a target system not reset when these are enabled.

\end{enumerate}

If you are intent on adding kgdb architecture specific support for a new
architecture, the architecture should define \code{HAVE\_ARCH\_KGDB} in the
architecture specific Kconfig file. This will enable kgdb for the
architecture, and at that point you must create an architecture specific
kgdb implementation.

There are a few flags which must be set on every architecture in their
\code{asm/kgdb.h} file. These are:
\begin{itemize}
\item {} \begin{description}
\item[{\code{NUMREGBYTES}:}] \leavevmode
The size in bytes of all of the registers, so that we
can ensure they will all fit into a packet.

\end{description}

\item {} \begin{description}
\item[{\code{BUFMAX}:}] \leavevmode
The size in bytes of the buffer GDB will read into. This must
be larger than NUMREGBYTES.

\end{description}

\item {} \begin{description}
\item[{\code{CACHE\_FLUSH\_IS\_SAFE}:}] \leavevmode
Set to 1 if it is always safe to call
flush\_cache\_range or flush\_icache\_range. On some architectures,
these functions may not be safe to call on SMP since we keep other
CPUs in a holding pattern.

\end{description}

\end{itemize}

There are also the following functions for the common backend, found in
\code{kernel/kgdb.c}, that must be supplied by the architecture-specific
backend unless marked as (optional), in which case a default function
maybe used if the architecture does not need to provide a specific
implementation.
\index{kgdb\_skipexception (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kgdb:c.kgdb_skipexception}\pysiglinewithargsret{int \bfcode{kgdb\_skipexception}}{int\emph{ exception}, struct pt\_regs *\emph{ regs}}{}
(optional) exit kgdb\_handle\_exception early

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int exception}}] \leavevmode
Exception vector number

\item[{\code{struct pt\_regs * regs}}] \leavevmode
Current \code{struct pt\_regs}.

\end{description}

\textbf{Description}
\begin{quote}

On some architectures it is required to skip a breakpoint
exception when it occurs after a breakpoint has been removed.
This can be implemented in the architecture specific portion of kgdb.
\end{quote}
\index{kgdb\_breakpoint (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kgdb:c.kgdb_breakpoint}\pysiglinewithargsret{void \bfcode{kgdb\_breakpoint}}{void}{}
compiled in breakpoint

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}
\begin{quote}

This will be implemented as a static inline per architecture.  This
function is called by the kgdb core to execute an architecture
specific trap to cause kgdb to enter the exception processing.
\end{quote}
\index{kgdb\_arch\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kgdb:c.kgdb_arch_init}\pysiglinewithargsret{int \bfcode{kgdb\_arch\_init}}{void}{}
Perform any architecture specific initalization.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}
\begin{quote}

This function will handle the initalization of any architecture
specific callbacks.
\end{quote}
\index{kgdb\_arch\_exit (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kgdb:c.kgdb_arch_exit}\pysiglinewithargsret{void \bfcode{kgdb\_arch\_exit}}{void}{}
Perform any architecture specific uninitalization.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}
\begin{quote}

This function will handle the uninitalization of any architecture
specific callbacks, for dynamic registration and unregistration.
\end{quote}
\index{pt\_regs\_to\_gdb\_regs (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kgdb:c.pt_regs_to_gdb_regs}\pysiglinewithargsret{void \bfcode{pt\_regs\_to\_gdb\_regs}}{unsigned long *\emph{ gdb\_regs}, struct pt\_regs *\emph{ regs}}{}
Convert ptrace regs to GDB regs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long * gdb\_regs}}] \leavevmode
A pointer to hold the registers in the order GDB wants.

\item[{\code{struct pt\_regs * regs}}] \leavevmode
The \code{struct pt\_regs} of the current process.

\end{description}

\textbf{Description}
\begin{quote}

Convert the pt\_regs in \textbf{regs} into the format for registers that
GDB expects, stored in \textbf{gdb\_regs}.
\end{quote}
\index{sleeping\_thread\_to\_gdb\_regs (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kgdb:c.sleeping_thread_to_gdb_regs}\pysiglinewithargsret{void \bfcode{sleeping\_thread\_to\_gdb\_regs}}{unsigned long *\emph{ gdb\_regs}, struct task\_struct *\emph{ p}}{}
Convert ptrace regs to GDB regs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long * gdb\_regs}}] \leavevmode
A pointer to hold the registers in the order GDB wants.

\item[{\code{struct task\_struct * p}}] \leavevmode
The \code{struct task\_struct} of the desired process.

\end{description}

\textbf{Description}
\begin{quote}

Convert the register values of the sleeping process in \textbf{p} to
the format that GDB expects.
This function is called when kgdb does not have access to the
\code{struct pt\_regs} and therefore it should fill the gdb registers
\textbf{gdb\_regs} with what has been saved in \code{struct thread\_struct}
thread field during switch\_to.
\end{quote}
\index{gdb\_regs\_to\_pt\_regs (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kgdb:c.gdb_regs_to_pt_regs}\pysiglinewithargsret{void \bfcode{gdb\_regs\_to\_pt\_regs}}{unsigned long *\emph{ gdb\_regs}, struct pt\_regs *\emph{ regs}}{}
Convert GDB regs to ptrace regs.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long * gdb\_regs}}] \leavevmode
A pointer to hold the registers we've received from GDB.

\item[{\code{struct pt\_regs * regs}}] \leavevmode
A pointer to a \code{struct pt\_regs} to hold these values in.

\end{description}

\textbf{Description}
\begin{quote}

Convert the GDB regs in \textbf{gdb\_regs} into the pt\_regs, and store them
in \textbf{regs}.
\end{quote}
\index{kgdb\_arch\_handle\_exception (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kgdb:c.kgdb_arch_handle_exception}\pysiglinewithargsret{int \bfcode{kgdb\_arch\_handle\_exception}}{int\emph{ vector}, int\emph{ signo}, int\emph{ err\_code}, char *\emph{ remcom\_in\_buffer}, char *\emph{ remcom\_out\_buffer}, struct pt\_regs *\emph{ regs}}{}
Handle architecture specific GDB packets.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int vector}}] \leavevmode
The error vector of the exception that happened.

\item[{\code{int signo}}] \leavevmode
The signal number of the exception that happened.

\item[{\code{int err\_code}}] \leavevmode
The error code of the exception that happened.

\item[{\code{char * remcom\_in\_buffer}}] \leavevmode
The buffer of the packet we have read.

\item[{\code{char * remcom\_out\_buffer}}] \leavevmode
The buffer of \code{BUFMAX} bytes to write a packet into.

\item[{\code{struct pt\_regs * regs}}] \leavevmode
The \code{struct pt\_regs} of the current process.

\end{description}

\textbf{Description}
\begin{quote}

This function MUST handle the `c' and `s' command packets,
as well packets to set / remove a hardware breakpoint, if used.
If there are additional packets which the hardware needs to handle,
they are handled here.  The code should return -1 if it wants to
process more packets, and a \code{0} or \code{1} if it wants to exit from the
kgdb callback.
\end{quote}
\index{kgdb\_roundup\_cpus (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kgdb:c.kgdb_roundup_cpus}\pysiglinewithargsret{void \bfcode{kgdb\_roundup\_cpus}}{unsigned long\emph{ flags}}{}
Get other CPUs into a holding pattern

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long flags}}] \leavevmode
Current IRQ state

\end{description}

\textbf{Description}
\begin{quote}

On SMP systems, we need to get the attention of the other CPUs
and get them into a known state.  This should do what is needed
to get the other CPUs to call \code{kgdb\_wait()}. Note that on some arches,
the NMI approach is not used for rounding up all the CPUs. For example,
in case of MIPS, \code{smp\_call\_function()} is used to roundup CPUs. In
this case, we have to make sure that interrupts are enabled before
calling \code{smp\_call\_function()}. The argument to this function is
the flags that will be used when restoring the interrupts. There is
\code{local\_irq\_save()} call before {\hyperref[dev\string-tools/kgdb:c.kgdb_roundup_cpus]{\emph{\code{kgdb\_roundup\_cpus()}}}}.

On non-SMP systems, this is not called.
\end{quote}
\index{kgdb\_arch\_set\_pc (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kgdb:c.kgdb_arch_set_pc}\pysiglinewithargsret{void \bfcode{kgdb\_arch\_set\_pc}}{struct pt\_regs *\emph{ regs}, unsigned long\emph{ pc}}{}
Generic call back to the program counter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pt\_regs * regs}}] \leavevmode
Current \code{struct pt\_regs}.

\item[{\code{unsigned long pc}}] \leavevmode
The new value for the program counter

\end{description}

\textbf{Description}
\begin{quote}

This function handles updating the program counter and requires an
architecture specific implementation.
\end{quote}
\index{kgdb\_arch\_late (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kgdb:c.kgdb_arch_late}\pysiglinewithargsret{void \bfcode{kgdb\_arch\_late}}{void}{}
Perform any architecture specific initalization.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}
\begin{quote}

This function will handle the late initalization of any
architecture specific callbacks.  This is an optional function for
handling things like late initialization of hw breakpoints.  The
default implementation does nothing.
\end{quote}
\index{kgdb\_arch (C type)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kgdb:c.kgdb_arch}\pysigline{struct \bfcode{kgdb\_arch}}
Describe architecture specific values.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct kgdb\PYGZus{}arch \PYGZob{}
  unsigned char           gdb\PYGZus{}bpt\PYGZus{}instr[BREAK\PYGZus{}INSTR\PYGZus{}SIZE];
  unsigned long           flags;
  int (*set\PYGZus{}breakpoint)(unsigned long, char *);
  int (*remove\PYGZus{}breakpoint)(unsigned long, char *);
  int (*set\PYGZus{}hw\PYGZus{}breakpoint)(unsigned long, int, enum kgdb\PYGZus{}bptype);
  int (*remove\PYGZus{}hw\PYGZus{}breakpoint)(unsigned long, int, enum kgdb\PYGZus{}bptype);
  void (*disable\PYGZus{}hw\PYGZus{}break)(struct pt\PYGZus{}regs *regs);
  void (*remove\PYGZus{}all\PYGZus{}hw\PYGZus{}break)(void);
  void (*correct\PYGZus{}hw\PYGZus{}break)(void);
  void (*enable\PYGZus{}nmi)(bool on);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{gdb\_bpt\_instr}}] \leavevmode
The instruction to trigger a breakpoint.

\item[{\code{flags}}] \leavevmode
Flags for the breakpoint, currently just \code{KGDB\_HW\_BREAKPOINT}.

\item[{\code{set\_breakpoint}}] \leavevmode
Allow an architecture to specify how to set a software
breakpoint.

\item[{\code{remove\_breakpoint}}] \leavevmode
Allow an architecture to specify how to remove a
software breakpoint.

\item[{\code{set\_hw\_breakpoint}}] \leavevmode
Allow an architecture to specify how to set a hardware
breakpoint.

\item[{\code{remove\_hw\_breakpoint}}] \leavevmode
Allow an architecture to specify how to remove a
hardware breakpoint.

\item[{\code{disable\_hw\_break}}] \leavevmode
Allow an architecture to specify how to disable
hardware breakpoints for a single cpu.

\item[{\code{remove\_all\_hw\_break}}] \leavevmode
Allow an architecture to specify how to remove all
hardware breakpoints.

\item[{\code{correct\_hw\_break}}] \leavevmode
Allow an architecture to specify how to correct the
hardware debug registers.

\item[{\code{enable\_nmi}}] \leavevmode
Manage NMI-triggered entry to KGDB

\end{description}
\index{kgdb\_io (C type)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kgdb:c.kgdb_io}\pysigline{struct \bfcode{kgdb\_io}}
Describe the interface for an I/O driver to talk with KGDB.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct kgdb\PYGZus{}io \PYGZob{}
  const char              *name;
  int (*read\PYGZus{}char) (void);
  void (*write\PYGZus{}char) (u8);
  void (*flush) (void);
  int (*init) (void);
  void (*pre\PYGZus{}exception) (void);
  void (*post\PYGZus{}exception) (void);
  int is\PYGZus{}console;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
Name of the I/O driver.

\item[{\code{read\_char}}] \leavevmode
Pointer to a function that will return one char.

\item[{\code{write\_char}}] \leavevmode
Pointer to a function that will write one char.

\item[{\code{flush}}] \leavevmode
Pointer to a function that will flush any pending writes.

\item[{\code{init}}] \leavevmode
Pointer to a function that will initialize the device.

\item[{\code{pre\_exception}}] \leavevmode
Pointer to a function that will do any prep work for
the I/O driver.

\item[{\code{post\_exception}}] \leavevmode
Pointer to a function that will do any cleanup work
for the I/O driver.

\item[{\code{is\_console}}] \leavevmode
1 if the end device is a console 0 if the I/O device is
not a console

\end{description}


\subsection{kgdboc internals}
\label{dev-tools/kgdb:kgdboc-internals}

\subsubsection{kgdboc and uarts}
\label{dev-tools/kgdb:kgdboc-and-uarts}
The kgdboc driver is actually a very thin driver that relies on the
underlying low level to the hardware driver having ``polling hooks'' to
which the tty driver is attached. In the initial implementation of
kgdboc the serial\_core was changed to expose a low level UART hook for
doing polled mode reading and writing of a single character while in an
atomic context. When kgdb makes an I/O request to the debugger, kgdboc
invokes a callback in the serial core which in turn uses the callback in
the UART driver.

When using kgdboc with a UART, the UART driver must implement two
callbacks in the \code{struct uart\_ops}.
Example from \code{drivers/8250.c}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}ifdef CONFIG\PYGZus{}CONSOLE\PYGZus{}POLL
    .poll\PYGZus{}get\PYGZus{}char = serial8250\PYGZus{}get\PYGZus{}poll\PYGZus{}char,
    .poll\PYGZus{}put\PYGZus{}char = serial8250\PYGZus{}put\PYGZus{}poll\PYGZus{}char,
\PYGZsh{}endif
\end{Verbatim}

Any implementation specifics around creating a polling driver use the
\code{\#ifdef CONFIG\_CONSOLE\_POLL}, as shown above. Keep in mind that
polling hooks have to be implemented in such a way that they can be
called from an atomic context and have to restore the state of the UART
chip on return such that the system can return to normal when the
debugger detaches. You need to be very careful with any kind of lock you
consider, because failing here is most likely going to mean pressing the
reset button.


\subsubsection{kgdboc and keyboards}
\label{dev-tools/kgdb:kgdboc-and-keyboards}
The kgdboc driver contains logic to configure communications with an
attached keyboard. The keyboard infrastructure is only compiled into the
kernel when \code{CONFIG\_KDB\_KEYBOARD=y} is set in the kernel configuration.

The core polled keyboard driver driver for PS/2 type keyboards is in
\code{drivers/char/kdb\_keyboard.c}. This driver is hooked into the debug core
when kgdboc populates the callback in the array called
\code{kdb\_poll\_funcs{[}{]}}. The \code{kdb\_get\_kbd\_char()} is the top-level
function which polls hardware for single character input.


\subsubsection{kgdboc and kms}
\label{dev-tools/kgdb:kgdboc-and-kms}
The kgdboc driver contains logic to request the graphics display to
switch to a text context when you are using \code{kgdboc=kms,kbd}, provided
that you have a video driver which has a frame buffer console and atomic
kernel mode setting support.

Every time the kernel debugger is entered it calls
\code{kgdboc\_pre\_exp\_handler()} which in turn calls \code{con\_debug\_enter()}
in the virtual console layer. On resuming kernel execution, the kernel
debugger calls \code{kgdboc\_post\_exp\_handler()} which in turn calls
\code{con\_debug\_leave()}.

Any video driver that wants to be compatible with the kernel debugger
and the atomic kms callbacks must implement the \code{mode\_set\_base\_atomic},
\code{fb\_debug\_enter} and \code{fb\_debug\_leave operations}. For the
\code{fb\_debug\_enter} and \code{fb\_debug\_leave} the option exists to use the
generic drm fb helper functions or implement something custom for the
hardware. The following example shows the initialization of the
.mode\_set\_base\_atomic operation in
drivers/gpu/drm/i915/intel\_display.c:

\begin{Verbatim}[commandchars=\\\{\}]
static const struct drm\PYGZus{}crtc\PYGZus{}helper\PYGZus{}funcs intel\PYGZus{}helper\PYGZus{}funcs = \PYGZob{}
[...]
        .mode\PYGZus{}set\PYGZus{}base\PYGZus{}atomic = intel\PYGZus{}pipe\PYGZus{}set\PYGZus{}base\PYGZus{}atomic,
[...]
\PYGZcb{};
\end{Verbatim}

Here is an example of how the i915 driver initializes the
fb\_debug\_enter and fb\_debug\_leave functions to use the generic drm
helpers in \code{drivers/gpu/drm/i915/intel\_fb.c}:

\begin{Verbatim}[commandchars=\\\{\}]
static struct fb\PYGZus{}ops intelfb\PYGZus{}ops = \PYGZob{}
[...]
       .fb\PYGZus{}debug\PYGZus{}enter = drm\PYGZus{}fb\PYGZus{}helper\PYGZus{}debug\PYGZus{}enter,
       .fb\PYGZus{}debug\PYGZus{}leave = drm\PYGZus{}fb\PYGZus{}helper\PYGZus{}debug\PYGZus{}leave,
[...]
\PYGZcb{};
\end{Verbatim}


\section{Credits}
\label{dev-tools/kgdb:credits}
The following people have contributed to this document:
\begin{enumerate}
\item {} 
Amit Kale \textless{}\href{mailto:amitkale@linsyssoft.com}{amitkale@linsyssoft.com}\textgreater{}

\item {} 
Tom Rini \textless{}\href{mailto:trini@kernel.crashing.org}{trini@kernel.crashing.org}\textgreater{}

\end{enumerate}

In March 2008 this document was completely rewritten by:
\begin{itemize}
\item {} 
Jason Wessel \textless{}\href{mailto:jason.wessel@windriver.com}{jason.wessel@windriver.com}\textgreater{}

\end{itemize}

In Jan 2010 this document was updated to include kdb.
\begin{itemize}
\item {} 
Jason Wessel \textless{}\href{mailto:jason.wessel@windriver.com}{jason.wessel@windriver.com}\textgreater{}

\end{itemize}


\chapter{Linux Kernel Selftests}
\label{dev-tools/kselftest:linux-kernel-selftests}\label{dev-tools/kselftest::doc}
The kernel contains a set of ``self tests'' under the tools/testing/selftests/
directory. These are intended to be small tests to exercise individual code
paths in the kernel. Tests are intended to be run after building, installing
and booting a kernel.

On some systems, hot-plug tests could hang forever waiting for cpu and
memory to be ready to be offlined. A special hot-plug target is created
to run full range of hot-plug tests. In default mode, hot-plug tests run
in safe mode with a limited scope. In limited mode, cpu-hotplug test is
run on a single cpu as opposed to all hotplug capable cpus, and memory
hotplug test is run on 2\% of hotplug capable memory instead of 10\%.


\section{Running the selftests (hotplug tests are run in limited mode)}
\label{dev-tools/kselftest:running-the-selftests-hotplug-tests-are-run-in-limited-mode}
To build the tests:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} make \PYGZhy{}C tools/testing/selftests
\end{Verbatim}

To run the tests:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} make \PYGZhy{}C tools/testing/selftests run\PYGZus{}tests
\end{Verbatim}

To build and run the tests with a single command, use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} make kselftest
\end{Verbatim}

Note that some tests will require root privileges.

Build and run from user specific object directory (make O=dir):

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} make O=/tmp/kselftest kselftest
\end{Verbatim}

Build and run KBUILD\_OUTPUT directory (make KBUILD\_OUTPUT=):

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} make KBUILD\PYGZus{}OUTPUT=/tmp/kselftest kselftest
\end{Verbatim}

The above commands run the tests and print pass/fail summary to make it
easier to understand the test results. Please find the detailed individual
test results for each test in /tmp/testname file(s).


\section{Running a subset of selftests}
\label{dev-tools/kselftest:running-a-subset-of-selftests}
You can use the ``TARGETS'' variable on the make command line to specify
single test to run, or a list of tests to run.

To run only tests targeted for a single subsystem:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} make \PYGZhy{}C tools/testing/selftests TARGETS=ptrace run\PYGZus{}tests
\end{Verbatim}

You can specify multiple tests to build and run:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}  make TARGETS=\PYGZdq{}size timers\PYGZdq{} kselftest
\end{Verbatim}

Build and run from user specific object directory (make O=dir):

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} make O=/tmp/kselftest TARGETS=\PYGZdq{}size timers\PYGZdq{} kselftest
\end{Verbatim}

Build and run KBUILD\_OUTPUT directory (make KBUILD\_OUTPUT=):

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} make KBUILD\PYGZus{}OUTPUT=/tmp/kselftest TARGETS=\PYGZdq{}size timers\PYGZdq{} kselftest
\end{Verbatim}

The above commands run the tests and print pass/fail summary to make it
easier to understand the test results. Please find the detailed individual
test results for each test in /tmp/testname file(s).

See the top-level tools/testing/selftests/Makefile for the list of all
possible targets.


\section{Running the full range hotplug selftests}
\label{dev-tools/kselftest:running-the-full-range-hotplug-selftests}
To build the hotplug tests:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} make \PYGZhy{}C tools/testing/selftests hotplug
\end{Verbatim}

To run the hotplug tests:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} make \PYGZhy{}C tools/testing/selftests run\PYGZus{}hotplug
\end{Verbatim}

Note that some tests will require root privileges.


\section{Install selftests}
\label{dev-tools/kselftest:install-selftests}
You can use kselftest\_install.sh tool installs selftests in default
location which is tools/testing/selftests/kselftest or a user specified
location.

To install selftests in default location:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} cd tools/testing/selftests
\PYGZdl{} ./kselftest\PYGZus{}install.sh
\end{Verbatim}

To install selftests in a user specified location:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} cd tools/testing/selftests
\PYGZdl{} ./kselftest\PYGZus{}install.sh install\PYGZus{}dir
\end{Verbatim}


\section{Running installed selftests}
\label{dev-tools/kselftest:running-installed-selftests}
Kselftest install as well as the Kselftest tarball provide a script
named ``run\_kselftest.sh'' to run the tests.

You can simply do the following to run the installed Kselftests. Please
note some tests will require root privileges:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} cd kselftest
\PYGZdl{} ./run\PYGZus{}kselftest.sh
\end{Verbatim}


\section{Contributing new tests}
\label{dev-tools/kselftest:contributing-new-tests}
In general, the rules for selftests are
\begin{itemize}
\item {} 
Do as much as you can if you're not root;

\item {} 
Don't take too long;

\item {} 
Don't break the build on any architecture, and

\item {} 
Don't cause the top-level ``make run\_tests'' to fail if your feature is
unconfigured.

\end{itemize}


\section{Contributing new tests (details)}
\label{dev-tools/kselftest:contributing-new-tests-details}\begin{itemize}
\item {} 
Use TEST\_GEN\_XXX if such binaries or files are generated during
compiling.

TEST\_PROGS, TEST\_GEN\_PROGS mean it is the executable tested by
default.

TEST\_CUSTOM\_PROGS should be used by tests that require custom build
rule and prevent common build rule use.

TEST\_PROGS are for test shell scripts. Please ensure shell script has
its exec bit set. Otherwise, lib.mk run\_tests will generate a warning.

TEST\_CUSTOM\_PROGS and TEST\_PROGS will be run by common run\_tests.

TEST\_PROGS\_EXTENDED, TEST\_GEN\_PROGS\_EXTENDED mean it is the
executable which is not tested by default.
TEST\_FILES, TEST\_GEN\_FILES mean it is the file which is used by
test.

\end{itemize}


\section{Test Harness}
\label{dev-tools/kselftest:test-harness}
The kselftest\_harness.h file contains useful helpers to build tests.  The tests
from tools/testing/selftests/seccomp/seccomp\_bpf.c can be used as example.


\subsection{Example}
\label{dev-tools/kselftest:example}
\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZdq{}../kselftest\PYGZus{}harness.h\PYGZdq{}

TEST(standalone\PYGZus{}test) \PYGZob{}
  do\PYGZus{}some\PYGZus{}stuff;
  EXPECT\PYGZus{}GT(10, stuff) \PYGZob{}
     stuff\PYGZus{}state\PYGZus{}t state;
     enumerate\PYGZus{}stuff\PYGZus{}state(:c:type:{}`state{}`);
     TH\PYGZus{}LOG(\PYGZdq{}expectation failed with state: {}`{}`s{}`{}`\PYGZdq{}, state.msg);
  \PYGZcb{}
  more\PYGZus{}stuff;
  ASSERT\PYGZus{}NE(some\PYGZus{}stuff, NULL) TH\PYGZus{}LOG(\PYGZdq{}how did it happen?!\PYGZdq{});
  last\PYGZus{}stuff;
  EXPECT\PYGZus{}EQ(0, last\PYGZus{}stuff);
\PYGZcb{}

FIXTURE(my\PYGZus{}fixture) \PYGZob{}
  mytype\PYGZus{}t *data;
  int awesomeness\PYGZus{}level;
\PYGZcb{};
FIXTURE\PYGZus{}SETUP(my\PYGZus{}fixture) \PYGZob{}
  self\PYGZhy{}\PYGZgt{}data = :c:func:{}`mytype\PYGZus{}new(){}`;
  ASSERT\PYGZus{}NE(NULL, self\PYGZhy{}\PYGZgt{}data);
\PYGZcb{}
FIXTURE\PYGZus{}TEARDOWN(my\PYGZus{}fixture) \PYGZob{}
  mytype\PYGZus{}free(self\PYGZhy{}\PYGZgt{}data);
\PYGZcb{}
TEST\PYGZus{}F(my\PYGZus{}fixture, data\PYGZus{}is\PYGZus{}good) \PYGZob{}
  EXPECT\PYGZus{}EQ(1, is\PYGZus{}my\PYGZus{}data\PYGZus{}good(self\PYGZhy{}\PYGZgt{}data));
\PYGZcb{}

TEST\PYGZus{}HARNESS\PYGZus{}MAIN
\end{Verbatim}


\subsection{Helpers}
\label{dev-tools/kselftest:helpers}\index{TH\_LOG (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.TH_LOG}\pysiglinewithargsret{\bfcode{TH\_LOG}}{\emph{fmt}, \emph{...}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{fmt}}] \leavevmode
format string

\item[{\code{...}}] \leavevmode
optional arguments

\end{description}

\textbf{Description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{TH\PYGZus{}LOG}\PYG{p}{(}\PYG{n}{format}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\end{Verbatim}

Optional debug logging function available for use in tests.
Logging may be enabled or disabled by defining TH\_LOG\_ENABLED.
E.g., \#define TH\_LOG\_ENABLED 1

If no definition is provided, logging is enabled by default.

If there is no way to print an error message for the process running the
test (e.g. not allowed to write to stderr), it is still possible to get the
ASSERT\_* number for which the test failed.  This behavior can be enabled by
writing \emph{\_metadata-\textgreater{}no\_print = true;} before the check sequence that is
unable to print.  When an error occur, instead of printing an error message
and calling \emph{abort(3)}, the test process call \emph{\_exit(2)} with the assert
number as argument, which is then printed by the parent process.
\index{TEST (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.TEST}\pysiglinewithargsret{\bfcode{TEST}}{\emph{test\_name}}{}
Defines the test function and creates the registration stub

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{test\_name}}] \leavevmode
test name

\end{description}

\textbf{Description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{TEST}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{implementation} \PYG{p}{\PYGZcb{}}
\end{Verbatim}

Defines a test by name.
Names must be unique and tests must not be run in parallel.  The
implementation containing block is a function and scoping should be treated
as such.  Returning early may be performed with a bare ``return;'' statement.

EXPECT\_* and ASSERT\_* are valid in a {\hyperref[dev\string-tools/kselftest:c.TEST]{\emph{\code{TEST()}}}} \{ \} context.
\index{TEST\_SIGNAL (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.TEST_SIGNAL}\pysiglinewithargsret{\bfcode{TEST\_SIGNAL}}{\emph{test\_name}, \emph{signal}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{test\_name}}] \leavevmode
test name

\item[{\code{signal}}] \leavevmode
signal number

\end{description}

\textbf{Description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{TEST\PYGZus{}SIGNAL}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{n}{signal}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{implementation} \PYG{p}{\PYGZcb{}}
\end{Verbatim}

Defines a test by name and the expected term signal.
Names must be unique and tests must not be run in parallel.  The
implementation containing block is a function and scoping should be treated
as such.  Returning early may be performed with a bare ``return;'' statement.

EXPECT\_* and ASSERT\_* are valid in a {\hyperref[dev\string-tools/kselftest:c.TEST]{\emph{\code{TEST()}}}} \{ \} context.
\index{FIXTURE\_DATA (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.FIXTURE_DATA}\pysiglinewithargsret{\bfcode{FIXTURE\_DATA}}{\emph{datatype\_name}}{}
Wraps the struct name so we have one less argument to pass around

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{datatype\_name}}] \leavevmode
datatype name

\end{description}

\textbf{Description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{FIXTURE\PYGZus{}DATA}\PYG{p}{(}\PYG{n}{datatype} \PYG{n}{name}\PYG{p}{)}
\end{Verbatim}

This call may be used when the type of the fixture data
is needed.  In general, this should not be needed unless
the \emph{self} is being passed to a helper directly.
\index{FIXTURE (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.FIXTURE}\pysiglinewithargsret{\bfcode{FIXTURE}}{\emph{fixture\_name}}{}
Called once per fixture to setup the data and register

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{fixture\_name}}] \leavevmode
fixture name

\end{description}

\textbf{Description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{FIXTURE}\PYG{p}{(}\PYG{n}{datatype} \PYG{n}{name}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{n}{type} \PYG{n}{property1}\PYG{p}{;}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

Defines the data provided to {\hyperref[dev\string-tools/kselftest:c.TEST_F]{\emph{\code{TEST\_F()}}}}-defined tests as \emph{self}.  It should be
populated and cleaned up using {\hyperref[dev\string-tools/kselftest:c.FIXTURE_SETUP]{\emph{\code{FIXTURE\_SETUP()}}}} and {\hyperref[dev\string-tools/kselftest:c.FIXTURE_TEARDOWN]{\emph{\code{FIXTURE\_TEARDOWN()}}}}.
\index{FIXTURE\_SETUP (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.FIXTURE_SETUP}\pysiglinewithargsret{\bfcode{FIXTURE\_SETUP}}{\emph{fixture\_name}}{}
Prepares the setup function for the fixture. \emph{\_metadata} is included so that ASSERT\_* work as a convenience

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{fixture\_name}}] \leavevmode
fixture name

\end{description}

\textbf{Description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{FIXTURE\PYGZus{}SETUP}\PYG{p}{(}\PYG{n}{fixture} \PYG{n}{name}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{implementation} \PYG{p}{\PYGZcb{}}
\end{Verbatim}

Populates the required ``setup'' function for a fixture.  An instance of the
datatype defined with {\hyperref[dev\string-tools/kselftest:c.FIXTURE_DATA]{\emph{\code{FIXTURE\_DATA()}}}} will be exposed as \emph{self} for the
implementation.

ASSERT\_* are valid for use in this context and will prempt the execution
of any dependent fixture tests.

A bare ``return;'' statement may be used to return early.
\index{FIXTURE\_TEARDOWN (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.FIXTURE_TEARDOWN}\pysiglinewithargsret{\bfcode{FIXTURE\_TEARDOWN}}{\emph{fixture\_name}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{fixture\_name}}] \leavevmode
fixture name

\end{description}

\textbf{Description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{FIXTURE\PYGZus{}TEARDOWN}\PYG{p}{(}\PYG{n}{fixture} \PYG{n}{name}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{implementation} \PYG{p}{\PYGZcb{}}
\end{Verbatim}

Populates the required ``teardown'' function for a fixture.  An instance of the
datatype defined with {\hyperref[dev\string-tools/kselftest:c.FIXTURE_DATA]{\emph{\code{FIXTURE\_DATA()}}}} will be exposed as \emph{self} for the
implementation to clean up.

A bare ``return;'' statement may be used to return early.
\index{TEST\_F (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.TEST_F}\pysiglinewithargsret{\bfcode{TEST\_F}}{\emph{fixture\_name}, \emph{test\_name}}{}
Emits test registration and helpers for fixture-based test cases

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{fixture\_name}}] \leavevmode
fixture name

\item[{\code{test\_name}}] \leavevmode
test name

\end{description}

\textbf{Description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{TEST\PYGZus{}F}\PYG{p}{(}\PYG{n}{fixture}\PYG{p}{,} \PYG{n}{name}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{implementation} \PYG{p}{\PYGZcb{}}
\end{Verbatim}

Defines a test that depends on a fixture (e.g., is part of a test case).
Very similar to {\hyperref[dev\string-tools/kselftest:c.TEST]{\emph{\code{TEST()}}}} except that \emph{self} is the setup instance of fixture's
datatype exposed for use by the implementation.
\index{TEST\_HARNESS\_MAIN (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.TEST_HARNESS_MAIN}\pysiglinewithargsret{\bfcode{TEST\_HARNESS\_MAIN}}{}{}
Simple wrapper to run the test harness

\end{fulllineitems}


\textbf{Parameters}

\textbf{Description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{TEST\PYGZus{}HARNESS\PYGZus{}MAIN}
\end{Verbatim}

Use once to append a \code{main()} to the test file.


\subsection{Operators}
\label{dev-tools/kselftest:operators}
Operators for use in {\hyperref[dev\string-tools/kselftest:c.TEST]{\emph{\code{TEST()}}}} and {\hyperref[dev\string-tools/kselftest:c.TEST_F]{\emph{\code{TEST\_F()}}}}.
ASSERT\_* calls will stop test execution immediately.
EXPECT\_* calls will emit a failure warning, note it, and continue.
\index{ASSERT\_EQ (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.ASSERT_EQ}\pysiglinewithargsret{\bfcode{ASSERT\_EQ}}{\emph{expected}, \emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{expected}}] \leavevmode
expected value

\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

ASSERT\_EQ(expected, measured): expected == measured
\index{ASSERT\_NE (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.ASSERT_NE}\pysiglinewithargsret{\bfcode{ASSERT\_NE}}{\emph{expected}, \emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{expected}}] \leavevmode
expected value

\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

ASSERT\_NE(expected, measured): expected != measured
\index{ASSERT\_LT (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.ASSERT_LT}\pysiglinewithargsret{\bfcode{ASSERT\_LT}}{\emph{expected}, \emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{expected}}] \leavevmode
expected value

\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

ASSERT\_LT(expected, measured): expected \textless{} measured
\index{ASSERT\_LE (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.ASSERT_LE}\pysiglinewithargsret{\bfcode{ASSERT\_LE}}{\emph{expected}, \emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{expected}}] \leavevmode
expected value

\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

ASSERT\_LE(expected, measured): expected \textless{}= measured
\index{ASSERT\_GT (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.ASSERT_GT}\pysiglinewithargsret{\bfcode{ASSERT\_GT}}{\emph{expected}, \emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{expected}}] \leavevmode
expected value

\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

ASSERT\_GT(expected, measured): expected \textgreater{} measured
\index{ASSERT\_GE (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.ASSERT_GE}\pysiglinewithargsret{\bfcode{ASSERT\_GE}}{\emph{expected}, \emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{expected}}] \leavevmode
expected value

\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

ASSERT\_GE(expected, measured): expected \textgreater{}= measured
\index{ASSERT\_NULL (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.ASSERT_NULL}\pysiglinewithargsret{\bfcode{ASSERT\_NULL}}{\emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

ASSERT\_NULL(measured): NULL == measured
\index{ASSERT\_TRUE (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.ASSERT_TRUE}\pysiglinewithargsret{\bfcode{ASSERT\_TRUE}}{\emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

ASSERT\_TRUE(measured): measured != 0
\index{ASSERT\_FALSE (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.ASSERT_FALSE}\pysiglinewithargsret{\bfcode{ASSERT\_FALSE}}{\emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

ASSERT\_FALSE(measured): measured == 0
\index{ASSERT\_STREQ (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.ASSERT_STREQ}\pysiglinewithargsret{\bfcode{ASSERT\_STREQ}}{\emph{expected}, \emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{expected}}] \leavevmode
expected value

\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

ASSERT\_STREQ(expected, measured): !strcmp(expected, measured)
\index{ASSERT\_STRNE (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.ASSERT_STRNE}\pysiglinewithargsret{\bfcode{ASSERT\_STRNE}}{\emph{expected}, \emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{expected}}] \leavevmode
expected value

\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

ASSERT\_STRNE(expected, measured): strcmp(expected, measured)
\index{EXPECT\_EQ (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.EXPECT_EQ}\pysiglinewithargsret{\bfcode{EXPECT\_EQ}}{\emph{expected}, \emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{expected}}] \leavevmode
expected value

\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

EXPECT\_EQ(expected, measured): expected == measured
\index{EXPECT\_NE (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.EXPECT_NE}\pysiglinewithargsret{\bfcode{EXPECT\_NE}}{\emph{expected}, \emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{expected}}] \leavevmode
expected value

\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

EXPECT\_NE(expected, measured): expected != measured
\index{EXPECT\_LT (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.EXPECT_LT}\pysiglinewithargsret{\bfcode{EXPECT\_LT}}{\emph{expected}, \emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{expected}}] \leavevmode
expected value

\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

EXPECT\_LT(expected, measured): expected \textless{} measured
\index{EXPECT\_LE (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.EXPECT_LE}\pysiglinewithargsret{\bfcode{EXPECT\_LE}}{\emph{expected}, \emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{expected}}] \leavevmode
expected value

\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

EXPECT\_LE(expected, measured): expected \textless{}= measured
\index{EXPECT\_GT (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.EXPECT_GT}\pysiglinewithargsret{\bfcode{EXPECT\_GT}}{\emph{expected}, \emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{expected}}] \leavevmode
expected value

\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

EXPECT\_GT(expected, measured): expected \textgreater{} measured
\index{EXPECT\_GE (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.EXPECT_GE}\pysiglinewithargsret{\bfcode{EXPECT\_GE}}{\emph{expected}, \emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{expected}}] \leavevmode
expected value

\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

EXPECT\_GE(expected, measured): expected \textgreater{}= measured
\index{EXPECT\_NULL (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.EXPECT_NULL}\pysiglinewithargsret{\bfcode{EXPECT\_NULL}}{\emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

EXPECT\_NULL(measured): NULL == measured
\index{EXPECT\_TRUE (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.EXPECT_TRUE}\pysiglinewithargsret{\bfcode{EXPECT\_TRUE}}{\emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

EXPECT\_TRUE(measured): 0 != measured
\index{EXPECT\_FALSE (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.EXPECT_FALSE}\pysiglinewithargsret{\bfcode{EXPECT\_FALSE}}{\emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

EXPECT\_FALSE(measured): 0 == measured
\index{EXPECT\_STREQ (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.EXPECT_STREQ}\pysiglinewithargsret{\bfcode{EXPECT\_STREQ}}{\emph{expected}, \emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{expected}}] \leavevmode
expected value

\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

EXPECT\_STREQ(expected, measured): !strcmp(expected, measured)
\index{EXPECT\_STRNE (C function)}

\begin{fulllineitems}
\phantomsection\label{dev-tools/kselftest:c.EXPECT_STRNE}\pysiglinewithargsret{\bfcode{EXPECT\_STRNE}}{\emph{expected}, \emph{seen}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{expected}}] \leavevmode
expected value

\item[{\code{seen}}] \leavevmode
measured value

\end{description}

\textbf{Description}

EXPECT\_STRNE(expected, measured): strcmp(expected, measured)



\renewcommand{\indexname}{Index}
\printindex
\end{document}
