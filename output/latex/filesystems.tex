% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,8pt,english]{sphinxmanual}


\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }


	% Use some font with UTF-8 support with XeLaTeX
        \usepackage{fontspec}
        \setsansfont{DejaVu Serif}
        \setromanfont{DejaVu Sans}
        \setmonofont{DejaVu Sans Mono}

     \usepackage[margin=0.5in, top=1in, bottom=1in]{geometry}
        \usepackage{ifthen}

        % Put notes in color and let them be inside a table
	\definecolor{NoteColor}{RGB}{204,255,255}
	\definecolor{WarningColor}{RGB}{255,204,204}
	\definecolor{AttentionColor}{RGB}{255,255,204}
	\definecolor{ImportantColor}{RGB}{192,255,204}
	\definecolor{OtherColor}{RGB}{204,204,204}
        \newlength{\mynoticelength}
        \makeatletter\newenvironment{coloredbox}[1]{%
	   \setlength{\fboxrule}{1pt}
	   \setlength{\fboxsep}{7pt}
	   \setlength{\mynoticelength}{\linewidth}
	   \addtolength{\mynoticelength}{-2\fboxsep}
	   \addtolength{\mynoticelength}{-2\fboxrule}
           \begin{lrbox}{\@tempboxa}\begin{minipage}{\mynoticelength}}{\end{minipage}\end{lrbox}%
	   \ifthenelse%
	      {\equal{\py@noticetype}{note}}%
	      {\colorbox{NoteColor}{\usebox{\@tempboxa}}}%
	      {%
	         \ifthenelse%
	         {\equal{\py@noticetype}{warning}}%
	         {\colorbox{WarningColor}{\usebox{\@tempboxa}}}%
		 {%
	            \ifthenelse%
	            {\equal{\py@noticetype}{attention}}%
	            {\colorbox{AttentionColor}{\usebox{\@tempboxa}}}%
		    {%
	               \ifthenelse%
	               {\equal{\py@noticetype}{important}}%
	               {\colorbox{ImportantColor}{\usebox{\@tempboxa}}}%
	               {\colorbox{OtherColor}{\usebox{\@tempboxa}}}%
		    }%
		 }%
	      }%
        }\makeatother

        \makeatletter
        \renewenvironment{notice}[2]{%
          \def\py@noticetype{#1}
          \begin{coloredbox}{#1}
          \bf\it
          \par\strong{#2}
          \csname py@noticestart@#1\endcsname
        }
	{
          \csname py@noticeend@\py@noticetype\endcsname
          \end{coloredbox}
        }
	\makeatother

     

\title{Linux Filesystems API}
\date{March 08, 2018}
\release{4.16.0-rc4+}
\author{The kernel development community}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\setcounter{tocdepth}{1}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{filesystems/index::doc}



\chapter{The Linux VFS}
\label{filesystems/index:the-linux-vfs}\label{filesystems/index:linux-filesystems-api}

\section{The Filesystem types}
\label{filesystems/index:the-filesystem-types}\index{positive\_aop\_returns (C type)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.positive_aop_returns}\pysigline{enum \bfcode{positive\_aop\_returns}}
aop return codes with specific semantics

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{AOP\_WRITEPAGE\_ACTIVATE}}] \leavevmode
Informs the caller that page writeback has
completed, that the page is still locked, and
should be considered active.  The VM uses this hint
to return the page to the active list -- it won't
be a candidate for writeback again in the near
future.  Other callers must be careful to unlock
the page if they get this return.  Returned by
\code{writepage()};

\item[{\code{AOP\_TRUNCATED\_PAGE}}] \leavevmode
The AOP method that was handed a locked page has
unlocked it and the page might have been truncated.
The caller should back up to acquiring a new page and
trying again.  The aop will be taking reasonable
precautions not to livelock.  If the caller held a page
reference, it should drop it before retrying.  Returned
by \code{readpage()}.

\end{description}

\textbf{Description}

address\_space\_operation functions return these large constants to indicate
special semantics to the caller.  These are much larger than the bytes in a
page to allow for functions that return the number of bytes operated on in a
given page.
\index{sb\_end\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sb_end_write}\pysiglinewithargsret{void \bfcode{sb\_end\_write}}{struct super\_block *\emph{ sb}}{}
drop write access to a superblock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
the super we wrote to

\end{description}

\textbf{Description}

Decrement number of writers to the filesystem. Wake up possible waiters
wanting to freeze the filesystem.
\index{sb\_end\_pagefault (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sb_end_pagefault}\pysiglinewithargsret{void \bfcode{sb\_end\_pagefault}}{struct super\_block *\emph{ sb}}{}
drop write access to a superblock from a page fault

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
the super we wrote to

\end{description}

\textbf{Description}

Decrement number of processes handling write page fault to the filesystem.
Wake up possible waiters wanting to freeze the filesystem.
\index{sb\_end\_intwrite (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sb_end_intwrite}\pysiglinewithargsret{void \bfcode{sb\_end\_intwrite}}{struct super\_block *\emph{ sb}}{}
drop write access to a superblock for internal fs purposes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
the super we wrote to

\end{description}

\textbf{Description}

Decrement fs-internal number of writers to the filesystem.  Wake up possible
waiters wanting to freeze the filesystem.
\index{sb\_start\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sb_start_write}\pysiglinewithargsret{void \bfcode{sb\_start\_write}}{struct super\_block *\emph{ sb}}{}
get write access to a superblock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
the super we write to

\end{description}

\textbf{Description}

When a process wants to write data or metadata to a file system (i.e. dirty
a page or an inode), it should embed the operation in a {\hyperref[filesystems/index:c.sb_start_write]{\emph{\code{sb\_start\_write()}}}} -
{\hyperref[filesystems/index:c.sb_end_write]{\emph{\code{sb\_end\_write()}}}} pair to get exclusion against file system freezing. This
function increments number of writers preventing freezing. If the file
system is already frozen, the function waits until the file system is
thawed.

Since freeze protection behaves as a lock, users have to preserve
ordering of freeze protection and other filesystem locks. Generally,
freeze protection should be the outermost lock. In particular, we have:
\begin{description}
\item[{sb\_start\_write}] \leavevmode
-\textgreater{} i\_mutex                 (write path, truncate, directory ops, ...)
-\textgreater{} s\_umount                (freeze\_super, thaw\_super)

\end{description}
\index{sb\_start\_pagefault (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sb_start_pagefault}\pysiglinewithargsret{void \bfcode{sb\_start\_pagefault}}{struct super\_block *\emph{ sb}}{}
get write access to a superblock from a page fault

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
the super we write to

\end{description}

\textbf{Description}

When a process starts handling write page fault, it should embed the
operation into {\hyperref[filesystems/index:c.sb_start_pagefault]{\emph{\code{sb\_start\_pagefault()}}}} - {\hyperref[filesystems/index:c.sb_end_pagefault]{\emph{\code{sb\_end\_pagefault()}}}} pair to get
exclusion against file system freezing. This is needed since the page fault
is going to dirty a page. This function increments number of running page
faults preventing freezing. If the file system is already frozen, the
function waits until the file system is thawed.

Since page fault freeze protection behaves as a lock, users have to preserve
ordering of freeze protection and other filesystem locks. It is advised to
put {\hyperref[filesystems/index:c.sb_start_pagefault]{\emph{\code{sb\_start\_pagefault()}}}} close to mmap\_sem in lock ordering. Page fault
handling code implies lock dependency:
\begin{description}
\item[{mmap\_sem}] \leavevmode
-\textgreater{} sb\_start\_pagefault

\end{description}
\index{filemap\_set\_wb\_err (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.filemap_set_wb_err}\pysiglinewithargsret{void \bfcode{filemap\_set\_wb\_err}}{struct address\_space *\emph{ mapping}, int\emph{ err}}{}
set a writeback error on an address\_space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct address\_space * mapping}}] \leavevmode
mapping in which to set writeback error

\item[{\code{int err}}] \leavevmode
error to be set in mapping

\end{description}

\textbf{Description}

When writeback fails in some way, we must record that error so that
userspace can be informed when fsync and the like are called.  We endeavor
to report errors on any file that was open at the time of the error.  Some
internal callers also need to know when writeback errors have occurred.

When a writeback error occurs, most filesystems will want to call
filemap\_set\_wb\_err to record the error in the mapping so that it will be
automatically reported whenever fsync is called on the file.
\index{filemap\_check\_wb\_err (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.filemap_check_wb_err}\pysiglinewithargsret{int \bfcode{filemap\_check\_wb\_err}}{struct address\_space *\emph{ mapping}, errseq\_t\emph{ since}}{}
has an error occurred since the mark was sampled?

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct address\_space * mapping}}] \leavevmode
mapping to check for writeback errors

\item[{\code{errseq\_t since}}] \leavevmode
previously-sampled errseq\_t

\end{description}

\textbf{Description}

Grab the errseq\_t value from the mapping, and see if it has changed ``since''
the given value was sampled.

If it has then report the latest error set, otherwise return 0.
\index{filemap\_sample\_wb\_err (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.filemap_sample_wb_err}\pysiglinewithargsret{errseq\_t \bfcode{filemap\_sample\_wb\_err}}{struct address\_space *\emph{ mapping}}{}
sample the current errseq\_t to test for later errors

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct address\_space * mapping}}] \leavevmode
mapping to be sampled

\end{description}

\textbf{Description}

Writeback errors are always reported relative to a particular sample point
in the past. This function provides those sample points.


\section{The Directory Cache}
\label{filesystems/index:the-directory-cache}\index{shrink\_dcache\_sb (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.shrink_dcache_sb}\pysiglinewithargsret{void \bfcode{shrink\_dcache\_sb}}{struct super\_block *\emph{ sb}}{}
shrink dcache for a superblock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
superblock

\end{description}

\textbf{Description}

Shrink the dcache for the specified super block. This is used to free
the dcache before unmounting a file system.
\index{path\_has\_submounts (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.path_has_submounts}\pysiglinewithargsret{int \bfcode{path\_has\_submounts}}{const struct path *\emph{ parent}}{}
check for mounts over a dentry in the current namespace.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct path * parent}}] \leavevmode
path to check.

\end{description}

\textbf{Description}

Return true if the parent or its subdirectories contain
a mount point in the current namespace.
\index{shrink\_dcache\_parent (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.shrink_dcache_parent}\pysiglinewithargsret{void \bfcode{shrink\_dcache\_parent}}{struct dentry *\emph{ parent}}{}
prune dcache

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * parent}}] \leavevmode
parent of entries to prune

\end{description}

\textbf{Description}

Prune the dcache to remove unused children of the parent dentry.
\index{d\_invalidate (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_invalidate}\pysiglinewithargsret{void \bfcode{d\_invalidate}}{struct dentry *\emph{ dentry}}{}
detach submounts, prune dcache, and drop

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * dentry}}] \leavevmode
dentry to invalidate (aka detach, prune and drop)

\end{description}

\textbf{Description}

no dcache lock.

The final d\_drop is done as an atomic operation relative to
rename\_lock ensuring there are no races with d\_set\_mounted.  This
ensures there are no unhashed dentries on the path to a mountpoint.
\index{d\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_alloc}\pysiglinewithargsret{struct dentry * \bfcode{d\_alloc}}{struct dentry *\emph{ parent}, const struct qstr *\emph{ name}}{}
allocate a dcache entry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * parent}}] \leavevmode
parent of entry to allocate

\item[{\code{const struct qstr * name}}] \leavevmode
qstr of the name

\end{description}

\textbf{Description}

Allocates a dentry. It returns \code{NULL} if there is insufficient memory
available. On a success the dentry is returned. The name passed in is
copied and the copy passed in may be reused after this call.
\index{d\_alloc\_pseudo (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_alloc_pseudo}\pysiglinewithargsret{struct dentry * \bfcode{d\_alloc\_pseudo}}{struct super\_block *\emph{ sb}, const struct qstr *\emph{ name}}{}
allocate a dentry (for lookup-less filesystems)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
the superblock

\item[{\code{const struct qstr * name}}] \leavevmode
qstr of the name

\end{description}

\textbf{Description}

For a filesystem that just pins its dentries in memory and never
performs lookups at all, return an unhashed IS\_ROOT dentry.
\index{d\_instantiate (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_instantiate}\pysiglinewithargsret{void \bfcode{d\_instantiate}}{struct dentry *\emph{ entry}, struct inode *\emph{ inode}}{}
fill in inode information for a dentry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * entry}}] \leavevmode
dentry to complete

\item[{\code{struct inode * inode}}] \leavevmode
inode to attach to this dentry

\end{description}

\textbf{Description}

Fill in inode information in the entry.

This turns negative dentries into productive full members
of society.

NOTE! This assumes that the inode count has been incremented
(or otherwise set) by the caller to indicate that it is now
in use by the dcache.
\index{d\_instantiate\_no\_diralias (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_instantiate_no_diralias}\pysiglinewithargsret{int \bfcode{d\_instantiate\_no\_diralias}}{struct dentry *\emph{ entry}, struct inode *\emph{ inode}}{}
instantiate a non-aliased dentry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * entry}}] \leavevmode
dentry to complete

\item[{\code{struct inode * inode}}] \leavevmode
inode to attach to this dentry

\end{description}

\textbf{Description}

Fill in inode information in the entry.  If a directory alias is found, then
return an error (and drop inode).  Together with \code{d\_materialise\_unique()} this
guarantees that a directory inode may never have more than one alias.
\index{d\_find\_any\_alias (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_find_any_alias}\pysiglinewithargsret{struct dentry * \bfcode{d\_find\_any\_alias}}{struct inode *\emph{ inode}}{}
find any alias for a given inode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode to find an alias for

\end{description}

\textbf{Description}

If any aliases exist for the given inode, take and return a
reference for one of them.  If no aliases exist, return \code{NULL}.
\index{d\_obtain\_alias (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_obtain_alias}\pysiglinewithargsret{struct dentry * \bfcode{d\_obtain\_alias}}{struct inode *\emph{ inode}}{}
find or allocate a DISCONNECTED dentry for a given inode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode to allocate the dentry for

\end{description}

\textbf{Description}

Obtain a dentry for an inode resulting from NFS filehandle conversion or
similar open by handle operations.  The returned dentry may be anonymous,
or may have a full name (if the inode was already in the cache).

When called on a directory inode, we must ensure that the inode only ever
has one dentry.  If a dentry is found, that is returned instead of
allocating a new one.

On successful return, the reference to the inode has been transferred
to the dentry.  In case of an error the reference on the inode is released.
To make it easier to use in export operations a \code{NULL} or IS\_ERR inode may
be passed in and the error will be propagated to the return value,
with a \code{NULL} \textbf{inode} replaced by ERR\_PTR(-ESTALE).
\index{d\_obtain\_root (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_obtain_root}\pysiglinewithargsret{struct dentry * \bfcode{d\_obtain\_root}}{struct inode *\emph{ inode}}{}
find or allocate a dentry for a given inode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode to allocate the dentry for

\end{description}

\textbf{Description}

Obtain an IS\_ROOT dentry for the root of a filesystem.

We must ensure that directory inodes only ever have one dentry.  If a
dentry is found, that is returned instead of allocating a new one.

On successful return, the reference to the inode has been transferred
to the dentry.  In case of an error the reference on the inode is
released.  A \code{NULL} or IS\_ERR inode may be passed in and will be the
error will be propagate to the return value, with a \code{NULL} \textbf{inode}
replaced by ERR\_PTR(-ESTALE).
\index{d\_add\_ci (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_add_ci}\pysiglinewithargsret{struct dentry * \bfcode{d\_add\_ci}}{struct dentry *\emph{ dentry}, struct inode *\emph{ inode}, struct qstr *\emph{ name}}{}
lookup or allocate new dentry with case-exact name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * dentry}}] \leavevmode
the negative dentry that was passed to the parent's lookup func

\item[{\code{struct inode * inode}}] \leavevmode
the inode case-insensitive lookup has found

\item[{\code{struct qstr * name}}] \leavevmode
the case-exact name to be associated with the returned dentry

\end{description}

\textbf{Description}

This is to avoid filling the dcache with case-insensitive names to the
same inode, only the actual correct case is stored in the dcache for
case-insensitive filesystems.

For a case-insensitive lookup match and if the the case-exact dentry
already exists in in the dcache, use it and return it.

If no entry exists with the exact case name, allocate new dentry with
the exact case, and return the spliced entry.
\index{d\_lookup (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_lookup}\pysiglinewithargsret{struct dentry * \bfcode{d\_lookup}}{const struct dentry *\emph{ parent}, const struct qstr *\emph{ name}}{}
search for a dentry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct dentry * parent}}] \leavevmode
parent dentry

\item[{\code{const struct qstr * name}}] \leavevmode
qstr of name we wish to find

\end{description}

\textbf{Return}

dentry, or NULL

d\_lookup searches the children of the parent dentry for the name in
question. If the dentry is found its reference count is incremented and the
dentry is returned. The caller must use dput to free the entry when it has
finished using it. \code{NULL} is returned if the dentry does not exist.
\index{d\_hash\_and\_lookup (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_hash_and_lookup}\pysiglinewithargsret{struct dentry * \bfcode{d\_hash\_and\_lookup}}{struct dentry *\emph{ dir}, struct qstr *\emph{ name}}{}
hash the qstr then search for a dentry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * dir}}] \leavevmode
Directory to search in

\item[{\code{struct qstr * name}}] \leavevmode
qstr of name we wish to find

\end{description}

\textbf{Description}

On lookup failure NULL is returned; on bad name - ERR\_PTR(-error)
\index{d\_delete (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_delete}\pysiglinewithargsret{void \bfcode{d\_delete}}{struct dentry *\emph{ dentry}}{}
delete a dentry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * dentry}}] \leavevmode
The dentry to delete

\end{description}

\textbf{Description}

Turn the dentry into a negative dentry if possible, otherwise
remove it from the hash queues so it can be deleted later
\index{d\_rehash (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_rehash}\pysiglinewithargsret{void \bfcode{d\_rehash}}{struct dentry *\emph{ entry}}{}
add an entry back to the hash

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * entry}}] \leavevmode
dentry to add to the hash

\end{description}

\textbf{Description}

Adds a dentry to the hash according to its name.
\index{d\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_add}\pysiglinewithargsret{void \bfcode{d\_add}}{struct dentry *\emph{ entry}, struct inode *\emph{ inode}}{}
add dentry to hash queues

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * entry}}] \leavevmode
dentry to add

\item[{\code{struct inode * inode}}] \leavevmode
The inode to attach to this dentry

\end{description}

\textbf{Description}

This adds the entry to the hash queues and initializes \textbf{inode}.
The entry was actually filled in earlier during {\hyperref[filesystems/index:c.d_alloc]{\emph{\code{d\_alloc()}}}}.
\index{d\_exact\_alias (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_exact_alias}\pysiglinewithargsret{struct dentry * \bfcode{d\_exact\_alias}}{struct dentry *\emph{ entry}, struct inode *\emph{ inode}}{}
find and hash an exact unhashed alias

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * entry}}] \leavevmode
dentry to add

\item[{\code{struct inode * inode}}] \leavevmode
The inode to go with this dentry

\end{description}

\textbf{Description}

If an unhashed dentry with the same name/parent and desired
inode already exists, hash and return it.  Otherwise, return
NULL.

Parent directory should be locked.
\index{dentry\_update\_name\_case (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.dentry_update_name_case}\pysiglinewithargsret{void \bfcode{dentry\_update\_name\_case}}{struct dentry *\emph{ dentry}, const struct qstr *\emph{ name}}{}
update case insensitive dentry with a new name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * dentry}}] \leavevmode
dentry to be updated

\item[{\code{const struct qstr * name}}] \leavevmode
new name

\end{description}

\textbf{Description}

Update a case insensitive dentry with new case of name.

dentry must have been returned by d\_lookup with name \textbf{name}. Old and new
name lengths must match (ie. no d\_compare which allows mismatched name
lengths).

Parent inode i\_mutex must be held over d\_lookup and into this call (to
keep renames and concurrent inserts, and readdir(2) away).
\index{d\_splice\_alias (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_splice_alias}\pysiglinewithargsret{struct dentry * \bfcode{d\_splice\_alias}}{struct inode *\emph{ inode}, struct dentry *\emph{ dentry}}{}
splice a disconnected dentry into the tree if one exists

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
the inode which may have a disconnected dentry

\item[{\code{struct dentry * dentry}}] \leavevmode
a negative dentry which we want to point to the inode.

\end{description}

\textbf{Description}

If inode is a directory and has an IS\_ROOT alias, then d\_move that in
place of the given dentry and return it, else simply d\_add the inode
to the dentry and return NULL.

If a non-IS\_ROOT directory is found, the filesystem is corrupt, and
we should error out: directories can't have multiple aliases.

This is needed in the lookup routine of any filesystem that is exportable
(via knfsd) so that we can build dcache paths to directories effectively.

If a dentry was found and moved, then it is returned.  Otherwise NULL
is returned.  This matches the expected return value of -\textgreater{}lookup.

Cluster filesystems may call this function with a negative, hashed dentry.
In that case, we know that the inode will be a regular file, and also this
will only occur during atomic\_open. So we need to check for the dentry
being already hashed only in the final case.
\index{d\_path (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_path}\pysiglinewithargsret{char * \bfcode{d\_path}}{const struct path *\emph{ path}, char *\emph{ buf}, int\emph{ buflen}}{}
return the path of a dentry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct path * path}}] \leavevmode
path to report

\item[{\code{char * buf}}] \leavevmode
buffer to return value in

\item[{\code{int buflen}}] \leavevmode
buffer length

\end{description}

\textbf{Description}

Convert a dentry into an ASCII path name. If the entry has been deleted
the string '' (deleted)'' is appended. Note that this is ambiguous.

Returns a pointer into the buffer or an error code if the path was
too long. Note: Callers should use the returned pointer, not the passed
in buffer, to use the name! The implementation often starts at an offset
into the buffer, and may leave 0 bytes at the start.

``buflen'' should be positive.
\index{is\_subdir (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.is_subdir}\pysiglinewithargsret{bool \bfcode{is\_subdir}}{struct dentry *\emph{ new\_dentry}, struct dentry *\emph{ old\_dentry}}{}
is new dentry a subdirectory of old\_dentry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * new\_dentry}}] \leavevmode
new dentry

\item[{\code{struct dentry * old\_dentry}}] \leavevmode
old dentry

\end{description}

\textbf{Description}

Returns true if new\_dentry is a subdirectory of the parent (at any depth).
Returns false otherwise.
Caller must ensure that ``new\_dentry'' is pinned before calling {\hyperref[filesystems/index:c.is_subdir]{\emph{\code{is\_subdir()}}}}
\index{dget\_dlock (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.dget_dlock}\pysiglinewithargsret{struct dentry * \bfcode{dget\_dlock}}{struct dentry *\emph{ dentry}}{}
get a reference to a dentry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * dentry}}] \leavevmode
dentry to get a reference to

\end{description}

\textbf{Description}
\begin{quote}

Given a dentry or \code{NULL} pointer increment the reference count
if appropriate and return the dentry. A dentry will not be
destroyed when it has references.
\end{quote}
\index{d\_unhashed (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_unhashed}\pysiglinewithargsret{int \bfcode{d\_unhashed}}{const struct dentry *\emph{ dentry}}{}
is dentry hashed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct dentry * dentry}}] \leavevmode
entry to check

\end{description}

\textbf{Description}
\begin{quote}

Returns true if the dentry passed is not currently hashed.
\end{quote}
\index{d\_really\_is\_negative (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_really_is_negative}\pysiglinewithargsret{bool \bfcode{d\_really\_is\_negative}}{const struct dentry *\emph{ dentry}}{}
Determine if a dentry is really negative (ignoring fallthroughs)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct dentry * dentry}}] \leavevmode
The dentry in question

\end{description}

\textbf{Description}

Returns true if the dentry represents either an absent name or a name that
doesn't map to an inode (ie. -\textgreater{}d\_inode is NULL).  The dentry could represent
a true miss, a whiteout that isn't represented by a 0,0 chardev or a
fallthrough marker in an opaque directory.

Note!  (1) This should be used \emph{only} by a filesystem to examine its own
dentries.  It should not be used to look at some other filesystem's
dentries.  (2) It should also be used in combination with {\hyperref[filesystems/index:c.d_inode]{\emph{\code{d\_inode()}}}} to get
the inode.  (3) The dentry may have something attached to -\textgreater{}d\_lower and the
type field of the flags may be set to something other than miss or whiteout.
\index{d\_really\_is\_positive (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_really_is_positive}\pysiglinewithargsret{bool \bfcode{d\_really\_is\_positive}}{const struct dentry *\emph{ dentry}}{}
Determine if a dentry is really positive (ignoring fallthroughs)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct dentry * dentry}}] \leavevmode
The dentry in question

\end{description}

\textbf{Description}

Returns true if the dentry represents a name that maps to an inode
(ie. -\textgreater{}d\_inode is not NULL).  The dentry might still represent a whiteout if
that is represented on medium as a 0,0 chardev.

Note!  (1) This should be used \emph{only} by a filesystem to examine its own
dentries.  It should not be used to look at some other filesystem's
dentries.  (2) It should also be used in combination with {\hyperref[filesystems/index:c.d_inode]{\emph{\code{d\_inode()}}}} to get
the inode.
\index{d\_inode (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_inode}\pysiglinewithargsret{struct inode * \bfcode{d\_inode}}{const struct dentry *\emph{ dentry}}{}
Get the actual inode of this dentry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct dentry * dentry}}] \leavevmode
The dentry to query

\end{description}

\textbf{Description}

This is the helper normal filesystems should use to get at their own inodes
in their own dentries and ignore the layering superimposed upon them.
\index{d\_inode\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_inode_rcu}\pysiglinewithargsret{struct inode * \bfcode{d\_inode\_rcu}}{const struct dentry *\emph{ dentry}}{}
Get the actual inode of this dentry with \code{READ\_ONCE()}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct dentry * dentry}}] \leavevmode
The dentry to query

\end{description}

\textbf{Description}

This is the helper normal filesystems should use to get at their own inodes
in their own dentries and ignore the layering superimposed upon them.
\index{d\_backing\_inode (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_backing_inode}\pysiglinewithargsret{struct inode * \bfcode{d\_backing\_inode}}{const struct dentry *\emph{ upper}}{}
Get upper or lower inode we should be using

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct dentry * upper}}] \leavevmode
The upper layer

\end{description}

\textbf{Description}

This is the helper that should be used to get at the inode that will be used
if this dentry were to be opened as a file.  The inode may be on the upper
dentry or it may be on a lower dentry pinned by the upper.

Normal filesystems should not use this to access their own inodes.
\index{d\_backing\_dentry (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_backing_dentry}\pysiglinewithargsret{struct dentry * \bfcode{d\_backing\_dentry}}{struct dentry *\emph{ upper}}{}
Get upper or lower dentry we should be using

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * upper}}] \leavevmode
The upper layer

\end{description}

\textbf{Description}

This is the helper that should be used to get the dentry of the inode that
will be used if this dentry were opened as a file.  It may be the upper
dentry or it may be a lower dentry pinned by the upper.

Normal filesystems should not use this to access their own dentries.
\index{d\_real (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_real}\pysiglinewithargsret{struct dentry * \bfcode{d\_real}}{struct dentry *\emph{ dentry}, const struct inode *\emph{ inode}, unsigned int\emph{ open\_flags}, unsigned int\emph{ flags}}{}
Return the real dentry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * dentry}}] \leavevmode
the dentry to query

\item[{\code{const struct inode * inode}}] \leavevmode
inode to select the dentry from multiple layers (can be NULL)

\item[{\code{unsigned int open\_flags}}] \leavevmode
open flags to control copy-up behavior

\item[{\code{unsigned int flags}}] \leavevmode
flags to control what is returned by this function

\end{description}

\textbf{Description}

If dentry is on a union/overlay, then return the underlying, real dentry.
Otherwise return the dentry itself.

See also: Documentation/filesystems/vfs.txt
\index{d\_real\_inode (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.d_real_inode}\pysiglinewithargsret{struct inode * \bfcode{d\_real\_inode}}{const struct dentry *\emph{ dentry}}{}
Return the real inode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct dentry * dentry}}] \leavevmode
The dentry to query

\end{description}

\textbf{Description}

If dentry is on a union/overlay, then return the underlying, real inode.
Otherwise return {\hyperref[filesystems/index:c.d_inode]{\emph{\code{d\_inode()}}}}.


\section{Inode Handling}
\label{filesystems/index:inode-handling}\index{inode\_init\_always (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.inode_init_always}\pysiglinewithargsret{int \bfcode{inode\_init\_always}}{struct super\_block *\emph{ sb}, struct inode *\emph{ inode}}{}
perform inode structure initialisation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
superblock inode belongs to

\item[{\code{struct inode * inode}}] \leavevmode
inode to initialise

\end{description}

\textbf{Description}

These are initializations that need to be done on every inode
allocation as the fields are not initialised by slab allocation.
\index{drop\_nlink (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.drop_nlink}\pysiglinewithargsret{void \bfcode{drop\_nlink}}{struct inode *\emph{ inode}}{}
directly drop an inode's link count

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode

\end{description}

\textbf{Description}

This is a low-level filesystem helper to replace any
direct filesystem manipulation of i\_nlink.  In cases
where we are attempting to track writes to the
filesystem, a decrement to zero means an imminent
write when the file is truncated and actually unlinked
on the filesystem.
\index{clear\_nlink (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.clear_nlink}\pysiglinewithargsret{void \bfcode{clear\_nlink}}{struct inode *\emph{ inode}}{}
directly zero an inode's link count

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode

\end{description}

\textbf{Description}

This is a low-level filesystem helper to replace any
direct filesystem manipulation of i\_nlink.  See
{\hyperref[filesystems/index:c.drop_nlink]{\emph{\code{drop\_nlink()}}}} for why we care about i\_nlink hitting zero.
\index{set\_nlink (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.set_nlink}\pysiglinewithargsret{void \bfcode{set\_nlink}}{struct inode *\emph{ inode}, unsigned int\emph{ nlink}}{}
directly set an inode's link count

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode

\item[{\code{unsigned int nlink}}] \leavevmode
new nlink (should be non-zero)

\end{description}

\textbf{Description}

This is a low-level filesystem helper to replace any
direct filesystem manipulation of i\_nlink.
\index{inc\_nlink (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.inc_nlink}\pysiglinewithargsret{void \bfcode{inc\_nlink}}{struct inode *\emph{ inode}}{}
directly increment an inode's link count

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode

\end{description}

\textbf{Description}

This is a low-level filesystem helper to replace any
direct filesystem manipulation of i\_nlink.  Currently,
it is only here for parity with \code{dec\_nlink()}.
\index{inode\_sb\_list\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.inode_sb_list_add}\pysiglinewithargsret{void \bfcode{inode\_sb\_list\_add}}{struct inode *\emph{ inode}}{}
add inode to the superblock list of inodes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode to add

\end{description}
\index{\_\_insert\_inode\_hash (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.__insert_inode_hash}\pysiglinewithargsret{void \bfcode{\_\_insert\_inode\_hash}}{struct inode *\emph{ inode}, unsigned long\emph{ hashval}}{}
hash an inode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
unhashed inode

\item[{\code{unsigned long hashval}}] \leavevmode
unsigned long value used to locate this object in the
inode\_hashtable.

\end{description}

\textbf{Description}
\begin{quote}

Add an inode to the inode hash for this superblock.
\end{quote}
\index{\_\_remove\_inode\_hash (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.__remove_inode_hash}\pysiglinewithargsret{void \bfcode{\_\_remove\_inode\_hash}}{struct inode *\emph{ inode}}{}
remove an inode from the hash

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode to unhash

\end{description}

\textbf{Description}
\begin{quote}

Remove an inode from the superblock.
\end{quote}
\index{evict\_inodes (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.evict_inodes}\pysiglinewithargsret{void \bfcode{evict\_inodes}}{struct super\_block *\emph{ sb}}{}
evict all evictable inodes for a superblock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
superblock to operate on

\end{description}

\textbf{Description}

Make sure that no inodes with zero refcount are retained.  This is
called by superblock shutdown after having SB\_ACTIVE flag removed,
so any inode reaching zero refcount during or after that call will
be immediately evicted.
\index{new\_inode (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.new_inode}\pysiglinewithargsret{struct inode * \bfcode{new\_inode}}{struct super\_block *\emph{ sb}}{}
obtain an inode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
superblock

\end{description}

\textbf{Description}
\begin{quote}

Allocates a new inode for given superblock. The default gfp\_mask
for allocations related to inode-\textgreater{}i\_mapping is GFP\_HIGHUSER\_MOVABLE.
If HIGHMEM pages are unsuitable or it is known that pages allocated
for the page cache are not reclaimable or migratable,
\code{mapping\_set\_gfp\_mask()} must be called with suitable flags on the
newly created inode's mapping
\end{quote}
\index{unlock\_new\_inode (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.unlock_new_inode}\pysiglinewithargsret{void \bfcode{unlock\_new\_inode}}{struct inode *\emph{ inode}}{}
clear the I\_NEW state and wake up any waiters

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
new inode to unlock

\end{description}

\textbf{Description}

Called when the inode is fully initialised to clear the new state of the
inode and wake up anyone waiting for the inode to finish initialisation.
\index{lock\_two\_nondirectories (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.lock_two_nondirectories}\pysiglinewithargsret{void \bfcode{lock\_two\_nondirectories}}{struct inode *\emph{ inode1}, struct inode *\emph{ inode2}}{}
take two i\_mutexes on non-directory objects

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode1}}] \leavevmode
first inode to lock

\item[{\code{struct inode * inode2}}] \leavevmode
second inode to lock

\end{description}

\textbf{Description}

Lock any non-NULL argument that is not a directory.
Zero, one or two objects may be locked by this function.
\index{unlock\_two\_nondirectories (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.unlock_two_nondirectories}\pysiglinewithargsret{void \bfcode{unlock\_two\_nondirectories}}{struct inode *\emph{ inode1}, struct inode *\emph{ inode2}}{}
release locks from {\hyperref[filesystems/index:c.lock_two_nondirectories]{\emph{\code{lock\_two\_nondirectories()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode1}}] \leavevmode
first inode to unlock

\item[{\code{struct inode * inode2}}] \leavevmode
second inode to unlock

\end{description}
\index{iget5\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.iget5_locked}\pysiglinewithargsret{struct inode * \bfcode{iget5\_locked}}{struct super\_block *\emph{ sb}, unsigned long\emph{ hashval}, int (*test) (struct inode\emph{ *}, void\emph{ *}, int (*set) (struct inode\emph{ *}, void\emph{ *}, void *\emph{ data}}{}
obtain an inode from a mounted file system

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
super block of file system

\item[{\code{unsigned long hashval}}] \leavevmode
hash value (usually inode number) to get

\item[{\code{int (*)(struct inode *, void *) test}}] \leavevmode
callback used for comparisons between inodes

\item[{\code{int (*)(struct inode *, void *) set}}] \leavevmode
callback used to initialize a new struct inode

\item[{\code{void * data}}] \leavevmode
opaque data pointer to pass to \textbf{test} and \textbf{set}

\end{description}

\textbf{Description}

Search for the inode specified by \textbf{hashval} and \textbf{data} in the inode cache,
and if present it is return it with an increased reference count. This is
a generalized version of {\hyperref[filesystems/index:c.iget_locked]{\emph{\code{iget\_locked()}}}} for file systems where the inode
number is not sufficient for unique identification of an inode.

If the inode is not in cache, allocate a new inode and return it locked,
hashed, and with the I\_NEW flag set. The file system gets to fill it in
before unlocking it via {\hyperref[filesystems/index:c.unlock_new_inode]{\emph{\code{unlock\_new\_inode()}}}}.

Note both \textbf{test} and \textbf{set} are called with the inode\_hash\_lock held, so can't
sleep.
\index{iget\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.iget_locked}\pysiglinewithargsret{struct inode * \bfcode{iget\_locked}}{struct super\_block *\emph{ sb}, unsigned long\emph{ ino}}{}
obtain an inode from a mounted file system

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
super block of file system

\item[{\code{unsigned long ino}}] \leavevmode
inode number to get

\end{description}

\textbf{Description}

Search for the inode specified by \textbf{ino} in the inode cache and if present
return it with an increased reference count. This is for file systems
where the inode number is sufficient for unique identification of an inode.

If the inode is not in cache, allocate a new inode and return it locked,
hashed, and with the I\_NEW flag set.  The file system gets to fill it in
before unlocking it via {\hyperref[filesystems/index:c.unlock_new_inode]{\emph{\code{unlock\_new\_inode()}}}}.
\index{iunique (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.iunique}\pysiglinewithargsret{ino\_t \bfcode{iunique}}{struct super\_block *\emph{ sb}, ino\_t\emph{ max\_reserved}}{}
get a unique inode number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
superblock

\item[{\code{ino\_t max\_reserved}}] \leavevmode
highest reserved inode number

\end{description}

\textbf{Description}
\begin{quote}

Obtain an inode number that is unique on the system for a given
superblock. This is used by file systems that have no natural
permanent inode numbering system. An inode number is returned that
is higher than the reserved limit but unique.

BUGS:
With a large number of inodes live on the file system this function
currently becomes quite slow.
\end{quote}
\index{ilookup5\_nowait (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.ilookup5_nowait}\pysiglinewithargsret{struct inode * \bfcode{ilookup5\_nowait}}{struct super\_block *\emph{ sb}, unsigned long\emph{ hashval}, int (*test) (struct inode\emph{ *}, void\emph{ *}, void *\emph{ data}}{}
search for an inode in the inode cache

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
super block of file system to search

\item[{\code{unsigned long hashval}}] \leavevmode
hash value (usually inode number) to search for

\item[{\code{int (*)(struct inode *, void *) test}}] \leavevmode
callback used for comparisons between inodes

\item[{\code{void * data}}] \leavevmode
opaque data pointer to pass to \textbf{test}

\end{description}

\textbf{Description}

Search for the inode specified by \textbf{hashval} and \textbf{data} in the inode cache.
If the inode is in the cache, the inode is returned with an incremented
reference count.

\textbf{Note}

I\_NEW is not waited upon so you have to be very careful what you do
with the returned inode.  You probably should be using {\hyperref[filesystems/index:c.ilookup5]{\emph{\code{ilookup5()}}}} instead.

Note2: \textbf{test} is called with the inode\_hash\_lock held, so can't sleep.
\index{ilookup5 (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.ilookup5}\pysiglinewithargsret{struct inode * \bfcode{ilookup5}}{struct super\_block *\emph{ sb}, unsigned long\emph{ hashval}, int (*test) (struct inode\emph{ *}, void\emph{ *}, void *\emph{ data}}{}
search for an inode in the inode cache

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
super block of file system to search

\item[{\code{unsigned long hashval}}] \leavevmode
hash value (usually inode number) to search for

\item[{\code{int (*)(struct inode *, void *) test}}] \leavevmode
callback used for comparisons between inodes

\item[{\code{void * data}}] \leavevmode
opaque data pointer to pass to \textbf{test}

\end{description}

\textbf{Description}

Search for the inode specified by \textbf{hashval} and \textbf{data} in the inode cache,
and if the inode is in the cache, return the inode with an incremented
reference count.  Waits on I\_NEW before returning the inode.
returned with an incremented reference count.

This is a generalized version of {\hyperref[filesystems/index:c.ilookup]{\emph{\code{ilookup()}}}} for file systems where the
inode number is not sufficient for unique identification of an inode.

\textbf{Note}

\textbf{test} is called with the inode\_hash\_lock held, so can't sleep.
\index{ilookup (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.ilookup}\pysiglinewithargsret{struct inode * \bfcode{ilookup}}{struct super\_block *\emph{ sb}, unsigned long\emph{ ino}}{}
search for an inode in the inode cache

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
super block of file system to search

\item[{\code{unsigned long ino}}] \leavevmode
inode number to search for

\end{description}

\textbf{Description}

Search for the inode \textbf{ino} in the inode cache, and if the inode is in the
cache, the inode is returned with an incremented reference count.
\index{find\_inode\_nowait (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.find_inode_nowait}\pysiglinewithargsret{struct inode * \bfcode{find\_inode\_nowait}}{struct super\_block *\emph{ sb}, unsigned long\emph{ hashval}, int (*match) (struct inode\emph{ *}, unsigned\emph{ long}, void\emph{ *}, void *\emph{ data}}{}
find an inode in the inode cache

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
super block of file system to search

\item[{\code{unsigned long hashval}}] \leavevmode
hash value (usually inode number) to search for

\item[{\code{int (*)(struct inode *, unsigned long, void *) match}}] \leavevmode
callback used for comparisons between inodes

\item[{\code{void * data}}] \leavevmode
opaque data pointer to pass to \textbf{match}

\end{description}

\textbf{Description}

Search for the inode specified by \textbf{hashval} and \textbf{data} in the inode
cache, where the helper function \textbf{match} will return 0 if the inode
does not match, 1 if the inode does match, and -1 if the search
should be stopped.  The \textbf{match} function must be responsible for
taking the i\_lock spin\_lock and checking i\_state for an inode being
freed or being initialized, and incrementing the reference count
before returning 1.  It also must not sleep, since it is called with
the inode\_hash\_lock spinlock held.

This is a even more generalized version of {\hyperref[filesystems/index:c.ilookup5]{\emph{\code{ilookup5()}}}} when the
function must never block --- \code{find\_inode()} can block in
\code{\_\_wait\_on\_freeing\_inode()} --- or when the caller can not increment
the reference count because the resulting {\hyperref[filesystems/index:c.iput]{\emph{\code{iput()}}}} might cause an
inode eviction.  The tradeoff is that the \textbf{match} funtion must be
very carefully implemented.
\index{iput (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.iput}\pysiglinewithargsret{void \bfcode{iput}}{struct inode *\emph{ inode}}{}
put an inode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode to put

\end{description}

\textbf{Description}
\begin{quote}

Puts an inode, dropping its usage count. If the inode use count hits
zero, the inode is then freed and may also be destroyed.

Consequently, {\hyperref[filesystems/index:c.iput]{\emph{\code{iput()}}}} can sleep.
\end{quote}
\index{bmap (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bmap}\pysiglinewithargsret{sector\_t \bfcode{bmap}}{struct inode *\emph{ inode}, sector\_t\emph{ block}}{}
find a block number in a file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode of file

\item[{\code{sector\_t block}}] \leavevmode
block to find

\end{description}

\textbf{Description}
\begin{quote}

Returns the block number on the device holding the inode that
is the disk block number for the block of the file requested.
That is, asked for block 4 of inode 1 the function will return the
disk block relative to the disk start that holds that block of the
file.
\end{quote}
\index{file\_update\_time (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.file_update_time}\pysiglinewithargsret{int \bfcode{file\_update\_time}}{struct file *\emph{ file}}{}
update mtime and ctime time

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * file}}] \leavevmode
file accessed

\end{description}

\textbf{Description}
\begin{quote}

Update the mtime and ctime members of an inode and mark the inode
for writeback.  Note that this function is meant exclusively for
usage in the file write path of filesystems, and filesystems may
choose to explicitly ignore update via this function with the
S\_NOCMTIME inode flag, e.g. for network filesystem where these
timestamps are handled by the server.  This can return an error for
file systems who need to allocate space in order to update an inode.
\end{quote}
\index{inode\_init\_owner (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.inode_init_owner}\pysiglinewithargsret{void \bfcode{inode\_init\_owner}}{struct inode *\emph{ inode}, const struct inode *\emph{ dir}, umode\_t\emph{ mode}}{}
Init uid,gid,mode for new inode according to posix standards

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
New inode

\item[{\code{const struct inode * dir}}] \leavevmode
Directory inode

\item[{\code{umode\_t mode}}] \leavevmode
mode of the new inode

\end{description}
\index{inode\_owner\_or\_capable (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.inode_owner_or_capable}\pysiglinewithargsret{bool \bfcode{inode\_owner\_or\_capable}}{const struct inode *\emph{ inode}}{}
check current task permissions to inode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct inode * inode}}] \leavevmode
inode being checked

\end{description}

\textbf{Description}

Return true if current either has CAP\_FOWNER in a namespace with the
inode owner uid mapped, or owns the file.
\index{inode\_dio\_wait (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.inode_dio_wait}\pysiglinewithargsret{void \bfcode{inode\_dio\_wait}}{struct inode *\emph{ inode}}{}
wait for outstanding DIO requests to finish

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode to wait for

\end{description}

\textbf{Description}

Waits for all pending direct I/O requests to finish so that we can
proceed with a truncate or equivalent operation.

Must be called under a lock that serializes taking new references
to i\_dio\_count, usually by inode-\textgreater{}i\_mutex.
\index{current\_time (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.current_time}\pysiglinewithargsret{struct timespec \bfcode{current\_time}}{struct inode *\emph{ inode}}{}
Return FS time

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode.

\end{description}

\textbf{Description}

Return the current time truncated to the time granularity supported by
the fs.

Note that inode and inode-\textgreater{}sb cannot be NULL.
Otherwise, the function warns and returns time without truncation.
\index{make\_bad\_inode (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.make_bad_inode}\pysiglinewithargsret{void \bfcode{make\_bad\_inode}}{struct inode *\emph{ inode}}{}
mark an inode bad due to an I/O error

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
Inode to mark bad

\end{description}

\textbf{Description}
\begin{quote}

When an inode cannot be read due to a media or remote network
failure this function makes the inode ``bad'' and causes I/O operations
on it to fail from this point on.
\end{quote}
\index{is\_bad\_inode (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.is_bad_inode}\pysiglinewithargsret{bool \bfcode{is\_bad\_inode}}{struct inode *\emph{ inode}}{}
is an inode errored

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode to test

\end{description}

\textbf{Description}
\begin{quote}

Returns true if the inode in question has been marked as bad.
\end{quote}
\index{iget\_failed (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.iget_failed}\pysiglinewithargsret{void \bfcode{iget\_failed}}{struct inode *\emph{ inode}}{}
Mark an under-construction inode as dead and release it

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
The inode to discard

\end{description}

\textbf{Description}

Mark an under-construction inode as dead and release it.


\section{Registration and Superblocks}
\label{filesystems/index:registration-and-superblocks}\index{deactivate\_locked\_super (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.deactivate_locked_super}\pysiglinewithargsret{void \bfcode{deactivate\_locked\_super}}{struct super\_block *\emph{ s}}{}
drop an active reference to superblock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * s}}] \leavevmode
superblock to deactivate

\end{description}

\textbf{Description}
\begin{quote}

Drops an active reference to superblock, converting it into a temporary
one if there is no other active references left.  In that case we
tell fs driver to shut it down and drop the temporary reference we
had just acquired.

Caller holds exclusive lock on superblock; that lock is released.
\end{quote}
\index{deactivate\_super (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.deactivate_super}\pysiglinewithargsret{void \bfcode{deactivate\_super}}{struct super\_block *\emph{ s}}{}
drop an active reference to superblock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * s}}] \leavevmode
superblock to deactivate

\end{description}

\textbf{Description}
\begin{quote}

Variant of {\hyperref[filesystems/index:c.deactivate_locked_super]{\emph{\code{deactivate\_locked\_super()}}}}, except that superblock is \emph{not}
locked by caller.  If we are going to drop the final active reference,
lock will be acquired prior to that.
\end{quote}
\index{generic\_shutdown\_super (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.generic_shutdown_super}\pysiglinewithargsret{void \bfcode{generic\_shutdown\_super}}{struct super\_block *\emph{ sb}}{}
common helper for -\textgreater{}:c:func:\emph{kill\_sb()}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
superblock to kill

\end{description}

\textbf{Description}
\begin{quote}

{\hyperref[filesystems/index:c.generic_shutdown_super]{\emph{\code{generic\_shutdown\_super()}}}} does all fs-independent work on superblock
shutdown.  Typical -\textgreater{}:c:func:\emph{kill\_sb()} should pick all fs-specific objects
that need destruction out of superblock, call {\hyperref[filesystems/index:c.generic_shutdown_super]{\emph{\code{generic\_shutdown\_super()}}}}
and release aforementioned objects.  Note: dentries and inodes \_are\_
taken care of and do not need specific handling.

Upon calling this function, the filesystem may no longer alter or
rearrange the set of dentries belonging to this super\_block, nor may it
change the attachments of dentries to inodes.
\end{quote}
\index{sget\_userns (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sget_userns}\pysiglinewithargsret{struct super\_block * \bfcode{sget\_userns}}{struct file\_system\_type *\emph{ type}, int (*test) (struct super\_block\emph{ *}, void\emph{ *}, int (*set) (struct super\_block\emph{ *}, void\emph{ *}, int\emph{ flags}, struct user\_namespace *\emph{ user\_ns}, void *\emph{ data}}{}
find or create a superblock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file\_system\_type * type}}] \leavevmode
filesystem type superblock should belong to

\item[{\code{int (*)(struct super\_block *,void *) test}}] \leavevmode
comparison callback

\item[{\code{int (*)(struct super\_block *,void *) set}}] \leavevmode
setup callback

\item[{\code{int flags}}] \leavevmode
mount flags

\item[{\code{struct user\_namespace * user\_ns}}] \leavevmode
User namespace for the super\_block

\item[{\code{void * data}}] \leavevmode
argument to each of them

\end{description}
\index{sget (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sget}\pysiglinewithargsret{struct super\_block * \bfcode{sget}}{struct file\_system\_type *\emph{ type}, int (*test) (struct super\_block\emph{ *}, void\emph{ *}, int (*set) (struct super\_block\emph{ *}, void\emph{ *}, int\emph{ flags}, void *\emph{ data}}{}
find or create a superblock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file\_system\_type * type}}] \leavevmode
filesystem type superblock should belong to

\item[{\code{int (*)(struct super\_block *,void *) test}}] \leavevmode
comparison callback

\item[{\code{int (*)(struct super\_block *,void *) set}}] \leavevmode
setup callback

\item[{\code{int flags}}] \leavevmode
mount flags

\item[{\code{void * data}}] \leavevmode
argument to each of them

\end{description}
\index{iterate\_supers\_type (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.iterate_supers_type}\pysiglinewithargsret{void \bfcode{iterate\_supers\_type}}{struct file\_system\_type *\emph{ type}, void (*f) (struct super\_block\emph{ *}, void\emph{ *}, void *\emph{ arg}}{}
call function for superblocks of given type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file\_system\_type * type}}] \leavevmode
fs type

\item[{\code{void (*)(struct super\_block *, void *) f}}] \leavevmode
function to call

\item[{\code{void * arg}}] \leavevmode
argument to pass to it

\end{description}

\textbf{Description}
\begin{quote}

Scans the superblock list and calls given function, passing it
locked superblock and given argument.
\end{quote}
\index{get\_super (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.get_super}\pysiglinewithargsret{struct super\_block * \bfcode{get\_super}}{struct block\_device *\emph{ bdev}}{}
get the superblock of a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct block\_device * bdev}}] \leavevmode
device to get the superblock for

\end{description}

\textbf{Description}
\begin{quote}

Scans the superblock list and finds the superblock of the file system
mounted on the device given. \code{NULL} is returned if no match is found.
\end{quote}
\index{get\_super\_thawed (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.get_super_thawed}\pysiglinewithargsret{struct super\_block * \bfcode{get\_super\_thawed}}{struct block\_device *\emph{ bdev}}{}
get thawed superblock of a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct block\_device * bdev}}] \leavevmode
device to get the superblock for

\end{description}

\textbf{Description}
\begin{quote}

Scans the superblock list and finds the superblock of the file system
mounted on the device. The superblock is returned once it is thawed
(or immediately if it was not frozen). \code{NULL} is returned if no match
is found.
\end{quote}
\index{get\_super\_exclusive\_thawed (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.get_super_exclusive_thawed}\pysiglinewithargsret{struct super\_block * \bfcode{get\_super\_exclusive\_thawed}}{struct block\_device *\emph{ bdev}}{}
get thawed superblock of a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct block\_device * bdev}}] \leavevmode
device to get the superblock for

\end{description}

\textbf{Description}
\begin{quote}

Scans the superblock list and finds the superblock of the file system
mounted on the device. The superblock is returned once it is thawed
(or immediately if it was not frozen) and s\_umount semaphore is held
in exclusive mode. \code{NULL} is returned if no match is found.
\end{quote}
\index{freeze\_super (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.freeze_super}\pysiglinewithargsret{int \bfcode{freeze\_super}}{struct super\_block *\emph{ sb}}{}
lock the filesystem and force it into a consistent state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
the super to lock

\end{description}

\textbf{Description}

Syncs the super to make sure the filesystem is consistent and calls the fs's
freeze\_fs.  Subsequent calls to this without first thawing the fs will return
-EBUSY.

During this function, sb-\textgreater{}s\_writers.frozen goes through these values:

SB\_UNFROZEN: File system is normal, all writes progress as usual.

SB\_FREEZE\_WRITE: The file system is in the process of being frozen.  New
writes should be blocked, though page faults are still allowed. We wait for
all writes to complete and then proceed to the next stage.

SB\_FREEZE\_PAGEFAULT: Freezing continues. Now also page faults are blocked
but internal fs threads can still modify the filesystem (although they
should not dirty new pages or inodes), writeback can run etc. After waiting
for all running page faults we sync the filesystem which will clean all
dirty pages and inodes (no new dirty pages or inodes can be created when
sync is running).

SB\_FREEZE\_FS: The file system is frozen. Now all internal sources of fs
modification are blocked (e.g. XFS preallocation truncation on inode
reclaim). This is usually implemented by blocking new transactions for
filesystems that have them and need this additional guard. After all
internal writers are finished we call -\textgreater{}:c:func:\emph{freeze\_fs()} to finish filesystem
freezing. Then we transition to SB\_FREEZE\_COMPLETE state. This state is
mostly auxiliary for filesystems to verify they do not modify frozen fs.

sb-\textgreater{}s\_writers.frozen is protected by sb-\textgreater{}s\_umount.
\index{thaw\_super (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.thaw_super}\pysiglinewithargsret{int \bfcode{thaw\_super}}{struct super\_block *\emph{ sb}}{}~\begin{itemize}
\item {} 
unlock filesystem

\end{itemize}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
the super to thaw

\end{description}

\textbf{Description}

Unlocks the filesystem and marks it writeable again after {\hyperref[filesystems/index:c.freeze_super]{\emph{\code{freeze\_super()}}}}.


\section{File Locks}
\label{filesystems/index:file-locks}\index{posix\_lock\_file (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.posix_lock_file}\pysiglinewithargsret{int \bfcode{posix\_lock\_file}}{struct file *\emph{ filp}, struct file\_lock *\emph{ fl}, struct file\_lock *\emph{ conflock}}{}
Apply a POSIX-style lock to a file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
The file to apply the lock to

\item[{\code{struct file\_lock * fl}}] \leavevmode
The lock to be applied

\item[{\code{struct file\_lock * conflock}}] \leavevmode
Place to return a copy of the conflicting lock, if found.

\end{description}

\textbf{Description}

Add a POSIX style lock to a file.
We merge adjacent \& overlapping locks whenever possible.
POSIX locks are sorted by owner task, then by starting address

Note that if called with an FL\_EXISTS argument, the caller may determine
whether or not a lock was successfully freed by testing the return
value for -ENOENT.
\index{locks\_mandatory\_area (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.locks_mandatory_area}\pysiglinewithargsret{int \bfcode{locks\_mandatory\_area}}{struct inode *\emph{ inode}, struct file *\emph{ filp}, loff\_t\emph{ start}, loff\_t\emph{ end}, unsigned char\emph{ type}}{}
Check for a conflicting lock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
the file to check

\item[{\code{struct file * filp}}] \leavevmode
how the file was opened (if it was)

\item[{\code{loff\_t start}}] \leavevmode
first byte in the file to check

\item[{\code{loff\_t end}}] \leavevmode
lastbyte in the file to check

\item[{\code{unsigned char type}}] \leavevmode
\code{F\_WRLCK} for a write lock, else \code{F\_RDLCK}

\end{description}

\textbf{Description}

Searches the inode's list of locks to find any POSIX locks which conflict.
\index{\_\_break\_lease (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.__break_lease}\pysiglinewithargsret{int \bfcode{\_\_break\_lease}}{struct inode *\emph{ inode}, unsigned int\emph{ mode}, unsigned int\emph{ type}}{}
revoke all outstanding leases on file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
the inode of the file to return

\item[{\code{unsigned int mode}}] \leavevmode
O\_RDONLY: break only write leases; O\_WRONLY or O\_RDWR:
break all leases

\item[{\code{unsigned int type}}] \leavevmode
FL\_LEASE: break leases and delegations; FL\_DELEG: break
only delegations

\end{description}

\textbf{Description}
\begin{quote}

break\_lease (inlined for speed) has checked there already is at least
some kind of lock (maybe a lease) on this file.  Leases are broken on
a call to \code{open()} or \code{truncate()}.  This function can sleep unless you
specified \code{O\_NONBLOCK} to your \code{open()}.
\end{quote}
\index{lease\_get\_mtime (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.lease_get_mtime}\pysiglinewithargsret{void \bfcode{lease\_get\_mtime}}{struct inode *\emph{ inode}, struct timespec *\emph{ time}}{}
update modified time of an inode with exclusive lease

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
the inode

\item[{\code{struct timespec * time}}] \leavevmode
pointer to a timespec which contains the last modified time

\end{description}

\textbf{Description}

This is to force NFS clients to flush their caches for files with
exclusive leases.  The justification is that if someone has an
exclusive lease, then they could be modifying it.
\index{generic\_setlease (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.generic_setlease}\pysiglinewithargsret{int \bfcode{generic\_setlease}}{struct file *\emph{ filp}, long\emph{ arg}, struct file\_lock **\emph{ flp}, void **\emph{ priv}}{}
sets a lease on an open file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
file pointer

\item[{\code{long arg}}] \leavevmode
type of lease to obtain

\item[{\code{struct file\_lock ** flp}}] \leavevmode
input - file\_lock to use, output - file\_lock inserted

\item[{\code{void ** priv}}] \leavevmode
private data for lm\_setup (may be NULL if lm\_setup
doesn't require it)

\end{description}

\textbf{Description}
\begin{quote}

The (input) flp-\textgreater{}fl\_lmops-\textgreater{}lm\_break function is required
by \code{break\_lease()}.
\end{quote}
\index{vfs\_setlease (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.vfs_setlease}\pysiglinewithargsret{int \bfcode{vfs\_setlease}}{struct file *\emph{ filp}, long\emph{ arg}, struct file\_lock **\emph{ lease}, void **\emph{ priv}}{}
sets a lease on an open file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
file pointer

\item[{\code{long arg}}] \leavevmode
type of lease to obtain

\item[{\code{struct file\_lock ** lease}}] \leavevmode
file\_lock to use when adding a lease

\item[{\code{void ** priv}}] \leavevmode
private info for lm\_setup when adding a lease (may be
NULL if lm\_setup doesn't require it)

\end{description}

\textbf{Description}

Call this to establish a lease on the file. The ``lease'' argument is not
used for F\_UNLCK requests and may be NULL. For commands that set or alter
an existing lease, the \code{(*lease)-\textgreater{}fl\_lmops-\textgreater{}lm\_break} operation must be
set; if not, this function will return -ENOLCK (and generate a scary-looking
stack trace).

The ``priv'' pointer is passed directly to the lm\_setup function as-is. It
may be NULL if the lm\_setup operation doesn't require it.
\index{locks\_lock\_inode\_wait (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.locks_lock_inode_wait}\pysiglinewithargsret{int \bfcode{locks\_lock\_inode\_wait}}{struct inode *\emph{ inode}, struct file\_lock *\emph{ fl}}{}
Apply a lock to an inode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode of the file to apply to

\item[{\code{struct file\_lock * fl}}] \leavevmode
The lock to be applied

\end{description}

\textbf{Description}

Apply a POSIX or FLOCK style lock request to an inode.
\index{vfs\_test\_lock (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.vfs_test_lock}\pysiglinewithargsret{int \bfcode{vfs\_test\_lock}}{struct file *\emph{ filp}, struct file\_lock *\emph{ fl}}{}
test file byte range lock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
The file to test lock for

\item[{\code{struct file\_lock * fl}}] \leavevmode
The lock to test; also used to hold result

\end{description}

\textbf{Description}

Returns -ERRNO on failure.  Indicates presence of conflicting lock by
setting conf-\textgreater{}fl\_type to something other than F\_UNLCK.
\index{vfs\_lock\_file (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.vfs_lock_file}\pysiglinewithargsret{int \bfcode{vfs\_lock\_file}}{struct file *\emph{ filp}, unsigned int\emph{ cmd}, struct file\_lock *\emph{ fl}, struct file\_lock *\emph{ conf}}{}
file byte range lock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
The file to apply the lock to

\item[{\code{unsigned int cmd}}] \leavevmode
type of locking operation (F\_SETLK, F\_GETLK, etc.)

\item[{\code{struct file\_lock * fl}}] \leavevmode
The lock to be applied

\item[{\code{struct file\_lock * conf}}] \leavevmode
Place to return a copy of the conflicting lock, if found.

\end{description}

\textbf{Description}

A caller that doesn't care about the conflicting lock may pass NULL
as the final argument.

If the filesystem defines a private -\textgreater{}:c:func:\emph{lock()} method, then \textbf{conf} will
be left unchanged; so a caller that cares should initialize it to
some acceptable default.

To avoid blocking kernel daemons, such as lockd, that need to acquire POSIX
locks, the -\textgreater{}:c:func:\emph{lock()} interface may return asynchronously, before the lock has
been granted or denied by the underlying filesystem, if (and only if)
lm\_grant is set. Callers expecting -\textgreater{}:c:func:\emph{lock()} to return asynchronously
will only use F\_SETLK, not F\_SETLKW; they will set FL\_SLEEP if (and only if)
the request is for a blocking lock. When -\textgreater{}:c:func:\emph{lock()} does return asynchronously,
it must return FILE\_LOCK\_DEFERRED, and call -\textgreater{}:c:func:\emph{lm\_grant()} when the lock
request completes.
If the request is for non-blocking lock the file system should return
FILE\_LOCK\_DEFERRED then try to get the lock and call the callback routine
with the result. If the request timed out the callback routine will return a
nonzero return code and the file system should release the lock. The file
system is also responsible to keep a corresponding posix lock when it
grants a lock so the VFS can find out which locks are locally held and do
the correct lock cleanup when required.
The underlying filesystem must not drop the kernel lock or call
-\textgreater{}:c:func:\emph{lm\_grant()} before returning to the caller with a FILE\_LOCK\_DEFERRED
return code.
\index{posix\_unblock\_lock (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.posix_unblock_lock}\pysiglinewithargsret{int \bfcode{posix\_unblock\_lock}}{struct file\_lock *\emph{ waiter}}{}
stop waiting for a file lock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file\_lock * waiter}}] \leavevmode
the lock which was waiting

\end{description}

\textbf{Description}
\begin{quote}

lockd needs to block waiting for locks.
\end{quote}
\index{vfs\_cancel\_lock (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.vfs_cancel_lock}\pysiglinewithargsret{int \bfcode{vfs\_cancel\_lock}}{struct file *\emph{ filp}, struct file\_lock *\emph{ fl}}{}
file byte range unblock lock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
The file to apply the unblock to

\item[{\code{struct file\_lock * fl}}] \leavevmode
The lock to be unblocked

\end{description}

\textbf{Description}

Used by lock managers to cancel blocked requests
\index{posix\_lock\_inode\_wait (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.posix_lock_inode_wait}\pysiglinewithargsret{int \bfcode{posix\_lock\_inode\_wait}}{struct inode *\emph{ inode}, struct file\_lock *\emph{ fl}}{}
Apply a POSIX-style lock to a file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode of file to which lock request should be applied

\item[{\code{struct file\_lock * fl}}] \leavevmode
The lock to be applied

\end{description}

\textbf{Description}

Apply a POSIX style lock request to an inode.
\index{locks\_mandatory\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.locks_mandatory_locked}\pysiglinewithargsret{int \bfcode{locks\_mandatory\_locked}}{struct file *\emph{ file}}{}
Check for an active lock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * file}}] \leavevmode
the file to check

\end{description}

\textbf{Description}

Searches the inode's list of locks to find any POSIX locks which conflict.
This function is called from \code{locks\_verify\_locked()} only.
\index{fcntl\_getlease (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.fcntl_getlease}\pysiglinewithargsret{int \bfcode{fcntl\_getlease}}{struct file *\emph{ filp}}{}
Enquire what lease is currently active

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
the file

\end{description}

\textbf{Description}
\begin{quote}

The value returned by this function will be one of
(if no lease break is pending):

\code{F\_RDLCK} to indicate a shared lease is held.

\code{F\_WRLCK} to indicate an exclusive lease is held.

\code{F\_UNLCK} to indicate no lease is held.

(if a lease break is pending):
\begin{description}
\item[{\code{F\_RDLCK} to indicate an exclusive lease needs to be}] \leavevmode
changed to a shared lease (or removed).

\end{description}

\code{F\_UNLCK} to indicate the lease needs to be removed.

XXX: sfr \& willy disagree over whether F\_INPROGRESS
should be returned to userspace.
\end{quote}
\index{check\_conflicting\_open (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.check_conflicting_open}\pysiglinewithargsret{int \bfcode{check\_conflicting\_open}}{const struct dentry *\emph{ dentry}, const long\emph{ arg}, int\emph{ flags}}{}
see if the given dentry points to a file that has an existing open that would conflict with the desired lease.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct dentry * dentry}}] \leavevmode
dentry to check

\item[{\code{const long arg}}] \leavevmode
type of lease that we're trying to acquire

\item[{\code{int flags}}] \leavevmode
current lock flags

\end{description}

\textbf{Description}

Check to see if there's an existing open fd on this file that would
conflict with the lease we're trying to set.
\index{fcntl\_setlease (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.fcntl_setlease}\pysiglinewithargsret{int \bfcode{fcntl\_setlease}}{unsigned int\emph{ fd}, struct file *\emph{ filp}, long\emph{ arg}}{}
sets a lease on an open file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int fd}}] \leavevmode
open file descriptor

\item[{\code{struct file * filp}}] \leavevmode
file pointer

\item[{\code{long arg}}] \leavevmode
type of lease to obtain

\end{description}

\textbf{Description}
\begin{quote}

Call this fcntl to establish a lease on the file.
Note that you also need to call \code{F\_SETSIG} to
receive a signal when the lease is broken.
\end{quote}
\index{flock\_lock\_inode\_wait (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.flock_lock_inode_wait}\pysiglinewithargsret{int \bfcode{flock\_lock\_inode\_wait}}{struct inode *\emph{ inode}, struct file\_lock *\emph{ fl}}{}
Apply a FLOCK-style lock to a file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode of the file to apply to

\item[{\code{struct file\_lock * fl}}] \leavevmode
The lock to be applied

\end{description}

\textbf{Description}

Apply a FLOCK style lock request to an inode.
\index{sys\_flock (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sys_flock}\pysiglinewithargsret{long \bfcode{sys\_flock}}{unsigned int\emph{ fd}, unsigned int\emph{ cmd}}{}
\code{flock()} system call.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int fd}}] \leavevmode
the file descriptor to lock.

\item[{\code{unsigned int cmd}}] \leavevmode
the type of lock to apply.

\end{description}

\textbf{Description}
\begin{quote}

Apply a \code{FL\_FLOCK} style lock to an open file descriptor.
The \textbf{cmd} can be one of:
\begin{itemize}
\item {} 
\code{LOCK\_SH} -- a shared lock.

\item {} 
\code{LOCK\_EX} -- an exclusive lock.

\item {} 
\code{LOCK\_UN} -- remove an existing lock.

\item {} 
\code{LOCK\_MAND} -- a `mandatory' flock.
This exists to emulate Windows Share Modes.

\end{itemize}

\code{LOCK\_MAND} can be combined with \code{LOCK\_READ} or \code{LOCK\_WRITE} to allow other
processes read and write access respectively.
\end{quote}
\index{locks\_translate\_pid (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.locks_translate_pid}\pysiglinewithargsret{pid\_t \bfcode{locks\_translate\_pid}}{struct file\_lock *\emph{ fl}, struct pid\_namespace *\emph{ ns}}{}
translate a file\_lock's fl\_pid number into a namespace

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file\_lock * fl}}] \leavevmode
The file\_lock who's fl\_pid should be translated

\item[{\code{struct pid\_namespace * ns}}] \leavevmode
The namespace into which the pid should be translated

\end{description}

\textbf{Description}

Used to tranlate a fl\_pid into a namespace virtual pid number


\section{Other Functions}
\label{filesystems/index:other-functions}\index{mpage\_readpages (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.mpage_readpages}\pysiglinewithargsret{int \bfcode{mpage\_readpages}}{struct address\_space *\emph{ mapping}, struct list\_head *\emph{ pages}, unsigned\emph{ nr\_pages}, get\_block\_t\emph{ get\_block}}{}
populate an address space with some pages \& start reads against them

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct address\_space * mapping}}] \leavevmode
the address\_space

\item[{\code{struct list\_head * pages}}] \leavevmode
The address of a list\_head which contains the target pages.  These
pages have their -\textgreater{}index populated and are otherwise uninitialised.
The page at \textbf{pages}-\textgreater{}prev has the lowest file offset, and reads should be
issued in \textbf{pages}-\textgreater{}prev to \textbf{pages}-\textgreater{}next order.

\item[{\code{unsigned nr\_pages}}] \leavevmode
The number of pages at \textbf{*pages}

\item[{\code{get\_block\_t get\_block}}] \leavevmode
The filesystem's block mapper function.

\end{description}

\textbf{Description}

This function walks the pages and the blocks within each page, building and
emitting large BIOs.

If anything unusual happens, such as:
\begin{itemize}
\item {} 
encountering a page which has buffers

\item {} 
encountering a page which has a non-hole after a hole

\item {} 
encountering a page with non-contiguous blocks

\end{itemize}

then this code just gives up and calls the buffer\_head-based read function.
It does handle a page which has holes at the end - that is a common case:
the end-of-file on blocksize \textless{} PAGE\_SIZE setups.

BH\_Boundary explanation:

There is a problem.  The mpage read code assembles several pages, gets all
their disk mappings, and then submits them all.  That's fine, but obtaining
the disk mappings may require I/O.  Reads of indirect blocks, for example.

So an mpage read of the first 16 blocks of an ext2 file will cause I/O to be
submitted in the following order:
\begin{quote}

12 0 1 2 3 4 5 6 7 8 9 10 11 13 14 15 16
\end{quote}

because the indirect block has to be read to get the mappings of blocks
13,14,15,16.  Obviously, this impacts performance.

So what we do it to allow the filesystem's \code{get\_block()} function to set
BH\_Boundary when it maps block 11.  BH\_Boundary says: mapping of the block
after this one will require I/O against a block which is probably close to
this one.  So you should push what I/O you have currently accumulated.

This all causes the disk requests to be issued in the correct order.
\index{mpage\_writepages (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.mpage_writepages}\pysiglinewithargsret{int \bfcode{mpage\_writepages}}{struct address\_space *\emph{ mapping}, struct writeback\_control *\emph{ wbc}, get\_block\_t\emph{ get\_block}}{}
walk the list of dirty pages of the given address space \& \code{writepage()} all of them

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct address\_space * mapping}}] \leavevmode
address space structure to write

\item[{\code{struct writeback\_control * wbc}}] \leavevmode
subtract the number of written pages from \textbf{*wbc}-\textgreater{}nr\_to\_write

\item[{\code{get\_block\_t get\_block}}] \leavevmode
the filesystem's block mapper function.
If this is NULL then use a\_ops-\textgreater{}writepage.  Otherwise, go
direct-to-BIO.

\end{description}

\textbf{Description}

This is a library function, which implements the \code{writepages()}
address\_space\_operation.

If a page is already under I/O, \code{generic\_writepages()} skips it, even
if it's dirty.  This is desirable behaviour for memory-cleaning writeback,
but it is INCORRECT for data-integrity system calls such as \code{fsync()}.  \code{fsync()}
and \code{msync()} need to guarantee that all the data which was dirty at the time
the call was made get new I/O started against them.  If wbc-\textgreater{}sync\_mode is
WB\_SYNC\_ALL then we were called for data integrity and we must wait for
existing IO to complete.
\index{generic\_permission (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.generic_permission}\pysiglinewithargsret{int \bfcode{generic\_permission}}{struct inode *\emph{ inode}, int\emph{ mask}}{}
check for access rights on a Posix-like filesystem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode to check access rights for

\item[{\code{int mask}}] \leavevmode
right to check for (\code{MAY\_READ}, \code{MAY\_WRITE}, \code{MAY\_EXEC}, ...)

\end{description}

\textbf{Description}

Used to check for read/write/execute permissions on a file.
We use ``fsuid'' for this, letting us set arbitrary permissions
for filesystem access without changing the ``normal'' uids which
are used for other things.

generic\_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk
request cannot be satisfied (eg. requires blocking or too much complexity).
It would then be called again in ref-walk mode.
\index{inode\_permission (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.inode_permission}\pysiglinewithargsret{int \bfcode{inode\_permission}}{struct inode *\emph{ inode}, int\emph{ mask}}{}
Check for access rights to a given inode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
Inode to check permission on

\item[{\code{int mask}}] \leavevmode
Right to check for (\code{MAY\_READ}, \code{MAY\_WRITE}, \code{MAY\_EXEC})

\end{description}

\textbf{Description}

Check for read/write/execute permissions on an inode.  We use fs{[}ug{]}id for
this, letting us set arbitrary permissions for filesystem access without
changing the ``normal'' UIDs which are used for other things.

When checking for MAY\_APPEND, MAY\_WRITE must also be set in \textbf{mask}.
\index{path\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.path_get}\pysiglinewithargsret{void \bfcode{path\_get}}{const struct path *\emph{ path}}{}
get a reference to a path

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct path * path}}] \leavevmode
path to get the reference to

\end{description}

\textbf{Description}

Given a path increment the reference count to the dentry and the vfsmount.
\index{path\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.path_put}\pysiglinewithargsret{void \bfcode{path\_put}}{const struct path *\emph{ path}}{}
put a reference to a path

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct path * path}}] \leavevmode
path to put the reference to

\end{description}

\textbf{Description}

Given a path decrement the reference count to the dentry and the vfsmount.
\index{vfs\_path\_lookup (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.vfs_path_lookup}\pysiglinewithargsret{int \bfcode{vfs\_path\_lookup}}{struct dentry *\emph{ dentry}, struct vfsmount *\emph{ mnt}, const char *\emph{ name}, unsigned int\emph{ flags}, struct path *\emph{ path}}{}
lookup a file path relative to a dentry-vfsmount pair

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * dentry}}] \leavevmode
pointer to dentry of the base directory

\item[{\code{struct vfsmount * mnt}}] \leavevmode
pointer to vfs mount of the base directory

\item[{\code{const char * name}}] \leavevmode
pointer to file name

\item[{\code{unsigned int flags}}] \leavevmode
lookup flags

\item[{\code{struct path * path}}] \leavevmode
pointer to struct path to fill

\end{description}
\index{lookup\_one\_len (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.lookup_one_len}\pysiglinewithargsret{struct dentry * \bfcode{lookup\_one\_len}}{const char *\emph{ name}, struct dentry *\emph{ base}, int\emph{ len}}{}
filesystem helper to lookup single pathname component

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
pathname component to lookup

\item[{\code{struct dentry * base}}] \leavevmode
base directory to lookup from

\item[{\code{int len}}] \leavevmode
maximum length \textbf{len} should be interpreted to

\end{description}

\textbf{Description}

Note that this routine is purely a helper for filesystem usage and should
not be called by generic code.

The caller must hold base-\textgreater{}i\_mutex.
\index{lookup\_one\_len\_unlocked (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.lookup_one_len_unlocked}\pysiglinewithargsret{struct dentry * \bfcode{lookup\_one\_len\_unlocked}}{const char *\emph{ name}, struct dentry *\emph{ base}, int\emph{ len}}{}
filesystem helper to lookup single pathname component

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
pathname component to lookup

\item[{\code{struct dentry * base}}] \leavevmode
base directory to lookup from

\item[{\code{int len}}] \leavevmode
maximum length \textbf{len} should be interpreted to

\end{description}

\textbf{Description}

Note that this routine is purely a helper for filesystem usage and should
not be called by generic code.

Unlike lookup\_one\_len, it should be called without the parent
i\_mutex held, and will take the i\_mutex itself if necessary.
\index{vfs\_unlink (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.vfs_unlink}\pysiglinewithargsret{int \bfcode{vfs\_unlink}}{struct inode *\emph{ dir}, struct dentry *\emph{ dentry}, struct inode **\emph{ delegated\_inode}}{}
unlink a filesystem object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * dir}}] \leavevmode
parent directory

\item[{\code{struct dentry * dentry}}] \leavevmode
victim

\item[{\code{struct inode ** delegated\_inode}}] \leavevmode
returns victim inode, if the inode is delegated.

\end{description}

\textbf{Description}

The caller must hold dir-\textgreater{}i\_mutex.

If vfs\_unlink discovers a delegation, it will return -EWOULDBLOCK and
return a reference to the inode in delegated\_inode.  The caller
should then break the delegation on that inode and retry.  Because
breaking a delegation may take a long time, the caller should drop
dir-\textgreater{}i\_mutex before doing so.

Alternatively, a caller may pass NULL for delegated\_inode.  This may
be appropriate for callers that expect the underlying filesystem not
to be NFS exported.
\index{vfs\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.vfs_link}\pysiglinewithargsret{int \bfcode{vfs\_link}}{struct dentry *\emph{ old\_dentry}, struct inode *\emph{ dir}, struct dentry *\emph{ new\_dentry}, struct inode **\emph{ delegated\_inode}}{}
create a new link

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * old\_dentry}}] \leavevmode
object to be linked

\item[{\code{struct inode * dir}}] \leavevmode
new parent

\item[{\code{struct dentry * new\_dentry}}] \leavevmode
where to create the new link

\item[{\code{struct inode ** delegated\_inode}}] \leavevmode
returns inode needing a delegation break

\end{description}

\textbf{Description}

The caller must hold dir-\textgreater{}i\_mutex

If vfs\_link discovers a delegation on the to-be-linked file in need
of breaking, it will return -EWOULDBLOCK and return a reference to the
inode in delegated\_inode.  The caller should then break the delegation
and retry.  Because breaking a delegation may take a long time, the
caller should drop the i\_mutex before doing so.

Alternatively, a caller may pass NULL for delegated\_inode.  This may
be appropriate for callers that expect the underlying filesystem not
to be NFS exported.
\index{vfs\_rename (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.vfs_rename}\pysiglinewithargsret{int \bfcode{vfs\_rename}}{struct inode *\emph{ old\_dir}, struct dentry *\emph{ old\_dentry}, struct inode *\emph{ new\_dir}, struct dentry *\emph{ new\_dentry}, struct inode **\emph{ delegated\_inode}, unsigned int\emph{ flags}}{}
rename a filesystem object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * old\_dir}}] \leavevmode
parent of source

\item[{\code{struct dentry * old\_dentry}}] \leavevmode
source

\item[{\code{struct inode * new\_dir}}] \leavevmode
parent of destination

\item[{\code{struct dentry * new\_dentry}}] \leavevmode
destination

\item[{\code{struct inode ** delegated\_inode}}] \leavevmode
returns an inode needing a delegation break

\item[{\code{unsigned int flags}}] \leavevmode
rename flags

\end{description}

\textbf{Description}

The caller must hold multiple mutexes--see \code{lock\_rename()}).

If vfs\_rename discovers a delegation in need of breaking at either
the source or destination, it will return -EWOULDBLOCK and return a
reference to the inode in delegated\_inode.  The caller should then
break the delegation and retry.  Because breaking a delegation may
take a long time, the caller should drop all locks before doing
so.

Alternatively, a caller may pass NULL for delegated\_inode.  This may
be appropriate for callers that expect the underlying filesystem not
to be NFS exported.

The worst of all namespace operations - renaming directory. ``Perverted''
doesn't even start to describe it. Somebody in UCB had a heck of a trip...
Problems:
\begin{enumerate}
\item {} 
we can get into loop creation.

\item {} 
race potential - two innocent renames can create a loop together.
That's where 4.4 screws up. Current fix: serialization on
sb-\textgreater{}s\_vfs\_rename\_mutex. We might be more accurate, but that's another
story.

\item {} 
we have to lock \_four\_ objects - parents and victim (if it exists),
and source (if it is not a directory).
And that - after we got -\textgreater{}i\_mutex on parents (until then we don't know
whether the target exists).  Solution: try to be smart with locking
order for inodes.  We rely on the fact that tree topology may change
only under -\textgreater{}s\_vfs\_rename\_mutex \_and\_ that parent of the object we
move will be locked.  Thus we can rank directories by the tree
(ancestors first) and rank all non-directories after them.
That works since everybody except rename does ``lock parent, lookup,
lock child'' and rename is under -\textgreater{}s\_vfs\_rename\_mutex.
HOWEVER, it relies on the assumption that any object with -\textgreater{}:c:func:\emph{lookup()}
has no more than 1 dentry.  If ``hybrid'' objects will ever appear,
we'd better make sure that there's no link(2) for them.

\item {} 
conversion from fhandle to dentry may come in the wrong moment - when
we are removing the target. Solution: we will have to grab -\textgreater{}i\_mutex
in the fhandle\_to\_dentry code. {[}FIXME - current nfsfh.c relies on
-\textgreater{}i\_mutex on parents, which works but leads to some truly excessive
locking{]}.

\end{enumerate}
\index{vfs\_readlink (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.vfs_readlink}\pysiglinewithargsret{int \bfcode{vfs\_readlink}}{struct dentry *\emph{ dentry}, char \_\_user *\emph{ buffer}, int\emph{ buflen}}{}
copy symlink body into userspace buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * dentry}}] \leavevmode
dentry on which to get symbolic link

\item[{\code{char \_\_user * buffer}}] \leavevmode
user memory pointer

\item[{\code{int buflen}}] \leavevmode
size of buffer

\end{description}

\textbf{Description}

Does not touch atime.  That's up to the caller if necessary

Does not call security hook.
\index{vfs\_get\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.vfs_get_link}\pysiglinewithargsret{const char * \bfcode{vfs\_get\_link}}{struct dentry *\emph{ dentry}, struct delayed\_call *\emph{ done}}{}
get symlink body

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * dentry}}] \leavevmode
dentry on which to get symbolic link

\item[{\code{struct delayed\_call * done}}] \leavevmode
caller needs to free returned data with this

\end{description}

\textbf{Description}

Calls security hook and i\_op-\textgreater{}:c:func:\emph{get\_link()} on the supplied inode.

It does not touch atime.  That's up to the caller if necessary.

Does not work on ``special'' symlinks like /proc/\$\$/fd/N
\index{sync\_mapping\_buffers (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sync_mapping_buffers}\pysiglinewithargsret{int \bfcode{sync\_mapping\_buffers}}{struct address\_space *\emph{ mapping}}{}
write out \& wait upon a mapping's ``associated'' buffers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct address\_space * mapping}}] \leavevmode
the mapping which wants those buffers written

\end{description}

\textbf{Description}

Starts I/O against the buffers at mapping-\textgreater{}private\_list, and waits upon
that I/O.

Basically, this is a convenience function for \code{fsync()}.
\textbf{mapping} is a file or directory which needs those buffers to be written for
a successful \code{fsync()}.
\index{mark\_buffer\_dirty (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.mark_buffer_dirty}\pysiglinewithargsret{void \bfcode{mark\_buffer\_dirty}}{struct buffer\_head *\emph{ bh}}{}
mark a buffer\_head as needing writeout

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct buffer\_head * bh}}] \leavevmode
the buffer\_head to mark dirty

\end{description}

\textbf{Description}

{\hyperref[filesystems/index:c.mark_buffer_dirty]{\emph{\code{mark\_buffer\_dirty()}}}} will set the dirty bit against the buffer, then set its
backing page dirty, then tag the page as dirty in its address\_space's radix
tree and then attach the address\_space's inode to its superblock's dirty
inode list.

{\hyperref[filesystems/index:c.mark_buffer_dirty]{\emph{\code{mark\_buffer\_dirty()}}}} is atomic.  It takes bh-\textgreater{}b\_page-\textgreater{}mapping-\textgreater{}private\_lock,
mapping-\textgreater{}tree\_lock and mapping-\textgreater{}host-\textgreater{}i\_lock.
\index{\_\_bread\_gfp (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.__bread_gfp}\pysiglinewithargsret{struct buffer\_head * \bfcode{\_\_bread\_gfp}}{struct block\_device *\emph{ bdev}, sector\_t\emph{ block}, unsigned\emph{ size}, gfp\_t\emph{ gfp}}{}
reads a specified block and returns the bh

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct block\_device * bdev}}] \leavevmode
the block\_device to read from

\item[{\code{sector\_t block}}] \leavevmode
number of block

\item[{\code{unsigned size}}] \leavevmode
size (in bytes) to read

\item[{\code{gfp\_t gfp}}] \leavevmode
page allocation flag

\end{description}

\textbf{Description}
\begin{quote}

Reads a specified block, and returns buffer head that contains it.
The page cache can be allocated from non-movable area
not to prevent page migration if you set gfp to zero.
It returns NULL if the block was unreadable.
\end{quote}
\index{block\_invalidatepage (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.block_invalidatepage}\pysiglinewithargsret{void \bfcode{block\_invalidatepage}}{struct page *\emph{ page}, unsigned int\emph{ offset}, unsigned int\emph{ length}}{}
invalidate part or all of a buffer-backed page

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct page * page}}] \leavevmode
the page which is affected

\item[{\code{unsigned int offset}}] \leavevmode
start of the range to invalidate

\item[{\code{unsigned int length}}] \leavevmode
length of the range to invalidate

\end{description}

\textbf{Description}

{\hyperref[filesystems/index:c.block_invalidatepage]{\emph{\code{block\_invalidatepage()}}}} is called when all or part of the page has become
invalidated by a truncate operation.

{\hyperref[filesystems/index:c.block_invalidatepage]{\emph{\code{block\_invalidatepage()}}}} does not have to release all buffers, but it must
ensure that no dirty buffer is left outside \textbf{offset} and that no I/O
is underway against any of the blocks which are outside the truncation
point.  Because the caller is about to free (and possibly reuse) those
blocks on-disk.
\index{clean\_bdev\_aliases (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.clean_bdev_aliases}\pysiglinewithargsret{void \bfcode{clean\_bdev\_aliases}}{struct block\_device *\emph{ bdev}, sector\_t\emph{ block}, sector\_t\emph{ len}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct block\_device * bdev}}] \leavevmode
Block device to clean buffers in

\item[{\code{sector\_t block}}] \leavevmode
Start of a range of blocks to clean

\item[{\code{sector\_t len}}] \leavevmode
Number of blocks to clean

\end{description}

\textbf{Description}

We are taking a range of blocks for data and we don't want writeback of any
buffer-cache aliases starting from return from this function and until the
moment when something will explicitly mark the buffer dirty (hopefully that
will not happen until we will free that block ;-) We don't even need to mark
it not-uptodate - nobody can expect anything from a newly allocated buffer
anyway. We used to use \code{unmap\_buffer()} for such invalidation, but that was
wrong. We definitely don't want to mark the alias unmapped, for example - it
would confuse anyone who might pick it with \code{bread()} afterwards...

Also..  Note that \code{bforget()} doesn't lock the buffer.  So there can be
writeout I/O going on against recently-freed buffers.  We don't wait on that
I/O in \code{bforget()} - it's more efficient to wait on the I/O only if we really
need to.  That happens here.
\index{ll\_rw\_block (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.ll_rw_block}\pysiglinewithargsret{void \bfcode{ll\_rw\_block}}{int\emph{ op}, int\emph{ op\_flags}, int\emph{ nr}, struct buffer\_head *\emph{ bhs}}{}
level access to block devices (DEPRECATED)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int op}}] \leavevmode
whether to \code{READ} or \code{WRITE}

\item[{\code{int op\_flags}}] \leavevmode
req\_flag\_bits

\item[{\code{int nr}}] \leavevmode
number of \code{struct buffer\_heads} in the array

\item[{\code{struct buffer\_head * bhs}}] \leavevmode
array of pointers to \code{struct buffer\_head}

\end{description}

\textbf{Description}

{\hyperref[filesystems/index:c.ll_rw_block]{\emph{\code{ll\_rw\_block()}}}} takes an array of pointers to \code{struct buffer\_heads}, and
requests an I/O operation on them, either a \code{REQ\_OP\_READ} or a \code{REQ\_OP\_WRITE}.
\textbf{op\_flags} contains flags modifying the detailed I/O behavior, most notably
\code{REQ\_RAHEAD}.

This function drops any buffer that it cannot get a lock on (with the
BH\_Lock state bit), any buffer that appears to be clean when doing a write
request, and any buffer that appears to be up-to-date when doing read
request.  Further it marks as clean buffers that are processed for
writing (the buffer cache won't assume that they are actually clean
until the buffer gets unlocked).

ll\_rw\_block sets b\_end\_io to simple completion handler that marks
the buffer up-to-date (if appropriate), unlocks the buffer and wakes
any waiters.

All of the buffers must be for the same device, and must also be a
multiple of the current approved size for the device.
\index{bh\_uptodate\_or\_lock (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bh_uptodate_or_lock}\pysiglinewithargsret{int \bfcode{bh\_uptodate\_or\_lock}}{struct buffer\_head *\emph{ bh}}{}
Test whether the buffer is uptodate

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct buffer\_head * bh}}] \leavevmode
struct buffer\_head

\end{description}

\textbf{Description}

Return true if the buffer is up-to-date and false,
with the buffer locked, if not.
\index{bh\_submit\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bh_submit_read}\pysiglinewithargsret{int \bfcode{bh\_submit\_read}}{struct buffer\_head *\emph{ bh}}{}
Submit a locked buffer for reading

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct buffer\_head * bh}}] \leavevmode
struct buffer\_head

\end{description}

\textbf{Description}

Returns zero on success and -EIO on error.
\index{bio\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bio_reset}\pysiglinewithargsret{void \bfcode{bio\_reset}}{struct bio *\emph{ bio}}{}
reinitialize a bio

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bio * bio}}] \leavevmode
bio to reset

\end{description}

\textbf{Description}
\begin{quote}

After calling {\hyperref[filesystems/index:c.bio_reset]{\emph{\code{bio\_reset()}}}}, \textbf{bio} will be in the same state as a freshly
allocated bio returned bio {\hyperref[filesystems/index:c.bio_alloc_bioset]{\emph{\code{bio\_alloc\_bioset()}}}} - the only fields that are
preserved are the ones that are initialized by {\hyperref[filesystems/index:c.bio_alloc_bioset]{\emph{\code{bio\_alloc\_bioset()}}}}. See
comment in struct bio.
\end{quote}
\index{bio\_chain (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bio_chain}\pysiglinewithargsret{void \bfcode{bio\_chain}}{struct bio *\emph{ bio}, struct bio *\emph{ parent}}{}
chain bio completions

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bio * bio}}] \leavevmode
the target bio

\item[{\code{struct bio * parent}}] \leavevmode
the \textbf{bio}`s parent bio

\end{description}

\textbf{Description}

The caller won't have a bi\_end\_io called when \textbf{bio} completes - instead,
\textbf{parent}`s bi\_end\_io won't be called until both \textbf{parent} and \textbf{bio} have
completed; the chained bio will also be freed when it completes.

The caller must not set bi\_private or bi\_end\_io in \textbf{bio}.
\index{bio\_alloc\_bioset (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bio_alloc_bioset}\pysiglinewithargsret{struct bio * \bfcode{bio\_alloc\_bioset}}{gfp\_t\emph{ gfp\_mask}, unsigned int\emph{ nr\_iovecs}, struct bio\_set *\emph{ bs}}{}
allocate a bio for I/O

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
the GFP\_* mask given to the slab allocator

\item[{\code{unsigned int nr\_iovecs}}] \leavevmode
number of iovecs to pre-allocate

\item[{\code{struct bio\_set * bs}}] \leavevmode
the bio\_set to allocate from.

\end{description}

\textbf{Description}
\begin{quote}

If \textbf{bs} is NULL, uses \code{kmalloc()} to allocate the bio; else the allocation is
backed by the \textbf{bs}`s mempool.

When \textbf{bs} is not NULL, if \code{\_\_GFP\_DIRECT\_RECLAIM} is set then bio\_alloc will
always be able to allocate a bio. This is due to the mempool guarantees.
To make this work, callers must never allocate more than 1 bio at a time
from this pool. Callers that need to allocate more than 1 bio must always
submit the previously allocated bio for IO before attempting to allocate
a new one. Failure to do so can cause deadlocks under memory pressure.

Note that when running under \code{generic\_make\_request()} (i.e. any block
driver), bios are not submitted until after you return - see the code in
\code{generic\_make\_request()} that converts recursion into iteration, to prevent
stack overflows.

This would normally mean allocating multiple bios under
\code{generic\_make\_request()} would be susceptible to deadlocks, but we have
deadlock avoidance code that resubmits any blocked bios from a rescuer
thread.

However, we do not guarantee forward progress for allocations from other
mempools. Doing multiple allocations from the same mempool under
\code{generic\_make\_request()} should be avoided - instead, use bio\_set's front\_pad
for per bio allocations.
\end{quote}

\textbf{Return}
\begin{quote}

Pointer to new bio on success, NULL on failure.
\end{quote}
\index{bio\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bio_put}\pysiglinewithargsret{void \bfcode{bio\_put}}{struct bio *\emph{ bio}}{}
release a reference to a bio

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bio * bio}}] \leavevmode
bio to release reference to

\end{description}

\textbf{Description}
\begin{quote}

Put a reference to a \code{struct bio}, either one you have gotten with
bio\_alloc, bio\_get or bio\_clone\_*. The last put of a bio will free it.
\end{quote}
\index{\_\_bio\_clone\_fast (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.__bio_clone_fast}\pysiglinewithargsret{void \bfcode{\_\_bio\_clone\_fast}}{struct bio *\emph{ bio}, struct bio *\emph{ bio\_src}}{}
clone a bio that shares the original bio's biovec

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bio * bio}}] \leavevmode
destination bio

\item[{\code{struct bio * bio\_src}}] \leavevmode
bio to clone

\end{description}

\textbf{Description}
\begin{quote}

Clone a \code{bio}. Caller will own the returned bio, but not
the actual data it points to. Reference count of returned
bio will be one.

Caller must ensure that \textbf{bio\_src} is not freed before \textbf{bio}.
\end{quote}
\index{bio\_clone\_fast (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bio_clone_fast}\pysiglinewithargsret{struct bio * \bfcode{bio\_clone\_fast}}{struct bio *\emph{ bio}, gfp\_t\emph{ gfp\_mask}, struct bio\_set *\emph{ bs}}{}
clone a bio that shares the original bio's biovec

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bio * bio}}] \leavevmode
bio to clone

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
allocation priority

\item[{\code{struct bio\_set * bs}}] \leavevmode
bio\_set to allocate from

\end{description}

\textbf{Description}
\begin{quote}

Like \_\_bio\_clone\_fast, only also allocates the returned bio
\end{quote}
\index{bio\_clone\_bioset (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bio_clone_bioset}\pysiglinewithargsret{struct bio * \bfcode{bio\_clone\_bioset}}{struct bio *\emph{ bio\_src}, gfp\_t\emph{ gfp\_mask}, struct bio\_set *\emph{ bs}}{}
clone a bio

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bio * bio\_src}}] \leavevmode
bio to clone

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
allocation priority

\item[{\code{struct bio\_set * bs}}] \leavevmode
bio\_set to allocate from

\end{description}

\textbf{Description}
\begin{quote}

Clone bio. Caller will own the returned bio, but not the actual data it
points to. Reference count of returned bio will be one.
\end{quote}
\index{bio\_add\_pc\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bio_add_pc_page}\pysiglinewithargsret{int \bfcode{bio\_add\_pc\_page}}{struct request\_queue *\emph{ q}, struct bio *\emph{ bio}, struct page *\emph{ page}, unsigned int\emph{ len}, unsigned int\emph{ offset}}{}
attempt to add page to bio

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct request\_queue * q}}] \leavevmode
the target queue

\item[{\code{struct bio * bio}}] \leavevmode
destination bio

\item[{\code{struct page * page}}] \leavevmode
page to add

\item[{\code{unsigned int len}}] \leavevmode
vec entry length

\item[{\code{unsigned int offset}}] \leavevmode
vec entry offset

\end{description}

\textbf{Description}
\begin{quote}

Attempt to add a page to the bio\_vec maplist. This can fail for a
number of reasons, such as the bio being full or target block device
limitations. The target block device must allow bio's up to PAGE\_SIZE,
so it is always possible to add a single page to an empty bio.

This should only be used by REQ\_PC bios.
\end{quote}
\index{bio\_add\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bio_add_page}\pysiglinewithargsret{int \bfcode{bio\_add\_page}}{struct bio *\emph{ bio}, struct page *\emph{ page}, unsigned int\emph{ len}, unsigned int\emph{ offset}}{}
attempt to add page to bio

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bio * bio}}] \leavevmode
destination bio

\item[{\code{struct page * page}}] \leavevmode
page to add

\item[{\code{unsigned int len}}] \leavevmode
vec entry length

\item[{\code{unsigned int offset}}] \leavevmode
vec entry offset

\end{description}

\textbf{Description}
\begin{quote}

Attempt to add a page to the bio\_vec maplist. This will only fail
if either bio-\textgreater{}bi\_vcnt == bio-\textgreater{}bi\_max\_vecs or it's a cloned bio.
\end{quote}
\index{bio\_iov\_iter\_get\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bio_iov_iter_get_pages}\pysiglinewithargsret{int \bfcode{bio\_iov\_iter\_get\_pages}}{struct bio *\emph{ bio}, struct iov\_iter *\emph{ iter}}{}
pin user or kernel pages and add them to a bio

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bio * bio}}] \leavevmode
bio to add pages to

\item[{\code{struct iov\_iter * iter}}] \leavevmode
iov iterator describing the region to be mapped

\end{description}

\textbf{Description}

Pins as many pages from \emph{iter and appends them to **bio*}`s bvec array. The
pages will have to be released using \code{put\_page()} when done.
\index{submit\_bio\_wait (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.submit_bio_wait}\pysiglinewithargsret{int \bfcode{submit\_bio\_wait}}{struct bio *\emph{ bio}}{}
submit a bio, and wait until it completes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bio * bio}}] \leavevmode
The \code{struct bio} which describes the I/O

\end{description}

\textbf{Description}

Simple wrapper around \code{submit\_bio()}. Returns 0 on success, or the error from
{\hyperref[filesystems/index:c.bio_endio]{\emph{\code{bio\_endio()}}}} on failure.

WARNING: Unlike to how \code{submit\_bio()} is usually used, this function does not
result in bio reference to be consumed. The caller must drop the reference
on his own.
\index{bio\_advance (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bio_advance}\pysiglinewithargsret{void \bfcode{bio\_advance}}{struct bio *\emph{ bio}, unsigned\emph{ bytes}}{}
increment/complete a bio by some number of bytes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bio * bio}}] \leavevmode
bio to advance

\item[{\code{unsigned bytes}}] \leavevmode
number of bytes to complete

\end{description}

\textbf{Description}

This updates bi\_sector, bi\_size and bi\_idx; if the number of bytes to
complete doesn't align with a bvec boundary, then bv\_len and bv\_offset will
be updated on the last bvec as well.

\textbf{bio} will then represent the remaining, uncompleted portion of the io.
\index{bio\_copy\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bio_copy_data}\pysiglinewithargsret{void \bfcode{bio\_copy\_data}}{struct bio *\emph{ dst}, struct bio *\emph{ src}}{}
copy contents of data buffers from one chain of bios to another

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bio * dst}}] \leavevmode
destination bio list

\item[{\code{struct bio * src}}] \leavevmode
source bio list

\end{description}

\textbf{Description}

If \textbf{src} and \textbf{dst} are single bios, bi\_next must be NULL - otherwise, treats
\textbf{src} and \textbf{dst} as linked lists of bios.

Stops when it reaches the end of either \textbf{src} or \textbf{dst} - that is, copies
min(src-\textgreater{}bi\_size, dst-\textgreater{}bi\_size) bytes (or the equivalent for lists of bios).
\index{bio\_map\_kern (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bio_map_kern}\pysiglinewithargsret{struct bio * \bfcode{bio\_map\_kern}}{struct request\_queue *\emph{ q}, void *\emph{ data}, unsigned int\emph{ len}, gfp\_t\emph{ gfp\_mask}}{}
map kernel address into bio

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct request\_queue * q}}] \leavevmode
the struct request\_queue for the bio

\item[{\code{void * data}}] \leavevmode
pointer to buffer to map

\item[{\code{unsigned int len}}] \leavevmode
length in bytes

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
allocation flags for bio allocation

\end{description}

\textbf{Description}
\begin{quote}

Map the kernel address into a bio suitable for io to a block
device. Returns an error pointer in case of error.
\end{quote}
\index{bio\_endio (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bio_endio}\pysiglinewithargsret{void \bfcode{bio\_endio}}{struct bio *\emph{ bio}}{}
end I/O on a bio

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bio * bio}}] \leavevmode
bio

\end{description}

\textbf{Description}
\begin{quote}

{\hyperref[filesystems/index:c.bio_endio]{\emph{\code{bio\_endio()}}}} will end I/O on the whole bio. {\hyperref[filesystems/index:c.bio_endio]{\emph{\code{bio\_endio()}}}} is the preferred
way to end I/O on a bio. No one should call \code{bi\_end\_io()} directly on a
bio unless they own it and thus know that it has an end\_io function.

{\hyperref[filesystems/index:c.bio_endio]{\emph{\code{bio\_endio()}}}} can be called several times on a bio that has been chained
using {\hyperref[filesystems/index:c.bio_chain]{\emph{\code{bio\_chain()}}}}.  The -\textgreater{}:c:func:\emph{bi\_end\_io()} function will only be called the
last time.  At this point the BLK\_TA\_COMPLETE tracing event will be
generated if BIO\_TRACE\_COMPLETION is set.
\end{quote}
\index{bio\_split (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bio_split}\pysiglinewithargsret{struct bio * \bfcode{bio\_split}}{struct bio *\emph{ bio}, int\emph{ sectors}, gfp\_t\emph{ gfp}, struct bio\_set *\emph{ bs}}{}
split a bio

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bio * bio}}] \leavevmode
bio to split

\item[{\code{int sectors}}] \leavevmode
number of sectors to split from the front of \textbf{bio}

\item[{\code{gfp\_t gfp}}] \leavevmode
gfp mask

\item[{\code{struct bio\_set * bs}}] \leavevmode
bio set to allocate from

\end{description}

\textbf{Description}

Allocates and returns a new bio which represents \textbf{sectors} from the start of
\textbf{bio}, and updates \textbf{bio} to represent the remaining sectors.

Unless this is a discard request the newly allocated bio will point
to \textbf{bio}`s bi\_io\_vec; it is the caller's responsibility to ensure that
\textbf{bio} is not freed before the split.
\index{bio\_trim (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bio_trim}\pysiglinewithargsret{void \bfcode{bio\_trim}}{struct bio *\emph{ bio}, int\emph{ offset}, int\emph{ size}}{}
trim a bio

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bio * bio}}] \leavevmode
bio to trim

\item[{\code{int offset}}] \leavevmode
number of sectors to trim from the front of \textbf{bio}

\item[{\code{int size}}] \leavevmode
size we want to trim \textbf{bio} to, in sectors

\end{description}
\index{bioset\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bioset_create}\pysiglinewithargsret{struct bio\_set * \bfcode{bioset\_create}}{unsigned int\emph{ pool\_size}, unsigned int\emph{ front\_pad}, int\emph{ flags}}{}
Create a bio\_set

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int pool\_size}}] \leavevmode
Number of bio and bio\_vecs to cache in the mempool

\item[{\code{unsigned int front\_pad}}] \leavevmode
Number of bytes to allocate in front of the returned bio

\item[{\code{int flags}}] \leavevmode
Flags to modify behavior, currently \code{BIOSET\_NEED\_BVECS}
and \code{BIOSET\_NEED\_RESCUER}

\end{description}

\textbf{Description}
\begin{quote}

Set up a bio\_set to be used with \textbf{bio\_alloc\_bioset}. Allows the caller
to ask for a number of bytes to be allocated in front of the bio.
Front pad allocation is useful for embedding the bio inside
another structure, to avoid allocating extra data to go with the bio.
Note that the bio must be embedded at the END of that structure always,
or things will break badly.
If \code{BIOSET\_NEED\_BVECS} is set in \textbf{flags}, a separate pool will be allocated
for allocating iovecs.  This pool is not needed e.g. for {\hyperref[filesystems/index:c.bio_clone_fast]{\emph{\code{bio\_clone\_fast()}}}}.
If \code{BIOSET\_NEED\_RESCUER} is set, a workqueue is created which can be used to
dispatch queued requests when the mempool runs out of space.
\end{quote}
\index{bio\_associate\_blkcg (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bio_associate_blkcg}\pysiglinewithargsret{int \bfcode{bio\_associate\_blkcg}}{struct bio *\emph{ bio}, struct cgroup\_subsys\_state *\emph{ blkcg\_css}}{}
associate a bio with the specified blkcg

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bio * bio}}] \leavevmode
target bio

\item[{\code{struct cgroup\_subsys\_state * blkcg\_css}}] \leavevmode
css of the blkcg to associate

\end{description}

\textbf{Description}

Associate \textbf{bio} with the blkcg specified by \textbf{blkcg\_css}.  Block layer will
treat \textbf{bio} as if it were issued by a task which belongs to the blkcg.

This function takes an extra reference of \textbf{blkcg\_css} which will be put
when \textbf{bio} is released.  The caller must own \textbf{bio} and is responsible for
synchronizing calls to this function.
\index{bio\_clone\_blkcg\_association (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bio_clone_blkcg_association}\pysiglinewithargsret{void \bfcode{bio\_clone\_blkcg\_association}}{struct bio *\emph{ dst}, struct bio *\emph{ src}}{}
clone blkcg association from src to dst bio

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bio * dst}}] \leavevmode
destination bio

\item[{\code{struct bio * src}}] \leavevmode
source bio

\end{description}
\index{seq\_open (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.seq_open}\pysiglinewithargsret{int \bfcode{seq\_open}}{struct file *\emph{ file}, const struct seq\_operations *\emph{ op}}{}
initialize sequential file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * file}}] \leavevmode
file we initialize

\item[{\code{const struct seq\_operations * op}}] \leavevmode
method table describing the sequence

\end{description}

\textbf{Description}
\begin{quote}

{\hyperref[filesystems/index:c.seq_open]{\emph{\code{seq\_open()}}}} sets \textbf{file}, associating it with a sequence described
by \textbf{op}.  \textbf{op}-\textgreater{}:c:func:\emph{start()} sets the iterator up and returns the first
element of sequence. \textbf{op}-\textgreater{}:c:func:\emph{stop()} shuts it down.  \textbf{op}-\textgreater{}:c:func:\emph{next()}
returns the next element of sequence.  \textbf{op}-\textgreater{}:c:func:\emph{show()} prints element
into the buffer.  In case of error -\textgreater{}:c:func:\emph{start()} and -\textgreater{}:c:func:\emph{next()} return
ERR\_PTR(error).  In the end of sequence they return \code{NULL}. -\textgreater{}:c:func:\emph{show()}
returns 0 in case of success and negative number in case of error.
Returning SEQ\_SKIP means ``discard this element and move on''.
\end{quote}

\textbf{Note}
\begin{description}
\item[{{\hyperref[filesystems/index:c.seq_open]{\emph{\code{seq\_open()}}}} will allocate a struct seq\_file and store its}] \leavevmode
pointer in \textbf{file}-\textgreater{}private\_data. This pointer should not be modified.

\end{description}
\index{seq\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.seq_read}\pysiglinewithargsret{ssize\_t \bfcode{seq\_read}}{struct file *\emph{ file}, char \_\_user *\emph{ buf}, size\_t\emph{ size}, loff\_t *\emph{ ppos}}{}
-\textgreater{}:c:func:\emph{read()} method for sequential files.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * file}}] \leavevmode
the file to read from

\item[{\code{char \_\_user * buf}}] \leavevmode
the buffer to read to

\item[{\code{size\_t size}}] \leavevmode
the maximum number of bytes to read

\item[{\code{loff\_t * ppos}}] \leavevmode
the current position in the file

\end{description}

\textbf{Description}
\begin{quote}

Ready-made -\textgreater{}f\_op-\textgreater{}:c:func:\emph{read()}
\end{quote}
\index{seq\_lseek (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.seq_lseek}\pysiglinewithargsret{loff\_t \bfcode{seq\_lseek}}{struct file *\emph{ file}, loff\_t\emph{ offset}, int\emph{ whence}}{}
-\textgreater{}:c:func:\emph{llseek()} method for sequential files.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * file}}] \leavevmode
the file in question

\item[{\code{loff\_t offset}}] \leavevmode
new position

\item[{\code{int whence}}] \leavevmode
0 for absolute, 1 for relative position

\end{description}

\textbf{Description}
\begin{quote}

Ready-made -\textgreater{}f\_op-\textgreater{}:c:func:\emph{llseek()}
\end{quote}
\index{seq\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.seq_release}\pysiglinewithargsret{int \bfcode{seq\_release}}{struct inode *\emph{ inode}, struct file *\emph{ file}}{}
free the structures associated with sequential file.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
its inode

\item[{\code{struct file * file}}] \leavevmode
file in question

\end{description}

\textbf{Description}
\begin{quote}

Frees the structures associated with sequential file; can be used
as -\textgreater{}f\_op-\textgreater{}:c:func:\emph{release()} if you don't have private data to destroy.
\end{quote}
\index{seq\_escape (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.seq_escape}\pysiglinewithargsret{void \bfcode{seq\_escape}}{struct seq\_file *\emph{ m}, const char *\emph{ s}, const char *\emph{ esc}}{}
print string into buffer, escaping some characters

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct seq\_file * m}}] \leavevmode
target buffer

\item[{\code{const char * s}}] \leavevmode
string

\item[{\code{const char * esc}}] \leavevmode
set of characters that need escaping

\end{description}

\textbf{Description}
\begin{quote}

Puts string into buffer, replacing each occurrence of character from
\textbf{esc} with usual octal escape.
Use \code{seq\_has\_overflowed()} to check for errors.
\end{quote}
\index{mangle\_path (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.mangle_path}\pysiglinewithargsret{char * \bfcode{mangle\_path}}{char *\emph{ s}, const char *\emph{ p}, const char *\emph{ esc}}{}
mangle and copy path to buffer beginning

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{char * s}}] \leavevmode
buffer start

\item[{\code{const char * p}}] \leavevmode
beginning of path in above buffer

\item[{\code{const char * esc}}] \leavevmode
set of characters that need escaping

\end{description}

\textbf{Description}
\begin{quote}

Copy the path from \textbf{p} to \textbf{s}, replacing each occurrence of character from
\textbf{esc} with usual octal escape.
Returns pointer past last written character in \textbf{s}, or NULL in case of
failure.
\end{quote}
\index{seq\_path (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.seq_path}\pysiglinewithargsret{int \bfcode{seq\_path}}{struct seq\_file *\emph{ m}, const struct path *\emph{ path}, const char *\emph{ esc}}{}
seq\_file interface to print a pathname

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct seq\_file * m}}] \leavevmode
the seq\_file handle

\item[{\code{const struct path * path}}] \leavevmode
the struct path to print

\item[{\code{const char * esc}}] \leavevmode
set of characters to escape in the output

\end{description}

\textbf{Description}

return the absolute path of `path', as represented by the
dentry / mnt pair in the path parameter.
\index{seq\_file\_path (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.seq_file_path}\pysiglinewithargsret{int \bfcode{seq\_file\_path}}{struct seq\_file *\emph{ m}, struct file *\emph{ file}, const char *\emph{ esc}}{}
seq\_file interface to print a pathname of a file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct seq\_file * m}}] \leavevmode
the seq\_file handle

\item[{\code{struct file * file}}] \leavevmode
the struct file to print

\item[{\code{const char * esc}}] \leavevmode
set of characters to escape in the output

\end{description}

\textbf{Description}

return the absolute path to the file.
\index{seq\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.seq_write}\pysiglinewithargsret{int \bfcode{seq\_write}}{struct seq\_file *\emph{ seq}, const void *\emph{ data}, size\_t\emph{ len}}{}
write arbitrary data to buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct seq\_file * seq}}] \leavevmode
seq\_file identifying the buffer to which data should be written

\item[{\code{const void * data}}] \leavevmode
data address

\item[{\code{size\_t len}}] \leavevmode
number of bytes

\end{description}

\textbf{Description}

Return 0 on success, non-zero otherwise.
\index{seq\_pad (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.seq_pad}\pysiglinewithargsret{void \bfcode{seq\_pad}}{struct seq\_file *\emph{ m}, char\emph{ c}}{}
write padding spaces to buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct seq\_file * m}}] \leavevmode
seq\_file identifying the buffer to which data should be written

\item[{\code{char c}}] \leavevmode
the byte to append after padding if non-zero

\end{description}
\index{seq\_hlist\_start (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.seq_hlist_start}\pysiglinewithargsret{struct hlist\_node * \bfcode{seq\_hlist\_start}}{struct hlist\_head *\emph{ head}, loff\_t\emph{ pos}}{}
start an iteration of a hlist

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hlist\_head * head}}] \leavevmode
the head of the hlist

\item[{\code{loff\_t pos}}] \leavevmode
the start position of the sequence

\end{description}

\textbf{Description}

Called at seq\_file-\textgreater{}op-\textgreater{}:c:func:\emph{start()}.
\index{seq\_hlist\_start\_head (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.seq_hlist_start_head}\pysiglinewithargsret{struct hlist\_node * \bfcode{seq\_hlist\_start\_head}}{struct hlist\_head *\emph{ head}, loff\_t\emph{ pos}}{}
start an iteration of a hlist

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hlist\_head * head}}] \leavevmode
the head of the hlist

\item[{\code{loff\_t pos}}] \leavevmode
the start position of the sequence

\end{description}

\textbf{Description}

Called at seq\_file-\textgreater{}op-\textgreater{}:c:func:\emph{start()}. Call this function if you want to
print a header at the top of the output.
\index{seq\_hlist\_next (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.seq_hlist_next}\pysiglinewithargsret{struct hlist\_node * \bfcode{seq\_hlist\_next}}{void *\emph{ v}, struct hlist\_head *\emph{ head}, loff\_t *\emph{ ppos}}{}
move to the next position of the hlist

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * v}}] \leavevmode
the current iterator

\item[{\code{struct hlist\_head * head}}] \leavevmode
the head of the hlist

\item[{\code{loff\_t * ppos}}] \leavevmode
the current position

\end{description}

\textbf{Description}

Called at seq\_file-\textgreater{}op-\textgreater{}:c:func:\emph{next()}.
\index{seq\_hlist\_start\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.seq_hlist_start_rcu}\pysiglinewithargsret{struct hlist\_node * \bfcode{seq\_hlist\_start\_rcu}}{struct hlist\_head *\emph{ head}, loff\_t\emph{ pos}}{}
start an iteration of a hlist protected by RCU

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hlist\_head * head}}] \leavevmode
the head of the hlist

\item[{\code{loff\_t pos}}] \leavevmode
the start position of the sequence

\end{description}

\textbf{Description}

Called at seq\_file-\textgreater{}op-\textgreater{}:c:func:\emph{start()}.

This list-traversal primitive may safely run concurrently with
the \_rcu list-mutation primitives such as \code{hlist\_add\_head\_rcu()}
as long as the traversal is guarded by \code{rcu\_read\_lock()}.
\index{seq\_hlist\_start\_head\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.seq_hlist_start_head_rcu}\pysiglinewithargsret{struct hlist\_node * \bfcode{seq\_hlist\_start\_head\_rcu}}{struct hlist\_head *\emph{ head}, loff\_t\emph{ pos}}{}
start an iteration of a hlist protected by RCU

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hlist\_head * head}}] \leavevmode
the head of the hlist

\item[{\code{loff\_t pos}}] \leavevmode
the start position of the sequence

\end{description}

\textbf{Description}

Called at seq\_file-\textgreater{}op-\textgreater{}:c:func:\emph{start()}. Call this function if you want to
print a header at the top of the output.

This list-traversal primitive may safely run concurrently with
the \_rcu list-mutation primitives such as \code{hlist\_add\_head\_rcu()}
as long as the traversal is guarded by \code{rcu\_read\_lock()}.
\index{seq\_hlist\_next\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.seq_hlist_next_rcu}\pysiglinewithargsret{struct hlist\_node * \bfcode{seq\_hlist\_next\_rcu}}{void *\emph{ v}, struct hlist\_head *\emph{ head}, loff\_t *\emph{ ppos}}{}
move to the next position of the hlist protected by RCU

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * v}}] \leavevmode
the current iterator

\item[{\code{struct hlist\_head * head}}] \leavevmode
the head of the hlist

\item[{\code{loff\_t * ppos}}] \leavevmode
the current position

\end{description}

\textbf{Description}

Called at seq\_file-\textgreater{}op-\textgreater{}:c:func:\emph{next()}.

This list-traversal primitive may safely run concurrently with
the \_rcu list-mutation primitives such as \code{hlist\_add\_head\_rcu()}
as long as the traversal is guarded by \code{rcu\_read\_lock()}.
\index{seq\_hlist\_start\_percpu (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.seq_hlist_start_percpu}\pysiglinewithargsret{struct hlist\_node * \bfcode{seq\_hlist\_start\_percpu}}{struct hlist\_head \_\_percpu *\emph{ head}, int *\emph{ cpu}, loff\_t\emph{ pos}}{}
start an iteration of a percpu hlist array

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hlist\_head \_\_percpu * head}}] \leavevmode
pointer to percpu array of struct hlist\_heads

\item[{\code{int * cpu}}] \leavevmode
pointer to cpu ``cursor''

\item[{\code{loff\_t pos}}] \leavevmode
start position of sequence

\end{description}

\textbf{Description}

Called at seq\_file-\textgreater{}op-\textgreater{}:c:func:\emph{start()}.
\index{seq\_hlist\_next\_percpu (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.seq_hlist_next_percpu}\pysiglinewithargsret{struct hlist\_node * \bfcode{seq\_hlist\_next\_percpu}}{void *\emph{ v}, struct hlist\_head \_\_percpu *\emph{ head}, int *\emph{ cpu}, loff\_t *\emph{ pos}}{}
move to the next position of the percpu hlist array

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * v}}] \leavevmode
pointer to current hlist\_node

\item[{\code{struct hlist\_head \_\_percpu * head}}] \leavevmode
pointer to percpu array of struct hlist\_heads

\item[{\code{int * cpu}}] \leavevmode
pointer to cpu ``cursor''

\item[{\code{loff\_t * pos}}] \leavevmode
start position of sequence

\end{description}

\textbf{Description}

Called at seq\_file-\textgreater{}op-\textgreater{}:c:func:\emph{next()}.
\index{register\_filesystem (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.register_filesystem}\pysiglinewithargsret{int \bfcode{register\_filesystem}}{struct file\_system\_type *\emph{ fs}}{}
register a new filesystem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file\_system\_type * fs}}] \leavevmode
the file system structure

\end{description}

\textbf{Description}
\begin{quote}

Adds the file system passed to the list of file systems the kernel
is aware of for mount and other syscalls. Returns 0 on success,
or a negative errno code on an error.

The \code{struct file\_system\_type} that is passed is linked into the kernel
structures and must not be freed until the file system has been
unregistered.
\end{quote}
\index{unregister\_filesystem (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.unregister_filesystem}\pysiglinewithargsret{int \bfcode{unregister\_filesystem}}{struct file\_system\_type *\emph{ fs}}{}
unregister a file system

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file\_system\_type * fs}}] \leavevmode
filesystem to unregister

\end{description}

\textbf{Description}
\begin{quote}

Remove a file system that was previously successfully registered
with the kernel. An error is returned if the file system is not found.
Zero is returned on a success.

Once this function has returned the \code{struct file\_system\_type} structure
may be freed or reused.
\end{quote}
\index{wbc\_account\_io (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.wbc_account_io}\pysiglinewithargsret{void \bfcode{wbc\_account\_io}}{struct writeback\_control *\emph{ wbc}, struct page *\emph{ page}, size\_t\emph{ bytes}}{}
account IO issued during writeback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct writeback\_control * wbc}}] \leavevmode
writeback\_control of the writeback in progress

\item[{\code{struct page * page}}] \leavevmode
page being written out

\item[{\code{size\_t bytes}}] \leavevmode
number of bytes being written out

\end{description}

\textbf{Description}

\textbf{bytes} from \textbf{page} are about to written out during the writeback
controlled by \textbf{wbc}.  Keep the book for foreign inode detection.  See
\code{wbc\_detach\_inode()}.
\index{inode\_congested (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.inode_congested}\pysiglinewithargsret{int \bfcode{inode\_congested}}{struct inode *\emph{ inode}, int\emph{ cong\_bits}}{}
test whether an inode is congested

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode to test for congestion (may be NULL)

\item[{\code{int cong\_bits}}] \leavevmode
mask of WB\_{[}a{]}sync\_congested bits to test

\end{description}

\textbf{Description}

Tests whether \textbf{inode} is congested.  \textbf{cong\_bits} is the mask of congestion
bits to test and the return value is the mask of set bits.

If cgroup writeback is enabled for \textbf{inode}, the congestion state is
determined by whether the cgwb (cgroup bdi\_writeback) for the blkcg
associated with \textbf{inode} is congested; otherwise, the root wb's congestion
state is used.

\textbf{inode} is allowed to be NULL as this function is often called on
mapping-\textgreater{}host which is NULL for the swapper space.
\index{\_\_mark\_inode\_dirty (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.__mark_inode_dirty}\pysiglinewithargsret{void \bfcode{\_\_mark\_inode\_dirty}}{struct inode *\emph{ inode}, int\emph{ flags}}{}
internal function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode to mark

\item[{\code{int flags}}] \leavevmode
what kind of dirty (i.e. I\_DIRTY\_SYNC)

\end{description}

\textbf{Description}

Mark an inode as dirty. Callers should use mark\_inode\_dirty or
mark\_inode\_dirty\_sync.

Put the inode on the super block's dirty list.

CAREFUL! We mark it dirty unconditionally, but move it onto the
dirty list only if it is hashed or if it refers to a blockdev.
If it was not hashed, it will never be added to the dirty list
even if it is later hashed, as it will have been marked dirty already.

In short, make sure you hash any inodes \_before\_ you start marking
them dirty.

Note that for blockdevs, inode-\textgreater{}dirtied\_when represents the dirtying time of
the block-special inode (/dev/hda1) itself.  And the -\textgreater{}dirtied\_when field of
the kernel-internal blockdev inode represents the dirtying time of the
blockdev's pages.  This is why for I\_DIRTY\_PAGES we always use
page-\textgreater{}mapping-\textgreater{}host, so the page-dirtying time is recorded in the internal
blockdev inode.
\index{writeback\_inodes\_sb\_nr (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.writeback_inodes_sb_nr}\pysiglinewithargsret{void \bfcode{writeback\_inodes\_sb\_nr}}{struct super\_block *\emph{ sb}, unsigned long\emph{ nr}, enum wb\_reason\emph{ reason}}{}
writeback dirty inodes from given super\_block

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
the superblock

\item[{\code{unsigned long nr}}] \leavevmode
the number of pages to write

\item[{\code{enum wb\_reason reason}}] \leavevmode
reason why some writeback work initiated

\end{description}

\textbf{Description}

Start writeback on some inodes on this super\_block. No guarantees are made
on how many (if any) will be written, and this function does not wait
for IO completion of submitted IO.
\index{writeback\_inodes\_sb (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.writeback_inodes_sb}\pysiglinewithargsret{void \bfcode{writeback\_inodes\_sb}}{struct super\_block *\emph{ sb}, enum wb\_reason\emph{ reason}}{}
writeback dirty inodes from given super\_block

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
the superblock

\item[{\code{enum wb\_reason reason}}] \leavevmode
reason why some writeback work was initiated

\end{description}

\textbf{Description}

Start writeback on some inodes on this super\_block. No guarantees are made
on how many (if any) will be written, and this function does not wait
for IO completion of submitted IO.
\index{try\_to\_writeback\_inodes\_sb (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.try_to_writeback_inodes_sb}\pysiglinewithargsret{void \bfcode{try\_to\_writeback\_inodes\_sb}}{struct super\_block *\emph{ sb}, enum wb\_reason\emph{ reason}}{}
try to start writeback if none underway

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
the superblock

\item[{\code{enum wb\_reason reason}}] \leavevmode
reason why some writeback work was initiated

\end{description}

\textbf{Description}

Invoke \_\_writeback\_inodes\_sb\_nr if no writeback is currently underway.
\index{sync\_inodes\_sb (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sync_inodes_sb}\pysiglinewithargsret{void \bfcode{sync\_inodes\_sb}}{struct super\_block *\emph{ sb}}{}
sync sb inode pages

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct super\_block * sb}}] \leavevmode
the superblock

\end{description}

\textbf{Description}

This function writes and waits on any dirty inode belonging to this
super\_block.
\index{write\_inode\_now (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.write_inode_now}\pysiglinewithargsret{int \bfcode{write\_inode\_now}}{struct inode *\emph{ inode}, int\emph{ sync}}{}
write an inode to disk

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
inode to write to disk

\item[{\code{int sync}}] \leavevmode
whether the write should be synchronous or not

\end{description}

\textbf{Description}

This function commits an inode to disk immediately if it is dirty. This is
primarily needed by knfsd.

The caller must either have a ref on the inode or must have set I\_WILL\_FREE.
\index{sync\_inode (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sync_inode}\pysiglinewithargsret{int \bfcode{sync\_inode}}{struct inode *\emph{ inode}, struct writeback\_control *\emph{ wbc}}{}
write an inode and its pages to disk.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
the inode to sync

\item[{\code{struct writeback\_control * wbc}}] \leavevmode
controls the writeback mode

\end{description}

\textbf{Description}

{\hyperref[filesystems/index:c.sync_inode]{\emph{\code{sync\_inode()}}}} will write an inode and its pages to disk.  It will also
correctly update the inode on its superblock's dirty inode lists and will
update inode-\textgreater{}i\_state.

The caller must have a ref on the inode.
\index{sync\_inode\_metadata (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sync_inode_metadata}\pysiglinewithargsret{int \bfcode{sync\_inode\_metadata}}{struct inode *\emph{ inode}, int\emph{ wait}}{}
write an inode to disk

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
the inode to sync

\item[{\code{int wait}}] \leavevmode
wait for I/O to complete.

\end{description}

\textbf{Description}

Write an inode to disk and adjust its dirty state after completion.

\textbf{Note}

only writes the actual inode, no associated data or other metadata.
\index{freeze\_bdev (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.freeze_bdev}\pysiglinewithargsret{struct super\_block * \bfcode{freeze\_bdev}}{struct block\_device *\emph{ bdev}}{}~\begin{itemize}
\item {} 
lock a filesystem and force it into a consistent state

\end{itemize}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct block\_device * bdev}}] \leavevmode
blockdevice to lock

\end{description}

\textbf{Description}

If a superblock is found on this device, we take the s\_umount semaphore
on it to make sure nobody unmounts until the snapshot creation is done.
The reference counter (bd\_fsfreeze\_count) guarantees that only the last
unfreeze process can unfreeze the frozen filesystem actually when multiple
freeze requests arrive simultaneously. It counts up in {\hyperref[filesystems/index:c.freeze_bdev]{\emph{\code{freeze\_bdev()}}}} and
count down in {\hyperref[filesystems/index:c.thaw_bdev]{\emph{\code{thaw\_bdev()}}}}. When it becomes 0, {\hyperref[filesystems/index:c.thaw_bdev]{\emph{\code{thaw\_bdev()}}}} will unfreeze
actually.
\index{thaw\_bdev (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.thaw_bdev}\pysiglinewithargsret{int \bfcode{thaw\_bdev}}{struct block\_device *\emph{ bdev}, struct super\_block *\emph{ sb}}{}~\begin{itemize}
\item {} 
unlock filesystem

\end{itemize}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct block\_device * bdev}}] \leavevmode
blockdevice to unlock

\item[{\code{struct super\_block * sb}}] \leavevmode
associated superblock

\end{description}

\textbf{Description}

Unlocks the filesystem and marks it writeable again after {\hyperref[filesystems/index:c.freeze_bdev]{\emph{\code{freeze\_bdev()}}}}.
\index{bdev\_read\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bdev_read_page}\pysiglinewithargsret{int \bfcode{bdev\_read\_page}}{struct block\_device *\emph{ bdev}, sector\_t\emph{ sector}, struct page *\emph{ page}}{}
Start reading a page from a block device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct block\_device * bdev}}] \leavevmode
The device to read the page from

\item[{\code{sector\_t sector}}] \leavevmode
The offset on the device to read the page to (need not be aligned)

\item[{\code{struct page * page}}] \leavevmode
The page to read

\end{description}

\textbf{Description}

On entry, the page should be locked.  It will be unlocked when the page
has been read.  If the block driver implements rw\_page synchronously,
that will be true on exit from this function, but it need not be.

Errors returned by this function are usually ``soft'', eg out of memory, or
queue full; callers should try a different route to read this page rather
than propagate an error back up the stack.

\textbf{Return}

negative errno if an error occurs, 0 if submission was successful.
\index{bdev\_write\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bdev_write_page}\pysiglinewithargsret{int \bfcode{bdev\_write\_page}}{struct block\_device *\emph{ bdev}, sector\_t\emph{ sector}, struct page *\emph{ page}, struct writeback\_control *\emph{ wbc}}{}
Start writing a page to a block device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct block\_device * bdev}}] \leavevmode
The device to write the page to

\item[{\code{sector\_t sector}}] \leavevmode
The offset on the device to write the page to (need not be aligned)

\item[{\code{struct page * page}}] \leavevmode
The page to write

\item[{\code{struct writeback\_control * wbc}}] \leavevmode
The writeback\_control for the write

\end{description}

\textbf{Description}

On entry, the page should be locked and not currently under writeback.
On exit, if the write started successfully, the page will be unlocked and
under writeback.  If the write failed already (eg the driver failed to
queue the page to the device), the page will still be locked.  If the
caller is a -\textgreater{}writepage implementation, it will need to unlock the page.

Errors returned by this function are usually ``soft'', eg out of memory, or
queue full; callers should try a different route to write this page rather
than propagate an error back up the stack.

\textbf{Return}

negative errno if an error occurs, 0 if submission was successful.
\index{bdgrab (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bdgrab}\pysiglinewithargsret{struct block\_device * \bfcode{bdgrab}}{struct block\_device *\emph{ bdev}}{}~\begin{itemize}
\item {} 
Grab a reference to an already referenced block device

\end{itemize}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct block\_device * bdev}}] \leavevmode
Block device to grab a reference to.

\end{description}
\index{bd\_link\_disk\_holder (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bd_link_disk_holder}\pysiglinewithargsret{int \bfcode{bd\_link\_disk\_holder}}{struct block\_device *\emph{ bdev}, struct gendisk *\emph{ disk}}{}
create symlinks between holding disk and slave bdev

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct block\_device * bdev}}] \leavevmode
the claimed slave bdev

\item[{\code{struct gendisk * disk}}] \leavevmode
the holding disk

\end{description}

\textbf{Description}

DON'T USE THIS UNLESS YOU'RE ALREADY USING IT.

This functions creates the following sysfs symlinks.
\begin{itemize}
\item {} 
from ``slaves'' directory of the holder \textbf{disk} to the claimed \textbf{bdev}

\item {} 
from ``holders'' directory of the \textbf{bdev} to the holder \textbf{disk}

\end{itemize}

For example, if /dev/dm-0 maps to /dev/sda and disk for dm-0 is
passed to {\hyperref[filesystems/index:c.bd_link_disk_holder]{\emph{\code{bd\_link\_disk\_holder()}}}}, then:
\begin{quote}

/sys/block/dm-0/slaves/sda --\textgreater{} /sys/block/sda
/sys/block/sda/holders/dm-0 --\textgreater{} /sys/block/dm-0
\end{quote}

The caller must have claimed \textbf{bdev} before calling this function and
ensure that both \textbf{bdev} and \textbf{disk} are valid during the creation and
lifetime of these symlinks.

\textbf{Context}

Might sleep.

\textbf{Return}

0 on success, -errno on failure.
\index{bd\_unlink\_disk\_holder (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.bd_unlink_disk_holder}\pysiglinewithargsret{void \bfcode{bd\_unlink\_disk\_holder}}{struct block\_device *\emph{ bdev}, struct gendisk *\emph{ disk}}{}
destroy symlinks created by {\hyperref[filesystems/index:c.bd_link_disk_holder]{\emph{\code{bd\_link\_disk\_holder()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct block\_device * bdev}}] \leavevmode
the calimed slave bdev

\item[{\code{struct gendisk * disk}}] \leavevmode
the holding disk

\end{description}

\textbf{Description}

DON'T USE THIS UNLESS YOU'RE ALREADY USING IT.

\textbf{Context}

Might sleep.
\index{check\_disk\_size\_change (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.check_disk_size_change}\pysiglinewithargsret{void \bfcode{check\_disk\_size\_change}}{struct gendisk *\emph{ disk}, struct block\_device *\emph{ bdev}}{}
checks for disk size change and adjusts bdev size.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gendisk * disk}}] \leavevmode
struct gendisk to check

\item[{\code{struct block\_device * bdev}}] \leavevmode
struct bdev to adjust.

\end{description}

\textbf{Description}

This routine checks to see if the bdev size does not match the disk size
and adjusts it if it differs.
\index{revalidate\_disk (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.revalidate_disk}\pysiglinewithargsret{int \bfcode{revalidate\_disk}}{struct gendisk *\emph{ disk}}{}
wrapper for lower-level driver's revalidate\_disk call-back

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gendisk * disk}}] \leavevmode
struct gendisk to be revalidated

\end{description}

\textbf{Description}

This routine is a wrapper for lower-level driver's revalidate\_disk
call-backs.  It is used to do common pre and post operations needed
for all revalidate\_disk operations.
\index{blkdev\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.blkdev_get}\pysiglinewithargsret{int \bfcode{blkdev\_get}}{struct block\_device *\emph{ bdev}, fmode\_t\emph{ mode}, void *\emph{ holder}}{}
open a block device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct block\_device * bdev}}] \leavevmode
block\_device to open

\item[{\code{fmode\_t mode}}] \leavevmode
FMODE\_* mask

\item[{\code{void * holder}}] \leavevmode
exclusive holder identifier

\end{description}

\textbf{Description}

Open \textbf{bdev} with \textbf{mode}.  If \textbf{mode} includes \code{FMODE\_EXCL}, \textbf{bdev} is
open with exclusive access.  Specifying \code{FMODE\_EXCL} with \code{NULL}
\textbf{holder} is invalid.  Exclusive opens may nest for the same \textbf{holder}.

On success, the reference count of \textbf{bdev} is unchanged.  On failure,
\textbf{bdev} is put.

\textbf{Context}

Might sleep.

\textbf{Return}

0 on success, -errno on failure.
\index{blkdev\_get\_by\_path (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.blkdev_get_by_path}\pysiglinewithargsret{struct block\_device * \bfcode{blkdev\_get\_by\_path}}{const char *\emph{ path}, fmode\_t\emph{ mode}, void *\emph{ holder}}{}
open a block device by name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * path}}] \leavevmode
path to the block device to open

\item[{\code{fmode\_t mode}}] \leavevmode
FMODE\_* mask

\item[{\code{void * holder}}] \leavevmode
exclusive holder identifier

\end{description}

\textbf{Description}

Open the blockdevice described by the device file at \textbf{path}.  \textbf{mode}
and \textbf{holder} are identical to {\hyperref[filesystems/index:c.blkdev_get]{\emph{\code{blkdev\_get()}}}}.

On success, the returned block\_device has reference count of one.

\textbf{Context}

Might sleep.

\textbf{Return}

Pointer to block\_device on success, ERR\_PTR(-errno) on failure.
\index{blkdev\_get\_by\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.blkdev_get_by_dev}\pysiglinewithargsret{struct block\_device * \bfcode{blkdev\_get\_by\_dev}}{dev\_t\emph{ dev}, fmode\_t\emph{ mode}, void *\emph{ holder}}{}
open a block device by device number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{dev\_t dev}}] \leavevmode
device number of block device to open

\item[{\code{fmode\_t mode}}] \leavevmode
FMODE\_* mask

\item[{\code{void * holder}}] \leavevmode
exclusive holder identifier

\end{description}

\textbf{Description}

Open the blockdevice described by device number \textbf{dev}.  \textbf{mode} and
\textbf{holder} are identical to {\hyperref[filesystems/index:c.blkdev_get]{\emph{\code{blkdev\_get()}}}}.

Use it ONLY if you really do not have anything better - i.e. when
you are behind a truly sucky interface and all you are given is a
device number.  \_Never\_ to be used for internal purposes.  If you
ever need it - reconsider your API.

On success, the returned block\_device has reference count of one.

\textbf{Context}

Might sleep.

\textbf{Return}

Pointer to block\_device on success, ERR\_PTR(-errno) on failure.
\index{lookup\_bdev (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.lookup_bdev}\pysiglinewithargsret{struct block\_device * \bfcode{lookup\_bdev}}{const char *\emph{ pathname}}{}
lookup a struct block\_device by name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * pathname}}] \leavevmode
special file representing the block device

\end{description}

\textbf{Description}

Get a reference to the blockdevice at \textbf{pathname} in the current
namespace if possible and return it.  Return ERR\_PTR(error)
otherwise.


\chapter{The proc filesystem}
\label{filesystems/index:the-proc-filesystem}

\section{sysctl interface}
\label{filesystems/index:sysctl-interface}\index{proc\_dostring (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.proc_dostring}\pysiglinewithargsret{int \bfcode{proc\_dostring}}{struct ctl\_table *\emph{ table}, int\emph{ write}, void \_\_user *\emph{ buffer}, size\_t *\emph{ lenp}, loff\_t *\emph{ ppos}}{}
read a string sysctl

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ctl\_table * table}}] \leavevmode
the sysctl table

\item[{\code{int write}}] \leavevmode
\code{TRUE} if this is a write to the sysctl file

\item[{\code{void \_\_user * buffer}}] \leavevmode
the user buffer

\item[{\code{size\_t * lenp}}] \leavevmode
the size of the user buffer

\item[{\code{loff\_t * ppos}}] \leavevmode
file position

\end{description}

\textbf{Description}

Reads/writes a string from/to the user buffer. If the kernel
buffer provided is not large enough to hold the string, the
string is truncated. The copied string is \code{NULL-terminated}.
If the string is being read by the user process, it is copied
and a newline `n' is added. It is truncated if the buffer is
not large enough.

Returns 0 on success.
\index{proc\_dointvec (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.proc_dointvec}\pysiglinewithargsret{int \bfcode{proc\_dointvec}}{struct ctl\_table *\emph{ table}, int\emph{ write}, void \_\_user *\emph{ buffer}, size\_t *\emph{ lenp}, loff\_t *\emph{ ppos}}{}
read a vector of integers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ctl\_table * table}}] \leavevmode
the sysctl table

\item[{\code{int write}}] \leavevmode
\code{TRUE} if this is a write to the sysctl file

\item[{\code{void \_\_user * buffer}}] \leavevmode
the user buffer

\item[{\code{size\_t * lenp}}] \leavevmode
the size of the user buffer

\item[{\code{loff\_t * ppos}}] \leavevmode
file position

\end{description}

\textbf{Description}

Reads/writes up to table-\textgreater{}maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.

Returns 0 on success.
\index{proc\_douintvec (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.proc_douintvec}\pysiglinewithargsret{int \bfcode{proc\_douintvec}}{struct ctl\_table *\emph{ table}, int\emph{ write}, void \_\_user *\emph{ buffer}, size\_t *\emph{ lenp}, loff\_t *\emph{ ppos}}{}
read a vector of unsigned integers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ctl\_table * table}}] \leavevmode
the sysctl table

\item[{\code{int write}}] \leavevmode
\code{TRUE} if this is a write to the sysctl file

\item[{\code{void \_\_user * buffer}}] \leavevmode
the user buffer

\item[{\code{size\_t * lenp}}] \leavevmode
the size of the user buffer

\item[{\code{loff\_t * ppos}}] \leavevmode
file position

\end{description}

\textbf{Description}

Reads/writes up to table-\textgreater{}maxlen/sizeof(unsigned int) unsigned integer
values from/to the user buffer, treated as an ASCII string.

Returns 0 on success.
\index{proc\_dointvec\_minmax (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.proc_dointvec_minmax}\pysiglinewithargsret{int \bfcode{proc\_dointvec\_minmax}}{struct ctl\_table *\emph{ table}, int\emph{ write}, void \_\_user *\emph{ buffer}, size\_t *\emph{ lenp}, loff\_t *\emph{ ppos}}{}
read a vector of integers with min/max values

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ctl\_table * table}}] \leavevmode
the sysctl table

\item[{\code{int write}}] \leavevmode
\code{TRUE} if this is a write to the sysctl file

\item[{\code{void \_\_user * buffer}}] \leavevmode
the user buffer

\item[{\code{size\_t * lenp}}] \leavevmode
the size of the user buffer

\item[{\code{loff\_t * ppos}}] \leavevmode
file position

\end{description}

\textbf{Description}

Reads/writes up to table-\textgreater{}maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.

This routine will ensure the values are within the range specified by
table-\textgreater{}extra1 (min) and table-\textgreater{}extra2 (max).

Returns 0 on success.
\index{proc\_douintvec\_minmax (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.proc_douintvec_minmax}\pysiglinewithargsret{int \bfcode{proc\_douintvec\_minmax}}{struct ctl\_table *\emph{ table}, int\emph{ write}, void \_\_user *\emph{ buffer}, size\_t *\emph{ lenp}, loff\_t *\emph{ ppos}}{}
read a vector of unsigned ints with min/max values

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ctl\_table * table}}] \leavevmode
the sysctl table

\item[{\code{int write}}] \leavevmode
\code{TRUE} if this is a write to the sysctl file

\item[{\code{void \_\_user * buffer}}] \leavevmode
the user buffer

\item[{\code{size\_t * lenp}}] \leavevmode
the size of the user buffer

\item[{\code{loff\_t * ppos}}] \leavevmode
file position

\end{description}

\textbf{Description}

Reads/writes up to table-\textgreater{}maxlen/sizeof(unsigned int) unsigned integer
values from/to the user buffer, treated as an ASCII string. Negative
strings are not allowed.

This routine will ensure the values are within the range specified by
table-\textgreater{}extra1 (min) and table-\textgreater{}extra2 (max). There is a final sanity
check for UINT\_MAX to avoid having to support wrap around uses from
userspace.

Returns 0 on success.
\index{proc\_doulongvec\_minmax (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.proc_doulongvec_minmax}\pysiglinewithargsret{int \bfcode{proc\_doulongvec\_minmax}}{struct ctl\_table *\emph{ table}, int\emph{ write}, void \_\_user *\emph{ buffer}, size\_t *\emph{ lenp}, loff\_t *\emph{ ppos}}{}
read a vector of long integers with min/max values

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ctl\_table * table}}] \leavevmode
the sysctl table

\item[{\code{int write}}] \leavevmode
\code{TRUE} if this is a write to the sysctl file

\item[{\code{void \_\_user * buffer}}] \leavevmode
the user buffer

\item[{\code{size\_t * lenp}}] \leavevmode
the size of the user buffer

\item[{\code{loff\_t * ppos}}] \leavevmode
file position

\end{description}

\textbf{Description}

Reads/writes up to table-\textgreater{}maxlen/sizeof(unsigned long) unsigned long
values from/to the user buffer, treated as an ASCII string.

This routine will ensure the values are within the range specified by
table-\textgreater{}extra1 (min) and table-\textgreater{}extra2 (max).

Returns 0 on success.
\index{proc\_doulongvec\_ms\_jiffies\_minmax (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.proc_doulongvec_ms_jiffies_minmax}\pysiglinewithargsret{int \bfcode{proc\_doulongvec\_ms\_jiffies\_minmax}}{struct ctl\_table *\emph{ table}, int\emph{ write}, void \_\_user *\emph{ buffer}, size\_t *\emph{ lenp}, loff\_t *\emph{ ppos}}{}
read a vector of millisecond values with min/max values

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ctl\_table * table}}] \leavevmode
the sysctl table

\item[{\code{int write}}] \leavevmode
\code{TRUE} if this is a write to the sysctl file

\item[{\code{void \_\_user * buffer}}] \leavevmode
the user buffer

\item[{\code{size\_t * lenp}}] \leavevmode
the size of the user buffer

\item[{\code{loff\_t * ppos}}] \leavevmode
file position

\end{description}

\textbf{Description}

Reads/writes up to table-\textgreater{}maxlen/sizeof(unsigned long) unsigned long
values from/to the user buffer, treated as an ASCII string. The values
are treated as milliseconds, and converted to jiffies when they are stored.

This routine will ensure the values are within the range specified by
table-\textgreater{}extra1 (min) and table-\textgreater{}extra2 (max).

Returns 0 on success.
\index{proc\_dointvec\_jiffies (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.proc_dointvec_jiffies}\pysiglinewithargsret{int \bfcode{proc\_dointvec\_jiffies}}{struct ctl\_table *\emph{ table}, int\emph{ write}, void \_\_user *\emph{ buffer}, size\_t *\emph{ lenp}, loff\_t *\emph{ ppos}}{}
read a vector of integers as seconds

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ctl\_table * table}}] \leavevmode
the sysctl table

\item[{\code{int write}}] \leavevmode
\code{TRUE} if this is a write to the sysctl file

\item[{\code{void \_\_user * buffer}}] \leavevmode
the user buffer

\item[{\code{size\_t * lenp}}] \leavevmode
the size of the user buffer

\item[{\code{loff\_t * ppos}}] \leavevmode
file position

\end{description}

\textbf{Description}

Reads/writes up to table-\textgreater{}maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.
The values read are assumed to be in seconds, and are converted into
jiffies.

Returns 0 on success.
\index{proc\_dointvec\_userhz\_jiffies (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.proc_dointvec_userhz_jiffies}\pysiglinewithargsret{int \bfcode{proc\_dointvec\_userhz\_jiffies}}{struct ctl\_table *\emph{ table}, int\emph{ write}, void \_\_user *\emph{ buffer}, size\_t *\emph{ lenp}, loff\_t *\emph{ ppos}}{}
read a vector of integers as 1/USER\_HZ seconds

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ctl\_table * table}}] \leavevmode
the sysctl table

\item[{\code{int write}}] \leavevmode
\code{TRUE} if this is a write to the sysctl file

\item[{\code{void \_\_user * buffer}}] \leavevmode
the user buffer

\item[{\code{size\_t * lenp}}] \leavevmode
the size of the user buffer

\item[{\code{loff\_t * ppos}}] \leavevmode
pointer to the file position

\end{description}

\textbf{Description}

Reads/writes up to table-\textgreater{}maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.
The values read are assumed to be in 1/USER\_HZ seconds, and
are converted into jiffies.

Returns 0 on success.
\index{proc\_dointvec\_ms\_jiffies (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.proc_dointvec_ms_jiffies}\pysiglinewithargsret{int \bfcode{proc\_dointvec\_ms\_jiffies}}{struct ctl\_table *\emph{ table}, int\emph{ write}, void \_\_user *\emph{ buffer}, size\_t *\emph{ lenp}, loff\_t *\emph{ ppos}}{}
read a vector of integers as 1 milliseconds

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ctl\_table * table}}] \leavevmode
the sysctl table

\item[{\code{int write}}] \leavevmode
\code{TRUE} if this is a write to the sysctl file

\item[{\code{void \_\_user * buffer}}] \leavevmode
the user buffer

\item[{\code{size\_t * lenp}}] \leavevmode
the size of the user buffer

\item[{\code{loff\_t * ppos}}] \leavevmode
the current position in the file

\end{description}

\textbf{Description}

Reads/writes up to table-\textgreater{}maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.
The values read are assumed to be in 1/1000 seconds, and
are converted into jiffies.

Returns 0 on success.


\section{proc filesystem interface}
\label{filesystems/index:proc-filesystem-interface}\index{proc\_flush\_task (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.proc_flush_task}\pysiglinewithargsret{void \bfcode{proc\_flush\_task}}{struct task\_struct *\emph{ task}}{}
Remove dcache entries for \textbf{task} from the /proc dcache.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct task\_struct * task}}] \leavevmode
task that should be flushed.

\end{description}

\textbf{Description}

When flushing dentries from proc, one needs to flush them from global
proc (proc\_mnt) and from all the namespaces' procs this task was seen
in. This call is supposed to do all of this job.

Looks in the dcache for
/proc/\textbf{pid}
/proc/\textbf{tgid}/task/\textbf{pid}
if either directory is present flushes it and all of it'ts children
from the dcache.

It is safe and reasonable to cache /proc entries for a task until
that task exits.  After that they just clog up the dcache with
useless entries, possibly causing useful dcache entries to be
flushed instead.  This routine is proved to flush those useless
dcache entries at process exit time.

\textbf{NOTE}
\begin{description}
\item[{This routine is just an optimization so it does not guarantee}] \leavevmode
that no dcache entries will exist at process exit time it
just makes it very unlikely that any will persist.

\end{description}


\chapter{Events based on file descriptors}
\label{filesystems/index:events-based-on-file-descriptors}\index{eventfd\_signal (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.eventfd_signal}\pysiglinewithargsret{\_\_u64 \bfcode{eventfd\_signal}}{struct eventfd\_ctx *\emph{ ctx}, \_\_u64\emph{ n}}{}
Adds \textbf{n} to the eventfd counter.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct eventfd\_ctx * ctx}}] \leavevmode
{[}in{]} Pointer to the eventfd context.

\item[{\code{\_\_u64 n}}] \leavevmode
{[}in{]} Value of the counter to be added to the eventfd internal counter.
The value cannot be negative.

\end{description}

\textbf{Description}

This function is supposed to be called by the kernel in paths that do not
allow sleeping. In this function we allow the counter to reach the ULLONG\_MAX
value, and we signal this as overflow condition by returning a EPOLLERR
to poll(2).

Returns the amount by which the counter was incremented.  This will be less
than \textbf{n} if the counter has overflowed.
\index{eventfd\_ctx\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.eventfd_ctx_put}\pysiglinewithargsret{void \bfcode{eventfd\_ctx\_put}}{struct eventfd\_ctx *\emph{ ctx}}{}
Releases a reference to the internal eventfd context.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct eventfd\_ctx * ctx}}] \leavevmode
{[}in{]} Pointer to eventfd context.

\end{description}

\textbf{Description}

The eventfd context reference must have been previously acquired either
with {\hyperref[filesystems/index:c.eventfd_ctx_fdget]{\emph{\code{eventfd\_ctx\_fdget()}}}} or {\hyperref[filesystems/index:c.eventfd_ctx_fileget]{\emph{\code{eventfd\_ctx\_fileget()}}}}.
\index{eventfd\_ctx\_remove\_wait\_queue (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.eventfd_ctx_remove_wait_queue}\pysiglinewithargsret{int \bfcode{eventfd\_ctx\_remove\_wait\_queue}}{struct eventfd\_ctx *\emph{ ctx}, wait\_queue\_entry\_t *\emph{ wait}, \_\_u64 *\emph{ cnt}}{}
Read the current counter and removes wait queue.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct eventfd\_ctx * ctx}}] \leavevmode
{[}in{]} Pointer to eventfd context.

\item[{\code{wait\_queue\_entry\_t * wait}}] \leavevmode
{[}in{]} Wait queue to be removed.

\item[{\code{\_\_u64 * cnt}}] \leavevmode
{[}out{]} Pointer to the 64-bit counter value.

\end{description}

\textbf{Description}

Returns \code{0} if successful, or the following error codes:
\begin{optionlist}{3cm}
\item [-EAGAIN]  
: The operation would have blocked.
\end{optionlist}

This is used to atomically remove a wait queue entry from the eventfd wait
queue head, and read/reset the counter value.
\index{eventfd\_fget (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.eventfd_fget}\pysiglinewithargsret{struct file * \bfcode{eventfd\_fget}}{int\emph{ fd}}{}
Acquire a reference of an eventfd file descriptor.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int fd}}] \leavevmode
{[}in{]} Eventfd file descriptor.

\end{description}

\textbf{Description}

Returns a pointer to the eventfd file structure in case of success, or the
following error pointer:
\begin{optionlist}{3cm}
\item [-EBADF]  
: Invalid \textbf{fd} file descriptor.
\item [-EINVAL]  
: The \textbf{fd} file descriptor is not an eventfd file.
\end{optionlist}
\index{eventfd\_ctx\_fdget (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.eventfd_ctx_fdget}\pysiglinewithargsret{struct eventfd\_ctx * \bfcode{eventfd\_ctx\_fdget}}{int\emph{ fd}}{}
Acquires a reference to the internal eventfd context.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int fd}}] \leavevmode
{[}in{]} Eventfd file descriptor.

\end{description}

\textbf{Description}

Returns a pointer to the internal eventfd context, otherwise the error
pointers returned by the following functions:

eventfd\_fget
\index{eventfd\_ctx\_fileget (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.eventfd_ctx_fileget}\pysiglinewithargsret{struct eventfd\_ctx * \bfcode{eventfd\_ctx\_fileget}}{struct file *\emph{ file}}{}
Acquires a reference to the internal eventfd context.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * file}}] \leavevmode
{[}in{]} Eventfd file pointer.

\end{description}

\textbf{Description}

Returns a pointer to the internal eventfd context, otherwise the error
pointer:
\begin{optionlist}{3cm}
\item [-EINVAL]  
: The \textbf{fd} file descriptor is not an eventfd file.
\end{optionlist}


\chapter{The Filesystem for Exporting Kernel Objects}
\label{filesystems/index:the-filesystem-for-exporting-kernel-objects}\index{sysfs\_create\_file\_ns (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sysfs_create_file_ns}\pysiglinewithargsret{int \bfcode{sysfs\_create\_file\_ns}}{struct kobject *\emph{ kobj}, const struct attribute *\emph{ attr}, const void *\emph{ ns}}{}
create an attribute file for an object with custom ns

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
object we're creating for

\item[{\code{const struct attribute * attr}}] \leavevmode
attribute descriptor

\item[{\code{const void * ns}}] \leavevmode
namespace the new file should belong to

\end{description}
\index{sysfs\_add\_file\_to\_group (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sysfs_add_file_to_group}\pysiglinewithargsret{int \bfcode{sysfs\_add\_file\_to\_group}}{struct kobject *\emph{ kobj}, const struct attribute *\emph{ attr}, const char *\emph{ group}}{}
add an attribute file to a pre-existing group.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
object we're acting for.

\item[{\code{const struct attribute * attr}}] \leavevmode
attribute descriptor.

\item[{\code{const char * group}}] \leavevmode
group name.

\end{description}
\index{sysfs\_chmod\_file (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sysfs_chmod_file}\pysiglinewithargsret{int \bfcode{sysfs\_chmod\_file}}{struct kobject *\emph{ kobj}, const struct attribute *\emph{ attr}, umode\_t\emph{ mode}}{}
update the modified mode value on an object attribute.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
object we're acting for.

\item[{\code{const struct attribute * attr}}] \leavevmode
attribute descriptor.

\item[{\code{umode\_t mode}}] \leavevmode
file permissions.

\end{description}
\index{sysfs\_remove\_file\_ns (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sysfs_remove_file_ns}\pysiglinewithargsret{void \bfcode{sysfs\_remove\_file\_ns}}{struct kobject *\emph{ kobj}, const struct attribute *\emph{ attr}, const void *\emph{ ns}}{}
remove an object attribute with a custom ns tag

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
object we're acting for

\item[{\code{const struct attribute * attr}}] \leavevmode
attribute descriptor

\item[{\code{const void * ns}}] \leavevmode
namespace tag of the file to remove

\end{description}

\textbf{Description}

Hash the attribute name and namespace tag and kill the victim.
\index{sysfs\_remove\_file\_from\_group (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sysfs_remove_file_from_group}\pysiglinewithargsret{void \bfcode{sysfs\_remove\_file\_from\_group}}{struct kobject *\emph{ kobj}, const struct attribute *\emph{ attr}, const char *\emph{ group}}{}
remove an attribute file from a group.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
object we're acting for.

\item[{\code{const struct attribute * attr}}] \leavevmode
attribute descriptor.

\item[{\code{const char * group}}] \leavevmode
group name.

\end{description}
\index{sysfs\_create\_bin\_file (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sysfs_create_bin_file}\pysiglinewithargsret{int \bfcode{sysfs\_create\_bin\_file}}{struct kobject *\emph{ kobj}, const struct bin\_attribute *\emph{ attr}}{}
create binary file for object.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
object.

\item[{\code{const struct bin\_attribute * attr}}] \leavevmode
attribute descriptor.

\end{description}
\index{sysfs\_remove\_bin\_file (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sysfs_remove_bin_file}\pysiglinewithargsret{void \bfcode{sysfs\_remove\_bin\_file}}{struct kobject *\emph{ kobj}, const struct bin\_attribute *\emph{ attr}}{}
remove binary file for object.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
object.

\item[{\code{const struct bin\_attribute * attr}}] \leavevmode
attribute descriptor.

\end{description}
\index{sysfs\_create\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sysfs_create_link}\pysiglinewithargsret{int \bfcode{sysfs\_create\_link}}{struct kobject *\emph{ kobj}, struct kobject *\emph{ target}, const char *\emph{ name}}{}
create symlink between two objects.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
object whose directory we're creating the link in.

\item[{\code{struct kobject * target}}] \leavevmode
object we're pointing to.

\item[{\code{const char * name}}] \leavevmode
name of the symlink.

\end{description}
\index{sysfs\_remove\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sysfs_remove_link}\pysiglinewithargsret{void \bfcode{sysfs\_remove\_link}}{struct kobject *\emph{ kobj}, const char *\emph{ name}}{}
remove symlink in object's directory.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
object we're acting for.

\item[{\code{const char * name}}] \leavevmode
name of the symlink to remove.

\end{description}
\index{sysfs\_rename\_link\_ns (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.sysfs_rename_link_ns}\pysiglinewithargsret{int \bfcode{sysfs\_rename\_link\_ns}}{struct kobject *\emph{ kobj}, struct kobject *\emph{ targ}, const char *\emph{ old}, const char *\emph{ new}, const void *\emph{ new\_ns}}{}
rename symlink in object's directory.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
object we're acting for.

\item[{\code{struct kobject * targ}}] \leavevmode
object we're pointing to.

\item[{\code{const char * old}}] \leavevmode
previous name of the symlink.

\item[{\code{const char * new}}] \leavevmode
new name of the symlink.

\item[{\code{const void * new\_ns}}] \leavevmode
new namespace of the symlink.

\end{description}

\textbf{Description}
\begin{quote}

A helper function for the common rename symlink idiom.
\end{quote}


\chapter{The debugfs filesystem}
\label{filesystems/index:the-debugfs-filesystem}

\section{debugfs interface}
\label{filesystems/index:debugfs-interface}\index{debugfs\_lookup (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_lookup}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_lookup}}{const char *\emph{ name}, struct dentry *\emph{ parent}}{}
look up an existing debugfs file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to look up.

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry of the file.

\end{description}

\textbf{Description}

This function will return a pointer to a dentry if it succeeds.  If the file
doesn't exist or an error occurs, \code{NULL} will be returned.  The returned
dentry must be passed to \code{dput()} when it is no longer needed.

If debugfs is not enabled in the kernel, the value -\code{ENODEV} will be
returned.
\index{debugfs\_create\_file (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_file}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_file}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, void *\emph{ data}, const struct file\_operations *\emph{ fops}}{}
create a file in the debugfs filesystem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have.

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{void * data}}] \leavevmode
a pointer to something that the caller will want to get to later
on.  The inode.i\_private pointer will point to this value on
the \code{open()} call.

\item[{\code{const struct file\_operations * fops}}] \leavevmode
a pointer to a struct file\_operations that should be used for
this file.

\end{description}

\textbf{Description}

This is the basic ``create a file'' function for debugfs.  It allows for a
wide range of flexibility in creating a file, or a directory (if you want
to create a directory, the {\hyperref[filesystems/index:c.debugfs_create_dir]{\emph{\code{debugfs\_create\_dir()}}}} function is
recommended to be used instead.)

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the {\hyperref[filesystems/index:c.debugfs_remove]{\emph{\code{debugfs\_remove()}}}} function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, \code{NULL} will be returned.

If debugfs is not enabled in the kernel, the value -\code{ENODEV} will be
returned.
\index{debugfs\_create\_file\_unsafe (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_file_unsafe}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_file\_unsafe}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, void *\emph{ data}, const struct file\_operations *\emph{ fops}}{}
create a file in the debugfs filesystem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have.

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{void * data}}] \leavevmode
a pointer to something that the caller will want to get to later
on.  The inode.i\_private pointer will point to this value on
the \code{open()} call.

\item[{\code{const struct file\_operations * fops}}] \leavevmode
a pointer to a struct file\_operations that should be used for
this file.

\end{description}

\textbf{Description}

{\hyperref[filesystems/index:c.debugfs_create_file_unsafe]{\emph{\code{debugfs\_create\_file\_unsafe()}}}} is completely analogous to
{\hyperref[filesystems/index:c.debugfs_create_file]{\emph{\code{debugfs\_create\_file()}}}}, the only difference being that the fops
handed it will not get protected against file removals by the
debugfs core.

It is your responsibility to protect your struct file\_operation
methods against file removals by means of \code{debugfs\_use\_file\_start()}
and \code{debugfs\_use\_file\_finish()}. -\textgreater{}:c:func:\emph{open()} is still protected by
debugfs though.

Any struct file\_operations defined by means of
\code{DEFINE\_DEBUGFS\_ATTRIBUTE()} is protected against file removals and
thus, may be used here.
\index{debugfs\_create\_file\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_file_size}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_file\_size}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, void *\emph{ data}, const struct file\_operations *\emph{ fops}, loff\_t\emph{ file\_size}}{}
create a file in the debugfs filesystem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have.

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{void * data}}] \leavevmode
a pointer to something that the caller will want to get to later
on.  The inode.i\_private pointer will point to this value on
the \code{open()} call.

\item[{\code{const struct file\_operations * fops}}] \leavevmode
a pointer to a struct file\_operations that should be used for
this file.

\item[{\code{loff\_t file\_size}}] \leavevmode
initial file size

\end{description}

\textbf{Description}

This is the basic ``create a file'' function for debugfs.  It allows for a
wide range of flexibility in creating a file, or a directory (if you want
to create a directory, the {\hyperref[filesystems/index:c.debugfs_create_dir]{\emph{\code{debugfs\_create\_dir()}}}} function is
recommended to be used instead.)

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the {\hyperref[filesystems/index:c.debugfs_remove]{\emph{\code{debugfs\_remove()}}}} function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, \code{NULL} will be returned.

If debugfs is not enabled in the kernel, the value -\code{ENODEV} will be
returned.
\index{debugfs\_create\_dir (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_dir}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_dir}}{const char *\emph{ name}, struct dentry *\emph{ parent}}{}
create a directory in the debugfs filesystem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the directory to
create.

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
directory will be created in the root of the debugfs filesystem.

\end{description}

\textbf{Description}

This function creates a directory in debugfs with the given name.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the {\hyperref[filesystems/index:c.debugfs_remove]{\emph{\code{debugfs\_remove()}}}} function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, \code{NULL} will be returned.

If debugfs is not enabled in the kernel, the value -\code{ENODEV} will be
returned.
\index{debugfs\_create\_automount (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_automount}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_automount}}{const char *\emph{ name}, struct dentry *\emph{ parent}, debugfs\_automount\_t\emph{ f}, void *\emph{ data}}{}
create automount point in the debugfs filesystem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{debugfs\_automount\_t f}}] \leavevmode
function to be called when pathname resolution steps on that one.

\item[{\code{void * data}}] \leavevmode
opaque argument to pass to \code{f()}.

\end{description}

\textbf{Description}

\textbf{f} should return what -\textgreater{}:c:func:\emph{d\_automount()} would.
\index{debugfs\_create\_symlink (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_symlink}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_symlink}}{const char *\emph{ name}, struct dentry *\emph{ parent}, const char *\emph{ target}}{}
create a symbolic link in the debugfs filesystem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the symbolic link to
create.

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this symbolic link.  This
should be a directory dentry if set.  If this parameter is NULL,
then the symbolic link will be created in the root of the debugfs
filesystem.

\item[{\code{const char * target}}] \leavevmode
a pointer to a string containing the path to the target of the
symbolic link.

\end{description}

\textbf{Description}

This function creates a symbolic link with the given name in debugfs that
links to the given target path.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the {\hyperref[filesystems/index:c.debugfs_remove]{\emph{\code{debugfs\_remove()}}}} function when the symbolic
link is to be removed (no automatic cleanup happens if your module is
unloaded, you are responsible here.)  If an error occurs, \code{NULL} will be
returned.

If debugfs is not enabled in the kernel, the value -\code{ENODEV} will be
returned.
\index{debugfs\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_remove}\pysiglinewithargsret{void \bfcode{debugfs\_remove}}{struct dentry *\emph{ dentry}}{}
removes a file or directory from the debugfs filesystem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * dentry}}] \leavevmode
a pointer to a the dentry of the file or directory to be
removed.  If this parameter is NULL or an error value, nothing
will be done.

\end{description}

\textbf{Description}

This function removes a file or directory in debugfs that was previously
created with a call to another debugfs function (like
{\hyperref[filesystems/index:c.debugfs_create_file]{\emph{\code{debugfs\_create\_file()}}}} or variants thereof.)

This function is required to be called in order for the file to be
removed, no automatic cleanup of files will happen when a module is
removed, you are responsible here.
\index{debugfs\_remove\_recursive (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_remove_recursive}\pysiglinewithargsret{void \bfcode{debugfs\_remove\_recursive}}{struct dentry *\emph{ dentry}}{}
recursively removes a directory

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * dentry}}] \leavevmode
a pointer to a the dentry of the directory to be removed.  If this
parameter is NULL or an error value, nothing will be done.

\end{description}

\textbf{Description}

This function recursively removes a directory tree in debugfs that
was previously created with a call to another debugfs function
(like {\hyperref[filesystems/index:c.debugfs_create_file]{\emph{\code{debugfs\_create\_file()}}}} or variants thereof.)

This function is required to be called in order for the file to be
removed, no automatic cleanup of files will happen when a module is
removed, you are responsible here.
\index{debugfs\_rename (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_rename}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_rename}}{struct dentry *\emph{ old\_dir}, struct dentry *\emph{ old\_dentry}, struct dentry *\emph{ new\_dir}, const char *\emph{ new\_name}}{}
rename a file/directory in the debugfs filesystem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * old\_dir}}] \leavevmode
a pointer to the parent dentry for the renamed object. This
should be a directory dentry.

\item[{\code{struct dentry * old\_dentry}}] \leavevmode
dentry of an object to be renamed.

\item[{\code{struct dentry * new\_dir}}] \leavevmode
a pointer to the parent dentry where the object should be
moved. This should be a directory dentry.

\item[{\code{const char * new\_name}}] \leavevmode
a pointer to a string containing the target name.

\end{description}

\textbf{Description}

This function renames a file/directory in debugfs.  The target must not
exist for rename to succeed.

This function will return a pointer to old\_dentry (which is updated to
reflect renaming) if it succeeds. If an error occurs, \code{NULL} will be
returned.

If debugfs is not enabled in the kernel, the value -\code{ENODEV} will be
returned.
\index{debugfs\_initialized (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_initialized}\pysiglinewithargsret{bool \bfcode{debugfs\_initialized}}{void}{}
Tells whether debugfs has been registered

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}
\index{debugfs\_file\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_file_get}\pysiglinewithargsret{int \bfcode{debugfs\_file\_get}}{struct dentry *\emph{ dentry}}{}
mark the beginning of file data access

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * dentry}}] \leavevmode
the dentry object whose data is being accessed.

\end{description}

\textbf{Description}

Up to a matching call to {\hyperref[filesystems/index:c.debugfs_file_put]{\emph{\code{debugfs\_file\_put()}}}}, any successive call
into the file removing functions {\hyperref[filesystems/index:c.debugfs_remove]{\emph{\code{debugfs\_remove()}}}} and
{\hyperref[filesystems/index:c.debugfs_remove_recursive]{\emph{\code{debugfs\_remove\_recursive()}}}} will block. Since associated private
file data may only get freed after a successful return of any of
the removal functions, you may safely access it after a successful
call to {\hyperref[filesystems/index:c.debugfs_file_get]{\emph{\code{debugfs\_file\_get()}}}} without worrying about lifetime issues.

If -\code{EIO} is returned, the file has already been removed and thus,
it is not safe to access any of its data. If, on the other hand,
it is allowed to access the file data, zero is returned.
\index{debugfs\_file\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_file_put}\pysiglinewithargsret{void \bfcode{debugfs\_file\_put}}{struct dentry *\emph{ dentry}}{}
mark the end of file data access

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * dentry}}] \leavevmode
the dentry object formerly passed to
{\hyperref[filesystems/index:c.debugfs_file_get]{\emph{\code{debugfs\_file\_get()}}}}.

\end{description}

\textbf{Description}

Allow any ongoing concurrent call into {\hyperref[filesystems/index:c.debugfs_remove]{\emph{\code{debugfs\_remove()}}}} or
{\hyperref[filesystems/index:c.debugfs_remove_recursive]{\emph{\code{debugfs\_remove\_recursive()}}}} blocked by a former call to
{\hyperref[filesystems/index:c.debugfs_file_get]{\emph{\code{debugfs\_file\_get()}}}} to proceed and return to its caller.
\index{debugfs\_create\_u8 (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_u8}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_u8}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, u8 *\emph{ value}}{}
create a debugfs file that is used to read and write an unsigned 8-bit value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is \code{NULL}, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{u8 * value}}] \leavevmode
a pointer to the variable that the file should read to and write
from.

\end{description}

\textbf{Description}

This function creates a file in debugfs with the given name that
contains the value of the variable \textbf{value}.  If the \textbf{mode} variable is so
set, it can be read from, and written to.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the {\hyperref[filesystems/index:c.debugfs_remove]{\emph{\code{debugfs\_remove()}}}} function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, \code{NULL} will be returned.

If debugfs is not enabled in the kernel, the value -\code{ENODEV} will be
returned.  It is not wise to check for this value, but rather, check for
\code{NULL} or !{}`{}`NULL{}`{}` instead as to eliminate the need for \#ifdef in the calling
code.
\index{debugfs\_create\_u16 (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_u16}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_u16}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, u16 *\emph{ value}}{}
create a debugfs file that is used to read and write an unsigned 16-bit value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is \code{NULL}, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{u16 * value}}] \leavevmode
a pointer to the variable that the file should read to and write
from.

\end{description}

\textbf{Description}

This function creates a file in debugfs with the given name that
contains the value of the variable \textbf{value}.  If the \textbf{mode} variable is so
set, it can be read from, and written to.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the {\hyperref[filesystems/index:c.debugfs_remove]{\emph{\code{debugfs\_remove()}}}} function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, \code{NULL} will be returned.

If debugfs is not enabled in the kernel, the value -\code{ENODEV} will be
returned.  It is not wise to check for this value, but rather, check for
\code{NULL} or !{}`{}`NULL{}`{}` instead as to eliminate the need for \#ifdef in the calling
code.
\index{debugfs\_create\_u32 (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_u32}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_u32}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, u32 *\emph{ value}}{}
create a debugfs file that is used to read and write an unsigned 32-bit value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is \code{NULL}, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{u32 * value}}] \leavevmode
a pointer to the variable that the file should read to and write
from.

\end{description}

\textbf{Description}

This function creates a file in debugfs with the given name that
contains the value of the variable \textbf{value}.  If the \textbf{mode} variable is so
set, it can be read from, and written to.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the {\hyperref[filesystems/index:c.debugfs_remove]{\emph{\code{debugfs\_remove()}}}} function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, \code{NULL} will be returned.

If debugfs is not enabled in the kernel, the value -\code{ENODEV} will be
returned.  It is not wise to check for this value, but rather, check for
\code{NULL} or !{}`{}`NULL{}`{}` instead as to eliminate the need for \#ifdef in the calling
code.
\index{debugfs\_create\_u64 (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_u64}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_u64}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, u64 *\emph{ value}}{}
create a debugfs file that is used to read and write an unsigned 64-bit value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is \code{NULL}, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{u64 * value}}] \leavevmode
a pointer to the variable that the file should read to and write
from.

\end{description}

\textbf{Description}

This function creates a file in debugfs with the given name that
contains the value of the variable \textbf{value}.  If the \textbf{mode} variable is so
set, it can be read from, and written to.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the {\hyperref[filesystems/index:c.debugfs_remove]{\emph{\code{debugfs\_remove()}}}} function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, \code{NULL} will be returned.

If debugfs is not enabled in the kernel, the value -\code{ENODEV} will be
returned.  It is not wise to check for this value, but rather, check for
\code{NULL} or !{}`{}`NULL{}`{}` instead as to eliminate the need for \#ifdef in the calling
code.
\index{debugfs\_create\_ulong (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_ulong}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_ulong}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, unsigned long *\emph{ value}}{}
create a debugfs file that is used to read and write an unsigned long value.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is \code{NULL}, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{unsigned long * value}}] \leavevmode
a pointer to the variable that the file should read to and write
from.

\end{description}

\textbf{Description}

This function creates a file in debugfs with the given name that
contains the value of the variable \textbf{value}.  If the \textbf{mode} variable is so
set, it can be read from, and written to.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the {\hyperref[filesystems/index:c.debugfs_remove]{\emph{\code{debugfs\_remove()}}}} function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, \code{NULL} will be returned.

If debugfs is not enabled in the kernel, the value -\code{ENODEV} will be
returned.  It is not wise to check for this value, but rather, check for
\code{NULL} or !{}`{}`NULL{}`{}` instead as to eliminate the need for \#ifdef in the calling
code.
\index{debugfs\_create\_x8 (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_x8}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_x8}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, u8 *\emph{ value}}{}
create a debugfs file that is used to read and write an unsigned 8-bit value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is \code{NULL}, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{u8 * value}}] \leavevmode
a pointer to the variable that the file should read to and write
from.

\end{description}
\index{debugfs\_create\_x16 (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_x16}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_x16}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, u16 *\emph{ value}}{}
create a debugfs file that is used to read and write an unsigned 16-bit value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is \code{NULL}, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{u16 * value}}] \leavevmode
a pointer to the variable that the file should read to and write
from.

\end{description}
\index{debugfs\_create\_x32 (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_x32}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_x32}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, u32 *\emph{ value}}{}
create a debugfs file that is used to read and write an unsigned 32-bit value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is \code{NULL}, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{u32 * value}}] \leavevmode
a pointer to the variable that the file should read to and write
from.

\end{description}
\index{debugfs\_create\_x64 (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_x64}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_x64}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, u64 *\emph{ value}}{}
create a debugfs file that is used to read and write an unsigned 64-bit value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is \code{NULL}, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{u64 * value}}] \leavevmode
a pointer to the variable that the file should read to and write
from.

\end{description}
\index{debugfs\_create\_size\_t (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_size_t}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_size\_t}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, size\_t *\emph{ value}}{}
create a debugfs file that is used to read and write an size\_t value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is \code{NULL}, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{size\_t * value}}] \leavevmode
a pointer to the variable that the file should read to and write
from.

\end{description}
\index{debugfs\_create\_atomic\_t (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_atomic_t}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_atomic\_t}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, atomic\_t *\emph{ value}}{}
create a debugfs file that is used to read and write an atomic\_t value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is \code{NULL}, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{atomic\_t * value}}] \leavevmode
a pointer to the variable that the file should read to and write
from.

\end{description}
\index{debugfs\_create\_bool (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_bool}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_bool}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, bool *\emph{ value}}{}
create a debugfs file that is used to read and write a boolean value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is \code{NULL}, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{bool * value}}] \leavevmode
a pointer to the variable that the file should read to and write
from.

\end{description}

\textbf{Description}

This function creates a file in debugfs with the given name that
contains the value of the variable \textbf{value}.  If the \textbf{mode} variable is so
set, it can be read from, and written to.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the {\hyperref[filesystems/index:c.debugfs_remove]{\emph{\code{debugfs\_remove()}}}} function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, \code{NULL} will be returned.

If debugfs is not enabled in the kernel, the value -\code{ENODEV} will be
returned.  It is not wise to check for this value, but rather, check for
\code{NULL} or !{}`{}`NULL{}`{}` instead as to eliminate the need for \#ifdef in the calling
code.
\index{debugfs\_create\_blob (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_blob}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_blob}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, struct debugfs\_blob\_wrapper *\emph{ blob}}{}
create a debugfs file that is used to read a binary blob

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is \code{NULL}, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{struct debugfs\_blob\_wrapper * blob}}] \leavevmode
a pointer to a struct debugfs\_blob\_wrapper which contains a pointer
to the blob data and the size of the data.

\end{description}

\textbf{Description}

This function creates a file in debugfs with the given name that exports
\textbf{blob}-\textgreater{}data as a binary blob. If the \textbf{mode} variable is so set it can be
read from. Writing is not supported.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the {\hyperref[filesystems/index:c.debugfs_remove]{\emph{\code{debugfs\_remove()}}}} function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, \code{NULL} will be returned.

If debugfs is not enabled in the kernel, the value -\code{ENODEV} will be
returned.  It is not wise to check for this value, but rather, check for
\code{NULL} or !{}`{}`NULL{}`{}` instead as to eliminate the need for \#ifdef in the calling
code.
\index{debugfs\_create\_u32\_array (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_u32_array}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_u32\_array}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, u32 *\emph{ array}, u32\emph{ elements}}{}
create a debugfs file that is used to read u32 array.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have.

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is \code{NULL}, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{u32 * array}}] \leavevmode
u32 array that provides data.

\item[{\code{u32 elements}}] \leavevmode
total number of elements in the array.

\end{description}

\textbf{Description}

This function creates a file in debugfs with the given name that exports
\textbf{array} as data. If the \textbf{mode} variable is so set it can be read from.
Writing is not supported. Seek within the file is also not supported.
Once array is created its size can not be changed.

The function returns a pointer to dentry on success. If debugfs is not
enabled in the kernel, the value -\code{ENODEV} will be returned.
\index{debugfs\_print\_regs32 (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_print_regs32}\pysiglinewithargsret{void \bfcode{debugfs\_print\_regs32}}{struct seq\_file *\emph{ s}, const struct debugfs\_reg32 *\emph{ regs}, int\emph{ nregs}, void \_\_iomem *\emph{ base}, char *\emph{ prefix}}{}
use seq\_print to describe a set of registers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct seq\_file * s}}] \leavevmode
the seq\_file structure being used to generate output

\item[{\code{const struct debugfs\_reg32 * regs}}] \leavevmode
an array if struct debugfs\_reg32 structures

\item[{\code{int nregs}}] \leavevmode
the length of the above array

\item[{\code{void \_\_iomem * base}}] \leavevmode
the base address to be used in reading the registers

\item[{\code{char * prefix}}] \leavevmode
a string to be prefixed to every output line

\end{description}

\textbf{Description}

This function outputs a text block describing the current values of
some 32-bit hardware registers. It is meant to be used within debugfs
files based on seq\_file that need to show registers, intermixed with other
information. The prefix argument may be used to specify a leading string,
because some peripherals have several blocks of identical registers,
for example configuration of dma channels
\index{debugfs\_create\_regset32 (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_regset32}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_regset32}}{const char *\emph{ name}, umode\_t\emph{ mode}, struct dentry *\emph{ parent}, struct debugfs\_regset32 *\emph{ regset}}{}
create a debugfs file that returns register values

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
a pointer to a string containing the name of the file to create.

\item[{\code{umode\_t mode}}] \leavevmode
the permission that the file should have

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is \code{NULL}, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{struct debugfs\_regset32 * regset}}] \leavevmode
a pointer to a struct debugfs\_regset32, which contains a pointer
to an array of register definitions, the array size and the base
address where the register bank is to be found.

\end{description}

\textbf{Description}

This function creates a file in debugfs with the given name that reports
the names and values of a set of 32-bit registers. If the \textbf{mode} variable
is so set it can be read from. Writing is not supported.

This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the {\hyperref[filesystems/index:c.debugfs_remove]{\emph{\code{debugfs\_remove()}}}} function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, \code{NULL} will be returned.

If debugfs is not enabled in the kernel, the value -\code{ENODEV} will be
returned.  It is not wise to check for this value, but rather, check for
\code{NULL} or !{}`{}`NULL{}`{}` instead as to eliminate the need for \#ifdef in the calling
code.
\index{debugfs\_create\_devm\_seqfile (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.debugfs_create_devm_seqfile}\pysiglinewithargsret{struct dentry * \bfcode{debugfs\_create\_devm\_seqfile}}{struct device *\emph{ dev}, const char *\emph{ name}, struct dentry *\emph{ parent}, int (*read\_fn) (struct seq\_file\emph{ *s}, void\emph{ *data}}{}
create a debugfs file that is bound to device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device related to this debugfs file.

\item[{\code{const char * name}}] \leavevmode
name of the debugfs file.

\item[{\code{struct dentry * parent}}] \leavevmode
a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is \code{NULL}, then the
file will be created in the root of the debugfs filesystem.

\item[{\code{int (*)(struct seq\_file *s, void *data) read\_fn}}] \leavevmode
function pointer called to print the seq\_file content.

\end{description}


\chapter{The Linux Journalling API}
\label{filesystems/index:the-linux-journalling-api}

\section{Overview}
\label{filesystems/index:overview}

\subsection{Details}
\label{filesystems/index:details}
The journalling layer is easy to use. You need to first of all create a
journal\_t data structure. There are two calls to do this dependent on
how you decide to allocate the physical media on which the journal
resides. The {\hyperref[filesystems/index:c.jbd2_journal_init_inode]{\emph{\code{jbd2\_journal\_init\_inode()}}}} call is for journals stored in
filesystem inodes, or the {\hyperref[filesystems/index:c.jbd2_journal_init_dev]{\emph{\code{jbd2\_journal\_init\_dev()}}}} call can be used
for journal stored on a raw device (in a continuous range of blocks). A
journal\_t is a typedef for a struct pointer, so when you are finally
finished make sure you call {\hyperref[filesystems/index:c.jbd2_journal_destroy]{\emph{\code{jbd2\_journal\_destroy()}}}} on it to free up
any used kernel memory.

Once you have got your journal\_t object you need to `mount' or load the
journal file. The journalling layer expects the space for the journal
was already allocated and initialized properly by the userspace tools.
When loading the journal you must call {\hyperref[filesystems/index:c.jbd2_journal_load]{\emph{\code{jbd2\_journal\_load()}}}} to process
journal contents. If the client file system detects the journal contents
does not need to be processed (or even need not have valid contents), it
may call {\hyperref[filesystems/index:c.jbd2_journal_wipe]{\emph{\code{jbd2\_journal\_wipe()}}}} to clear the journal contents before
calling {\hyperref[filesystems/index:c.jbd2_journal_load]{\emph{\code{jbd2\_journal\_load()}}}}.

Note that jbd2\_journal\_wipe(..,0) calls
{\hyperref[filesystems/index:c.jbd2_journal_skip_recovery]{\emph{\code{jbd2\_journal\_skip\_recovery()}}}} for you if it detects any outstanding
transactions in the journal and similarly {\hyperref[filesystems/index:c.jbd2_journal_load]{\emph{\code{jbd2\_journal\_load()}}}} will
call {\hyperref[filesystems/index:c.jbd2_journal_recover]{\emph{\code{jbd2\_journal\_recover()}}}} if necessary. I would advise reading
\code{ext4\_load\_journal()} in fs/ext4/super.c for examples on this stage.

Now you can go ahead and start modifying the underlying filesystem.
Almost.

You still need to actually journal your filesystem changes, this is done
by wrapping them into transactions. Additionally you also need to wrap
the modification of each of the buffers with calls to the journal layer,
so it knows what the modifications you are actually making are. To do
this use {\hyperref[filesystems/index:c.jbd2_journal_start]{\emph{\code{jbd2\_journal\_start()}}}} which returns a transaction handle.

{\hyperref[filesystems/index:c.jbd2_journal_start]{\emph{\code{jbd2\_journal\_start()}}}} and its counterpart {\hyperref[filesystems/index:c.jbd2_journal_stop]{\emph{\code{jbd2\_journal\_stop()}}}},
which indicates the end of a transaction are nestable calls, so you can
reenter a transaction if necessary, but remember you must call
{\hyperref[filesystems/index:c.jbd2_journal_stop]{\emph{\code{jbd2\_journal\_stop()}}}} the same number of times as
{\hyperref[filesystems/index:c.jbd2_journal_start]{\emph{\code{jbd2\_journal\_start()}}}} before the transaction is completed (or more
accurately leaves the update phase). Ext4/VFS makes use of this feature to
simplify handling of inode dirtying, quota support, etc.

Inside each transaction you need to wrap the modifications to the
individual buffers (blocks). Before you start to modify a buffer you
need to call {\hyperref[filesystems/index:c.jbd2_journal_get_create_access]{\emph{\code{jbd2\_journal\_get\_create\_access()}}}} /
{\hyperref[filesystems/index:c.jbd2_journal_get_write_access]{\emph{\code{jbd2\_journal\_get\_write\_access()}}}} /
{\hyperref[filesystems/index:c.jbd2_journal_get_undo_access]{\emph{\code{jbd2\_journal\_get\_undo\_access()}}}} as appropriate, this allows the
journalling layer to copy the unmodified
data if it needs to. After all the buffer may be part of a previously
uncommitted transaction. At this point you are at last ready to modify a
buffer, and once you are have done so you need to call
{\hyperref[filesystems/index:c.jbd2_journal_dirty_metadata]{\emph{\code{jbd2\_journal\_dirty\_metadata()}}}}. Or if you've asked for access to a
buffer you now know is now longer required to be pushed back on the
device you can call {\hyperref[filesystems/index:c.jbd2_journal_forget]{\emph{\code{jbd2\_journal\_forget()}}}} in much the same way as you
might have used \code{bforget()} in the past.

A {\hyperref[filesystems/index:c.jbd2_journal_flush]{\emph{\code{jbd2\_journal\_flush()}}}} may be called at any time to commit and
checkpoint all your transactions.

Then at umount time , in your \code{put\_super()} you can then call
{\hyperref[filesystems/index:c.jbd2_journal_destroy]{\emph{\code{jbd2\_journal\_destroy()}}}} to clean up your in-core journal object.

Unfortunately there a couple of ways the journal layer can cause a
deadlock. The first thing to note is that each task can only have a
single outstanding transaction at any one time, remember nothing commits
until the outermost {\hyperref[filesystems/index:c.jbd2_journal_stop]{\emph{\code{jbd2\_journal\_stop()}}}}. This means you must complete
the transaction at the end of each file/inode/address etc. operation you
perform, so that the journalling system isn't re-entered on another
journal. Since transactions can't be nested/batched across differing
journals, and another filesystem other than yours (say ext4) may be
modified in a later syscall.

The second case to bear in mind is that {\hyperref[filesystems/index:c.jbd2_journal_start]{\emph{\code{jbd2\_journal\_start()}}}} can block
if there isn't enough space in the journal for your transaction (based
on the passed nblocks param) - when it blocks it merely(!) needs to wait
for transactions to complete and be committed from other tasks, so
essentially we are waiting for {\hyperref[filesystems/index:c.jbd2_journal_stop]{\emph{\code{jbd2\_journal\_stop()}}}}. So to avoid
deadlocks you must treat {\hyperref[filesystems/index:c.jbd2_journal_start]{\emph{\code{jbd2\_journal\_start()}}}} /
{\hyperref[filesystems/index:c.jbd2_journal_stop]{\emph{\code{jbd2\_journal\_stop()}}}} as if they were semaphores and include them in
your semaphore ordering rules to prevent
deadlocks. Note that {\hyperref[filesystems/index:c.jbd2_journal_extend]{\emph{\code{jbd2\_journal\_extend()}}}} has similar blocking
behaviour to {\hyperref[filesystems/index:c.jbd2_journal_start]{\emph{\code{jbd2\_journal\_start()}}}} so you can deadlock here just as
easily as on {\hyperref[filesystems/index:c.jbd2_journal_start]{\emph{\code{jbd2\_journal\_start()}}}}.

Try to reserve the right number of blocks the first time. ;-). This will
be the maximum number of blocks you are going to touch in this
transaction. I advise having a look at at least ext4\_jbd.h to see the
basis on which ext4 uses to make these decisions.

Another wriggle to watch out for is your on-disk block allocation
strategy. Why? Because, if you do a delete, you need to ensure you
haven't reused any of the freed blocks until the transaction freeing
these blocks commits. If you reused these blocks and crash happens,
there is no way to restore the contents of the reallocated blocks at the
end of the last fully committed transaction. One simple way of doing
this is to mark blocks as free in internal in-memory block allocation
structures only after the transaction freeing them commits. Ext4 uses
journal commit callback for this purpose.

With journal commit callbacks you can ask the journalling layer to call
a callback function when the transaction is finally committed to disk,
so that you can do some of your own management. You ask the journalling
layer for calling the callback by simply setting
\code{journal-\textgreater{}j\_commit\_callback} function pointer and that function is
called after each transaction commit. You can also use
\code{transaction-\textgreater{}t\_private\_list} for attaching entries to a transaction
that need processing when the transaction commits.

JBD2 also provides a way to block all transaction updates via
{\hyperref[filesystems/index:c.jbd2_journal_lock_updates]{\emph{\code{jbd2\_journal\_lock\_updates()}}}} /
{\hyperref[filesystems/index:c.jbd2_journal_unlock_updates]{\emph{\code{jbd2\_journal\_unlock\_updates()}}}}. Ext4 uses this when it wants a
window with a clean and stable fs for a moment. E.g.

\begin{Verbatim}[commandchars=\\\{\}]
jbd2\PYGZus{}journal\PYGZus{}lock\PYGZus{}updates() //stop new stuff happening..
jbd2\PYGZus{}journal\PYGZus{}flush()        // checkpoint everything.
..do stuff on stable fs
jbd2\PYGZus{}journal\PYGZus{}unlock\PYGZus{}updates() // carry on with filesystem use.
\end{Verbatim}

The opportunities for abuse and DOS attacks with this should be obvious,
if you allow unprivileged userspace to trigger codepaths containing
these calls.


\subsection{Summary}
\label{filesystems/index:summary}
Using the journal is a matter of wrapping the different context changes,
being each mount, each modification (transaction) and each changed
buffer to tell the journalling layer about them.


\section{Data Types}
\label{filesystems/index:data-types}
The journalling layer uses typedefs to `hide' the concrete definitions
of the structures used. As a client of the JBD2 layer you can just rely
on the using the pointer as a magic cookie of some sort. Obviously the
hiding is not enforced as this is `C'.


\subsection{Structures}
\label{filesystems/index:structures}\index{handle\_t (C type)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.handle_t}\pysigline{typedef \bfcode{handle\_t}}
The handle\_t type represents a single atomic update being performed by some process.

\end{fulllineitems}


\textbf{Description}

All filesystem modifications made by the process go
through this handle.  Recursive operations (such as quota operations)
are gathered into a single update.

The buffer credits field is used to account for journaled buffers
being modified by the running process.  To ensure that there is
enough log space for all outstanding operations, we need to limit the
number of outstanding buffers possible at any time.  When the
operation completes, any buffer credits not used are credited back to
the transaction, so that at all times we know how many buffers the
outstanding updates on a transaction might possibly touch.

This is an opaque datatype.
\index{journal\_t (C type)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.journal_t}\pysigline{typedef \bfcode{journal\_t}}
The journal\_t maintains all of the journaling state information for a single filesystem.

\end{fulllineitems}


\textbf{Description}

journal\_t is linked to from the fs superblock structure.

We use the journal\_t to keep track of all outstanding transaction
activity on the filesystem, and to manage the state of the log
writing process.

This is an opaque datatype.
\index{jbd2\_inode (C type)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_inode}\pysigline{struct \bfcode{jbd2\_inode}}
The jbd\_inode type is the structure linking inodes in ordered mode present in a transaction so that we can sync them during commit.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct jbd2\PYGZus{}inode \PYGZob{}
  transaction\PYGZus{}t *i\PYGZus{}transaction;
  transaction\PYGZus{}t *i\PYGZus{}next\PYGZus{}transaction;
  struct list\PYGZus{}head i\PYGZus{}list;
  struct inode *i\PYGZus{}vfs\PYGZus{}inode;
  unsigned long i\PYGZus{}flags;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{i\_transaction}}] \leavevmode
Which transaction does this inode belong to? Either the running
transaction or the committing one. {[}j\_list\_lock{]}

\item[{\code{i\_next\_transaction}}] \leavevmode
Pointer to the running transaction modifying inode's data in case
there is already a committing transaction touching it. {[}j\_list\_lock{]}

\item[{\code{i\_list}}] \leavevmode
List of inodes in the i\_transaction {[}j\_list\_lock{]}

\item[{\code{i\_vfs\_inode}}] \leavevmode
VFS inode this inode belongs to {[}constant for lifetime of structure{]}

\item[{\code{i\_flags}}] \leavevmode
Flags of inode {[}j\_list\_lock{]}

\end{description}
\index{jbd2\_journal\_handle (C type)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_handle}\pysigline{struct \bfcode{jbd2\_journal\_handle}}
The handle\_s type is the concrete type associated with handle\_t.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct jbd2\PYGZus{}journal\PYGZus{}handle \PYGZob{}
  union \PYGZob{}
    transaction\PYGZus{}t *h\PYGZus{}transaction;
    journal\PYGZus{}t *h\PYGZus{}journal;
  \PYGZcb{};
  handle\PYGZus{}t *h\PYGZus{}rsv\PYGZus{}handle;
  int h\PYGZus{}buffer\PYGZus{}credits;
  int h\PYGZus{}ref;
  int h\PYGZus{}err;
  unsigned int    h\PYGZus{}sync:         1;
  unsigned int    h\PYGZus{}jdata:        1;
  unsigned int    h\PYGZus{}reserved:     1;
  unsigned int    h\PYGZus{}aborted:      1;
  unsigned int    h\PYGZus{}type:         8;
  unsigned int    h\PYGZus{}line\PYGZus{}no:      16;
  unsigned long           h\PYGZus{}start\PYGZus{}jiffies;
  unsigned int            h\PYGZus{}requested\PYGZus{}credits;
  unsigned int            saved\PYGZus{}alloc\PYGZus{}context;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{h\_transaction}}] \leavevmode
Which compound transaction is this update a part of?

\item[{\code{h\_journal}}] \leavevmode
Which journal handle belongs to - used iff h\_reserved set.

\item[{\code{h\_rsv\_handle}}] \leavevmode
Handle reserved for finishing the logical operation.

\item[{\code{h\_buffer\_credits}}] \leavevmode
Number of remaining buffers we are allowed to dirty.

\item[{\code{h\_ref}}] \leavevmode
Reference count on this handle.

\item[{\code{h\_err}}] \leavevmode
Field for caller's use to track errors through large fs operations.

\item[{\code{h\_sync}}] \leavevmode
Flag for sync-on-close.

\item[{\code{h\_jdata}}] \leavevmode
Flag to force data journaling.

\item[{\code{h\_reserved}}] \leavevmode
Flag for handle for reserved credits.

\item[{\code{h\_aborted}}] \leavevmode
Flag indicating fatal error on handle.

\item[{\code{h\_type}}] \leavevmode
For handle statistics.

\item[{\code{h\_line\_no}}] \leavevmode
For handle statistics.

\item[{\code{h\_start\_jiffies}}] \leavevmode
Handle Start time.

\item[{\code{h\_requested\_credits}}] \leavevmode
Holds \textbf{h\_buffer\_credits} after handle is started.

\item[{\code{saved\_alloc\_context}}] \leavevmode
Saved context while transaction is open.

\end{description}
\index{journal\_s (C type)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.journal_s}\pysigline{struct \bfcode{journal\_s}}
The journal\_s type is the concrete type associated with journal\_t.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct journal\PYGZus{}s \PYGZob{}
  unsigned long           j\PYGZus{}flags;
  int j\PYGZus{}errno;
  struct buffer\PYGZus{}head      *j\PYGZus{}sb\PYGZus{}buffer;
  journal\PYGZus{}superblock\PYGZus{}t *j\PYGZus{}superblock;
  int j\PYGZus{}format\PYGZus{}version;
  rwlock\PYGZus{}t j\PYGZus{}state\PYGZus{}lock;
  int j\PYGZus{}barrier\PYGZus{}count;
  struct mutex            j\PYGZus{}barrier;
  transaction\PYGZus{}t *j\PYGZus{}running\PYGZus{}transaction;
  transaction\PYGZus{}t *j\PYGZus{}committing\PYGZus{}transaction;
  transaction\PYGZus{}t *j\PYGZus{}checkpoint\PYGZus{}transactions;
  wait\PYGZus{}queue\PYGZus{}head\PYGZus{}t j\PYGZus{}wait\PYGZus{}transaction\PYGZus{}locked;
  wait\PYGZus{}queue\PYGZus{}head\PYGZus{}t j\PYGZus{}wait\PYGZus{}done\PYGZus{}commit;
  wait\PYGZus{}queue\PYGZus{}head\PYGZus{}t j\PYGZus{}wait\PYGZus{}commit;
  wait\PYGZus{}queue\PYGZus{}head\PYGZus{}t j\PYGZus{}wait\PYGZus{}updates;
  wait\PYGZus{}queue\PYGZus{}head\PYGZus{}t j\PYGZus{}wait\PYGZus{}reserved;
  struct mutex            j\PYGZus{}checkpoint\PYGZus{}mutex;
  struct buffer\PYGZus{}head      *j\PYGZus{}chkpt\PYGZus{}bhs[JBD2\PYGZus{}NR\PYGZus{}BATCH];
  unsigned long           j\PYGZus{}head;
  unsigned long           j\PYGZus{}tail;
  unsigned long           j\PYGZus{}free;
  unsigned long           j\PYGZus{}first;
  unsigned long           j\PYGZus{}last;
  struct block\PYGZus{}device     *j\PYGZus{}dev;
  int j\PYGZus{}blocksize;
  unsigned long long      j\PYGZus{}blk\PYGZus{}offset;
  char j\PYGZus{}devname[BDEVNAME\PYGZus{}SIZE+24];
  struct block\PYGZus{}device     *j\PYGZus{}fs\PYGZus{}dev;
  unsigned int            j\PYGZus{}maxlen;
  atomic\PYGZus{}t j\PYGZus{}reserved\PYGZus{}credits;
  spinlock\PYGZus{}t j\PYGZus{}list\PYGZus{}lock;
  struct inode            *j\PYGZus{}inode;
  tid\PYGZus{}t j\PYGZus{}tail\PYGZus{}sequence;
  tid\PYGZus{}t j\PYGZus{}transaction\PYGZus{}sequence;
  tid\PYGZus{}t j\PYGZus{}commit\PYGZus{}sequence;
  tid\PYGZus{}t j\PYGZus{}commit\PYGZus{}request;
  \PYGZus{}\PYGZus{}u8 j\PYGZus{}uuid[16];
  struct task\PYGZus{}struct      *j\PYGZus{}task;
  int j\PYGZus{}max\PYGZus{}transaction\PYGZus{}buffers;
  unsigned long           j\PYGZus{}commit\PYGZus{}interval;
  struct timer\PYGZus{}list       j\PYGZus{}commit\PYGZus{}timer;
  spinlock\PYGZus{}t j\PYGZus{}revoke\PYGZus{}lock;
  struct jbd2\PYGZus{}revoke\PYGZus{}table\PYGZus{}s *j\PYGZus{}revoke;
  struct jbd2\PYGZus{}revoke\PYGZus{}table\PYGZus{}s *j\PYGZus{}revoke\PYGZus{}table[2];
  struct buffer\PYGZus{}head      **j\PYGZus{}wbuf;
  int j\PYGZus{}wbufsize;
  pid\PYGZus{}t j\PYGZus{}last\PYGZus{}sync\PYGZus{}writer;
  u64 j\PYGZus{}average\PYGZus{}commit\PYGZus{}time;
  u32 j\PYGZus{}min\PYGZus{}batch\PYGZus{}time;
  u32 j\PYGZus{}max\PYGZus{}batch\PYGZus{}time;
  void (*j\PYGZus{}commit\PYGZus{}callback)(journal\PYGZus{}t *, transaction\PYGZus{}t *);
  spinlock\PYGZus{}t j\PYGZus{}history\PYGZus{}lock;
  struct proc\PYGZus{}dir\PYGZus{}entry   *j\PYGZus{}proc\PYGZus{}entry;
  struct transaction\PYGZus{}stats\PYGZus{}s j\PYGZus{}stats;
  unsigned int            j\PYGZus{}failed\PYGZus{}commit;
  void *j\PYGZus{}private;
  struct crypto\PYGZus{}shash *j\PYGZus{}chksum\PYGZus{}driver;
  \PYGZus{}\PYGZus{}u32 j\PYGZus{}csum\PYGZus{}seed;
\PYGZsh{}ifdef CONFIG\PYGZus{}DEBUG\PYGZus{}LOCK\PYGZus{}ALLOC;
  struct lockdep\PYGZus{}map      j\PYGZus{}trans\PYGZus{}commit\PYGZus{}map;
\PYGZsh{}endif;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{j\_flags}}] \leavevmode
General journaling state flags {[}j\_state\_lock{]}

\item[{\code{j\_errno}}] \leavevmode
Is there an outstanding uncleared error on the journal (from a prior
abort)? {[}j\_state\_lock{]}

\item[{\code{j\_sb\_buffer}}] \leavevmode
The first part of the superblock buffer.

\item[{\code{j\_superblock}}] \leavevmode
The second part of the superblock buffer.

\item[{\code{j\_format\_version}}] \leavevmode
Version of the superblock format.

\item[{\code{j\_state\_lock}}] \leavevmode
Protect the various scalars in the journal.

\item[{\code{j\_barrier\_count}}] \leavevmode
Number of processes waiting to create a barrier lock {[}j\_state\_lock{]}

\item[{\code{j\_barrier}}] \leavevmode
The barrier lock itself.

\item[{\code{j\_running\_transaction}}] \leavevmode
Transactions: The current running transaction...
{[}j\_state\_lock{]} {[}caller holding open handle{]}

\item[{\code{j\_committing\_transaction}}] \leavevmode
the transaction we are pushing to disk
{[}j\_state\_lock{]} {[}caller holding open handle{]}

\item[{\code{j\_checkpoint\_transactions}}] \leavevmode
... and a linked circular list of all transactions waiting for
checkpointing. {[}j\_list\_lock{]}

\item[{\code{j\_wait\_transaction\_locked}}] \leavevmode
Wait queue for waiting for a locked transaction to start committing,
or for a barrier lock to be released.

\item[{\code{j\_wait\_done\_commit}}] \leavevmode
Wait queue for waiting for commit to complete.

\item[{\code{j\_wait\_commit}}] \leavevmode
Wait queue to trigger commit.

\item[{\code{j\_wait\_updates}}] \leavevmode
Wait queue to wait for updates to complete.

\item[{\code{j\_wait\_reserved}}] \leavevmode
Wait queue to wait for reserved buffer credits to drop.

\item[{\code{j\_checkpoint\_mutex}}] \leavevmode
Semaphore for locking against concurrent checkpoints.

\item[{\code{j\_chkpt\_bhs}}] \leavevmode
List of buffer heads used by the checkpoint routine.  This
was moved from \code{jbd2\_log\_do\_checkpoint()} to reduce stack
usage.  Access to this array is controlled by the
\textbf{j\_checkpoint\_mutex}.  {[}j\_checkpoint\_mutex{]}

\item[{\code{j\_head}}] \leavevmode
Journal head: identifies the first unused block in the journal.
{[}j\_state\_lock{]}

\item[{\code{j\_tail}}] \leavevmode
Journal tail: identifies the oldest still-used block in the journal.
{[}j\_state\_lock{]}

\item[{\code{j\_free}}] \leavevmode
Journal free: how many free blocks are there in the journal?
{[}j\_state\_lock{]}

\item[{\code{j\_first}}] \leavevmode
The block number of the first usable block in the journal
{[}j\_state\_lock{]}.

\item[{\code{j\_last}}] \leavevmode
The block number one beyond the last usable block in the journal
{[}j\_state\_lock{]}.

\item[{\code{j\_dev}}] \leavevmode
Device where we store the journal.

\item[{\code{j\_blocksize}}] \leavevmode
Block size for the location where we store the journal.

\item[{\code{j\_blk\_offset}}] \leavevmode
Starting block offset into the device where we store the journal.

\item[{\code{j\_devname}}] \leavevmode
Journal device name.

\item[{\code{j\_fs\_dev}}] \leavevmode
Device which holds the client fs.  For internal journal this will be
equal to j\_dev.

\item[{\code{j\_maxlen}}] \leavevmode
Total maximum capacity of the journal region on disk.

\item[{\code{j\_reserved\_credits}}] \leavevmode
Number of buffers reserved from the running transaction.

\item[{\code{j\_list\_lock}}] \leavevmode
Protects the buffer lists and internal buffer state.

\item[{\code{j\_inode}}] \leavevmode
Optional inode where we store the journal.  If present, all
journal block numbers are mapped into this inode via {\hyperref[filesystems/index:c.bmap]{\emph{\code{bmap()}}}}.

\item[{\code{j\_tail\_sequence}}] \leavevmode
Sequence number of the oldest transaction in the log {[}j\_state\_lock{]}

\item[{\code{j\_transaction\_sequence}}] \leavevmode
Sequence number of the next transaction to grant {[}j\_state\_lock{]}

\item[{\code{j\_commit\_sequence}}] \leavevmode
Sequence number of the most recently committed transaction
{[}j\_state\_lock{]}.

\item[{\code{j\_commit\_request}}] \leavevmode
Sequence number of the most recent transaction wanting commit
{[}j\_state\_lock{]}

\item[{\code{j\_uuid}}] \leavevmode
Journal uuid: identifies the object (filesystem, LVM volume etc)
backed by this journal.  This will eventually be replaced by an array
of uuids, allowing us to index multiple devices within a single
journal and to perform atomic updates across them.

\item[{\code{j\_task}}] \leavevmode
Pointer to the current commit thread for this journal.

\item[{\code{j\_max\_transaction\_buffers}}] \leavevmode
Maximum number of metadata buffers to allow in a single compound
commit transaction.

\item[{\code{j\_commit\_interval}}] \leavevmode
What is the maximum transaction lifetime before we begin a commit?

\item[{\code{j\_commit\_timer}}] \leavevmode
The timer used to wakeup the commit thread.

\item[{\code{j\_revoke\_lock}}] \leavevmode
Protect the revoke table.

\item[{\code{j\_revoke}}] \leavevmode
The revoke table - maintains the list of revoked blocks in the
current transaction.

\item[{\code{j\_revoke\_table}}] \leavevmode
Alternate revoke tables for j\_revoke.

\item[{\code{j\_wbuf}}] \leavevmode
Array of bhs for jbd2\_journal\_commit\_transaction.

\item[{\code{j\_wbufsize}}] \leavevmode
Size of \textbf{j\_wbuf} array.

\item[{\code{j\_last\_sync\_writer}}] \leavevmode
The pid of the last person to run a synchronous operation
through the journal.

\item[{\code{j\_average\_commit\_time}}] \leavevmode
The average amount of time in nanoseconds it takes to commit a
transaction to disk. {[}j\_state\_lock{]}

\item[{\code{j\_min\_batch\_time}}] \leavevmode
Minimum time that we should wait for additional filesystem operations
to get batched into a synchronous handle in microseconds.

\item[{\code{j\_max\_batch\_time}}] \leavevmode
Maximum time that we should wait for additional filesystem operations
to get batched into a synchronous handle in microseconds.

\item[{\code{j\_commit\_callback}}] \leavevmode
This function is called when a transaction is closed.

\item[{\code{j\_history\_lock}}] \leavevmode
Protect the transactions statistics history.

\item[{\code{j\_proc\_entry}}] \leavevmode
procfs entry for the jbd statistics directory.

\item[{\code{j\_stats}}] \leavevmode
Overall statistics.

\item[{\code{j\_failed\_commit}}] \leavevmode
Failed journal commit ID.

\item[{\code{j\_private}}] \leavevmode
An opaque pointer to fs-private information.  ext3 puts its
superblock pointer here.

\item[{\code{j\_chksum\_driver}}] \leavevmode
Reference to checksum algorithm driver via cryptoapi.

\item[{\code{j\_csum\_seed}}] \leavevmode
Precomputed journal UUID checksum for seeding other checksums.

\item[{\code{j\_trans\_commit\_map}}] \leavevmode
Lockdep entity to track transaction commit dependencies. Handles
hold this ``lock'' for read, when we wait for commit, we acquire the
``lock'' for writing. This matches the properties of jbd2 journalling
where the running transaction has to wait for all handles to be
dropped to commit that transaction and also acquiring a handle may
require transaction commit to finish.

\end{description}


\section{Functions}
\label{filesystems/index:functions}
The functions here are split into two groups those that affect a journal
as a whole, and those which are used to manage transactions


\subsection{Journal Level}
\label{filesystems/index:journal-level}\index{jbd2\_journal\_force\_commit\_nested (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_force_commit_nested}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_force\_commit\_nested}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
journal to force
Returns true if progress was made.

\end{description}

\textbf{Description}

transaction.  This is used for forcing out undo-protected data which contains
bitmaps, when the fs is running out of space.
\index{jbd2\_journal\_force\_commit (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_force_commit}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_force\_commit}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}}{}
force any uncommitted transactions

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
journal to force

\end{description}

\textbf{Description}

Caller want unconditional commit. We can only force the running transaction
if we don't have an active handle, otherwise, we will deadlock.
\index{jbd2\_journal\_init\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_init_dev}\pysiglinewithargsret{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} * \bfcode{jbd2\_journal\_init\_dev}}{struct block\_device *\emph{ bdev}, struct block\_device *\emph{ fs\_dev}, unsigned long long\emph{ start}, int\emph{ len}, int\emph{ blocksize}}{}
creates and initialises a journal structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct block\_device * bdev}}] \leavevmode
Block device on which to create the journal

\item[{\code{struct block\_device * fs\_dev}}] \leavevmode
Device which hold journalled filesystem for this journal.

\item[{\code{unsigned long long start}}] \leavevmode
Block nr Start of journal.

\item[{\code{int len}}] \leavevmode
Length of the journal in blocks.

\item[{\code{int blocksize}}] \leavevmode
blocksize of journalling device

\end{description}

\textbf{Return}

a newly created journal\_t *
\begin{quote}

jbd2\_journal\_init\_dev creates a journal which maps a fixed contiguous
range of blocks on an arbitrary block device.
\end{quote}
\index{jbd2\_journal\_init\_inode (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_init_inode}\pysiglinewithargsret{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} * \bfcode{jbd2\_journal\_init\_inode}}{struct inode *\emph{ inode}}{}
creates a journal which maps to a inode.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
An inode to create the journal in

\end{description}

\textbf{Description}

jbd2\_journal\_init\_inode creates a journal which maps an on-disk inode as
the journal.  The inode must exist already, must support {\hyperref[filesystems/index:c.bmap]{\emph{\code{bmap()}}}} and
must have all data blocks preallocated.
\index{jbd2\_journal\_update\_sb\_errno (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_update_sb_errno}\pysiglinewithargsret{void \bfcode{jbd2\_journal\_update\_sb\_errno}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}}{}
Update error in the journal.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
The journal to update.

\end{description}

\textbf{Description}

Update a journal's errno.  Write updated superblock to disk waiting for IO
to complete.
\index{jbd2\_journal\_load (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_load}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_load}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}}{}
Read journal from disk.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
Journal to act on.

\end{description}

\textbf{Description}

Given a journal\_t structure which tells us which disk blocks contain
a journal, read the journal from disk to initialise the in-memory
structures.
\index{jbd2\_journal\_destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_destroy}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_destroy}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}}{}
Release a journal\_t structure.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
Journal to act on.

\end{description}

\textbf{Description}

Release a journal\_t structure once it is no longer in use by the
journaled object.
Return \textless{}0 if we couldn't clean up the journal.
\index{jbd2\_journal\_check\_used\_features (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_check_used_features}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_check\_used\_features}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}, unsigned long\emph{ compat}, unsigned long\emph{ ro}, unsigned long\emph{ incompat}}{}
Check if features specified are used.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
Journal to check.

\item[{\code{unsigned long compat}}] \leavevmode
bitmask of compatible features

\item[{\code{unsigned long ro}}] \leavevmode
bitmask of features that force read-only mount

\item[{\code{unsigned long incompat}}] \leavevmode
bitmask of incompatible features

\end{description}

\textbf{Description}

Check whether the journal uses all of a given set of
features.  Return true (non-zero) if it does.
\index{jbd2\_journal\_check\_available\_features (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_check_available_features}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_check\_available\_features}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}, unsigned long\emph{ compat}, unsigned long\emph{ ro}, unsigned long\emph{ incompat}}{}
Check feature set in journalling layer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
Journal to check.

\item[{\code{unsigned long compat}}] \leavevmode
bitmask of compatible features

\item[{\code{unsigned long ro}}] \leavevmode
bitmask of features that force read-only mount

\item[{\code{unsigned long incompat}}] \leavevmode
bitmask of incompatible features

\end{description}

\textbf{Description}

Check whether the journaling code supports the use of
all of a given set of features on this journal.  Return true
\index{jbd2\_journal\_set\_features (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_set_features}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_set\_features}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}, unsigned long\emph{ compat}, unsigned long\emph{ ro}, unsigned long\emph{ incompat}}{}
Mark a given journal feature in the superblock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
Journal to act on.

\item[{\code{unsigned long compat}}] \leavevmode
bitmask of compatible features

\item[{\code{unsigned long ro}}] \leavevmode
bitmask of features that force read-only mount

\item[{\code{unsigned long incompat}}] \leavevmode
bitmask of incompatible features

\end{description}

\textbf{Description}

Mark a given journal feature as present on the
superblock.  Returns true if the requested features could be set.
\index{jbd2\_journal\_flush (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_flush}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_flush}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}}{}
Flush journal

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
Journal to act on.

\end{description}

\textbf{Description}

Flush all data for a given journal to disk and empty the journal.
Filesystems can use this when remounting readonly to ensure that
recovery does not need to happen on remount.
\index{jbd2\_journal\_wipe (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_wipe}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_wipe}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}, int\emph{ write}}{}
Wipe journal contents

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
Journal to act on.

\item[{\code{int write}}] \leavevmode
flag (see below)

\end{description}

\textbf{Description}

Wipe out all of the contents of a journal, safely.  This will produce
a warning if the journal contains any valid recovery information.
Must be called between journal\_init\_*() and {\hyperref[filesystems/index:c.jbd2_journal_load]{\emph{\code{jbd2\_journal\_load()}}}}.

If `write' is non-zero, then we wipe out the journal on disk; otherwise
we merely suppress recovery.
\index{jbd2\_journal\_abort (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_abort}\pysiglinewithargsret{void \bfcode{jbd2\_journal\_abort}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}, int\emph{ errno}}{}
Shutdown the journal immediately.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
the journal to shutdown.

\item[{\code{int errno}}] \leavevmode
an error number to record in the journal indicating
the reason for the shutdown.

\end{description}

\textbf{Description}

Perform a complete, immediate shutdown of the ENTIRE
journal (not of a single transaction).  This operation cannot be
undone without closing and reopening the journal.

The jbd2\_journal\_abort function is intended to support higher level error
recovery mechanisms such as the ext2/ext3 remount-readonly error
mode.

Journal abort has very specific semantics.  Any existing dirty,
unjournaled buffers in the main filesystem will still be written to
disk by bdflush, but the journaling mechanism will be suspended
immediately and no further transaction commits will be honoured.

Any dirty, journaled buffers will be written back to disk without
hitting the journal.  Atomicity cannot be guaranteed on an aborted
filesystem, but we \_do\_ attempt to leave as much data as possible
behind for fsck to use for cleanup.

Any attempt to get a new transaction handle on a journal which is in
ABORT state will just result in an -EROFS error return.  A
jbd2\_journal\_stop on an existing handle will return -EIO if we have
entered abort state during the update.

Recursive transactions are not disturbed by journal abort until the
final jbd2\_journal\_stop, which will receive the -EIO error.

Finally, the jbd2\_journal\_abort call allows the caller to supply an errno
which will be recorded (if possible) in the journal superblock.  This
allows a client to record failure conditions in the middle of a
transaction without having to complete the transaction to record the
failure to disk.  ext3\_error, for example, now uses this
functionality.

Errors which originate from within the journaling layer will NOT
supply an errno; a null errno implies that absolutely no further
writes are done to the journal (unless there are any already in
progress).
\index{jbd2\_journal\_errno (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_errno}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_errno}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}}{}
returns the journal's error state.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
journal to examine.

\end{description}

\textbf{Description}

This is the errno number set with {\hyperref[filesystems/index:c.jbd2_journal_abort]{\emph{\code{jbd2\_journal\_abort()}}}}, the last
time the journal was mounted - if the journal was stopped
without calling abort this will be 0.

If the journal has been aborted on this mount time -EROFS will
be returned.
\index{jbd2\_journal\_clear\_err (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_clear_err}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_clear\_err}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}}{}
clears the journal's error state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
journal to act on.

\end{description}

\textbf{Description}

An error must be cleared or acked to take a FS out of readonly
mode.
\index{jbd2\_journal\_ack\_err (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_ack_err}\pysiglinewithargsret{void \bfcode{jbd2\_journal\_ack\_err}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}}{}
Ack journal err.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
journal to act on.

\end{description}

\textbf{Description}

An error must be cleared or acked to take a FS out of readonly
mode.
\index{jbd2\_journal\_recover (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_recover}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_recover}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}}{}
recovers a on-disk journal

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
the journal to recover

\end{description}

\textbf{Description}

The primary function for recovering the log contents when mounting a
journaled device.

Recovery is done in three passes.  In the first pass, we look for the
end of the log.  In the second, we assemble the list of revoke
blocks.  In the third and final pass, we replay any un-revoked blocks
in the log.
\index{jbd2\_journal\_skip\_recovery (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_skip_recovery}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_skip\_recovery}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}}{}
Start journal and wipe exiting records

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
journal to startup

\end{description}

\textbf{Description}

Locate any valid recovery information from the journal and set up the
journal structures in memory to ignore it (presumably because the
caller has evidence that it is out of date).
This function doesn't appear to be exported..

We perform one pass over the journal to allow us to tell the user how
much recovery information is being erased, and to let us initialise
the journal transaction sequence numbers to the next unused ID.


\subsection{Transasction Level}
\label{filesystems/index:transasction-level}\index{jbd2\_journal\_start (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_start}\pysiglinewithargsret{{\hyperref[filesystems/index:c.handle_t]{\emph{handle\_t}}} * \bfcode{jbd2\_journal\_start}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}, int\emph{ nblocks}}{}
Obtain a new handle.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
Journal to start transaction on.

\item[{\code{int nblocks}}] \leavevmode
number of block buffer we might modify

\end{description}

\textbf{Description}

We make sure that the transaction can guarantee at least nblocks of
modified buffers in the log.  We block until the log can guarantee
that much space. Additionally, if rsv\_blocks \textgreater{} 0, we also create another
handle with rsv\_blocks reserved blocks in the journal. This handle is
is stored in h\_rsv\_handle. It is not attached to any particular transaction
and thus doesn't block transaction commit. If the caller uses this reserved
handle, it has to set h\_rsv\_handle to NULL as otherwise {\hyperref[filesystems/index:c.jbd2_journal_stop]{\emph{\code{jbd2\_journal\_stop()}}}}
on the parent handle will dispose the reserved one. Reserved handle has to
be converted to a normal handle using {\hyperref[filesystems/index:c.jbd2_journal_start_reserved]{\emph{\code{jbd2\_journal\_start\_reserved()}}}} before
it can be used.

Return a pointer to a newly allocated handle, or an \code{ERR\_PTR()} value
on failure.
\index{jbd2\_journal\_start\_reserved (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_start_reserved}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_start\_reserved}}{{\hyperref[filesystems/index:c.handle_t]{\emph{handle\_t}}} *\emph{ handle}, unsigned int\emph{ type}, unsigned int\emph{ line\_no}}{}
start reserved handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{handle\_t * handle}}] \leavevmode
handle to start

\item[{\code{unsigned int type}}] \leavevmode
for handle statistics

\item[{\code{unsigned int line\_no}}] \leavevmode
for handle statistics

\end{description}

\textbf{Description}

Start handle that has been previously reserved with \code{jbd2\_journal\_reserve()}.
This attaches \textbf{handle} to the running transaction (or creates one if there's
not transaction running). Unlike {\hyperref[filesystems/index:c.jbd2_journal_start]{\emph{\code{jbd2\_journal\_start()}}}} this function cannot
block on journal commit, checkpointing, or similar stuff. It can block on
memory allocation or frozen journal though.

Return 0 on success, non-zero on error - handle is freed in that case.
\index{jbd2\_journal\_extend (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_extend}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_extend}}{{\hyperref[filesystems/index:c.handle_t]{\emph{handle\_t}}} *\emph{ handle}, int\emph{ nblocks}}{}
extend buffer credits.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{handle\_t * handle}}] \leavevmode
handle to `extend'

\item[{\code{int nblocks}}] \leavevmode
nr blocks to try to extend by.

\end{description}

\textbf{Description}

Some transactions, such as large extends and truncates, can be done
atomically all at once or in several stages.  The operation requests
a credit for a number of buffer modifications in advance, but can
extend its credit if it needs more.

jbd2\_journal\_extend tries to give the running handle more buffer credits.
It does not guarantee that allocation - this is a best-effort only.
The calling process MUST be able to deal cleanly with a failure to
extend here.

Return 0 on success, non-zero on failure.

return code \textless{} 0 implies an error
return code \textgreater{} 0 implies normal transaction-full status.
\index{jbd2\_\_journal\_restart (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2__journal_restart}\pysiglinewithargsret{int \bfcode{jbd2\_\_journal\_restart}}{{\hyperref[filesystems/index:c.handle_t]{\emph{handle\_t}}} *\emph{ handle}, int\emph{ nblocks}, gfp\_t\emph{ gfp\_mask}}{}
restart a handle .

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{handle\_t * handle}}] \leavevmode
handle to restart

\item[{\code{int nblocks}}] \leavevmode
nr credits requested

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
memory allocation flags (for start\_this\_handle)

\end{description}

\textbf{Description}

Restart a handle for a multi-transaction filesystem
operation.

If the {\hyperref[filesystems/index:c.jbd2_journal_extend]{\emph{\code{jbd2\_journal\_extend()}}}} call above fails to grant new buffer credits
to a running handle, a call to jbd2\_journal\_restart will commit the
handle's transaction so far and reattach the handle to a new
transaction capable of guaranteeing the requested number of
credits. We preserve reserved handle if there's any attached to the
passed in handle.
\index{jbd2\_journal\_lock\_updates (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_lock_updates}\pysiglinewithargsret{void \bfcode{jbd2\_journal\_lock\_updates}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}}{}
establish a transaction barrier.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
Journal to establish a barrier on.

\end{description}

\textbf{Description}

This locks out any further updates from being started, and blocks
until all existing updates have completed, returning only once the
journal is in a quiescent state with no updates running.

The journal lock should not be held on entry.
\index{jbd2\_journal\_unlock\_updates (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_unlock_updates}\pysiglinewithargsret{void \bfcode{jbd2\_journal\_unlock\_updates}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}}{}
release barrier

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
Journal to release the barrier on.

\end{description}

\textbf{Description}

Release a transaction barrier obtained with {\hyperref[filesystems/index:c.jbd2_journal_lock_updates]{\emph{\code{jbd2\_journal\_lock\_updates()}}}}.

Should be called without the journal lock held.
\index{jbd2\_journal\_get\_write\_access (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_get_write_access}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_get\_write\_access}}{{\hyperref[filesystems/index:c.handle_t]{\emph{handle\_t}}} *\emph{ handle}, struct buffer\_head *\emph{ bh}}{}
notify intent to modify a buffer for metadata (not data) update.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{handle\_t * handle}}] \leavevmode
transaction to add buffer modifications to

\item[{\code{struct buffer\_head * bh}}] \leavevmode
bh to be used for metadata writes

\end{description}

\textbf{Return}

error code or 0 on success.

In full data journalling mode the buffer may be of type BJ\_AsyncData,
because we're \code{:c:func:{}`write(){}`ing} a buffer which is also part of a shared mapping.
\index{jbd2\_journal\_get\_create\_access (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_get_create_access}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_get\_create\_access}}{{\hyperref[filesystems/index:c.handle_t]{\emph{handle\_t}}} *\emph{ handle}, struct buffer\_head *\emph{ bh}}{}
notify intent to use newly created bh

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{handle\_t * handle}}] \leavevmode
transaction to new buffer to

\item[{\code{struct buffer\_head * bh}}] \leavevmode
new buffer.

\end{description}

\textbf{Description}

Call this if you create a new bh.
\index{jbd2\_journal\_get\_undo\_access (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_get_undo_access}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_get\_undo\_access}}{{\hyperref[filesystems/index:c.handle_t]{\emph{handle\_t}}} *\emph{ handle}, struct buffer\_head *\emph{ bh}}{}
Notify intent to modify metadata with non-rewindable consequences

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{handle\_t * handle}}] \leavevmode
transaction

\item[{\code{struct buffer\_head * bh}}] \leavevmode
buffer to undo

\end{description}

\textbf{Description}

Sometimes there is a need to distinguish between metadata which has
been committed to disk and that which has not.  The ext3fs code uses
this for freeing and allocating space, we have to make sure that we
do not reuse freed space until the deallocation has been committed,
since if we overwrote that space we would make the delete
un-rewindable in case of a crash.

To deal with that, jbd2\_journal\_get\_undo\_access requests write access to a
buffer for parts of non-rewindable operations such as delete
operations on the bitmaps.  The journaling code must keep a copy of
the buffer's contents prior to the undo\_access call until such time
as we know that the buffer has definitely been committed to disk.

We never need to know which transaction the committed data is part
of, buffers touched here are guaranteed to be dirtied later and so
will be committed to a new transaction in due course, at which point
we can discard the old committed data pointer.

Returns error number or 0 on success.
\index{jbd2\_journal\_set\_triggers (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_set_triggers}\pysiglinewithargsret{void \bfcode{jbd2\_journal\_set\_triggers}}{struct buffer\_head *\emph{ bh}, struct jbd2\_buffer\_trigger\_type *\emph{ type}}{}
Add triggers for commit writeout

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct buffer\_head * bh}}] \leavevmode
buffer to trigger on

\item[{\code{struct jbd2\_buffer\_trigger\_type * type}}] \leavevmode
struct jbd2\_buffer\_trigger\_type containing the trigger(s).

\end{description}

\textbf{Description}

Set any triggers on this journal\_head.  This is always safe, because
triggers for a committing buffer will be saved off, and triggers for
a running transaction will match the buffer in that transaction.

Call with NULL to clear the triggers.
\index{jbd2\_journal\_dirty\_metadata (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_dirty_metadata}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_dirty\_metadata}}{{\hyperref[filesystems/index:c.handle_t]{\emph{handle\_t}}} *\emph{ handle}, struct buffer\_head *\emph{ bh}}{}
mark a buffer as containing dirty metadata

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{handle\_t * handle}}] \leavevmode
transaction to add buffer to.

\item[{\code{struct buffer\_head * bh}}] \leavevmode
buffer to mark

\end{description}

\textbf{Description}

mark dirty metadata which needs to be journaled as part of the current
transaction.

The buffer must have previously had {\hyperref[filesystems/index:c.jbd2_journal_get_write_access]{\emph{\code{jbd2\_journal\_get\_write\_access()}}}}
called so that it has a valid journal\_head attached to the buffer
head.

The buffer is placed on the transaction's metadata list and is marked
as belonging to the transaction.

Returns error number or 0 on success.

Special care needs to be taken if the buffer already belongs to the
current committing transaction (in which case we should have frozen
data present for that commit).  In that case, we don't relink the
buffer: that only gets done when the old transaction finally
completes its commit.
\index{jbd2\_journal\_forget (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_forget}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_forget}}{{\hyperref[filesystems/index:c.handle_t]{\emph{handle\_t}}} *\emph{ handle}, struct buffer\_head *\emph{ bh}}{}
\code{bforget()} for potentially-journaled buffers.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{handle\_t * handle}}] \leavevmode
transaction handle

\item[{\code{struct buffer\_head * bh}}] \leavevmode
bh to `forget'

\end{description}

\textbf{Description}

We can only do the bforget if there are no commits pending against the
buffer.  If the buffer is dirty in the current running transaction we
can safely unlink it.

bh may not be a journalled buffer at all - it may be a non-JBD
buffer which came off the hashtable.  Check for this.

Decrements bh-\textgreater{}b\_count by one.

Allow this call even if the handle has aborted --- it may be part of
the caller's cleanup after an abort.
\index{jbd2\_journal\_stop (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_stop}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_stop}}{{\hyperref[filesystems/index:c.handle_t]{\emph{handle\_t}}} *\emph{ handle}}{}
complete a transaction

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{handle\_t * handle}}] \leavevmode
transaction to complete.

\end{description}

\textbf{Description}

All done for a particular handle.

There is not much action needed here.  We just return any remaining
buffer credits to the transaction and remove the handle.  The only
complication is that we need to start a commit operation if the
filesystem is marked for synchronous update.

jbd2\_journal\_stop itself will not usually return an error, but it may
do so in unusual circumstances.  In particular, expect it to
return -EIO if a jbd2\_journal\_abort has been executed since the
transaction began.
\index{jbd2\_journal\_try\_to\_free\_buffers (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_try_to_free_buffers}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_try\_to\_free\_buffers}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}, struct page *\emph{ page}, gfp\_t\emph{ gfp\_mask}}{}
try to free page buffers.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
journal for operation

\item[{\code{struct page * page}}] \leavevmode
to try and free

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
we use the mask to detect how hard should we try to release
buffers. If \_\_GFP\_DIRECT\_RECLAIM and \_\_GFP\_FS is set, we wait for commit
code to release the buffers.

\end{description}

\textbf{Description}

For all the buffers on this page,
if they are fully written out ordered data, move them onto BUF\_CLEAN
so \code{try\_to\_free\_buffers()} can reap them.

This function returns non-zero if we wish \code{try\_to\_free\_buffers()}
to be called. We do this if the page is releasable by \code{try\_to\_free\_buffers()}.
We also do it if the page has locked or dirty buffers and the caller wants
us to perform sync or async writeout.

This complicates JBD locking somewhat.  We aren't protected by the
BKL here.  We wish to remove the buffer from its committing or
running transaction's -\textgreater{}t\_datalist via \_\_jbd2\_journal\_unfile\_buffer.

This may \emph{change} the value of transaction\_t-\textgreater{}t\_datalist, so anyone
who looks at t\_datalist needs to lock against this function.

Even worse, someone may be doing a jbd2\_journal\_dirty\_data on this
buffer.  So we need to lock against that.  \code{jbd2\_journal\_dirty\_data()}
will come out of the lock with the buffer dirty, which makes it
ineligible for release here.

Who else is affected by this?  hmm...  Really the only contender
is \code{do\_get\_write\_access()} - it could be looking at the buffer while
\code{journal\_try\_to\_free\_buffer()} is changing its state.  But that
cannot happen because we never reallocate freed data as metadata
while the data is part of a transaction.  Yes?

Return 0 on failure, 1 on success
\index{jbd2\_journal\_invalidatepage (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.jbd2_journal_invalidatepage}\pysiglinewithargsret{int \bfcode{jbd2\_journal\_invalidatepage}}{{\hyperref[filesystems/index:c.journal_t]{\emph{journal\_t}}} *\emph{ journal}, struct page *\emph{ page}, unsigned int\emph{ offset}, unsigned int\emph{ length}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{journal\_t * journal}}] \leavevmode
journal to use for flush...

\item[{\code{struct page * page}}] \leavevmode
page to flush

\item[{\code{unsigned int offset}}] \leavevmode
start of the range to invalidate

\item[{\code{unsigned int length}}] \leavevmode
length of the range to invalidate

\end{description}

\textbf{Description}

Reap page buffers containing data after in the specified range in page.
Can return -EBUSY if buffers are part of the committing transaction and
the page is straddling i\_size. Caller then has to wait for current commit
and try again.


\section{See also}
\label{filesystems/index:see-also}
\href{http://kernel.org/pub/linux/kernel/people/sct/ext3/journal-design.ps.gz}{Journaling the Linux ext2fs Filesystem, LinuxExpo 98, Stephen
Tweedie}

\href{http://olstrans.sourceforge.net/release/OLS2000-ext3/OLS2000-ext3.html}{Ext3 Journalling FileSystem, OLS 2000, Dr. Stephen
Tweedie}


\chapter{splice API}
\label{filesystems/index:splice-api}
splice is a method for moving blocks of data around inside the kernel,
without continually transferring them between the kernel and user space.
\index{splice\_to\_pipe (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.splice_to_pipe}\pysiglinewithargsret{ssize\_t \bfcode{splice\_to\_pipe}}{struct {\hyperref[filesystems/index:c.pipe_inode_info]{\emph{pipe\_inode\_info}}} *\emph{ pipe}, struct splice\_pipe\_desc *\emph{ spd}}{}
fill passed data into a pipe

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pipe\_inode\_info * pipe}}] \leavevmode
pipe to fill

\item[{\code{struct splice\_pipe\_desc * spd}}] \leavevmode
data to fill

\end{description}

\textbf{Description}
\begin{quote}

\textbf{spd} contains a map of pages and len/offset tuples, along with
the struct pipe\_buf\_operations associated with these pages. This
function will link that data to the pipe.
\end{quote}
\index{generic\_file\_splice\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.generic_file_splice_read}\pysiglinewithargsret{ssize\_t \bfcode{generic\_file\_splice\_read}}{struct file *\emph{ in}, loff\_t *\emph{ ppos}, struct {\hyperref[filesystems/index:c.pipe_inode_info]{\emph{pipe\_inode\_info}}} *\emph{ pipe}, size\_t\emph{ len}, unsigned int\emph{ flags}}{}
splice data from file to a pipe

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * in}}] \leavevmode
file to splice from

\item[{\code{loff\_t * ppos}}] \leavevmode
position in \textbf{in}

\item[{\code{struct pipe\_inode\_info * pipe}}] \leavevmode
pipe to splice to

\item[{\code{size\_t len}}] \leavevmode
number of bytes to splice

\item[{\code{unsigned int flags}}] \leavevmode
splice modifier flags

\end{description}

\textbf{Description}
\begin{quote}

Will read pages from given file and fill them into a pipe. Can be
used as long as it has more or less sane -\textgreater{}:c:func:\emph{read\_iter()}.
\end{quote}
\index{splice\_from\_pipe\_feed (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.splice_from_pipe_feed}\pysiglinewithargsret{int \bfcode{splice\_from\_pipe\_feed}}{struct {\hyperref[filesystems/index:c.pipe_inode_info]{\emph{pipe\_inode\_info}}} *\emph{ pipe}, struct splice\_desc *\emph{ sd}, splice\_actor *\emph{ actor}}{}
feed available data from a pipe to a file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pipe\_inode\_info * pipe}}] \leavevmode
pipe to splice from

\item[{\code{struct splice\_desc * sd}}] \leavevmode
information to \textbf{actor}

\item[{\code{splice\_actor * actor}}] \leavevmode
handler that splices the data

\end{description}

\textbf{Description}
\begin{quote}

This function loops over the pipe and calls \textbf{actor} to do the
actual moving of a single struct pipe\_buffer to the desired
destination.  It returns when there's no more buffers left in
the pipe or if the requested number of bytes (\textbf{sd}-\textgreater{}total\_len)
have been copied.  It returns a positive number (one) if the
pipe needs to be filled with more data, zero if the required
number of bytes have been copied and -errno on error.

This, together with splice\_from\_pipe\_\{begin,end,next\}, may be
used to implement the functionality of {\hyperref[filesystems/index:c.__splice_from_pipe]{\emph{\code{\_\_splice\_from\_pipe()}}}} when
locking is required around copying the pipe buffers to the
destination.
\end{quote}
\index{splice\_from\_pipe\_next (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.splice_from_pipe_next}\pysiglinewithargsret{int \bfcode{splice\_from\_pipe\_next}}{struct {\hyperref[filesystems/index:c.pipe_inode_info]{\emph{pipe\_inode\_info}}} *\emph{ pipe}, struct splice\_desc *\emph{ sd}}{}
wait for some data to splice from

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pipe\_inode\_info * pipe}}] \leavevmode
pipe to splice from

\item[{\code{struct splice\_desc * sd}}] \leavevmode
information about the splice operation

\end{description}

\textbf{Description}
\begin{quote}

This function will wait for some data and return a positive
value (one) if pipe buffers are available.  It will return zero
or -errno if no more data needs to be spliced.
\end{quote}
\index{splice\_from\_pipe\_begin (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.splice_from_pipe_begin}\pysiglinewithargsret{void \bfcode{splice\_from\_pipe\_begin}}{struct splice\_desc *\emph{ sd}}{}
start splicing from pipe

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct splice\_desc * sd}}] \leavevmode
information about the splice operation

\end{description}

\textbf{Description}
\begin{quote}

This function should be called before a loop containing
{\hyperref[filesystems/index:c.splice_from_pipe_next]{\emph{\code{splice\_from\_pipe\_next()}}}} and {\hyperref[filesystems/index:c.splice_from_pipe_feed]{\emph{\code{splice\_from\_pipe\_feed()}}}} to
initialize the necessary fields of \textbf{sd}.
\end{quote}
\index{splice\_from\_pipe\_end (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.splice_from_pipe_end}\pysiglinewithargsret{void \bfcode{splice\_from\_pipe\_end}}{struct {\hyperref[filesystems/index:c.pipe_inode_info]{\emph{pipe\_inode\_info}}} *\emph{ pipe}, struct splice\_desc *\emph{ sd}}{}
finish splicing from pipe

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pipe\_inode\_info * pipe}}] \leavevmode
pipe to splice from

\item[{\code{struct splice\_desc * sd}}] \leavevmode
information about the splice operation

\end{description}

\textbf{Description}
\begin{quote}

This function will wake up pipe writers if necessary.  It should
be called after a loop containing {\hyperref[filesystems/index:c.splice_from_pipe_next]{\emph{\code{splice\_from\_pipe\_next()}}}} and
{\hyperref[filesystems/index:c.splice_from_pipe_feed]{\emph{\code{splice\_from\_pipe\_feed()}}}}.
\end{quote}
\index{\_\_splice\_from\_pipe (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.__splice_from_pipe}\pysiglinewithargsret{ssize\_t \bfcode{\_\_splice\_from\_pipe}}{struct {\hyperref[filesystems/index:c.pipe_inode_info]{\emph{pipe\_inode\_info}}} *\emph{ pipe}, struct splice\_desc *\emph{ sd}, splice\_actor *\emph{ actor}}{}
splice data from a pipe to given actor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pipe\_inode\_info * pipe}}] \leavevmode
pipe to splice from

\item[{\code{struct splice\_desc * sd}}] \leavevmode
information to \textbf{actor}

\item[{\code{splice\_actor * actor}}] \leavevmode
handler that splices the data

\end{description}

\textbf{Description}
\begin{quote}

This function does little more than loop over the pipe and call
\textbf{actor} to do the actual moving of a single struct pipe\_buffer to
the desired destination. See pipe\_to\_file, pipe\_to\_sendpage, or
pipe\_to\_user.
\end{quote}
\index{splice\_from\_pipe (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.splice_from_pipe}\pysiglinewithargsret{ssize\_t \bfcode{splice\_from\_pipe}}{struct {\hyperref[filesystems/index:c.pipe_inode_info]{\emph{pipe\_inode\_info}}} *\emph{ pipe}, struct file *\emph{ out}, loff\_t *\emph{ ppos}, size\_t\emph{ len}, unsigned int\emph{ flags}, splice\_actor *\emph{ actor}}{}
splice data from a pipe to a file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pipe\_inode\_info * pipe}}] \leavevmode
pipe to splice from

\item[{\code{struct file * out}}] \leavevmode
file to splice to

\item[{\code{loff\_t * ppos}}] \leavevmode
position in \textbf{out}

\item[{\code{size\_t len}}] \leavevmode
how many bytes to splice

\item[{\code{unsigned int flags}}] \leavevmode
splice modifier flags

\item[{\code{splice\_actor * actor}}] \leavevmode
handler that splices the data

\end{description}

\textbf{Description}
\begin{quote}

See \_\_splice\_from\_pipe. This function locks the pipe inode,
otherwise it's identical to {\hyperref[filesystems/index:c.__splice_from_pipe]{\emph{\code{\_\_splice\_from\_pipe()}}}}.
\end{quote}
\index{iter\_file\_splice\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.iter_file_splice_write}\pysiglinewithargsret{ssize\_t \bfcode{iter\_file\_splice\_write}}{struct {\hyperref[filesystems/index:c.pipe_inode_info]{\emph{pipe\_inode\_info}}} *\emph{ pipe}, struct file *\emph{ out}, loff\_t *\emph{ ppos}, size\_t\emph{ len}, unsigned int\emph{ flags}}{}
splice data from a pipe to a file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pipe\_inode\_info * pipe}}] \leavevmode
pipe info

\item[{\code{struct file * out}}] \leavevmode
file to write to

\item[{\code{loff\_t * ppos}}] \leavevmode
position in \textbf{out}

\item[{\code{size\_t len}}] \leavevmode
number of bytes to splice

\item[{\code{unsigned int flags}}] \leavevmode
splice modifier flags

\end{description}

\textbf{Description}
\begin{quote}

Will either move or copy pages (determined by \textbf{flags} options) from
the given pipe inode to the given file.
This one is -\textgreater{}write\_iter-based.
\end{quote}
\index{generic\_splice\_sendpage (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.generic_splice_sendpage}\pysiglinewithargsret{ssize\_t \bfcode{generic\_splice\_sendpage}}{struct {\hyperref[filesystems/index:c.pipe_inode_info]{\emph{pipe\_inode\_info}}} *\emph{ pipe}, struct file *\emph{ out}, loff\_t *\emph{ ppos}, size\_t\emph{ len}, unsigned int\emph{ flags}}{}
splice data from a pipe to a socket

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pipe\_inode\_info * pipe}}] \leavevmode
pipe to splice from

\item[{\code{struct file * out}}] \leavevmode
socket to write to

\item[{\code{loff\_t * ppos}}] \leavevmode
position in \textbf{out}

\item[{\code{size\_t len}}] \leavevmode
number of bytes to splice

\item[{\code{unsigned int flags}}] \leavevmode
splice modifier flags

\end{description}

\textbf{Description}
\begin{quote}

Will send \textbf{len} bytes from the pipe to a network socket. No data copying
is involved.
\end{quote}
\index{splice\_direct\_to\_actor (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.splice_direct_to_actor}\pysiglinewithargsret{ssize\_t \bfcode{splice\_direct\_to\_actor}}{struct file *\emph{ in}, struct splice\_desc *\emph{ sd}, splice\_direct\_actor *\emph{ actor}}{}
splices data directly between two non-pipes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * in}}] \leavevmode
file to splice from

\item[{\code{struct splice\_desc * sd}}] \leavevmode
actor information on where to splice to

\item[{\code{splice\_direct\_actor * actor}}] \leavevmode
handles the data splicing

\end{description}

\textbf{Description}
\begin{quote}

This is a special case helper to splice directly between two
points, without requiring an explicit pipe. Internally an allocated
pipe is cached in the process, and reused during the lifetime of
that process.
\end{quote}
\index{do\_splice\_direct (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.do_splice_direct}\pysiglinewithargsret{long \bfcode{do\_splice\_direct}}{struct file *\emph{ in}, loff\_t *\emph{ ppos}, struct file *\emph{ out}, loff\_t *\emph{ opos}, size\_t\emph{ len}, unsigned int\emph{ flags}}{}
splices data directly between two files

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * in}}] \leavevmode
file to splice from

\item[{\code{loff\_t * ppos}}] \leavevmode
input file offset

\item[{\code{struct file * out}}] \leavevmode
file to splice to

\item[{\code{loff\_t * opos}}] \leavevmode
output file offset

\item[{\code{size\_t len}}] \leavevmode
number of bytes to splice

\item[{\code{unsigned int flags}}] \leavevmode
splice modifier flags

\end{description}

\textbf{Description}
\begin{quote}

For use by \code{do\_sendfile()}. splice can easily emulate sendfile, but
doing it in the application would incur an extra system call
(splice in + splice out, as compared to just \code{sendfile()}). So this helper
can splice directly through a process-private pipe.
\end{quote}


\chapter{pipes API}
\label{filesystems/index:pipes-api}
Pipe interfaces are all for in-kernel (builtin image) use. They are not
exported for use by modules.
\index{pipe\_buffer (C type)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.pipe_buffer}\pysigline{struct \bfcode{pipe\_buffer}}
a linux kernel pipe buffer

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct pipe\PYGZus{}buffer \PYGZob{}
  struct page *page;
  unsigned int offset, len;
  const struct pipe\PYGZus{}buf\PYGZus{}operations *ops;
  unsigned int flags;
  unsigned long private;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{page}}] \leavevmode
the page containing the data for the pipe buffer

\item[{\code{offset}}] \leavevmode
offset of data inside the \textbf{page}

\item[{\code{len}}] \leavevmode
length of data inside the \textbf{page}

\item[{\code{ops}}] \leavevmode
operations associated with this buffer. See \textbf{pipe\_buf\_operations}.

\item[{\code{flags}}] \leavevmode
pipe buffer flags. See above.

\item[{\code{private}}] \leavevmode
private data owned by the ops.

\end{description}
\index{pipe\_inode\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.pipe_inode_info}\pysigline{struct \bfcode{pipe\_inode\_info}}
a linux kernel pipe

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct pipe\PYGZus{}inode\PYGZus{}info \PYGZob{}
  struct mutex mutex;
  wait\PYGZus{}queue\PYGZus{}head\PYGZus{}t wait;
  unsigned int nrbufs, curbuf, buffers;
  unsigned int readers;
  unsigned int writers;
  unsigned int files;
  unsigned int waiting\PYGZus{}writers;
  unsigned int r\PYGZus{}counter;
  unsigned int w\PYGZus{}counter;
  struct page *tmp\PYGZus{}page;
  struct fasync\PYGZus{}struct *fasync\PYGZus{}readers;
  struct fasync\PYGZus{}struct *fasync\PYGZus{}writers;
  struct pipe\PYGZus{}buffer *bufs;
  struct user\PYGZus{}struct *user;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{mutex}}] \leavevmode
mutex protecting the whole thing

\item[{\code{wait}}] \leavevmode
reader/writer wait point in case of empty/full pipe

\item[{\code{nrbufs}}] \leavevmode
the number of non-empty pipe buffers in this pipe

\item[{\code{curbuf}}] \leavevmode
the current pipe buffer entry

\item[{\code{buffers}}] \leavevmode
total number of buffers (should be a power of 2)

\item[{\code{readers}}] \leavevmode
number of current readers of this pipe

\item[{\code{writers}}] \leavevmode
number of current writers of this pipe

\item[{\code{files}}] \leavevmode
number of struct file referring this pipe (protected by -\textgreater{}i\_lock)

\item[{\code{waiting\_writers}}] \leavevmode
number of writers blocked waiting for room

\item[{\code{r\_counter}}] \leavevmode
reader counter

\item[{\code{w\_counter}}] \leavevmode
writer counter

\item[{\code{tmp\_page}}] \leavevmode
cached released page

\item[{\code{fasync\_readers}}] \leavevmode
reader side fasync

\item[{\code{fasync\_writers}}] \leavevmode
writer side fasync

\item[{\code{bufs}}] \leavevmode
the circular array of pipe buffers

\item[{\code{user}}] \leavevmode
the user who created this pipe

\end{description}
\index{pipe\_buf\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.pipe_buf_get}\pysiglinewithargsret{void \bfcode{pipe\_buf\_get}}{struct {\hyperref[filesystems/index:c.pipe_inode_info]{\emph{pipe\_inode\_info}}} *\emph{ pipe}, struct {\hyperref[filesystems/index:c.pipe_buffer]{\emph{pipe\_buffer}}} *\emph{ buf}}{}
get a reference to a pipe\_buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pipe\_inode\_info * pipe}}] \leavevmode
the pipe that the buffer belongs to

\item[{\code{struct pipe\_buffer * buf}}] \leavevmode
the buffer to get a reference to

\end{description}
\index{pipe\_buf\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.pipe_buf_release}\pysiglinewithargsret{void \bfcode{pipe\_buf\_release}}{struct {\hyperref[filesystems/index:c.pipe_inode_info]{\emph{pipe\_inode\_info}}} *\emph{ pipe}, struct {\hyperref[filesystems/index:c.pipe_buffer]{\emph{pipe\_buffer}}} *\emph{ buf}}{}
put a reference to a pipe\_buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pipe\_inode\_info * pipe}}] \leavevmode
the pipe that the buffer belongs to

\item[{\code{struct pipe\_buffer * buf}}] \leavevmode
the buffer to put a reference to

\end{description}
\index{pipe\_buf\_confirm (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.pipe_buf_confirm}\pysiglinewithargsret{int \bfcode{pipe\_buf\_confirm}}{struct {\hyperref[filesystems/index:c.pipe_inode_info]{\emph{pipe\_inode\_info}}} *\emph{ pipe}, struct {\hyperref[filesystems/index:c.pipe_buffer]{\emph{pipe\_buffer}}} *\emph{ buf}}{}
verify contents of the pipe buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pipe\_inode\_info * pipe}}] \leavevmode
the pipe that the buffer belongs to

\item[{\code{struct pipe\_buffer * buf}}] \leavevmode
the buffer to confirm

\end{description}
\index{pipe\_buf\_steal (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.pipe_buf_steal}\pysiglinewithargsret{int \bfcode{pipe\_buf\_steal}}{struct {\hyperref[filesystems/index:c.pipe_inode_info]{\emph{pipe\_inode\_info}}} *\emph{ pipe}, struct {\hyperref[filesystems/index:c.pipe_buffer]{\emph{pipe\_buffer}}} *\emph{ buf}}{}
attempt to take ownership of a pipe\_buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pipe\_inode\_info * pipe}}] \leavevmode
the pipe that the buffer belongs to

\item[{\code{struct pipe\_buffer * buf}}] \leavevmode
the buffer to attempt to steal

\end{description}
\index{generic\_pipe\_buf\_steal (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.generic_pipe_buf_steal}\pysiglinewithargsret{int \bfcode{generic\_pipe\_buf\_steal}}{struct {\hyperref[filesystems/index:c.pipe_inode_info]{\emph{pipe\_inode\_info}}} *\emph{ pipe}, struct {\hyperref[filesystems/index:c.pipe_buffer]{\emph{pipe\_buffer}}} *\emph{ buf}}{}
attempt to take ownership of a {\hyperref[filesystems/index:c.pipe_buffer]{\emph{\code{pipe\_buffer}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pipe\_inode\_info * pipe}}] \leavevmode
the pipe that the buffer belongs to

\item[{\code{struct pipe\_buffer * buf}}] \leavevmode
the buffer to attempt to steal

\end{description}

\textbf{Description}
\begin{quote}

This function attempts to steal the \code{struct page} attached to
\textbf{buf}. If successful, this function returns 0 and returns with
the page locked. The caller may then reuse the page for whatever
he wishes; the typical use is insertion into a different file
page cache.
\end{quote}
\index{generic\_pipe\_buf\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.generic_pipe_buf_get}\pysiglinewithargsret{void \bfcode{generic\_pipe\_buf\_get}}{struct {\hyperref[filesystems/index:c.pipe_inode_info]{\emph{pipe\_inode\_info}}} *\emph{ pipe}, struct {\hyperref[filesystems/index:c.pipe_buffer]{\emph{pipe\_buffer}}} *\emph{ buf}}{}
get a reference to a {\hyperref[filesystems/index:c.pipe_buffer]{\emph{\code{struct pipe\_buffer}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pipe\_inode\_info * pipe}}] \leavevmode
the pipe that the buffer belongs to

\item[{\code{struct pipe\_buffer * buf}}] \leavevmode
the buffer to get a reference to

\end{description}

\textbf{Description}
\begin{quote}

This function grabs an extra reference to \textbf{buf}. It's used in
in the \code{tee()} system call, when we duplicate the buffers in one
pipe into another.
\end{quote}
\index{generic\_pipe\_buf\_confirm (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.generic_pipe_buf_confirm}\pysiglinewithargsret{int \bfcode{generic\_pipe\_buf\_confirm}}{struct {\hyperref[filesystems/index:c.pipe_inode_info]{\emph{pipe\_inode\_info}}} *\emph{ info}, struct {\hyperref[filesystems/index:c.pipe_buffer]{\emph{pipe\_buffer}}} *\emph{ buf}}{}
verify contents of the pipe buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pipe\_inode\_info * info}}] \leavevmode
the pipe that the buffer belongs to

\item[{\code{struct pipe\_buffer * buf}}] \leavevmode
the buffer to confirm

\end{description}

\textbf{Description}
\begin{quote}

This function does nothing, because the generic pipe code uses
pages that are always good when inserted into the pipe.
\end{quote}
\index{generic\_pipe\_buf\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{filesystems/index:c.generic_pipe_buf_release}\pysiglinewithargsret{void \bfcode{generic\_pipe\_buf\_release}}{struct {\hyperref[filesystems/index:c.pipe_inode_info]{\emph{pipe\_inode\_info}}} *\emph{ pipe}, struct {\hyperref[filesystems/index:c.pipe_buffer]{\emph{pipe\_buffer}}} *\emph{ buf}}{}
put a reference to a {\hyperref[filesystems/index:c.pipe_buffer]{\emph{\code{struct pipe\_buffer}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pipe\_inode\_info * pipe}}] \leavevmode
the pipe that the buffer belongs to

\item[{\code{struct pipe\_buffer * buf}}] \leavevmode
the buffer to put a reference to

\end{description}

\textbf{Description}
\begin{quote}

This function releases a reference to \textbf{buf}.
\end{quote}


\chapter{Encryption API}
\label{filesystems/index:encryption-api}
A library which filesystems can hook into to support transparent
encryption of files and directories.


\section{Filesystem-level encryption (fscrypt)}
\label{filesystems/fscrypt::doc}\label{filesystems/fscrypt:filesystem-level-encryption-fscrypt}

\subsection{Introduction}
\label{filesystems/fscrypt:introduction}
fscrypt is a library which filesystems can hook into to support
transparent encryption of files and directories.

Note: ``fscrypt'' in this document refers to the kernel-level portion,
implemented in \code{fs/crypto/}, as opposed to the userspace tool
\href{https://github.com/google/fscrypt}{fscrypt}.  This document only
covers the kernel-level portion.  For command-line examples of how to
use encryption, see the documentation for the userspace tool \href{https://github.com/google/fscrypt}{fscrypt}.  Also, it is recommended to use
the fscrypt userspace tool, or other existing userspace tools such as
\href{https://github.com/google/fscryptctl}{fscryptctl} or \href{https://source.android.com/security/encryption/file-based}{Android's key
management system}, over
using the kernel's API directly.  Using existing tools reduces the
chance of introducing your own security bugs.  (Nevertheless, for
completeness this documentation covers the kernel's API anyway.)

Unlike dm-crypt, fscrypt operates at the filesystem level rather than
at the block device level.  This allows it to encrypt different files
with different keys and to have unencrypted files on the same
filesystem.  This is useful for multi-user systems where each user's
data-at-rest needs to be cryptographically isolated from the others.
However, except for filenames, fscrypt does not encrypt filesystem
metadata.

Unlike eCryptfs, which is a stacked filesystem, fscrypt is integrated
directly into supported filesystems --- currently ext4, F2FS, and
UBIFS.  This allows encrypted files to be read and written without
caching both the decrypted and encrypted pages in the pagecache,
thereby nearly halving the memory used and bringing it in line with
unencrypted files.  Similarly, half as many dentries and inodes are
needed.  eCryptfs also limits encrypted filenames to 143 bytes,
causing application compatibility issues; fscrypt allows the full 255
bytes (NAME\_MAX).  Finally, unlike eCryptfs, the fscrypt API can be
used by unprivileged users, with no need to mount anything.

fscrypt does not support encrypting files in-place.  Instead, it
supports marking an empty directory as encrypted.  Then, after
userspace provides the key, all regular files, directories, and
symbolic links created in that directory tree are transparently
encrypted.


\subsection{Threat model}
\label{filesystems/fscrypt:threat-model}

\subsubsection{Offline attacks}
\label{filesystems/fscrypt:offline-attacks}
Provided that userspace chooses a strong encryption key, fscrypt
protects the confidentiality of file contents and filenames in the
event of a single point-in-time permanent offline compromise of the
block device content.  fscrypt does not protect the confidentiality of
non-filename metadata, e.g. file sizes, file permissions, file
timestamps, and extended attributes.  Also, the existence and location
of holes (unallocated blocks which logically contain all zeroes) in
files is not protected.

fscrypt is not guaranteed to protect confidentiality or authenticity
if an attacker is able to manipulate the filesystem offline prior to
an authorized user later accessing the filesystem.


\subsubsection{Online attacks}
\label{filesystems/fscrypt:online-attacks}
fscrypt (and storage encryption in general) can only provide limited
protection, if any at all, against online attacks.  In detail:

fscrypt is only resistant to side-channel attacks, such as timing or
electromagnetic attacks, to the extent that the underlying Linux
Cryptographic API algorithms are.  If a vulnerable algorithm is used,
such as a table-based implementation of AES, it may be possible for an
attacker to mount a side channel attack against the online system.
Side channel attacks may also be mounted against applications
consuming decrypted data.

After an encryption key has been provided, fscrypt is not designed to
hide the plaintext file contents or filenames from other users on the
same system, regardless of the visibility of the keyring key.
Instead, existing access control mechanisms such as file mode bits,
POSIX ACLs, LSMs, or mount namespaces should be used for this purpose.
Also note that as long as the encryption keys are \emph{anywhere} in
memory, an online attacker can necessarily compromise them by mounting
a physical attack or by exploiting any kernel security vulnerability
which provides an arbitrary memory read primitive.

While it is ostensibly possible to ``evict'' keys from the system,
recently accessed encrypted files will remain accessible at least
until the filesystem is unmounted or the VFS caches are dropped, e.g.
using \code{echo 2 \textgreater{} /proc/sys/vm/drop\_caches}.  Even after that, if the
RAM is compromised before being powered off, it will likely still be
possible to recover portions of the plaintext file contents, if not
some of the encryption keys as well.  (Since Linux v4.12, all
in-kernel keys related to fscrypt are sanitized before being freed.
However, userspace would need to do its part as well.)

Currently, fscrypt does not prevent a user from maliciously providing
an incorrect key for another user's existing encrypted files.  A
protection against this is planned.


\subsection{Key hierarchy}
\label{filesystems/fscrypt:key-hierarchy}

\subsubsection{Master Keys}
\label{filesystems/fscrypt:master-keys}
Each encrypted directory tree is protected by a \emph{master key}.  Master
keys can be up to 64 bytes long, and must be at least as long as the
greater of the key length needed by the contents and filenames
encryption modes being used.  For example, if AES-256-XTS is used for
contents encryption, the master key must be 64 bytes (512 bits).  Note
that the XTS mode is defined to require a key twice as long as that
required by the underlying block cipher.

To ``unlock'' an encrypted directory tree, userspace must provide the
appropriate master key.  There can be any number of master keys, each
of which protects any number of directory trees on any number of
filesystems.

Userspace should generate master keys either using a cryptographically
secure random number generator, or by using a KDF (Key Derivation
Function).  Note that whenever a KDF is used to ``stretch'' a
lower-entropy secret such as a passphrase, it is critical that a KDF
designed for this purpose be used, such as scrypt, PBKDF2, or Argon2.


\subsubsection{Per-file keys}
\label{filesystems/fscrypt:per-file-keys}
Master keys are not used to encrypt file contents or names directly.
Instead, a unique key is derived for each encrypted file, including
each regular file, directory, and symbolic link.  This has several
advantages:
\begin{itemize}
\item {} 
In cryptosystems, the same key material should never be used for
different purposes.  Using the master key as both an XTS key for
contents encryption and as a CTS-CBC key for filenames encryption
would violate this rule.

\item {} 
Per-file keys simplify the choice of IVs (Initialization Vectors)
for contents encryption.  Without per-file keys, to ensure IV
uniqueness both the inode and logical block number would need to be
encoded in the IVs.  This would make it impossible to renumber
inodes, which e.g. \code{resize2fs} can do when resizing an ext4
filesystem.  With per-file keys, it is sufficient to encode just the
logical block number in the IVs.

\item {} 
Per-file keys strengthen the encryption of filenames, where IVs are
reused out of necessity.  With a unique key per directory, IV reuse
is limited to within a single directory.

\item {} 
Per-file keys allow individual files to be securely erased simply by
securely erasing their keys.  (Not yet implemented.)

\end{itemize}

A KDF (Key Derivation Function) is used to derive per-file keys from
the master key.  This is done instead of wrapping a randomly-generated
key for each file because it reduces the size of the encryption xattr,
which for some filesystems makes the xattr more likely to fit in-line
in the filesystem's inode table.  With a KDF, only a 16-byte nonce is
required --- long enough to make key reuse extremely unlikely.  A
wrapped key, on the other hand, would need to be up to 64 bytes ---
the length of an AES-256-XTS key.  Furthermore, currently there is no
requirement to support unlocking a file with multiple alternative
master keys or to support rotating master keys.  Instead, the master
keys may be wrapped in userspace, e.g. as done by the \href{https://github.com/google/fscrypt}{fscrypt} tool.

The current KDF encrypts the master key using the 16-byte nonce as an
AES-128-ECB key.  The output is used as the derived key.  If the
output is longer than needed, then it is truncated to the needed
length.  Truncation is the norm for directories and symlinks, since
those use the CTS-CBC encryption mode which requires a key half as
long as that required by the XTS encryption mode.

Note: this KDF meets the primary security requirement, which is to
produce unique derived keys that preserve the entropy of the master
key, assuming that the master key is already a good pseudorandom key.
However, it is nonstandard and has some problems such as being
reversible, so it is generally considered to be a mistake!  It may be
replaced with HKDF or another more standard KDF in the future.


\subsection{Encryption modes and usage}
\label{filesystems/fscrypt:encryption-modes-and-usage}
fscrypt allows one encryption mode to be specified for file contents
and one encryption mode to be specified for filenames.  Different
directory trees are permitted to use different encryption modes.
Currently, the following pairs of encryption modes are supported:
\begin{itemize}
\item {} 
AES-256-XTS for contents and AES-256-CTS-CBC for filenames

\item {} 
AES-128-CBC for contents and AES-128-CTS-CBC for filenames

\end{itemize}

It is strongly recommended to use AES-256-XTS for contents encryption.
AES-128-CBC was added only for low-powered embedded devices with
crypto accelerators such as CAAM or CESA that do not support XTS.

New encryption modes can be added relatively easily, without changes
to individual filesystems.  However, authenticated encryption (AE)
modes are not currently supported because of the difficulty of dealing
with ciphertext expansion.

For file contents, each filesystem block is encrypted independently.
Currently, only the case where the filesystem block size is equal to
the system's page size (usually 4096 bytes) is supported.  With the
XTS mode of operation (recommended), the logical block number within
the file is used as the IV.  With the CBC mode of operation (not
recommended), ESSIV is used; specifically, the IV for CBC is the
logical block number encrypted with AES-256, where the AES-256 key is
the SHA-256 hash of the inode's data encryption key.

For filenames, the full filename is encrypted at once.  Because of the
requirements to retain support for efficient directory lookups and
filenames of up to 255 bytes, a constant initialization vector (IV) is
used.  However, each encrypted directory uses a unique key, which
limits IV reuse to within a single directory.  Note that IV reuse in
the context of CTS-CBC encryption means that when the original
filenames share a common prefix at least as long as the cipher block
size (16 bytes for AES), the corresponding encrypted filenames will
also share a common prefix.  This is undesirable; it may be fixed in
the future by switching to an encryption mode that is a strong
pseudorandom permutation on arbitrary-length messages, e.g. the HEH
(Hash-Encrypt-Hash) mode.

Since filenames are encrypted with the CTS-CBC mode of operation, the
plaintext and ciphertext filenames need not be multiples of the AES
block size, i.e. 16 bytes.  However, the minimum size that can be
encrypted is 16 bytes, so shorter filenames are NUL-padded to 16 bytes
before being encrypted.  In addition, to reduce leakage of filename
lengths via their ciphertexts, all filenames are NUL-padded to the
next 4, 8, 16, or 32-byte boundary (configurable).  32 is recommended
since this provides the best confidentiality, at the cost of making
directory entries consume slightly more space.  Note that since NUL
(\code{\textbackslash{}0}) is not otherwise a valid character in filenames, the padding
will never produce duplicate plaintexts.

Symbolic link targets are considered a type of filename and are
encrypted in the same way as filenames in directory entries.  Each
symlink also uses a unique key; hence, the hardcoded IV is not a
problem for symlinks.


\subsection{User API}
\label{filesystems/fscrypt:user-api}

\subsubsection{Setting an encryption policy}
\label{filesystems/fscrypt:setting-an-encryption-policy}
The FS\_IOC\_SET\_ENCRYPTION\_POLICY ioctl sets an encryption policy on an
empty directory or verifies that a directory or regular file already
has the specified encryption policy.  It takes in a pointer to a
\code{struct fscrypt\_policy}, defined as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}define FS\PYGZus{}KEY\PYGZus{}DESCRIPTOR\PYGZus{}SIZE  8

struct fscrypt\PYGZus{}policy \PYGZob{}
        \PYGZus{}\PYGZus{}u8 version;
        \PYGZus{}\PYGZus{}u8 contents\PYGZus{}encryption\PYGZus{}mode;
        \PYGZus{}\PYGZus{}u8 filenames\PYGZus{}encryption\PYGZus{}mode;
        \PYGZus{}\PYGZus{}u8 flags;
        \PYGZus{}\PYGZus{}u8 master\PYGZus{}key\PYGZus{}descriptor[FS\PYGZus{}KEY\PYGZus{}DESCRIPTOR\PYGZus{}SIZE];
\PYGZcb{};
\end{Verbatim}

This structure must be initialized as follows:
\begin{itemize}
\item {} 
\code{version} must be 0.

\item {} 
\code{contents\_encryption\_mode} and \code{filenames\_encryption\_mode} must
be set to constants from \code{\textless{}linux/fs.h\textgreater{}} which identify the
encryption modes to use.  If unsure, use
FS\_ENCRYPTION\_MODE\_AES\_256\_XTS (1) for \code{contents\_encryption\_mode}
and FS\_ENCRYPTION\_MODE\_AES\_256\_CTS (4) for
\code{filenames\_encryption\_mode}.

\item {} 
\code{flags} must be set to a value from \code{\textless{}linux/fs.h\textgreater{}} which
identifies the amount of NUL-padding to use when encrypting
filenames.  If unsure, use FS\_POLICY\_FLAGS\_PAD\_32 (0x3).

\item {} 
\code{master\_key\_descriptor} specifies how to find the master key in
the keyring; see {\hyperref[filesystems/fscrypt:adding\string-keys]{\emph{Adding keys}}}.  It is up to userspace to choose a
unique \code{master\_key\_descriptor} for each master key.  The e4crypt
and fscrypt tools use the first 8 bytes of
\code{SHA-512(SHA-512(master\_key))}, but this particular scheme is not
required.  Also, the master key need not be in the keyring yet when
FS\_IOC\_SET\_ENCRYPTION\_POLICY is executed.  However, it must be added
before any files can be created in the encrypted directory.

\end{itemize}

If the file is not yet encrypted, then FS\_IOC\_SET\_ENCRYPTION\_POLICY
verifies that the file is an empty directory.  If so, the specified
encryption policy is assigned to the directory, turning it into an
encrypted directory.  After that, and after providing the
corresponding master key as described in {\hyperref[filesystems/fscrypt:adding\string-keys]{\emph{Adding keys}}}, all regular
files, directories (recursively), and symlinks created in the
directory will be encrypted, inheriting the same encryption policy.
The filenames in the directory's entries will be encrypted as well.

Alternatively, if the file is already encrypted, then
FS\_IOC\_SET\_ENCRYPTION\_POLICY validates that the specified encryption
policy exactly matches the actual one.  If they match, then the ioctl
returns 0.  Otherwise, it fails with EEXIST.  This works on both
regular files and directories, including nonempty directories.

Note that the ext4 filesystem does not allow the root directory to be
encrypted, even if it is empty.  Users who want to encrypt an entire
filesystem with one key should consider using dm-crypt instead.

FS\_IOC\_SET\_ENCRYPTION\_POLICY can fail with the following errors:
\begin{itemize}
\item {} 
\code{EACCES}: the file is not owned by the process's uid, nor does the
process have the CAP\_FOWNER capability in a namespace with the file
owner's uid mapped

\item {} 
\code{EEXIST}: the file is already encrypted with an encryption policy
different from the one specified

\item {} 
\code{EINVAL}: an invalid encryption policy was specified (invalid
version, mode(s), or flags)

\item {} 
\code{ENOTDIR}: the file is unencrypted and is a regular file, not a
directory

\item {} 
\code{ENOTEMPTY}: the file is unencrypted and is a nonempty directory

\item {} 
\code{ENOTTY}: this type of filesystem does not implement encryption

\item {} 
\code{EOPNOTSUPP}: the kernel was not configured with encryption
support for this filesystem, or the filesystem superblock has not
had encryption enabled on it.  (For example, to use encryption on an
ext4 filesystem, CONFIG\_EXT4\_ENCRYPTION must be enabled in the
kernel config, and the superblock must have had the ``encrypt''
feature flag enabled using \code{tune2fs -O encrypt} or \code{mkfs.ext4 -O
encrypt}.)

\item {} 
\code{EPERM}: this directory may not be encrypted, e.g. because it is
the root directory of an ext4 filesystem

\item {} 
\code{EROFS}: the filesystem is readonly

\end{itemize}


\subsubsection{Getting an encryption policy}
\label{filesystems/fscrypt:getting-an-encryption-policy}
The FS\_IOC\_GET\_ENCRYPTION\_POLICY ioctl retrieves the \code{struct
fscrypt\_policy}, if any, for a directory or regular file.  See above
for the struct definition.  No additional permissions are required
beyond the ability to open the file.

FS\_IOC\_GET\_ENCRYPTION\_POLICY can fail with the following errors:
\begin{itemize}
\item {} 
\code{EINVAL}: the file is encrypted, but it uses an unrecognized
encryption context format

\item {} 
\code{ENODATA}: the file is not encrypted

\item {} 
\code{ENOTTY}: this type of filesystem does not implement encryption

\item {} 
\code{EOPNOTSUPP}: the kernel was not configured with encryption
support for this filesystem

\end{itemize}

Note: if you only need to know whether a file is encrypted or not, on
most filesystems it is also possible to use the FS\_IOC\_GETFLAGS ioctl
and check for FS\_ENCRYPT\_FL, or to use the statx() system call and
check for STATX\_ATTR\_ENCRYPTED in stx\_attributes.


\subsubsection{Getting the per-filesystem salt}
\label{filesystems/fscrypt:getting-the-per-filesystem-salt}
Some filesystems, such as ext4 and F2FS, also support the deprecated
ioctl FS\_IOC\_GET\_ENCRYPTION\_PWSALT.  This ioctl retrieves a randomly
generated 16-byte value stored in the filesystem superblock.  This
value is intended to used as a salt when deriving an encryption key
from a passphrase or other low-entropy user credential.

FS\_IOC\_GET\_ENCRYPTION\_PWSALT is deprecated.  Instead, prefer to
generate and manage any needed salt(s) in userspace.


\subsubsection{Adding keys}
\label{filesystems/fscrypt:adding-keys}
To provide a master key, userspace must add it to an appropriate
keyring using the add\_key() system call (see:
\code{Documentation/security/keys/core.rst}).  The key type must be
``logon''; keys of this type are kept in kernel memory and cannot be
read back by userspace.  The key description must be ``fscrypt:''
followed by the 16-character lower case hex representation of the
\code{master\_key\_descriptor} that was set in the encryption policy.  The
key payload must conform to the following structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}define FS\PYGZus{}MAX\PYGZus{}KEY\PYGZus{}SIZE 64

struct fscrypt\PYGZus{}key \PYGZob{}
        u32 mode;
        u8 raw[FS\PYGZus{}MAX\PYGZus{}KEY\PYGZus{}SIZE];
        u32 size;
\PYGZcb{};
\end{Verbatim}

\code{mode} is ignored; just set it to 0.  The actual key is provided in
\code{raw} with \code{size} indicating its size in bytes.  That is, the
bytes \code{raw{[}0..size-1{]}} (inclusive) are the actual key.

The key description prefix ``fscrypt:'' may alternatively be replaced
with a filesystem-specific prefix such as ``ext4:''.  However, the
filesystem-specific prefixes are deprecated and should not be used in
new programs.

There are several different types of keyrings in which encryption keys
may be placed, such as a session keyring, a user session keyring, or a
user keyring.  Each key must be placed in a keyring that is ``attached''
to all processes that might need to access files encrypted with it, in
the sense that request\_key() will find the key.  Generally, if only
processes belonging to a specific user need to access a given
encrypted directory and no session keyring has been installed, then
that directory's key should be placed in that user's user session
keyring or user keyring.  Otherwise, a session keyring should be
installed if needed, and the key should be linked into that session
keyring, or in a keyring linked into that session keyring.

Note: introducing the complex visibility semantics of keyrings here
was arguably a mistake --- especially given that by design, after any
process successfully opens an encrypted file (thereby setting up the
per-file key), possessing the keyring key is not actually required for
any process to read/write the file until its in-memory inode is
evicted.  In the future there probably should be a way to provide keys
directly to the filesystem instead, which would make the intended
semantics clearer.


\subsection{Access semantics}
\label{filesystems/fscrypt:access-semantics}

\subsubsection{With the key}
\label{filesystems/fscrypt:with-the-key}
With the encryption key, encrypted regular files, directories, and
symlinks behave very similarly to their unencrypted counterparts ---
after all, the encryption is intended to be transparent.  However,
astute users may notice some differences in behavior:
\begin{itemize}
\item {} 
Unencrypted files, or files encrypted with a different encryption
policy (i.e. different key, modes, or flags), cannot be renamed or
linked into an encrypted directory; see {\hyperref[filesystems/fscrypt:encryption\string-policy\string-enforcement]{\emph{Encryption policy
enforcement}}}.  Attempts to do so will fail with EPERM.  However,
encrypted files can be renamed within an encrypted directory, or
into an unencrypted directory.

\item {} 
Direct I/O is not supported on encrypted files.  Attempts to use
direct I/O on such files will fall back to buffered I/O.

\item {} 
The fallocate operations FALLOC\_FL\_COLLAPSE\_RANGE,
FALLOC\_FL\_INSERT\_RANGE, and FALLOC\_FL\_ZERO\_RANGE are not supported
on encrypted files and will fail with EOPNOTSUPP.

\item {} 
Online defragmentation of encrypted files is not supported.  The
EXT4\_IOC\_MOVE\_EXT and F2FS\_IOC\_MOVE\_RANGE ioctls will fail with
EOPNOTSUPP.

\item {} 
The ext4 filesystem does not support data journaling with encrypted
regular files.  It will fall back to ordered data mode instead.

\item {} 
DAX (Direct Access) is not supported on encrypted files.

\item {} 
The st\_size of an encrypted symlink will not necessarily give the
length of the symlink target as required by POSIX.  It will actually
give the length of the ciphertext, which will be slightly longer
than the plaintext due to NUL-padding and an extra 2-byte overhead.

\item {} 
The maximum length of an encrypted symlink is 2 bytes shorter than
the maximum length of an unencrypted symlink.  For example, on an
EXT4 filesystem with a 4K block size, unencrypted symlinks can be up
to 4095 bytes long, while encrypted symlinks can only be up to 4093
bytes long (both lengths excluding the terminating null).

\end{itemize}

Note that mmap \emph{is} supported.  This is possible because the pagecache
for an encrypted file contains the plaintext, not the ciphertext.


\subsubsection{Without the key}
\label{filesystems/fscrypt:without-the-key}
Some filesystem operations may be performed on encrypted regular
files, directories, and symlinks even before their encryption key has
been provided:
\begin{itemize}
\item {} 
File metadata may be read, e.g. using stat().

\item {} 
Directories may be listed, in which case the filenames will be
listed in an encoded form derived from their ciphertext.  The
current encoding algorithm is described in {\hyperref[filesystems/fscrypt:filename\string-hashing\string-and\string-encoding]{\emph{Filename hashing and
encoding}}}.  The algorithm is subject to change, but it is
guaranteed that the presented filenames will be no longer than
NAME\_MAX bytes, will not contain the \code{/} or \code{\textbackslash{}0} characters, and
will uniquely identify directory entries.

The \code{.} and \code{..} directory entries are special.  They are always
present and are not encrypted or encoded.

\item {} 
Files may be deleted.  That is, nondirectory files may be deleted
with unlink() as usual, and empty directories may be deleted with
rmdir() as usual.  Therefore, \code{rm} and \code{rm -r} will work as
expected.

\item {} 
Symlink targets may be read and followed, but they will be presented
in encrypted form, similar to filenames in directories.  Hence, they
are unlikely to point to anywhere useful.

\end{itemize}

Without the key, regular files cannot be opened or truncated.
Attempts to do so will fail with ENOKEY.  This implies that any
regular file operations that require a file descriptor, such as
read(), write(), mmap(), fallocate(), and ioctl(), are also forbidden.

Also without the key, files of any type (including directories) cannot
be created or linked into an encrypted directory, nor can a name in an
encrypted directory be the source or target of a rename, nor can an
O\_TMPFILE temporary file be created in an encrypted directory.  All
such operations will fail with ENOKEY.

It is not currently possible to backup and restore encrypted files
without the encryption key.  This would require special APIs which
have not yet been implemented.


\subsection{Encryption policy enforcement}
\label{filesystems/fscrypt:encryption-policy-enforcement}
After an encryption policy has been set on a directory, all regular
files, directories, and symbolic links created in that directory
(recursively) will inherit that encryption policy.  Special files ---
that is, named pipes, device nodes, and UNIX domain sockets --- will
not be encrypted.

Except for those special files, it is forbidden to have unencrypted
files, or files encrypted with a different encryption policy, in an
encrypted directory tree.  Attempts to link or rename such a file into
an encrypted directory will fail with EPERM.  This is also enforced
during -\textgreater{}lookup() to provide limited protection against offline
attacks that try to disable or downgrade encryption in known locations
where applications may later write sensitive data.  It is recommended
that systems implementing a form of ``verified boot'' take advantage of
this by validating all top-level encryption policies prior to access.


\subsection{Implementation details}
\label{filesystems/fscrypt:implementation-details}

\subsubsection{Encryption context}
\label{filesystems/fscrypt:encryption-context}
An encryption policy is represented on-disk by a \code{struct
fscrypt\_context}.  It is up to individual filesystems to decide where
to store it, but normally it would be stored in a hidden extended
attribute.  It should \emph{not} be exposed by the xattr-related system
calls such as getxattr() and setxattr() because of the special
semantics of the encryption xattr.  (In particular, there would be
much confusion if an encryption policy were to be added to or removed
from anything other than an empty directory.)  The struct is defined
as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}define FS\PYGZus{}KEY\PYGZus{}DESCRIPTOR\PYGZus{}SIZE  8
\PYGZsh{}define FS\PYGZus{}KEY\PYGZus{}DERIVATION\PYGZus{}NONCE\PYGZus{}SIZE 16

struct fscrypt\PYGZus{}context \PYGZob{}
        u8 format;
        u8 contents\PYGZus{}encryption\PYGZus{}mode;
        u8 filenames\PYGZus{}encryption\PYGZus{}mode;
        u8 flags;
        u8 master\PYGZus{}key\PYGZus{}descriptor[FS\PYGZus{}KEY\PYGZus{}DESCRIPTOR\PYGZus{}SIZE];
        u8 nonce[FS\PYGZus{}KEY\PYGZus{}DERIVATION\PYGZus{}NONCE\PYGZus{}SIZE];
\PYGZcb{};
\end{Verbatim}

Note that \code{struct fscrypt\_context} contains the same
information as \code{struct fscrypt\_policy} (see {\hyperref[filesystems/fscrypt:setting\string-an\string-encryption\string-policy]{\emph{Setting an
encryption policy}}}), except that \code{struct fscrypt\_context}
also contains a nonce.  The nonce is randomly generated by the kernel
and is used to derive the inode's encryption key as described in
{\hyperref[filesystems/fscrypt:per\string-file\string-keys]{\emph{Per-file keys}}}.


\subsubsection{Data path changes}
\label{filesystems/fscrypt:data-path-changes}
For the read path (-\textgreater{}readpage()) of regular files, filesystems can
read the ciphertext into the page cache and decrypt it in-place.  The
page lock must be held until decryption has finished, to prevent the
page from becoming visible to userspace prematurely.

For the write path (-\textgreater{}writepage()) of regular files, filesystems
cannot encrypt data in-place in the page cache, since the cached
plaintext must be preserved.  Instead, filesystems must encrypt into a
temporary buffer or ``bounce page'', then write out the temporary
buffer.  Some filesystems, such as UBIFS, already use temporary
buffers regardless of encryption.  Other filesystems, such as ext4 and
F2FS, have to allocate bounce pages specially for encryption.


\subsubsection{Filename hashing and encoding}
\label{filesystems/fscrypt:filename-hashing-and-encoding}
Modern filesystems accelerate directory lookups by using indexed
directories.  An indexed directory is organized as a tree keyed by
filename hashes.  When a -\textgreater{}lookup() is requested, the filesystem
normally hashes the filename being looked up so that it can quickly
find the corresponding directory entry, if any.

With encryption, lookups must be supported and efficient both with and
without the encryption key.  Clearly, it would not work to hash the
plaintext filenames, since the plaintext filenames are unavailable
without the key.  (Hashing the plaintext filenames would also make it
impossible for the filesystem's fsck tool to optimize encrypted
directories.)  Instead, filesystems hash the ciphertext filenames,
i.e. the bytes actually stored on-disk in the directory entries.  When
asked to do a -\textgreater{}lookup() with the key, the filesystem just encrypts
the user-supplied name to get the ciphertext.

Lookups without the key are more complicated.  The raw ciphertext may
contain the \code{\textbackslash{}0} and \code{/} characters, which are illegal in
filenames.  Therefore, readdir() must base64-encode the ciphertext for
presentation.  For most filenames, this works fine; on -\textgreater{}lookup(), the
filesystem just base64-decodes the user-supplied name to get back to
the raw ciphertext.

However, for very long filenames, base64 encoding would cause the
filename length to exceed NAME\_MAX.  To prevent this, readdir()
actually presents long filenames in an abbreviated form which encodes
a strong ``hash'' of the ciphertext filename, along with the optional
filesystem-specific hash(es) needed for directory lookups.  This
allows the filesystem to still, with a high degree of confidence, map
the filename given in -\textgreater{}lookup() back to a particular directory entry
that was previously listed by readdir().  See \code{struct
fscrypt\_digested\_name} in the source for more details.

Note that the precise way that filenames are presented to userspace
without the key is subject to change in the future.  It is only meant
as a way to temporarily present valid filenames so that commands like
\code{rm -r} work as expected on encrypted directories.



\renewcommand{\indexname}{Index}
\printindex
\end{document}
