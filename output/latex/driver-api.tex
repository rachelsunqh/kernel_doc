% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,8pt,english]{sphinxmanual}


\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }


	% Use some font with UTF-8 support with XeLaTeX
        \usepackage{fontspec}
        \setsansfont{DejaVu Serif}
        \setromanfont{DejaVu Sans}
        \setmonofont{DejaVu Sans Mono}

     \usepackage[margin=0.5in, top=1in, bottom=1in]{geometry}
        \usepackage{ifthen}

        % Put notes in color and let them be inside a table
	\definecolor{NoteColor}{RGB}{204,255,255}
	\definecolor{WarningColor}{RGB}{255,204,204}
	\definecolor{AttentionColor}{RGB}{255,255,204}
	\definecolor{ImportantColor}{RGB}{192,255,204}
	\definecolor{OtherColor}{RGB}{204,204,204}
        \newlength{\mynoticelength}
        \makeatletter\newenvironment{coloredbox}[1]{%
	   \setlength{\fboxrule}{1pt}
	   \setlength{\fboxsep}{7pt}
	   \setlength{\mynoticelength}{\linewidth}
	   \addtolength{\mynoticelength}{-2\fboxsep}
	   \addtolength{\mynoticelength}{-2\fboxrule}
           \begin{lrbox}{\@tempboxa}\begin{minipage}{\mynoticelength}}{\end{minipage}\end{lrbox}%
	   \ifthenelse%
	      {\equal{\py@noticetype}{note}}%
	      {\colorbox{NoteColor}{\usebox{\@tempboxa}}}%
	      {%
	         \ifthenelse%
	         {\equal{\py@noticetype}{warning}}%
	         {\colorbox{WarningColor}{\usebox{\@tempboxa}}}%
		 {%
	            \ifthenelse%
	            {\equal{\py@noticetype}{attention}}%
	            {\colorbox{AttentionColor}{\usebox{\@tempboxa}}}%
		    {%
	               \ifthenelse%
	               {\equal{\py@noticetype}{important}}%
	               {\colorbox{ImportantColor}{\usebox{\@tempboxa}}}%
	               {\colorbox{OtherColor}{\usebox{\@tempboxa}}}%
		    }%
		 }%
	      }%
        }\makeatother

        \makeatletter
        \renewenvironment{notice}[2]{%
          \def\py@noticetype{#1}
          \begin{coloredbox}{#1}
          \bf\it
          \par\strong{#2}
          \csname py@noticestart@#1\endcsname
        }
	{
          \csname py@noticeend@\py@noticetype\endcsname
          \end{coloredbox}
        }
	\makeatother

     

\title{The kernel driver API manual}
\date{March 08, 2018}
\release{4.16.0-rc4+}
\author{The kernel development community}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\setcounter{tocdepth}{1}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{driver-api/index::doc}


The kernel offers a wide variety of interfaces to support the development
of device drivers.  This document is an only somewhat organized collection
of some of those interfaces — it will hopefully get better over time!  The
available subsections can be seen below.

Table of contents


\chapter{Driver Basics}
\label{driver-api/basics:the-linux-driver-implementer-s-api-guide}\label{driver-api/basics::doc}\label{driver-api/basics:driver-basics}

\section{Driver Entry and Exit points}
\label{driver-api/basics:driver-entry-and-exit-points}\index{module\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.module_init}\pysiglinewithargsret{\bfcode{module\_init}}{\emph{x}}{}
driver initialization entry point

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{x}}] \leavevmode
function to be run at kernel boot time or module insertion

\end{description}

\textbf{Description}

{\hyperref[driver\string-api/basics:c.module_init]{\emph{\code{module\_init()}}}} will either be called during \code{do\_initcalls()} (if
builtin) or at module insertion time (if a module).  There can only
be one per module.
\index{module\_exit (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.module_exit}\pysiglinewithargsret{\bfcode{module\_exit}}{\emph{x}}{}
driver exit entry point

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{x}}] \leavevmode
function to be run when driver is removed

\end{description}

\textbf{Description}

{\hyperref[driver\string-api/basics:c.module_exit]{\emph{\code{module\_exit()}}}} will wrap the driver clean-up code
with \code{cleanup\_module()} when used with rmmod when
the driver is a module.  If the driver is statically
compiled into the kernel, {\hyperref[driver\string-api/basics:c.module_exit]{\emph{\code{module\_exit()}}}} has no effect.
There can only be one per module.


\section{Driver device table}
\label{driver-api/basics:driver-device-table}\index{usb\_device\_id (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.usb_device_id}\pysigline{struct \bfcode{usb\_device\_id}}
identifies USB devices for probing and hotplugging

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}device\PYGZus{}id \PYGZob{}
  \PYGZus{}\PYGZus{}u16 match\PYGZus{}flags;
  \PYGZus{}\PYGZus{}u16 idVendor;
  \PYGZus{}\PYGZus{}u16 idProduct;
  \PYGZus{}\PYGZus{}u16 bcdDevice\PYGZus{}lo;
  \PYGZus{}\PYGZus{}u16 bcdDevice\PYGZus{}hi;
  \PYGZus{}\PYGZus{}u8 bDeviceClass;
  \PYGZus{}\PYGZus{}u8 bDeviceSubClass;
  \PYGZus{}\PYGZus{}u8 bDeviceProtocol;
  \PYGZus{}\PYGZus{}u8 bInterfaceClass;
  \PYGZus{}\PYGZus{}u8 bInterfaceSubClass;
  \PYGZus{}\PYGZus{}u8 bInterfaceProtocol;
  \PYGZus{}\PYGZus{}u8 bInterfaceNumber;
  kernel\PYGZus{}ulong\PYGZus{}t driver\PYGZus{}info ;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{match\_flags}}] \leavevmode
Bit mask controlling which of the other fields are used to
match against new devices. Any field except for driver\_info may be
used, although some only make sense in conjunction with other fields.
This is usually set by a USB\_DEVICE\_*() macro, which sets all
other fields in this structure except for driver\_info.

\item[{\code{idVendor}}] \leavevmode
USB vendor ID for a device; numbers are assigned
by the USB forum to its members.

\item[{\code{idProduct}}] \leavevmode
Vendor-assigned product ID.

\item[{\code{bcdDevice\_lo}}] \leavevmode
Low end of range of vendor-assigned product version numbers.
This is also used to identify individual product versions, for
a range consisting of a single device.

\item[{\code{bcdDevice\_hi}}] \leavevmode
High end of version number range.  The range of product
versions is inclusive.

\item[{\code{bDeviceClass}}] \leavevmode
Class of device; numbers are assigned
by the USB forum.  Products may choose to implement classes,
or be vendor-specific.  Device classes specify behavior of all
the interfaces on a device.

\item[{\code{bDeviceSubClass}}] \leavevmode
Subclass of device; associated with bDeviceClass.

\item[{\code{bDeviceProtocol}}] \leavevmode
Protocol of device; associated with bDeviceClass.

\item[{\code{bInterfaceClass}}] \leavevmode
Class of interface; numbers are assigned
by the USB forum.  Products may choose to implement classes,
or be vendor-specific.  Interface classes specify behavior only
of a given interface; other interfaces may support other classes.

\item[{\code{bInterfaceSubClass}}] \leavevmode
Subclass of interface; associated with bInterfaceClass.

\item[{\code{bInterfaceProtocol}}] \leavevmode
Protocol of interface; associated with bInterfaceClass.

\item[{\code{bInterfaceNumber}}] \leavevmode
Number of interface; composite devices may use
fixed interface numbers to differentiate between vendor-specific
interfaces.

\item[{\code{driver\_info}}] \leavevmode
Holds information used by the driver.  Usually it holds
a pointer to a descriptor understood by the driver, or perhaps
device flags.

\end{description}

\textbf{Description}

In most cases, drivers will create a table of device IDs by using
{\hyperref[driver\string-api/usb/usb:c.USB_DEVICE]{\emph{\code{USB\_DEVICE()}}}}, or similar macros designed for that purpose.
They will then export it to userspace using \code{MODULE\_DEVICE\_TABLE()},
and provide it to the USB core through their usb\_driver structure.

See the {\hyperref[driver\string-api/usb/usb:c.usb_match_id]{\emph{\code{usb\_match\_id()}}}} function for information about how matches are
performed.  Briefly, you will normally use one of several macros to help
construct these entries.  Each entry you provide will either identify
one or more specific products, or will identify a class of products
which have agreed to behave the same.  You should put the more specific
matches towards the beginning of your table, so that driver\_info can
record quirks of specific products.
\index{mdio\_device\_id (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.mdio_device_id}\pysigline{struct \bfcode{mdio\_device\_id}}
identifies PHY devices on an MDIO/MII bus

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct mdio\PYGZus{}device\PYGZus{}id \PYGZob{}
  \PYGZus{}\PYGZus{}u32 phy\PYGZus{}id;
  \PYGZus{}\PYGZus{}u32 phy\PYGZus{}id\PYGZus{}mask;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{phy\_id}}] \leavevmode
The result of
(mdio\_read(\code{MII\_PHYSID1}) \textless{}\textless{} 16 \textbar{} mdio\_read(\code{PHYSID2})) \& \textbf{phy\_id\_mask}
for this PHY type

\item[{\code{phy\_id\_mask}}] \leavevmode
Defines the significant bits of \textbf{phy\_id}.  A value of 0
is used to terminate an array of struct mdio\_device\_id.

\end{description}
\index{amba\_id (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.amba_id}\pysigline{struct \bfcode{amba\_id}}
identifies a device on an AMBA bus

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct amba\PYGZus{}id \PYGZob{}
  unsigned int            id;
  unsigned int            mask;
  void *data;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{id}}] \leavevmode
The significant bits if the hardware device ID

\item[{\code{mask}}] \leavevmode
Bitmask specifying which bits of the id field are significant when
matching.  A driver binds to a device when ((hardware device ID) \& mask)
== id.

\item[{\code{data}}] \leavevmode
Private data used by the driver.

\end{description}
\index{mips\_cdmm\_device\_id (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.mips_cdmm_device_id}\pysigline{struct \bfcode{mips\_cdmm\_device\_id}}
identifies devices in MIPS CDMM bus

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct mips\PYGZus{}cdmm\PYGZus{}device\PYGZus{}id \PYGZob{}
  \PYGZus{}\PYGZus{}u8 type;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{type}}] \leavevmode
Device type identifier.

\end{description}
\index{mei\_cl\_device\_id (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.mei_cl_device_id}\pysigline{struct \bfcode{mei\_cl\_device\_id}}
MEI client device identifier

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct mei\PYGZus{}cl\PYGZus{}device\PYGZus{}id \PYGZob{}
  char name[MEI\PYGZus{}CL\PYGZus{}NAME\PYGZus{}SIZE];
  uuid\PYGZus{}le uuid;
  \PYGZus{}\PYGZus{}u8 version;
  kernel\PYGZus{}ulong\PYGZus{}t driver\PYGZus{}info;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
helper name

\item[{\code{uuid}}] \leavevmode
client uuid

\item[{\code{version}}] \leavevmode
client protocol version

\item[{\code{driver\_info}}] \leavevmode
information used by the driver.

\end{description}

\textbf{Description}

identifies mei client device by uuid and name
\index{rio\_device\_id (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.rio_device_id}\pysigline{struct \bfcode{rio\_device\_id}}
RIO device identifier

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct rio\PYGZus{}device\PYGZus{}id \PYGZob{}
  \PYGZus{}\PYGZus{}u16 did, vid;
  \PYGZus{}\PYGZus{}u16 asm\PYGZus{}did, asm\PYGZus{}vid;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{did}}] \leavevmode
RapidIO device ID

\item[{\code{vid}}] \leavevmode
RapidIO vendor ID

\item[{\code{asm\_did}}] \leavevmode
RapidIO assembly device ID

\item[{\code{asm\_vid}}] \leavevmode
RapidIO assembly vendor ID

\end{description}

\textbf{Description}

Identifies a RapidIO device based on both the device/vendor IDs and
the assembly device/vendor IDs.
\index{fsl\_mc\_device\_id (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.fsl_mc_device_id}\pysigline{struct \bfcode{fsl\_mc\_device\_id}}
MC object device identifier

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct fsl\PYGZus{}mc\PYGZus{}device\PYGZus{}id \PYGZob{}
  \PYGZus{}\PYGZus{}u16 vendor;
  const char obj\PYGZus{}type[16];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{vendor}}] \leavevmode
vendor ID

\item[{\code{obj\_type}}] \leavevmode
MC object type

\end{description}

\textbf{Description}

Type of entries in the ``device Id'' table for MC object devices supported by
a MC object device driver. The last entry of the table has vendor set to 0x0
\index{tb\_service\_id (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.tb_service_id}\pysigline{struct \bfcode{tb\_service\_id}}
Thunderbolt service identifiers

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct tb\PYGZus{}service\PYGZus{}id \PYGZob{}
  \PYGZus{}\PYGZus{}u32 match\PYGZus{}flags;
  char protocol\PYGZus{}key[8 + 1];
  \PYGZus{}\PYGZus{}u32 protocol\PYGZus{}id;
  \PYGZus{}\PYGZus{}u32 protocol\PYGZus{}version;
  \PYGZus{}\PYGZus{}u32 protocol\PYGZus{}revision;
  kernel\PYGZus{}ulong\PYGZus{}t driver\PYGZus{}data;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{match\_flags}}] \leavevmode
Flags used to match the structure

\item[{\code{protocol\_key}}] \leavevmode
Protocol key the service supports

\item[{\code{protocol\_id}}] \leavevmode
Protocol id the service supports

\item[{\code{protocol\_version}}] \leavevmode
Version of the protocol

\item[{\code{protocol\_revision}}] \leavevmode
Revision of the protocol software

\item[{\code{driver\_data}}] \leavevmode
Driver specific data

\end{description}

\textbf{Description}

Thunderbolt XDomain services are exposed as devices where each device
carries the protocol information the service supports. Thunderbolt
XDomain service drivers match against that information.


\section{Delaying, scheduling, and timer routines}
\label{driver-api/basics:delaying-scheduling-and-timer-routines}\index{prev\_cputime (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.prev_cputime}\pysigline{struct \bfcode{prev\_cputime}}
snapshot of system and user cputime

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct prev\PYGZus{}cputime \PYGZob{}
\PYGZsh{}ifndef CONFIG\PYGZus{}VIRT\PYGZus{}CPU\PYGZus{}ACCOUNTING\PYGZus{}NATIVE;
  u64 utime;
  u64 stime;
  raw\PYGZus{}spinlock\PYGZus{}t lock;
\PYGZsh{}endif;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{utime}}] \leavevmode
time spent in user mode

\item[{\code{stime}}] \leavevmode
time spent in system mode

\item[{\code{lock}}] \leavevmode
protects the above two fields

\end{description}

\textbf{Description}

Stores previous user/system time values such that we can guarantee
monotonicity.
\index{task\_cputime (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.task_cputime}\pysigline{struct \bfcode{task\_cputime}}
collected CPU time counts

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct task\PYGZus{}cputime \PYGZob{}
  u64 utime;
  u64 stime;
  unsigned long long              sum\PYGZus{}exec\PYGZus{}runtime;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{utime}}] \leavevmode
time spent in user mode, in nanoseconds

\item[{\code{stime}}] \leavevmode
time spent in kernel mode, in nanoseconds

\item[{\code{sum\_exec\_runtime}}] \leavevmode
total time spent on the CPU, in nanoseconds

\end{description}

\textbf{Description}

This structure groups together three kinds of CPU time that are tracked for
threads and thread groups.  Most things considering CPU time want to group
these counts together and treat all three of them in parallel.
\index{pid\_alive (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.pid_alive}\pysiglinewithargsret{int \bfcode{pid\_alive}}{const struct task\_struct *\emph{ p}}{}
check that a task structure is not stale

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct task\_struct * p}}] \leavevmode
Task structure to be checked.

\end{description}

\textbf{Description}

Test if a process is not yet dead (at most zombie state)
If pid\_alive fails, then pointers within the task structure
can be stale and must not be dereferenced.

\textbf{Return}

1 if the process is alive. 0 otherwise.
\index{is\_global\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.is_global_init}\pysiglinewithargsret{int \bfcode{is\_global\_init}}{struct task\_struct *\emph{ tsk}}{}
check if a task structure is init. Since init is free to have sub-threads we need to check tgid.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct task\_struct * tsk}}] \leavevmode
Task structure to be checked.

\end{description}

\textbf{Description}

Check if a task structure is the first user space task the kernel created.

\textbf{Return}

1 if the task structure is init. 0 otherwise.
\index{task\_nice (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.task_nice}\pysiglinewithargsret{int \bfcode{task\_nice}}{const struct task\_struct *\emph{ p}}{}
return the nice value of a given task.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct task\_struct * p}}] \leavevmode
the task in question.

\end{description}

\textbf{Return}

The nice value {[} -20 ... 0 ... 19 {]}.
\index{is\_idle\_task (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.is_idle_task}\pysiglinewithargsret{bool \bfcode{is\_idle\_task}}{const struct task\_struct *\emph{ p}}{}
is the specified task an idle task?

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct task\_struct * p}}] \leavevmode
the task in question.

\end{description}

\textbf{Return}

1 if \textbf{p} is an idle task. 0 otherwise.
\index{wake\_up\_process (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wake_up_process}\pysiglinewithargsret{int \bfcode{wake\_up\_process}}{struct task\_struct *\emph{ p}}{}
Wake up a specific process

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct task\_struct * p}}] \leavevmode
The process to be woken up.

\end{description}

\textbf{Description}

Attempt to wake up the nominated process and move it to the set of runnable
processes.

\textbf{Return}

1 if the process was woken up, 0 if it was already running.

It may be assumed that this function implies a write memory barrier before
changing the task state if and only if any tasks are woken up.
\index{preempt\_notifier\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.preempt_notifier_register}\pysiglinewithargsret{void \bfcode{preempt\_notifier\_register}}{struct preempt\_notifier *\emph{ notifier}}{}
tell me when current is being preempted \& rescheduled

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct preempt\_notifier * notifier}}] \leavevmode
notifier struct to register

\end{description}
\index{preempt\_notifier\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.preempt_notifier_unregister}\pysiglinewithargsret{void \bfcode{preempt\_notifier\_unregister}}{struct preempt\_notifier *\emph{ notifier}}{}
no longer interested in preemption notifications

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct preempt\_notifier * notifier}}] \leavevmode
notifier struct to unregister

\end{description}

\textbf{Description}

This is \emph{not} safe to call from within a preemption notifier.
\index{preempt\_schedule\_notrace (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.preempt_schedule_notrace}\pysiglinewithargsret{\_\_visible void \_\_sched notrace \bfcode{preempt\_schedule\_notrace}}{void}{}
preempt\_schedule called by tracing

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

The tracing infrastructure uses preempt\_enable\_notrace to prevent
recursion and tracing preempt enabling caused by the tracing
infrastructure itself. But as tracing can happen in areas coming
from userspace or just about to enter userspace, a preempt enable
can occur before \code{user\_exit()} is called. This will cause the scheduler
to be called when the system is still in usermode.

To prevent this, the preempt\_enable\_notrace will use this function
instead of \code{preempt\_schedule()} to exit user context if needed before
calling the scheduler.
\index{sched\_setscheduler (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.sched_setscheduler}\pysiglinewithargsret{int \bfcode{sched\_setscheduler}}{struct task\_struct *\emph{ p}, int\emph{ policy}, const struct sched\_param *\emph{ param}}{}
change the scheduling policy and/or RT priority of a thread.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct task\_struct * p}}] \leavevmode
the task in question.

\item[{\code{int policy}}] \leavevmode
new policy.

\item[{\code{const struct sched\_param * param}}] \leavevmode
structure containing the new RT priority.

\end{description}

\textbf{Return}

0 on success. An error code otherwise.

NOTE that the task may be already dead.
\index{sched\_setscheduler\_nocheck (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.sched_setscheduler_nocheck}\pysiglinewithargsret{int \bfcode{sched\_setscheduler\_nocheck}}{struct task\_struct *\emph{ p}, int\emph{ policy}, const struct sched\_param *\emph{ param}}{}
change the scheduling policy and/or RT priority of a thread from kernelspace.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct task\_struct * p}}] \leavevmode
the task in question.

\item[{\code{int policy}}] \leavevmode
new policy.

\item[{\code{const struct sched\_param * param}}] \leavevmode
structure containing the new RT priority.

\end{description}

\textbf{Description}

Just like sched\_setscheduler, only don't bother checking if the
current context has permission.  For example, this is needed in
\code{stop\_machine()}: we create temporary high priority worker threads,
but our caller might not have that capability.

\textbf{Return}

0 on success. An error code otherwise.
\index{yield (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.yield}\pysiglinewithargsret{void \_\_sched \bfcode{yield}}{void}{}
yield the current processor to other threads.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Do not ever use this function, there's a 99\% chance you're doing it wrong.

The scheduler is at all times free to pick the calling task as the most
eligible task to run, if removing the {\hyperref[driver\string-api/basics:c.yield]{\emph{\code{yield()}}}} call from your code breaks
it, its already broken.

Typical broken usage is:
\begin{description}
\item[{while (!event)}] \leavevmode
{\hyperref[driver\string-api/basics:c.yield]{\emph{\code{yield()}}}};

\end{description}

where one assumes that {\hyperref[driver\string-api/basics:c.yield]{\emph{\code{yield()}}}} will let `the other' process run that will
make event true. If the current task is a SCHED\_FIFO task that will never
happen. Never use {\hyperref[driver\string-api/basics:c.yield]{\emph{\code{yield()}}}} as a progress guarantee!!

If you want to use {\hyperref[driver\string-api/basics:c.yield]{\emph{\code{yield()}}}} to wait for something, use {\hyperref[driver\string-api/basics:c.wait_event]{\emph{\code{wait\_event()}}}}.
If you want to use {\hyperref[driver\string-api/basics:c.yield]{\emph{\code{yield()}}}} to be `nice' for others, use \code{cond\_resched()}.
If you still want to use {\hyperref[driver\string-api/basics:c.yield]{\emph{\code{yield()}}}}, do not!
\index{yield\_to (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.yield_to}\pysiglinewithargsret{int \_\_sched \bfcode{yield\_to}}{struct task\_struct *\emph{ p}, bool\emph{ preempt}}{}
yield the current processor to another thread in your thread group, or accelerate that thread toward the processor it's on.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct task\_struct * p}}] \leavevmode
target task

\item[{\code{bool preempt}}] \leavevmode
whether task preemption is allowed or not

\end{description}

\textbf{Description}

It's the caller's job to ensure that the target task struct
can't go away on us before we can do any checks.

\textbf{Return}
\begin{quote}

true (\textgreater{}0) if we indeed boosted the target task.
false (0) if we failed to boost the target.
-ESRCH if there's no task to yield to.
\end{quote}
\index{cpupri\_find (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.cpupri_find}\pysiglinewithargsret{int \bfcode{cpupri\_find}}{struct cpupri *\emph{ cp}, struct task\_struct *\emph{ p}, struct cpumask *\emph{ lowest\_mask}}{}
find the best (lowest-pri) CPU in the system

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct cpupri * cp}}] \leavevmode
The cpupri context

\item[{\code{struct task\_struct * p}}] \leavevmode
The task

\item[{\code{struct cpumask * lowest\_mask}}] \leavevmode
A mask to fill in with selected CPUs (or NULL)

\end{description}

\textbf{Note}

This function returns the recommended CPUs as calculated during the
current invocation.  By the time the call returns, the CPUs may have in
fact changed priorities any number of times.  While not ideal, it is not
an issue of correctness since the normal rebalancer logic will correct
any discrepancies created by racing against the uncertainty of the current
priority configuration.

\textbf{Return}

(int)bool - CPUs were found
\index{cpupri\_set (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.cpupri_set}\pysiglinewithargsret{void \bfcode{cpupri\_set}}{struct cpupri *\emph{ cp}, int\emph{ cpu}, int\emph{ newpri}}{}
update the cpu priority setting

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct cpupri * cp}}] \leavevmode
The cpupri context

\item[{\code{int cpu}}] \leavevmode
The target cpu

\item[{\code{int newpri}}] \leavevmode
The priority (INVALID-RT99) to assign to this CPU

\end{description}

\textbf{Note}

Assumes cpu\_rq(cpu)-\textgreater{}lock is locked

\textbf{Return}

(void)
\index{cpupri\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.cpupri_init}\pysiglinewithargsret{int \bfcode{cpupri\_init}}{struct cpupri *\emph{ cp}}{}
initialize the cpupri structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct cpupri * cp}}] \leavevmode
The cpupri context

\end{description}

\textbf{Return}

-ENOMEM on memory allocation failure.
\index{cpupri\_cleanup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.cpupri_cleanup}\pysiglinewithargsret{void \bfcode{cpupri\_cleanup}}{struct cpupri *\emph{ cp}}{}
clean up the cpupri structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct cpupri * cp}}] \leavevmode
The cpupri context

\end{description}
\index{update\_tg\_load\_avg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.update_tg_load_avg}\pysiglinewithargsret{void \bfcode{update\_tg\_load\_avg}}{struct cfs\_rq *\emph{ cfs\_rq}, int\emph{ force}}{}
update the tg's load avg

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct cfs\_rq * cfs\_rq}}] \leavevmode
the cfs\_rq whose avg changed

\item[{\code{int force}}] \leavevmode
update regardless of how small the difference

\end{description}

\textbf{Description}

This function `ensures': tg-\textgreater{}load\_avg := Sum tg-\textgreater{}cfs\_rq{[}{]}-\textgreater{}avg.load.
However, because tg-\textgreater{}load\_avg is a global value there are performance
considerations.

In order to avoid having to look at the other cfs\_rq's, we use a
differential update where we store the last value we propagated. This in
turn allows skipping updates if the differential is `small'.

Updating tg's load\_avg is necessary before \code{update\_cfs\_share()}.
\index{update\_cfs\_rq\_load\_avg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.update_cfs_rq_load_avg}\pysiglinewithargsret{int \bfcode{update\_cfs\_rq\_load\_avg}}{u64\emph{ now}, struct cfs\_rq *\emph{ cfs\_rq}}{}
update the cfs\_rq's load/util averages

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u64 now}}] \leavevmode
current time, as per \code{cfs\_rq\_clock\_task()}

\item[{\code{struct cfs\_rq * cfs\_rq}}] \leavevmode
cfs\_rq to update

\end{description}

\textbf{Description}

The cfs\_rq avg is the direct sum of all its entities (blocked and runnable)
avg. The immediate corollary is that all (fair) tasks must be attached, see
\code{post\_init\_entity\_util\_avg()}.

cfs\_rq-\textgreater{}avg is used for \code{task\_h\_load()} and \code{update\_cfs\_share()} for example.

Returns true if the load decayed or we removed load.

Since both these conditions indicate a changed cfs\_rq-\textgreater{}avg.load we should
call {\hyperref[driver\string-api/basics:c.update_tg_load_avg]{\emph{\code{update\_tg\_load\_avg()}}}} when this function returns true.
\index{attach\_entity\_load\_avg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.attach_entity_load_avg}\pysiglinewithargsret{void \bfcode{attach\_entity\_load\_avg}}{struct cfs\_rq *\emph{ cfs\_rq}, struct sched\_entity *\emph{ se}}{}
attach this entity to its cfs\_rq load avg

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct cfs\_rq * cfs\_rq}}] \leavevmode
cfs\_rq to attach to

\item[{\code{struct sched\_entity * se}}] \leavevmode
sched\_entity to attach

\end{description}

\textbf{Description}

Must call {\hyperref[driver\string-api/basics:c.update_cfs_rq_load_avg]{\emph{\code{update\_cfs\_rq\_load\_avg()}}}} before this, since we rely on
cfs\_rq-\textgreater{}avg.last\_update\_time being current.
\index{detach\_entity\_load\_avg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.detach_entity_load_avg}\pysiglinewithargsret{void \bfcode{detach\_entity\_load\_avg}}{struct cfs\_rq *\emph{ cfs\_rq}, struct sched\_entity *\emph{ se}}{}
detach this entity from its cfs\_rq load avg

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct cfs\_rq * cfs\_rq}}] \leavevmode
cfs\_rq to detach from

\item[{\code{struct sched\_entity * se}}] \leavevmode
sched\_entity to detach

\end{description}

\textbf{Description}

Must call {\hyperref[driver\string-api/basics:c.update_cfs_rq_load_avg]{\emph{\code{update\_cfs\_rq\_load\_avg()}}}} before this, since we rely on
cfs\_rq-\textgreater{}avg.last\_update\_time being current.
\index{cpu\_load\_update (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.cpu_load_update}\pysiglinewithargsret{void \bfcode{cpu\_load\_update}}{struct rq *\emph{ this\_rq}, unsigned long\emph{ this\_load}, unsigned long\emph{ pending\_updates}}{}
update the rq-\textgreater{}cpu\_load{[}{]} statistics

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rq * this\_rq}}] \leavevmode
The rq to update statistics for

\item[{\code{unsigned long this\_load}}] \leavevmode
The current load

\item[{\code{unsigned long pending\_updates}}] \leavevmode
The number of missed updates

\end{description}

\textbf{Description}

Update rq-\textgreater{}cpu\_load{[}{]} statistics. This function is usually called every
scheduler tick (TICK\_NSEC).

This function computes a decaying average:
\begin{quote}

load{[}i{]}' = (1 - 1/2\textasciicircum{}i) * load{[}i{]} + (1/2\textasciicircum{}i) * load
\end{quote}

Because of NOHZ it might not get called on every tick which gives need for
the \textbf{pending\_updates} argument.
\begin{quote}
\begin{description}
\item[{load{[}i{]}\_n = (1 - 1/2\textasciicircum{}i) * load{[}i{]}\_n-1 + (1/2\textasciicircum{}i) * load\_n-1}] \leavevmode
= A * load{[}i{]}\_n-1 + B ; A := (1 - 1/2\textasciicircum{}i), B := (1/2\textasciicircum{}i) * load
= A * (A * load{[}i{]}\_n-2 + B) + B
= A * (A * (A * load{[}i{]}\_n-3 + B) + B) + B
= A\textasciicircum{}3 * load{[}i{]}\_n-3 + (A\textasciicircum{}2 + A + 1) * B
= A\textasciicircum{}n * load{[}i{]}\_0 + (A\textasciicircum{}(n-1) + A\textasciicircum{}(n-2) + ... + 1) * B
= A\textasciicircum{}n * load{[}i{]}\_0 + ((1 - A\textasciicircum{}n) / (1 - A)) * B
= (1 - 1/2\textasciicircum{}i)\textasciicircum{}n * (load{[}i{]}\_0 - load) + load

\end{description}
\end{quote}

In the above we've assumed load\_n := load, which is true for NOHZ\_FULL as
any change in load would have resulted in the tick being turned back on.

For regular NOHZ, this reduces to:
\begin{quote}

load{[}i{]}\_n = (1 - 1/2\textasciicircum{}i)\textasciicircum{}n * load{[}i{]}\_0
\end{quote}

see \code{decay\_load\_misses()}. For NOHZ\_FULL we get to subtract and add the extra
term.
\index{get\_sd\_load\_idx (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.get_sd_load_idx}\pysiglinewithargsret{int \bfcode{get\_sd\_load\_idx}}{struct sched\_domain *\emph{ sd}, enum cpu\_idle\_type\emph{ idle}}{}
Obtain the load index for a given sched domain.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sched\_domain * sd}}] \leavevmode
The sched\_domain whose load\_idx is to be obtained.

\item[{\code{enum cpu\_idle\_type idle}}] \leavevmode
The idle status of the CPU for whose sd load\_idx is obtained.

\end{description}

\textbf{Return}

The load index.
\index{update\_sg\_lb\_stats (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.update_sg_lb_stats}\pysiglinewithargsret{void \bfcode{update\_sg\_lb\_stats}}{struct lb\_env *\emph{ env}, struct sched\_group *\emph{ group}, int\emph{ load\_idx}, int\emph{ local\_group}, struct sg\_lb\_stats *\emph{ sgs}, bool *\emph{ overload}}{}
Update sched\_group's statistics for load balancing.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct lb\_env * env}}] \leavevmode
The load balancing environment.

\item[{\code{struct sched\_group * group}}] \leavevmode
sched\_group whose statistics are to be updated.

\item[{\code{int load\_idx}}] \leavevmode
Load index of sched\_domain of this\_cpu for load calc.

\item[{\code{int local\_group}}] \leavevmode
Does group contain this\_cpu.

\item[{\code{struct sg\_lb\_stats * sgs}}] \leavevmode
variable to hold the statistics for this group.

\item[{\code{bool * overload}}] \leavevmode
Indicate more than one runnable task for any CPU.

\end{description}
\index{update\_sd\_pick\_busiest (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.update_sd_pick_busiest}\pysiglinewithargsret{bool \bfcode{update\_sd\_pick\_busiest}}{struct lb\_env *\emph{ env}, struct sd\_lb\_stats *\emph{ sds}, struct sched\_group *\emph{ sg}, struct sg\_lb\_stats *\emph{ sgs}}{}
return 1 on busiest group

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct lb\_env * env}}] \leavevmode
The load balancing environment.

\item[{\code{struct sd\_lb\_stats * sds}}] \leavevmode
sched\_domain statistics

\item[{\code{struct sched\_group * sg}}] \leavevmode
sched\_group candidate to be checked for being the busiest

\item[{\code{struct sg\_lb\_stats * sgs}}] \leavevmode
sched\_group statistics

\end{description}

\textbf{Description}

Determine if \textbf{sg} is a busier group than the previously selected
busiest group.

\textbf{Return}

\code{true} if \textbf{sg} is a busier group than the previously selected
busiest group. \code{false} otherwise.
\index{update\_sd\_lb\_stats (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.update_sd_lb_stats}\pysiglinewithargsret{void \bfcode{update\_sd\_lb\_stats}}{struct lb\_env *\emph{ env}, struct sd\_lb\_stats *\emph{ sds}}{}
Update sched\_domain's statistics for load balancing.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct lb\_env * env}}] \leavevmode
The load balancing environment.

\item[{\code{struct sd\_lb\_stats * sds}}] \leavevmode
variable to hold the statistics for this sched\_domain.

\end{description}
\index{check\_asym\_packing (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.check_asym_packing}\pysiglinewithargsret{int \bfcode{check\_asym\_packing}}{struct lb\_env *\emph{ env}, struct sd\_lb\_stats *\emph{ sds}}{}
Check to see if the group is packed into the sched domain.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct lb\_env * env}}] \leavevmode
The load balancing environment.

\item[{\code{struct sd\_lb\_stats * sds}}] \leavevmode
Statistics of the sched\_domain which is to be packed

\end{description}

\textbf{Description}

This is primarily intended to used at the sibling level.  Some
cores like POWER7 prefer to use lower numbered SMT threads.  In the
case of POWER7, it can move to lower SMT modes only when higher
threads are idle.  When in lower SMT modes, the threads will
perform better since they share less core resources.  Hence when we
have idle threads, we want them to be the higher ones.

This packing function is run on idle threads.  It checks to see if
the busiest CPU in this domain (core in the P7 case) has a higher
CPU number than the packing function is being run on.  Here we are
assuming lower CPU number will be equivalent to lower a SMT thread
number.

\textbf{Return}

1 when packing is required and a task should be moved to
this CPU.  The amount of the imbalance is returned in env-\textgreater{}imbalance.
\index{fix\_small\_imbalance (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.fix_small_imbalance}\pysiglinewithargsret{void \bfcode{fix\_small\_imbalance}}{struct lb\_env *\emph{ env}, struct sd\_lb\_stats *\emph{ sds}}{}
Calculate the minor imbalance that exists amongst the groups of a sched\_domain, during load balancing.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct lb\_env * env}}] \leavevmode
The load balancing environment.

\item[{\code{struct sd\_lb\_stats * sds}}] \leavevmode
Statistics of the sched\_domain whose imbalance is to be calculated.

\end{description}
\index{calculate\_imbalance (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.calculate_imbalance}\pysiglinewithargsret{void \bfcode{calculate\_imbalance}}{struct lb\_env *\emph{ env}, struct sd\_lb\_stats *\emph{ sds}}{}
Calculate the amount of imbalance present within the groups of a given sched\_domain during load balance.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct lb\_env * env}}] \leavevmode
load balance environment

\item[{\code{struct sd\_lb\_stats * sds}}] \leavevmode
statistics of the sched\_domain whose imbalance is to be calculated.

\end{description}
\index{find\_busiest\_group (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.find_busiest_group}\pysiglinewithargsret{struct sched\_group * \bfcode{find\_busiest\_group}}{struct lb\_env *\emph{ env}}{}
Returns the busiest group within the sched\_domain if there is an imbalance.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct lb\_env * env}}] \leavevmode
The load balancing environment.

\end{description}

\textbf{Description}

Also calculates the amount of weighted load which should be moved
to restore balance.

\textbf{Return}
\begin{itemize}
\item {} 
The busiest group if imbalance exists.

\end{itemize}
\index{DECLARE\_COMPLETION (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.DECLARE_COMPLETION}\pysiglinewithargsret{\bfcode{DECLARE\_COMPLETION}}{\emph{work}}{}
declare and initialize a completion structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{work}}] \leavevmode
identifier for the completion structure

\end{description}

\textbf{Description}

This macro declares and initializes a completion structure. Generally used
for static declarations. You should use the \_ONSTACK variant for automatic
variables.
\index{DECLARE\_COMPLETION\_ONSTACK (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.DECLARE_COMPLETION_ONSTACK}\pysiglinewithargsret{\bfcode{DECLARE\_COMPLETION\_ONSTACK}}{\emph{work}}{}
declare and initialize a completion structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{work}}] \leavevmode
identifier for the completion structure

\end{description}

\textbf{Description}

This macro declares and initializes a completion structure on the kernel
stack.
\index{\_\_init\_completion (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.__init_completion}\pysiglinewithargsret{void \bfcode{\_\_init\_completion}}{struct completion *\emph{ x}}{}
Initialize a dynamically allocated completion

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct completion * x}}] \leavevmode
pointer to completion structure that is to be initialized

\end{description}

\textbf{Description}

This inline function will initialize a dynamically created completion
structure.
\index{reinit\_completion (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.reinit_completion}\pysiglinewithargsret{void \bfcode{reinit\_completion}}{struct completion *\emph{ x}}{}
reinitialize a completion structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct completion * x}}] \leavevmode
pointer to completion structure that is to be reinitialized

\end{description}

\textbf{Description}

This inline function should be used to reinitialize a completion structure so it can
be reused. This is especially important after \code{complete\_all()} is used.
\index{\_\_round\_jiffies (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.__round_jiffies}\pysiglinewithargsret{unsigned long \bfcode{\_\_round\_jiffies}}{unsigned long\emph{ j}, int\emph{ cpu}}{}
function to round jiffies to a full second

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long j}}] \leavevmode
the time in (absolute) jiffies that should be rounded

\item[{\code{int cpu}}] \leavevmode
the processor number on which the timeout will happen

\end{description}

\textbf{Description}

{\hyperref[driver\string-api/basics:c.__round_jiffies]{\emph{\code{\_\_round\_jiffies()}}}} rounds an absolute time in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.

By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.

The exact rounding is skewed for each processor to avoid all
processors firing at the exact same time, which could lead
to lock contention or spurious cache line bouncing.

The return value is the rounded version of the \textbf{j} parameter.
\index{\_\_round\_jiffies\_relative (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.__round_jiffies_relative}\pysiglinewithargsret{unsigned long \bfcode{\_\_round\_jiffies\_relative}}{unsigned long\emph{ j}, int\emph{ cpu}}{}
function to round jiffies to a full second

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long j}}] \leavevmode
the time in (relative) jiffies that should be rounded

\item[{\code{int cpu}}] \leavevmode
the processor number on which the timeout will happen

\end{description}

\textbf{Description}

{\hyperref[driver\string-api/basics:c.__round_jiffies_relative]{\emph{\code{\_\_round\_jiffies\_relative()}}}} rounds a time delta  in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.

By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.

The exact rounding is skewed for each processor to avoid all
processors firing at the exact same time, which could lead
to lock contention or spurious cache line bouncing.

The return value is the rounded version of the \textbf{j} parameter.
\index{round\_jiffies (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.round_jiffies}\pysiglinewithargsret{unsigned long \bfcode{round\_jiffies}}{unsigned long\emph{ j}}{}
function to round jiffies to a full second

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long j}}] \leavevmode
the time in (absolute) jiffies that should be rounded

\end{description}

\textbf{Description}

{\hyperref[driver\string-api/basics:c.round_jiffies]{\emph{\code{round\_jiffies()}}}} rounds an absolute time in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.

By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.

The return value is the rounded version of the \textbf{j} parameter.
\index{round\_jiffies\_relative (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.round_jiffies_relative}\pysiglinewithargsret{unsigned long \bfcode{round\_jiffies\_relative}}{unsigned long\emph{ j}}{}
function to round jiffies to a full second

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long j}}] \leavevmode
the time in (relative) jiffies that should be rounded

\end{description}

\textbf{Description}

{\hyperref[driver\string-api/basics:c.round_jiffies_relative]{\emph{\code{round\_jiffies\_relative()}}}} rounds a time delta  in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.

By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.

The return value is the rounded version of the \textbf{j} parameter.
\index{\_\_round\_jiffies\_up (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.__round_jiffies_up}\pysiglinewithargsret{unsigned long \bfcode{\_\_round\_jiffies\_up}}{unsigned long\emph{ j}, int\emph{ cpu}}{}
function to round jiffies up to a full second

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long j}}] \leavevmode
the time in (absolute) jiffies that should be rounded

\item[{\code{int cpu}}] \leavevmode
the processor number on which the timeout will happen

\end{description}

\textbf{Description}

This is the same as {\hyperref[driver\string-api/basics:c.__round_jiffies]{\emph{\code{\_\_round\_jiffies()}}}} except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don't fire too
early.
\index{\_\_round\_jiffies\_up\_relative (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.__round_jiffies_up_relative}\pysiglinewithargsret{unsigned long \bfcode{\_\_round\_jiffies\_up\_relative}}{unsigned long\emph{ j}, int\emph{ cpu}}{}
function to round jiffies up to a full second

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long j}}] \leavevmode
the time in (relative) jiffies that should be rounded

\item[{\code{int cpu}}] \leavevmode
the processor number on which the timeout will happen

\end{description}

\textbf{Description}

This is the same as {\hyperref[driver\string-api/basics:c.__round_jiffies_relative]{\emph{\code{\_\_round\_jiffies\_relative()}}}} except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don't fire too
early.
\index{round\_jiffies\_up (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.round_jiffies_up}\pysiglinewithargsret{unsigned long \bfcode{round\_jiffies\_up}}{unsigned long\emph{ j}}{}
function to round jiffies up to a full second

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long j}}] \leavevmode
the time in (absolute) jiffies that should be rounded

\end{description}

\textbf{Description}

This is the same as {\hyperref[driver\string-api/basics:c.round_jiffies]{\emph{\code{round\_jiffies()}}}} except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don't fire too
early.
\index{round\_jiffies\_up\_relative (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.round_jiffies_up_relative}\pysiglinewithargsret{unsigned long \bfcode{round\_jiffies\_up\_relative}}{unsigned long\emph{ j}}{}
function to round jiffies up to a full second

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long j}}] \leavevmode
the time in (relative) jiffies that should be rounded

\end{description}

\textbf{Description}

This is the same as {\hyperref[driver\string-api/basics:c.round_jiffies_relative]{\emph{\code{round\_jiffies\_relative()}}}} except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don't fire too
early.
\index{init\_timer\_key (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.init_timer_key}\pysiglinewithargsret{void \bfcode{init\_timer\_key}}{struct timer\_list *\emph{ timer}, void (*func) (struct timer\_list\emph{ *}, unsigned int\emph{ flags}, const char *\emph{ name}, struct lock\_class\_key *\emph{ key}}{}
initialize a timer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct timer\_list * timer}}] \leavevmode
the timer to be initialized

\item[{\code{void (*)(struct timer\_list *) func}}] \leavevmode
timer callback function

\item[{\code{unsigned int flags}}] \leavevmode
timer flags

\item[{\code{const char * name}}] \leavevmode
name of the timer

\item[{\code{struct lock\_class\_key * key}}] \leavevmode
lockdep class key of the fake lock used for tracking timer
sync lock dependencies

\end{description}

\textbf{Description}

{\hyperref[driver\string-api/basics:c.init_timer_key]{\emph{\code{init\_timer\_key()}}}} must be done to a timer prior calling \emph{any} of the
other timer functions.
\index{mod\_timer\_pending (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.mod_timer_pending}\pysiglinewithargsret{int \bfcode{mod\_timer\_pending}}{struct timer\_list *\emph{ timer}, unsigned long\emph{ expires}}{}
modify a pending timer's timeout

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct timer\_list * timer}}] \leavevmode
the pending timer to be modified

\item[{\code{unsigned long expires}}] \leavevmode
new timeout in jiffies

\end{description}

\textbf{Description}

{\hyperref[driver\string-api/basics:c.mod_timer_pending]{\emph{\code{mod\_timer\_pending()}}}} is the same for pending timers as {\hyperref[driver\string-api/basics:c.mod_timer]{\emph{\code{mod\_timer()}}}},
but will not re-activate and modify already deleted timers.

It is useful for unserialized use of timers.
\index{mod\_timer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.mod_timer}\pysiglinewithargsret{int \bfcode{mod\_timer}}{struct timer\_list *\emph{ timer}, unsigned long\emph{ expires}}{}
modify a timer's timeout

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct timer\_list * timer}}] \leavevmode
the timer to be modified

\item[{\code{unsigned long expires}}] \leavevmode
new timeout in jiffies

\end{description}

\textbf{Description}

{\hyperref[driver\string-api/basics:c.mod_timer]{\emph{\code{mod\_timer()}}}} is a more efficient way to update the expire field of an
active timer (if the timer is inactive it will be activated)

mod\_timer(timer, expires) is equivalent to:
\begin{quote}

del\_timer(timer); timer-\textgreater{}expires = expires; add\_timer(timer);
\end{quote}

Note that if there are multiple unserialized concurrent users of the
same timer, then {\hyperref[driver\string-api/basics:c.mod_timer]{\emph{\code{mod\_timer()}}}} is the only safe way to modify the timeout,
since {\hyperref[driver\string-api/basics:c.add_timer]{\emph{\code{add\_timer()}}}} cannot modify an already running timer.

The function returns whether it has modified a pending timer or not.
(ie. {\hyperref[driver\string-api/basics:c.mod_timer]{\emph{\code{mod\_timer()}}}} of an inactive timer returns 0, {\hyperref[driver\string-api/basics:c.mod_timer]{\emph{\code{mod\_timer()}}}} of an
active timer returns 1.)
\index{timer\_reduce (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.timer_reduce}\pysiglinewithargsret{int \bfcode{timer\_reduce}}{struct timer\_list *\emph{ timer}, unsigned long\emph{ expires}}{}
Modify a timer's timeout if it would reduce the timeout

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct timer\_list * timer}}] \leavevmode
The timer to be modified

\item[{\code{unsigned long expires}}] \leavevmode
New timeout in jiffies

\end{description}

\textbf{Description}

{\hyperref[driver\string-api/basics:c.timer_reduce]{\emph{\code{timer\_reduce()}}}} is very similar to {\hyperref[driver\string-api/basics:c.mod_timer]{\emph{\code{mod\_timer()}}}}, except that it will only
modify a running timer if that would reduce the expiration time (it will
start a timer that isn't running).
\index{add\_timer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.add_timer}\pysiglinewithargsret{void \bfcode{add\_timer}}{struct timer\_list *\emph{ timer}}{}
start a timer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct timer\_list * timer}}] \leavevmode
the timer to be added

\end{description}

\textbf{Description}

The kernel will do a -\textgreater{}function(\textbf{timer}) callback from the
timer interrupt at the -\textgreater{}expires point in the future. The
current time is `jiffies'.

The timer's -\textgreater{}expires, -\textgreater{}function fields must be set prior calling this
function.

Timers with an -\textgreater{}expires field in the past will be executed in the next
timer tick.
\index{add\_timer\_on (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.add_timer_on}\pysiglinewithargsret{void \bfcode{add\_timer\_on}}{struct timer\_list *\emph{ timer}, int\emph{ cpu}}{}
start a timer on a particular CPU

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct timer\_list * timer}}] \leavevmode
the timer to be added

\item[{\code{int cpu}}] \leavevmode
the CPU to start it on

\end{description}

\textbf{Description}

This is not very scalable on SMP. Double adds are not possible.
\index{del\_timer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.del_timer}\pysiglinewithargsret{int \bfcode{del\_timer}}{struct timer\_list *\emph{ timer}}{}
deactivate a timer.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct timer\_list * timer}}] \leavevmode
the timer to be deactivated

\end{description}

\textbf{Description}

{\hyperref[driver\string-api/basics:c.del_timer]{\emph{\code{del\_timer()}}}} deactivates a timer - this works on both active and inactive
timers.

The function returns whether it has deactivated a pending timer or not.
(ie. {\hyperref[driver\string-api/basics:c.del_timer]{\emph{\code{del\_timer()}}}} of an inactive timer returns 0, {\hyperref[driver\string-api/basics:c.del_timer]{\emph{\code{del\_timer()}}}} of an
active timer returns 1.)
\index{try\_to\_del\_timer\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.try_to_del_timer_sync}\pysiglinewithargsret{int \bfcode{try\_to\_del\_timer\_sync}}{struct timer\_list *\emph{ timer}}{}
Try to deactivate a timer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct timer\_list * timer}}] \leavevmode
timer to delete

\end{description}

\textbf{Description}

This function tries to deactivate a timer. Upon successful (ret \textgreater{}= 0)
exit the timer is not queued and the handler is not running on any CPU.
\index{del\_timer\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.del_timer_sync}\pysiglinewithargsret{int \bfcode{del\_timer\_sync}}{struct timer\_list *\emph{ timer}}{}
deactivate a timer and wait for the handler to finish.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct timer\_list * timer}}] \leavevmode
the timer to be deactivated

\end{description}

\textbf{Description}

This function only differs from {\hyperref[driver\string-api/basics:c.del_timer]{\emph{\code{del\_timer()}}}} on SMP: besides deactivating
the timer it also makes sure the handler has finished executing on other
CPUs.

Synchronization rules: Callers must prevent restarting of the timer,
otherwise this function is meaningless. It must not be called from
interrupt contexts unless the timer is an irqsafe one. The caller must
not hold locks which would prevent completion of the timer's
handler. The timer's handler must not call {\hyperref[driver\string-api/basics:c.add_timer_on]{\emph{\code{add\_timer\_on()}}}}. Upon exit the
timer is not queued and the handler is not running on any CPU.

\textbf{Note}
\begin{description}
\item[{For !irqsafe timers, you must not hold locks that are held in}] \leavevmode\begin{quote}

interrupt context while calling this function. Even if the lock has
nothing to do with the timer in question.  Here's why:
\begin{quote}

CPU0                             CPU1
----                             ----
\begin{quote}

\textless{}SOFTIRQ\textgreater{}
\code{call\_timer\_fn()};
\begin{quote}

base-\textgreater{}running\_timer = mytimer;
\end{quote}
\end{quote}
\end{quote}
\end{quote}
\begin{description}
\item[{spin\_lock\_irq(somelock);}] \leavevmode\begin{description}
\item[{\textless{}IRQ\textgreater{}}] \leavevmode
spin\_lock(somelock);

\end{description}

\item[{del\_timer\_sync(mytimer);}] \leavevmode
while (base-\textgreater{}running\_timer == mytimer);

\end{description}

\end{description}

Now {\hyperref[driver\string-api/basics:c.del_timer_sync]{\emph{\code{del\_timer\_sync()}}}} will never return and never release somelock.
The interrupt on the other CPU is waiting to grab somelock but
it has interrupted the softirq that CPU0 is waiting to finish.

The function returns whether it has deactivated a pending timer or not.
\index{schedule\_timeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.schedule_timeout}\pysiglinewithargsret{signed long \_\_sched \bfcode{schedule\_timeout}}{signed long\emph{ timeout}}{}
sleep until timeout

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{signed long timeout}}] \leavevmode
timeout value in jiffies

\end{description}

\textbf{Description}

Make the current task sleep until \textbf{timeout} jiffies have
elapsed. The routine will return immediately unless
the current task state has been set (see \code{set\_current\_state()}).

You can set the task state as follows -

\code{TASK\_UNINTERRUPTIBLE} - at least \textbf{timeout} jiffies are guaranteed to
pass before the routine returns unless the current task is explicitly
woken up, (e.g. by {\hyperref[driver\string-api/basics:c.wake_up_process]{\emph{\code{wake\_up\_process()}}}})''.

\code{TASK\_INTERRUPTIBLE} - the routine may return early if a signal is
delivered to the current task or the current task is explicitly woken
up.

The current task state is guaranteed to be TASK\_RUNNING when this
routine returns.

Specifying a \textbf{timeout} value of \code{MAX\_SCHEDULE\_TIMEOUT} will schedule
the CPU away without a bound on the timeout. In this case the return
value will be \code{MAX\_SCHEDULE\_TIMEOUT}.

Returns 0 when the timer has expired otherwise the remaining time in
jiffies will be returned.  In all cases the return value is guaranteed
to be non-negative.
\index{msleep (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.msleep}\pysiglinewithargsret{void \bfcode{msleep}}{unsigned int\emph{ msecs}}{}
sleep safely even with waitqueue interruptions

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int msecs}}] \leavevmode
Time in milliseconds to sleep for

\end{description}
\index{msleep\_interruptible (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.msleep_interruptible}\pysiglinewithargsret{unsigned long \bfcode{msleep\_interruptible}}{unsigned int\emph{ msecs}}{}
sleep waiting for signals

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int msecs}}] \leavevmode
Time in milliseconds to sleep for

\end{description}
\index{usleep\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.usleep_range}\pysiglinewithargsret{void \_\_sched \bfcode{usleep\_range}}{unsigned long\emph{ min}, unsigned long\emph{ max}}{}
Sleep for an approximate time

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long min}}] \leavevmode
Minimum time in usecs to sleep

\item[{\code{unsigned long max}}] \leavevmode
Maximum time in usecs to sleep

\end{description}

\textbf{Description}

In non-atomic context where the exact wakeup time is flexible, use
{\hyperref[driver\string-api/basics:c.usleep_range]{\emph{\code{usleep\_range()}}}} instead of \code{udelay()}.  The sleep improves responsiveness
by avoiding the CPU-hogging busy-wait of \code{udelay()}, and the range reduces
power usage by allowing hrtimers to take advantage of an already-
scheduled interrupt instead of scheduling a new one just for this sleep.


\section{Wait queues and Wake events}
\label{driver-api/basics:wait-queues-and-wake-events}\index{waitqueue\_active (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.waitqueue_active}\pysiglinewithargsret{int \bfcode{waitqueue\_active}}{struct wait\_queue\_head *\emph{ wq\_head}}{}~\begin{itemize}
\item {} 
locklessly test for waiters on the queue

\end{itemize}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wait\_queue\_head * wq\_head}}] \leavevmode
the waitqueue to test for waiters

\end{description}

\textbf{Description}

returns true if the wait list is not empty

\textbf{NOTE}

this function is lockless and requires care, incorrect usage \_will\_
lead to sporadic and non-obvious failure.

Use either while holding wait\_queue\_head::lock or when used for wakeups
with an extra \code{smp\_mb()} like:
\begin{quote}

CPU0 - waker                    CPU1 - waiter
\begin{quote}

for (;;) \{
\end{quote}

\textbf{cond} = true;                     prepare\_to\_wait(\code{wq\_head}, \code{wait}, state);
\code{smp\_mb()};                         // \code{smp\_mb()} from \code{set\_current\_state()}
if (waitqueue\_active(wq\_head))         if (\textbf{cond})
\begin{quote}
\begin{description}
\item[{wake\_up(wq\_head);                      break;}] \leavevmode\begin{quote}

\code{schedule()};
\end{quote}

\}
finish\_wait(\code{wq\_head}, \code{wait});

\end{description}
\end{quote}
\end{quote}

Because without the explicit \code{smp\_mb()} it's possible for the
{\hyperref[driver\string-api/basics:c.waitqueue_active]{\emph{\code{waitqueue\_active()}}}} load to get hoisted over the \textbf{cond} store such that we'll
observe an empty wait list while the waiter might not observe \textbf{cond}.

Also note that this `optimization' trades a \code{spin\_lock()} for an \code{smp\_mb()},
which (when the lock is uncontended) are of roughly equal cost.
\index{wq\_has\_sleeper (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wq_has_sleeper}\pysiglinewithargsret{bool \bfcode{wq\_has\_sleeper}}{struct wait\_queue\_head *\emph{ wq\_head}}{}
check if there are any waiting processes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wait\_queue\_head * wq\_head}}] \leavevmode
wait queue head

\end{description}

\textbf{Description}

Returns true if wq\_head has waiting processes

Please refer to the comment for waitqueue\_active.
\index{wait\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event}\pysiglinewithargsret{\bfcode{wait\_event}}{\emph{wq\_head}, \emph{condition}}{}
sleep until a condition gets true

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq\_head}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_UNINTERRUPTIBLE) until the
\textbf{condition} evaluates to true. The \textbf{condition} is checked each time
the waitqueue \textbf{wq\_head} is woken up.

\code{wake\_up()} has to be called after changing any variable that could
change the result of the wait condition.
\index{wait\_event\_freezable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_freezable}\pysiglinewithargsret{\bfcode{wait\_event\_freezable}}{\emph{wq\_head}, \emph{condition}}{}
sleep (or freeze) until a condition gets true

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq\_head}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_INTERRUPTIBLE -- so as not to contribute
to system load) until the \textbf{condition} evaluates to true. The
\textbf{condition} is checked each time the waitqueue \textbf{wq\_head} is woken up.

\code{wake\_up()} has to be called after changing any variable that could
change the result of the wait condition.
\index{wait\_event\_timeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_timeout}\pysiglinewithargsret{\bfcode{wait\_event\_timeout}}{\emph{wq\_head}, \emph{condition}, \emph{timeout}}{}
sleep until a condition gets true or a timeout elapses

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq\_head}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\item[{\code{timeout}}] \leavevmode
timeout, in jiffies

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_UNINTERRUPTIBLE) until the
\textbf{condition} evaluates to true. The \textbf{condition} is checked each time
the waitqueue \textbf{wq\_head} is woken up.

\code{wake\_up()} has to be called after changing any variable that could
change the result of the wait condition.

\textbf{Return}

0 if the \textbf{condition} evaluated to \code{false} after the \textbf{timeout} elapsed,
1 if the \textbf{condition} evaluated to \code{true} after the \textbf{timeout} elapsed,
or the remaining jiffies (at least 1) if the \textbf{condition} evaluated
to \code{true} before the \textbf{timeout} elapsed.
\index{wait\_event\_cmd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_cmd}\pysiglinewithargsret{\bfcode{wait\_event\_cmd}}{\emph{wq\_head}, \emph{condition}, \emph{cmd1}, \emph{cmd2}}{}
sleep until a condition gets true

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq\_head}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\item[{\code{cmd1}}] \leavevmode
the command will be executed before sleep

\item[{\code{cmd2}}] \leavevmode
the command will be executed after sleep

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_UNINTERRUPTIBLE) until the
\textbf{condition} evaluates to true. The \textbf{condition} is checked each time
the waitqueue \textbf{wq\_head} is woken up.

\code{wake\_up()} has to be called after changing any variable that could
change the result of the wait condition.
\index{wait\_event\_interruptible (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_interruptible}\pysiglinewithargsret{\bfcode{wait\_event\_interruptible}}{\emph{wq\_head}, \emph{condition}}{}
sleep until a condition gets true

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq\_head}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_INTERRUPTIBLE) until the
\textbf{condition} evaluates to true or a signal is received.
The \textbf{condition} is checked each time the waitqueue \textbf{wq\_head} is woken up.

\code{wake\_up()} has to be called after changing any variable that could
change the result of the wait condition.

The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if \textbf{condition} evaluated to true.
\index{wait\_event\_interruptible\_timeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_interruptible_timeout}\pysiglinewithargsret{\bfcode{wait\_event\_interruptible\_timeout}}{\emph{wq\_head}, \emph{condition}, \emph{timeout}}{}
sleep until a condition gets true or a timeout elapses

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq\_head}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\item[{\code{timeout}}] \leavevmode
timeout, in jiffies

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_INTERRUPTIBLE) until the
\textbf{condition} evaluates to true or a signal is received.
The \textbf{condition} is checked each time the waitqueue \textbf{wq\_head} is woken up.

\code{wake\_up()} has to be called after changing any variable that could
change the result of the wait condition.

\textbf{Return}

0 if the \textbf{condition} evaluated to \code{false} after the \textbf{timeout} elapsed,
1 if the \textbf{condition} evaluated to \code{true} after the \textbf{timeout} elapsed,
the remaining jiffies (at least 1) if the \textbf{condition} evaluated
to \code{true} before the \textbf{timeout} elapsed, or -\code{ERESTARTSYS} if it was
interrupted by a signal.
\index{wait\_event\_hrtimeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_hrtimeout}\pysiglinewithargsret{\bfcode{wait\_event\_hrtimeout}}{\emph{wq\_head}, \emph{condition}, \emph{timeout}}{}
sleep until a condition gets true or a timeout elapses

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq\_head}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\item[{\code{timeout}}] \leavevmode
timeout, as a ktime\_t

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_UNINTERRUPTIBLE) until the
\textbf{condition} evaluates to true or a signal is received.
The \textbf{condition} is checked each time the waitqueue \textbf{wq\_head} is woken up.

\code{wake\_up()} has to be called after changing any variable that could
change the result of the wait condition.

The function returns 0 if \textbf{condition} became true, or -ETIME if the timeout
elapsed.
\index{wait\_event\_interruptible\_hrtimeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_interruptible_hrtimeout}\pysiglinewithargsret{\bfcode{wait\_event\_interruptible\_hrtimeout}}{\emph{wq}, \emph{condition}, \emph{timeout}}{}
sleep until a condition gets true or a timeout elapses

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\item[{\code{timeout}}] \leavevmode
timeout, as a ktime\_t

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_INTERRUPTIBLE) until the
\textbf{condition} evaluates to true or a signal is received.
The \textbf{condition} is checked each time the waitqueue \textbf{wq} is woken up.

\code{wake\_up()} has to be called after changing any variable that could
change the result of the wait condition.

The function returns 0 if \textbf{condition} became true, -ERESTARTSYS if it was
interrupted by a signal, or -ETIME if the timeout elapsed.
\index{wait\_event\_interruptible\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_interruptible_locked}\pysiglinewithargsret{\bfcode{wait\_event\_interruptible\_locked}}{\emph{wq}, \emph{condition}}{}
sleep until a condition gets true

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_INTERRUPTIBLE) until the
\textbf{condition} evaluates to true or a signal is received.
The \textbf{condition} is checked each time the waitqueue \textbf{wq} is woken up.

It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but \textbf{condition} testing is done while lock
is held and when this macro exits the lock is held.

The lock is locked/unlocked using \code{spin\_lock()}/\code{spin\_unlock()}
functions which must match the way they are locked/unlocked outside
of this macro.

\code{wake\_up\_locked()} has to be called after changing any variable that could
change the result of the wait condition.

The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if \textbf{condition} evaluated to true.
\index{wait\_event\_interruptible\_locked\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_interruptible_locked_irq}\pysiglinewithargsret{\bfcode{wait\_event\_interruptible\_locked\_irq}}{\emph{wq}, \emph{condition}}{}
sleep until a condition gets true

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_INTERRUPTIBLE) until the
\textbf{condition} evaluates to true or a signal is received.
The \textbf{condition} is checked each time the waitqueue \textbf{wq} is woken up.

It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but \textbf{condition} testing is done while lock
is held and when this macro exits the lock is held.

The lock is locked/unlocked using \code{spin\_lock\_irq()}/\code{spin\_unlock\_irq()}
functions which must match the way they are locked/unlocked outside
of this macro.

\code{wake\_up\_locked()} has to be called after changing any variable that could
change the result of the wait condition.

The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if \textbf{condition} evaluated to true.
\index{wait\_event\_interruptible\_exclusive\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_interruptible_exclusive_locked}\pysiglinewithargsret{\bfcode{wait\_event\_interruptible\_exclusive\_locked}}{\emph{wq}, \emph{condition}}{}
sleep exclusively until a condition gets true

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_INTERRUPTIBLE) until the
\textbf{condition} evaluates to true or a signal is received.
The \textbf{condition} is checked each time the waitqueue \textbf{wq} is woken up.

It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but \textbf{condition} testing is done while lock
is held and when this macro exits the lock is held.

The lock is locked/unlocked using \code{spin\_lock()}/\code{spin\_unlock()}
functions which must match the way they are locked/unlocked outside
of this macro.

The process is put on the wait queue with an WQ\_FLAG\_EXCLUSIVE flag
set thus when other process waits process on the list if this
process is awaken further processes are not considered.

\code{wake\_up\_locked()} has to be called after changing any variable that could
change the result of the wait condition.

The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if \textbf{condition} evaluated to true.
\index{wait\_event\_interruptible\_exclusive\_locked\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_interruptible_exclusive_locked_irq}\pysiglinewithargsret{\bfcode{wait\_event\_interruptible\_exclusive\_locked\_irq}}{\emph{wq}, \emph{condition}}{}
sleep until a condition gets true

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_INTERRUPTIBLE) until the
\textbf{condition} evaluates to true or a signal is received.
The \textbf{condition} is checked each time the waitqueue \textbf{wq} is woken up.

It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but \textbf{condition} testing is done while lock
is held and when this macro exits the lock is held.

The lock is locked/unlocked using \code{spin\_lock\_irq()}/\code{spin\_unlock\_irq()}
functions which must match the way they are locked/unlocked outside
of this macro.

The process is put on the wait queue with an WQ\_FLAG\_EXCLUSIVE flag
set thus when other process waits process on the list if this
process is awaken further processes are not considered.

\code{wake\_up\_locked()} has to be called after changing any variable that could
change the result of the wait condition.

The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if \textbf{condition} evaluated to true.
\index{wait\_event\_killable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_killable}\pysiglinewithargsret{\bfcode{wait\_event\_killable}}{\emph{wq\_head}, \emph{condition}}{}
sleep until a condition gets true

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq\_head}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_KILLABLE) until the
\textbf{condition} evaluates to true or a signal is received.
The \textbf{condition} is checked each time the waitqueue \textbf{wq\_head} is woken up.

\code{wake\_up()} has to be called after changing any variable that could
change the result of the wait condition.

The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if \textbf{condition} evaluated to true.
\index{wait\_event\_killable\_timeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_killable_timeout}\pysiglinewithargsret{\bfcode{wait\_event\_killable\_timeout}}{\emph{wq\_head}, \emph{condition}, \emph{timeout}}{}
sleep until a condition gets true or a timeout elapses

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq\_head}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\item[{\code{timeout}}] \leavevmode
timeout, in jiffies

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_KILLABLE) until the
\textbf{condition} evaluates to true or a kill signal is received.
The \textbf{condition} is checked each time the waitqueue \textbf{wq\_head} is woken up.

\code{wake\_up()} has to be called after changing any variable that could
change the result of the wait condition.

\textbf{Return}

0 if the \textbf{condition} evaluated to \code{false} after the \textbf{timeout} elapsed,
1 if the \textbf{condition} evaluated to \code{true} after the \textbf{timeout} elapsed,
the remaining jiffies (at least 1) if the \textbf{condition} evaluated
to \code{true} before the \textbf{timeout} elapsed, or -\code{ERESTARTSYS} if it was
interrupted by a kill signal.

Only kill signals interrupt this process.
\index{wait\_event\_lock\_irq\_cmd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_lock_irq_cmd}\pysiglinewithargsret{\bfcode{wait\_event\_lock\_irq\_cmd}}{\emph{wq\_head}, \emph{condition}, \emph{lock}, \emph{cmd}}{}
sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq\_head}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\item[{\code{lock}}] \leavevmode
a locked spinlock\_t, which will be released before cmd
and \code{schedule()} and reacquired afterwards.

\item[{\code{cmd}}] \leavevmode
a command which is invoked outside the critical section before
sleep

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_UNINTERRUPTIBLE) until the
\textbf{condition} evaluates to true. The \textbf{condition} is checked each time
the waitqueue \textbf{wq\_head} is woken up.

\code{wake\_up()} has to be called after changing any variable that could
change the result of the wait condition.

This is supposed to be called while holding the lock. The lock is
dropped before invoking the cmd and going to sleep and is reacquired
afterwards.
\index{wait\_event\_lock\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_lock_irq}\pysiglinewithargsret{\bfcode{wait\_event\_lock\_irq}}{\emph{wq\_head}, \emph{condition}, \emph{lock}}{}
sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq\_head}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\item[{\code{lock}}] \leavevmode
a locked spinlock\_t, which will be released before \code{schedule()}
and reacquired afterwards.

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_UNINTERRUPTIBLE) until the
\textbf{condition} evaluates to true. The \textbf{condition} is checked each time
the waitqueue \textbf{wq\_head} is woken up.

\code{wake\_up()} has to be called after changing any variable that could
change the result of the wait condition.

This is supposed to be called while holding the lock. The lock is
dropped before going to sleep and is reacquired afterwards.
\index{wait\_event\_interruptible\_lock\_irq\_cmd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_interruptible_lock_irq_cmd}\pysiglinewithargsret{\bfcode{wait\_event\_interruptible\_lock\_irq\_cmd}}{\emph{wq\_head}, \emph{condition}, \emph{lock}, \emph{cmd}}{}
sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq\_head}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\item[{\code{lock}}] \leavevmode
a locked spinlock\_t, which will be released before cmd and
\code{schedule()} and reacquired afterwards.

\item[{\code{cmd}}] \leavevmode
a command which is invoked outside the critical section before
sleep

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_INTERRUPTIBLE) until the
\textbf{condition} evaluates to true or a signal is received. The \textbf{condition} is
checked each time the waitqueue \textbf{wq\_head} is woken up.

\code{wake\_up()} has to be called after changing any variable that could
change the result of the wait condition.

This is supposed to be called while holding the lock. The lock is
dropped before invoking the cmd and going to sleep and is reacquired
afterwards.

The macro will return -ERESTARTSYS if it was interrupted by a signal
and 0 if \textbf{condition} evaluated to true.
\index{wait\_event\_interruptible\_lock\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_interruptible_lock_irq}\pysiglinewithargsret{\bfcode{wait\_event\_interruptible\_lock\_irq}}{\emph{wq\_head}, \emph{condition}, \emph{lock}}{}
sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq\_head}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\item[{\code{lock}}] \leavevmode
a locked spinlock\_t, which will be released before \code{schedule()}
and reacquired afterwards.

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_INTERRUPTIBLE) until the
\textbf{condition} evaluates to true or signal is received. The \textbf{condition} is
checked each time the waitqueue \textbf{wq\_head} is woken up.

\code{wake\_up()} has to be called after changing any variable that could
change the result of the wait condition.

This is supposed to be called while holding the lock. The lock is
dropped before going to sleep and is reacquired afterwards.

The macro will return -ERESTARTSYS if it was interrupted by a signal
and 0 if \textbf{condition} evaluated to true.
\index{wait\_event\_interruptible\_lock\_irq\_timeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_event_interruptible_lock_irq_timeout}\pysiglinewithargsret{\bfcode{wait\_event\_interruptible\_lock\_irq\_timeout}}{\emph{wq\_head}, \emph{condition}, \emph{lock}, \emph{timeout}}{}
sleep until a condition gets true or a timeout elapses. The condition is checked under the lock. This is expected to be called with the lock taken.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{wq\_head}}] \leavevmode
the waitqueue to wait on

\item[{\code{condition}}] \leavevmode
a C expression for the event to wait for

\item[{\code{lock}}] \leavevmode
a locked spinlock\_t, which will be released before \code{schedule()}
and reacquired afterwards.

\item[{\code{timeout}}] \leavevmode
timeout, in jiffies

\end{description}

\textbf{Description}

The process is put to sleep (TASK\_INTERRUPTIBLE) until the
\textbf{condition} evaluates to true or signal is received. The \textbf{condition} is
checked each time the waitqueue \textbf{wq\_head} is woken up.

\code{wake\_up()} has to be called after changing any variable that could
change the result of the wait condition.

This is supposed to be called while holding the lock. The lock is
dropped before going to sleep and is reacquired afterwards.

The function returns 0 if the \textbf{timeout} elapsed, -ERESTARTSYS if it
was interrupted by a signal, and the remaining jiffies otherwise
if the condition evaluated to true before the timeout elapsed.
\index{\_\_wake\_up (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.__wake_up}\pysiglinewithargsret{void \bfcode{\_\_wake\_up}}{struct wait\_queue\_head *\emph{ wq\_head}, unsigned int\emph{ mode}, int\emph{ nr\_exclusive}, void *\emph{ key}}{}
wake up threads blocked on a waitqueue.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wait\_queue\_head * wq\_head}}] \leavevmode
the waitqueue

\item[{\code{unsigned int mode}}] \leavevmode
which threads

\item[{\code{int nr\_exclusive}}] \leavevmode
how many wake-one or wake-many threads to wake up

\item[{\code{void * key}}] \leavevmode
is directly passed to the wakeup function

\end{description}

\textbf{Description}

It may be assumed that this function implies a write memory barrier before
changing the task state if and only if any tasks are woken up.
\index{\_\_wake\_up\_sync\_key (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.__wake_up_sync_key}\pysiglinewithargsret{void \bfcode{\_\_wake\_up\_sync\_key}}{struct wait\_queue\_head *\emph{ wq\_head}, unsigned int\emph{ mode}, int\emph{ nr\_exclusive}, void *\emph{ key}}{}
wake up threads blocked on a waitqueue.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wait\_queue\_head * wq\_head}}] \leavevmode
the waitqueue

\item[{\code{unsigned int mode}}] \leavevmode
which threads

\item[{\code{int nr\_exclusive}}] \leavevmode
how many wake-one or wake-many threads to wake up

\item[{\code{void * key}}] \leavevmode
opaque value to be passed to wakeup targets

\end{description}

\textbf{Description}

The sync wakeup differs that the waker knows that it will schedule
away soon, so while the target thread will be woken up, it will not
be migrated to another CPU - ie. the two threads are `synchronized'
with each other. This can prevent needless bouncing between CPUs.

On UP it can prevent extra preemption.

It may be assumed that this function implies a write memory barrier before
changing the task state if and only if any tasks are woken up.
\index{finish\_wait (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.finish_wait}\pysiglinewithargsret{void \bfcode{finish\_wait}}{struct wait\_queue\_head *\emph{ wq\_head}, struct wait\_queue\_entry *\emph{ wq\_entry}}{}
clean up after waiting in a queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wait\_queue\_head * wq\_head}}] \leavevmode
waitqueue waited on

\item[{\code{struct wait\_queue\_entry * wq\_entry}}] \leavevmode
wait descriptor

\end{description}

\textbf{Description}

Sets current thread back to running state and removes
the wait descriptor from the given waitqueue if still
queued.


\section{High-resolution timers}
\label{driver-api/basics:high-resolution-timers}\index{ktime\_set (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.ktime_set}\pysiglinewithargsret{ktime\_t \bfcode{ktime\_set}}{const s64\emph{ secs}, const unsigned long\emph{ nsecs}}{}
Set a ktime\_t variable from a seconds/nanoseconds value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const s64 secs}}] \leavevmode
seconds to set

\item[{\code{const unsigned long nsecs}}] \leavevmode
nanoseconds to set

\end{description}

\textbf{Return}

The ktime\_t representation of the value.
\index{ktime\_compare (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.ktime_compare}\pysiglinewithargsret{int \bfcode{ktime\_compare}}{const ktime\_t\emph{ cmp1}, const ktime\_t\emph{ cmp2}}{}
Compares two ktime\_t variables for less, greater or equal

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const ktime\_t cmp1}}] \leavevmode
comparable1

\item[{\code{const ktime\_t cmp2}}] \leavevmode
comparable2

\end{description}

\textbf{Return}
\begin{description}
\item[{...}] \leavevmode
cmp1  \textless{} cmp2: return \textless{}0
cmp1 == cmp2: return 0
cmp1  \textgreater{} cmp2: return \textgreater{}0

\end{description}
\index{ktime\_after (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.ktime_after}\pysiglinewithargsret{bool \bfcode{ktime\_after}}{const ktime\_t\emph{ cmp1}, const ktime\_t\emph{ cmp2}}{}
Compare if a ktime\_t value is bigger than another one.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const ktime\_t cmp1}}] \leavevmode
comparable1

\item[{\code{const ktime\_t cmp2}}] \leavevmode
comparable2

\end{description}

\textbf{Return}

true if cmp1 happened after cmp2.
\index{ktime\_before (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.ktime_before}\pysiglinewithargsret{bool \bfcode{ktime\_before}}{const ktime\_t\emph{ cmp1}, const ktime\_t\emph{ cmp2}}{}
Compare if a ktime\_t value is smaller than another one.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const ktime\_t cmp1}}] \leavevmode
comparable1

\item[{\code{const ktime\_t cmp2}}] \leavevmode
comparable2

\end{description}

\textbf{Return}

true if cmp1 happened before cmp2.
\index{ktime\_to\_timespec\_cond (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.ktime_to_timespec_cond}\pysiglinewithargsret{bool \bfcode{ktime\_to\_timespec\_cond}}{const ktime\_t\emph{ kt}, struct timespec *\emph{ ts}}{}
convert a ktime\_t variable to timespec format only if the variable contains data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const ktime\_t kt}}] \leavevmode
the ktime\_t variable to convert

\item[{\code{struct timespec * ts}}] \leavevmode
the timespec variable to store the result in

\end{description}

\textbf{Return}

\code{true} if there was a successful conversion, \code{false} if kt was 0.
\index{ktime\_to\_timespec64\_cond (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.ktime_to_timespec64_cond}\pysiglinewithargsret{bool \bfcode{ktime\_to\_timespec64\_cond}}{const ktime\_t\emph{ kt}, struct timespec64 *\emph{ ts}}{}
convert a ktime\_t variable to timespec64 format only if the variable contains data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const ktime\_t kt}}] \leavevmode
the ktime\_t variable to convert

\item[{\code{struct timespec64 * ts}}] \leavevmode
the timespec variable to store the result in

\end{description}

\textbf{Return}

\code{true} if there was a successful conversion, \code{false} if kt was 0.
\index{hrtimer (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.hrtimer}\pysigline{struct \bfcode{hrtimer}}
the basic hrtimer structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct hrtimer \PYGZob{}
  struct timerqueue\PYGZus{}node          node;
  ktime\PYGZus{}t \PYGZus{}softexpires;
  enum hrtimer\PYGZus{}restart            (*function)(struct hrtimer *);
  struct hrtimer\PYGZus{}clock\PYGZus{}base       *base;
  u8 state;
  u8 is\PYGZus{}rel;
  u8 is\PYGZus{}soft;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{node}}] \leavevmode
timerqueue node, which also manages node.expires,
the absolute expiry time in the hrtimers internal
representation. The time is related to the clock on
which the timer is based. Is setup by adding
slack to the \_softexpires value. For non range timers
identical to \_softexpires.

\item[{\code{\_softexpires}}] \leavevmode
the absolute earliest expiry time of the hrtimer.
The time which was given as expiry time when the timer
was armed.

\item[{\code{function}}] \leavevmode
timer expiry callback function

\item[{\code{base}}] \leavevmode
pointer to the timer base (per cpu and per clock)

\item[{\code{state}}] \leavevmode
state information (See bit values above)

\item[{\code{is\_rel}}] \leavevmode
Set if the timer was armed relative

\item[{\code{is\_soft}}] \leavevmode
Set if hrtimer will be expired in soft interrupt context.

\end{description}

\textbf{Description}

The hrtimer structure must be initialized by {\hyperref[driver\string-api/basics:c.hrtimer_init]{\emph{\code{hrtimer\_init()}}}}
\index{hrtimer\_sleeper (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.hrtimer_sleeper}\pysigline{struct \bfcode{hrtimer\_sleeper}}
simple sleeper structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct hrtimer\PYGZus{}sleeper \PYGZob{}
  struct hrtimer timer;
  struct task\PYGZus{}struct *task;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{timer}}] \leavevmode
embedded timer structure

\item[{\code{task}}] \leavevmode
task to wake up

\end{description}

\textbf{Description}

task is set to NULL, when the timer expires.
\index{hrtimer\_clock\_base (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.hrtimer_clock_base}\pysigline{struct \bfcode{hrtimer\_clock\_base}}
the timer base for a specific clock

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct hrtimer\PYGZus{}clock\PYGZus{}base \PYGZob{}
  struct hrtimer\PYGZus{}cpu\PYGZus{}base *cpu\PYGZus{}base;
  unsigned int            index;
  clockid\PYGZus{}t clockid;
  seqcount\PYGZus{}t seq;
  struct hrtimer          *running;
  struct timerqueue\PYGZus{}head  active;
  ktime\PYGZus{}t (*get\PYGZus{}time)(void);
  ktime\PYGZus{}t offset;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{cpu\_base}}] \leavevmode
per cpu clock base

\item[{\code{index}}] \leavevmode
clock type index for per\_cpu support when moving a
timer to a base on another cpu.

\item[{\code{clockid}}] \leavevmode
clock id for per\_cpu support

\item[{\code{seq}}] \leavevmode
seqcount around \_\_run\_hrtimer

\item[{\code{running}}] \leavevmode
pointer to the currently running hrtimer

\item[{\code{active}}] \leavevmode
red black tree root node for the active timers

\item[{\code{get\_time}}] \leavevmode
function to retrieve the current time of the clock

\item[{\code{offset}}] \leavevmode
offset of this clock to the monotonic base

\end{description}
\index{hrtimer\_cpu\_base (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.hrtimer_cpu_base}\pysigline{struct \bfcode{hrtimer\_cpu\_base}}
the per cpu clock bases

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct hrtimer\PYGZus{}cpu\PYGZus{}base \PYGZob{}
  raw\PYGZus{}spinlock\PYGZus{}t lock;
  unsigned int                    cpu;
  unsigned int                    active\PYGZus{}bases;
  unsigned int                    clock\PYGZus{}was\PYGZus{}set\PYGZus{}seq;
  unsigned int                    hres\PYGZus{}active             : 1,in\PYGZus{}hrtirq               : 1,hang\PYGZus{}detected           : 1, softirq\PYGZus{}activated       : 1;
\PYGZsh{}ifdef CONFIG\PYGZus{}HIGH\PYGZus{}RES\PYGZus{}TIMERS;
  unsigned int                    nr\PYGZus{}events;
  unsigned short                  nr\PYGZus{}retries;
  unsigned short                  nr\PYGZus{}hangs;
  unsigned int                    max\PYGZus{}hang\PYGZus{}time;
\PYGZsh{}endif;
  ktime\PYGZus{}t expires\PYGZus{}next;
  struct hrtimer                  *next\PYGZus{}timer;
  ktime\PYGZus{}t softirq\PYGZus{}expires\PYGZus{}next;
  struct hrtimer                  *softirq\PYGZus{}next\PYGZus{}timer;
  struct hrtimer\PYGZus{}clock\PYGZus{}base       clock\PYGZus{}base[HRTIMER\PYGZus{}MAX\PYGZus{}CLOCK\PYGZus{}BASES];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{lock}}] \leavevmode
lock protecting the base and associated clock bases
and timers

\item[{\code{cpu}}] \leavevmode
cpu number

\item[{\code{active\_bases}}] \leavevmode
Bitfield to mark bases with active timers

\item[{\code{clock\_was\_set\_seq}}] \leavevmode
Sequence counter of clock was set events

\item[{\code{hres\_active}}] \leavevmode
State of high resolution mode

\item[{\code{in\_hrtirq}}] \leavevmode
\code{hrtimer\_interrupt()} is currently executing

\item[{\code{hang\_detected}}] \leavevmode
The last hrtimer interrupt detected a hang

\item[{\code{softirq\_activated}}] \leavevmode
displays, if the softirq is raised - update of softirq
related settings is not required then.

\item[{\code{nr\_events}}] \leavevmode
Total number of hrtimer interrupt events

\item[{\code{nr\_retries}}] \leavevmode
Total number of hrtimer interrupt retries

\item[{\code{nr\_hangs}}] \leavevmode
Total number of hrtimer interrupt hangs

\item[{\code{max\_hang\_time}}] \leavevmode
Maximum time spent in hrtimer\_interrupt

\item[{\code{expires\_next}}] \leavevmode
absolute time of the next event, is required for remote
hrtimer enqueue; it is the total first expiry time (hard
and soft hrtimer are taken into account)

\item[{\code{next\_timer}}] \leavevmode
Pointer to the first expiring timer

\item[{\code{softirq\_expires\_next}}] \leavevmode
Time to check, if soft queues needs also to be expired

\item[{\code{softirq\_next\_timer}}] \leavevmode
Pointer to the first expiring softirq based timer

\item[{\code{clock\_base}}] \leavevmode
array of clock bases for this cpu

\end{description}

\textbf{Note}
\begin{description}
\item[{next\_timer is just an optimization for \code{\_\_remove\_hrtimer()}.}] \leavevmode
Do not dereference the pointer because it is not reliable on
cross cpu removals.

\end{description}
\index{hrtimer\_start (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.hrtimer_start}\pysiglinewithargsret{void \bfcode{hrtimer\_start}}{struct {\hyperref[driver\string-api/basics:c.hrtimer]{\emph{hrtimer}}} *\emph{ timer}, ktime\_t\emph{ tim}, const enum hrtimer\_mode\emph{ mode}}{}
(re)start an hrtimer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hrtimer * timer}}] \leavevmode
the timer to be added

\item[{\code{ktime\_t tim}}] \leavevmode
expiry time

\item[{\code{const enum hrtimer\_mode mode}}] \leavevmode
timer mode: absolute (HRTIMER\_MODE\_ABS) or
relative (HRTIMER\_MODE\_REL), and pinned (HRTIMER\_MODE\_PINNED);
softirq based mode is considered for debug purpose only!

\end{description}
\index{hrtimer\_forward\_now (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.hrtimer_forward_now}\pysiglinewithargsret{u64 \bfcode{hrtimer\_forward\_now}}{struct {\hyperref[driver\string-api/basics:c.hrtimer]{\emph{hrtimer}}} *\emph{ timer}, ktime\_t\emph{ interval}}{}
forward the timer expiry so it expires after now

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hrtimer * timer}}] \leavevmode
hrtimer to forward

\item[{\code{ktime\_t interval}}] \leavevmode
the interval to forward

\end{description}

\textbf{Description}

Forward the timer expiry so it will expire after the current time
of the hrtimer clock base. Returns the number of overruns.

Can be safely called from the callback function of \textbf{timer}. If
called from other contexts \textbf{timer} must neither be enqueued nor
running the callback and the caller needs to take care of
serialization.

\textbf{Note}

This only updates the timer expiry value and does not requeue
the timer.
\index{hrtimer\_forward (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.hrtimer_forward}\pysiglinewithargsret{u64 \bfcode{hrtimer\_forward}}{struct {\hyperref[driver\string-api/basics:c.hrtimer]{\emph{hrtimer}}} *\emph{ timer}, ktime\_t\emph{ now}, ktime\_t\emph{ interval}}{}
forward the timer expiry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hrtimer * timer}}] \leavevmode
hrtimer to forward

\item[{\code{ktime\_t now}}] \leavevmode
forward past this time

\item[{\code{ktime\_t interval}}] \leavevmode
the interval to forward

\end{description}

\textbf{Description}

Forward the timer expiry so it will expire in the future.
Returns the number of overruns.

Can be safely called from the callback function of \textbf{timer}. If
called from other contexts \textbf{timer} must neither be enqueued nor
running the callback and the caller needs to take care of
serialization.

\textbf{Note}

This only updates the timer expiry value and does not requeue
the timer.
\index{hrtimer\_start\_range\_ns (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.hrtimer_start_range_ns}\pysiglinewithargsret{void \bfcode{hrtimer\_start\_range\_ns}}{struct {\hyperref[driver\string-api/basics:c.hrtimer]{\emph{hrtimer}}} *\emph{ timer}, ktime\_t\emph{ tim}, u64\emph{ delta\_ns}, const enum hrtimer\_mode\emph{ mode}}{}
(re)start an hrtimer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hrtimer * timer}}] \leavevmode
the timer to be added

\item[{\code{ktime\_t tim}}] \leavevmode
expiry time

\item[{\code{u64 delta\_ns}}] \leavevmode
``slack'' range for the timer

\item[{\code{const enum hrtimer\_mode mode}}] \leavevmode
timer mode: absolute (HRTIMER\_MODE\_ABS) or
relative (HRTIMER\_MODE\_REL), and pinned (HRTIMER\_MODE\_PINNED);
softirq based mode is considered for debug purpose only!

\end{description}
\index{hrtimer\_try\_to\_cancel (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.hrtimer_try_to_cancel}\pysiglinewithargsret{int \bfcode{hrtimer\_try\_to\_cancel}}{struct {\hyperref[driver\string-api/basics:c.hrtimer]{\emph{hrtimer}}} *\emph{ timer}}{}
try to deactivate a timer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hrtimer * timer}}] \leavevmode
hrtimer to stop

\end{description}

\textbf{Return}
\begin{quote}

0 when the timer was not active
1 when the timer was active
\end{quote}
\begin{description}
\item[{-1 when the timer is currently executing the callback function and}] \leavevmode
cannot be stopped

\end{description}
\index{hrtimer\_cancel (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.hrtimer_cancel}\pysiglinewithargsret{int \bfcode{hrtimer\_cancel}}{struct {\hyperref[driver\string-api/basics:c.hrtimer]{\emph{hrtimer}}} *\emph{ timer}}{}
cancel a timer and wait for the handler to finish.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hrtimer * timer}}] \leavevmode
the timer to be cancelled

\end{description}

\textbf{Return}
\begin{quote}

0 when the timer was not active
1 when the timer was active
\end{quote}
\index{\_\_hrtimer\_get\_remaining (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.__hrtimer_get_remaining}\pysiglinewithargsret{ktime\_t \bfcode{\_\_hrtimer\_get\_remaining}}{const struct {\hyperref[driver\string-api/basics:c.hrtimer]{\emph{hrtimer}}} *\emph{ timer}, bool\emph{ adjust}}{}
get remaining time for the timer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct hrtimer * timer}}] \leavevmode
the timer to read

\item[{\code{bool adjust}}] \leavevmode
adjust relative timers when CONFIG\_TIME\_LOW\_RES=y

\end{description}
\index{hrtimer\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.hrtimer_init}\pysiglinewithargsret{void \bfcode{hrtimer\_init}}{struct {\hyperref[driver\string-api/basics:c.hrtimer]{\emph{hrtimer}}} *\emph{ timer}, clockid\_t\emph{ clock\_id}, enum hrtimer\_mode\emph{ mode}}{}
initialize a timer to the given clock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hrtimer * timer}}] \leavevmode
the timer to be initialized

\item[{\code{clockid\_t clock\_id}}] \leavevmode
the clock to be used

\item[{\code{enum hrtimer\_mode mode}}] \leavevmode
The modes which are relevant for intitialization:
HRTIMER\_MODE\_ABS, HRTIMER\_MODE\_REL, HRTIMER\_MODE\_ABS\_SOFT,
HRTIMER\_MODE\_REL\_SOFT

\end{description}

\textbf{Description}
\begin{quote}

The PINNED variants of the above can be handed in,
but the PINNED bit is ignored as pinning happens
when the hrtimer is started
\end{quote}
\index{schedule\_hrtimeout\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.schedule_hrtimeout_range}\pysiglinewithargsret{int \_\_sched \bfcode{schedule\_hrtimeout\_range}}{ktime\_t *\emph{ expires}, u64\emph{ delta}, const enum hrtimer\_mode\emph{ mode}}{}
sleep until timeout

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{ktime\_t * expires}}] \leavevmode
timeout value (ktime\_t)

\item[{\code{u64 delta}}] \leavevmode
slack in expires timeout (ktime\_t)

\item[{\code{const enum hrtimer\_mode mode}}] \leavevmode
timer mode

\end{description}

\textbf{Description}

Make the current task sleep until the given expiry time has
elapsed. The routine will return immediately unless
the current task state has been set (see \code{set\_current\_state()}).

The \textbf{delta} argument gives the kernel the freedom to schedule the
actual wakeup to a time that is both power and performance friendly.
The kernel give the normal best effort behavior for ``\textbf{expires**+**delta}'',
but may decide to fire the timer earlier, but no earlier than \textbf{expires}.

You can set the task state as follows -

\code{TASK\_UNINTERRUPTIBLE} - at least \textbf{timeout} time is guaranteed to
pass before the routine returns unless the current task is explicitly
woken up, (e.g. by {\hyperref[driver\string-api/basics:c.wake_up_process]{\emph{\code{wake\_up\_process()}}}}).

\code{TASK\_INTERRUPTIBLE} - the routine may return early if a signal is
delivered to the current task or the current task is explicitly woken
up.

The current task state is guaranteed to be TASK\_RUNNING when this
routine returns.

Returns 0 when the timer has expired. If the task was woken before the
timer expired by a signal (only possible in state TASK\_INTERRUPTIBLE) or
by an explicit wakeup, it returns -EINTR.
\index{schedule\_hrtimeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.schedule_hrtimeout}\pysiglinewithargsret{int \_\_sched \bfcode{schedule\_hrtimeout}}{ktime\_t *\emph{ expires}, const enum hrtimer\_mode\emph{ mode}}{}
sleep until timeout

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{ktime\_t * expires}}] \leavevmode
timeout value (ktime\_t)

\item[{\code{const enum hrtimer\_mode mode}}] \leavevmode
timer mode

\end{description}

\textbf{Description}

Make the current task sleep until the given expiry time has
elapsed. The routine will return immediately unless
the current task state has been set (see \code{set\_current\_state()}).

You can set the task state as follows -

\code{TASK\_UNINTERRUPTIBLE} - at least \textbf{timeout} time is guaranteed to
pass before the routine returns unless the current task is explicitly
woken up, (e.g. by {\hyperref[driver\string-api/basics:c.wake_up_process]{\emph{\code{wake\_up\_process()}}}}).

\code{TASK\_INTERRUPTIBLE} - the routine may return early if a signal is
delivered to the current task or the current task is explicitly woken
up.

The current task state is guaranteed to be TASK\_RUNNING when this
routine returns.

Returns 0 when the timer has expired. If the task was woken before the
timer expired by a signal (only possible in state TASK\_INTERRUPTIBLE) or
by an explicit wakeup, it returns -EINTR.


\section{Workqueues and Kevents}
\label{driver-api/basics:workqueues-and-kevents}\index{workqueue\_attrs (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.workqueue_attrs}\pysigline{struct \bfcode{workqueue\_attrs}}
A struct for workqueue attributes.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct workqueue\PYGZus{}attrs \PYGZob{}
  int nice;
  cpumask\PYGZus{}var\PYGZus{}t cpumask;
  bool no\PYGZus{}numa;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{nice}}] \leavevmode
nice level

\item[{\code{cpumask}}] \leavevmode
allowed CPUs

\item[{\code{no\_numa}}] \leavevmode
disable NUMA affinity

Unlike other fields, \code{no\_numa} isn't a property of a worker\_pool. It
only modifies how {\hyperref[driver\string-api/basics:c.apply_workqueue_attrs]{\emph{\code{apply\_workqueue\_attrs()}}}} select pools and thus
doesn't participate in pool hash calculations or equality comparisons.

\end{description}

\textbf{Description}

This can be used to change attributes of an unbound workqueue.
\index{work\_pending (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.work_pending}\pysiglinewithargsret{\bfcode{work\_pending}}{\emph{work}}{}
Find out whether a work item is currently pending

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{work}}] \leavevmode
The work item in question

\end{description}
\index{delayed\_work\_pending (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.delayed_work_pending}\pysiglinewithargsret{\bfcode{delayed\_work\_pending}}{\emph{w}}{}
Find out whether a delayable work item is currently pending

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{w}}] \leavevmode
The work item in question

\end{description}
\index{alloc\_workqueue (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.alloc_workqueue}\pysiglinewithargsret{\bfcode{alloc\_workqueue}}{\emph{fmt}, \emph{flags}, \emph{max\_active}, \emph{args...}}{}
allocate a workqueue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{fmt}}] \leavevmode
printf format for the name of the workqueue

\item[{\code{flags}}] \leavevmode
WQ\_* flags

\item[{\code{max\_active}}] \leavevmode
max in-flight work items, 0 for default

\item[{\code{args...}}] \leavevmode
args for \textbf{fmt}

\end{description}

\textbf{Description}

Allocate a workqueue with the specified parameters.  For detailed
information on WQ\_* flags, please refer to
Documentation/core-api/workqueue.rst.

The \_\_lock\_name macro dance is to guarantee that single lock\_class\_key
doesn't end up with different namesm, which isn't allowed by lockdep.

\textbf{Return}

Pointer to the allocated workqueue on success, \code{NULL} on failure.
\index{alloc\_ordered\_workqueue (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.alloc_ordered_workqueue}\pysiglinewithargsret{\bfcode{alloc\_ordered\_workqueue}}{\emph{fmt}, \emph{flags}, \emph{args...}}{}
allocate an ordered workqueue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{fmt}}] \leavevmode
printf format for the name of the workqueue

\item[{\code{flags}}] \leavevmode
WQ\_* flags (only WQ\_FREEZABLE and WQ\_MEM\_RECLAIM are meaningful)

\item[{\code{args...}}] \leavevmode
args for \textbf{fmt}

\end{description}

\textbf{Description}

Allocate an ordered workqueue.  An ordered workqueue executes at
most one work item at any given time in the queued order.  They are
implemented as unbound workqueues with \textbf{max\_active} of one.

\textbf{Return}

Pointer to the allocated workqueue on success, \code{NULL} on failure.
\index{queue\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.queue_work}\pysiglinewithargsret{bool \bfcode{queue\_work}}{struct workqueue\_struct *\emph{ wq}, struct work\_struct *\emph{ work}}{}
queue work on a workqueue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct workqueue\_struct * wq}}] \leavevmode
workqueue to use

\item[{\code{struct work\_struct * work}}] \leavevmode
work to queue

\end{description}

\textbf{Description}

Returns \code{false} if \textbf{work} was already on a queue, \code{true} otherwise.

We queue the work to the CPU on which it was submitted, but if the CPU dies
it can be processed by another CPU.
\index{queue\_delayed\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.queue_delayed_work}\pysiglinewithargsret{bool \bfcode{queue\_delayed\_work}}{struct workqueue\_struct *\emph{ wq}, struct delayed\_work *\emph{ dwork}, unsigned long\emph{ delay}}{}
queue work on a workqueue after delay

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct workqueue\_struct * wq}}] \leavevmode
workqueue to use

\item[{\code{struct delayed\_work * dwork}}] \leavevmode
delayable work to queue

\item[{\code{unsigned long delay}}] \leavevmode
number of jiffies to wait before queueing

\end{description}

\textbf{Description}

Equivalent to {\hyperref[driver\string-api/basics:c.queue_delayed_work_on]{\emph{\code{queue\_delayed\_work\_on()}}}} but tries to use the local CPU.
\index{mod\_delayed\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.mod_delayed_work}\pysiglinewithargsret{bool \bfcode{mod\_delayed\_work}}{struct workqueue\_struct *\emph{ wq}, struct delayed\_work *\emph{ dwork}, unsigned long\emph{ delay}}{}
modify delay of or queue a delayed work

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct workqueue\_struct * wq}}] \leavevmode
workqueue to use

\item[{\code{struct delayed\_work * dwork}}] \leavevmode
work to queue

\item[{\code{unsigned long delay}}] \leavevmode
number of jiffies to wait before queueing

\end{description}

\textbf{Description}

{\hyperref[driver\string-api/basics:c.mod_delayed_work_on]{\emph{\code{mod\_delayed\_work\_on()}}}} on local CPU.
\index{schedule\_work\_on (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.schedule_work_on}\pysiglinewithargsret{bool \bfcode{schedule\_work\_on}}{int\emph{ cpu}, struct work\_struct *\emph{ work}}{}
put work task on a specific cpu

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int cpu}}] \leavevmode
cpu to put the work task on

\item[{\code{struct work\_struct * work}}] \leavevmode
job to be done

\end{description}

\textbf{Description}

This puts a job on a specific cpu
\index{schedule\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.schedule_work}\pysiglinewithargsret{bool \bfcode{schedule\_work}}{struct work\_struct *\emph{ work}}{}
put work task in global workqueue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct work\_struct * work}}] \leavevmode
job to be done

\end{description}

\textbf{Description}

Returns \code{false} if \textbf{work} was already on the kernel-global workqueue and
\code{true} otherwise.

This puts a job in the kernel-global workqueue if it was not already
queued and leaves it in the same position on the kernel-global
workqueue otherwise.
\index{flush\_scheduled\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.flush_scheduled_work}\pysiglinewithargsret{void \bfcode{flush\_scheduled\_work}}{void}{}
ensure that any scheduled work has run to completion.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Forces execution of the kernel-global workqueue and blocks until its
completion.

Think twice before calling this function!  It's very easy to get into
trouble if you don't take great care.  Either of the following situations
will lead to deadlock:
\begin{quote}

One of the work items currently on the workqueue needs to acquire
a lock held by your code or its caller.

Your code is running in the context of a work routine.
\end{quote}

They will be detected by lockdep when they occur, but the first might not
occur very often.  It depends on what work items are on the workqueue and
what locks they need, which you have no control over.

In most situations flushing the entire workqueue is overkill; you merely
need to know that a particular work item isn't queued and isn't running.
In such cases you should use {\hyperref[driver\string-api/basics:c.cancel_delayed_work_sync]{\emph{\code{cancel\_delayed\_work\_sync()}}}} or
{\hyperref[driver\string-api/basics:c.cancel_work_sync]{\emph{\code{cancel\_work\_sync()}}}} instead.
\index{schedule\_delayed\_work\_on (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.schedule_delayed_work_on}\pysiglinewithargsret{bool \bfcode{schedule\_delayed\_work\_on}}{int\emph{ cpu}, struct delayed\_work *\emph{ dwork}, unsigned long\emph{ delay}}{}
queue work in global workqueue on CPU after delay

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int cpu}}] \leavevmode
cpu to use

\item[{\code{struct delayed\_work * dwork}}] \leavevmode
job to be done

\item[{\code{unsigned long delay}}] \leavevmode
number of jiffies to wait

\end{description}

\textbf{Description}

After waiting for a given time this puts a job in the kernel-global
workqueue on the specified CPU.
\index{schedule\_delayed\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.schedule_delayed_work}\pysiglinewithargsret{bool \bfcode{schedule\_delayed\_work}}{struct delayed\_work *\emph{ dwork}, unsigned long\emph{ delay}}{}
put work task in global workqueue after delay

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct delayed\_work * dwork}}] \leavevmode
job to be done

\item[{\code{unsigned long delay}}] \leavevmode
number of jiffies to wait or 0 for immediate execution

\end{description}

\textbf{Description}

After waiting for a given time this puts a job in the kernel-global
workqueue.
\index{queue\_work\_on (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.queue_work_on}\pysiglinewithargsret{bool \bfcode{queue\_work\_on}}{int\emph{ cpu}, struct workqueue\_struct *\emph{ wq}, struct work\_struct *\emph{ work}}{}
queue work on specific cpu

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int cpu}}] \leavevmode
CPU number to execute work on

\item[{\code{struct workqueue\_struct * wq}}] \leavevmode
workqueue to use

\item[{\code{struct work\_struct * work}}] \leavevmode
work to queue

\end{description}

\textbf{Description}

We queue the work to a specific CPU, the caller must ensure it
can't go away.

\textbf{Return}

\code{false} if \textbf{work} was already on a queue, \code{true} otherwise.
\index{queue\_delayed\_work\_on (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.queue_delayed_work_on}\pysiglinewithargsret{bool \bfcode{queue\_delayed\_work\_on}}{int\emph{ cpu}, struct workqueue\_struct *\emph{ wq}, struct delayed\_work *\emph{ dwork}, unsigned long\emph{ delay}}{}
queue work on specific CPU after delay

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int cpu}}] \leavevmode
CPU number to execute work on

\item[{\code{struct workqueue\_struct * wq}}] \leavevmode
workqueue to use

\item[{\code{struct delayed\_work * dwork}}] \leavevmode
work to queue

\item[{\code{unsigned long delay}}] \leavevmode
number of jiffies to wait before queueing

\end{description}

\textbf{Return}

\code{false} if \textbf{work} was already on a queue, \code{true} otherwise.  If
\textbf{delay} is zero and \textbf{dwork} is idle, it will be scheduled for immediate
execution.
\index{mod\_delayed\_work\_on (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.mod_delayed_work_on}\pysiglinewithargsret{bool \bfcode{mod\_delayed\_work\_on}}{int\emph{ cpu}, struct workqueue\_struct *\emph{ wq}, struct delayed\_work *\emph{ dwork}, unsigned long\emph{ delay}}{}
modify delay of or queue a delayed work on specific CPU

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int cpu}}] \leavevmode
CPU number to execute work on

\item[{\code{struct workqueue\_struct * wq}}] \leavevmode
workqueue to use

\item[{\code{struct delayed\_work * dwork}}] \leavevmode
work to queue

\item[{\code{unsigned long delay}}] \leavevmode
number of jiffies to wait before queueing

\end{description}

\textbf{Description}

If \textbf{dwork} is idle, equivalent to {\hyperref[driver\string-api/basics:c.queue_delayed_work_on]{\emph{\code{queue\_delayed\_work\_on()}}}}; otherwise,
modify \textbf{dwork}`s timer so that it expires after \textbf{delay}.  If \textbf{delay} is
zero, \textbf{work} is guaranteed to be scheduled immediately regardless of its
current state.

\textbf{Return}

\code{false} if \textbf{dwork} was idle and queued, \code{true} if \textbf{dwork} was
pending and its timer was modified.

This function is safe to call from any context including IRQ handler.
See \code{try\_to\_grab\_pending()} for details.
\index{flush\_workqueue (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.flush_workqueue}\pysiglinewithargsret{void \bfcode{flush\_workqueue}}{struct workqueue\_struct *\emph{ wq}}{}
ensure that any scheduled work has run to completion.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct workqueue\_struct * wq}}] \leavevmode
workqueue to flush

\end{description}

\textbf{Description}

This function sleeps until all work items which were queued on entry
have finished execution, but it is not livelocked by new incoming ones.
\index{drain\_workqueue (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.drain_workqueue}\pysiglinewithargsret{void \bfcode{drain\_workqueue}}{struct workqueue\_struct *\emph{ wq}}{}
drain a workqueue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct workqueue\_struct * wq}}] \leavevmode
workqueue to drain

\end{description}

\textbf{Description}

Wait until the workqueue becomes empty.  While draining is in progress,
only chain queueing is allowed.  IOW, only currently pending or running
work items on \textbf{wq} can queue further work items on it.  \textbf{wq} is flushed
repeatedly until it becomes empty.  The number of flushing is determined
by the depth of chaining and should be relatively short.  Whine if it
takes too long.
\index{flush\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.flush_work}\pysiglinewithargsret{bool \bfcode{flush\_work}}{struct work\_struct *\emph{ work}}{}
wait for a work to finish executing the last queueing instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct work\_struct * work}}] \leavevmode
the work to flush

\end{description}

\textbf{Description}

Wait until \textbf{work} has finished execution.  \textbf{work} is guaranteed to be idle
on return if it hasn't been requeued since flush started.

\textbf{Return}

\code{true} if {\hyperref[driver\string-api/basics:c.flush_work]{\emph{\code{flush\_work()}}}} waited for the work to finish execution,
\code{false} if it was already idle.
\index{cancel\_work\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.cancel_work_sync}\pysiglinewithargsret{bool \bfcode{cancel\_work\_sync}}{struct work\_struct *\emph{ work}}{}
cancel a work and wait for it to finish

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct work\_struct * work}}] \leavevmode
the work to cancel

\end{description}

\textbf{Description}

Cancel \textbf{work} and wait for its execution to finish.  This function
can be used even if the work re-queues itself or migrates to
another workqueue.  On return from this function, \textbf{work} is
guaranteed to be not pending or executing on any CPU.

cancel\_work\_sync(\code{delayed\_work-\textgreater{}work}) must not be used for
delayed\_work's.  Use {\hyperref[driver\string-api/basics:c.cancel_delayed_work_sync]{\emph{\code{cancel\_delayed\_work\_sync()}}}} instead.

The caller must ensure that the workqueue on which \textbf{work} was last
queued can't be destroyed before this function returns.

\textbf{Return}

\code{true} if \textbf{work} was pending, \code{false} otherwise.
\index{flush\_delayed\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.flush_delayed_work}\pysiglinewithargsret{bool \bfcode{flush\_delayed\_work}}{struct delayed\_work *\emph{ dwork}}{}
wait for a dwork to finish executing the last queueing

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct delayed\_work * dwork}}] \leavevmode
the delayed work to flush

\end{description}

\textbf{Description}

Delayed timer is cancelled and the pending work is queued for
immediate execution.  Like {\hyperref[driver\string-api/basics:c.flush_work]{\emph{\code{flush\_work()}}}}, this function only
considers the last queueing instance of \textbf{dwork}.

\textbf{Return}

\code{true} if {\hyperref[driver\string-api/basics:c.flush_work]{\emph{\code{flush\_work()}}}} waited for the work to finish execution,
\code{false} if it was already idle.
\index{cancel\_delayed\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.cancel_delayed_work}\pysiglinewithargsret{bool \bfcode{cancel\_delayed\_work}}{struct delayed\_work *\emph{ dwork}}{}
cancel a delayed work

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct delayed\_work * dwork}}] \leavevmode
delayed\_work to cancel

\end{description}

\textbf{Description}

Kill off a pending delayed\_work.

\textbf{Return}

\code{true} if \textbf{dwork} was pending and canceled; \code{false} if it wasn't
pending.

\textbf{Note}

The work callback function may still be running on return, unless
it returns \code{true} and the work doesn't re-arm itself.  Explicitly flush or
use {\hyperref[driver\string-api/basics:c.cancel_delayed_work_sync]{\emph{\code{cancel\_delayed\_work\_sync()}}}} to wait on it.

This function is safe to call from any context including IRQ handler.
\index{cancel\_delayed\_work\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.cancel_delayed_work_sync}\pysiglinewithargsret{bool \bfcode{cancel\_delayed\_work\_sync}}{struct delayed\_work *\emph{ dwork}}{}
cancel a delayed work and wait for it to finish

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct delayed\_work * dwork}}] \leavevmode
the delayed work cancel

\end{description}

\textbf{Description}

This is {\hyperref[driver\string-api/basics:c.cancel_work_sync]{\emph{\code{cancel\_work\_sync()}}}} for delayed works.

\textbf{Return}

\code{true} if \textbf{dwork} was pending, \code{false} otherwise.
\index{execute\_in\_process\_context (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.execute_in_process_context}\pysiglinewithargsret{int \bfcode{execute\_in\_process\_context}}{work\_func\_t\emph{ fn}, struct execute\_work *\emph{ ew}}{}
reliably execute the routine with user context

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{work\_func\_t fn}}] \leavevmode
the function to execute

\item[{\code{struct execute\_work * ew}}] \leavevmode
guaranteed storage for the execute work structure (must
be available when the work executes)

\end{description}

\textbf{Description}

Executes the function immediately if process context is available,
otherwise schedules the function for delayed execution.

\textbf{Return}
\begin{description}
\item[{0 - function was executed}] \leavevmode
1 - function was scheduled for execution

\end{description}
\index{apply\_workqueue\_attrs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.apply_workqueue_attrs}\pysiglinewithargsret{int \bfcode{apply\_workqueue\_attrs}}{struct workqueue\_struct *\emph{ wq}, const struct {\hyperref[driver\string-api/basics:c.workqueue_attrs]{\emph{workqueue\_attrs}}} *\emph{ attrs}}{}
apply new workqueue\_attrs to an unbound workqueue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct workqueue\_struct * wq}}] \leavevmode
the target workqueue

\item[{\code{const struct workqueue\_attrs * attrs}}] \leavevmode
the workqueue\_attrs to apply, allocated with \code{alloc\_workqueue\_attrs()}

\end{description}

\textbf{Description}

Apply \textbf{attrs} to an unbound workqueue \textbf{wq}.  Unless disabled, on NUMA
machines, this function maps a separate pwq to each NUMA node with
possibles CPUs in \textbf{attrs}-\textgreater{}cpumask so that work items are affine to the
NUMA node it was issued on.  Older pwqs are released as in-flight work
items finish.  Note that a work item which repeatedly requeues itself
back-to-back will stay on its current pwq.

Performs GFP\_KERNEL allocations.

\textbf{Return}

0 on success and -errno on failure.
\index{destroy\_workqueue (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.destroy_workqueue}\pysiglinewithargsret{void \bfcode{destroy\_workqueue}}{struct workqueue\_struct *\emph{ wq}}{}
safely terminate a workqueue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct workqueue\_struct * wq}}] \leavevmode
target workqueue

\end{description}

\textbf{Description}

Safely destroy a workqueue. All work currently pending will be done first.
\index{workqueue\_set\_max\_active (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.workqueue_set_max_active}\pysiglinewithargsret{void \bfcode{workqueue\_set\_max\_active}}{struct workqueue\_struct *\emph{ wq}, int\emph{ max\_active}}{}
adjust max\_active of a workqueue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct workqueue\_struct * wq}}] \leavevmode
target workqueue

\item[{\code{int max\_active}}] \leavevmode
new max\_active value.

\end{description}

\textbf{Description}

Set max\_active of \textbf{wq} to \textbf{max\_active}.

\textbf{Context}

Don't call from IRQ context.
\index{current\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.current_work}\pysiglinewithargsret{struct work\_struct * \bfcode{current\_work}}{void}{}
retrieve \code{current} task's work struct

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Determine if \code{current} task is a workqueue worker and what it's working on.
Useful to find out the context that the \code{current} task is running in.

\textbf{Return}

work struct if \code{current} task is a workqueue worker, \code{NULL} otherwise.
\index{workqueue\_congested (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.workqueue_congested}\pysiglinewithargsret{bool \bfcode{workqueue\_congested}}{int\emph{ cpu}, struct workqueue\_struct *\emph{ wq}}{}
test whether a workqueue is congested

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int cpu}}] \leavevmode
CPU in question

\item[{\code{struct workqueue\_struct * wq}}] \leavevmode
target workqueue

\end{description}

\textbf{Description}

Test whether \textbf{wq}`s cpu workqueue for \textbf{cpu} is congested.  There is
no synchronization around this function and the test result is
unreliable and only useful as advisory hints or for debugging.

If \textbf{cpu} is WORK\_CPU\_UNBOUND, the test is performed on the local CPU.
Note that both per-cpu and unbound workqueues may be associated with
multiple pool\_workqueues which have separate congested states.  A
workqueue being congested on one CPU doesn't mean the workqueue is also
contested on other CPUs / NUMA nodes.

\textbf{Return}

\code{true} if congested, \code{false} otherwise.
\index{work\_busy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.work_busy}\pysiglinewithargsret{unsigned int \bfcode{work\_busy}}{struct work\_struct *\emph{ work}}{}
test whether a work is currently pending or running

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct work\_struct * work}}] \leavevmode
the work to be tested

\end{description}

\textbf{Description}

Test whether \textbf{work} is currently pending or running.  There is no
synchronization around this function and the test result is
unreliable and only useful as advisory hints or for debugging.

\textbf{Return}

OR'd bitmask of WORK\_BUSY\_* bits.
\index{work\_on\_cpu (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.work_on_cpu}\pysiglinewithargsret{long \bfcode{work\_on\_cpu}}{int\emph{ cpu}, long (*fn) (void\emph{ *}, void *\emph{ arg}}{}
run a function in thread context on a particular cpu

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int cpu}}] \leavevmode
the cpu to run on

\item[{\code{long (*)(void *) fn}}] \leavevmode
the function to run

\item[{\code{void * arg}}] \leavevmode
the function arg

\end{description}

\textbf{Description}

It is up to the caller to ensure that the cpu doesn't go offline.
The caller must not hold any locks which would prevent \textbf{fn} from completing.

\textbf{Return}

The value \textbf{fn} returns.
\index{work\_on\_cpu\_safe (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.work_on_cpu_safe}\pysiglinewithargsret{long \bfcode{work\_on\_cpu\_safe}}{int\emph{ cpu}, long (*fn) (void\emph{ *}, void *\emph{ arg}}{}
run a function in thread context on a particular cpu

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int cpu}}] \leavevmode
the cpu to run on

\item[{\code{long (*)(void *) fn}}] \leavevmode
the function to run

\item[{\code{void * arg}}] \leavevmode
the function argument

\end{description}

\textbf{Description}

Disables CPU hotplug and calls {\hyperref[driver\string-api/basics:c.work_on_cpu]{\emph{\code{work\_on\_cpu()}}}}. The caller must not hold
any locks which would prevent \textbf{fn} from completing.

\textbf{Return}

The value \textbf{fn} returns.


\section{Internal Functions}
\label{driver-api/basics:internal-functions}\index{wait\_task\_stopped (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wait_task_stopped}\pysiglinewithargsret{int \bfcode{wait\_task\_stopped}}{struct wait\_opts *\emph{ wo}, int\emph{ ptrace}, struct task\_struct *\emph{ p}}{}
Wait for \code{TASK\_STOPPED} or \code{TASK\_TRACED}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wait\_opts * wo}}] \leavevmode
wait options

\item[{\code{int ptrace}}] \leavevmode
is the wait for ptrace

\item[{\code{struct task\_struct * p}}] \leavevmode
task to wait for

\end{description}

\textbf{Description}

Handle \code{sys\_wait4()} work for \code{p} in state \code{TASK\_STOPPED} or \code{TASK\_TRACED}.

\textbf{Context}

read\_lock(\code{tasklist\_lock}), which is released if return value is
non-zero.  Also, grabs and releases \textbf{p}-\textgreater{}sighand-\textgreater{}siglock.

\textbf{Return}

0 if wait condition didn't exist and search for other wait conditions
should continue.  Non-zero return, -errno on failure and \textbf{p}`s pid on
success, implies that tasklist\_lock is released and wait condition
search should terminate.
\index{task\_set\_jobctl\_pending (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.task_set_jobctl_pending}\pysiglinewithargsret{bool \bfcode{task\_set\_jobctl\_pending}}{struct task\_struct *\emph{ task}, unsigned long\emph{ mask}}{}
set jobctl pending bits

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct task\_struct * task}}] \leavevmode
target task

\item[{\code{unsigned long mask}}] \leavevmode
pending bits to set

\end{description}

\textbf{Description}

Clear \textbf{mask} from \textbf{task}-\textgreater{}jobctl.  \textbf{mask} must be subset of
\code{JOBCTL\_PENDING\_MASK} \textbar{} \code{JOBCTL\_STOP\_CONSUME} \textbar{} \code{JOBCTL\_STOP\_SIGMASK} \textbar{}
\code{JOBCTL\_TRAPPING}.  If stop signo is being set, the existing signo is
cleared.  If \textbf{task} is already being killed or exiting, this function
becomes noop.

\textbf{Context}

Must be called with \textbf{task}-\textgreater{}sighand-\textgreater{}siglock held.

\textbf{Return}

\code{true} if \textbf{mask} is set, \code{false} if made noop because \textbf{task} was dying.
\index{task\_clear\_jobctl\_trapping (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.task_clear_jobctl_trapping}\pysiglinewithargsret{void \bfcode{task\_clear\_jobctl\_trapping}}{struct task\_struct *\emph{ task}}{}
clear jobctl trapping bit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct task\_struct * task}}] \leavevmode
target task

\end{description}

\textbf{Description}

If JOBCTL\_TRAPPING is set, a ptracer is waiting for us to enter TRACED.
Clear it and wake up the ptracer.  Note that we don't need any further
locking.  \textbf{task}-\textgreater{}siglock guarantees that \textbf{task}-\textgreater{}parent points to the
ptracer.

\textbf{Context}

Must be called with \textbf{task}-\textgreater{}sighand-\textgreater{}siglock held.
\index{task\_clear\_jobctl\_pending (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.task_clear_jobctl_pending}\pysiglinewithargsret{void \bfcode{task\_clear\_jobctl\_pending}}{struct task\_struct *\emph{ task}, unsigned long\emph{ mask}}{}
clear jobctl pending bits

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct task\_struct * task}}] \leavevmode
target task

\item[{\code{unsigned long mask}}] \leavevmode
pending bits to clear

\end{description}

\textbf{Description}

Clear \textbf{mask} from \textbf{task}-\textgreater{}jobctl.  \textbf{mask} must be subset of
\code{JOBCTL\_PENDING\_MASK}.  If \code{JOBCTL\_STOP\_PENDING} is being cleared, other
STOP bits are cleared together.

If clearing of \textbf{mask} leaves no stop or trap pending, this function calls
{\hyperref[driver\string-api/basics:c.task_clear_jobctl_trapping]{\emph{\code{task\_clear\_jobctl\_trapping()}}}}.

\textbf{Context}

Must be called with \textbf{task}-\textgreater{}sighand-\textgreater{}siglock held.
\index{task\_participate\_group\_stop (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.task_participate_group_stop}\pysiglinewithargsret{bool \bfcode{task\_participate\_group\_stop}}{struct task\_struct *\emph{ task}}{}
participate in a group stop

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct task\_struct * task}}] \leavevmode
task participating in a group stop

\end{description}

\textbf{Description}

\textbf{task} has \code{JOBCTL\_STOP\_PENDING} set and is participating in a group stop.
Group stop states are cleared and the group stop count is consumed if
\code{JOBCTL\_STOP\_CONSUME} was set.  If the consumption completes the group
stop, the appropriate {\color{red}\bfseries{}{}`{}`}SIGNAL\_{}`{}`* flags are set.

\textbf{Context}

Must be called with \textbf{task}-\textgreater{}sighand-\textgreater{}siglock held.

\textbf{Return}

\code{true} if group stop completion should be notified to the parent, \code{false}
otherwise.
\index{ptrace\_trap\_notify (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.ptrace_trap_notify}\pysiglinewithargsret{void \bfcode{ptrace\_trap\_notify}}{struct task\_struct *\emph{ t}}{}
schedule trap to notify ptracer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct task\_struct * t}}] \leavevmode
tracee wanting to notify tracer

\end{description}

\textbf{Description}

This function schedules sticky ptrace trap which is cleared on the next
TRAP\_STOP to notify ptracer of an event.  \textbf{t} must have been seized by
ptracer.

If \textbf{t} is running, STOP trap will be taken.  If trapped for STOP and
ptracer is listening for events, tracee is woken up so that it can
re-trap for the new event.  If trapped otherwise, STOP trap will be
eventually taken without returning to userland after the existing traps
are finished by PTRACE\_CONT.

\textbf{Context}

Must be called with \textbf{task}-\textgreater{}sighand-\textgreater{}siglock held.
\index{do\_notify\_parent\_cldstop (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.do_notify_parent_cldstop}\pysiglinewithargsret{void \bfcode{do\_notify\_parent\_cldstop}}{struct task\_struct *\emph{ tsk}, bool\emph{ for\_ptracer}, int\emph{ why}}{}
notify parent of stopped/continued state change

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct task\_struct * tsk}}] \leavevmode
task reporting the state change

\item[{\code{bool for\_ptracer}}] \leavevmode
the notification is for ptracer

\item[{\code{int why}}] \leavevmode
CLD\_\{CONTINUED\textbar{}STOPPED\textbar{}TRAPPED\} to report

\end{description}

\textbf{Description}

Notify \textbf{tsk}`s parent that the stopped/continued state has changed.  If
\textbf{for\_ptracer} is \code{false}, \textbf{tsk}`s group leader notifies to its real parent.
If \code{true}, \textbf{tsk} reports to \textbf{tsk}-\textgreater{}parent which should be the ptracer.

\textbf{Context}

Must be called with tasklist\_lock at least read locked.
\index{do\_signal\_stop (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.do_signal_stop}\pysiglinewithargsret{bool \bfcode{do\_signal\_stop}}{int\emph{ signr}}{}
handle group stop for SIGSTOP and other stop signals

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int signr}}] \leavevmode
signr causing group stop if initiating

\end{description}

\textbf{Description}

If \code{JOBCTL\_STOP\_PENDING} is not set yet, initiate group stop with \textbf{signr}
and participate in it.  If already set, participate in the existing
group stop.  If participated in a group stop (and thus slept), \code{true} is
returned with siglock released.

If ptraced, this function doesn't handle stop itself.  Instead,
\code{JOBCTL\_TRAP\_STOP} is scheduled and \code{false} is returned with siglock
untouched.  The caller must ensure that INTERRUPT trap handling takes
places afterwards.

\textbf{Context}

Must be called with \textbf{current}-\textgreater{}sighand-\textgreater{}siglock held, which is released
on \code{true} return.

\textbf{Return}

\code{false} if group stop is already cancelled or ptrace trap is scheduled.
\code{true} if participated in group stop.
\index{do\_jobctl\_trap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.do_jobctl_trap}\pysiglinewithargsret{void \bfcode{do\_jobctl\_trap}}{void}{}
take care of ptrace jobctl traps

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

When PT\_SEIZED, it's used for both group stop and explicit
SEIZE/INTERRUPT traps.  Both generate PTRACE\_EVENT\_STOP trap with
accompanying siginfo.  If stopped, lower eight bits of exit\_code contain
the stop signal; otherwise, \code{SIGTRAP}.

When !PT\_SEIZED, it's used only for group stop trap with stop signal
number as exit\_code and no siginfo.

\textbf{Context}

Must be called with \textbf{current}-\textgreater{}sighand-\textgreater{}siglock held, which may be
released and re-acquired before returning with intervening sleep.
\index{signal\_delivered (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.signal_delivered}\pysiglinewithargsret{void \bfcode{signal\_delivered}}{struct ksignal *\emph{ ksig}, int\emph{ stepping}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ksignal * ksig}}] \leavevmode
kernel signal struct

\item[{\code{int stepping}}] \leavevmode
nonzero if debugger single-step or block-step in use

\end{description}

\textbf{Description}

This function should be called when a signal has successfully been
delivered. It updates the blocked signals accordingly (\textbf{ksig}-\textgreater{}ka.sa.sa\_mask
is always blocked, and the signal itself is blocked unless \code{SA\_NODEFER}
is set in \textbf{ksig}-\textgreater{}ka.sa.sa\_flags.  Tracing is notified.
\index{sys\_restart\_syscall (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.sys_restart_syscall}\pysiglinewithargsret{long \bfcode{sys\_restart\_syscall}}{void}{}
restart a system call

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}
\index{set\_current\_blocked (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.set_current_blocked}\pysiglinewithargsret{void \bfcode{set\_current\_blocked}}{sigset\_t *\emph{ newset}}{}
change current-\textgreater{}blocked mask

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{sigset\_t * newset}}] \leavevmode
new mask

\end{description}

\textbf{Description}

It is wrong to change -\textgreater{}blocked directly, this helper should be used
to ensure the process can't miss a shared signal we are going to block.
\index{sys\_rt\_sigprocmask (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.sys_rt_sigprocmask}\pysiglinewithargsret{long \bfcode{sys\_rt\_sigprocmask}}{int\emph{ how}, sigset\_t \_\_user *\emph{ nset}, sigset\_t \_\_user *\emph{ oset}, size\_t\emph{ sigsetsize}}{}
change the list of currently blocked signals

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int how}}] \leavevmode
whether to add, remove, or set signals

\item[{\code{sigset\_t \_\_user * nset}}] \leavevmode
stores pending signals

\item[{\code{sigset\_t \_\_user * oset}}] \leavevmode
previous value of signal mask if non-null

\item[{\code{size\_t sigsetsize}}] \leavevmode
size of sigset\_t type

\end{description}
\index{sys\_rt\_sigpending (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.sys_rt_sigpending}\pysiglinewithargsret{long \bfcode{sys\_rt\_sigpending}}{sigset\_t \_\_user *\emph{ uset}, size\_t\emph{ sigsetsize}}{}
examine a pending signal that has been raised while blocked

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{sigset\_t \_\_user * uset}}] \leavevmode
stores pending signals

\item[{\code{size\_t sigsetsize}}] \leavevmode
size of sigset\_t type or larger

\end{description}
\index{do\_sigtimedwait (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.do_sigtimedwait}\pysiglinewithargsret{int \bfcode{do\_sigtimedwait}}{const sigset\_t *\emph{ which}, siginfo\_t *\emph{ info}, const struct timespec *\emph{ ts}}{}
wait for queued signals specified in \textbf{which}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const sigset\_t * which}}] \leavevmode
queued signals to wait for

\item[{\code{siginfo\_t * info}}] \leavevmode
if non-null, the signal's siginfo is returned here

\item[{\code{const struct timespec * ts}}] \leavevmode
upper bound on process time suspension

\end{description}
\index{sys\_rt\_sigtimedwait (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.sys_rt_sigtimedwait}\pysiglinewithargsret{long \bfcode{sys\_rt\_sigtimedwait}}{const sigset\_t \_\_user *\emph{ uthese}, siginfo\_t \_\_user *\emph{ uinfo}, const struct timespec \_\_user *\emph{ uts}, size\_t\emph{ sigsetsize}}{}
synchronously wait for queued signals specified in \textbf{uthese}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const sigset\_t \_\_user * uthese}}] \leavevmode
queued signals to wait for

\item[{\code{siginfo\_t \_\_user * uinfo}}] \leavevmode
if non-null, the signal's siginfo is returned here

\item[{\code{const struct timespec \_\_user * uts}}] \leavevmode
upper bound on process time suspension

\item[{\code{size\_t sigsetsize}}] \leavevmode
size of sigset\_t type

\end{description}
\index{sys\_kill (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.sys_kill}\pysiglinewithargsret{long \bfcode{sys\_kill}}{pid\_t\emph{ pid}, int\emph{ sig}}{}
send a signal to a process

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{pid\_t pid}}] \leavevmode
the PID of the process

\item[{\code{int sig}}] \leavevmode
signal to be sent

\end{description}
\index{sys\_tgkill (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.sys_tgkill}\pysiglinewithargsret{long \bfcode{sys\_tgkill}}{pid\_t\emph{ tgid}, pid\_t\emph{ pid}, int\emph{ sig}}{}
send signal to one specific thread

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{pid\_t tgid}}] \leavevmode
the thread group ID of the thread

\item[{\code{pid\_t pid}}] \leavevmode
the PID of the thread

\item[{\code{int sig}}] \leavevmode
signal to be sent

\end{description}

\textbf{Description}
\begin{quote}

This syscall also checks the \textbf{tgid} and returns -ESRCH even if the PID
exists but it's not belonging to the target process anymore. This
method solves the problem of threads exiting and PIDs getting reused.
\end{quote}
\index{sys\_tkill (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.sys_tkill}\pysiglinewithargsret{long \bfcode{sys\_tkill}}{pid\_t\emph{ pid}, int\emph{ sig}}{}
send signal to one specific task

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{pid\_t pid}}] \leavevmode
the PID of the task

\item[{\code{int sig}}] \leavevmode
signal to be sent

\end{description}

\textbf{Description}
\begin{quote}

Send a signal to only one task, even if it's a CLONE\_THREAD task.
\end{quote}
\index{sys\_rt\_sigqueueinfo (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.sys_rt_sigqueueinfo}\pysiglinewithargsret{long \bfcode{sys\_rt\_sigqueueinfo}}{pid\_t\emph{ pid}, int\emph{ sig}, siginfo\_t \_\_user *\emph{ uinfo}}{}
send signal information to a signal

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{pid\_t pid}}] \leavevmode
the PID of the thread

\item[{\code{int sig}}] \leavevmode
signal to be sent

\item[{\code{siginfo\_t \_\_user * uinfo}}] \leavevmode
signal info to be sent

\end{description}
\index{sys\_sigpending (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.sys_sigpending}\pysiglinewithargsret{long \bfcode{sys\_sigpending}}{old\_sigset\_t \_\_user *\emph{ set}}{}
examine pending signals

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{old\_sigset\_t \_\_user * set}}] \leavevmode
where mask of pending signal is returned

\end{description}
\index{sys\_sigprocmask (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.sys_sigprocmask}\pysiglinewithargsret{long \bfcode{sys\_sigprocmask}}{int\emph{ how}, old\_sigset\_t \_\_user *\emph{ nset}, old\_sigset\_t \_\_user *\emph{ oset}}{}
examine and change blocked signals

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int how}}] \leavevmode
whether to add, remove, or set signals

\item[{\code{old\_sigset\_t \_\_user * nset}}] \leavevmode
signals to add or remove (if non-null)

\item[{\code{old\_sigset\_t \_\_user * oset}}] \leavevmode
previous value of signal mask if non-null

\end{description}

\textbf{Description}

Some platforms have their own version with special arguments;
others support only sys\_rt\_sigprocmask.
\index{sys\_rt\_sigaction (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.sys_rt_sigaction}\pysiglinewithargsret{long \bfcode{sys\_rt\_sigaction}}{int\emph{ sig}, const struct sigaction \_\_user *\emph{ act}, struct sigaction \_\_user *\emph{ oact}, size\_t\emph{ sigsetsize}}{}
alter an action taken by a process

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int sig}}] \leavevmode
signal to be sent

\item[{\code{const struct sigaction \_\_user * act}}] \leavevmode
new sigaction

\item[{\code{struct sigaction \_\_user * oact}}] \leavevmode
used to save the previous sigaction

\item[{\code{size\_t sigsetsize}}] \leavevmode
size of sigset\_t type

\end{description}
\index{sys\_rt\_sigsuspend (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.sys_rt_sigsuspend}\pysiglinewithargsret{long \bfcode{sys\_rt\_sigsuspend}}{sigset\_t \_\_user *\emph{ unewset}, size\_t\emph{ sigsetsize}}{}
replace the signal mask for a value with the \textbf{unewset} value until a signal is received

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{sigset\_t \_\_user * unewset}}] \leavevmode
new signal mask value

\item[{\code{size\_t sigsetsize}}] \leavevmode
size of sigset\_t type

\end{description}
\index{kthread\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_create}\pysiglinewithargsret{\bfcode{kthread\_create}}{\emph{threadfn}, \emph{data}, \emph{namefmt}, \emph{arg...}}{}
create a kthread on the current node

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{threadfn}}] \leavevmode
the function to run in the thread

\item[{\code{data}}] \leavevmode
data pointer for \textbf{threadfn()}

\item[{\code{namefmt}}] \leavevmode
printf-style format string for the thread name

\item[{\code{arg...}}] \leavevmode
arguments for \textbf{namefmt}.

\end{description}

\textbf{Description}

This macro will create a kthread on the current node, leaving it in
the stopped state.  This is just a helper for {\hyperref[driver\string-api/basics:c.kthread_create_on_node]{\emph{\code{kthread\_create\_on\_node()}}}};
see the documentation there for more details.
\index{kthread\_run (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_run}\pysiglinewithargsret{\bfcode{kthread\_run}}{\emph{threadfn}, \emph{data}, \emph{namefmt}, \emph{...}}{}
create and wake a thread.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{threadfn}}] \leavevmode
the function to run until signal\_pending(current).

\item[{\code{data}}] \leavevmode
data ptr for \textbf{threadfn}.

\item[{\code{namefmt}}] \leavevmode
printf-style name for the thread.

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

Convenient wrapper for {\hyperref[driver\string-api/basics:c.kthread_create]{\emph{\code{kthread\_create()}}}} followed by
{\hyperref[driver\string-api/basics:c.wake_up_process]{\emph{\code{wake\_up\_process()}}}}.  Returns the kthread or ERR\_PTR(-ENOMEM).
\index{kthread\_should\_stop (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_should_stop}\pysiglinewithargsret{bool \bfcode{kthread\_should\_stop}}{void}{}
should this kthread return now?

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

When someone calls {\hyperref[driver\string-api/basics:c.kthread_stop]{\emph{\code{kthread\_stop()}}}} on your kthread, it will be woken
and this will return true.  You should then return, and your return
value will be passed through to {\hyperref[driver\string-api/basics:c.kthread_stop]{\emph{\code{kthread\_stop()}}}}.
\index{kthread\_should\_park (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_should_park}\pysiglinewithargsret{bool \bfcode{kthread\_should\_park}}{void}{}
should this kthread park now?

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

When someone calls {\hyperref[driver\string-api/basics:c.kthread_park]{\emph{\code{kthread\_park()}}}} on your kthread, it will be woken
and this will return true.  You should then do the necessary
cleanup and call \code{kthread\_parkme()}

Similar to {\hyperref[driver\string-api/basics:c.kthread_should_stop]{\emph{\code{kthread\_should\_stop()}}}}, but this keeps the thread alive
and in a park position. {\hyperref[driver\string-api/basics:c.kthread_unpark]{\emph{\code{kthread\_unpark()}}}} ``restarts'' the thread and
calls the thread function again.
\index{kthread\_freezable\_should\_stop (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_freezable_should_stop}\pysiglinewithargsret{bool \bfcode{kthread\_freezable\_should\_stop}}{bool *\emph{ was\_frozen}}{}
should this freezable kthread return now?

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{bool * was\_frozen}}] \leavevmode
optional out parameter, indicates whether \code{current} was frozen

\end{description}

\textbf{Description}

{\hyperref[driver\string-api/basics:c.kthread_should_stop]{\emph{\code{kthread\_should\_stop()}}}} for freezable kthreads, which will enter
refrigerator if necessary.  This function is safe from {\hyperref[driver\string-api/basics:c.kthread_stop]{\emph{\code{kthread\_stop()}}}} /
freezer deadlock and freezable kthreads should use this function instead
of calling \code{try\_to\_freeze()} directly.
\index{kthread\_create\_on\_node (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_create_on_node}\pysiglinewithargsret{struct task\_struct * \bfcode{kthread\_create\_on\_node}}{int (*threadfn) (void\emph{ *data}, void *\emph{ data}, int\emph{ node}, const char\emph{ namefmt}, ...}{}
create a kthread.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int (*)(void *data) threadfn}}] \leavevmode
the function to run until signal\_pending(current).

\item[{\code{void * data}}] \leavevmode
data ptr for \textbf{threadfn}.

\item[{\code{int node}}] \leavevmode
task and thread structures for the thread are allocated on this node

\item[{\code{const char namefmt}}] \leavevmode
printf-style name for the thread.

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

This helper function creates and names a kernel
thread.  The thread will be stopped: use {\hyperref[driver\string-api/basics:c.wake_up_process]{\emph{\code{wake\_up\_process()}}}} to start
it.  See also {\hyperref[driver\string-api/basics:c.kthread_run]{\emph{\code{kthread\_run()}}}}.  The new thread has SCHED\_NORMAL policy and
is affine to all CPUs.

If thread is going to be bound on a particular cpu, give its node
in \textbf{node}, to get NUMA affinity for kthread stack, or else give NUMA\_NO\_NODE.
When woken, the thread will run \textbf{threadfn()} with \textbf{data} as its
argument. \textbf{threadfn()} can either call \code{do\_exit()} directly if it is a
standalone thread for which no one will call {\hyperref[driver\string-api/basics:c.kthread_stop]{\emph{\code{kthread\_stop()}}}}, or
return when `{\hyperref[driver\string-api/basics:c.kthread_should_stop]{\emph{\code{kthread\_should\_stop()}}}}` is true (which means
{\hyperref[driver\string-api/basics:c.kthread_stop]{\emph{\code{kthread\_stop()}}}} has been called).  The return value should be zero
or a negative error number; it will be passed to {\hyperref[driver\string-api/basics:c.kthread_stop]{\emph{\code{kthread\_stop()}}}}.

Returns a task\_struct or ERR\_PTR(-ENOMEM) or ERR\_PTR(-EINTR).
\index{kthread\_bind (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_bind}\pysiglinewithargsret{void \bfcode{kthread\_bind}}{struct task\_struct *\emph{ p}, unsigned int\emph{ cpu}}{}
bind a just-created kthread to a cpu.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct task\_struct * p}}] \leavevmode
thread created by {\hyperref[driver\string-api/basics:c.kthread_create]{\emph{\code{kthread\_create()}}}}.

\item[{\code{unsigned int cpu}}] \leavevmode
cpu (might not be online, must be possible) for \textbf{k} to run on.

\end{description}

\textbf{Description}

This function is equivalent to \code{set\_cpus\_allowed()},
except that \textbf{cpu} doesn't need to be online, and the thread must be
stopped (i.e., just returned from {\hyperref[driver\string-api/basics:c.kthread_create]{\emph{\code{kthread\_create()}}}}).
\index{kthread\_unpark (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_unpark}\pysiglinewithargsret{void \bfcode{kthread\_unpark}}{struct task\_struct *\emph{ k}}{}
unpark a thread created by {\hyperref[driver\string-api/basics:c.kthread_create]{\emph{\code{kthread\_create()}}}}.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct task\_struct * k}}] \leavevmode
thread created by {\hyperref[driver\string-api/basics:c.kthread_create]{\emph{\code{kthread\_create()}}}}.

\end{description}

\textbf{Description}

Sets {\hyperref[driver\string-api/basics:c.kthread_should_park]{\emph{\code{kthread\_should\_park()}}}} for \textbf{k} to return false, wakes it, and
waits for it to return. If the thread is marked percpu then its
bound to the cpu again.
\index{kthread\_park (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_park}\pysiglinewithargsret{int \bfcode{kthread\_park}}{struct task\_struct *\emph{ k}}{}
park a thread created by {\hyperref[driver\string-api/basics:c.kthread_create]{\emph{\code{kthread\_create()}}}}.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct task\_struct * k}}] \leavevmode
thread created by {\hyperref[driver\string-api/basics:c.kthread_create]{\emph{\code{kthread\_create()}}}}.

\end{description}

\textbf{Description}

Sets {\hyperref[driver\string-api/basics:c.kthread_should_park]{\emph{\code{kthread\_should\_park()}}}} for \textbf{k} to return true, wakes it, and
waits for it to return. This can also be called after {\hyperref[driver\string-api/basics:c.kthread_create]{\emph{\code{kthread\_create()}}}}
instead of calling {\hyperref[driver\string-api/basics:c.wake_up_process]{\emph{\code{wake\_up\_process()}}}}: the thread will park without
calling \code{threadfn()}.

Returns 0 if the thread is parked, -ENOSYS if the thread exited.
If called by the kthread itself just the park bit is set.
\index{kthread\_stop (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_stop}\pysiglinewithargsret{int \bfcode{kthread\_stop}}{struct task\_struct *\emph{ k}}{}
stop a thread created by {\hyperref[driver\string-api/basics:c.kthread_create]{\emph{\code{kthread\_create()}}}}.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct task\_struct * k}}] \leavevmode
thread created by {\hyperref[driver\string-api/basics:c.kthread_create]{\emph{\code{kthread\_create()}}}}.

\end{description}

\textbf{Description}

Sets {\hyperref[driver\string-api/basics:c.kthread_should_stop]{\emph{\code{kthread\_should\_stop()}}}} for \textbf{k} to return true, wakes it, and
waits for it to exit. This can also be called after {\hyperref[driver\string-api/basics:c.kthread_create]{\emph{\code{kthread\_create()}}}}
instead of calling {\hyperref[driver\string-api/basics:c.wake_up_process]{\emph{\code{wake\_up\_process()}}}}: the thread will exit without
calling \code{threadfn()}.

If \code{threadfn()} may call \code{do\_exit()} itself, the caller must ensure
task\_struct can't go away.

Returns the result of \code{threadfn()}, or \code{-EINTR} if {\hyperref[driver\string-api/basics:c.wake_up_process]{\emph{\code{wake\_up\_process()}}}}
was never called.
\index{kthread\_worker\_fn (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_worker_fn}\pysiglinewithargsret{int \bfcode{kthread\_worker\_fn}}{void *\emph{ worker\_ptr}}{}
kthread function to process kthread\_worker

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * worker\_ptr}}] \leavevmode
pointer to initialized kthread\_worker

\end{description}

\textbf{Description}

This function implements the main cycle of kthread worker. It processes
work\_list until it is stopped with {\hyperref[driver\string-api/basics:c.kthread_stop]{\emph{\code{kthread\_stop()}}}}. It sleeps when the queue
is empty.

The works are not allowed to keep any locks, disable preemption or interrupts
when they finish. There is defined a safe point for freezing when one work
finishes and before a new one is started.

Also the works must not be handled by more than one worker at the same time,
see also {\hyperref[driver\string-api/basics:c.kthread_queue_work]{\emph{\code{kthread\_queue\_work()}}}}.
\index{kthread\_create\_worker (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_create_worker}\pysiglinewithargsret{struct kthread\_worker * \bfcode{kthread\_create\_worker}}{unsigned int\emph{ flags}, const char\emph{ namefmt}, ...}{}
create a kthread worker

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int flags}}] \leavevmode
flags modifying the default behavior of the worker

\item[{\code{const char namefmt}}] \leavevmode
printf-style name for the kthread worker (task).

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

Returns a pointer to the allocated worker on success, ERR\_PTR(-ENOMEM)
when the needed structures could not get allocated, and ERR\_PTR(-EINTR)
when the worker was SIGKILLed.
\index{kthread\_create\_worker\_on\_cpu (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_create_worker_on_cpu}\pysiglinewithargsret{struct kthread\_worker * \bfcode{kthread\_create\_worker\_on\_cpu}}{int\emph{ cpu}, unsigned int\emph{ flags}, const char\emph{ namefmt}, ...}{}
create a kthread worker and bind it it to a given CPU and the associated NUMA node.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int cpu}}] \leavevmode
CPU number

\item[{\code{unsigned int flags}}] \leavevmode
flags modifying the default behavior of the worker

\item[{\code{const char namefmt}}] \leavevmode
printf-style name for the kthread worker (task).

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

Use a valid CPU number if you want to bind the kthread worker
to the given CPU and the associated NUMA node.

A good practice is to add the cpu number also into the worker name.
For example, use kthread\_create\_worker\_on\_cpu(cpu, ``helper/\code{d}'', cpu).

Returns a pointer to the allocated worker on success, ERR\_PTR(-ENOMEM)
when the needed structures could not get allocated, and ERR\_PTR(-EINTR)
when the worker was SIGKILLed.
\index{kthread\_queue\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_queue_work}\pysiglinewithargsret{bool \bfcode{kthread\_queue\_work}}{struct kthread\_worker *\emph{ worker}, struct kthread\_work *\emph{ work}}{}
queue a kthread\_work

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kthread\_worker * worker}}] \leavevmode
target kthread\_worker

\item[{\code{struct kthread\_work * work}}] \leavevmode
kthread\_work to queue

\end{description}

\textbf{Description}

Queue \textbf{work} to work processor \textbf{task} for async execution.  \textbf{task}
must have been created with \code{kthread\_worker\_create()}.  Returns \code{true}
if \textbf{work} was successfully queued, \code{false} if it was already pending.

Reinitialize the work if it needs to be used by another worker.
For example, when the worker was stopped and started again.
\index{kthread\_delayed\_work\_timer\_fn (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_delayed_work_timer_fn}\pysiglinewithargsret{void \bfcode{kthread\_delayed\_work\_timer\_fn}}{struct timer\_list *\emph{ t}}{}
callback that queues the associated kthread delayed work when the timer expires.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct timer\_list * t}}] \leavevmode
pointer to the expired timer

\end{description}

\textbf{Description}

The format of the function is defined by struct timer\_list.
It should have been called from irqsafe timer with irq already off.
\index{kthread\_queue\_delayed\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_queue_delayed_work}\pysiglinewithargsret{bool \bfcode{kthread\_queue\_delayed\_work}}{struct kthread\_worker *\emph{ worker}, struct kthread\_delayed\_work *\emph{ dwork}, unsigned long\emph{ delay}}{}
queue the associated kthread work after a delay.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kthread\_worker * worker}}] \leavevmode
target kthread\_worker

\item[{\code{struct kthread\_delayed\_work * dwork}}] \leavevmode
kthread\_delayed\_work to queue

\item[{\code{unsigned long delay}}] \leavevmode
number of jiffies to wait before queuing

\end{description}

\textbf{Description}

If the work has not been pending it starts a timer that will queue
the work after the given \textbf{delay}. If \textbf{delay} is zero, it queues the
work immediately.

\textbf{Return}

\code{false} if the \textbf{work} has already been pending. It means that
either the timer was running or the work was queued. It returns \code{true}
otherwise.
\index{kthread\_flush\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_flush_work}\pysiglinewithargsret{void \bfcode{kthread\_flush\_work}}{struct kthread\_work *\emph{ work}}{}
flush a kthread\_work

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kthread\_work * work}}] \leavevmode
work to flush

\end{description}

\textbf{Description}

If \textbf{work} is queued or executing, wait for it to finish execution.
\index{kthread\_mod\_delayed\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_mod_delayed_work}\pysiglinewithargsret{bool \bfcode{kthread\_mod\_delayed\_work}}{struct kthread\_worker *\emph{ worker}, struct kthread\_delayed\_work *\emph{ dwork}, unsigned long\emph{ delay}}{}
modify delay of or queue a kthread delayed work

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kthread\_worker * worker}}] \leavevmode
kthread worker to use

\item[{\code{struct kthread\_delayed\_work * dwork}}] \leavevmode
kthread delayed work to queue

\item[{\code{unsigned long delay}}] \leavevmode
number of jiffies to wait before queuing

\end{description}

\textbf{Description}

If \textbf{dwork} is idle, equivalent to {\hyperref[driver\string-api/basics:c.kthread_queue_delayed_work]{\emph{\code{kthread\_queue\_delayed\_work()}}}}. Otherwise,
modify \textbf{dwork}`s timer so that it expires after \textbf{delay}. If \textbf{delay} is zero,
\textbf{work} is guaranteed to be queued immediately.

\textbf{Return}

\code{true} if \textbf{dwork} was pending and its timer was modified,
\code{false} otherwise.

A special case is when the work is being canceled in parallel.
It might be caused either by the real {\hyperref[driver\string-api/basics:c.kthread_cancel_delayed_work_sync]{\emph{\code{kthread\_cancel\_delayed\_work\_sync()}}}}
or yet another {\hyperref[driver\string-api/basics:c.kthread_mod_delayed_work]{\emph{\code{kthread\_mod\_delayed\_work()}}}} call. We let the other command
win and return \code{false} here. The caller is supposed to synchronize these
operations a reasonable way.

This function is safe to call from any context including IRQ handler.
See \code{\_\_kthread\_cancel\_work()} and {\hyperref[driver\string-api/basics:c.kthread_delayed_work_timer_fn]{\emph{\code{kthread\_delayed\_work\_timer\_fn()}}}}
for details.
\index{kthread\_cancel\_work\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_cancel_work_sync}\pysiglinewithargsret{bool \bfcode{kthread\_cancel\_work\_sync}}{struct kthread\_work *\emph{ work}}{}
cancel a kthread work and wait for it to finish

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kthread\_work * work}}] \leavevmode
the kthread work to cancel

\end{description}

\textbf{Description}

Cancel \textbf{work} and wait for its execution to finish.  This function
can be used even if the work re-queues itself. On return from this
function, \textbf{work} is guaranteed to be not pending or executing on any CPU.

kthread\_cancel\_work\_sync(\code{delayed\_work-\textgreater{}work}) must not be used for
delayed\_work's. Use {\hyperref[driver\string-api/basics:c.kthread_cancel_delayed_work_sync]{\emph{\code{kthread\_cancel\_delayed\_work\_sync()}}}} instead.

The caller must ensure that the worker on which \textbf{work} was last
queued can't be destroyed before this function returns.

\textbf{Return}

\code{true} if \textbf{work} was pending, \code{false} otherwise.
\index{kthread\_cancel\_delayed\_work\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_cancel_delayed_work_sync}\pysiglinewithargsret{bool \bfcode{kthread\_cancel\_delayed\_work\_sync}}{struct kthread\_delayed\_work *\emph{ dwork}}{}
cancel a kthread delayed work and wait for it to finish.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kthread\_delayed\_work * dwork}}] \leavevmode
the kthread delayed work to cancel

\end{description}

\textbf{Description}

This is {\hyperref[driver\string-api/basics:c.kthread_cancel_work_sync]{\emph{\code{kthread\_cancel\_work\_sync()}}}} for delayed works.

\textbf{Return}

\code{true} if \textbf{dwork} was pending, \code{false} otherwise.
\index{kthread\_flush\_worker (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_flush_worker}\pysiglinewithargsret{void \bfcode{kthread\_flush\_worker}}{struct kthread\_worker *\emph{ worker}}{}
flush all current works on a kthread\_worker

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kthread\_worker * worker}}] \leavevmode
worker to flush

\end{description}

\textbf{Description}

Wait until all currently executing or pending works on \textbf{worker} are
finished.
\index{kthread\_destroy\_worker (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_destroy_worker}\pysiglinewithargsret{void \bfcode{kthread\_destroy\_worker}}{struct kthread\_worker *\emph{ worker}}{}
destroy a kthread worker

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kthread\_worker * worker}}] \leavevmode
worker to be destroyed

\end{description}

\textbf{Description}

Flush and destroy \textbf{worker}.  The simple flush is enough because the kthread
worker API is used only in trivial scenarios.  There are no multi-step state
machines needed.
\index{kthread\_associate\_blkcg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_associate_blkcg}\pysiglinewithargsret{void \bfcode{kthread\_associate\_blkcg}}{struct cgroup\_subsys\_state *\emph{ css}}{}
associate blkcg to current kthread

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct cgroup\_subsys\_state * css}}] \leavevmode
the cgroup info

\end{description}

\textbf{Description}

Current thread must be a kthread. The thread is running jobs on behalf of
other threads. In some cases, we expect the jobs attach cgroup info of
original threads instead of that of current thread. This function stores
original thread's cgroup info in current kthread context for later
retrieval.
\index{kthread\_blkcg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kthread_blkcg}\pysiglinewithargsret{struct cgroup\_subsys\_state * \bfcode{kthread\_blkcg}}{void}{}
get associated blkcg css of current kthread

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Current thread must be a kthread.


\section{Reference counting}
\label{driver-api/basics:reference-counting}\index{refcount\_struct (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.refcount_struct}\pysigline{struct \bfcode{refcount\_struct}}
variant of atomic\_t specialized for reference counts

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct refcount\PYGZus{}struct \PYGZob{}
  atomic\PYGZus{}t refs;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{refs}}] \leavevmode
atomic\_t counter field

\end{description}

\textbf{Description}

The counter saturates at UINT\_MAX and will not move once
there. This avoids wrapping the counter and causing `spurious'
use-after-free bugs.
\index{refcount\_set (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.refcount_set}\pysiglinewithargsret{void \bfcode{refcount\_set}}{refcount\_t *\emph{ r}, unsigned int\emph{ n}}{}
set a refcount's value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{refcount\_t * r}}] \leavevmode
the refcount

\item[{\code{unsigned int n}}] \leavevmode
value to which the refcount will be set

\end{description}
\index{refcount\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.refcount_read}\pysiglinewithargsret{unsigned int \bfcode{refcount\_read}}{const refcount\_t *\emph{ r}}{}
get a refcount's value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const refcount\_t * r}}] \leavevmode
the refcount

\end{description}

\textbf{Return}

the refcount's value
\index{refcount\_add\_not\_zero (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.refcount_add_not_zero}\pysiglinewithargsret{bool \bfcode{refcount\_add\_not\_zero}}{unsigned int\emph{ i}, refcount\_t *\emph{ r}}{}
add a value to a refcount unless it is 0

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int i}}] \leavevmode
the value to add to the refcount

\item[{\code{refcount\_t * r}}] \leavevmode
the refcount

\end{description}

\textbf{Description}

Will saturate at UINT\_MAX and WARN.

Provides no memory ordering, it is assumed the caller has guaranteed the
object memory to be stable (RCU, etc.). It does provide a control dependency
and thereby orders future stores. See the comment on top.

Use of this function is not recommended for the normal reference counting
use case in which references are taken and released one at a time.  In these
cases, {\hyperref[driver\string-api/basics:c.refcount_inc]{\emph{\code{refcount\_inc()}}}}, or one of its variants, should instead be used to
increment a reference count.

\textbf{Return}

false if the passed refcount is 0, true otherwise
\index{refcount\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.refcount_add}\pysiglinewithargsret{void \bfcode{refcount\_add}}{unsigned int\emph{ i}, refcount\_t *\emph{ r}}{}
add a value to a refcount

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int i}}] \leavevmode
the value to add to the refcount

\item[{\code{refcount\_t * r}}] \leavevmode
the refcount

\end{description}

\textbf{Description}

Similar to {\hyperref[driver\string-api/basics:c.atomic_add]{\emph{\code{atomic\_add()}}}}, but will saturate at UINT\_MAX and WARN.

Provides no memory ordering, it is assumed the caller has guaranteed the
object memory to be stable (RCU, etc.). It does provide a control dependency
and thereby orders future stores. See the comment on top.

Use of this function is not recommended for the normal reference counting
use case in which references are taken and released one at a time.  In these
cases, {\hyperref[driver\string-api/basics:c.refcount_inc]{\emph{\code{refcount\_inc()}}}}, or one of its variants, should instead be used to
increment a reference count.
\index{refcount\_inc\_not\_zero (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.refcount_inc_not_zero}\pysiglinewithargsret{bool \bfcode{refcount\_inc\_not\_zero}}{refcount\_t *\emph{ r}}{}
increment a refcount unless it is 0

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{refcount\_t * r}}] \leavevmode
the refcount to increment

\end{description}

\textbf{Description}

Similar to \code{atomic\_inc\_not\_zero()}, but will saturate at UINT\_MAX and WARN.

Provides no memory ordering, it is assumed the caller has guaranteed the
object memory to be stable (RCU, etc.). It does provide a control dependency
and thereby orders future stores. See the comment on top.

\textbf{Return}

true if the increment was successful, false otherwise
\index{refcount\_inc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.refcount_inc}\pysiglinewithargsret{void \bfcode{refcount\_inc}}{refcount\_t *\emph{ r}}{}
increment a refcount

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{refcount\_t * r}}] \leavevmode
the refcount to increment

\end{description}

\textbf{Description}

Similar to {\hyperref[driver\string-api/basics:c.atomic_inc]{\emph{\code{atomic\_inc()}}}}, but will saturate at UINT\_MAX and WARN.

Provides no memory ordering, it is assumed the caller already has a
reference on the object.

Will WARN if the refcount is 0, as this represents a possible use-after-free
condition.
\index{refcount\_sub\_and\_test (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.refcount_sub_and_test}\pysiglinewithargsret{bool \bfcode{refcount\_sub\_and\_test}}{unsigned int\emph{ i}, refcount\_t *\emph{ r}}{}
subtract from a refcount and test if it is 0

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int i}}] \leavevmode
amount to subtract from the refcount

\item[{\code{refcount\_t * r}}] \leavevmode
the refcount

\end{description}

\textbf{Description}

Similar to {\hyperref[driver\string-api/basics:c.atomic_dec_and_test]{\emph{\code{atomic\_dec\_and\_test()}}}}, but it will WARN, return false and
ultimately leak on underflow and will fail to decrement when saturated
at UINT\_MAX.

Provides release memory ordering, such that prior loads and stores are done
before, and provides a control dependency such that \code{free()} must come after.
See the comment on top.

Use of this function is not recommended for the normal reference counting
use case in which references are taken and released one at a time.  In these
cases, {\hyperref[driver\string-api/basics:c.refcount_dec]{\emph{\code{refcount\_dec()}}}}, or one of its variants, should instead be used to
decrement a reference count.

\textbf{Return}

true if the resulting refcount is 0, false otherwise
\index{refcount\_dec\_and\_test (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.refcount_dec_and_test}\pysiglinewithargsret{bool \bfcode{refcount\_dec\_and\_test}}{refcount\_t *\emph{ r}}{}
decrement a refcount and test if it is 0

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{refcount\_t * r}}] \leavevmode
the refcount

\end{description}

\textbf{Description}

Similar to {\hyperref[driver\string-api/basics:c.atomic_dec_and_test]{\emph{\code{atomic\_dec\_and\_test()}}}}, it will WARN on underflow and fail to
decrement when saturated at UINT\_MAX.

Provides release memory ordering, such that prior loads and stores are done
before, and provides a control dependency such that \code{free()} must come after.
See the comment on top.

\textbf{Return}

true if the resulting refcount is 0, false otherwise
\index{refcount\_dec (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.refcount_dec}\pysiglinewithargsret{void \bfcode{refcount\_dec}}{refcount\_t *\emph{ r}}{}
decrement a refcount

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{refcount\_t * r}}] \leavevmode
the refcount

\end{description}

\textbf{Description}

Similar to {\hyperref[driver\string-api/basics:c.atomic_dec]{\emph{\code{atomic\_dec()}}}}, it will WARN on underflow and fail to decrement
when saturated at UINT\_MAX.

Provides release memory ordering, such that prior loads and stores are done
before.
\index{refcount\_dec\_if\_one (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.refcount_dec_if_one}\pysiglinewithargsret{bool \bfcode{refcount\_dec\_if\_one}}{refcount\_t *\emph{ r}}{}
decrement a refcount if it is 1

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{refcount\_t * r}}] \leavevmode
the refcount

\end{description}

\textbf{Description}

No atomic\_t counterpart, it attempts a 1 -\textgreater{} 0 transition and returns the
success thereof.

Like all decrement operations, it provides release memory order and provides
a control dependency.

It can be used like a try-delete operator; this explicit case is provided
and not cmpxchg in generic, because that would allow implementing unsafe
operations.

\textbf{Return}

true if the resulting refcount is 0, false otherwise
\index{refcount\_dec\_not\_one (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.refcount_dec_not_one}\pysiglinewithargsret{bool \bfcode{refcount\_dec\_not\_one}}{refcount\_t *\emph{ r}}{}
decrement a refcount if it is not 1

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{refcount\_t * r}}] \leavevmode
the refcount

\end{description}

\textbf{Description}

No atomic\_t counterpart, it decrements unless the value is 1, in which case
it will return false.

Was often done like: atomic\_add\_unless(\code{var}, -1, 1)

\textbf{Return}

true if the decrement operation was successful, false otherwise
\index{refcount\_dec\_and\_mutex\_lock (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.refcount_dec_and_mutex_lock}\pysiglinewithargsret{bool \bfcode{refcount\_dec\_and\_mutex\_lock}}{refcount\_t *\emph{ r}, struct mutex *\emph{ lock}}{}
return holding mutex if able to decrement refcount to 0

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{refcount\_t * r}}] \leavevmode
the refcount

\item[{\code{struct mutex * lock}}] \leavevmode
the mutex to be locked

\end{description}

\textbf{Description}

Similar to \code{atomic\_dec\_and\_mutex\_lock()}, it will WARN on underflow and fail
to decrement when saturated at UINT\_MAX.

Provides release memory ordering, such that prior loads and stores are done
before, and provides a control dependency such that \code{free()} must come after.
See the comment on top.

\textbf{Return}
\begin{description}
\item[{true and hold mutex if able to decrement refcount to 0, false}] \leavevmode
otherwise

\end{description}
\index{refcount\_dec\_and\_lock (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.refcount_dec_and_lock}\pysiglinewithargsret{bool \bfcode{refcount\_dec\_and\_lock}}{refcount\_t *\emph{ r}, spinlock\_t *\emph{ lock}}{}
return holding spinlock if able to decrement refcount to 0

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{refcount\_t * r}}] \leavevmode
the refcount

\item[{\code{spinlock\_t * lock}}] \leavevmode
the spinlock to be locked

\end{description}

\textbf{Description}

Similar to \code{atomic\_dec\_and\_lock()}, it will WARN on underflow and fail to
decrement when saturated at UINT\_MAX.

Provides release memory ordering, such that prior loads and stores are done
before, and provides a control dependency such that \code{free()} must come after.
See the comment on top.

\textbf{Return}
\begin{description}
\item[{true and hold spinlock if able to decrement refcount to 0, false}] \leavevmode
otherwise

\end{description}


\section{Atomics}
\label{driver-api/basics:atomics}\index{atomic\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.atomic_read}\pysiglinewithargsret{int \bfcode{atomic\_read}}{const atomic\_t *\emph{ v}}{}
read atomic variable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const atomic\_t * v}}] \leavevmode
pointer of type atomic\_t

\end{description}

\textbf{Description}

Atomically reads the value of \textbf{v}.
\index{atomic\_set (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.atomic_set}\pysiglinewithargsret{void \bfcode{atomic\_set}}{atomic\_t *\emph{ v}, int\emph{ i}}{}
set atomic variable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{atomic\_t * v}}] \leavevmode
pointer of type atomic\_t

\item[{\code{int i}}] \leavevmode
required value

\end{description}

\textbf{Description}

Atomically sets the value of \textbf{v} to \textbf{i}.
\index{atomic\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.atomic_add}\pysiglinewithargsret{void \bfcode{atomic\_add}}{int\emph{ i}, atomic\_t *\emph{ v}}{}
add integer to atomic variable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int i}}] \leavevmode
integer value to add

\item[{\code{atomic\_t * v}}] \leavevmode
pointer of type atomic\_t

\end{description}

\textbf{Description}

Atomically adds \textbf{i} to \textbf{v}.
\index{atomic\_sub (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.atomic_sub}\pysiglinewithargsret{void \bfcode{atomic\_sub}}{int\emph{ i}, atomic\_t *\emph{ v}}{}
subtract integer from atomic variable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int i}}] \leavevmode
integer value to subtract

\item[{\code{atomic\_t * v}}] \leavevmode
pointer of type atomic\_t

\end{description}

\textbf{Description}

Atomically subtracts \textbf{i} from \textbf{v}.
\index{atomic\_sub\_and\_test (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.atomic_sub_and_test}\pysiglinewithargsret{bool \bfcode{atomic\_sub\_and\_test}}{int\emph{ i}, atomic\_t *\emph{ v}}{}
subtract value from variable and test result

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int i}}] \leavevmode
integer value to subtract

\item[{\code{atomic\_t * v}}] \leavevmode
pointer of type atomic\_t

\end{description}

\textbf{Description}

Atomically subtracts \textbf{i} from \textbf{v} and returns
true if the result is zero, or false for all
other cases.
\index{atomic\_inc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.atomic_inc}\pysiglinewithargsret{void \bfcode{atomic\_inc}}{atomic\_t *\emph{ v}}{}
increment atomic variable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{atomic\_t * v}}] \leavevmode
pointer of type atomic\_t

\end{description}

\textbf{Description}

Atomically increments \textbf{v} by 1.
\index{atomic\_dec (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.atomic_dec}\pysiglinewithargsret{void \bfcode{atomic\_dec}}{atomic\_t *\emph{ v}}{}
decrement atomic variable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{atomic\_t * v}}] \leavevmode
pointer of type atomic\_t

\end{description}

\textbf{Description}

Atomically decrements \textbf{v} by 1.
\index{atomic\_dec\_and\_test (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.atomic_dec_and_test}\pysiglinewithargsret{bool \bfcode{atomic\_dec\_and\_test}}{atomic\_t *\emph{ v}}{}
decrement and test

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{atomic\_t * v}}] \leavevmode
pointer of type atomic\_t

\end{description}

\textbf{Description}

Atomically decrements \textbf{v} by 1 and
returns true if the result is 0, or false for all other
cases.
\index{atomic\_inc\_and\_test (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.atomic_inc_and_test}\pysiglinewithargsret{bool \bfcode{atomic\_inc\_and\_test}}{atomic\_t *\emph{ v}}{}
increment and test

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{atomic\_t * v}}] \leavevmode
pointer of type atomic\_t

\end{description}

\textbf{Description}

Atomically increments \textbf{v} by 1
and returns true if the result is zero, or false for all
other cases.
\index{atomic\_add\_negative (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.atomic_add_negative}\pysiglinewithargsret{bool \bfcode{atomic\_add\_negative}}{int\emph{ i}, atomic\_t *\emph{ v}}{}
add and test if negative

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int i}}] \leavevmode
integer value to add

\item[{\code{atomic\_t * v}}] \leavevmode
pointer of type atomic\_t

\end{description}

\textbf{Description}

Atomically adds \textbf{i} to \textbf{v} and returns true
if the result is negative, or false when
result is greater than or equal to zero.
\index{atomic\_add\_return (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.atomic_add_return}\pysiglinewithargsret{int \bfcode{atomic\_add\_return}}{int\emph{ i}, atomic\_t *\emph{ v}}{}
add integer and return

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int i}}] \leavevmode
integer value to add

\item[{\code{atomic\_t * v}}] \leavevmode
pointer of type atomic\_t

\end{description}

\textbf{Description}

Atomically adds \textbf{i} to \textbf{v} and returns \textbf{i} + \textbf{v}
\index{atomic\_sub\_return (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.atomic_sub_return}\pysiglinewithargsret{int \bfcode{atomic\_sub\_return}}{int\emph{ i}, atomic\_t *\emph{ v}}{}
subtract integer and return

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int i}}] \leavevmode
integer value to subtract

\item[{\code{atomic\_t * v}}] \leavevmode
pointer of type atomic\_t

\end{description}

\textbf{Description}

Atomically subtracts \textbf{i} from \textbf{v} and returns \textbf{v} - \textbf{i}
\index{\_\_atomic\_add\_unless (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.__atomic_add_unless}\pysiglinewithargsret{int \bfcode{\_\_atomic\_add\_unless}}{atomic\_t *\emph{ v}, int\emph{ a}, int\emph{ u}}{}
add unless the number is already a given value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{atomic\_t * v}}] \leavevmode
pointer of type atomic\_t

\item[{\code{int a}}] \leavevmode
the amount to add to v...

\item[{\code{int u}}] \leavevmode
...unless v is equal to u.

\end{description}

\textbf{Description}

Atomically adds \textbf{a} to \textbf{v}, so long as \textbf{v} was not already \textbf{u}.
Returns the old value of \textbf{v}.


\section{Kernel objects manipulation}
\label{driver-api/basics:kernel-objects-manipulation}\index{kobject\_get\_path (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kobject_get_path}\pysiglinewithargsret{char * \bfcode{kobject\_get\_path}}{struct kobject *\emph{ kobj}, gfp\_t\emph{ gfp\_mask}}{}
generate and return the path associated with a given kobj and kset pair.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
kobject in question, with which to build the path

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
the allocation type used to allocate the path

\end{description}

\textbf{Description}

The result must be freed by the caller with \code{kfree()}.
\index{kobject\_set\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kobject_set_name}\pysiglinewithargsret{int \bfcode{kobject\_set\_name}}{struct kobject *\emph{ kobj}, const char *\emph{ fmt}, ...}{}
Set the name of a kobject

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
struct kobject to set the name of

\item[{\code{const char * fmt}}] \leavevmode
format string used to build the name

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

This sets the name of the kobject.  If you have already added the
kobject to the system, you must call {\hyperref[driver\string-api/basics:c.kobject_rename]{\emph{\code{kobject\_rename()}}}} in order to
change the name of the kobject.
\index{kobject\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kobject_init}\pysiglinewithargsret{void \bfcode{kobject\_init}}{struct kobject *\emph{ kobj}, struct kobj\_type *\emph{ ktype}}{}
initialize a kobject structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
pointer to the kobject to initialize

\item[{\code{struct kobj\_type * ktype}}] \leavevmode
pointer to the ktype for this kobject.

\end{description}

\textbf{Description}

This function will properly initialize a kobject such that it can then
be passed to the {\hyperref[driver\string-api/basics:c.kobject_add]{\emph{\code{kobject\_add()}}}} call.

After this function is called, the kobject MUST be cleaned up by a call
to {\hyperref[driver\string-api/basics:c.kobject_put]{\emph{\code{kobject\_put()}}}}, not by a call to kfree directly to ensure that all of
the memory is cleaned up properly.
\index{kobject\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kobject_add}\pysiglinewithargsret{int \bfcode{kobject\_add}}{struct kobject *\emph{ kobj}, struct kobject *\emph{ parent}, const char *\emph{ fmt}, ...}{}
the main kobject add function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
the kobject to add

\item[{\code{struct kobject * parent}}] \leavevmode
pointer to the parent of the kobject.

\item[{\code{const char * fmt}}] \leavevmode
format to name the kobject with.

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

The kobject name is set and added to the kobject hierarchy in this
function.

If \textbf{parent} is set, then the parent of the \textbf{kobj} will be set to it.
If \textbf{parent} is NULL, then the parent of the \textbf{kobj} will be set to the
kobject associated with the kset assigned to this kobject.  If no kset
is assigned to the kobject, then the kobject will be located in the
root of the sysfs tree.

If this function returns an error, {\hyperref[driver\string-api/basics:c.kobject_put]{\emph{\code{kobject\_put()}}}} must be called to
properly clean up the memory associated with the object.
Under no instance should the kobject that is passed to this function
be directly freed with a call to \code{kfree()}, that can leak memory.

Note, no ``add'' uevent will be created with this call, the caller should set
up all of the necessary sysfs files for the object and then call
\code{kobject\_uevent()} with the UEVENT\_ADD parameter to ensure that
userspace is properly notified of this kobject's creation.
\index{kobject\_init\_and\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kobject_init_and_add}\pysiglinewithargsret{int \bfcode{kobject\_init\_and\_add}}{struct kobject *\emph{ kobj}, struct kobj\_type *\emph{ ktype}, struct kobject *\emph{ parent}, const char *\emph{ fmt}, ...}{}
initialize a kobject structure and add it to the kobject hierarchy

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
pointer to the kobject to initialize

\item[{\code{struct kobj\_type * ktype}}] \leavevmode
pointer to the ktype for this kobject.

\item[{\code{struct kobject * parent}}] \leavevmode
pointer to the parent of this kobject.

\item[{\code{const char * fmt}}] \leavevmode
the name of the kobject.

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

This function combines the call to {\hyperref[driver\string-api/basics:c.kobject_init]{\emph{\code{kobject\_init()}}}} and
{\hyperref[driver\string-api/basics:c.kobject_add]{\emph{\code{kobject\_add()}}}}.  The same type of error handling after a call to
{\hyperref[driver\string-api/basics:c.kobject_add]{\emph{\code{kobject\_add()}}}} and kobject lifetime rules are the same here.
\index{kobject\_rename (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kobject_rename}\pysiglinewithargsret{int \bfcode{kobject\_rename}}{struct kobject *\emph{ kobj}, const char *\emph{ new\_name}}{}
change the name of an object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
object in question.

\item[{\code{const char * new\_name}}] \leavevmode
object's new name

\end{description}

\textbf{Description}

It is the responsibility of the caller to provide mutual
exclusion between two different calls of kobject\_rename
on the same kobject and to ensure that new\_name is valid and
won't conflict with other kobjects.
\index{kobject\_move (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kobject_move}\pysiglinewithargsret{int \bfcode{kobject\_move}}{struct kobject *\emph{ kobj}, struct kobject *\emph{ new\_parent}}{}
move object to another parent

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
object in question.

\item[{\code{struct kobject * new\_parent}}] \leavevmode
object's new parent (can be NULL)

\end{description}
\index{kobject\_del (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kobject_del}\pysiglinewithargsret{void \bfcode{kobject\_del}}{struct kobject *\emph{ kobj}}{}
unlink kobject from hierarchy.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
object.

\end{description}
\index{kobject\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kobject_get}\pysiglinewithargsret{struct kobject * \bfcode{kobject\_get}}{struct kobject *\emph{ kobj}}{}
increment refcount for object.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
object.

\end{description}
\index{kobject\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kobject_put}\pysiglinewithargsret{void \bfcode{kobject\_put}}{struct kobject *\emph{ kobj}}{}
decrement refcount for object.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
object.

\end{description}

\textbf{Description}

Decrement the refcount, and if 0, call \code{kobject\_cleanup()}.
\index{kobject\_create\_and\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kobject_create_and_add}\pysiglinewithargsret{struct kobject * \bfcode{kobject\_create\_and\_add}}{const char *\emph{ name}, struct kobject *\emph{ parent}}{}
create a struct kobject dynamically and register it with sysfs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
the name for the kobject

\item[{\code{struct kobject * parent}}] \leavevmode
the parent kobject of this kobject, if any.

\end{description}

\textbf{Description}

This function creates a kobject structure dynamically and registers it
with sysfs.  When you are finished with this structure, call
{\hyperref[driver\string-api/basics:c.kobject_put]{\emph{\code{kobject\_put()}}}} and the structure will be dynamically freed when
it is no longer being used.

If the kobject was not able to be created, NULL will be returned.
\index{kset\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kset_register}\pysiglinewithargsret{int \bfcode{kset\_register}}{struct kset *\emph{ k}}{}
initialize and add a kset.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kset * k}}] \leavevmode
kset.

\end{description}
\index{kset\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kset_unregister}\pysiglinewithargsret{void \bfcode{kset\_unregister}}{struct kset *\emph{ k}}{}
remove a kset.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kset * k}}] \leavevmode
kset.

\end{description}
\index{kset\_find\_obj (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kset_find_obj}\pysiglinewithargsret{struct kobject * \bfcode{kset\_find\_obj}}{struct kset *\emph{ kset}, const char *\emph{ name}}{}
search for object in kset.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kset * kset}}] \leavevmode
kset we're looking in.

\item[{\code{const char * name}}] \leavevmode
object's name.

\end{description}

\textbf{Description}

Lock kset via \textbf{kset}-\textgreater{}subsys, and iterate over \textbf{kset}-\textgreater{}list,
looking for a matching kobject. If matching object is found
take a reference and return the object.
\index{kset\_create\_and\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kset_create_and_add}\pysiglinewithargsret{struct kset * \bfcode{kset\_create\_and\_add}}{const char *\emph{ name}, const struct kset\_uevent\_ops *\emph{ uevent\_ops}, struct kobject *\emph{ parent\_kobj}}{}
create a struct kset dynamically and add it to sysfs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
the name for the kset

\item[{\code{const struct kset\_uevent\_ops * uevent\_ops}}] \leavevmode
a struct kset\_uevent\_ops for the kset

\item[{\code{struct kobject * parent\_kobj}}] \leavevmode
the parent kobject of this kset, if any.

\end{description}

\textbf{Description}

This function creates a kset structure dynamically and registers it
with sysfs.  When you are finished with this structure, call
{\hyperref[driver\string-api/basics:c.kset_unregister]{\emph{\code{kset\_unregister()}}}} and the structure will be dynamically freed when it
is no longer being used.

If the kset was not able to be created, NULL will be returned.


\section{Kernel utility functions}
\label{driver-api/basics:kernel-utility-functions}\index{REPEAT\_BYTE (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.REPEAT_BYTE}\pysiglinewithargsret{\bfcode{REPEAT\_BYTE}}{\emph{x}}{}
repeat the value \textbf{x} multiple times as an unsigned long value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{x}}] \leavevmode
value to repeat

\end{description}

\textbf{NOTE}

\textbf{x} is not checked for \textgreater{} 0xff; larger values produce odd results.
\index{ARRAY\_SIZE (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.ARRAY_SIZE}\pysiglinewithargsret{\bfcode{ARRAY\_SIZE}}{\emph{arr}}{}
get the number of elements in array \textbf{arr}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{arr}}] \leavevmode
array to be sized

\end{description}
\index{FIELD\_SIZEOF (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.FIELD_SIZEOF}\pysiglinewithargsret{\bfcode{FIELD\_SIZEOF}}{\emph{t}, \emph{f}}{}
get the size of a struct's field

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{t}}] \leavevmode
the target struct

\item[{\code{f}}] \leavevmode
the target struct's field

\end{description}

\textbf{Return}

the size of \textbf{f} in the struct definition without having a
declared instance of \textbf{t}.
\index{upper\_32\_bits (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.upper_32_bits}\pysiglinewithargsret{\bfcode{upper\_32\_bits}}{\emph{n}}{}
return bits 32-63 of a number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{n}}] \leavevmode
the number we're accessing

\end{description}

\textbf{Description}

A basic shift-right of a 64- or 32-bit quantity.  Use this to suppress
the ``right shift count \textgreater{}= width of type'' warning when that quantity is
32-bits.
\index{lower\_32\_bits (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.lower_32_bits}\pysiglinewithargsret{\bfcode{lower\_32\_bits}}{\emph{n}}{}
return bits 0-31 of a number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{n}}] \leavevmode
the number we're accessing

\end{description}
\index{might\_sleep (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.might_sleep}\pysiglinewithargsret{\bfcode{might\_sleep}}{}{}
annotation for functions that can sleep

\end{fulllineitems}


\textbf{Parameters}

\textbf{Description}

this macro will print a stack trace if it is executed in an atomic
context (spinlock, irq-handler, ...).

This is a useful debugging help to be able to catch problems early and not
be bitten later when the calling function happens to sleep when it is not
supposed to.
\index{abs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.abs}\pysiglinewithargsret{\bfcode{abs}}{\emph{x}}{}
return absolute value of an argument

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{x}}] \leavevmode
the value.  If it is unsigned type, it is converted to signed type first.
char is treated as if it was signed (regardless of whether it really is)
but the macro's return type is preserved as char.

\end{description}

\textbf{Return}

an absolute value of x.
\index{reciprocal\_scale (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.reciprocal_scale}\pysiglinewithargsret{u32 \bfcode{reciprocal\_scale}}{u32\emph{ val}, u32\emph{ ep\_ro}}{}
``scale'' a value into range {[}0, ep\_ro)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u32 val}}] \leavevmode
value

\item[{\code{u32 ep\_ro}}] \leavevmode
right open interval endpoint

\end{description}

\textbf{Description}

Perform a ``reciprocal multiplication'' in order to ``scale'' a value into
range {[}0, \textbf{ep\_ro}), where the upper interval endpoint is right-open.
This is useful, e.g. for accessing a index of an array containing
\textbf{ep\_ro} elements, for example. Think of it as sort of modulus, only that
the result isn't that of modulo. ;) Note that if initial input is a
small value, then result will return 0.

\textbf{Return}

a result based on \textbf{val} in interval {[}0, \textbf{ep\_ro}).
\index{kstrtoul (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kstrtoul}\pysiglinewithargsret{int \bfcode{kstrtoul}}{const char *\emph{ s}, unsigned int\emph{ base}, unsigned long *\emph{ res}}{}
convert a string to an unsigned long

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * s}}] \leavevmode
The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign, but not a minus sign.

\item[{\code{unsigned int base}}] \leavevmode
The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.

\item[{\code{unsigned long * res}}] \leavevmode
Where to write the result of the conversion on success.

\end{description}

\textbf{Description}

Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple\_strtoull. Return code must
be checked.
\index{kstrtol (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kstrtol}\pysiglinewithargsret{int \bfcode{kstrtol}}{const char *\emph{ s}, unsigned int\emph{ base}, long *\emph{ res}}{}
convert a string to a long

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * s}}] \leavevmode
The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign or a minus sign.

\item[{\code{unsigned int base}}] \leavevmode
The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.

\item[{\code{long * res}}] \leavevmode
Where to write the result of the conversion on success.

\end{description}

\textbf{Description}

Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple\_strtoull. Return code must
be checked.
\index{trace\_printk (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.trace_printk}\pysiglinewithargsret{\bfcode{trace\_printk}}{\emph{fmt}, \emph{...}}{}
printf formatting in the ftrace buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{fmt}}] \leavevmode
the printf format for printing

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Note}
\begin{description}
\item[{\_\_trace\_printk is an internal function for {\hyperref[driver\string-api/basics:c.trace_printk]{\emph{\code{trace\_printk()}}}} and}] \leavevmode
the \textbf{ip} is passed in via the {\hyperref[driver\string-api/basics:c.trace_printk]{\emph{\code{trace\_printk()}}}} macro.

\end{description}

This function allows a kernel developer to debug fast path sections
that printk is not appropriate for. By scattering in various
printk like tracing in the code, a developer can quickly see
where problems are occurring.

This is intended as a debugging tool for the developer only.
Please refrain from leaving trace\_printks scattered around in
your code. (Extra memory is used for special buffers that are
allocated when {\hyperref[driver\string-api/basics:c.trace_printk]{\emph{\code{trace\_printk()}}}} is used.)

A little optization trick is done here. If there's only one
argument, there's no need to scan the string for printf formats.
The {\hyperref[driver\string-api/basics:c.trace_puts]{\emph{\code{trace\_puts()}}}} will suffice. But how can we take advantage of
using {\hyperref[driver\string-api/basics:c.trace_puts]{\emph{\code{trace\_puts()}}}} when {\hyperref[driver\string-api/basics:c.trace_printk]{\emph{\code{trace\_printk()}}}} has only one argument?
By stringifying the args and checking the size we can tell
whether or not there are args. \_\_stringify((\_\_VA\_ARGS\_\_)) will
turn into ``()0'' with a size of 3 when there are no args, anything
else will be bigger. All we need to do is define a string to this,
and then take its size and compare to 3. If it's bigger, use
\code{do\_trace\_printk()} otherwise, optimize it to {\hyperref[driver\string-api/basics:c.trace_puts]{\emph{\code{trace\_puts()}}}}. Then just
let gcc optimize the rest.
\index{trace\_puts (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.trace_puts}\pysiglinewithargsret{\bfcode{trace\_puts}}{\emph{str}}{}
write a string into the ftrace buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{str}}] \leavevmode
the string to record

\end{description}

\textbf{Note}
\begin{description}
\item[{\_\_trace\_bputs is an internal function for trace\_puts and}] \leavevmode
the \textbf{ip} is passed in via the trace\_puts macro.

\end{description}

This is similar to {\hyperref[driver\string-api/basics:c.trace_printk]{\emph{\code{trace\_printk()}}}} but is made for those really fast
paths that a developer wants the least amount of ``Heisenbug'' effects,
where the processing of the print format is still too much.

This function allows a kernel developer to debug fast path sections
that printk is not appropriate for. By scattering in various
printk like tracing in the code, a developer can quickly see
where problems are occurring.

This is intended as a debugging tool for the developer only.
Please refrain from leaving trace\_puts scattered around in
your code. (Extra memory is used for special buffers that are
allocated when {\hyperref[driver\string-api/basics:c.trace_puts]{\emph{\code{trace\_puts()}}}} is used.)

\textbf{Return}
\begin{description}
\item[{0 if nothing was written, positive \# if string was.}] \leavevmode
(1 when \_\_trace\_bputs is used, strlen(str) when \_\_trace\_puts is used)

\end{description}
\index{min (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.min}\pysiglinewithargsret{\bfcode{min}}{\emph{x}, \emph{y}}{}
return minimum of two values of the same or compatible types

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{x}}] \leavevmode
first value

\item[{\code{y}}] \leavevmode
second value

\end{description}
\index{max (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.max}\pysiglinewithargsret{\bfcode{max}}{\emph{x}, \emph{y}}{}
return maximum of two values of the same or compatible types

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{x}}] \leavevmode
first value

\item[{\code{y}}] \leavevmode
second value

\end{description}
\index{min3 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.min3}\pysiglinewithargsret{\bfcode{min3}}{\emph{x}, \emph{y}, \emph{z}}{}
return minimum of three values

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{x}}] \leavevmode
first value

\item[{\code{y}}] \leavevmode
second value

\item[{\code{z}}] \leavevmode
third value

\end{description}
\index{max3 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.max3}\pysiglinewithargsret{\bfcode{max3}}{\emph{x}, \emph{y}, \emph{z}}{}
return maximum of three values

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{x}}] \leavevmode
first value

\item[{\code{y}}] \leavevmode
second value

\item[{\code{z}}] \leavevmode
third value

\end{description}
\index{min\_not\_zero (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.min_not_zero}\pysiglinewithargsret{\bfcode{min\_not\_zero}}{\emph{x}, \emph{y}}{}
return the minimum that is \_not\_ zero, unless both are zero

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{x}}] \leavevmode
value1

\item[{\code{y}}] \leavevmode
value2

\end{description}
\index{clamp (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.clamp}\pysiglinewithargsret{\bfcode{clamp}}{\emph{val}, \emph{lo}, \emph{hi}}{}
return a value clamped to a given range with strict typechecking

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{val}}] \leavevmode
current value

\item[{\code{lo}}] \leavevmode
lowest allowable value

\item[{\code{hi}}] \leavevmode
highest allowable value

\end{description}

\textbf{Description}

This macro does strict typechecking of \textbf{lo}/\textbf{hi} to make sure they are of the
same type as \textbf{val}.  See the unnecessary pointer comparisons.
\index{min\_t (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.min_t}\pysiglinewithargsret{\bfcode{min\_t}}{\emph{type}, \emph{x}, \emph{y}}{}
return minimum of two values, using the specified type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{type}}] \leavevmode
data type to use

\item[{\code{x}}] \leavevmode
first value

\item[{\code{y}}] \leavevmode
second value

\end{description}
\index{max\_t (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.max_t}\pysiglinewithargsret{\bfcode{max\_t}}{\emph{type}, \emph{x}, \emph{y}}{}
return maximum of two values, using the specified type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{type}}] \leavevmode
data type to use

\item[{\code{x}}] \leavevmode
first value

\item[{\code{y}}] \leavevmode
second value

\end{description}
\index{clamp\_t (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.clamp_t}\pysiglinewithargsret{\bfcode{clamp\_t}}{\emph{type}, \emph{val}, \emph{lo}, \emph{hi}}{}
return a value clamped to a given range using a given type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{type}}] \leavevmode
the type of variable to use

\item[{\code{val}}] \leavevmode
current value

\item[{\code{lo}}] \leavevmode
minimum allowable value

\item[{\code{hi}}] \leavevmode
maximum allowable value

\end{description}

\textbf{Description}

This macro does no typechecking and uses temporary variables of type
\textbf{type} to make all the comparisons.
\index{clamp\_val (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.clamp_val}\pysiglinewithargsret{\bfcode{clamp\_val}}{\emph{val}, \emph{lo}, \emph{hi}}{}
return a value clamped to a given range using val's type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{val}}] \leavevmode
current value

\item[{\code{lo}}] \leavevmode
minimum allowable value

\item[{\code{hi}}] \leavevmode
maximum allowable value

\end{description}

\textbf{Description}

This macro does no typechecking and uses temporary variables of whatever
type the input argument \textbf{val} is.  This is useful when \textbf{val} is an unsigned
type and \textbf{lo} and \textbf{hi} are literals that will otherwise be assigned a signed
integer type.
\index{swap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.swap}\pysiglinewithargsret{\bfcode{swap}}{\emph{a}, \emph{b}}{}
swap values of \textbf{a} and \textbf{b}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{a}}] \leavevmode
first value

\item[{\code{b}}] \leavevmode
second value

\end{description}
\index{container\_of (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.container_of}\pysiglinewithargsret{\bfcode{container\_of}}{\emph{ptr}, \emph{type}, \emph{member}}{}
cast a member of a structure out to the containing structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{ptr}}] \leavevmode
the pointer to the member.

\item[{\code{type}}] \leavevmode
the type of the container struct this is embedded in.

\item[{\code{member}}] \leavevmode
the name of the member within the struct.

\end{description}
\index{printk (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.printk}\pysiglinewithargsret{\_\_visible int \bfcode{printk}}{const char *\emph{ fmt}, ...}{}
print a kernel message

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * fmt}}] \leavevmode
format string

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

This is {\hyperref[driver\string-api/basics:c.printk]{\emph{\code{printk()}}}}. It can be called from any context. We want it to work.

We try to grab the console\_lock. If we succeed, it's easy - we log the
output and call the console drivers.  If we fail to get the semaphore, we
place the output into the log buffer and return. The current holder of
the console\_sem will notice the new output in {\hyperref[driver\string-api/basics:c.console_unlock]{\emph{\code{console\_unlock()}}}}; and will
send it to the consoles before releasing the lock.

One effect of this deferred printing is that code which calls {\hyperref[driver\string-api/basics:c.printk]{\emph{\code{printk()}}}} and
then changes console\_loglevel may break. This is because console\_loglevel
is inspected when the actual printing occurs.

See also:
printf(3)

See the \code{vsnprintf()} documentation for format string extensions over C99.
\index{console\_lock (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.console_lock}\pysiglinewithargsret{void \bfcode{console\_lock}}{void}{}
lock the console system for exclusive use.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Acquires a lock which guarantees that the caller has
exclusive access to the console system and the console\_drivers list.

Can sleep, returns nothing.
\index{console\_trylock (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.console_trylock}\pysiglinewithargsret{int \bfcode{console\_trylock}}{void}{}
try to lock the console system for exclusive use.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Try to acquire a lock which guarantees that the caller has exclusive
access to the console system and the console\_drivers list.

returns 1 on success, and 0 on failure to acquire the lock.
\index{console\_unlock (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.console_unlock}\pysiglinewithargsret{void \bfcode{console\_unlock}}{void}{}
unlock the console system

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Releases the console\_lock which the caller holds on the console system
and the console driver list.

While the console\_lock was held, console output may have been buffered
by {\hyperref[driver\string-api/basics:c.printk]{\emph{\code{printk()}}}}.  If this is the case, {\hyperref[driver\string-api/basics:c.console_unlock]{\emph{\code{console\_unlock()}}}}; emits
the output prior to releasing the lock.

If there is output waiting, we wake /dev/kmsg and \code{syslog()} users.

{\hyperref[driver\string-api/basics:c.console_unlock]{\emph{\code{console\_unlock()}}}}; may be called from any context.
\index{console\_conditional\_schedule (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.console_conditional_schedule}\pysiglinewithargsret{void \_\_sched \bfcode{console\_conditional\_schedule}}{void}{}
yield the CPU if required

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

If the console code is currently allowed to sleep, and
if this CPU should yield the CPU to another task, do
so here.

Must be called within {\hyperref[driver\string-api/basics:c.console_lock]{\emph{\code{console\_lock()}}}};.
\index{printk\_timed\_ratelimit (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.printk_timed_ratelimit}\pysiglinewithargsret{bool \bfcode{printk\_timed\_ratelimit}}{unsigned long *\emph{ caller\_jiffies}, unsigned int\emph{ interval\_msecs}}{}
caller-controlled printk ratelimiting

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long * caller\_jiffies}}] \leavevmode
pointer to caller's state

\item[{\code{unsigned int interval\_msecs}}] \leavevmode
minimum interval between prints

\end{description}

\textbf{Description}

{\hyperref[driver\string-api/basics:c.printk_timed_ratelimit]{\emph{\code{printk\_timed\_ratelimit()}}}} returns true if more than \textbf{interval\_msecs}
milliseconds have elapsed since the last time {\hyperref[driver\string-api/basics:c.printk_timed_ratelimit]{\emph{\code{printk\_timed\_ratelimit()}}}}
returned true.
\index{kmsg\_dump\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kmsg_dump_register}\pysiglinewithargsret{int \bfcode{kmsg\_dump\_register}}{struct kmsg\_dumper *\emph{ dumper}}{}
register a kernel log dumper.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kmsg\_dumper * dumper}}] \leavevmode
pointer to the kmsg\_dumper structure

\end{description}

\textbf{Description}

Adds a kernel log dumper to the system. The dump callback in the
structure will be called when the kernel oopses or panics and must be
set. Returns zero on success and \code{-EINVAL} or \code{-EBUSY} otherwise.
\index{kmsg\_dump\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kmsg_dump_unregister}\pysiglinewithargsret{int \bfcode{kmsg\_dump\_unregister}}{struct kmsg\_dumper *\emph{ dumper}}{}
unregister a kmsg dumper.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kmsg\_dumper * dumper}}] \leavevmode
pointer to the kmsg\_dumper structure

\end{description}

\textbf{Description}

Removes a dump device from the system. Returns zero on success and
\code{-EINVAL} otherwise.
\index{kmsg\_dump\_get\_line (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kmsg_dump_get_line}\pysiglinewithargsret{bool \bfcode{kmsg\_dump\_get\_line}}{struct kmsg\_dumper *\emph{ dumper}, bool\emph{ syslog}, char *\emph{ line}, size\_t\emph{ size}, size\_t *\emph{ len}}{}
retrieve one kmsg log line

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kmsg\_dumper * dumper}}] \leavevmode
registered kmsg dumper

\item[{\code{bool syslog}}] \leavevmode
include the ``\textless{}4\textgreater{}'' prefixes

\item[{\code{char * line}}] \leavevmode
buffer to copy the line to

\item[{\code{size\_t size}}] \leavevmode
maximum size of the buffer

\item[{\code{size\_t * len}}] \leavevmode
length of line placed into buffer

\end{description}

\textbf{Description}

Start at the beginning of the kmsg buffer, with the oldest kmsg
record, and copy one record into the provided buffer.

Consecutive calls will return the next available record moving
towards the end of the buffer with the youngest messages.

A return value of FALSE indicates that there are no more records to
read.
\index{kmsg\_dump\_get\_buffer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kmsg_dump_get_buffer}\pysiglinewithargsret{bool \bfcode{kmsg\_dump\_get\_buffer}}{struct kmsg\_dumper *\emph{ dumper}, bool\emph{ syslog}, char *\emph{ buf}, size\_t\emph{ size}, size\_t *\emph{ len}}{}
copy kmsg log lines

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kmsg\_dumper * dumper}}] \leavevmode
registered kmsg dumper

\item[{\code{bool syslog}}] \leavevmode
include the ``\textless{}4\textgreater{}'' prefixes

\item[{\code{char * buf}}] \leavevmode
buffer to copy the line to

\item[{\code{size\_t size}}] \leavevmode
maximum size of the buffer

\item[{\code{size\_t * len}}] \leavevmode
length of line placed into buffer

\end{description}

\textbf{Description}

Start at the end of the kmsg buffer and fill the provided buffer
with as many of the the \emph{youngest} kmsg records that fit into it.
If the buffer is large enough, all available kmsg records will be
copied with a single call.

Consecutive calls will fill the buffer with the next block of
available older records, not including the earlier retrieved ones.

A return value of FALSE indicates that there are no more records to
read.
\index{kmsg\_dump\_rewind (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.kmsg_dump_rewind}\pysiglinewithargsret{void \bfcode{kmsg\_dump\_rewind}}{struct kmsg\_dumper *\emph{ dumper}}{}
reset the interator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kmsg\_dumper * dumper}}] \leavevmode
registered kmsg dumper

\end{description}

\textbf{Description}

Reset the dumper's iterator so that {\hyperref[driver\string-api/basics:c.kmsg_dump_get_line]{\emph{\code{kmsg\_dump\_get\_line()}}}} and
{\hyperref[driver\string-api/basics:c.kmsg_dump_get_buffer]{\emph{\code{kmsg\_dump\_get\_buffer()}}}} can be called again and used multiple
times within the same dumper.:c:func:\emph{dump()} callback.
\index{panic (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.panic}\pysiglinewithargsret{void \bfcode{panic}}{const char *\emph{ fmt}, ...}{}
halt the system

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * fmt}}] \leavevmode
The text string to print

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}
\begin{quote}

Display a message, then perform cleanups.

This function never returns.
\end{quote}
\index{add\_taint (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.add_taint}\pysiglinewithargsret{void \bfcode{add\_taint}}{unsigned\emph{ flag}, enum lockdep\_ok\emph{ lockdep\_ok}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned flag}}] \leavevmode
one of the TAINT\_* constants.

\item[{\code{enum lockdep\_ok lockdep\_ok}}] \leavevmode
whether lock debugging is still OK.

\end{description}

\textbf{Description}

If something bad has gone wrong, you'll want \textbf{lockdebug\_ok} = false, but for
some notewortht-but-not-corrupting cases, it can be set to true.
\index{rcu\_is\_watching (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.rcu_is_watching}\pysiglinewithargsret{bool notrace \bfcode{rcu\_is\_watching}}{void}{}
see if RCU thinks that the current CPU is idle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Return true if RCU is watching the running CPU, which means that this
CPU can safely enter RCU read-side critical sections.  In other words,
if the current CPU is in its idle loop and is neither in an interrupt
or NMI handler, return true.
\index{call\_rcu\_sched (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.call_rcu_sched}\pysiglinewithargsret{void \bfcode{call\_rcu\_sched}}{struct rcu\_head *\emph{ head}, rcu\_callback\_t\emph{ func}}{}
Queue an RCU for invocation after sched grace period.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rcu\_head * head}}] \leavevmode
structure to be used for queueing the RCU updates.

\item[{\code{rcu\_callback\_t func}}] \leavevmode
actual callback function to be invoked after the grace period

\end{description}

\textbf{Description}

The callback function will be invoked some time after a full grace
period elapses, in other words after all currently executing RCU
read-side critical sections have completed. {\hyperref[driver\string-api/basics:c.call_rcu_sched]{\emph{\code{call\_rcu\_sched()}}}} assumes
that the read-side critical sections end on enabling of preemption
or on voluntary preemption.
RCU read-side critical sections are delimited by:
\begin{itemize}
\item {} 
\code{rcu\_read\_lock\_sched()} and \code{rcu\_read\_unlock\_sched()}, OR

\item {} 
anything that disables preemption.

\end{itemize}
\begin{quote}

These may be nested.
\end{quote}

See the description of {\hyperref[driver\string-api/basics:c.call_rcu]{\emph{\code{call\_rcu()}}}} for more detailed information on
memory ordering guarantees.
\index{call\_rcu\_bh (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.call_rcu_bh}\pysiglinewithargsret{void \bfcode{call\_rcu\_bh}}{struct rcu\_head *\emph{ head}, rcu\_callback\_t\emph{ func}}{}
Queue an RCU for invocation after a quicker grace period.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rcu\_head * head}}] \leavevmode
structure to be used for queueing the RCU updates.

\item[{\code{rcu\_callback\_t func}}] \leavevmode
actual callback function to be invoked after the grace period

\end{description}

\textbf{Description}

The callback function will be invoked some time after a full grace
period elapses, in other words after all currently executing RCU
read-side critical sections have completed. {\hyperref[driver\string-api/basics:c.call_rcu_bh]{\emph{\code{call\_rcu\_bh()}}}} assumes
that the read-side critical sections end on completion of a softirq
handler. This means that read-side critical sections in process
context must not be interrupted by softirqs. This interface is to be
used when most of the read-side critical sections are in softirq context.
RCU read-side critical sections are delimited by:
\begin{itemize}
\item {} 
\code{rcu\_read\_lock()} and  \code{rcu\_read\_unlock()}, if in interrupt context, OR

\item {} 
\code{rcu\_read\_lock\_bh()} and \code{rcu\_read\_unlock\_bh()}, if in process context.

\end{itemize}

These may be nested.

See the description of {\hyperref[driver\string-api/basics:c.call_rcu]{\emph{\code{call\_rcu()}}}} for more detailed information on
memory ordering guarantees.
\index{synchronize\_sched (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.synchronize_sched}\pysiglinewithargsret{void \bfcode{synchronize\_sched}}{void}{}
wait until an rcu-sched grace period has elapsed.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Control will return to the caller some time after a full rcu-sched
grace period has elapsed, in other words after all currently executing
rcu-sched read-side critical sections have completed.   These read-side
critical sections are delimited by \code{rcu\_read\_lock\_sched()} and
\code{rcu\_read\_unlock\_sched()}, and may be nested.  Note that \code{preempt\_disable()},
\code{local\_irq\_disable()}, and so on may be used in place of
\code{rcu\_read\_lock\_sched()}.

This means that all preempt\_disable code sequences, including NMI and
non-threaded hardware-interrupt handlers, in progress on entry will
have completed before this primitive returns.  However, this does not
guarantee that softirq handlers will have completed, since in some
kernels, these handlers can run in process context, and can block.

Note that this guarantee implies further memory-ordering guarantees.
On systems with more than one CPU, when {\hyperref[driver\string-api/basics:c.synchronize_sched]{\emph{\code{synchronize\_sched()}}}} returns,
each CPU is guaranteed to have executed a full memory barrier since the
end of its last RCU-sched read-side critical section whose beginning
preceded the call to {\hyperref[driver\string-api/basics:c.synchronize_sched]{\emph{\code{synchronize\_sched()}}}}.  In addition, each CPU having
an RCU read-side critical section that extends beyond the return from
{\hyperref[driver\string-api/basics:c.synchronize_sched]{\emph{\code{synchronize\_sched()}}}} is guaranteed to have executed a full memory barrier
after the beginning of {\hyperref[driver\string-api/basics:c.synchronize_sched]{\emph{\code{synchronize\_sched()}}}} and before the beginning of
that RCU read-side critical section.  Note that these guarantees include
CPUs that are offline, idle, or executing in user mode, as well as CPUs
that are executing in the kernel.

Furthermore, if CPU A invoked {\hyperref[driver\string-api/basics:c.synchronize_sched]{\emph{\code{synchronize\_sched()}}}}, which returned
to its caller on CPU B, then both CPU A and CPU B are guaranteed
to have executed a full memory barrier during the execution of
{\hyperref[driver\string-api/basics:c.synchronize_sched]{\emph{\code{synchronize\_sched()}}}} -- even if CPU A and CPU B are the same CPU (but
again only if the system has more than one CPU).
\index{synchronize\_rcu\_bh (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.synchronize_rcu_bh}\pysiglinewithargsret{void \bfcode{synchronize\_rcu\_bh}}{void}{}
wait until an rcu\_bh grace period has elapsed.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Control will return to the caller some time after a full rcu\_bh grace
period has elapsed, in other words after all currently executing rcu\_bh
read-side critical sections have completed.  RCU read-side critical
sections are delimited by \code{rcu\_read\_lock\_bh()} and \code{rcu\_read\_unlock\_bh()},
and may be nested.

See the description of {\hyperref[driver\string-api/basics:c.synchronize_sched]{\emph{\code{synchronize\_sched()}}}} for more detailed information
on memory ordering guarantees.
\index{get\_state\_synchronize\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.get_state_synchronize_rcu}\pysiglinewithargsret{unsigned long \bfcode{get\_state\_synchronize\_rcu}}{void}{}
Snapshot current RCU state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Returns a cookie that is used by a later call to {\hyperref[driver\string-api/basics:c.cond_synchronize_rcu]{\emph{\code{cond\_synchronize\_rcu()}}}}
to determine whether or not a full grace period has elapsed in the
meantime.
\index{cond\_synchronize\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.cond_synchronize_rcu}\pysiglinewithargsret{void \bfcode{cond\_synchronize\_rcu}}{unsigned long\emph{ oldstate}}{}
Conditionally wait for an RCU grace period

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long oldstate}}] \leavevmode
return value from earlier call to {\hyperref[driver\string-api/basics:c.get_state_synchronize_rcu]{\emph{\code{get\_state\_synchronize\_rcu()}}}}

\end{description}

\textbf{Description}

If a full RCU grace period has elapsed since the earlier call to
{\hyperref[driver\string-api/basics:c.get_state_synchronize_rcu]{\emph{\code{get\_state\_synchronize\_rcu()}}}}, just return.  Otherwise, invoke
{\hyperref[driver\string-api/basics:c.synchronize_rcu]{\emph{\code{synchronize\_rcu()}}}} to wait for a full grace period.

Yes, this function does not take counter wrap into account.  But
counter wrap is harmless.  If the counter wraps, we have waited for
more than 2 billion grace periods (and way more on a 64-bit system!),
so waiting for one additional grace period should be just fine.
\index{get\_state\_synchronize\_sched (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.get_state_synchronize_sched}\pysiglinewithargsret{unsigned long \bfcode{get\_state\_synchronize\_sched}}{void}{}
Snapshot current RCU-sched state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Returns a cookie that is used by a later call to {\hyperref[driver\string-api/basics:c.cond_synchronize_sched]{\emph{\code{cond\_synchronize\_sched()}}}}
to determine whether or not a full grace period has elapsed in the
meantime.
\index{cond\_synchronize\_sched (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.cond_synchronize_sched}\pysiglinewithargsret{void \bfcode{cond\_synchronize\_sched}}{unsigned long\emph{ oldstate}}{}
Conditionally wait for an RCU-sched grace period

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long oldstate}}] \leavevmode
return value from earlier call to {\hyperref[driver\string-api/basics:c.get_state_synchronize_sched]{\emph{\code{get\_state\_synchronize\_sched()}}}}

\end{description}

\textbf{Description}

If a full RCU-sched grace period has elapsed since the earlier call to
{\hyperref[driver\string-api/basics:c.get_state_synchronize_sched]{\emph{\code{get\_state\_synchronize\_sched()}}}}, just return.  Otherwise, invoke
{\hyperref[driver\string-api/basics:c.synchronize_sched]{\emph{\code{synchronize\_sched()}}}} to wait for a full grace period.

Yes, this function does not take counter wrap into account.  But
counter wrap is harmless.  If the counter wraps, we have waited for
more than 2 billion grace periods (and way more on a 64-bit system!),
so waiting for one additional grace period should be just fine.
\index{rcu\_barrier\_bh (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.rcu_barrier_bh}\pysiglinewithargsret{void \bfcode{rcu\_barrier\_bh}}{void}{}
Wait until all in-flight {\hyperref[driver\string-api/basics:c.call_rcu_bh]{\emph{\code{call\_rcu\_bh()}}}} callbacks complete.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}
\index{rcu\_barrier\_sched (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.rcu_barrier_sched}\pysiglinewithargsret{void \bfcode{rcu\_barrier\_sched}}{void}{}
Wait for in-flight {\hyperref[driver\string-api/basics:c.call_rcu_sched]{\emph{\code{call\_rcu\_sched()}}}} callbacks.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}
\index{call\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.call_rcu}\pysiglinewithargsret{void \bfcode{call\_rcu}}{struct rcu\_head *\emph{ head}, rcu\_callback\_t\emph{ func}}{}
Queue an RCU callback for invocation after a grace period.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rcu\_head * head}}] \leavevmode
structure to be used for queueing the RCU updates.

\item[{\code{rcu\_callback\_t func}}] \leavevmode
actual callback function to be invoked after the grace period

\end{description}

\textbf{Description}

The callback function will be invoked some time after a full grace
period elapses, in other words after all pre-existing RCU read-side
critical sections have completed.  However, the callback function
might well execute concurrently with RCU read-side critical sections
that started after {\hyperref[driver\string-api/basics:c.call_rcu]{\emph{\code{call\_rcu()}}}} was invoked.  RCU read-side critical
sections are delimited by \code{rcu\_read\_lock()} and \code{rcu\_read\_unlock()},
and may be nested.

Note that all CPUs must agree that the grace period extended beyond
all pre-existing RCU read-side critical section.  On systems with more
than one CPU, this means that when ``\code{func()}'' is invoked, each CPU is
guaranteed to have executed a full memory barrier since the end of its
last RCU read-side critical section whose beginning preceded the call
to {\hyperref[driver\string-api/basics:c.call_rcu]{\emph{\code{call\_rcu()}}}}.  It also means that each CPU executing an RCU read-side
critical section that continues beyond the start of ``\code{func()}'' must have
executed a memory barrier after the {\hyperref[driver\string-api/basics:c.call_rcu]{\emph{\code{call\_rcu()}}}} but before the beginning
of that RCU read-side critical section.  Note that these guarantees
include CPUs that are offline, idle, or executing in user mode, as
well as CPUs that are executing in the kernel.

Furthermore, if CPU A invoked {\hyperref[driver\string-api/basics:c.call_rcu]{\emph{\code{call\_rcu()}}}} and CPU B invoked the
resulting RCU callback function ``\code{func()}'', then both CPU A and CPU B are
guaranteed to execute a full memory barrier during the time interval
between the call to {\hyperref[driver\string-api/basics:c.call_rcu]{\emph{\code{call\_rcu()}}}} and the invocation of ``\code{func()}'' -- even
if CPU A and CPU B are the same CPU (but again only if the system has
more than one CPU).
\index{synchronize\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.synchronize_rcu}\pysiglinewithargsret{void \bfcode{synchronize\_rcu}}{void}{}
wait until a grace period has elapsed.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Control will return to the caller some time after a full grace
period has elapsed, in other words after all currently executing RCU
read-side critical sections have completed.  Note, however, that
upon return from {\hyperref[driver\string-api/basics:c.synchronize_rcu]{\emph{\code{synchronize\_rcu()}}}}, the caller might well be executing
concurrently with new RCU read-side critical sections that began while
{\hyperref[driver\string-api/basics:c.synchronize_rcu]{\emph{\code{synchronize\_rcu()}}}} was waiting.  RCU read-side critical sections are
delimited by \code{rcu\_read\_lock()} and \code{rcu\_read\_unlock()}, and may be nested.

See the description of {\hyperref[driver\string-api/basics:c.synchronize_sched]{\emph{\code{synchronize\_sched()}}}} for more detailed
information on memory-ordering guarantees.  However, please note
that -only- the memory-ordering guarantees apply.  For example,
{\hyperref[driver\string-api/basics:c.synchronize_rcu]{\emph{\code{synchronize\_rcu()}}}} is -not- guaranteed to wait on things like code
protected by \code{preempt\_disable()}, instead, {\hyperref[driver\string-api/basics:c.synchronize_rcu]{\emph{\code{synchronize\_rcu()}}}} is -only-
guaranteed to wait on RCU read-side critical sections, that is, sections
of code protected by \code{rcu\_read\_lock()}.
\index{rcu\_barrier (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.rcu_barrier}\pysiglinewithargsret{void \bfcode{rcu\_barrier}}{void}{}
Wait until all in-flight {\hyperref[driver\string-api/basics:c.call_rcu]{\emph{\code{call\_rcu()}}}} callbacks complete.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Note that this primitive does not necessarily wait for an RCU grace period
to complete.  For example, if there are no RCU callbacks queued anywhere
in the system, then {\hyperref[driver\string-api/basics:c.rcu_barrier]{\emph{\code{rcu\_barrier()}}}} is within its rights to return
immediately, without waiting for anything, much less an RCU grace period.
\index{rcu\_read\_lock\_sched\_held (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.rcu_read_lock_sched_held}\pysiglinewithargsret{int \bfcode{rcu\_read\_lock\_sched\_held}}{void}{}
might we be in RCU-sched read-side critical section?

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

If CONFIG\_DEBUG\_LOCK\_ALLOC is selected, returns nonzero iff in an
RCU-sched read-side critical section.  In absence of
CONFIG\_DEBUG\_LOCK\_ALLOC, this assumes we are in an RCU-sched read-side
critical section unless it can prove otherwise.  Note that disabling
of preemption (including disabling irqs) counts as an RCU-sched
read-side critical section.  This is useful for debug checks in functions
that required that they be called within an RCU-sched read-side
critical section.

Check \code{debug\_lockdep\_rcu\_enabled()} to prevent false positives during boot
and while lockdep is disabled.

Note that if the CPU is in the idle loop from an RCU point of
view (ie: that we are in the section between \code{rcu\_idle\_enter()} and
\code{rcu\_idle\_exit()}) then {\hyperref[driver\string-api/basics:c.rcu_read_lock_held]{\emph{\code{rcu\_read\_lock\_held()}}}} returns false even if the CPU
did an \code{rcu\_read\_lock()}.  The reason for this is that RCU ignores CPUs
that are in such a section, considering these as in extended quiescent
state, so such a CPU is effectively never in an RCU read-side critical
section regardless of what RCU primitives it invokes.  This state of
affairs is required --- we need to keep an RCU-free window in idle
where the CPU may possibly enter into low power mode. This way we can
notice an extended quiescent state to other CPUs that started a grace
period. Otherwise we would delay any grace period as long as we run in
the idle task.

Similarly, we avoid claiming an SRCU read lock held if the current
CPU is offline.
\index{rcu\_expedite\_gp (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.rcu_expedite_gp}\pysiglinewithargsret{void \bfcode{rcu\_expedite\_gp}}{void}{}
Expedite future RCU grace periods

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

After a call to this function, future calls to {\hyperref[driver\string-api/basics:c.synchronize_rcu]{\emph{\code{synchronize\_rcu()}}}} and
friends act as the corresponding \code{synchronize\_rcu\_expedited()} function
had instead been called.
\index{rcu\_unexpedite\_gp (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.rcu_unexpedite_gp}\pysiglinewithargsret{void \bfcode{rcu\_unexpedite\_gp}}{void}{}
Cancel prior {\hyperref[driver\string-api/basics:c.rcu_expedite_gp]{\emph{\code{rcu\_expedite\_gp()}}}} invocation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Undo a prior call to {\hyperref[driver\string-api/basics:c.rcu_expedite_gp]{\emph{\code{rcu\_expedite\_gp()}}}}.  If all prior calls to
{\hyperref[driver\string-api/basics:c.rcu_expedite_gp]{\emph{\code{rcu\_expedite\_gp()}}}} are undone by a subsequent call to {\hyperref[driver\string-api/basics:c.rcu_unexpedite_gp]{\emph{\code{rcu\_unexpedite\_gp()}}}},
and if the rcu\_expedited sysfs/boot parameter is not set, then all
subsequent calls to {\hyperref[driver\string-api/basics:c.synchronize_rcu]{\emph{\code{synchronize\_rcu()}}}} and friends will return to
their normal non-expedited behavior.
\index{rcu\_read\_lock\_held (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.rcu_read_lock_held}\pysiglinewithargsret{int \bfcode{rcu\_read\_lock\_held}}{void}{}
might we be in RCU read-side critical section?

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

If CONFIG\_DEBUG\_LOCK\_ALLOC is selected, returns nonzero iff in an RCU
read-side critical section.  In absence of CONFIG\_DEBUG\_LOCK\_ALLOC,
this assumes we are in an RCU read-side critical section unless it can
prove otherwise.  This is useful for debug checks in functions that
require that they be called within an RCU read-side critical section.

Checks \code{debug\_lockdep\_rcu\_enabled()} to prevent false positives during boot
and while lockdep is disabled.

Note that \code{rcu\_read\_lock()} and the matching \code{rcu\_read\_unlock()} must
occur in the same context, for example, it is illegal to invoke
\code{rcu\_read\_unlock()} in process context if the matching \code{rcu\_read\_lock()}
was invoked from within an irq handler.

Note that \code{rcu\_read\_lock()} is disallowed if the CPU is either idle or
offline from an RCU perspective, so check for those as well.
\index{rcu\_read\_lock\_bh\_held (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.rcu_read_lock_bh_held}\pysiglinewithargsret{int \bfcode{rcu\_read\_lock\_bh\_held}}{void}{}
might we be in RCU-bh read-side critical section?

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Check for bottom half being disabled, which covers both the
CONFIG\_PROVE\_RCU and not cases.  Note that if someone uses
\code{rcu\_read\_lock\_bh()}, but then later enables BH, lockdep (if enabled)
will show the situation.  This is useful for debug checks in functions
that require that they be called within an RCU read-side critical
section.

Check \code{debug\_lockdep\_rcu\_enabled()} to prevent false positives during boot.

Note that \code{rcu\_read\_lock()} is disallowed if the CPU is either idle or
offline from an RCU perspective, so check for those as well.
\index{wakeme\_after\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.wakeme_after_rcu}\pysiglinewithargsret{void \bfcode{wakeme\_after\_rcu}}{struct rcu\_head *\emph{ head}}{}
Callback function to awaken a task after grace period

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rcu\_head * head}}] \leavevmode
Pointer to rcu\_head member within rcu\_synchronize structure

\end{description}

\textbf{Description}

Awaken the corresponding task now that a grace period has elapsed.
\index{init\_rcu\_head\_on\_stack (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.init_rcu_head_on_stack}\pysiglinewithargsret{void \bfcode{init\_rcu\_head\_on\_stack}}{struct rcu\_head *\emph{ head}}{}
initialize on-stack rcu\_head for debugobjects

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rcu\_head * head}}] \leavevmode
pointer to rcu\_head structure to be initialized

\end{description}

\textbf{Description}

This function informs debugobjects of a new rcu\_head structure that
has been allocated as an auto variable on the stack.  This function
is not required for rcu\_head structures that are statically defined or
that are dynamically allocated on the heap.  This function has no
effect for !CONFIG\_DEBUG\_OBJECTS\_RCU\_HEAD kernel builds.
\index{destroy\_rcu\_head\_on\_stack (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.destroy_rcu_head_on_stack}\pysiglinewithargsret{void \bfcode{destroy\_rcu\_head\_on\_stack}}{struct rcu\_head *\emph{ head}}{}
destroy on-stack rcu\_head for debugobjects

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rcu\_head * head}}] \leavevmode
pointer to rcu\_head structure to be initialized

\end{description}

\textbf{Description}

This function informs debugobjects that an on-stack rcu\_head structure
is about to go out of scope.  As with {\hyperref[driver\string-api/basics:c.init_rcu_head_on_stack]{\emph{\code{init\_rcu\_head\_on\_stack()}}}}, this
function is not required for rcu\_head structures that are statically
defined or that are dynamically allocated on the heap.  Also as with
{\hyperref[driver\string-api/basics:c.init_rcu_head_on_stack]{\emph{\code{init\_rcu\_head\_on\_stack()}}}}, this function has no effect for
!CONFIG\_DEBUG\_OBJECTS\_RCU\_HEAD kernel builds.
\index{call\_rcu\_tasks (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.call_rcu_tasks}\pysiglinewithargsret{void \bfcode{call\_rcu\_tasks}}{struct rcu\_head *\emph{ rhp}, rcu\_callback\_t\emph{ func}}{}
Queue an RCU for invocation task-based grace period

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rcu\_head * rhp}}] \leavevmode
structure to be used for queueing the RCU updates.

\item[{\code{rcu\_callback\_t func}}] \leavevmode
actual callback function to be invoked after the grace period

\end{description}

\textbf{Description}

The callback function will be invoked some time after a full grace
period elapses, in other words after all currently executing RCU
read-side critical sections have completed. {\hyperref[driver\string-api/basics:c.call_rcu_tasks]{\emph{\code{call\_rcu\_tasks()}}}} assumes
that the read-side critical sections end at a voluntary context
switch (not a preemption!), entry into idle, or transition to usermode
execution.  As such, there are no read-side primitives analogous to
\code{rcu\_read\_lock()} and \code{rcu\_read\_unlock()} because this primitive is intended
to determine that all tasks have passed through a safe state, not so
much for data-strcuture synchronization.

See the description of {\hyperref[driver\string-api/basics:c.call_rcu]{\emph{\code{call\_rcu()}}}} for more detailed information on
memory ordering guarantees.
\index{synchronize\_rcu\_tasks (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.synchronize_rcu_tasks}\pysiglinewithargsret{void \bfcode{synchronize\_rcu\_tasks}}{void}{}
wait until an rcu-tasks grace period has elapsed.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Control will return to the caller some time after a full rcu-tasks
grace period has elapsed, in other words after all currently
executing rcu-tasks read-side critical sections have elapsed.  These
read-side critical sections are delimited by calls to \code{schedule()},
\code{cond\_resched\_rcu\_qs()}, idle execution, userspace execution, calls
to {\hyperref[driver\string-api/basics:c.synchronize_rcu_tasks]{\emph{\code{synchronize\_rcu\_tasks()}}}}, and (in theory, anyway) \code{cond\_resched()}.

This is a very specialized primitive, intended only for a few uses in
tracing and other situations requiring manipulation of function
preambles and profiling hooks.  The {\hyperref[driver\string-api/basics:c.synchronize_rcu_tasks]{\emph{\code{synchronize\_rcu\_tasks()}}}} function
is not (yet) intended for heavy use from multiple CPUs.

Note that this guarantee implies further memory-ordering guarantees.
On systems with more than one CPU, when {\hyperref[driver\string-api/basics:c.synchronize_rcu_tasks]{\emph{\code{synchronize\_rcu\_tasks()}}}} returns,
each CPU is guaranteed to have executed a full memory barrier since the
end of its last RCU-tasks read-side critical section whose beginning
preceded the call to {\hyperref[driver\string-api/basics:c.synchronize_rcu_tasks]{\emph{\code{synchronize\_rcu\_tasks()}}}}.  In addition, each CPU
having an RCU-tasks read-side critical section that extends beyond
the return from {\hyperref[driver\string-api/basics:c.synchronize_rcu_tasks]{\emph{\code{synchronize\_rcu\_tasks()}}}} is guaranteed to have executed
a full memory barrier after the beginning of {\hyperref[driver\string-api/basics:c.synchronize_rcu_tasks]{\emph{\code{synchronize\_rcu\_tasks()}}}}
and before the beginning of that RCU-tasks read-side critical section.
Note that these guarantees include CPUs that are offline, idle, or
executing in user mode, as well as CPUs that are executing in the kernel.

Furthermore, if CPU A invoked {\hyperref[driver\string-api/basics:c.synchronize_rcu_tasks]{\emph{\code{synchronize\_rcu\_tasks()}}}}, which returned
to its caller on CPU B, then both CPU A and CPU B are guaranteed
to have executed a full memory barrier during the execution of
{\hyperref[driver\string-api/basics:c.synchronize_rcu_tasks]{\emph{\code{synchronize\_rcu\_tasks()}}}} -- even if CPU A and CPU B are the same CPU
(but again only if the system has more than one CPU).
\index{rcu\_barrier\_tasks (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.rcu_barrier_tasks}\pysiglinewithargsret{void \bfcode{rcu\_barrier\_tasks}}{void}{}
Wait for in-flight {\hyperref[driver\string-api/basics:c.call_rcu_tasks]{\emph{\code{call\_rcu\_tasks()}}}} callbacks.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Although the current implementation is guaranteed to wait, it is not
obligated to, for example, if there are no pending callbacks.


\section{Device Resource Management}
\label{driver-api/basics:device-resource-management}\index{devres\_alloc\_node (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devres_alloc_node}\pysiglinewithargsret{void * \bfcode{devres\_alloc\_node}}{dr\_release\_t\emph{ release}, size\_t\emph{ size}, gfp\_t\emph{ gfp}, int\emph{ nid}}{}
Allocate device resource data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{dr\_release\_t release}}] \leavevmode
Release function devres will be associated with

\item[{\code{size\_t size}}] \leavevmode
Allocation size

\item[{\code{gfp\_t gfp}}] \leavevmode
Allocation flags

\item[{\code{int nid}}] \leavevmode
NUMA node

\end{description}

\textbf{Description}

Allocate devres of \textbf{size} bytes.  The allocated area is zeroed, then
associated with \textbf{release}.  The returned pointer can be passed to
other devres\_*() functions.

\textbf{Return}

Pointer to allocated devres on success, NULL on failure.
\index{devres\_for\_each\_res (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devres_for_each_res}\pysiglinewithargsret{void \bfcode{devres\_for\_each\_res}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, dr\_release\_t\emph{ release}, dr\_match\_t\emph{ match}, void *\emph{ match\_data}, void (*fn) (struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}}\emph{ *}, void\emph{ *}, void\emph{ *}, void *\emph{ data}}{}
Resource iterator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to iterate resource from

\item[{\code{dr\_release\_t release}}] \leavevmode
Look for resources associated with this release function

\item[{\code{dr\_match\_t match}}] \leavevmode
Match function (optional)

\item[{\code{void * match\_data}}] \leavevmode
Data for the match function

\item[{\code{void (*)(struct device *, void *, void *) fn}}] \leavevmode
Function to be called for each matched resource.

\item[{\code{void * data}}] \leavevmode
Data for \textbf{fn}, the 3rd parameter of \textbf{fn}

\end{description}

\textbf{Description}

Call \textbf{fn} for each devres of \textbf{dev} which is associated with \textbf{release}
and for which \textbf{match} returns 1.

\textbf{Return}
\begin{quote}

void
\end{quote}
\index{devres\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devres_free}\pysiglinewithargsret{void \bfcode{devres\_free}}{void *\emph{ res}}{}
Free device resource data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * res}}] \leavevmode
Pointer to devres data to free

\end{description}

\textbf{Description}

Free devres created with \code{devres\_alloc()}.
\index{devres\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devres_add}\pysiglinewithargsret{void \bfcode{devres\_add}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, void *\emph{ res}}{}
Register device resource

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to add resource to

\item[{\code{void * res}}] \leavevmode
Resource to register

\end{description}

\textbf{Description}

Register devres \textbf{res} to \textbf{dev}.  \textbf{res} should have been allocated
using \code{devres\_alloc()}.  On driver detach, the associated release
function will be invoked and devres will be freed automatically.
\index{devres\_find (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devres_find}\pysiglinewithargsret{void * \bfcode{devres\_find}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, dr\_release\_t\emph{ release}, dr\_match\_t\emph{ match}, void *\emph{ match\_data}}{}
Find device resource

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to lookup resource from

\item[{\code{dr\_release\_t release}}] \leavevmode
Look for resources associated with this release function

\item[{\code{dr\_match\_t match}}] \leavevmode
Match function (optional)

\item[{\code{void * match\_data}}] \leavevmode
Data for the match function

\end{description}

\textbf{Description}

Find the latest devres of \textbf{dev} which is associated with \textbf{release}
and for which \textbf{match} returns 1.  If \textbf{match} is NULL, it's considered
to match all.

\textbf{Return}

Pointer to found devres, NULL if not found.
\index{devres\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devres_get}\pysiglinewithargsret{void * \bfcode{devres\_get}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, void *\emph{ new\_res}, dr\_match\_t\emph{ match}, void *\emph{ match\_data}}{}
Find devres, if non-existent, add one atomically

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to lookup or add devres for

\item[{\code{void * new\_res}}] \leavevmode
Pointer to new initialized devres to add if not found

\item[{\code{dr\_match\_t match}}] \leavevmode
Match function (optional)

\item[{\code{void * match\_data}}] \leavevmode
Data for the match function

\end{description}

\textbf{Description}

Find the latest devres of \textbf{dev} which has the same release function
as \textbf{new\_res} and for which \textbf{match} return 1.  If found, \textbf{new\_res} is
freed; otherwise, \textbf{new\_res} is added atomically.

\textbf{Return}

Pointer to found or added devres.
\index{devres\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devres_remove}\pysiglinewithargsret{void * \bfcode{devres\_remove}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, dr\_release\_t\emph{ release}, dr\_match\_t\emph{ match}, void *\emph{ match\_data}}{}
Find a device resource and remove it

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to find resource from

\item[{\code{dr\_release\_t release}}] \leavevmode
Look for resources associated with this release function

\item[{\code{dr\_match\_t match}}] \leavevmode
Match function (optional)

\item[{\code{void * match\_data}}] \leavevmode
Data for the match function

\end{description}

\textbf{Description}

Find the latest devres of \textbf{dev} associated with \textbf{release} and for
which \textbf{match} returns 1.  If \textbf{match} is NULL, it's considered to
match all.  If found, the resource is removed atomically and
returned.

\textbf{Return}

Pointer to removed devres on success, NULL if not found.
\index{devres\_destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devres_destroy}\pysiglinewithargsret{int \bfcode{devres\_destroy}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, dr\_release\_t\emph{ release}, dr\_match\_t\emph{ match}, void *\emph{ match\_data}}{}
Find a device resource and destroy it

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to find resource from

\item[{\code{dr\_release\_t release}}] \leavevmode
Look for resources associated with this release function

\item[{\code{dr\_match\_t match}}] \leavevmode
Match function (optional)

\item[{\code{void * match\_data}}] \leavevmode
Data for the match function

\end{description}

\textbf{Description}

Find the latest devres of \textbf{dev} associated with \textbf{release} and for
which \textbf{match} returns 1.  If \textbf{match} is NULL, it's considered to
match all.  If found, the resource is removed atomically and freed.

Note that the release function for the resource will not be called,
only the devres-allocated data will be freed.  The caller becomes
responsible for freeing any other data.

\textbf{Return}

0 if devres is found and freed, -ENOENT if not found.
\index{devres\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devres_release}\pysiglinewithargsret{int \bfcode{devres\_release}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, dr\_release\_t\emph{ release}, dr\_match\_t\emph{ match}, void *\emph{ match\_data}}{}
Find a device resource and destroy it, calling release

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to find resource from

\item[{\code{dr\_release\_t release}}] \leavevmode
Look for resources associated with this release function

\item[{\code{dr\_match\_t match}}] \leavevmode
Match function (optional)

\item[{\code{void * match\_data}}] \leavevmode
Data for the match function

\end{description}

\textbf{Description}

Find the latest devres of \textbf{dev} associated with \textbf{release} and for
which \textbf{match} returns 1.  If \textbf{match} is NULL, it's considered to
match all.  If found, the resource is removed atomically, the
release function called and the resource freed.

\textbf{Return}

0 if devres is found and freed, -ENOENT if not found.
\index{devres\_open\_group (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devres_open_group}\pysiglinewithargsret{void * \bfcode{devres\_open\_group}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, void *\emph{ id}, gfp\_t\emph{ gfp}}{}
Open a new devres group

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to open devres group for

\item[{\code{void * id}}] \leavevmode
Separator ID

\item[{\code{gfp\_t gfp}}] \leavevmode
Allocation flags

\end{description}

\textbf{Description}

Open a new devres group for \textbf{dev} with \textbf{id}.  For \textbf{id}, using a
pointer to an object which won't be used for another group is
recommended.  If \textbf{id} is NULL, address-wise unique ID is created.

\textbf{Return}

ID of the new group, NULL on failure.
\index{devres\_close\_group (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devres_close_group}\pysiglinewithargsret{void \bfcode{devres\_close\_group}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, void *\emph{ id}}{}
Close a devres group

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to close devres group for

\item[{\code{void * id}}] \leavevmode
ID of target group, can be NULL

\end{description}

\textbf{Description}

Close the group identified by \textbf{id}.  If \textbf{id} is NULL, the latest open
group is selected.
\index{devres\_remove\_group (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devres_remove_group}\pysiglinewithargsret{void \bfcode{devres\_remove\_group}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, void *\emph{ id}}{}
Remove a devres group

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to remove group for

\item[{\code{void * id}}] \leavevmode
ID of target group, can be NULL

\end{description}

\textbf{Description}

Remove the group identified by \textbf{id}.  If \textbf{id} is NULL, the latest
open group is selected.  Note that removing a group doesn't affect
any other resources.
\index{devres\_release\_group (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devres_release_group}\pysiglinewithargsret{int \bfcode{devres\_release\_group}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, void *\emph{ id}}{}
Release resources in a devres group

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to release group for

\item[{\code{void * id}}] \leavevmode
ID of target group, can be NULL

\end{description}

\textbf{Description}

Release all resources in the group identified by \textbf{id}.  If \textbf{id} is
NULL, the latest open group is selected.  The selected group and
groups properly nested inside the selected group are removed.

\textbf{Return}

The number of released non-group resources.
\index{devm\_add\_action (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devm_add_action}\pysiglinewithargsret{int \bfcode{devm\_add\_action}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, void (*action) (void\emph{ *}, void *\emph{ data}}{}
add a custom action to list of managed resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device that owns the action

\item[{\code{void (*)(void *) action}}] \leavevmode
Function that should be called

\item[{\code{void * data}}] \leavevmode
Pointer to data passed to \textbf{action} implementation

\end{description}

\textbf{Description}

This adds a custom action to the list of managed resources so that
it gets executed as part of standard resource unwinding.
\index{devm\_remove\_action (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devm_remove_action}\pysiglinewithargsret{void \bfcode{devm\_remove\_action}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, void (*action) (void\emph{ *}, void *\emph{ data}}{}
removes previously added custom action

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device that owns the action

\item[{\code{void (*)(void *) action}}] \leavevmode
Function implementing the action

\item[{\code{void * data}}] \leavevmode
Pointer to data passed to \textbf{action} implementation

\end{description}

\textbf{Description}

Removes instance of \textbf{action} previously added by {\hyperref[driver\string-api/basics:c.devm_add_action]{\emph{\code{devm\_add\_action()}}}}.
Both action and data should match one of the existing entries.
\index{devm\_kmalloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devm_kmalloc}\pysiglinewithargsret{void * \bfcode{devm\_kmalloc}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, size\_t\emph{ size}, gfp\_t\emph{ gfp}}{}
Resource-managed kmalloc

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to allocate memory for

\item[{\code{size\_t size}}] \leavevmode
Allocation size

\item[{\code{gfp\_t gfp}}] \leavevmode
Allocation gfp flags

\end{description}

\textbf{Description}

Managed kmalloc.  Memory allocated with this function is
automatically freed on driver detach.  Like all other devres
resources, guaranteed alignment is unsigned long long.

\textbf{Return}

Pointer to allocated memory on success, NULL on failure.
\index{devm\_kstrdup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devm_kstrdup}\pysiglinewithargsret{char * \bfcode{devm\_kstrdup}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ s}, gfp\_t\emph{ gfp}}{}
Allocate resource managed space and copy an existing string into that.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to allocate memory for

\item[{\code{const char * s}}] \leavevmode
the string to duplicate

\item[{\code{gfp\_t gfp}}] \leavevmode
the GFP mask used in the {\hyperref[driver\string-api/basics:c.devm_kmalloc]{\emph{\code{devm\_kmalloc()}}}} call when
allocating memory

\end{description}

\textbf{Return}

Pointer to allocated string on success, NULL on failure.
\index{devm\_kvasprintf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devm_kvasprintf}\pysiglinewithargsret{char * \bfcode{devm\_kvasprintf}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, gfp\_t\emph{ gfp}, const char *\emph{ fmt}, va\_list\emph{ ap}}{}
Allocate resource managed space and format a string into that.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to allocate memory for

\item[{\code{gfp\_t gfp}}] \leavevmode
the GFP mask used in the {\hyperref[driver\string-api/basics:c.devm_kmalloc]{\emph{\code{devm\_kmalloc()}}}} call when
allocating memory

\item[{\code{const char * fmt}}] \leavevmode
The \code{printf()}-style format string

\item[{\code{va\_list ap}}] \leavevmode
Arguments for the format string

\end{description}

\textbf{Return}

Pointer to allocated string on success, NULL on failure.
\index{devm\_kasprintf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devm_kasprintf}\pysiglinewithargsret{char * \bfcode{devm\_kasprintf}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, gfp\_t\emph{ gfp}, const char *\emph{ fmt}, ...}{}
Allocate resource managed space and format a string into that.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to allocate memory for

\item[{\code{gfp\_t gfp}}] \leavevmode
the GFP mask used in the {\hyperref[driver\string-api/basics:c.devm_kmalloc]{\emph{\code{devm\_kmalloc()}}}} call when
allocating memory

\item[{\code{const char * fmt}}] \leavevmode
The \code{printf()}-style format string

\item[{\code{...}}] \leavevmode
Arguments for the format string

\end{description}

\textbf{Return}

Pointer to allocated string on success, NULL on failure.
\index{devm\_kfree (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devm_kfree}\pysiglinewithargsret{void \bfcode{devm\_kfree}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, void *\emph{ p}}{}
Resource-managed kfree

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device this memory belongs to

\item[{\code{void * p}}] \leavevmode
Memory to free

\end{description}

\textbf{Description}

Free memory allocated with {\hyperref[driver\string-api/basics:c.devm_kmalloc]{\emph{\code{devm\_kmalloc()}}}}.
\index{devm\_kmemdup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devm_kmemdup}\pysiglinewithargsret{void * \bfcode{devm\_kmemdup}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const void *\emph{ src}, size\_t\emph{ len}, gfp\_t\emph{ gfp}}{}
Resource-managed kmemdup

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device this memory belongs to

\item[{\code{const void * src}}] \leavevmode
Memory region to duplicate

\item[{\code{size\_t len}}] \leavevmode
Memory region length

\item[{\code{gfp\_t gfp}}] \leavevmode
GFP mask to use

\end{description}

\textbf{Description}

Duplicate region of a memory using resource managed kmalloc
\index{devm\_get\_free\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devm_get_free_pages}\pysiglinewithargsret{unsigned long \bfcode{devm\_get\_free\_pages}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, gfp\_t\emph{ gfp\_mask}, unsigned int\emph{ order}}{}
Resource-managed \_\_get\_free\_pages

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to allocate memory for

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
Allocation gfp flags

\item[{\code{unsigned int order}}] \leavevmode
Allocation size is (1 \textless{}\textless{} order) pages

\end{description}

\textbf{Description}

Managed get\_free\_pages.  Memory allocated with this function is
automatically freed on driver detach.

\textbf{Return}

Address of allocated memory on success, 0 on failure.
\index{devm\_free\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devm_free_pages}\pysiglinewithargsret{void \bfcode{devm\_free\_pages}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, unsigned long\emph{ addr}}{}
Resource-managed free\_pages

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device this memory belongs to

\item[{\code{unsigned long addr}}] \leavevmode
Memory to free

\end{description}

\textbf{Description}

Free memory allocated with {\hyperref[driver\string-api/basics:c.devm_get_free_pages]{\emph{\code{devm\_get\_free\_pages()}}}}. Unlike free\_pages,
there is no need to supply the \textbf{order}.
\index{\_\_devm\_alloc\_percpu (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.__devm_alloc_percpu}\pysiglinewithargsret{void \_\_percpu * \bfcode{\_\_devm\_alloc\_percpu}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, size\_t\emph{ size}, size\_t\emph{ align}}{}
Resource-managed alloc\_percpu

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to allocate per-cpu memory for

\item[{\code{size\_t size}}] \leavevmode
Size of per-cpu memory to allocate

\item[{\code{size\_t align}}] \leavevmode
Alignment of per-cpu memory to allocate

\end{description}

\textbf{Description}

Managed alloc\_percpu. Per-cpu memory allocated with this function is
automatically freed on driver detach.

\textbf{Return}

Pointer to allocated memory on success, NULL on failure.
\index{devm\_free\_percpu (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/basics:c.devm_free_percpu}\pysiglinewithargsret{void \bfcode{devm\_free\_percpu}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, void \_\_percpu *\emph{ pdata}}{}
Resource-managed free\_percpu

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device this memory belongs to

\item[{\code{void \_\_percpu * pdata}}] \leavevmode
Per-cpu memory to free

\end{description}

\textbf{Description}

Free memory allocated with {\hyperref[driver\string-api/infrastructure:c.devm_alloc_percpu]{\emph{\code{devm\_alloc\_percpu()}}}}.


\chapter{Device drivers infrastructure}
\label{driver-api/infrastructure::doc}\label{driver-api/infrastructure:device-drivers-infrastructure}

\section{The Basic Device Driver-Model Structures}
\label{driver-api/infrastructure:the-basic-device-driver-model-structures}\index{bus\_type (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.bus_type}\pysigline{struct \bfcode{bus\_type}}
The bus type of the device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct bus\PYGZus{}type \PYGZob{}
  const char              *name;
  const char              *dev\PYGZus{}name;
  struct device           *dev\PYGZus{}root;
  const struct attribute\PYGZus{}group **bus\PYGZus{}groups;
  const struct attribute\PYGZus{}group **dev\PYGZus{}groups;
  const struct attribute\PYGZus{}group **drv\PYGZus{}groups;
  int (*match)(struct device *dev, struct device\PYGZus{}driver *drv);
  int (*uevent)(struct device *dev, struct kobj\PYGZus{}uevent\PYGZus{}env *env);
  int (*probe)(struct device *dev);
  int (*remove)(struct device *dev);
  void (*shutdown)(struct device *dev);
  int (*online)(struct device *dev);
  int (*offline)(struct device *dev);
  int (*suspend)(struct device *dev, pm\PYGZus{}message\PYGZus{}t state);
  int (*resume)(struct device *dev);
  int (*num\PYGZus{}vf)(struct device *dev);
  const struct dev\PYGZus{}pm\PYGZus{}ops *pm;
  const struct iommu\PYGZus{}ops *iommu\PYGZus{}ops;
  struct subsys\PYGZus{}private *p;
  struct lock\PYGZus{}class\PYGZus{}key lock\PYGZus{}key;
  bool force\PYGZus{}dma;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
The name of the bus.

\item[{\code{dev\_name}}] \leavevmode
Used for subsystems to enumerate devices like (``foo{}`{}`u{}`{}`'', dev-\textgreater{}id).

\item[{\code{dev\_root}}] \leavevmode
Default device to use as the parent.

\item[{\code{bus\_groups}}] \leavevmode
Default attributes of the bus.

\item[{\code{dev\_groups}}] \leavevmode
Default attributes of the devices on the bus.

\item[{\code{drv\_groups}}] \leavevmode
Default attributes of the device drivers on the bus.

\item[{\code{match}}] \leavevmode
Called, perhaps multiple times, whenever a new device or driver
is added for this bus. It should return a positive value if the
given device can be handled by the given driver and zero
otherwise. It may also return error code if determining that
the driver supports the device is not possible. In case of
-EPROBE\_DEFER it will queue the device for deferred probing.

\item[{\code{uevent}}] \leavevmode
Called when a device is added, removed, or a few other things
that generate uevents to add the environment variables.

\item[{\code{probe}}] \leavevmode
Called when a new device or driver add to this bus, and callback
the specific driver's probe to initial the matched device.

\item[{\code{remove}}] \leavevmode
Called when a device removed from this bus.

\item[{\code{shutdown}}] \leavevmode
Called at shut-down time to quiesce the device.

\item[{\code{online}}] \leavevmode
Called to put the device back online (after offlining it).

\item[{\code{offline}}] \leavevmode
Called to put the device offline for hot-removal. May fail.

\item[{\code{suspend}}] \leavevmode
Called when a device on this bus wants to go to sleep mode.

\item[{\code{resume}}] \leavevmode
Called to bring a device on this bus out of sleep mode.

\item[{\code{num\_vf}}] \leavevmode
Called to find out how many virtual functions a device on this
bus supports.

\item[{\code{pm}}] \leavevmode
Power management operations of this bus, callback the specific
device driver's pm-ops.

\item[{\code{iommu\_ops}}] \leavevmode
IOMMU specific operations for this bus, used to attach IOMMU
driver implementations to a bus and allow the driver to do
bus-specific setup

\item[{\code{p}}] \leavevmode
The private data of the driver core, only the driver core can
touch this.

\item[{\code{lock\_key}}] \leavevmode
Lock class key for use by the lock validator

\item[{\code{force\_dma}}] \leavevmode
Assume devices on this bus should be set up by \code{dma\_configure()}
even if DMA capability is not explicitly described by firmware.

\end{description}

\textbf{Description}

A bus is a channel between the processor and one or more devices. For the
purposes of the device model, all devices are connected via a bus, even if
it is an internal, virtual, ``platform'' bus. Buses can plug into each other.
A USB controller is usually a PCI device, for example. The device model
represents the actual connections between buses and the devices they control.
A bus is represented by the bus\_type structure. It contains the name, the
default attributes, the bus' methods, PM operations, and the driver core's
private data.
\index{probe\_type (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.probe_type}\pysigline{enum \bfcode{probe\_type}}
device driver probe type to try Device drivers may opt in for special handling of their respective probe routines. This tells the core what to expect and prefer.

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{PROBE\_DEFAULT\_STRATEGY}}] \leavevmode
Used by drivers that work equally well
whether probed synchronously or asynchronously.

\item[{\code{PROBE\_PREFER\_ASYNCHRONOUS}}] \leavevmode
Drivers for ``slow'' devices which
probing order is not essential for booting the system may
opt into executing their probes asynchronously.

\item[{\code{PROBE\_FORCE\_SYNCHRONOUS}}] \leavevmode
Use this to annotate drivers that need
their probe routines to run synchronously with driver and
device registration (with the exception of -EPROBE\_DEFER
handling - re-probing always ends up being done asynchronously).

\end{description}

\textbf{Description}

Note that the end goal is to switch the kernel to use asynchronous
probing by default, so annotating drivers with
\code{PROBE\_PREFER\_ASYNCHRONOUS} is a temporary measure that allows us
to speed up boot process while we are validating the rest of the
drivers.
\index{device\_driver (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_driver}\pysigline{struct \bfcode{device\_driver}}
The basic device driver structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct device\PYGZus{}driver \PYGZob{}
  const char              *name;
  struct bus\PYGZus{}type         *bus;
  struct module           *owner;
  const char              *mod\PYGZus{}name;
  bool suppress\PYGZus{}bind\PYGZus{}attrs;
  enum probe\PYGZus{}type probe\PYGZus{}type;
  const struct of\PYGZus{}device\PYGZus{}id       *of\PYGZus{}match\PYGZus{}table;
  const struct acpi\PYGZus{}device\PYGZus{}id     *acpi\PYGZus{}match\PYGZus{}table;
  int (*probe) (struct device *dev);
  int (*remove) (struct device *dev);
  void (*shutdown) (struct device *dev);
  int (*suspend) (struct device *dev, pm\PYGZus{}message\PYGZus{}t state);
  int (*resume) (struct device *dev);
  const struct attribute\PYGZus{}group **groups;
  const struct dev\PYGZus{}pm\PYGZus{}ops *pm;
  int (*coredump) (struct device *dev);
  struct driver\PYGZus{}private *p;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
Name of the device driver.

\item[{\code{bus}}] \leavevmode
The bus which the device of this driver belongs to.

\item[{\code{owner}}] \leavevmode
The module owner.

\item[{\code{mod\_name}}] \leavevmode
Used for built-in modules.

\item[{\code{suppress\_bind\_attrs}}] \leavevmode
Disables bind/unbind via sysfs.

\item[{\code{probe\_type}}] \leavevmode
Type of the probe (synchronous or asynchronous) to use.

\item[{\code{of\_match\_table}}] \leavevmode
The open firmware table.

\item[{\code{acpi\_match\_table}}] \leavevmode
The ACPI match table.

\item[{\code{probe}}] \leavevmode
Called to query the existence of a specific device,
whether this driver can work with it, and bind the driver
to a specific device.

\item[{\code{remove}}] \leavevmode
Called when the device is removed from the system to
unbind a device from this driver.

\item[{\code{shutdown}}] \leavevmode
Called at shut-down time to quiesce the device.

\item[{\code{suspend}}] \leavevmode
Called to put the device to sleep mode. Usually to a
low power state.

\item[{\code{resume}}] \leavevmode
Called to bring a device from sleep mode.

\item[{\code{groups}}] \leavevmode
Default attributes that get created by the driver core
automatically.

\item[{\code{pm}}] \leavevmode
Power management operations of the device which matched
this driver.

\item[{\code{p}}] \leavevmode
Driver core's private data, no one other than the driver
core can touch this.

\end{description}

\textbf{Description}

The device driver-model tracks all of the drivers known to the system.
The main reason for this tracking is to enable the driver core to match
up drivers with new devices. Once drivers are known objects within the
system, however, a number of other things become possible. Device drivers
can export information and configuration variables that are independent
of any specific device.
\index{subsys\_interface (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.subsys_interface}\pysigline{struct \bfcode{subsys\_interface}}
interfaces to device functions

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct subsys\PYGZus{}interface \PYGZob{}
  const char *name;
  struct bus\PYGZus{}type *subsys;
  struct list\PYGZus{}head node;
  int (*add\PYGZus{}dev)(struct device *dev, struct subsys\PYGZus{}interface *sif);
  void (*remove\PYGZus{}dev)(struct device *dev, struct subsys\PYGZus{}interface *sif);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
name of the device function

\item[{\code{subsys}}] \leavevmode
subsytem of the devices to attach to

\item[{\code{node}}] \leavevmode
the list of functions registered at the subsystem

\item[{\code{add\_dev}}] \leavevmode
device hookup to device function handler

\item[{\code{remove\_dev}}] \leavevmode
device hookup to device function handler

\end{description}

\textbf{Description}

Simple interfaces attached to a subsystem. Multiple interfaces can
attach to a subsystem and its devices. Unlike drivers, they do not
exclusively claim or control devices. Interfaces usually represent
a specific functionality of a subsystem/class of devices.
\index{class (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.class}\pysigline{struct \bfcode{class}}
device classes

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct class \PYGZob{}
  const char              *name;
  struct module           *owner;
  const struct attribute\PYGZus{}group    **class\PYGZus{}groups;
  const struct attribute\PYGZus{}group    **dev\PYGZus{}groups;
  struct kobject                  *dev\PYGZus{}kobj;
  int (*dev\PYGZus{}uevent)(struct device *dev, struct kobj\PYGZus{}uevent\PYGZus{}env *env);
  char *(*devnode)(struct device *dev, umode\PYGZus{}t *mode);
  void (*class\PYGZus{}release)(struct class *class);
  void (*dev\PYGZus{}release)(struct device *dev);
  int (*shutdown\PYGZus{}pre)(struct device *dev);
  const struct kobj\PYGZus{}ns\PYGZus{}type\PYGZus{}operations *ns\PYGZus{}type;
  const void *(*namespace)(struct device *dev);
  const struct dev\PYGZus{}pm\PYGZus{}ops *pm;
  struct subsys\PYGZus{}private *p;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
Name of the class.

\item[{\code{owner}}] \leavevmode
The module owner.

\item[{\code{class\_groups}}] \leavevmode
Default attributes of this class.

\item[{\code{dev\_groups}}] \leavevmode
Default attributes of the devices that belong to the class.

\item[{\code{dev\_kobj}}] \leavevmode
The kobject that represents this class and links it into the hierarchy.

\item[{\code{dev\_uevent}}] \leavevmode
Called when a device is added, removed from this class, or a
few other things that generate uevents to add the environment
variables.

\item[{\code{devnode}}] \leavevmode
Callback to provide the devtmpfs.

\item[{\code{class\_release}}] \leavevmode
Called to release this class.

\item[{\code{dev\_release}}] \leavevmode
Called to release the device.

\item[{\code{shutdown\_pre}}] \leavevmode
Called at shut-down time before driver shutdown.

\item[{\code{ns\_type}}] \leavevmode
Callbacks so sysfs can detemine namespaces.

\item[{\code{namespace}}] \leavevmode
Namespace of the device belongs to this class.

\item[{\code{pm}}] \leavevmode
The default device power management operations of this class.

\item[{\code{p}}] \leavevmode
The private data of the driver core, no one other than the
driver core can touch this.

\end{description}

\textbf{Description}

A class is a higher-level view of a device that abstracts out low-level
implementation details. Drivers may see a SCSI disk or an ATA disk, but,
at the class level, they are all simply disks. Classes allow user space
to work with devices based on what they do, rather than how they are
connected or how they work.
\index{devm\_alloc\_percpu (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.devm_alloc_percpu}\pysiglinewithargsret{\bfcode{devm\_alloc\_percpu}}{\emph{dev}, \emph{type}}{}
Resource-managed alloc\_percpu

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{dev}}] \leavevmode
Device to allocate per-cpu memory for

\item[{\code{type}}] \leavevmode
Type to allocate per-cpu memory for

\end{description}

\textbf{Description}

Managed alloc\_percpu. Per-cpu memory allocated with this function is
automatically freed on driver detach.

\textbf{Return}

Pointer to allocated memory on success, NULL on failure.
\index{device\_link\_state (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_link_state}\pysigline{enum \bfcode{device\_link\_state}}
Device link states.

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{DL\_STATE\_NONE}}] \leavevmode
The presence of the drivers is not being tracked.

\item[{\code{DL\_STATE\_DORMANT}}] \leavevmode
None of the supplier/consumer drivers is present.

\item[{\code{DL\_STATE\_AVAILABLE}}] \leavevmode
The supplier driver is present, but the consumer is not.

\item[{\code{DL\_STATE\_CONSUMER\_PROBE}}] \leavevmode
The consumer is probing (supplier driver present).

\item[{\code{DL\_STATE\_ACTIVE}}] \leavevmode
Both the supplier and consumer drivers are present.

\item[{\code{DL\_STATE\_SUPPLIER\_UNBIND}}] \leavevmode
The supplier driver is unbinding.

\end{description}
\index{device\_link (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_link}\pysigline{struct \bfcode{device\_link}}
Device link representation.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct device\PYGZus{}link \PYGZob{}
  struct device *supplier;
  struct list\PYGZus{}head s\PYGZus{}node;
  struct device *consumer;
  struct list\PYGZus{}head c\PYGZus{}node;
  enum device\PYGZus{}link\PYGZus{}state status;
  u32 flags;
  bool rpm\PYGZus{}active;
\PYGZsh{}ifdef CONFIG\PYGZus{}SRCU;
  struct rcu\PYGZus{}head rcu\PYGZus{}head;
\PYGZsh{}endif;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{supplier}}] \leavevmode
The device on the supplier end of the link.

\item[{\code{s\_node}}] \leavevmode
Hook to the supplier device's list of links to consumers.

\item[{\code{consumer}}] \leavevmode
The device on the consumer end of the link.

\item[{\code{c\_node}}] \leavevmode
Hook to the consumer device's list of links to suppliers.

\item[{\code{status}}] \leavevmode
The state of the link (with respect to the presence of drivers).

\item[{\code{flags}}] \leavevmode
Link flags.

\item[{\code{rpm\_active}}] \leavevmode
Whether or not the consumer device is runtime-PM-active.

\item[{\code{rcu\_head}}] \leavevmode
An RCU head to use for deferred execution of SRCU callbacks.

\end{description}
\index{dl\_dev\_state (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.dl_dev_state}\pysigline{enum \bfcode{dl\_dev\_state}}
Device driver presence tracking information.

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{DL\_DEV\_NO\_DRIVER}}] \leavevmode
There is no driver attached to the device.

\item[{\code{DL\_DEV\_PROBING}}] \leavevmode
A driver is probing.

\item[{\code{DL\_DEV\_DRIVER\_BOUND}}] \leavevmode
The driver has been bound to the device.

\item[{\code{DL\_DEV\_UNBINDING}}] \leavevmode
The driver is unbinding from the device.

\end{description}
\index{dev\_links\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.dev_links_info}\pysigline{struct \bfcode{dev\_links\_info}}
Device data related to device links.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dev\PYGZus{}links\PYGZus{}info \PYGZob{}
  struct list\PYGZus{}head suppliers;
  struct list\PYGZus{}head consumers;
  enum dl\PYGZus{}dev\PYGZus{}state status;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{suppliers}}] \leavevmode
List of links to supplier devices.

\item[{\code{consumers}}] \leavevmode
List of links to consumer devices.

\item[{\code{status}}] \leavevmode
Driver status information.

\end{description}
\index{device (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device}\pysigline{struct \bfcode{device}}
The basic device structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct device \PYGZob{}
  struct device           *parent;
  struct device\PYGZus{}private   *p;
  struct kobject kobj;
  const char              *init\PYGZus{}name;
  const struct device\PYGZus{}type *type;
  struct mutex            mutex;
  struct bus\PYGZus{}type *bus;
  struct device\PYGZus{}driver *driver;
  void *platform\PYGZus{}data;
  void *driver\PYGZus{}data;
  struct dev\PYGZus{}links\PYGZus{}info   links;
  struct dev\PYGZus{}pm\PYGZus{}info      power;
  struct dev\PYGZus{}pm\PYGZus{}domain    *pm\PYGZus{}domain;
\PYGZsh{}ifdef CONFIG\PYGZus{}GENERIC\PYGZus{}MSI\PYGZus{}IRQ\PYGZus{}DOMAIN;
  struct irq\PYGZus{}domain       *msi\PYGZus{}domain;
\PYGZsh{}endif;
\PYGZsh{}ifdef CONFIG\PYGZus{}PINCTRL;
  struct dev\PYGZus{}pin\PYGZus{}info     *pins;
\PYGZsh{}endif;
\PYGZsh{}ifdef CONFIG\PYGZus{}GENERIC\PYGZus{}MSI\PYGZus{}IRQ;
  struct list\PYGZus{}head        msi\PYGZus{}list;
\PYGZsh{}endif;
\PYGZsh{}ifdef CONFIG\PYGZus{}NUMA;
  int numa\PYGZus{}node;
\PYGZsh{}endif;
  const struct dma\PYGZus{}map\PYGZus{}ops *dma\PYGZus{}ops;
  u64 *dma\PYGZus{}mask;
  u64 coherent\PYGZus{}dma\PYGZus{}mask;
  unsigned long   dma\PYGZus{}pfn\PYGZus{}offset;
  struct device\PYGZus{}dma\PYGZus{}parameters *dma\PYGZus{}parms;
  struct list\PYGZus{}head        dma\PYGZus{}pools;
  struct dma\PYGZus{}coherent\PYGZus{}mem *dma\PYGZus{}mem;
\PYGZsh{}ifdef CONFIG\PYGZus{}DMA\PYGZus{}CMA;
  struct cma *cma\PYGZus{}area;
\PYGZsh{}endif;
  struct dev\PYGZus{}archdata     archdata;
  struct device\PYGZus{}node      *of\PYGZus{}node;
  struct fwnode\PYGZus{}handle    *fwnode;
  dev\PYGZus{}t devt;
  u32 id;
  spinlock\PYGZus{}t devres\PYGZus{}lock;
  struct list\PYGZus{}head        devres\PYGZus{}head;
  struct klist\PYGZus{}node       knode\PYGZus{}class;
  struct class            *class;
  const struct attribute\PYGZus{}group **groups;
  void (*release)(struct device *dev);
  struct iommu\PYGZus{}group      *iommu\PYGZus{}group;
  struct iommu\PYGZus{}fwspec     *iommu\PYGZus{}fwspec;
  bool offline\PYGZus{}disabled:1;
  bool offline:1;
  bool of\PYGZus{}node\PYGZus{}reused:1;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{parent}}] \leavevmode
The device's ``parent'' device, the device to which it is attached.
In most cases, a parent device is some sort of bus or host
controller. If parent is NULL, the device, is a top-level device,
which is not usually what you want.

\item[{\code{p}}] \leavevmode
Holds the private data of the driver core portions of the device.
See the comment of the struct device\_private for detail.

\item[{\code{kobj}}] \leavevmode
A top-level, abstract class from which other classes are derived.

\item[{\code{init\_name}}] \leavevmode
Initial name of the device.

\item[{\code{type}}] \leavevmode
The type of device.
This identifies the device type and carries type-specific
information.

\item[{\code{mutex}}] \leavevmode
Mutex to synchronize calls to its driver.

\item[{\code{bus}}] \leavevmode
Type of bus device is on.

\item[{\code{driver}}] \leavevmode
Which driver has allocated this

\item[{\code{platform\_data}}] \leavevmode
Platform data specific to the device.

\item[{\code{driver\_data}}] \leavevmode
Private pointer for driver specific info.

\item[{\code{links}}] \leavevmode
Links to suppliers and consumers of this device.

\item[{\code{power}}] \leavevmode
For device power management.
See Documentation/driver-api/pm/devices.rst for details.

\item[{\code{pm\_domain}}] \leavevmode
Provide callbacks that are executed during system suspend,
hibernation, system resume and during runtime PM transitions
along with subsystem-level and driver-level callbacks.

\item[{\code{msi\_domain}}] \leavevmode
The generic MSI domain this device is using.

\item[{\code{pins}}] \leavevmode
For device pin management.
See Documentation/driver-api/pinctl.rst for details.

\item[{\code{msi\_list}}] \leavevmode
Hosts MSI descriptors

\item[{\code{numa\_node}}] \leavevmode
NUMA node this device is close to.

\item[{\code{dma\_ops}}] \leavevmode
DMA mapping operations for this device.

\item[{\code{dma\_mask}}] \leavevmode
Dma mask (if dma'ble device).

\item[{\code{coherent\_dma\_mask}}] \leavevmode
Like dma\_mask, but for alloc\_coherent mapping as not all
hardware supports 64-bit addresses for consistent allocations
such descriptors.

\item[{\code{dma\_pfn\_offset}}] \leavevmode
offset of DMA memory range relatively of RAM

\item[{\code{dma\_parms}}] \leavevmode
A low level driver may set these to teach IOMMU code about
segment limitations.

\item[{\code{dma\_pools}}] \leavevmode
Dma pools (if dma'ble device).

\item[{\code{dma\_mem}}] \leavevmode
Internal for coherent mem override.

\item[{\code{cma\_area}}] \leavevmode
Contiguous memory area for dma allocations

\item[{\code{archdata}}] \leavevmode
For arch-specific additions.

\item[{\code{of\_node}}] \leavevmode
Associated device tree node.

\item[{\code{fwnode}}] \leavevmode
Associated device node supplied by platform firmware.

\item[{\code{devt}}] \leavevmode
For creating the sysfs ``dev''.

\item[{\code{id}}] \leavevmode
device instance

\item[{\code{devres\_lock}}] \leavevmode
Spinlock to protect the resource of the device.

\item[{\code{devres\_head}}] \leavevmode
The resources list of the device.

\item[{\code{knode\_class}}] \leavevmode
The node used to add the device to the class list.

\item[{\code{class}}] \leavevmode
The class of the device.

\item[{\code{groups}}] \leavevmode
Optional attribute groups.

\item[{\code{release}}] \leavevmode
Callback to free the device after all references have
gone away. This should be set by the allocator of the
device (i.e. the bus driver that discovered the device).

\item[{\code{iommu\_group}}] \leavevmode
IOMMU group the device belongs to.

\item[{\code{iommu\_fwspec}}] \leavevmode
IOMMU-specific properties supplied by firmware.

\item[{\code{offline\_disabled}}] \leavevmode
If set, the device is permanently online.

\item[{\code{offline}}] \leavevmode
Set after successful invocation of bus type's .:c:func:\emph{offline()}.

\item[{\code{of\_node\_reused}}] \leavevmode
Set if the device-tree node is shared with an ancestor
device.

\end{description}

\textbf{Example}
\begin{description}
\item[{For devices on custom boards, as typical of embedded}] \leavevmode
and SOC based hardware, Linux often uses platform\_data to point
to board-specific structures describing devices and how they
are wired.  That can include what ports are available, chip
variants, which GPIO pins act in what additional roles, and so
on.  This shrinks the ``Board Support Packages'' (BSPs) and
minimizes board-specific \#ifdefs in drivers.

\end{description}

\textbf{Description}

At the lowest level, every device in a Linux system is represented by an
instance of struct device. The device structure contains the information
that the device model core needs to model the system. Most subsystems,
however, track additional information about the devices they host. As a
result, it is rare for devices to be represented by bare device structures;
instead, that structure, like kobject structures, is usually embedded within
a higher-level representation of the device.
\index{module\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.module_driver}\pysiglinewithargsret{\bfcode{module\_driver}}{\emph{\_\_driver}, \emph{\_\_register}, \emph{\_\_unregister}, \emph{...}}{}
Helper macro for drivers that don't do anything special in module init/exit. This eliminates a lot of boilerplate. Each module may only use this macro once, and calling it replaces {\hyperref[driver\string-api/basics:c.module_init]{\emph{\code{module\_init()}}}} and {\hyperref[driver\string-api/basics:c.module_exit]{\emph{\code{module\_exit()}}}}.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_driver}}] \leavevmode
driver name

\item[{\code{\_\_register}}] \leavevmode
register function for this driver type

\item[{\code{\_\_unregister}}] \leavevmode
unregister function for this driver type

\item[{\code{...}}] \leavevmode
Additional arguments to be passed to \_\_register and \_\_unregister.

\end{description}

\textbf{Description}

Use this macro to construct bus specific macros for registering
drivers, and do not use it on its own.
\index{builtin\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.builtin_driver}\pysiglinewithargsret{\bfcode{builtin\_driver}}{\emph{\_\_driver}, \emph{\_\_register}, \emph{...}}{}
Helper macro for drivers that don't do anything special in init and have no exit. This eliminates some boilerplate. Each driver may only use this macro once, and calling it replaces device\_initcall (or in some cases, the legacy \_\_initcall). This is meant to be a direct parallel of {\hyperref[driver\string-api/infrastructure:c.module_driver]{\emph{\code{module\_driver()}}}} above but without the \_\_exit stuff that is not used for builtin cases.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_driver}}] \leavevmode
driver name

\item[{\code{\_\_register}}] \leavevmode
register function for this driver type

\item[{\code{...}}] \leavevmode
Additional arguments to be passed to \_\_register

\end{description}

\textbf{Description}

Use this macro to construct bus specific macros for registering
drivers, and do not use it on its own.


\section{Device Drivers Base}
\label{driver-api/infrastructure:device-drivers-base}\index{driver\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.driver_init}\pysiglinewithargsret{void \bfcode{driver\_init}}{void}{}
initialize driver model.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Call the driver model init functions to initialize their
subsystems. Called early from init/main.c.
\index{driver\_for\_each\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.driver_for_each_device}\pysiglinewithargsret{int \bfcode{driver\_for\_each\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.device_driver]{\emph{device\_driver}}} *\emph{ drv}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ start}, void *\emph{ data}, int (*fn) (struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}}\emph{ *}, void\emph{ *}}{}
Iterator for devices bound to a driver.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device\_driver * drv}}] \leavevmode
Driver we're iterating.

\item[{\code{struct device * start}}] \leavevmode
Device to begin with

\item[{\code{void * data}}] \leavevmode
Data to pass to the callback.

\item[{\code{int (*)(struct device *, void *) fn}}] \leavevmode
Function to call for each device.

\end{description}

\textbf{Description}

Iterate over the \textbf{drv}`s list of devices calling \textbf{fn} for each one.
\index{driver\_find\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.driver_find_device}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} * \bfcode{driver\_find\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.device_driver]{\emph{device\_driver}}} *\emph{ drv}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ start}, void *\emph{ data}, int (*match) (struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}}\emph{ *dev}, void\emph{ *data}}{}
device iterator for locating a particular device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device\_driver * drv}}] \leavevmode
The device's driver

\item[{\code{struct device * start}}] \leavevmode
Device to begin with

\item[{\code{void * data}}] \leavevmode
Data to pass to match function

\item[{\code{int (*)(struct device *dev, void *data) match}}] \leavevmode
Callback function to check device

\end{description}

\textbf{Description}

This is similar to the {\hyperref[driver\string-api/infrastructure:c.driver_for_each_device]{\emph{\code{driver\_for\_each\_device()}}}} function above, but
it returns a reference to a device that is `found' for later use, as
determined by the \textbf{match} callback.

The callback should return 0 if the device doesn't match and non-zero
if it does.  If the callback returns non-zero, this function will
return to the caller and not iterate over any more devices.
\index{driver\_create\_file (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.driver_create_file}\pysiglinewithargsret{int \bfcode{driver\_create\_file}}{struct {\hyperref[driver\string-api/infrastructure:c.device_driver]{\emph{device\_driver}}} *\emph{ drv}, const struct driver\_attribute *\emph{ attr}}{}
create sysfs file for driver.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device\_driver * drv}}] \leavevmode
driver.

\item[{\code{const struct driver\_attribute * attr}}] \leavevmode
driver attribute descriptor.

\end{description}
\index{driver\_remove\_file (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.driver_remove_file}\pysiglinewithargsret{void \bfcode{driver\_remove\_file}}{struct {\hyperref[driver\string-api/infrastructure:c.device_driver]{\emph{device\_driver}}} *\emph{ drv}, const struct driver\_attribute *\emph{ attr}}{}
remove sysfs file for driver.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device\_driver * drv}}] \leavevmode
driver.

\item[{\code{const struct driver\_attribute * attr}}] \leavevmode
driver attribute descriptor.

\end{description}
\index{driver\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.driver_register}\pysiglinewithargsret{int \bfcode{driver\_register}}{struct {\hyperref[driver\string-api/infrastructure:c.device_driver]{\emph{device\_driver}}} *\emph{ drv}}{}
register driver with bus

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device\_driver * drv}}] \leavevmode
driver to register

\end{description}

\textbf{Description}

We pass off most of the work to the \code{bus\_add\_driver()} call,
since most of the things we have to do deal with the bus
structures.
\index{driver\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.driver_unregister}\pysiglinewithargsret{void \bfcode{driver\_unregister}}{struct {\hyperref[driver\string-api/infrastructure:c.device_driver]{\emph{device\_driver}}} *\emph{ drv}}{}
remove driver from system.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device\_driver * drv}}] \leavevmode
driver.

\end{description}

\textbf{Description}

Again, we pass off most of the work to the bus-level call.
\index{driver\_find (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.driver_find}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device_driver]{\emph{device\_driver}}} * \bfcode{driver\_find}}{const char *\emph{ name}, struct {\hyperref[driver\string-api/infrastructure:c.bus_type]{\emph{bus\_type}}} *\emph{ bus}}{}
locate driver on a bus by its name.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
name of the driver.

\item[{\code{struct bus\_type * bus}}] \leavevmode
bus to scan for the driver.

\end{description}

\textbf{Description}

Call {\hyperref[driver\string-api/basics:c.kset_find_obj]{\emph{\code{kset\_find\_obj()}}}} to iterate over list of drivers on
a bus to find driver by name. Return driver if found.

This routine provides no locking to prevent the driver it returns
from being unregistered or unloaded while the caller is using it.
The caller is responsible for preventing this.
\index{device\_link\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_link_add}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device_link]{\emph{device\_link}}} * \bfcode{device\_link\_add}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ consumer}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ supplier}, u32\emph{ flags}}{}
Create a link between two devices.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * consumer}}] \leavevmode
Consumer end of the link.

\item[{\code{struct device * supplier}}] \leavevmode
Supplier end of the link.

\item[{\code{u32 flags}}] \leavevmode
Link flags.

\end{description}

\textbf{Description}

The caller is responsible for the proper synchronization of the link creation
with runtime PM.  First, setting the DL\_FLAG\_PM\_RUNTIME flag will cause the
runtime PM framework to take the link into account.  Second, if the
DL\_FLAG\_RPM\_ACTIVE flag is set in addition to it, the supplier devices will
be forced into the active metastate and reference-counted upon the creation
of the link.  If DL\_FLAG\_PM\_RUNTIME is not set, DL\_FLAG\_RPM\_ACTIVE will be
ignored.

If the DL\_FLAG\_AUTOREMOVE is set, the link will be removed automatically
when the consumer device driver unbinds from it.  The combination of both
DL\_FLAG\_AUTOREMOVE and DL\_FLAG\_STATELESS set is invalid and will cause NULL
to be returned.

A side effect of the link creation is re-ordering of dpm\_list and the
devices\_kset list by moving the consumer device and all devices depending
on it to the ends of these lists (that does not happen to devices that have
not been registered when this function is called).

The supplier device is required to be registered when this function is called
and NULL will be returned if that is not the case.  The consumer device need
not be registered, however.
\index{device\_link\_del (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_link_del}\pysiglinewithargsret{void \bfcode{device\_link\_del}}{struct {\hyperref[driver\string-api/infrastructure:c.device_link]{\emph{device\_link}}} *\emph{ link}}{}
Delete a link between two devices.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device\_link * link}}] \leavevmode
Device link to delete.

\end{description}

\textbf{Description}

The caller must ensure proper synchronization of this function with runtime
PM.
\index{dev\_driver\_string (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.dev_driver_string}\pysiglinewithargsret{const char * \bfcode{dev\_driver\_string}}{const struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
Return a device's driver name, if at all possible

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct device * dev}}] \leavevmode
struct device to get the name of

\end{description}

\textbf{Description}

Will return the device's driver's name if it is bound to a device.  If
the device is not bound to a driver, it will return the name of the bus
it is attached to.  If it is not attached to a bus either, an empty
string will be returned.
\index{devm\_device\_add\_group (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.devm_device_add_group}\pysiglinewithargsret{int \bfcode{devm\_device\_add\_group}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const struct attribute\_group *\emph{ grp}}{}
given a device, create a managed attribute group

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
The device to create the group for

\item[{\code{const struct attribute\_group * grp}}] \leavevmode
The attribute group to create

\end{description}

\textbf{Description}

This function creates a group for the first time.  It will explicitly
warn and error if any of the attribute files being created already exist.

Returns 0 on success or error code on failure.
\index{devm\_device\_remove\_group (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.devm_device_remove_group}\pysiglinewithargsret{void \bfcode{devm\_device\_remove\_group}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const struct attribute\_group *\emph{ grp}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device to remove the group from

\item[{\code{const struct attribute\_group * grp}}] \leavevmode
group to remove

\end{description}

\textbf{Description}

This function removes a group of attributes from a device. The attributes
previously have to have been created for this group, otherwise it will fail.
\index{devm\_device\_add\_groups (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.devm_device_add_groups}\pysiglinewithargsret{int \bfcode{devm\_device\_add\_groups}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const struct attribute\_group **\emph{ groups}}{}
create a bunch of managed attribute groups

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
The device to create the group for

\item[{\code{const struct attribute\_group ** groups}}] \leavevmode
The attribute groups to create, NULL terminated

\end{description}

\textbf{Description}

This function creates a bunch of managed attribute groups.  If an error
occurs when creating a group, all previously created groups will be
removed, unwinding everything back to the original state when this
function was called.  It will explicitly warn and error if any of the
attribute files being created already exist.

Returns 0 on success or error code from sysfs\_create\_group on failure.
\index{devm\_device\_remove\_groups (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.devm_device_remove_groups}\pysiglinewithargsret{void \bfcode{devm\_device\_remove\_groups}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const struct attribute\_group **\emph{ groups}}{}
remove a list of managed groups

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
The device for the groups to be removed from

\item[{\code{const struct attribute\_group ** groups}}] \leavevmode
NULL terminated list of groups to be removed

\end{description}

\textbf{Description}

If groups is not NULL, remove the specified groups from the device.
\index{device\_create\_file (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_create_file}\pysiglinewithargsret{int \bfcode{device\_create\_file}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const struct device\_attribute *\emph{ attr}}{}
create sysfs attribute file for device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device.

\item[{\code{const struct device\_attribute * attr}}] \leavevmode
device attribute descriptor.

\end{description}
\index{device\_remove\_file (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_remove_file}\pysiglinewithargsret{void \bfcode{device\_remove\_file}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const struct device\_attribute *\emph{ attr}}{}
remove sysfs attribute file.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device.

\item[{\code{const struct device\_attribute * attr}}] \leavevmode
device attribute descriptor.

\end{description}
\index{device\_remove\_file\_self (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_remove_file_self}\pysiglinewithargsret{bool \bfcode{device\_remove\_file\_self}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const struct device\_attribute *\emph{ attr}}{}
remove sysfs attribute file from its own method.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device.

\item[{\code{const struct device\_attribute * attr}}] \leavevmode
device attribute descriptor.

\end{description}

\textbf{Description}

See \code{kernfs\_remove\_self()} for details.
\index{device\_create\_bin\_file (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_create_bin_file}\pysiglinewithargsret{int \bfcode{device\_create\_bin\_file}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const struct bin\_attribute *\emph{ attr}}{}
create sysfs binary attribute file for device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device.

\item[{\code{const struct bin\_attribute * attr}}] \leavevmode
device binary attribute descriptor.

\end{description}
\index{device\_remove\_bin\_file (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_remove_bin_file}\pysiglinewithargsret{void \bfcode{device\_remove\_bin\_file}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const struct bin\_attribute *\emph{ attr}}{}
remove sysfs binary attribute file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device.

\item[{\code{const struct bin\_attribute * attr}}] \leavevmode
device binary attribute descriptor.

\end{description}
\index{device\_initialize (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_initialize}\pysiglinewithargsret{void \bfcode{device\_initialize}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
init device structure.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device.

\end{description}

\textbf{Description}

This prepares the device for use by other layers by initializing
its fields.
It is the first half of {\hyperref[driver\string-api/infrastructure:c.device_register]{\emph{\code{device\_register()}}}}, if called by
that function, though it can also be called separately, so one
may use \textbf{dev}`s fields. In particular, {\hyperref[driver\string-api/infrastructure:c.get_device]{\emph{\code{get\_device()}}}}/{\hyperref[driver\string-api/infrastructure:c.put_device]{\emph{\code{put\_device()}}}}
may be used for reference counting of \textbf{dev} after calling this
function.

All fields in \textbf{dev} must be initialized by the caller to 0, except
for those explicitly set to some other value.  The simplest
approach is to use \code{kzalloc()} to allocate the structure containing
\textbf{dev}.

\textbf{NOTE}

Use {\hyperref[driver\string-api/infrastructure:c.put_device]{\emph{\code{put\_device()}}}} to give up your reference instead of freeing
\textbf{dev} directly once you have called this function.
\index{dev\_set\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.dev_set_name}\pysiglinewithargsret{int \bfcode{dev\_set\_name}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ fmt}, ...}{}
set a device name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device

\item[{\code{const char * fmt}}] \leavevmode
format string for the device's name

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}
\index{device\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_add}\pysiglinewithargsret{int \bfcode{device\_add}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
add device to device hierarchy.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device.

\end{description}

\textbf{Description}

This is part 2 of {\hyperref[driver\string-api/infrastructure:c.device_register]{\emph{\code{device\_register()}}}}, though may be called
separately \_iff\_ {\hyperref[driver\string-api/infrastructure:c.device_initialize]{\emph{\code{device\_initialize()}}}} has been called separately.

This adds \textbf{dev} to the kobject hierarchy via {\hyperref[driver\string-api/basics:c.kobject_add]{\emph{\code{kobject\_add()}}}}, adds it
to the global and sibling lists for the device, then
adds it to the other relevant subsystems of the driver model.

Do not call this routine or {\hyperref[driver\string-api/infrastructure:c.device_register]{\emph{\code{device\_register()}}}} more than once for
any device structure.  The driver model core is not designed to work
with devices that get unregistered and then spring back to life.
(Among other things, it's very hard to guarantee that all references
to the previous incarnation of \textbf{dev} have been dropped.)  Allocate
and register a fresh new struct device instead.

\textbf{NOTE}

\_Never\_ directly free \textbf{dev} after calling this function, even
if it returned an error! Always use {\hyperref[driver\string-api/infrastructure:c.put_device]{\emph{\code{put\_device()}}}} to give up your
reference instead.
\index{device\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_register}\pysiglinewithargsret{int \bfcode{device\_register}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
register a device with the system.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
pointer to the device structure

\end{description}

\textbf{Description}

This happens in two clean steps - initialize the device
and add it to the system. The two steps can be called
separately, but this is the easiest and most common.
I.e. you should only call the two helpers separately if
have a clearly defined need to use and refcount the device
before it is added to the hierarchy.

For more information, see the kerneldoc for {\hyperref[driver\string-api/infrastructure:c.device_initialize]{\emph{\code{device\_initialize()}}}}
and {\hyperref[driver\string-api/infrastructure:c.device_add]{\emph{\code{device\_add()}}}}.

\textbf{NOTE}

\_Never\_ directly free \textbf{dev} after calling this function, even
if it returned an error! Always use {\hyperref[driver\string-api/infrastructure:c.put_device]{\emph{\code{put\_device()}}}} to give up the
reference initialized in this function instead.
\index{get\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.get_device}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} * \bfcode{get\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
increment reference count for device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device.

\end{description}

\textbf{Description}

This simply forwards the call to {\hyperref[driver\string-api/basics:c.kobject_get]{\emph{\code{kobject\_get()}}}}, though
we do take care to provide for the case that we get a NULL
pointer passed in.
\index{put\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.put_device}\pysiglinewithargsret{void \bfcode{put\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
decrement reference count.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device in question.

\end{description}
\index{device\_del (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_del}\pysiglinewithargsret{void \bfcode{device\_del}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
delete device from system.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device.

\end{description}

\textbf{Description}

This is the first part of the device unregistration
sequence. This removes the device from the lists we control
from here, has it removed from the other driver model
subsystems it was added to in {\hyperref[driver\string-api/infrastructure:c.device_add]{\emph{\code{device\_add()}}}}, and removes it
from the kobject hierarchy.

\textbf{NOTE}

this should be called manually \_iff\_ {\hyperref[driver\string-api/infrastructure:c.device_add]{\emph{\code{device\_add()}}}} was
also called manually.
\index{device\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_unregister}\pysiglinewithargsret{void \bfcode{device\_unregister}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
unregister device from system.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device going away.

\end{description}

\textbf{Description}

We do this in two parts, like we do {\hyperref[driver\string-api/infrastructure:c.device_register]{\emph{\code{device\_register()}}}}. First,
we remove it from all the subsystems with {\hyperref[driver\string-api/infrastructure:c.device_del]{\emph{\code{device\_del()}}}}, then
we decrement the reference count via {\hyperref[driver\string-api/infrastructure:c.put_device]{\emph{\code{put\_device()}}}}. If that
is the final reference count, the device will be cleaned up
via \code{device\_release()} above. Otherwise, the structure will
stick around until the final reference to the device is dropped.
\index{device\_for\_each\_child (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_for_each_child}\pysiglinewithargsret{int \bfcode{device\_for\_each\_child}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ parent}, void *\emph{ data}, int (*fn) (struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}}\emph{ *dev}, void\emph{ *data}}{}
device child iterator.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * parent}}] \leavevmode
parent struct device.

\item[{\code{void * data}}] \leavevmode
data for the callback.

\item[{\code{int (*)(struct device *dev, void *data) fn}}] \leavevmode
function to be called for each device.

\end{description}

\textbf{Description}

Iterate over \textbf{parent}`s child devices, and call \textbf{fn} for each,
passing it \textbf{data}.

We check the return of \textbf{fn} each time. If it returns anything
other than 0, we break out and return that value.
\index{device\_for\_each\_child\_reverse (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_for_each_child_reverse}\pysiglinewithargsret{int \bfcode{device\_for\_each\_child\_reverse}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ parent}, void *\emph{ data}, int (*fn) (struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}}\emph{ *dev}, void\emph{ *data}}{}
device child iterator in reversed order.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * parent}}] \leavevmode
parent struct device.

\item[{\code{void * data}}] \leavevmode
data for the callback.

\item[{\code{int (*)(struct device *dev, void *data) fn}}] \leavevmode
function to be called for each device.

\end{description}

\textbf{Description}

Iterate over \textbf{parent}`s child devices, and call \textbf{fn} for each,
passing it \textbf{data}.

We check the return of \textbf{fn} each time. If it returns anything
other than 0, we break out and return that value.
\index{device\_find\_child (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_find_child}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} * \bfcode{device\_find\_child}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ parent}, void *\emph{ data}, int (*match) (struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}}\emph{ *dev}, void\emph{ *data}}{}
device iterator for locating a particular device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * parent}}] \leavevmode
parent struct device

\item[{\code{void * data}}] \leavevmode
Data to pass to match function

\item[{\code{int (*)(struct device *dev, void *data) match}}] \leavevmode
Callback function to check device

\end{description}

\textbf{Description}

This is similar to the {\hyperref[driver\string-api/infrastructure:c.device_for_each_child]{\emph{\code{device\_for\_each\_child()}}}} function above, but it
returns a reference to a device that is `found' for later use, as
determined by the \textbf{match} callback.

The callback should return 0 if the device doesn't match and non-zero
if it does.  If the callback returns non-zero and a reference to the
current device can be obtained, this function will return to the caller
and not iterate over any more devices.

\textbf{NOTE}

you will need to drop the reference with {\hyperref[driver\string-api/infrastructure:c.put_device]{\emph{\code{put\_device()}}}} after use.
\index{\_\_root\_device\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.__root_device_register}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} * \bfcode{\_\_root\_device\_register}}{const char *\emph{ name}, struct module *\emph{ owner}}{}
allocate and register a root device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
root device name

\item[{\code{struct module * owner}}] \leavevmode
owner module of the root device, usually THIS\_MODULE

\end{description}

\textbf{Description}

This function allocates a root device and registers it
using {\hyperref[driver\string-api/infrastructure:c.device_register]{\emph{\code{device\_register()}}}}. In order to free the returned
device, use {\hyperref[driver\string-api/infrastructure:c.root_device_unregister]{\emph{\code{root\_device\_unregister()}}}}.

Root devices are dummy devices which allow other devices
to be grouped under /sys/devices. Use this function to
allocate a root device and then use it as the parent of
any device which should appear under /sys/devices/\{name\}

The /sys/devices/\{name\} directory will also contain a
`module' symlink which points to the \textbf{owner} directory
in sysfs.

Returns {\hyperref[driver\string-api/infrastructure:c.device]{\emph{\code{struct device}}}} pointer on success, or \code{ERR\_PTR()} on error.

\textbf{Note}

You probably want to use \code{root\_device\_register()}.
\index{root\_device\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.root_device_unregister}\pysiglinewithargsret{void \bfcode{root\_device\_unregister}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
unregister and free a root device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device going away

\end{description}

\textbf{Description}

This function unregisters and cleans up a device that was created by
\code{root\_device\_register()}.
\index{device\_create\_vargs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_create_vargs}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} * \bfcode{device\_create\_vargs}}{struct {\hyperref[driver\string-api/infrastructure:c.class]{\emph{class}}} *\emph{ class}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ parent}, dev\_t\emph{ devt}, void *\emph{ drvdata}, const char *\emph{ fmt}, va\_list\emph{ args}}{}
creates a device and registers it with sysfs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct class * class}}] \leavevmode
pointer to the struct class that this device should be registered to

\item[{\code{struct device * parent}}] \leavevmode
pointer to the parent struct device of this new device, if any

\item[{\code{dev\_t devt}}] \leavevmode
the dev\_t for the char device to be added

\item[{\code{void * drvdata}}] \leavevmode
the data to be added to the device for callbacks

\item[{\code{const char * fmt}}] \leavevmode
string for the device's name

\item[{\code{va\_list args}}] \leavevmode
va\_list for the device's name

\end{description}

\textbf{Description}

This function can be used by char device classes.  A struct device
will be created in sysfs, registered to the specified class.

A ``dev'' file will be created, showing the dev\_t for the device, if
the dev\_t is not 0,0.
If a pointer to a parent struct device is passed in, the newly created
struct device will be a child of that device in sysfs.
The pointer to the struct device will be returned from the call.
Any further sysfs files that might be required can be created using this
pointer.

Returns {\hyperref[driver\string-api/infrastructure:c.device]{\emph{\code{struct device}}}} pointer on success, or \code{ERR\_PTR()} on error.

\textbf{Note}

the struct class passed to this function must have previously
been created with a call to \code{class\_create()}.
\index{device\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_create}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} * \bfcode{device\_create}}{struct {\hyperref[driver\string-api/infrastructure:c.class]{\emph{class}}} *\emph{ class}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ parent}, dev\_t\emph{ devt}, void *\emph{ drvdata}, const char *\emph{ fmt}, ...}{}
creates a device and registers it with sysfs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct class * class}}] \leavevmode
pointer to the struct class that this device should be registered to

\item[{\code{struct device * parent}}] \leavevmode
pointer to the parent struct device of this new device, if any

\item[{\code{dev\_t devt}}] \leavevmode
the dev\_t for the char device to be added

\item[{\code{void * drvdata}}] \leavevmode
the data to be added to the device for callbacks

\item[{\code{const char * fmt}}] \leavevmode
string for the device's name

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

This function can be used by char device classes.  A struct device
will be created in sysfs, registered to the specified class.

A ``dev'' file will be created, showing the dev\_t for the device, if
the dev\_t is not 0,0.
If a pointer to a parent struct device is passed in, the newly created
struct device will be a child of that device in sysfs.
The pointer to the struct device will be returned from the call.
Any further sysfs files that might be required can be created using this
pointer.

Returns {\hyperref[driver\string-api/infrastructure:c.device]{\emph{\code{struct device}}}} pointer on success, or \code{ERR\_PTR()} on error.

\textbf{Note}

the struct class passed to this function must have previously
been created with a call to \code{class\_create()}.
\index{device\_create\_with\_groups (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_create_with_groups}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} * \bfcode{device\_create\_with\_groups}}{struct {\hyperref[driver\string-api/infrastructure:c.class]{\emph{class}}} *\emph{ class}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ parent}, dev\_t\emph{ devt}, void *\emph{ drvdata}, const struct attribute\_group **\emph{ groups}, const char *\emph{ fmt}, ...}{}
creates a device and registers it with sysfs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct class * class}}] \leavevmode
pointer to the struct class that this device should be registered to

\item[{\code{struct device * parent}}] \leavevmode
pointer to the parent struct device of this new device, if any

\item[{\code{dev\_t devt}}] \leavevmode
the dev\_t for the char device to be added

\item[{\code{void * drvdata}}] \leavevmode
the data to be added to the device for callbacks

\item[{\code{const struct attribute\_group ** groups}}] \leavevmode
NULL-terminated list of attribute groups to be created

\item[{\code{const char * fmt}}] \leavevmode
string for the device's name

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

This function can be used by char device classes.  A struct device
will be created in sysfs, registered to the specified class.
Additional attributes specified in the groups parameter will also
be created automatically.

A ``dev'' file will be created, showing the dev\_t for the device, if
the dev\_t is not 0,0.
If a pointer to a parent struct device is passed in, the newly created
struct device will be a child of that device in sysfs.
The pointer to the struct device will be returned from the call.
Any further sysfs files that might be required can be created using this
pointer.

Returns {\hyperref[driver\string-api/infrastructure:c.device]{\emph{\code{struct device}}}} pointer on success, or \code{ERR\_PTR()} on error.

\textbf{Note}

the struct class passed to this function must have previously
been created with a call to \code{class\_create()}.
\index{device\_destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_destroy}\pysiglinewithargsret{void \bfcode{device\_destroy}}{struct {\hyperref[driver\string-api/infrastructure:c.class]{\emph{class}}} *\emph{ class}, dev\_t\emph{ devt}}{}
removes a device that was created with {\hyperref[driver\string-api/infrastructure:c.device_create]{\emph{\code{device\_create()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct class * class}}] \leavevmode
pointer to the struct class that this device was registered with

\item[{\code{dev\_t devt}}] \leavevmode
the dev\_t of the device that was previously registered

\end{description}

\textbf{Description}

This call unregisters and cleans up a device that was created with a
call to {\hyperref[driver\string-api/infrastructure:c.device_create]{\emph{\code{device\_create()}}}}.
\index{device\_rename (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_rename}\pysiglinewithargsret{int \bfcode{device\_rename}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ new\_name}}{}
renames a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
the pointer to the struct device to be renamed

\item[{\code{const char * new\_name}}] \leavevmode
the new name of the device

\end{description}

\textbf{Description}

It is the responsibility of the caller to provide mutual
exclusion between two different calls of device\_rename
on the same device to ensure that new\_name is valid and
won't conflict with other devices.

\textbf{Note}

Don't call this function.  Currently, the networking layer calls this
function, but that will change.  The following text from Kay Sievers offers
some insight:

Renaming devices is racy at many levels, symlinks and other stuff are not
replaced atomically, and you get a ``move'' uevent, but it's not easy to
connect the event to the old and new device. Device nodes are not renamed at
all, there isn't even support for that in the kernel now.

In the meantime, during renaming, your target name might be taken by another
driver, creating conflicts. Or the old name is taken directly after you
renamed it -- then you get events for the same DEVPATH, before you even see
the ``move'' event. It's just a mess, and nothing new should ever rely on
kernel device renaming. Besides that, it's not even implemented now for
other things than (driver-core wise very simple) network devices.

We are currently about to change network renaming in udev to completely
disallow renaming of devices in the same namespace as the kernel uses,
because we can't solve the problems properly, that arise with swapping names
of multiple interfaces without races. Means, renaming of eth{[}0-9{]}* will only
be allowed to some other name than eth{[}0-9{]}*, for the aforementioned
reasons.

Make up a ``real'' name in the driver before you register anything, or add
some other attributes for userspace to find the device, or use udev to add
symlinks -- but never rename kernel devices later, it's a complete mess. We
don't even want to get into that and try to implement the missing pieces in
the core. We really have other pieces to fix in the driver core mess. :)
\index{device\_move (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_move}\pysiglinewithargsret{int \bfcode{device\_move}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ new\_parent}, enum dpm\_order\emph{ dpm\_order}}{}
moves a device to a new parent

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
the pointer to the struct device to be moved

\item[{\code{struct device * new\_parent}}] \leavevmode
the new parent of the device (can by NULL)

\item[{\code{enum dpm\_order dpm\_order}}] \leavevmode
how to reorder the dpm\_list

\end{description}
\index{set\_primary\_fwnode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.set_primary_fwnode}\pysiglinewithargsret{void \bfcode{set\_primary\_fwnode}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct fwnode\_handle *\emph{ fwnode}}{}
Change the primary firmware node of a given device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to handle.

\item[{\code{struct fwnode\_handle * fwnode}}] \leavevmode
New primary firmware node of the device.

\end{description}

\textbf{Description}

Set the device's firmware node pointer to \textbf{fwnode}, but if a secondary
firmware node of the device is present, preserve it.
\index{device\_set\_of\_node\_from\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_set_of_node_from_dev}\pysiglinewithargsret{void \bfcode{device\_set\_of\_node\_from\_dev}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev2}}{}
reuse device-tree node of another device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device whose device-tree node is being set

\item[{\code{const struct device * dev2}}] \leavevmode
device whose device-tree node is being reused

\end{description}

\textbf{Description}

Takes another reference to the new device-tree node after first dropping
any reference held to the old node.
\index{register\_syscore\_ops (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.register_syscore_ops}\pysiglinewithargsret{void \bfcode{register\_syscore\_ops}}{struct syscore\_ops *\emph{ ops}}{}
Register a set of system core operations.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct syscore\_ops * ops}}] \leavevmode
System core operations to register.

\end{description}
\index{unregister\_syscore\_ops (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.unregister_syscore_ops}\pysiglinewithargsret{void \bfcode{unregister\_syscore\_ops}}{struct syscore\_ops *\emph{ ops}}{}
Unregister a set of system core operations.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct syscore\_ops * ops}}] \leavevmode
System core operations to unregister.

\end{description}
\index{syscore\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.syscore_suspend}\pysiglinewithargsret{int \bfcode{syscore\_suspend}}{void}{}
Execute all the registered system core suspend callbacks.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

This function is executed with one CPU on-line and disabled interrupts.
\index{syscore\_resume (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.syscore_resume}\pysiglinewithargsret{void \bfcode{syscore\_resume}}{void}{}
Execute all the registered system core resume callbacks.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

This function is executed with one CPU on-line and disabled interrupts.
\index{\_\_class\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.__class_create}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.class]{\emph{class}}} * \bfcode{\_\_class\_create}}{struct module *\emph{ owner}, const char *\emph{ name}, struct lock\_class\_key *\emph{ key}}{}
create a struct class structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct module * owner}}] \leavevmode
pointer to the module that is to ``own'' this struct class

\item[{\code{const char * name}}] \leavevmode
pointer to a string for the name of this class.

\item[{\code{struct lock\_class\_key * key}}] \leavevmode
the lock\_class\_key for this class; used by mutex lock debugging

\end{description}

\textbf{Description}

This is used to create a struct class pointer that can then be used
in calls to {\hyperref[driver\string-api/infrastructure:c.device_create]{\emph{\code{device\_create()}}}}.

Returns {\hyperref[driver\string-api/infrastructure:c.class]{\emph{\code{struct class}}}} pointer on success, or \code{ERR\_PTR()} on error.

Note, the pointer created here is to be destroyed when finished by
making a call to {\hyperref[driver\string-api/infrastructure:c.class_destroy]{\emph{\code{class\_destroy()}}}}.
\index{class\_destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.class_destroy}\pysiglinewithargsret{void \bfcode{class\_destroy}}{struct {\hyperref[driver\string-api/infrastructure:c.class]{\emph{class}}} *\emph{ cls}}{}
destroys a struct class structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct class * cls}}] \leavevmode
pointer to the struct class that is to be destroyed

\end{description}

\textbf{Description}

Note, the pointer to be destroyed must have been created with a call
to \code{class\_create()}.
\index{class\_dev\_iter\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.class_dev_iter_init}\pysiglinewithargsret{void \bfcode{class\_dev\_iter\_init}}{struct class\_dev\_iter *\emph{ iter}, struct {\hyperref[driver\string-api/infrastructure:c.class]{\emph{class}}} *\emph{ class}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ start}, const struct device\_type *\emph{ type}}{}
initialize class device iterator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct class\_dev\_iter * iter}}] \leavevmode
class iterator to initialize

\item[{\code{struct class * class}}] \leavevmode
the class we wanna iterate over

\item[{\code{struct device * start}}] \leavevmode
the device to start iterating from, if any

\item[{\code{const struct device\_type * type}}] \leavevmode
device\_type of the devices to iterate over, NULL for all

\end{description}

\textbf{Description}

Initialize class iterator \textbf{iter} such that it iterates over devices
of \textbf{class}.  If \textbf{start} is set, the list iteration will start there,
otherwise if it is NULL, the iteration starts at the beginning of
the list.
\index{class\_dev\_iter\_next (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.class_dev_iter_next}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} * \bfcode{class\_dev\_iter\_next}}{struct class\_dev\_iter *\emph{ iter}}{}
iterate to the next device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct class\_dev\_iter * iter}}] \leavevmode
class iterator to proceed

\end{description}

\textbf{Description}

Proceed \textbf{iter} to the next device and return it.  Returns NULL if
iteration is complete.

The returned device is referenced and won't be released till
iterator is proceed to the next device or exited.  The caller is
free to do whatever it wants to do with the device including
calling back into class code.
\index{class\_dev\_iter\_exit (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.class_dev_iter_exit}\pysiglinewithargsret{void \bfcode{class\_dev\_iter\_exit}}{struct class\_dev\_iter *\emph{ iter}}{}
finish iteration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct class\_dev\_iter * iter}}] \leavevmode
class iterator to finish

\end{description}

\textbf{Description}

Finish an iteration.  Always call this function after iteration is
complete whether the iteration ran till the end or not.
\index{class\_for\_each\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.class_for_each_device}\pysiglinewithargsret{int \bfcode{class\_for\_each\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.class]{\emph{class}}} *\emph{ class}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ start}, void *\emph{ data}, int (*fn) (struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}}\emph{ *}, void\emph{ *}}{}
device iterator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct class * class}}] \leavevmode
the class we're iterating

\item[{\code{struct device * start}}] \leavevmode
the device to start with in the list, if any.

\item[{\code{void * data}}] \leavevmode
data for the callback

\item[{\code{int (*)(struct device *, void *) fn}}] \leavevmode
function to be called for each device

\end{description}

\textbf{Description}

Iterate over \textbf{class}`s list of devices, and call \textbf{fn} for each,
passing it \textbf{data}.  If \textbf{start} is set, the list iteration will start
there, otherwise if it is NULL, the iteration starts at the
beginning of the list.

We check the return of \textbf{fn} each time. If it returns anything
other than 0, we break out and return that value.

\textbf{fn} is allowed to do anything including calling back into class
code.  There's no locking restriction.
\index{class\_find\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.class_find_device}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} * \bfcode{class\_find\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.class]{\emph{class}}} *\emph{ class}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ start}, const void *\emph{ data}, int (*match) (struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}}\emph{ *}, const void\emph{ *}}{}
device iterator for locating a particular device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct class * class}}] \leavevmode
the class we're iterating

\item[{\code{struct device * start}}] \leavevmode
Device to begin with

\item[{\code{const void * data}}] \leavevmode
data for the match function

\item[{\code{int (*)(struct device *, const void *) match}}] \leavevmode
function to check device

\end{description}

\textbf{Description}

This is similar to the \code{class\_for\_each\_dev()} function above, but it
returns a reference to a device that is `found' for later use, as
determined by the \textbf{match} callback.

The callback should return 0 if the device doesn't match and non-zero
if it does.  If the callback returns non-zero, this function will
return to the caller and not iterate over any more devices.

Note, you will need to drop the reference with {\hyperref[driver\string-api/infrastructure:c.put_device]{\emph{\code{put\_device()}}}} after use.

\textbf{match} is allowed to do anything including calling back into class
code.  There's no locking restriction.
\index{class\_compat\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.class_compat_register}\pysiglinewithargsret{struct class\_compat * \bfcode{class\_compat\_register}}{const char *\emph{ name}}{}
register a compatibility class

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
the name of the class

\end{description}

\textbf{Description}

Compatibility class are meant as a temporary user-space compatibility
workaround when converting a family of class devices to a bus devices.
\index{class\_compat\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.class_compat_unregister}\pysiglinewithargsret{void \bfcode{class\_compat\_unregister}}{struct class\_compat *\emph{ cls}}{}
unregister a compatibility class

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct class\_compat * cls}}] \leavevmode
the class to unregister

\end{description}
\index{class\_compat\_create\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.class_compat_create_link}\pysiglinewithargsret{int \bfcode{class\_compat\_create\_link}}{struct class\_compat *\emph{ cls}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ device\_link}}{}
create a compatibility class device link to a bus device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct class\_compat * cls}}] \leavevmode
the compatibility class

\item[{\code{struct device * dev}}] \leavevmode
the target bus device

\item[{\code{struct device * device\_link}}] \leavevmode
an optional device to which a ``device'' link should be created

\end{description}
\index{class\_compat\_remove\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.class_compat_remove_link}\pysiglinewithargsret{void \bfcode{class\_compat\_remove\_link}}{struct class\_compat *\emph{ cls}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ device\_link}}{}
remove a compatibility class device link to a bus device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct class\_compat * cls}}] \leavevmode
the compatibility class

\item[{\code{struct device * dev}}] \leavevmode
the target bus device

\item[{\code{struct device * device\_link}}] \leavevmode
an optional device to which a ``device'' link was previously
created

\end{description}
\index{unregister\_node (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.unregister_node}\pysiglinewithargsret{void \bfcode{unregister\_node}}{struct node *\emph{ node}}{}
unregister a node device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct node * node}}] \leavevmode
node going away

\end{description}

\textbf{Description}

Unregisters a node device \textbf{node}.  All the devices on the node must be
unregistered before calling this function.
\index{request\_firmware (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.request_firmware}\pysiglinewithargsret{int \bfcode{request\_firmware}}{const struct firmware **\emph{ firmware\_p}, const char *\emph{ name}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ device}}{}
send firmware request and wait for it

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct firmware ** firmware\_p}}] \leavevmode
pointer to firmware image

\item[{\code{const char * name}}] \leavevmode
name of firmware file

\item[{\code{struct device * device}}] \leavevmode
device for which firmware is being loaded

\end{description}

\textbf{Description}
\begin{quote}

\textbf{firmware\_p} will be used to return a firmware image by the name
of \textbf{name} for device \textbf{device}.

Should be called from user context where sleeping is allowed.

\textbf{name} will be used as \$FIRMWARE in the uevent environment and
should be distinctive enough not to be confused with any other
firmware image for this or any other device.

Caller must hold the reference count of \textbf{device}.

The function can be called safely inside device's suspend and
resume callback.
\end{quote}
\index{request\_firmware\_direct (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.request_firmware_direct}\pysiglinewithargsret{int \bfcode{request\_firmware\_direct}}{const struct firmware **\emph{ firmware\_p}, const char *\emph{ name}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ device}}{}
load firmware directly without usermode helper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct firmware ** firmware\_p}}] \leavevmode
pointer to firmware image

\item[{\code{const char * name}}] \leavevmode
name of firmware file

\item[{\code{struct device * device}}] \leavevmode
device for which firmware is being loaded

\end{description}

\textbf{Description}

This function works pretty much like {\hyperref[driver\string-api/infrastructure:c.request_firmware]{\emph{\code{request\_firmware()}}}}, but this doesn't
fall back to usermode helper even if the firmware couldn't be loaded
directly from fs.  Hence it's useful for loading optional firmwares, which
aren't always present, without extra long timeouts of udev.
\index{request\_firmware\_into\_buf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.request_firmware_into_buf}\pysiglinewithargsret{int \bfcode{request\_firmware\_into\_buf}}{const struct firmware **\emph{ firmware\_p}, const char *\emph{ name}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ device}, void *\emph{ buf}, size\_t\emph{ size}}{}
load firmware into a previously allocated buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct firmware ** firmware\_p}}] \leavevmode
pointer to firmware image

\item[{\code{const char * name}}] \leavevmode
name of firmware file

\item[{\code{struct device * device}}] \leavevmode
device for which firmware is being loaded and DMA region allocated

\item[{\code{void * buf}}] \leavevmode
address of buffer to load firmware into

\item[{\code{size\_t size}}] \leavevmode
size of buffer

\end{description}

\textbf{Description}

This function works pretty much like {\hyperref[driver\string-api/infrastructure:c.request_firmware]{\emph{\code{request\_firmware()}}}}, but it doesn't
allocate a buffer to hold the firmware data. Instead, the firmware
is loaded directly into the buffer pointed to by \textbf{buf} and the \textbf{firmware\_p}
data member is pointed at \textbf{buf}.

This function doesn't cache firmware either.
\index{release\_firmware (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.release_firmware}\pysiglinewithargsret{void \bfcode{release\_firmware}}{const struct firmware *\emph{ fw}}{}
release the resource associated with a firmware image

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct firmware * fw}}] \leavevmode
firmware resource to release

\end{description}
\index{request\_firmware\_nowait (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.request_firmware_nowait}\pysiglinewithargsret{int \bfcode{request\_firmware\_nowait}}{struct module *\emph{ module}, bool\emph{ uevent}, const char *\emph{ name}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ device}, gfp\_t\emph{ gfp}, void *\emph{ context}, void (*cont) (const struct firmware\emph{ *fw}, void\emph{ *context}}{}
asynchronous version of request\_firmware

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct module * module}}] \leavevmode
module requesting the firmware

\item[{\code{bool uevent}}] \leavevmode
sends uevent to copy the firmware image if this flag
is non-zero else the firmware copy must be done manually.

\item[{\code{const char * name}}] \leavevmode
name of firmware file

\item[{\code{struct device * device}}] \leavevmode
device for which firmware is being loaded

\item[{\code{gfp\_t gfp}}] \leavevmode
allocation flags

\item[{\code{void * context}}] \leavevmode
will be passed over to \textbf{cont}, and
\textbf{fw} may be \code{NULL} if firmware request fails.

\item[{\code{void (*)(const struct firmware *fw, void *context) cont}}] \leavevmode
function will be called asynchronously when the firmware
request is over.

\end{description}

\textbf{Description}
\begin{quote}

Caller must hold the reference count of \textbf{device}.
\begin{description}
\item[{Asynchronous variant of {\hyperref[driver\string-api/infrastructure:c.request_firmware]{\emph{\code{request\_firmware()}}}} for user contexts:}] \leavevmode\begin{itemize}
\item {} 
sleep for as small periods as possible since it may
increase kernel boot time of built-in device drivers
requesting firmware in their -\textgreater{}:c:func:\emph{probe()} methods, if
\textbf{gfp} is GFP\_KERNEL.

\item {} 
can't sleep at all if \textbf{gfp} is GFP\_ATOMIC.

\end{itemize}

\end{description}
\end{quote}
\index{transport\_class\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.transport_class_register}\pysiglinewithargsret{int \bfcode{transport\_class\_register}}{struct transport\_class *\emph{ tclass}}{}
register an initial transport class

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct transport\_class * tclass}}] \leavevmode
a pointer to the transport class structure to be initialised

\end{description}

\textbf{Description}

The transport class contains an embedded class which is used to
identify it.  The caller should initialise this structure with
zeros and then generic class must have been initialised with the
actual transport class unique name.  There's a macro
\code{DECLARE\_TRANSPORT\_CLASS()} to do this (declared classes still must
be registered).

Returns 0 on success or error on failure.
\index{transport\_class\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.transport_class_unregister}\pysiglinewithargsret{void \bfcode{transport\_class\_unregister}}{struct transport\_class *\emph{ tclass}}{}
unregister a previously registered class

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct transport\_class * tclass}}] \leavevmode
The transport class to unregister

\end{description}

\textbf{Description}

Must be called prior to deallocating the memory for the transport
class.
\index{anon\_transport\_class\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.anon_transport_class_register}\pysiglinewithargsret{int \bfcode{anon\_transport\_class\_register}}{struct anon\_transport\_class *\emph{ atc}}{}
register an anonymous class

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct anon\_transport\_class * atc}}] \leavevmode
The anon transport class to register

\end{description}

\textbf{Description}

The anonymous transport class contains both a transport class and a
container.  The idea of an anonymous class is that it never
actually has any device attributes associated with it (and thus
saves on container storage).  So it can only be used for triggering
events.  Use prezero and then use \code{DECLARE\_ANON\_TRANSPORT\_CLASS()} to
initialise the anon transport class storage.
\index{anon\_transport\_class\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.anon_transport_class_unregister}\pysiglinewithargsret{void \bfcode{anon\_transport\_class\_unregister}}{struct anon\_transport\_class *\emph{ atc}}{}
unregister an anon class

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct anon\_transport\_class * atc}}] \leavevmode
Pointer to the anon transport class to unregister

\end{description}

\textbf{Description}

Must be called prior to deallocating the memory for the anon
transport class.
\index{transport\_setup\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.transport_setup_device}\pysiglinewithargsret{void \bfcode{transport\_setup\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
declare a new dev for transport class association but don't make it visible yet.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
the generic device representing the entity being added

\end{description}

\textbf{Description}

Usually, dev represents some component in the HBA system (either
the HBA itself or a device remote across the HBA bus).  This
routine is simply a trigger point to see if any set of transport
classes wishes to associate with the added device.  This allocates
storage for the class device and initialises it, but does not yet
add it to the system or add attributes to it (you do this with
transport\_add\_device).  If you have no need for a separate setup
and add operations, use transport\_register\_device (see
transport\_class.h).
\index{transport\_add\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.transport_add_device}\pysiglinewithargsret{void \bfcode{transport\_add\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
declare a new dev for transport class association

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
the generic device representing the entity being added

\end{description}

\textbf{Description}

Usually, dev represents some component in the HBA system (either
the HBA itself or a device remote across the HBA bus).  This
routine is simply a trigger point used to add the device to the
system and register attributes for it.
\index{transport\_configure\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.transport_configure_device}\pysiglinewithargsret{void \bfcode{transport\_configure\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
configure an already set up device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
generic device representing device to be configured

\end{description}

\textbf{Description}

The idea of configure is simply to provide a point within the setup
process to allow the transport class to extract information from a
device after it has been setup.  This is used in SCSI because we
have to have a setup device to begin using the HBA, but after we
send the initial inquiry, we use configure to extract the device
parameters.  The device need not have been added to be configured.
\index{transport\_remove\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.transport_remove_device}\pysiglinewithargsret{void \bfcode{transport\_remove\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
remove the visibility of a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
generic device to remove

\end{description}

\textbf{Description}

This call removes the visibility of the device (to the user from
sysfs), but does not destroy it.  To eliminate a device entirely
you must also call transport\_destroy\_device.  If you don't need to
do remove and destroy as separate operations, use
\code{transport\_unregister\_device()} (see transport\_class.h) which will
perform both calls for you.
\index{transport\_destroy\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.transport_destroy_device}\pysiglinewithargsret{void \bfcode{transport\_destroy\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
destroy a removed device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device to eliminate from the transport class.

\end{description}

\textbf{Description}

This call triggers the elimination of storage associated with the
transport classdev.  Note: all it really does is relinquish a
reference to the classdev.  The memory will not be freed until the
last reference goes to zero.  Note also that the classdev retains a
reference count on dev, so dev too will remain for as long as the
transport class device remains around.
\index{device\_bind\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_bind_driver}\pysiglinewithargsret{int \bfcode{device\_bind\_driver}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
bind a driver to one device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device.

\end{description}

\textbf{Description}

Allow manual attachment of a driver to a device.
Caller must have already set \textbf{dev}-\textgreater{}driver.

Note that this does not modify the bus reference count
nor take the bus's rwsem. Please verify those are accounted
for before calling this. (It is ok to call with no other effort
from a driver's \code{probe()} method.)

This function must be called with the device lock held.
\index{wait\_for\_device\_probe (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.wait_for_device_probe}\pysiglinewithargsret{void \bfcode{wait\_for\_device\_probe}}{void}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Wait for device probing to be completed.
\index{device\_attach (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_attach}\pysiglinewithargsret{int \bfcode{device\_attach}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
try to attach device to a driver.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device.

\end{description}

\textbf{Description}

Walk the list of drivers that the bus has and call
\code{driver\_probe\_device()} for each pair. If a compatible
pair is found, break out and return.

Returns 1 if the device was bound to a driver;
0 if no matching driver was found;
-ENODEV if the device is not registered.

When called for a USB interface, \textbf{dev}-\textgreater{}parent lock must be held.
\index{driver\_attach (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.driver_attach}\pysiglinewithargsret{int \bfcode{driver\_attach}}{struct {\hyperref[driver\string-api/infrastructure:c.device_driver]{\emph{device\_driver}}} *\emph{ drv}}{}
try to bind driver to devices.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device\_driver * drv}}] \leavevmode
driver.

\end{description}

\textbf{Description}

Walk the list of devices that the bus has on it and try to
match the driver with each one.  If \code{driver\_probe\_device()}
returns 0 and the \textbf{dev}-\textgreater{}driver is set, we've found a
compatible pair.
\index{device\_release\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_release_driver}\pysiglinewithargsret{void \bfcode{device\_release\_driver}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
manually detach device from driver.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device.

\end{description}

\textbf{Description}

Manually detach device from driver.
When called for a USB interface, \textbf{dev}-\textgreater{}parent lock must be held.

If this function is to be called with \textbf{dev}-\textgreater{}parent lock held, ensure that
the device's consumers are unbound in advance or that their locks can be
acquired under the \textbf{dev}-\textgreater{}parent lock.
\index{platform\_device\_register\_resndata (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_device_register_resndata}\pysiglinewithargsret{struct platform\_device * \bfcode{platform\_device\_register\_resndata}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ parent}, const char *\emph{ name}, int\emph{ id}, const struct resource *\emph{ res}, unsigned int\emph{ num}, const void *\emph{ data}, size\_t\emph{ size}}{}
add a platform-level device with resources and platform-specific data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * parent}}] \leavevmode
parent device for the device we're adding

\item[{\code{const char * name}}] \leavevmode
base name of the device we're adding

\item[{\code{int id}}] \leavevmode
instance id

\item[{\code{const struct resource * res}}] \leavevmode
set of resources that needs to be allocated for the device

\item[{\code{unsigned int num}}] \leavevmode
number of resources

\item[{\code{const void * data}}] \leavevmode
platform specific data for this platform device

\item[{\code{size\_t size}}] \leavevmode
size of platform specific data

\end{description}

\textbf{Description}

Returns \code{struct platform\_device} pointer on success, or \code{ERR\_PTR()} on error.
\index{platform\_device\_register\_simple (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_device_register_simple}\pysiglinewithargsret{struct platform\_device * \bfcode{platform\_device\_register\_simple}}{const char *\emph{ name}, int\emph{ id}, const struct resource *\emph{ res}, unsigned int\emph{ num}}{}
add a platform-level device and its resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
base name of the device we're adding

\item[{\code{int id}}] \leavevmode
instance id

\item[{\code{const struct resource * res}}] \leavevmode
set of resources that needs to be allocated for the device

\item[{\code{unsigned int num}}] \leavevmode
number of resources

\end{description}

\textbf{Description}

This function creates a simple platform device that requires minimal
resource and memory management. Canned release function freeing memory
allocated for the device allows drivers using such devices to be
unloaded without waiting for the last reference to the device to be
dropped.

This interface is primarily intended for use with legacy drivers which
probe hardware directly.  Because such drivers create sysfs device nodes
themselves, rather than letting system infrastructure handle such device
enumeration tasks, they don't fully conform to the Linux driver model.
In particular, when such drivers are built as modules, they can't be
``hotplugged''.

Returns \code{struct platform\_device} pointer on success, or \code{ERR\_PTR()} on error.
\index{platform\_device\_register\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_device_register_data}\pysiglinewithargsret{struct platform\_device * \bfcode{platform\_device\_register\_data}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ parent}, const char *\emph{ name}, int\emph{ id}, const void *\emph{ data}, size\_t\emph{ size}}{}
add a platform-level device with platform-specific data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * parent}}] \leavevmode
parent device for the device we're adding

\item[{\code{const char * name}}] \leavevmode
base name of the device we're adding

\item[{\code{int id}}] \leavevmode
instance id

\item[{\code{const void * data}}] \leavevmode
platform specific data for this platform device

\item[{\code{size\_t size}}] \leavevmode
size of platform specific data

\end{description}

\textbf{Description}

This function creates a simple platform device that requires minimal
resource and memory management. Canned release function freeing memory
allocated for the device allows drivers using such devices to be
unloaded without waiting for the last reference to the device to be
dropped.

Returns \code{struct platform\_device} pointer on success, or \code{ERR\_PTR()} on error.
\index{platform\_get\_resource (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_get_resource}\pysiglinewithargsret{struct resource * \bfcode{platform\_get\_resource}}{struct platform\_device *\emph{ dev}, unsigned int\emph{ type}, unsigned int\emph{ num}}{}
get a resource for a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_device * dev}}] \leavevmode
platform device

\item[{\code{unsigned int type}}] \leavevmode
resource type

\item[{\code{unsigned int num}}] \leavevmode
resource index

\end{description}
\index{platform\_get\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_get_irq}\pysiglinewithargsret{int \bfcode{platform\_get\_irq}}{struct platform\_device *\emph{ dev}, unsigned int\emph{ num}}{}
get an IRQ for a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_device * dev}}] \leavevmode
platform device

\item[{\code{unsigned int num}}] \leavevmode
IRQ number index

\end{description}
\index{platform\_irq\_count (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_irq_count}\pysiglinewithargsret{int \bfcode{platform\_irq\_count}}{struct platform\_device *\emph{ dev}}{}
Count the number of IRQs a platform device uses

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_device * dev}}] \leavevmode
platform device

\end{description}

\textbf{Return}

Number of IRQs a platform device uses or EPROBE\_DEFER
\index{platform\_get\_resource\_byname (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_get_resource_byname}\pysiglinewithargsret{struct resource * \bfcode{platform\_get\_resource\_byname}}{struct platform\_device *\emph{ dev}, unsigned int\emph{ type}, const char *\emph{ name}}{}
get a resource for a device by name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_device * dev}}] \leavevmode
platform device

\item[{\code{unsigned int type}}] \leavevmode
resource type

\item[{\code{const char * name}}] \leavevmode
resource name

\end{description}
\index{platform\_get\_irq\_byname (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_get_irq_byname}\pysiglinewithargsret{int \bfcode{platform\_get\_irq\_byname}}{struct platform\_device *\emph{ dev}, const char *\emph{ name}}{}
get an IRQ for a device by name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_device * dev}}] \leavevmode
platform device

\item[{\code{const char * name}}] \leavevmode
IRQ name

\end{description}
\index{platform\_add\_devices (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_add_devices}\pysiglinewithargsret{int \bfcode{platform\_add\_devices}}{struct platform\_device **\emph{ devs}, int\emph{ num}}{}
add a numbers of platform devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_device ** devs}}] \leavevmode
array of platform devices to add

\item[{\code{int num}}] \leavevmode
number of platform devices in array

\end{description}
\index{platform\_device\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_device_put}\pysiglinewithargsret{void \bfcode{platform\_device\_put}}{struct platform\_device *\emph{ pdev}}{}
destroy a platform device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_device * pdev}}] \leavevmode
platform device to free

\end{description}

\textbf{Description}

Free all memory associated with a platform device.  This function must
\_only\_ be externally called in error cases.  All other usage is a bug.
\index{platform\_device\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_device_alloc}\pysiglinewithargsret{struct platform\_device * \bfcode{platform\_device\_alloc}}{const char *\emph{ name}, int\emph{ id}}{}
create a platform device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
base name of the device we're adding

\item[{\code{int id}}] \leavevmode
instance id

\end{description}

\textbf{Description}

Create a platform device object which can have other objects attached
to it, and which will have attached objects freed when it is released.
\index{platform\_device\_add\_resources (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_device_add_resources}\pysiglinewithargsret{int \bfcode{platform\_device\_add\_resources}}{struct platform\_device *\emph{ pdev}, const struct resource *\emph{ res}, unsigned int\emph{ num}}{}
add resources to a platform device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_device * pdev}}] \leavevmode
platform device allocated by platform\_device\_alloc to add resources to

\item[{\code{const struct resource * res}}] \leavevmode
set of resources that needs to be allocated for the device

\item[{\code{unsigned int num}}] \leavevmode
number of resources

\end{description}

\textbf{Description}

Add a copy of the resources to the platform device.  The memory
associated with the resources will be freed when the platform device is
released.
\index{platform\_device\_add\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_device_add_data}\pysiglinewithargsret{int \bfcode{platform\_device\_add\_data}}{struct platform\_device *\emph{ pdev}, const void *\emph{ data}, size\_t\emph{ size}}{}
add platform-specific data to a platform device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_device * pdev}}] \leavevmode
platform device allocated by platform\_device\_alloc to add resources to

\item[{\code{const void * data}}] \leavevmode
platform specific data for this platform device

\item[{\code{size\_t size}}] \leavevmode
size of platform specific data

\end{description}

\textbf{Description}

Add a copy of platform specific data to the platform device's
platform\_data pointer.  The memory associated with the platform data
will be freed when the platform device is released.
\index{platform\_device\_add\_properties (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_device_add_properties}\pysiglinewithargsret{int \bfcode{platform\_device\_add\_properties}}{struct platform\_device *\emph{ pdev}, const struct property\_entry *\emph{ properties}}{}
add built-in properties to a platform device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_device * pdev}}] \leavevmode
platform device to add properties to

\item[{\code{const struct property\_entry * properties}}] \leavevmode
null terminated array of properties to add

\end{description}

\textbf{Description}

The function will take deep copy of \textbf{properties} and attach the copy to the
platform device. The memory associated with properties will be freed when the
platform device is released.
\index{platform\_device\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_device_add}\pysiglinewithargsret{int \bfcode{platform\_device\_add}}{struct platform\_device *\emph{ pdev}}{}
add a platform device to device hierarchy

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_device * pdev}}] \leavevmode
platform device we're adding

\end{description}

\textbf{Description}

This is part 2 of {\hyperref[driver\string-api/infrastructure:c.platform_device_register]{\emph{\code{platform\_device\_register()}}}}, though may be called
separately \_iff\_ pdev was allocated by {\hyperref[driver\string-api/infrastructure:c.platform_device_alloc]{\emph{\code{platform\_device\_alloc()}}}}.
\index{platform\_device\_del (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_device_del}\pysiglinewithargsret{void \bfcode{platform\_device\_del}}{struct platform\_device *\emph{ pdev}}{}
remove a platform-level device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_device * pdev}}] \leavevmode
platform device we're removing

\end{description}

\textbf{Description}

Note that this function will also release all memory- and port-based
resources owned by the device (\textbf{dev}-\textgreater{}resource).  This function must
\_only\_ be externally called in error cases.  All other usage is a bug.
\index{platform\_device\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_device_register}\pysiglinewithargsret{int \bfcode{platform\_device\_register}}{struct platform\_device *\emph{ pdev}}{}
add a platform-level device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_device * pdev}}] \leavevmode
platform device we're adding

\end{description}
\index{platform\_device\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_device_unregister}\pysiglinewithargsret{void \bfcode{platform\_device\_unregister}}{struct platform\_device *\emph{ pdev}}{}
unregister a platform-level device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_device * pdev}}] \leavevmode
platform device we're unregistering

\end{description}

\textbf{Description}

Unregistration is done in 2 steps. First we release all resources
and remove it from the subsystem, then we drop reference count by
calling {\hyperref[driver\string-api/infrastructure:c.platform_device_put]{\emph{\code{platform\_device\_put()}}}}.
\index{platform\_device\_register\_full (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_device_register_full}\pysiglinewithargsret{struct platform\_device * \bfcode{platform\_device\_register\_full}}{const struct platform\_device\_info *\emph{ pdevinfo}}{}
add a platform-level device with resources and platform-specific data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct platform\_device\_info * pdevinfo}}] \leavevmode
data used to create device

\end{description}

\textbf{Description}

Returns \code{struct platform\_device} pointer on success, or \code{ERR\_PTR()} on error.
\index{\_\_platform\_driver\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.__platform_driver_register}\pysiglinewithargsret{int \bfcode{\_\_platform\_driver\_register}}{struct platform\_driver *\emph{ drv}, struct module *\emph{ owner}}{}
register a driver for platform-level devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_driver * drv}}] \leavevmode
platform driver structure

\item[{\code{struct module * owner}}] \leavevmode
owning module/driver

\end{description}
\index{platform\_driver\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_driver_unregister}\pysiglinewithargsret{void \bfcode{platform\_driver\_unregister}}{struct platform\_driver *\emph{ drv}}{}
unregister a driver for platform-level devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_driver * drv}}] \leavevmode
platform driver structure

\end{description}
\index{\_\_platform\_driver\_probe (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.__platform_driver_probe}\pysiglinewithargsret{int \bfcode{\_\_platform\_driver\_probe}}{struct platform\_driver *\emph{ drv}, int (*probe) (struct platform\_device\emph{ *}, struct module *\emph{ module}}{}
register driver for non-hotpluggable device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_driver * drv}}] \leavevmode
platform driver structure

\item[{\code{int (*)(struct platform\_device *) probe}}] \leavevmode
the driver probe routine, probably from an \_\_init section

\item[{\code{struct module * module}}] \leavevmode
module which will be the owner of the driver

\end{description}

\textbf{Description}

Use this instead of \code{platform\_driver\_register()} when you know the device
is not hotpluggable and has already been registered, and you want to
remove its run-once \code{probe()} infrastructure from memory after the driver
has bound to the device.

One typical use for this would be with drivers for controllers integrated
into system-on-chip processors, where the controller devices have been
configured as part of board setup.

Note that this is incompatible with deferred probing.

Returns zero if the driver registered and bound to a device, else returns
a negative error code and with the driver not registered.
\index{\_\_platform\_create\_bundle (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.__platform_create_bundle}\pysiglinewithargsret{struct platform\_device * \bfcode{\_\_platform\_create\_bundle}}{struct platform\_driver *\emph{ driver}, int (*probe) (struct platform\_device\emph{ *}, struct resource *\emph{ res}, unsigned int\emph{ n\_res}, const void *\emph{ data}, size\_t\emph{ size}, struct module *\emph{ module}}{}
register driver and create corresponding device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_driver * driver}}] \leavevmode
platform driver structure

\item[{\code{int (*)(struct platform\_device *) probe}}] \leavevmode
the driver probe routine, probably from an \_\_init section

\item[{\code{struct resource * res}}] \leavevmode
set of resources that needs to be allocated for the device

\item[{\code{unsigned int n\_res}}] \leavevmode
number of resources

\item[{\code{const void * data}}] \leavevmode
platform specific data for this platform device

\item[{\code{size\_t size}}] \leavevmode
size of platform specific data

\item[{\code{struct module * module}}] \leavevmode
module which will be the owner of the driver

\end{description}

\textbf{Description}

Use this in legacy-style modules that probe hardware directly and
register a single platform device and corresponding platform driver.

Returns \code{struct platform\_device} pointer on success, or \code{ERR\_PTR()} on error.
\index{\_\_platform\_register\_drivers (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.__platform_register_drivers}\pysiglinewithargsret{int \bfcode{\_\_platform\_register\_drivers}}{struct platform\_driver *const *\emph{ drivers}, unsigned int\emph{ count}, struct module *\emph{ owner}}{}
register an array of platform drivers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_driver *const * drivers}}] \leavevmode
an array of drivers to register

\item[{\code{unsigned int count}}] \leavevmode
the number of drivers to register

\item[{\code{struct module * owner}}] \leavevmode
module owning the drivers

\end{description}

\textbf{Description}

Registers platform drivers specified by an array. On failure to register a
driver, all previously registered drivers will be unregistered. Callers of
this API should use {\hyperref[driver\string-api/infrastructure:c.platform_unregister_drivers]{\emph{\code{platform\_unregister\_drivers()}}}} to unregister drivers in
the reverse order.

\textbf{Return}

0 on success or a negative error code on failure.
\index{platform\_unregister\_drivers (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.platform_unregister_drivers}\pysiglinewithargsret{void \bfcode{platform\_unregister\_drivers}}{struct platform\_driver *const *\emph{ drivers}, unsigned int\emph{ count}}{}
unregister an array of platform drivers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_driver *const * drivers}}] \leavevmode
an array of drivers to unregister

\item[{\code{unsigned int count}}] \leavevmode
the number of drivers to unregister

\end{description}

\textbf{Description}

Unegisters platform drivers specified by an array. This is typically used
to complement an earlier call to \code{platform\_register\_drivers()}. Drivers are
unregistered in the reverse order in which they were registered.
\index{bus\_for\_each\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.bus_for_each_dev}\pysiglinewithargsret{int \bfcode{bus\_for\_each\_dev}}{struct {\hyperref[driver\string-api/infrastructure:c.bus_type]{\emph{bus\_type}}} *\emph{ bus}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ start}, void *\emph{ data}, int (*fn) (struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}}\emph{ *}, void\emph{ *}}{}
device iterator.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bus\_type * bus}}] \leavevmode
bus type.

\item[{\code{struct device * start}}] \leavevmode
device to start iterating from.

\item[{\code{void * data}}] \leavevmode
data for the callback.

\item[{\code{int (*)(struct device *, void *) fn}}] \leavevmode
function to be called for each device.

\end{description}

\textbf{Description}

Iterate over \textbf{bus}`s list of devices, and call \textbf{fn} for each,
passing it \textbf{data}. If \textbf{start} is not NULL, we use that device to
begin iterating from.

We check the return of \textbf{fn} each time. If it returns anything
other than 0, we break out and return that value.

\textbf{NOTE}

The device that returns a non-zero value is not retained
in any way, nor is its refcount incremented. If the caller needs
to retain this data, it should do so, and increment the reference
count in the supplied callback.
\index{bus\_find\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.bus_find_device}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} * \bfcode{bus\_find\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.bus_type]{\emph{bus\_type}}} *\emph{ bus}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ start}, void *\emph{ data}, int (*match) (struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}}\emph{ *dev}, void\emph{ *data}}{}
device iterator for locating a particular device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bus\_type * bus}}] \leavevmode
bus type

\item[{\code{struct device * start}}] \leavevmode
Device to begin with

\item[{\code{void * data}}] \leavevmode
Data to pass to match function

\item[{\code{int (*)(struct device *dev, void *data) match}}] \leavevmode
Callback function to check device

\end{description}

\textbf{Description}

This is similar to the {\hyperref[driver\string-api/infrastructure:c.bus_for_each_dev]{\emph{\code{bus\_for\_each\_dev()}}}} function above, but it
returns a reference to a device that is `found' for later use, as
determined by the \textbf{match} callback.

The callback should return 0 if the device doesn't match and non-zero
if it does.  If the callback returns non-zero, this function will
return to the caller and not iterate over any more devices.
\index{bus\_find\_device\_by\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.bus_find_device_by_name}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} * \bfcode{bus\_find\_device\_by\_name}}{struct {\hyperref[driver\string-api/infrastructure:c.bus_type]{\emph{bus\_type}}} *\emph{ bus}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ start}, const char *\emph{ name}}{}
device iterator for locating a particular device of a specific name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bus\_type * bus}}] \leavevmode
bus type

\item[{\code{struct device * start}}] \leavevmode
Device to begin with

\item[{\code{const char * name}}] \leavevmode
name of the device to match

\end{description}

\textbf{Description}

This is similar to the {\hyperref[driver\string-api/infrastructure:c.bus_find_device]{\emph{\code{bus\_find\_device()}}}} function above, but it handles
searching by a name automatically, no need to write another strcmp matching
function.
\index{subsys\_find\_device\_by\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.subsys_find_device_by_id}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} * \bfcode{subsys\_find\_device\_by\_id}}{struct {\hyperref[driver\string-api/infrastructure:c.bus_type]{\emph{bus\_type}}} *\emph{ subsys}, unsigned int\emph{ id}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ hint}}{}
find a device with a specific enumeration number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bus\_type * subsys}}] \leavevmode
subsystem

\item[{\code{unsigned int id}}] \leavevmode
index `id' in struct device

\item[{\code{struct device * hint}}] \leavevmode
device to check first

\end{description}

\textbf{Description}

Check the hint's next object and if it is a match return it directly,
otherwise, fall back to a full list search. Either way a reference for
the returned object is taken.
\index{bus\_for\_each\_drv (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.bus_for_each_drv}\pysiglinewithargsret{int \bfcode{bus\_for\_each\_drv}}{struct {\hyperref[driver\string-api/infrastructure:c.bus_type]{\emph{bus\_type}}} *\emph{ bus}, struct {\hyperref[driver\string-api/infrastructure:c.device_driver]{\emph{device\_driver}}} *\emph{ start}, void *\emph{ data}, int (*fn) (struct {\hyperref[driver\string-api/infrastructure:c.device_driver]{\emph{device\_driver}}}\emph{ *}, void\emph{ *}}{}
driver iterator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bus\_type * bus}}] \leavevmode
bus we're dealing with.

\item[{\code{struct device\_driver * start}}] \leavevmode
driver to start iterating on.

\item[{\code{void * data}}] \leavevmode
data to pass to the callback.

\item[{\code{int (*)(struct device\_driver *, void *) fn}}] \leavevmode
function to call for each driver.

\end{description}

\textbf{Description}

This is nearly identical to the device iterator above.
We iterate over each driver that belongs to \textbf{bus}, and call
\textbf{fn} for each. If \textbf{fn} returns anything but 0, we break out
and return it. If \textbf{start} is not NULL, we use it as the head
of the list.

\textbf{NOTE}

we don't return the driver that returns a non-zero
value, nor do we leave the reference count incremented for that
driver. If the caller needs to know that info, it must set it
in the callback. It must also be sure to increment the refcount
so it doesn't disappear before returning to the caller.
\index{bus\_rescan\_devices (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.bus_rescan_devices}\pysiglinewithargsret{int \bfcode{bus\_rescan\_devices}}{struct {\hyperref[driver\string-api/infrastructure:c.bus_type]{\emph{bus\_type}}} *\emph{ bus}}{}
rescan devices on the bus for possible drivers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bus\_type * bus}}] \leavevmode
the bus to scan.

\end{description}

\textbf{Description}

This function will look for devices on the bus with no driver
attached and rescan it against existing drivers to see if it matches
any by calling {\hyperref[driver\string-api/infrastructure:c.device_attach]{\emph{\code{device\_attach()}}}} for the unbound devices.
\index{device\_reprobe (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.device_reprobe}\pysiglinewithargsret{int \bfcode{device\_reprobe}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
remove driver for a device and probe for a new driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
the device to reprobe

\end{description}

\textbf{Description}

This function detaches the attached driver (if any) for the given
device and restarts the driver probing process.  It is intended
to use if probing criteria changed during a devices lifetime and
driver attachment should change accordingly.
\index{bus\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.bus_register}\pysiglinewithargsret{int \bfcode{bus\_register}}{struct {\hyperref[driver\string-api/infrastructure:c.bus_type]{\emph{bus\_type}}} *\emph{ bus}}{}
register a driver-core subsystem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bus\_type * bus}}] \leavevmode
bus to register

\end{description}

\textbf{Description}

Once we have that, we register the bus with the kobject
infrastructure, then register the children subsystems it has:
the devices and drivers that belong to the subsystem.
\index{bus\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.bus_unregister}\pysiglinewithargsret{void \bfcode{bus\_unregister}}{struct {\hyperref[driver\string-api/infrastructure:c.bus_type]{\emph{bus\_type}}} *\emph{ bus}}{}
remove a bus from the system

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bus\_type * bus}}] \leavevmode
bus.

\end{description}

\textbf{Description}

Unregister the child subsystems and the bus itself.
Finally, we call \code{bus\_put()} to release the refcount
\index{subsys\_dev\_iter\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.subsys_dev_iter_init}\pysiglinewithargsret{void \bfcode{subsys\_dev\_iter\_init}}{struct subsys\_dev\_iter *\emph{ iter}, struct {\hyperref[driver\string-api/infrastructure:c.bus_type]{\emph{bus\_type}}} *\emph{ subsys}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ start}, const struct device\_type *\emph{ type}}{}
initialize subsys device iterator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct subsys\_dev\_iter * iter}}] \leavevmode
subsys iterator to initialize

\item[{\code{struct bus\_type * subsys}}] \leavevmode
the subsys we wanna iterate over

\item[{\code{struct device * start}}] \leavevmode
the device to start iterating from, if any

\item[{\code{const struct device\_type * type}}] \leavevmode
device\_type of the devices to iterate over, NULL for all

\end{description}

\textbf{Description}

Initialize subsys iterator \textbf{iter} such that it iterates over devices
of \textbf{subsys}.  If \textbf{start} is set, the list iteration will start there,
otherwise if it is NULL, the iteration starts at the beginning of
the list.
\index{subsys\_dev\_iter\_next (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.subsys_dev_iter_next}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} * \bfcode{subsys\_dev\_iter\_next}}{struct subsys\_dev\_iter *\emph{ iter}}{}
iterate to the next device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct subsys\_dev\_iter * iter}}] \leavevmode
subsys iterator to proceed

\end{description}

\textbf{Description}

Proceed \textbf{iter} to the next device and return it.  Returns NULL if
iteration is complete.

The returned device is referenced and won't be released till
iterator is proceed to the next device or exited.  The caller is
free to do whatever it wants to do with the device including
calling back into subsys code.
\index{subsys\_dev\_iter\_exit (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.subsys_dev_iter_exit}\pysiglinewithargsret{void \bfcode{subsys\_dev\_iter\_exit}}{struct subsys\_dev\_iter *\emph{ iter}}{}
finish iteration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct subsys\_dev\_iter * iter}}] \leavevmode
subsys iterator to finish

\end{description}

\textbf{Description}

Finish an iteration.  Always call this function after iteration is
complete whether the iteration ran till the end or not.
\index{subsys\_system\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.subsys_system_register}\pysiglinewithargsret{int \bfcode{subsys\_system\_register}}{struct {\hyperref[driver\string-api/infrastructure:c.bus_type]{\emph{bus\_type}}} *\emph{ subsys}, const struct attribute\_group **\emph{ groups}}{}
register a subsystem at /sys/devices/system/

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bus\_type * subsys}}] \leavevmode
system subsystem

\item[{\code{const struct attribute\_group ** groups}}] \leavevmode
default attributes for the root device

\end{description}

\textbf{Description}

All `system' subsystems have a /sys/devices/system/\textless{}name\textgreater{} root device
with the name of the subsystem. The root device can carry subsystem-
wide attributes. All registered devices are below this single root
device and are named after the subsystem with a simple enumeration
number appended. The registered devices are not explicitly named;
only `id' in the device needs to be set.

Do not use this interface for anything new, it exists for compatibility
with bad ideas only. New subsystems should use plain subsystems; and
add the subsystem-wide attributes should be added to the subsystem
directory itself and not some create fake root-device placed in
/sys/devices/system/\textless{}name\textgreater{}.
\index{subsys\_virtual\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.subsys_virtual_register}\pysiglinewithargsret{int \bfcode{subsys\_virtual\_register}}{struct {\hyperref[driver\string-api/infrastructure:c.bus_type]{\emph{bus\_type}}} *\emph{ subsys}, const struct attribute\_group **\emph{ groups}}{}
register a subsystem at /sys/devices/virtual/

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bus\_type * subsys}}] \leavevmode
virtual subsystem

\item[{\code{const struct attribute\_group ** groups}}] \leavevmode
default attributes for the root device

\end{description}

\textbf{Description}

All `virtual' subsystems have a /sys/devices/system/\textless{}name\textgreater{} root device
with the name of the subystem.  The root device can carry subsystem-wide
attributes.  All registered devices are below this single root device.
There's no restriction on device naming.  This is for kernel software
constructs which need sysfs interface.


\section{Device Drivers DMA Management}
\label{driver-api/infrastructure:device-drivers-dma-management}\index{dma\_alloc\_from\_dev\_coherent (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.dma_alloc_from_dev_coherent}\pysiglinewithargsret{int \bfcode{dma\_alloc\_from\_dev\_coherent}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, ssize\_t\emph{ size}, dma\_addr\_t *\emph{ dma\_handle}, void **\emph{ ret}}{}
allocate memory from device coherent pool

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device from which we allocate memory

\item[{\code{ssize\_t size}}] \leavevmode
size of requested memory area

\item[{\code{dma\_addr\_t * dma\_handle}}] \leavevmode
This will be filled with the correct dma handle

\item[{\code{void ** ret}}] \leavevmode
This pointer will be filled with the virtual address
to allocated area.

\end{description}

\textbf{Description}

This function should be only called from per-arch \code{dma\_alloc\_coherent()}
to support allocation from per-device coherent memory pools.

Returns 0 if dma\_alloc\_coherent should continue with allocating from
generic memory areas, or !0 if dma\_alloc\_coherent should return \textbf{ret}.
\index{dma\_release\_from\_dev\_coherent (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.dma_release_from_dev_coherent}\pysiglinewithargsret{int \bfcode{dma\_release\_from\_dev\_coherent}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, int\emph{ order}, void *\emph{ vaddr}}{}
free memory to device coherent memory pool

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device from which the memory was allocated

\item[{\code{int order}}] \leavevmode
the order of pages allocated

\item[{\code{void * vaddr}}] \leavevmode
virtual address of allocated pages

\end{description}

\textbf{Description}

This checks whether the memory was allocated from the per-device
coherent memory pool and if so, releases that memory.

Returns 1 if we correctly released the memory, or 0 if the caller should
proceed with releasing memory from generic pools.
\index{dma\_mmap\_from\_dev\_coherent (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.dma_mmap_from_dev_coherent}\pysiglinewithargsret{int \bfcode{dma\_mmap\_from\_dev\_coherent}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct vm\_area\_struct *\emph{ vma}, void *\emph{ vaddr}, size\_t\emph{ size}, int *\emph{ ret}}{}
mmap memory from the device coherent pool

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device from which the memory was allocated

\item[{\code{struct vm\_area\_struct * vma}}] \leavevmode
vm\_area for the userspace memory

\item[{\code{void * vaddr}}] \leavevmode
cpu address returned by dma\_alloc\_from\_dev\_coherent

\item[{\code{size\_t size}}] \leavevmode
size of the memory buffer allocated

\item[{\code{int * ret}}] \leavevmode
result from \code{remap\_pfn\_range()}

\end{description}

\textbf{Description}

This checks whether the memory was allocated from the per-device
coherent memory pool and if so, maps that memory to the provided vma.

Returns 1 if we correctly mapped the memory, or 0 if the caller should
proceed with mapping memory from generic pools.
\index{dmam\_alloc\_coherent (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.dmam_alloc_coherent}\pysiglinewithargsret{void * \bfcode{dmam\_alloc\_coherent}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, size\_t\emph{ size}, dma\_addr\_t *\emph{ dma\_handle}, gfp\_t\emph{ gfp}}{}
Managed \code{dma\_alloc\_coherent()}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to allocate coherent memory for

\item[{\code{size\_t size}}] \leavevmode
Size of allocation

\item[{\code{dma\_addr\_t * dma\_handle}}] \leavevmode
Out argument for allocated DMA handle

\item[{\code{gfp\_t gfp}}] \leavevmode
Allocation flags

\end{description}

\textbf{Description}

Managed \code{dma\_alloc\_coherent()}.  Memory allocated using this function
will be automatically released on driver detach.

\textbf{Return}

Pointer to allocated memory on success, NULL on failure.
\index{dmam\_free\_coherent (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.dmam_free_coherent}\pysiglinewithargsret{void \bfcode{dmam\_free\_coherent}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, size\_t\emph{ size}, void *\emph{ vaddr}, dma\_addr\_t\emph{ dma\_handle}}{}
Managed \code{dma\_free\_coherent()}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to free coherent memory for

\item[{\code{size\_t size}}] \leavevmode
Size of allocation

\item[{\code{void * vaddr}}] \leavevmode
Virtual address of the memory to free

\item[{\code{dma\_addr\_t dma\_handle}}] \leavevmode
DMA handle of the memory to free

\end{description}

\textbf{Description}

Managed \code{dma\_free\_coherent()}.
\index{dmam\_alloc\_attrs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.dmam_alloc_attrs}\pysiglinewithargsret{void * \bfcode{dmam\_alloc\_attrs}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, size\_t\emph{ size}, dma\_addr\_t *\emph{ dma\_handle}, gfp\_t\emph{ gfp}, unsigned long\emph{ attrs}}{}
Managed \code{dma\_alloc\_attrs()}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to allocate non\_coherent memory for

\item[{\code{size\_t size}}] \leavevmode
Size of allocation

\item[{\code{dma\_addr\_t * dma\_handle}}] \leavevmode
Out argument for allocated DMA handle

\item[{\code{gfp\_t gfp}}] \leavevmode
Allocation flags

\item[{\code{unsigned long attrs}}] \leavevmode
Flags in the DMA\_ATTR\_* namespace.

\end{description}

\textbf{Description}

Managed \code{dma\_alloc\_attrs()}.  Memory allocated using this function will be
automatically released on driver detach.

\textbf{Return}

Pointer to allocated memory on success, NULL on failure.
\index{dmam\_declare\_coherent\_memory (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.dmam_declare_coherent_memory}\pysiglinewithargsret{int \bfcode{dmam\_declare\_coherent\_memory}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, phys\_addr\_t\emph{ phys\_addr}, dma\_addr\_t\emph{ device\_addr}, size\_t\emph{ size}, int\emph{ flags}}{}
Managed \code{dma\_declare\_coherent\_memory()}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to declare coherent memory for

\item[{\code{phys\_addr\_t phys\_addr}}] \leavevmode
Physical address of coherent memory to be declared

\item[{\code{dma\_addr\_t device\_addr}}] \leavevmode
Device address of coherent memory to be declared

\item[{\code{size\_t size}}] \leavevmode
Size of coherent memory to be declared

\item[{\code{int flags}}] \leavevmode
Flags

\end{description}

\textbf{Description}

Managed \code{dma\_declare\_coherent\_memory()}.

\textbf{Return}

0 on success, -errno on failure.
\index{dmam\_release\_declared\_memory (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.dmam_release_declared_memory}\pysiglinewithargsret{void \bfcode{dmam\_release\_declared\_memory}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
Managed \code{dma\_release\_declared\_memory()}.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to release declared coherent memory for

\end{description}

\textbf{Description}

Managed {\hyperref[driver\string-api/infrastructure:c.dmam_release_declared_memory]{\emph{\code{dmam\_release\_declared\_memory()}}}}.


\section{Device drivers PnP support}
\label{driver-api/infrastructure:device-drivers-pnp-support}\index{pnp\_register\_protocol (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.pnp_register_protocol}\pysiglinewithargsret{int \bfcode{pnp\_register\_protocol}}{struct pnp\_protocol *\emph{ protocol}}{}
adds a pnp protocol to the pnp layer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pnp\_protocol * protocol}}] \leavevmode
pointer to the corresponding pnp\_protocol structure

\end{description}

\textbf{Description}
\begin{quote}

Ex protocols: ISAPNP, PNPBIOS, etc
\end{quote}
\index{pnp\_unregister\_protocol (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.pnp_unregister_protocol}\pysiglinewithargsret{void \bfcode{pnp\_unregister\_protocol}}{struct pnp\_protocol *\emph{ protocol}}{}
removes a pnp protocol from the pnp layer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pnp\_protocol * protocol}}] \leavevmode
pointer to the corresponding pnp\_protocol structure

\end{description}
\index{pnp\_request\_card\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.pnp_request_card_device}\pysiglinewithargsret{struct pnp\_dev * \bfcode{pnp\_request\_card\_device}}{struct pnp\_card\_link *\emph{ clink}, const char *\emph{ id}, struct pnp\_dev *\emph{ from}}{}
Searches for a PnP device under the specified card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pnp\_card\_link * clink}}] \leavevmode
pointer to the card link, cannot be NULL

\item[{\code{const char * id}}] \leavevmode
pointer to a PnP ID structure that explains the rules for finding the device

\item[{\code{struct pnp\_dev * from}}] \leavevmode
Starting place to search from. If NULL it will start from the beginning.

\end{description}
\index{pnp\_release\_card\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.pnp_release_card_device}\pysiglinewithargsret{void \bfcode{pnp\_release\_card\_device}}{struct pnp\_dev *\emph{ dev}}{}
call this when the driver no longer needs the device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pnp\_dev * dev}}] \leavevmode
pointer to the PnP device structure

\end{description}
\index{pnp\_register\_card\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.pnp_register_card_driver}\pysiglinewithargsret{int \bfcode{pnp\_register\_card\_driver}}{struct pnp\_card\_driver *\emph{ drv}}{}
registers a PnP card driver with the PnP Layer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pnp\_card\_driver * drv}}] \leavevmode
pointer to the driver to register

\end{description}
\index{pnp\_unregister\_card\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.pnp_unregister_card_driver}\pysiglinewithargsret{void \bfcode{pnp\_unregister\_card\_driver}}{struct pnp\_card\_driver *\emph{ drv}}{}
unregisters a PnP card driver from the PnP Layer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pnp\_card\_driver * drv}}] \leavevmode
pointer to the driver to unregister

\end{description}
\index{pnp\_add\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.pnp_add_id}\pysiglinewithargsret{struct pnp\_id * \bfcode{pnp\_add\_id}}{struct pnp\_dev *\emph{ dev}, const char *\emph{ id}}{}
adds an EISA id to the specified device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pnp\_dev * dev}}] \leavevmode
pointer to the desired device

\item[{\code{const char * id}}] \leavevmode
pointer to an EISA id string

\end{description}
\index{pnp\_start\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.pnp_start_dev}\pysiglinewithargsret{int \bfcode{pnp\_start\_dev}}{struct pnp\_dev *\emph{ dev}}{}
low-level start of the PnP device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pnp\_dev * dev}}] \leavevmode
pointer to the desired device

\end{description}

\textbf{Description}

assumes that resources have already been allocated
\index{pnp\_stop\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.pnp_stop_dev}\pysiglinewithargsret{int \bfcode{pnp\_stop\_dev}}{struct pnp\_dev *\emph{ dev}}{}
low-level disable of the PnP device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pnp\_dev * dev}}] \leavevmode
pointer to the desired device

\end{description}

\textbf{Description}

does not free resources
\index{pnp\_activate\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.pnp_activate_dev}\pysiglinewithargsret{int \bfcode{pnp\_activate\_dev}}{struct pnp\_dev *\emph{ dev}}{}
activates a PnP device for use

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pnp\_dev * dev}}] \leavevmode
pointer to the desired device

\end{description}

\textbf{Description}

does not validate or set resources so be careful.
\index{pnp\_disable\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.pnp_disable_dev}\pysiglinewithargsret{int \bfcode{pnp\_disable\_dev}}{struct pnp\_dev *\emph{ dev}}{}
disables device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pnp\_dev * dev}}] \leavevmode
pointer to the desired device

\end{description}

\textbf{Description}

inform the correct pnp protocol so that resources can be used by other devices
\index{pnp\_is\_active (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.pnp_is_active}\pysiglinewithargsret{int \bfcode{pnp\_is\_active}}{struct pnp\_dev *\emph{ dev}}{}
Determines if a device is active based on its current resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pnp\_dev * dev}}] \leavevmode
pointer to the desired PnP device

\end{description}


\section{Userspace IO devices}
\label{driver-api/infrastructure:userspace-io-devices}\index{uio\_event\_notify (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.uio_event_notify}\pysiglinewithargsret{void \bfcode{uio\_event\_notify}}{struct {\hyperref[driver\string-api/infrastructure:c.uio_info]{\emph{uio\_info}}} *\emph{ info}}{}
trigger an interrupt event

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct uio\_info * info}}] \leavevmode
UIO device capabilities

\end{description}
\index{\_\_uio\_register\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.__uio_register_device}\pysiglinewithargsret{int \bfcode{\_\_uio\_register\_device}}{struct module *\emph{ owner}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ parent}, struct {\hyperref[driver\string-api/infrastructure:c.uio_info]{\emph{uio\_info}}} *\emph{ info}}{}
register a new userspace IO device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct module * owner}}] \leavevmode
module that creates the new device

\item[{\code{struct device * parent}}] \leavevmode
parent device

\item[{\code{struct uio\_info * info}}] \leavevmode
UIO device capabilities

\end{description}

\textbf{Description}

returns zero on success or a negative error code.
\index{uio\_unregister\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.uio_unregister_device}\pysiglinewithargsret{void \bfcode{uio\_unregister\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.uio_info]{\emph{uio\_info}}} *\emph{ info}}{}
unregister a industrial IO device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct uio\_info * info}}] \leavevmode
UIO device capabilities

\end{description}
\index{uio\_mem (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.uio_mem}\pysigline{struct \bfcode{uio\_mem}}
description of a UIO memory region

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct uio\PYGZus{}mem \PYGZob{}
  const char              *name;
  phys\PYGZus{}addr\PYGZus{}t addr;
  unsigned long           offs;
  resource\PYGZus{}size\PYGZus{}t size;
  int memtype;
  void \PYGZus{}\PYGZus{}iomem            *internal\PYGZus{}addr;
  struct uio\PYGZus{}map          *map;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
name of the memory region for identification

\item[{\code{addr}}] \leavevmode
address of the device's memory rounded to page
size (phys\_addr is used since addr can be
logical, virtual, or physical \& phys\_addr\_t
should always be large enough to handle any of
the address types)

\item[{\code{offs}}] \leavevmode
offset of device memory within the page

\item[{\code{size}}] \leavevmode
size of IO (multiple of page size)

\item[{\code{memtype}}] \leavevmode
type of memory addr points to

\item[{\code{internal\_addr}}] \leavevmode
ioremap-ped version of addr, for driver internal use

\item[{\code{map}}] \leavevmode
for use by the UIO core only.

\end{description}
\index{uio\_port (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.uio_port}\pysigline{struct \bfcode{uio\_port}}
description of a UIO port region

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct uio\PYGZus{}port \PYGZob{}
  const char              *name;
  unsigned long           start;
  unsigned long           size;
  int porttype;
  struct uio\PYGZus{}portio       *portio;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
name of the port region for identification

\item[{\code{start}}] \leavevmode
start of port region

\item[{\code{size}}] \leavevmode
size of port region

\item[{\code{porttype}}] \leavevmode
type of port (see UIO\_PORT\_* below)

\item[{\code{portio}}] \leavevmode
for use by the UIO core only.

\end{description}
\index{uio\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/infrastructure:c.uio_info}\pysigline{struct \bfcode{uio\_info}}
UIO device capabilities

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct uio\PYGZus{}info \PYGZob{}
  struct uio\PYGZus{}device       *uio\PYGZus{}dev;
  const char              *name;
  const char              *version;
  struct uio\PYGZus{}mem          mem[MAX\PYGZus{}UIO\PYGZus{}MAPS];
  struct uio\PYGZus{}port         port[MAX\PYGZus{}UIO\PYGZus{}PORT\PYGZus{}REGIONS];
  long irq;
  unsigned long           irq\PYGZus{}flags;
  void *priv;
  irqreturn\PYGZus{}t (*handler)(int irq, struct uio\PYGZus{}info *dev\PYGZus{}info);
  int (*mmap)(struct uio\PYGZus{}info *info, struct vm\PYGZus{}area\PYGZus{}struct *vma);
  int (*open)(struct uio\PYGZus{}info *info, struct inode *inode);
  int (*release)(struct uio\PYGZus{}info *info, struct inode *inode);
  int (*irqcontrol)(struct uio\PYGZus{}info *info, s32 irq\PYGZus{}on);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{uio\_dev}}] \leavevmode
the UIO device this info belongs to

\item[{\code{name}}] \leavevmode
device name

\item[{\code{version}}] \leavevmode
device driver version

\item[{\code{mem}}] \leavevmode
list of mappable memory regions, size==0 for end of list

\item[{\code{port}}] \leavevmode
list of port regions, size==0 for end of list

\item[{\code{irq}}] \leavevmode
interrupt number or UIO\_IRQ\_CUSTOM

\item[{\code{irq\_flags}}] \leavevmode
flags for \code{request\_irq()}

\item[{\code{priv}}] \leavevmode
optional private data

\item[{\code{handler}}] \leavevmode
the device's irq handler

\item[{\code{mmap}}] \leavevmode
mmap operation for this uio device

\item[{\code{open}}] \leavevmode
open operation for this uio device

\item[{\code{release}}] \leavevmode
release operation for this uio device

\item[{\code{irqcontrol}}] \leavevmode
disable/enable irqs when 0/1 is written to /dev/uioX

\end{description}


\chapter{Device Power Management}
\label{driver-api/pm/index:device-power-management}\label{driver-api/pm/index::doc}

\section{Device Power Management Basics}
\label{driver-api/pm/devices:device-power-management-basics}\label{driver-api/pm/devices::doc}
\begin{Verbatim}[commandchars=\\\{\}]
Copyright (c) 2010\PYGZhy{}2011 Rafael J. Wysocki \PYGZlt{}rjw@sisk.pl\PYGZgt{}, Novell Inc.
Copyright (c) 2010 Alan Stern \PYGZlt{}stern@rowland.harvard.edu\PYGZgt{}
Copyright (c) 2016 Intel Corp., Rafael J. Wysocki \PYGZlt{}rafael.j.wysocki@intel.com\PYGZgt{}
\end{Verbatim}

Most of the code in Linux is device drivers, so most of the Linux power
management (PM) code is also driver-specific.  Most drivers will do very
little; others, especially for platforms with small batteries (like cell
phones), will do a lot.

This writeup gives an overview of how drivers interact with system-wide
power management goals, emphasizing the models and interfaces that are
shared by everything that hooks up to the driver model core.  Read it as
background for the domain-specific work you'd do with any specific driver.


\subsection{Two Models for Device Power Management}
\label{driver-api/pm/devices:two-models-for-device-power-management}
Drivers will use one or both of these models to put devices into low-power
states:
\begin{quote}

System Sleep model:
\begin{quote}

Drivers can enter low-power states as part of entering system-wide
low-power states like ``suspend'' (also known as ``suspend-to-RAM''), or
(mostly for systems with disks) ``hibernation'' (also known as
``suspend-to-disk'').

This is something that device, bus, and class drivers collaborate on
by implementing various role-specific suspend and resume methods to
cleanly power down hardware and software subsystems, then reactivate
them without loss of data.

Some drivers can manage hardware wakeup events, which make the system
leave the low-power state.  This feature may be enabled or disabled
using the relevant \code{/sys/devices/.../power/wakeup} file (for
Ethernet drivers the ioctl interface used by ethtool may also be used
for this purpose); enabling it may cost some power usage, but let the
whole system enter low-power states more often.
\end{quote}

Runtime Power Management model:
\begin{quote}

Devices may also be put into low-power states while the system is
running, independently of other power management activity in principle.
However, devices are not generally independent of each other (for
example, a parent device cannot be suspended unless all of its child
devices have been suspended).  Moreover, depending on the bus type the
device is on, it may be necessary to carry out some bus-specific
operations on the device for this purpose.  Devices put into low power
states at run time may require special handling during system-wide power
transitions (suspend or hibernation).

For these reasons not only the device driver itself, but also the
appropriate subsystem (bus type, device type or device class) driver and
the PM core are involved in runtime power management.  As in the system
sleep power management case, they need to collaborate by implementing
various role-specific suspend and resume methods, so that the hardware
is cleanly powered down and reactivated without data or service loss.
\end{quote}
\end{quote}

There's not a lot to be said about those low-power states except that they are
very system-specific, and often device-specific.  Also, that if enough devices
have been put into low-power states (at runtime), the effect may be very similar
to entering some system-wide low-power state (system sleep) ... and that
synergies exist, so that several drivers using runtime PM might put the system
into a state where even deeper power saving options are available.

Most suspended devices will have quiesced all I/O: no more DMA or IRQs (except
for wakeup events), no more data read or written, and requests from upstream
drivers are no longer accepted.  A given bus or platform may have different
requirements though.

Examples of hardware wakeup events include an alarm from a real time clock,
network wake-on-LAN packets, keyboard or mouse activity, and media insertion
or removal (for PCMCIA, MMC/SD, USB, and so on).


\subsection{Interfaces for Entering System Sleep States}
\label{driver-api/pm/devices:interfaces-for-entering-system-sleep-states}
There are programming interfaces provided for subsystems (bus type, device type,
device class) and device drivers to allow them to participate in the power
management of devices they are concerned with.  These interfaces cover both
system sleep and runtime power management.


\subsubsection{Device Power Management Operations}
\label{driver-api/pm/devices:device-power-management-operations}
Device power management operations, at the subsystem level as well as at the
device driver level, are implemented by defining and populating objects of type
{\hyperref[driver\string-api/pm/types:c.dev_pm_ops]{\emph{\code{struct dev\_pm\_ops}}}} defined in \code{include/linux/pm.h}.  The roles of the
methods included in it will be explained in what follows.  For now, it should be
sufficient to remember that the last three methods are specific to runtime power
management while the remaining ones are used during system-wide power
transitions.

There also is a deprecated ``old'' or ``legacy'' interface for power management
operations available at least for some subsystems.  This approach does not use
{\hyperref[driver\string-api/pm/types:c.dev_pm_ops]{\emph{\code{struct dev\_pm\_ops}}}} objects and it is suitable only for implementing system
sleep power management methods in a limited way.  Therefore it is not described
in this document, so please refer directly to the source code for more
information about it.


\subsubsection{Subsystem-Level Methods}
\label{driver-api/pm/devices:subsystem-level-methods}
The core methods to suspend and resume devices reside in
{\hyperref[driver\string-api/pm/types:c.dev_pm_ops]{\emph{\code{struct dev\_pm\_ops}}}} pointed to by the \code{ops} member of
{\hyperref[driver\string-api/pm/types:c.dev_pm_domain]{\emph{\code{struct dev\_pm\_domain}}}}, or by the \code{pm} member of {\hyperref[driver\string-api/infrastructure:c.bus_type]{\emph{\code{struct bus\_type}}}},
\code{struct device\_type} and {\hyperref[driver\string-api/infrastructure:c.class]{\emph{\code{struct class}}}}.  They are mostly of interest to the
people writing infrastructure for platforms and buses, like PCI or USB, or
device type and device class drivers.  They also are relevant to the writers of
device drivers whose subsystems (PM domains, device types, device classes and
bus types) don't provide all power management methods.

Bus drivers implement these methods as appropriate for the hardware and the
drivers using it; PCI works differently from USB, and so on.  Not many people
write subsystem-level drivers; most driver code is a ``device driver'' that builds
on top of bus-specific framework code.

For more information on these driver calls, see the description later;
they are called in phases for every device, respecting the parent-child
sequencing in the driver model tree.


\subsubsection{\texttt{/sys/devices/.../power/wakeup} files}
\label{driver-api/pm/devices:sys-devices-power-wakeup-files}
All device objects in the driver model contain fields that control the handling
of system wakeup events (hardware signals that can force the system out of a
sleep state).  These fields are initialized by bus or device driver code using
\code{device\_set\_wakeup\_capable()} and \code{device\_set\_wakeup\_enable()},
defined in \code{include/linux/pm\_wakeup.h}.

The \code{power.can\_wakeup} flag just records whether the device (and its
driver) can physically support wakeup events.  The
\code{device\_set\_wakeup\_capable()} routine affects this flag.  The
\code{power.wakeup} field is a pointer to an object of type
\code{struct wakeup\_source} used for controlling whether or not the device should use
its system wakeup mechanism and for notifying the PM core of system wakeup
events signaled by the device.  This object is only present for wakeup-capable
devices (i.e. devices whose \code{can\_wakeup} flags are set) and is created
(or removed) by \code{device\_set\_wakeup\_capable()}.

Whether or not a device is capable of issuing wakeup events is a hardware
matter, and the kernel is responsible for keeping track of it.  By contrast,
whether or not a wakeup-capable device should issue wakeup events is a policy
decision, and it is managed by user space through a sysfs attribute: the
\code{power/wakeup} file.  User space can write the ``enabled'' or ``disabled''
strings to it to indicate whether or not, respectively, the device is supposed
to signal system wakeup.  This file is only present if the
\code{power.wakeup} object exists for the given device and is created (or
removed) along with that object, by \code{device\_set\_wakeup\_capable()}.
Reads from the file will return the corresponding string.

The initial value in the \code{power/wakeup} file is ``disabled'' for the
majority of devices; the major exceptions are power buttons, keyboards, and
Ethernet adapters whose WoL (wake-on-LAN) feature has been set up with ethtool.
It should also default to ``enabled'' for devices that don't generate wakeup
requests on their own but merely forward wakeup requests from one bus to another
(like PCI Express ports).

The \code{device\_may\_wakeup()} routine returns true only if the
\code{power.wakeup} object exists and the corresponding \code{power/wakeup}
file contains the ``enabled'' string.  This information is used by subsystems,
like the PCI bus type code, to see whether or not to enable the devices' wakeup
mechanisms.  If device wakeup mechanisms are enabled or disabled directly by
drivers, they also should use \code{device\_may\_wakeup()} to decide what to do
during a system sleep transition.  Device drivers, however, are not expected to
call \code{device\_set\_wakeup\_enable()} directly in any case.

It ought to be noted that system wakeup is conceptually different from ``remote
wakeup'' used by runtime power management, although it may be supported by the
same physical mechanism.  Remote wakeup is a feature allowing devices in
low-power states to trigger specific interrupts to signal conditions in which
they should be put into the full-power state.  Those interrupts may or may not
be used to signal system wakeup events, depending on the hardware design.  On
some systems it is impossible to trigger them from system sleep states.  In any
case, remote wakeup should always be enabled for runtime power management for
all devices and drivers that support it.


\subsubsection{\texttt{/sys/devices/.../power/control} files}
\label{driver-api/pm/devices:sys-devices-power-control-files}
Each device in the driver model has a flag to control whether it is subject to
runtime power management.  This flag, \code{runtime\_auto}, is initialized
by the bus type (or generally subsystem) code using \code{pm\_runtime\_allow()}
or \code{pm\_runtime\_forbid()}; the default is to allow runtime power
management.

The setting can be adjusted by user space by writing either ``on'' or ``auto'' to
the device's \code{power/control} sysfs file.  Writing ``auto'' calls
\code{pm\_runtime\_allow()}, setting the flag and allowing the device to be
runtime power-managed by its driver.  Writing ``on'' calls
\code{pm\_runtime\_forbid()}, clearing the flag, returning the device to full
power if it was in a low-power state, and preventing the
device from being runtime power-managed.  User space can check the current value
of the \code{runtime\_auto} flag by reading that file.

The device's \code{runtime\_auto} flag has no effect on the handling of
system-wide power transitions.  In particular, the device can (and in the
majority of cases should and will) be put into a low-power state during a
system-wide transition to a sleep state even though its \code{runtime\_auto}
flag is clear.

For more information about the runtime power management framework, refer to
\code{Documentation/power/runtime\_pm.txt}.


\subsection{Calling Drivers to Enter and Leave System Sleep States}
\label{driver-api/pm/devices:calling-drivers-to-enter-and-leave-system-sleep-states}
When the system goes into a sleep state, each device's driver is asked to
suspend the device by putting it into a state compatible with the target
system state.  That's usually some version of ``off'', but the details are
system-specific.  Also, wakeup-enabled devices will usually stay partly
functional in order to wake the system.

When the system leaves that low-power state, the device's driver is asked to
resume it by returning it to full power.  The suspend and resume operations
always go together, and both are multi-phase operations.

For simple drivers, suspend might quiesce the device using class code
and then turn its hardware as ``off'' as possible during suspend\_noirq.  The
matching resume calls would then completely reinitialize the hardware
before reactivating its class I/O queues.

More power-aware drivers might prepare the devices for triggering system wakeup
events.


\subsubsection{Call Sequence Guarantees}
\label{driver-api/pm/devices:call-sequence-guarantees}
To ensure that bridges and similar links needing to talk to a device are
available when the device is suspended or resumed, the device hierarchy is
walked in a bottom-up order to suspend devices.  A top-down order is
used to resume those devices.

The ordering of the device hierarchy is defined by the order in which devices
get registered:  a child can never be registered, probed or resumed before
its parent; and can't be removed or suspended after that parent.

The policy is that the device hierarchy should match hardware bus topology.
{[}Or at least the control bus, for devices which use multiple busses.{]}
In particular, this means that a device registration may fail if the parent of
the device is suspending (i.e. has been chosen by the PM core as the next
device to suspend) or has already suspended, as well as after all of the other
devices have been suspended.  Device drivers must be prepared to cope with such
situations.


\subsubsection{System Power Management Phases}
\label{driver-api/pm/devices:system-power-management-phases}
Suspending or resuming the system is done in several phases.  Different phases
are used for suspend-to-idle, shallow (standby), and deep (``suspend-to-RAM'')
sleep states and the hibernation state (``suspend-to-disk'').  Each phase involves
executing callbacks for every device before the next phase begins.  Not all
buses or classes support all these callbacks and not all drivers use all the
callbacks.  The various phases always run after tasks have been frozen and
before they are unfrozen.  Furthermore, the \code{*\_noirq} phases run at a time
when IRQ handlers have been disabled (except for those marked with the
IRQF\_NO\_SUSPEND flag).

All phases use PM domain, bus, type, class or driver callbacks (that is, methods
defined in \code{dev-\textgreater{}pm\_domain-\textgreater{}ops}, \code{dev-\textgreater{}bus-\textgreater{}pm}, \code{dev-\textgreater{}type-\textgreater{}pm},
\code{dev-\textgreater{}class-\textgreater{}pm} or \code{dev-\textgreater{}driver-\textgreater{}pm}).  These callbacks are regarded by the
PM core as mutually exclusive.  Moreover, PM domain callbacks always take
precedence over all of the other callbacks and, for example, type callbacks take
precedence over bus, class and driver callbacks.  To be precise, the following
rules are used to determine which callback to execute in the given phase:
\begin{enumerate}
\item {} 
If \code{dev-\textgreater{}pm\_domain} is present, the PM core will choose the callback
provided by \code{dev-\textgreater{}pm\_domain-\textgreater{}ops} for execution.

\item {} 
Otherwise, if both \code{dev-\textgreater{}type} and \code{dev-\textgreater{}type-\textgreater{}pm} are present, the
callback provided by \code{dev-\textgreater{}type-\textgreater{}pm} will be chosen for execution.

\item {} 
Otherwise, if both \code{dev-\textgreater{}class} and \code{dev-\textgreater{}class-\textgreater{}pm} are present,
the callback provided by \code{dev-\textgreater{}class-\textgreater{}pm} will be chosen for
execution.

\item {} 
Otherwise, if both \code{dev-\textgreater{}bus} and \code{dev-\textgreater{}bus-\textgreater{}pm} are present, the
callback provided by \code{dev-\textgreater{}bus-\textgreater{}pm} will be chosen for execution.

\end{enumerate}

This allows PM domains and device types to override callbacks provided by bus
types or device classes if necessary.

The PM domain, type, class and bus callbacks may in turn invoke device- or
driver-specific methods stored in \code{dev-\textgreater{}driver-\textgreater{}pm}, but they don't have to do
that.

If the subsystem callback chosen for execution is not present, the PM core will
execute the corresponding method from the \code{dev-\textgreater{}driver-\textgreater{}pm} set instead if
there is one.


\subsubsection{Entering System Suspend}
\label{driver-api/pm/devices:entering-system-suspend}
When the system goes into the freeze, standby or memory sleep state,
the phases are: \code{prepare}, \code{suspend}, \code{suspend\_late}, \code{suspend\_noirq}.
\begin{enumerate}
\item {} 
The \code{prepare} phase is meant to prevent races by preventing new
devices from being registered; the PM core would never know that all the
children of a device had been suspended if new children could be
registered at will.  {[}By contrast, from the PM core's perspective,
devices may be unregistered at any time.{]}  Unlike the other
suspend-related phases, during the \code{prepare} phase the device
hierarchy is traversed top-down.

After the \code{-\textgreater{}prepare} callback method returns, no new children may be
registered below the device.  The method may also prepare the device or
driver in some way for the upcoming system power transition, but it
should not put the device into a low-power state.  Moreover, if the
device supports runtime power management, the \code{-\textgreater{}prepare} callback
method must not update its state in case it is necessary to resume it
from runtime suspend later on.

For devices supporting runtime power management, the return value of the
prepare callback can be used to indicate to the PM core that it may
safely leave the device in runtime suspend (if runtime-suspended
already), provided that all of the device's descendants are also left in
runtime suspend.  Namely, if the prepare callback returns a positive
number and that happens for all of the descendants of the device too,
and all of them (including the device itself) are runtime-suspended, the
PM core will skip the \code{suspend}, \code{suspend\_late} and
\code{suspend\_noirq} phases as well as all of the corresponding phases of
the subsequent device resume for all of these devices.  In that case,
the \code{-\textgreater{}complete} callback will be invoked directly after the
\code{-\textgreater{}prepare} callback and is entirely responsible for putting the
device into a consistent state as appropriate.

Note that this direct-complete procedure applies even if the device is
disabled for runtime PM; only the runtime-PM status matters.  It follows
that if a device has system-sleep callbacks but does not support runtime
PM, then its prepare callback must never return a positive value.  This
is because all such devices are initially set to runtime-suspended with
runtime PM disabled.

This feature also can be controlled by device drivers by using the
\code{DPM\_FLAG\_NEVER\_SKIP} and \code{DPM\_FLAG\_SMART\_PREPARE} driver power
management flags.  {[}Typically, they are set at the time the driver is
probed against the device in question by passing them to the
\code{dev\_pm\_set\_driver\_flags()} helper function.{]}  If the first of
these flags is set, the PM core will not apply the direct-complete
procedure described above to the given device and, consequenty, to any
of its ancestors.  The second flag, when set, informs the middle layer
code (bus types, device types, PM domains, classes) that it should take
the return value of the \code{-\textgreater{}prepare} callback provided by the driver
into account and it may only return a positive value from its own
\code{-\textgreater{}prepare} callback if the driver's one also has returned a positive
value.

\item {} 
The \code{-\textgreater{}suspend} methods should quiesce the device to stop it from
performing I/O.  They also may save the device registers and put it into
the appropriate low-power state, depending on the bus type the device is
on, and they may enable wakeup events.

However, for devices supporting runtime power management, the
\code{-\textgreater{}suspend} methods provided by subsystems (bus types and PM domains
in particular) must follow an additional rule regarding what can be done
to the devices before their drivers' \code{-\textgreater{}suspend} methods are called.
Namely, they can only resume the devices from runtime suspend by
calling \code{pm\_runtime\_resume()} for them, if that is necessary, and
they must not update the state of the devices in any other way at that
time (in case the drivers need to resume the devices from runtime
suspend in their \code{-\textgreater{}suspend} methods).

\item {} 
For a number of devices it is convenient to split suspend into the
``quiesce device'' and ``save device state'' phases, in which cases
\code{suspend\_late} is meant to do the latter.  It is always executed after
runtime power management has been disabled for the device in question.

\item {} 
The \code{suspend\_noirq} phase occurs after IRQ handlers have been disabled,
which means that the driver's interrupt handler will not be called while
the callback method is running.  The \code{-\textgreater{}suspend\_noirq} methods should
save the values of the device's registers that weren't saved previously
and finally put the device into the appropriate low-power state.

The majority of subsystems and device drivers need not implement this
callback.  However, bus types allowing devices to share interrupt
vectors, like PCI, generally need it; otherwise a driver might encounter
an error during the suspend phase by fielding a shared interrupt
generated by some other device after its own device had been set to low
power.

\end{enumerate}

At the end of these phases, drivers should have stopped all I/O transactions
(DMA, IRQs), saved enough state that they can re-initialize or restore previous
state (as needed by the hardware), and placed the device into a low-power state.
On many platforms they will gate off one or more clock sources; sometimes they
will also switch off power supplies or reduce voltages.  {[}Drivers supporting
runtime PM may already have performed some or all of these steps.{]}

If \code{device\_may\_wakeup(dev)()} returns \code{true}, the device should be
prepared for generating hardware wakeup signals to trigger a system wakeup event
when the system is in the sleep state.  For example, \code{enable\_irq\_wake()}
might identify GPIO signals hooked up to a switch or other external hardware,
and {\hyperref[driver\string-api/pci:c.pci_enable_wake]{\emph{\code{pci\_enable\_wake()}}}} does something similar for the PCI PME signal.

If any of these callbacks returns an error, the system won't enter the desired
low-power state.  Instead, the PM core will unwind its actions by resuming all
the devices that were suspended.


\subsubsection{Leaving System Suspend}
\label{driver-api/pm/devices:leaving-system-suspend}
When resuming from freeze, standby or memory sleep, the phases are:
\code{resume\_noirq}, \code{resume\_early}, \code{resume}, \code{complete}.
\begin{enumerate}
\item {} 
The \code{-\textgreater{}resume\_noirq} callback methods should perform any actions
needed before the driver's interrupt handlers are invoked.  This
generally means undoing the actions of the \code{suspend\_noirq} phase.  If
the bus type permits devices to share interrupt vectors, like PCI, the
method should bring the device and its driver into a state in which the
driver can recognize if the device is the source of incoming interrupts,
if any, and handle them correctly.

For example, the PCI bus type's \code{-\textgreater{}pm.resume\_noirq()} puts the device
into the full-power state (D0 in the PCI terminology) and restores the
standard configuration registers of the device.  Then it calls the
device driver's \code{-\textgreater{}pm.resume\_noirq()} method to perform device-specific
actions.

\item {} 
The \code{-\textgreater{}resume\_early} methods should prepare devices for the execution
of the resume methods.  This generally involves undoing the actions of
the preceding \code{suspend\_late} phase.

\item {} 
The \code{-\textgreater{}resume} methods should bring the device back to its operating
state, so that it can perform normal I/O.  This generally involves
undoing the actions of the \code{suspend} phase.

\item {} 
The \code{complete} phase should undo the actions of the \code{prepare} phase.
For this reason, unlike the other resume-related phases, during the
\code{complete} phase the device hierarchy is traversed bottom-up.

Note, however, that new children may be registered below the device as
soon as the \code{-\textgreater{}resume} callbacks occur; it's not necessary to wait
until the \code{complete} phase with that.

Moreover, if the preceding \code{-\textgreater{}prepare} callback returned a positive
number, the device may have been left in runtime suspend throughout the
whole system suspend and resume (the \code{suspend}, \code{suspend\_late},
\code{suspend\_noirq} phases of system suspend and the \code{resume\_noirq},
\code{resume\_early}, \code{resume} phases of system resume may have been
skipped for it).  In that case, the \code{-\textgreater{}complete} callback is entirely
responsible for putting the device into a consistent state after system
suspend if necessary.  {[}For example, it may need to queue up a runtime
resume request for the device for this purpose.{]}  To check if that is
the case, the \code{-\textgreater{}complete} callback can consult the device's
\code{power.direct\_complete} flag.  Namely, if that flag is set when the
\code{-\textgreater{}complete} callback is being run, it has been called directly after
the preceding \code{-\textgreater{}prepare} and special actions may be required
to make the device work correctly afterward.

\end{enumerate}

At the end of these phases, drivers should be as functional as they were before
suspending: I/O can be performed using DMA and IRQs, and the relevant clocks are
gated on.

However, the details here may again be platform-specific.  For example,
some systems support multiple ``run'' states, and the mode in effect at
the end of resume might not be the one which preceded suspension.
That means availability of certain clocks or power supplies changed,
which could easily affect how a driver works.

Drivers need to be able to handle hardware which has been reset since all of the
suspend methods were called, for example by complete reinitialization.
This may be the hardest part, and the one most protected by NDA'd documents
and chip errata.  It's simplest if the hardware state hasn't changed since
the suspend was carried out, but that can only be guaranteed if the target
system sleep entered was suspend-to-idle.  For the other system sleep states
that may not be the case (and usually isn't for ACPI-defined system sleep
states, like S3).

Drivers must also be prepared to notice that the device has been removed
while the system was powered down, whenever that's physically possible.
PCMCIA, MMC, USB, Firewire, SCSI, and even IDE are common examples of busses
where common Linux platforms will see such removal.  Details of how drivers
will notice and handle such removals are currently bus-specific, and often
involve a separate thread.

These callbacks may return an error value, but the PM core will ignore such
errors since there's nothing it can do about them other than printing them in
the system log.


\subsubsection{Entering Hibernation}
\label{driver-api/pm/devices:entering-hibernation}
Hibernating the system is more complicated than putting it into sleep states,
because it involves creating and saving a system image.  Therefore there are
more phases for hibernation, with a different set of callbacks.  These phases
always run after tasks have been frozen and enough memory has been freed.

The general procedure for hibernation is to quiesce all devices (``freeze''),
create an image of the system memory while everything is stable, reactivate all
devices (``thaw''), write the image to permanent storage, and finally shut down
the system (``power off'').  The phases used to accomplish this are: \code{prepare},
\code{freeze}, \code{freeze\_late}, \code{freeze\_noirq}, \code{thaw\_noirq}, \code{thaw\_early},
\code{thaw}, \code{complete}, \code{prepare}, \code{poweroff}, \code{poweroff\_late},
\code{poweroff\_noirq}.
\begin{enumerate}
\item {} 
The \code{prepare} phase is discussed in the ``Entering System Suspend''
section above.

\item {} 
The \code{-\textgreater{}freeze} methods should quiesce the device so that it doesn't
generate IRQs or DMA, and they may need to save the values of device
registers.  However the device does not have to be put in a low-power
state, and to save time it's best not to do so.  Also, the device should
not be prepared to generate wakeup events.

\item {} 
The \code{freeze\_late} phase is analogous to the \code{suspend\_late} phase
described earlier, except that the device should not be put into a
low-power state and should not be allowed to generate wakeup events.

\item {} 
The \code{freeze\_noirq} phase is analogous to the \code{suspend\_noirq} phase
discussed earlier, except again that the device should not be put into
a low-power state and should not be allowed to generate wakeup events.

\end{enumerate}

At this point the system image is created.  All devices should be inactive and
the contents of memory should remain undisturbed while this happens, so that the
image forms an atomic snapshot of the system state.
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
The \code{thaw\_noirq} phase is analogous to the \code{resume\_noirq} phase
discussed earlier.  The main difference is that its methods can assume
the device is in the same state as at the end of the \code{freeze\_noirq}
phase.

\item {} 
The \code{thaw\_early} phase is analogous to the \code{resume\_early} phase
described above.  Its methods should undo the actions of the preceding
\code{freeze\_late}, if necessary.

\item {} 
The \code{thaw} phase is analogous to the \code{resume} phase discussed
earlier.  Its methods should bring the device back to an operating
state, so that it can be used for saving the image if necessary.

\item {} 
The \code{complete} phase is discussed in the ``Leaving System Suspend''
section above.

\end{enumerate}

At this point the system image is saved, and the devices then need to be
prepared for the upcoming system shutdown.  This is much like suspending them
before putting the system into the suspend-to-idle, shallow or deep sleep state,
and the phases are similar.
\begin{enumerate}
\setcounter{enumi}{8}
\item {} 
The \code{prepare} phase is discussed above.

\item {} 
The \code{poweroff} phase is analogous to the \code{suspend} phase.

\item {} 
The \code{poweroff\_late} phase is analogous to the \code{suspend\_late} phase.

\item {} 
The \code{poweroff\_noirq} phase is analogous to the \code{suspend\_noirq} phase.

\end{enumerate}

The \code{-\textgreater{}poweroff}, \code{-\textgreater{}poweroff\_late} and \code{-\textgreater{}poweroff\_noirq} callbacks
should do essentially the same things as the \code{-\textgreater{}suspend}, \code{-\textgreater{}suspend\_late}
and \code{-\textgreater{}suspend\_noirq} callbacks, respectively.  The only notable difference is
that they need not store the device register values, because the registers
should already have been stored during the \code{freeze}, \code{freeze\_late} or
\code{freeze\_noirq} phases.


\subsubsection{Leaving Hibernation}
\label{driver-api/pm/devices:leaving-hibernation}
Resuming from hibernation is, again, more complicated than resuming from a sleep
state in which the contents of main memory are preserved, because it requires
a system image to be loaded into memory and the pre-hibernation memory contents
to be restored before control can be passed back to the image kernel.

Although in principle the image might be loaded into memory and the
pre-hibernation memory contents restored by the boot loader, in practice this
can't be done because boot loaders aren't smart enough and there is no
established protocol for passing the necessary information.  So instead, the
boot loader loads a fresh instance of the kernel, called ``the restore kernel'',
into memory and passes control to it in the usual way.  Then the restore kernel
reads the system image, restores the pre-hibernation memory contents, and passes
control to the image kernel.  Thus two different kernel instances are involved
in resuming from hibernation.  In fact, the restore kernel may be completely
different from the image kernel: a different configuration and even a different
version.  This has important consequences for device drivers and their
subsystems.

To be able to load the system image into memory, the restore kernel needs to
include at least a subset of device drivers allowing it to access the storage
medium containing the image, although it doesn't need to include all of the
drivers present in the image kernel.  After the image has been loaded, the
devices managed by the boot kernel need to be prepared for passing control back
to the image kernel.  This is very similar to the initial steps involved in
creating a system image, and it is accomplished in the same way, using
\code{prepare}, \code{freeze}, and \code{freeze\_noirq} phases.  However, the devices
affected by these phases are only those having drivers in the restore kernel;
other devices will still be in whatever state the boot loader left them.

Should the restoration of the pre-hibernation memory contents fail, the restore
kernel would go through the ``thawing'' procedure described above, using the
\code{thaw\_noirq}, \code{thaw\_early}, \code{thaw}, and \code{complete} phases, and then
continue running normally.  This happens only rarely.  Most often the
pre-hibernation memory contents are restored successfully and control is passed
to the image kernel, which then becomes responsible for bringing the system back
to the working state.

To achieve this, the image kernel must restore the devices' pre-hibernation
functionality.  The operation is much like waking up from a sleep state (with
the memory contents preserved), although it involves different phases:
\code{restore\_noirq}, \code{restore\_early}, \code{restore}, \code{complete}.
\begin{enumerate}
\item {} 
The \code{restore\_noirq} phase is analogous to the \code{resume\_noirq} phase.

\item {} 
The \code{restore\_early} phase is analogous to the \code{resume\_early} phase.

\item {} 
The \code{restore} phase is analogous to the \code{resume} phase.

\item {} 
The \code{complete} phase is discussed above.

\end{enumerate}

The main difference from \code{resume{[}\_early\textbar{}\_noirq{]}} is that
\code{restore{[}\_early\textbar{}\_noirq{]}} must assume the device has been accessed and
reconfigured by the boot loader or the restore kernel.  Consequently, the state
of the device may be different from the state remembered from the \code{freeze},
\code{freeze\_late} and \code{freeze\_noirq} phases.  The device may even need to be
reset and completely re-initialized.  In many cases this difference doesn't
matter, so the \code{-\textgreater{}resume{[}\_early\textbar{}\_noirq{]}} and \code{-\textgreater{}restore{[}\_early\textbar{}\_norq{]}}
method pointers can be set to the same routines.  Nevertheless, different
callback pointers are used in case there is a situation where it actually does
matter.


\subsection{Power Management Notifiers}
\label{driver-api/pm/devices:power-management-notifiers}
There are some operations that cannot be carried out by the power management
callbacks discussed above, because the callbacks occur too late or too early.
To handle these cases, subsystems and device drivers may register power
management notifiers that are called before tasks are frozen and after they have
been thawed.  Generally speaking, the PM notifiers are suitable for performing
actions that either require user space to be available, or at least won't
interfere with user space.

For details refer to {\hyperref[driver\string-api/pm/notifiers::doc]{\emph{\emph{Suspend/Hibernation Notifiers}}}}.


\subsection{Device Low-Power (suspend) States}
\label{driver-api/pm/devices:device-low-power-suspend-states}
Device low-power states aren't standard.  One device might only handle
``on'' and ``off'', while another might support a dozen different versions of
``on'' (how many engines are active?), plus a state that gets back to ``on''
faster than from a full ``off''.

Some buses define rules about what different suspend states mean.  PCI
gives one example: after the suspend sequence completes, a non-legacy
PCI device may not perform DMA or issue IRQs, and any wakeup events it
issues would be issued through the PME\# bus signal.  Plus, there are
several PCI-standard device states, some of which are optional.

In contrast, integrated system-on-chip processors often use IRQs as the
wakeup event sources (so drivers would call \code{enable\_irq\_wake()}) and
might be able to treat DMA completion as a wakeup event (sometimes DMA can stay
active too, it'd only be the CPU and some peripherals that sleep).

Some details here may be platform-specific.  Systems may have devices that
can be fully active in certain sleep states, such as an LCD display that's
refreshed using DMA while most of the system is sleeping lightly ... and
its frame buffer might even be updated by a DSP or other non-Linux CPU while
the Linux control processor stays idle.

Moreover, the specific actions taken may depend on the target system state.
One target system state might allow a given device to be very operational;
another might require a hard shut down with re-initialization on resume.
And two different target systems might use the same device in different
ways; the aforementioned LCD might be active in one product's ``standby'',
but a different product using the same SOC might work differently.


\subsection{Device Power Management Domains}
\label{driver-api/pm/devices:device-power-management-domains}
Sometimes devices share reference clocks or other power resources.  In those
cases it generally is not possible to put devices into low-power states
individually.  Instead, a set of devices sharing a power resource can be put
into a low-power state together at the same time by turning off the shared
power resource.  Of course, they also need to be put into the full-power state
together, by turning the shared power resource on.  A set of devices with this
property is often referred to as a power domain. A power domain may also be
nested inside another power domain. The nested domain is referred to as the
sub-domain of the parent domain.

Support for power domains is provided through the \code{pm\_domain} field of
{\hyperref[driver\string-api/infrastructure:c.device]{\emph{\code{struct device}}}}.  This field is a pointer to an object of type
{\hyperref[driver\string-api/pm/types:c.dev_pm_domain]{\emph{\code{struct dev\_pm\_domain}}}}, defined in \code{include/linux/pm.h}, providing a set
of power management callbacks analogous to the subsystem-level and device driver
callbacks that are executed for the given device during all power transitions,
instead of the respective subsystem-level callbacks.  Specifically, if a
device's \code{pm\_domain} pointer is not NULL, the \code{-\textgreater{}suspend()} callback
from the object pointed to by it will be executed instead of its subsystem's
(e.g. bus type's) \code{-\textgreater{}suspend()} callback and analogously for all of the
remaining callbacks.  In other words, power management domain callbacks, if
defined for the given device, always take precedence over the callbacks provided
by the device's subsystem (e.g. bus type).

The support for device power management domains is only relevant to platforms
needing to use the same device driver power management callbacks in many
different power domain configurations and wanting to avoid incorporating the
support for power domains into subsystem-level callbacks, for example by
modifying the platform bus type.  Other platforms need not implement it or take
it into account in any way.

Devices may be defined as IRQ-safe which indicates to the PM core that their
runtime PM callbacks may be invoked with disabled interrupts (see
\code{Documentation/power/runtime\_pm.txt} for more information).  If an
IRQ-safe device belongs to a PM domain, the runtime PM of the domain will be
disallowed, unless the domain itself is defined as IRQ-safe. However, it
makes sense to define a PM domain as IRQ-safe only if all the devices in it
are IRQ-safe. Moreover, if an IRQ-safe domain has a parent domain, the runtime
PM of the parent is only allowed if the parent itself is IRQ-safe too with the
additional restriction that all child domains of an IRQ-safe parent must also
be IRQ-safe.


\subsection{Runtime Power Management}
\label{driver-api/pm/devices:runtime-power-management}
Many devices are able to dynamically power down while the system is still
running. This feature is useful for devices that are not being used, and
can offer significant power savings on a running system.  These devices
often support a range of runtime power states, which might use names such
as ``off'', ``sleep'', ``idle'', ``active'', and so on.  Those states will in some
cases (like PCI) be partially constrained by the bus the device uses, and will
usually include hardware states that are also used in system sleep states.

A system-wide power transition can be started while some devices are in low
power states due to runtime power management.  The system sleep PM callbacks
should recognize such situations and react to them appropriately, but the
necessary actions are subsystem-specific.

In some cases the decision may be made at the subsystem level while in other
cases the device driver may be left to decide.  In some cases it may be
desirable to leave a suspended device in that state during a system-wide power
transition, but in other cases the device must be put back into the full-power
state temporarily, for example so that its system wakeup capability can be
disabled.  This all depends on the hardware and the design of the subsystem and
device driver in question.

If it is necessary to resume a device from runtime suspend during a system-wide
transition into a sleep state, that can be done by calling
\code{pm\_runtime\_resume()} for it from the \code{-\textgreater{}suspend} callback (or its
couterpart for transitions related to hibernation) of either the device's driver
or a subsystem responsible for it (for example, a bus type or a PM domain).
That is guaranteed to work by the requirement that subsystems must not change
the state of devices (possibly except for resuming them from runtime suspend)
from their \code{-\textgreater{}prepare} and \code{-\textgreater{}suspend} callbacks (or equivalent) \emph{before}
invoking device drivers' \code{-\textgreater{}suspend} callbacks (or equivalent).

Some bus types and PM domains have a policy to resume all devices from runtime
suspend upfront in their \code{-\textgreater{}suspend} callbacks, but that may not be really
necessary if the driver of the device can cope with runtime-suspended devices.
The driver can indicate that by setting \code{DPM\_FLAG\_SMART\_SUSPEND} in
\code{power.driver\_flags} at the probe time, by passing it to the
\code{dev\_pm\_set\_driver\_flags()} helper.  That also may cause middle-layer code
(bus types, PM domains etc.) to skip the \code{-\textgreater{}suspend\_late} and
\code{-\textgreater{}suspend\_noirq} callbacks provided by the driver if the device remains in
runtime suspend at the beginning of the \code{suspend\_late} phase of system-wide
suspend (or in the \code{poweroff\_late} phase of hibernation), when runtime PM
has been disabled for it, under the assumption that its state should not change
after that point until the system-wide transition is over (the PM core itself
does that for devices whose ``noirq'', ``late'' and ``early'' system-wide PM callbacks
are executed directly by it).  If that happens, the driver's system-wide resume
callbacks, if present, may still be invoked during the subsequent system-wide
resume transition and the device's runtime power management status may be set
to ``active'' before enabling runtime PM for it, so the driver must be prepared to
cope with the invocation of its system-wide resume callbacks back-to-back with
its \code{-\textgreater{}runtime\_suspend} one (without the intervening \code{-\textgreater{}runtime\_resume} and
so on) and the final state of the device must reflect the ``active'' runtime PM
status in that case.

During system-wide resume from a sleep state it's easiest to put devices into
the full-power state, as explained in \code{Documentation/power/runtime\_pm.txt}.
{[}Refer to that document for more information regarding this particular issue as
well as for information on the device runtime power management framework in
general.{]}

However, it often is desirable to leave devices in suspend after system
transitions to the working state, especially if those devices had been in
runtime suspend before the preceding system-wide suspend (or analogous)
transition.  Device drivers can use the \code{DPM\_FLAG\_LEAVE\_SUSPENDED} flag to
indicate to the PM core (and middle-layer code) that they prefer the specific
devices handled by them to be left suspended and they have no problems with
skipping their system-wide resume callbacks for this reason.  Whether or not the
devices will actually be left in suspend may depend on their state before the
given system suspend-resume cycle and on the type of the system transition under
way.  In particular, devices are not left suspended if that transition is a
restore from hibernation, as device states are not guaranteed to be reflected
by the information stored in the hibernation image in that case.

The middle-layer code involved in the handling of the device is expected to
indicate to the PM core if the device may be left in suspend by setting its
\code{power.may\_skip\_resume} status bit which is checked by the PM core
during the ``noirq'' phase of the preceding system-wide suspend (or analogous)
transition.  The middle layer is then responsible for handling the device as
appropriate in its ``noirq'' resume callback, which is executed regardless of
whether or not the device is left suspended, but the other resume callbacks
(except for \code{-\textgreater{}complete}) will be skipped automatically by the PM core if the
device really can be left in suspend.

For devices whose ``noirq'', ``late'' and ``early'' driver callbacks are invoked
directly by the PM core, all of the system-wide resume callbacks are skipped if
\code{DPM\_FLAG\_LEAVE\_SUSPENDED} is set and the device is in runtime suspend during
the \code{suspend\_noirq} (or analogous) phase or the transition under way is a
proper system suspend (rather than anything related to hibernation) and the
device's wakeup settings are suitable for runtime PM (that is, it cannot
generate wakeup signals at all or it is allowed to wake up the system from
sleep).


\section{Suspend/Hibernation Notifiers}
\label{driver-api/pm/notifiers:suspend-hibernation-notifiers}\label{driver-api/pm/notifiers::doc}
\begin{Verbatim}[commandchars=\\\{\}]
Copyright (c) 2016 Intel Corp., Rafael J. Wysocki \PYGZlt{}rafael.j.wysocki@intel.com\PYGZgt{}
\end{Verbatim}

There are some operations that subsystems or drivers may want to carry out
before hibernation/suspend or after restore/resume, but they require the system
to be fully functional, so the drivers' and subsystems' \code{-\textgreater{}suspend()} and
\code{-\textgreater{}resume()} or even \code{-\textgreater{}prepare()} and \code{-\textgreater{}complete()} callbacks are not
suitable for this purpose.

For example, device drivers may want to upload firmware to their devices after
resume/restore, but they cannot do it by calling {\hyperref[driver\string-api/infrastructure:c.request_firmware]{\emph{\code{request\_firmware()}}}}
from their \code{-\textgreater{}resume()} or \code{-\textgreater{}complete()} callback routines (user land
processes are frozen at these points).  The solution may be to load the firmware
into memory before processes are frozen and upload it from there in the
\code{-\textgreater{}resume()} routine.  A suspend/hibernation notifier may be used for that.

Subsystems or drivers having such needs can register suspend notifiers that
will be called upon the following events by the PM core:
\begin{description}
\item[{\code{PM\_HIBERNATION\_PREPARE}}] \leavevmode
The system is going to hibernate, tasks will be frozen immediately. This
is different from \code{PM\_SUSPEND\_PREPARE} below, because in this case
additional work is done between the notifiers and the invocation of PM
callbacks for the ``freeze'' transition.

\item[{\code{PM\_POST\_HIBERNATION}}] \leavevmode
The system memory state has been restored from a hibernation image or an
error occurred during hibernation.  Device restore callbacks have been
executed and tasks have been thawed.

\item[{\code{PM\_RESTORE\_PREPARE}}] \leavevmode
The system is going to restore a hibernation image.  If all goes well,
the restored image kernel will issue a \code{PM\_POST\_HIBERNATION}
notification.

\item[{\code{PM\_POST\_RESTORE}}] \leavevmode
An error occurred during restore from hibernation.  Device restore
callbacks have been executed and tasks have been thawed.

\item[{\code{PM\_SUSPEND\_PREPARE}}] \leavevmode
The system is preparing for suspend.

\item[{\code{PM\_POST\_SUSPEND}}] \leavevmode
The system has just resumed or an error occurred during suspend.  Device
resume callbacks have been executed and tasks have been thawed.

\end{description}

It is generally assumed that whatever the notifiers do for
\code{PM\_HIBERNATION\_PREPARE}, should be undone for \code{PM\_POST\_HIBERNATION}.
Analogously, operations carried out for \code{PM\_SUSPEND\_PREPARE} should be
reversed for \code{PM\_POST\_SUSPEND}.

Moreover, if one of the notifiers fails for the \code{PM\_HIBERNATION\_PREPARE} or
\code{PM\_SUSPEND\_PREPARE} event, the notifiers that have already succeeded for that
event will be called for \code{PM\_POST\_HIBERNATION} or \code{PM\_POST\_SUSPEND},
respectively.

The hibernation and suspend notifiers are called with \code{pm\_mutex} held.
They are defined in the usual way, but their last argument is meaningless (it is
always NULL).

To register and/or unregister a suspend notifier use
\code{register\_pm\_notifier()} and \code{unregister\_pm\_notifier()},
respectively (both defined in \code{include/linux/suspend.h}).  If you don't
need to unregister the notifier, you can also use the \code{pm\_notifier()}
macro defined in \code{include/linux/suspend.h}.


\section{Device Power Management Data Types}
\label{driver-api/pm/types:device-power-management-data-types}\label{driver-api/pm/types::doc}\index{dev\_pm\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pm/types:c.dev_pm_ops}\pysigline{struct \bfcode{dev\_pm\_ops}}
device PM callbacks.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dev\PYGZus{}pm\PYGZus{}ops \PYGZob{}
  int (*prepare)(struct device *dev);
  void (*complete)(struct device *dev);
  int (*suspend)(struct device *dev);
  int (*resume)(struct device *dev);
  int (*freeze)(struct device *dev);
  int (*thaw)(struct device *dev);
  int (*poweroff)(struct device *dev);
  int (*restore)(struct device *dev);
  int (*suspend\PYGZus{}late)(struct device *dev);
  int (*resume\PYGZus{}early)(struct device *dev);
  int (*freeze\PYGZus{}late)(struct device *dev);
  int (*thaw\PYGZus{}early)(struct device *dev);
  int (*poweroff\PYGZus{}late)(struct device *dev);
  int (*restore\PYGZus{}early)(struct device *dev);
  int (*suspend\PYGZus{}noirq)(struct device *dev);
  int (*resume\PYGZus{}noirq)(struct device *dev);
  int (*freeze\PYGZus{}noirq)(struct device *dev);
  int (*thaw\PYGZus{}noirq)(struct device *dev);
  int (*poweroff\PYGZus{}noirq)(struct device *dev);
  int (*restore\PYGZus{}noirq)(struct device *dev);
  int (*runtime\PYGZus{}suspend)(struct device *dev);
  int (*runtime\PYGZus{}resume)(struct device *dev);
  int (*runtime\PYGZus{}idle)(struct device *dev);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{prepare}}] \leavevmode
The principal role of this callback is to prevent new children of
the device from being registered after it has returned (the driver's
subsystem and generally the rest of the kernel is supposed to prevent
new calls to the probe method from being made too once \textbf{prepare()} has
succeeded).  If \textbf{prepare()} detects a situation it cannot handle (e.g.
registration of a child already in progress), it may return -EAGAIN, so
that the PM core can execute it once again (e.g. after a new child has
been registered) to recover from the race condition.
This method is executed for all kinds of suspend transitions and is
followed by one of the suspend callbacks: \textbf{suspend()}, \textbf{freeze()}, or
\textbf{poweroff()}.  If the transition is a suspend to memory or standby (that
is, not related to hibernation), the return value of \textbf{prepare()} may be
used to indicate to the PM core to leave the device in runtime suspend
if applicable.  Namely, if \textbf{prepare()} returns a positive number, the PM
core will understand that as a declaration that the device appears to be
runtime-suspended and it may be left in that state during the entire
transition and during the subsequent resume if all of its descendants
are left in runtime suspend too.  If that happens, \textbf{complete()} will be
executed directly after \textbf{prepare()} and it must ensure the proper
functioning of the device after the system resume.
The PM core executes subsystem-level \textbf{prepare()} for all devices before
starting to invoke suspend callbacks for any of them, so generally
devices may be assumed to be functional or to respond to runtime resume
requests while \textbf{prepare()} is being executed.  However, device drivers
may NOT assume anything about the availability of user space at that
time and it is NOT valid to request firmware from within \textbf{prepare()}
(it's too late to do that).  It also is NOT valid to allocate
substantial amounts of memory from \textbf{prepare()} in the GFP\_KERNEL mode.
{[}To work around these limitations, drivers may register suspend and
hibernation notifiers to be executed before the freezing of tasks.{]}

\item[{\code{complete}}] \leavevmode
Undo the changes made by \textbf{prepare()}.  This method is executed for
all kinds of resume transitions, following one of the resume callbacks:
\textbf{resume()}, \textbf{thaw()}, \textbf{restore()}.  Also called if the state transition
fails before the driver's suspend callback: \textbf{suspend()}, \textbf{freeze()} or
\textbf{poweroff()}, can be executed (e.g. if the suspend callback fails for one
of the other devices that the PM core has unsuccessfully attempted to
suspend earlier).
The PM core executes subsystem-level \textbf{complete()} after it has executed
the appropriate resume callbacks for all devices.  If the corresponding
\textbf{prepare()} at the beginning of the suspend transition returned a
positive number and the device was left in runtime suspend (without
executing any suspend and resume callbacks for it), \textbf{complete()} will be
the only callback executed for the device during resume.  In that case,
\textbf{complete()} must be prepared to do whatever is necessary to ensure the
proper functioning of the device after the system resume.  To this end,
\textbf{complete()} can check the power.direct\_complete flag of the device to
learn whether (unset) or not (set) the previous suspend and resume
callbacks have been executed for it.

\item[{\code{suspend}}] \leavevmode
Executed before putting the system into a sleep state in which the
contents of main memory are preserved.  The exact action to perform
depends on the device's subsystem (PM domain, device type, class or bus
type), but generally the device must be quiescent after subsystem-level
\textbf{suspend()} has returned, so that it doesn't do any I/O or DMA.
Subsystem-level \textbf{suspend()} is executed for all devices after invoking
subsystem-level \textbf{prepare()} for all of them.

\item[{\code{resume}}] \leavevmode
Executed after waking the system up from a sleep state in which the
contents of main memory were preserved.  The exact action to perform
depends on the device's subsystem, but generally the driver is expected
to start working again, responding to hardware events and software
requests (the device itself may be left in a low-power state, waiting
for a runtime resume to occur).  The state of the device at the time its
driver's \textbf{resume()} callback is run depends on the platform and subsystem
the device belongs to.  On most platforms, there are no restrictions on
availability of resources like clocks during \textbf{resume()}.
Subsystem-level \textbf{resume()} is executed for all devices after invoking
subsystem-level \textbf{resume\_noirq()} for all of them.

\item[{\code{freeze}}] \leavevmode
Hibernation-specific, executed before creating a hibernation image.
Analogous to \textbf{suspend()}, but it should not enable the device to signal
wakeup events or change its power state.  The majority of subsystems
(with the notable exception of the PCI bus type) expect the driver-level
\textbf{freeze()} to save the device settings in memory to be used by \textbf{restore()}
during the subsequent resume from hibernation.
Subsystem-level \textbf{freeze()} is executed for all devices after invoking
subsystem-level \textbf{prepare()} for all of them.

\item[{\code{thaw}}] \leavevmode
Hibernation-specific, executed after creating a hibernation image OR
if the creation of an image has failed.  Also executed after a failing
attempt to restore the contents of main memory from such an image.
Undo the changes made by the preceding \textbf{freeze()}, so the device can be
operated in the same way as immediately before the call to \textbf{freeze()}.
Subsystem-level \textbf{thaw()} is executed for all devices after invoking
subsystem-level \textbf{thaw\_noirq()} for all of them.  It also may be executed
directly after \textbf{freeze()} in case of a transition error.

\item[{\code{poweroff}}] \leavevmode
Hibernation-specific, executed after saving a hibernation image.
Analogous to \textbf{suspend()}, but it need not save the device's settings in
memory.
Subsystem-level \textbf{poweroff()} is executed for all devices after invoking
subsystem-level \textbf{prepare()} for all of them.

\item[{\code{restore}}] \leavevmode
Hibernation-specific, executed after restoring the contents of main
memory from a hibernation image, analogous to \textbf{resume()}.

\item[{\code{suspend\_late}}] \leavevmode
Continue operations started by \textbf{suspend()}.  For a number of
devices \textbf{suspend\_late()} may point to the same callback routine as the
runtime suspend callback.

\item[{\code{resume\_early}}] \leavevmode
Prepare to execute \textbf{resume()}.  For a number of devices
\textbf{resume\_early()} may point to the same callback routine as the runtime
resume callback.

\item[{\code{freeze\_late}}] \leavevmode
Continue operations started by \textbf{freeze()}.  Analogous to
\textbf{suspend\_late()}, but it should not enable the device to signal wakeup
events or change its power state.

\item[{\code{thaw\_early}}] \leavevmode
Prepare to execute \textbf{thaw()}.  Undo the changes made by the
preceding \textbf{freeze\_late()}.

\item[{\code{poweroff\_late}}] \leavevmode
Continue operations started by \textbf{poweroff()}.  Analogous to
\textbf{suspend\_late()}, but it need not save the device's settings in memory.

\item[{\code{restore\_early}}] \leavevmode
Prepare to execute \textbf{restore()}, analogous to \textbf{resume\_early()}.

\item[{\code{suspend\_noirq}}] \leavevmode
Complete the actions started by \textbf{suspend()}.  Carry out any
additional operations required for suspending the device that might be
racing with its driver's interrupt handler, which is guaranteed not to
run while \textbf{suspend\_noirq()} is being executed.
It generally is expected that the device will be in a low-power state
(appropriate for the target system sleep state) after subsystem-level
\textbf{suspend\_noirq()} has returned successfully.  If the device can generate
system wakeup signals and is enabled to wake up the system, it should be
configured to do so at that time.  However, depending on the platform
and device's subsystem, \textbf{suspend()} or \textbf{suspend\_late()} may be allowed to
put the device into the low-power state and configure it to generate
wakeup signals, in which case it generally is not necessary to define
\textbf{suspend\_noirq()}.

\item[{\code{resume\_noirq}}] \leavevmode
Prepare for the execution of \textbf{resume()} by carrying out any
operations required for resuming the device that might be racing with
its driver's interrupt handler, which is guaranteed not to run while
\textbf{resume\_noirq()} is being executed.

\item[{\code{freeze\_noirq}}] \leavevmode
Complete the actions started by \textbf{freeze()}.  Carry out any
additional operations required for freezing the device that might be
racing with its driver's interrupt handler, which is guaranteed not to
run while \textbf{freeze\_noirq()} is being executed.
The power state of the device should not be changed by either \textbf{freeze()},
or \textbf{freeze\_late()}, or \textbf{freeze\_noirq()} and it should not be configured to
signal system wakeup by any of these callbacks.

\item[{\code{thaw\_noirq}}] \leavevmode
Prepare for the execution of \textbf{thaw()} by carrying out any
operations required for thawing the device that might be racing with its
driver's interrupt handler, which is guaranteed not to run while
\textbf{thaw\_noirq()} is being executed.

\item[{\code{poweroff\_noirq}}] \leavevmode
Complete the actions started by \textbf{poweroff()}.  Analogous to
\textbf{suspend\_noirq()}, but it need not save the device's settings in memory.

\item[{\code{restore\_noirq}}] \leavevmode
Prepare for the execution of \textbf{restore()} by carrying out any
operations required for thawing the device that might be racing with its
driver's interrupt handler, which is guaranteed not to run while
\textbf{restore\_noirq()} is being executed.  Analogous to \textbf{resume\_noirq()}.

\item[{\code{runtime\_suspend}}] \leavevmode
Prepare the device for a condition in which it won't be
able to communicate with the CPU(s) and RAM due to power management.
This need not mean that the device should be put into a low-power state.
For example, if the device is behind a link which is about to be turned
off, the device may remain at full power.  If the device does go to low
power and is capable of generating runtime wakeup events, remote wakeup
(i.e., a hardware mechanism allowing the device to request a change of
its power state via an interrupt) should be enabled for it.

\item[{\code{runtime\_resume}}] \leavevmode
Put the device into the fully active state in response to a
wakeup event generated by hardware or at the request of software.  If
necessary, put the device into the full-power state and restore its
registers, so that it is fully operational.

\item[{\code{runtime\_idle}}] \leavevmode
Device appears to be inactive and it might be put into a
low-power state if all of the necessary conditions are satisfied.
Check these conditions, and return 0 if it's appropriate to let the PM
core queue a suspend request for the device.

\end{description}

\textbf{Description}

Several device power state transitions are externally visible, affecting
the state of pending I/O queues and (for drivers that touch hardware)
interrupts, wakeups, DMA, and other hardware state.  There may also be
internal transitions to various low-power modes which are transparent
to the rest of the driver stack (such as a driver that's ON gating off
clocks which are not in active use).

The externally visible transitions are handled with the help of callbacks
included in this structure in such a way that, typically, two levels of
callbacks are involved.  First, the PM core executes callbacks provided by PM
domains, device types, classes and bus types.  They are the subsystem-level
callbacks expected to execute callbacks provided by device drivers, although
they may choose not to do that.  If the driver callbacks are executed, they
have to collaborate with the subsystem-level callbacks to achieve the goals
appropriate for the given system transition, given transition phase and the
subsystem the device belongs to.

All of the above callbacks, except for \textbf{complete()}, return error codes.
However, the error codes returned by \textbf{resume()}, \textbf{thaw()}, \textbf{restore()},
\textbf{resume\_noirq()}, \textbf{thaw\_noirq()}, and \textbf{restore\_noirq()}, do not cause the PM
core to abort the resume transition during which they are returned.  The
error codes returned in those cases are only printed to the system logs for
debugging purposes.  Still, it is recommended that drivers only return error
codes from their resume methods in case of an unrecoverable failure (i.e.
when the device being handled refuses to resume and becomes unusable) to
allow the PM core to be modified in the future, so that it can avoid
attempting to handle devices that failed to resume and their children.

It is allowed to unregister devices while the above callbacks are being
executed.  However, a callback routine MUST NOT try to unregister the device
it was called for, although it may unregister children of that device (for
example, if it detects that a child was unplugged while the system was
asleep).

There also are callbacks related to runtime power management of devices.
Again, as a rule these callbacks are executed by the PM core for subsystems
(PM domains, device types, classes and bus types) and the subsystem-level
callbacks are expected to invoke the driver callbacks.  Moreover, the exact
actions to be performed by a device driver's callbacks generally depend on
the platform and subsystem the device belongs to.

Refer to Documentation/power/runtime\_pm.txt for more information about the
role of the \textbf{runtime\_suspend()}, \textbf{runtime\_resume()} and \textbf{runtime\_idle()}
callbacks in device runtime power management.
\index{dev\_pm\_domain (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pm/types:c.dev_pm_domain}\pysigline{struct \bfcode{dev\_pm\_domain}}
power management domain representation.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dev\PYGZus{}pm\PYGZus{}domain \PYGZob{}
  struct dev\PYGZus{}pm\PYGZus{}ops       ops;
  void (*detach)(struct device *dev, bool power\PYGZus{}off);
  int (*activate)(struct device *dev);
  void (*sync)(struct device *dev);
  void (*dismiss)(struct device *dev);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{ops}}] \leavevmode
Power management operations associated with this domain.

\item[{\code{detach}}] \leavevmode
Called when removing a device from the domain.

\item[{\code{activate}}] \leavevmode
Called before executing probe routines for bus types and drivers.

\item[{\code{sync}}] \leavevmode
Called after successful driver probe.

\item[{\code{dismiss}}] \leavevmode
Called after unsuccessful driver probe and after driver removal.

\end{description}

\textbf{Description}

Power domains provide callbacks that are executed during system suspend,
hibernation, system resume and during runtime PM transitions instead of
subsystem-level and driver-level callbacks.


\chapter{Bus-Independent Device Accesses}
\label{driver-api/device-io:bus-independent-device-accesses}\label{driver-api/device-io::doc}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Matthew Wilcox

\item[{Author}] \leavevmode
Alan Cox

\end{description}\end{quote}


\section{Introduction}
\label{driver-api/device-io:introduction}
Linux provides an API which abstracts performing IO across all busses
and devices, allowing device drivers to be written independently of bus
type.


\section{Memory Mapped IO}
\label{driver-api/device-io:memory-mapped-io}

\subsection{Getting Access to the Device}
\label{driver-api/device-io:getting-access-to-the-device}
The most widely supported form of IO is memory mapped IO. That is, a
part of the CPU's address space is interpreted not as accesses to
memory, but as accesses to a device. Some architectures define devices
to be at a fixed address, but most have some method of discovering
devices. The PCI bus walk is a good example of such a scheme. This
document does not cover how to receive such an address, but assumes you
are starting with one. Physical addresses are of type unsigned long.

This address should not be used directly. Instead, to get an address
suitable for passing to the accessor functions described below, you
should call {\hyperref[driver\string-api/device\string-io:c.ioremap]{\emph{\code{ioremap()}}}}. An address suitable for accessing
the device will be returned to you.

After you've finished using the device (say, in your module's exit
routine), call \code{iounmap()} in order to return the address
space to the kernel. Most architectures allocate new address space each
time you call {\hyperref[driver\string-api/device\string-io:c.ioremap]{\emph{\code{ioremap()}}}}, and they can run out unless you
call \code{iounmap()}.


\subsection{Accessing the device}
\label{driver-api/device-io:accessing-the-device}
The part of the interface most used by drivers is reading and writing
memory-mapped registers on the device. Linux provides interfaces to read
and write 8-bit, 16-bit, 32-bit and 64-bit quantities. Due to a
historical accident, these are named byte, word, long and quad accesses.
Both read and write accesses are supported; there is no prefetch support
at this time.

The functions are named readb(), readw(), readl(), readq(),
readb\_relaxed(), readw\_relaxed(), readl\_relaxed(), readq\_relaxed(),
writeb(), writew(), writel() and writeq().

Some devices (such as framebuffers) would like to use larger transfers than
8 bytes at a time. For these devices, the \code{memcpy\_toio()},
\code{memcpy\_fromio()} and \code{memset\_io()} functions are
provided. Do not use memset or memcpy on IO addresses; they are not
guaranteed to copy data in order.

The read and write functions are defined to be ordered. That is the
compiler is not permitted to reorder the I/O sequence. When the ordering
can be compiler optimised, you can use \_\_readb() and friends to
indicate the relaxed ordering. Use this with care.

While the basic functions are defined to be synchronous with respect to
each other and ordered with respect to each other the busses the devices
sit on may themselves have asynchronicity. In particular many authors
are burned by the fact that PCI bus writes are posted asynchronously. A
driver author must issue a read from the same device to ensure that
writes have occurred in the specific cases the author cares. This kind
of property cannot be hidden from driver writers in the API. In some
cases, the read used to flush the device may be expected to fail (if the
card is resetting, for example). In that case, the read should be done
from config space, which is guaranteed to soft-fail if the card doesn't
respond.

The following is an example of flushing a write to a device when the
driver would like to ensure the write's effects are visible prior to
continuing execution:

\begin{Verbatim}[commandchars=\\\{\}]
static inline void
qla1280\PYGZus{}disable\PYGZus{}intrs(struct scsi\PYGZus{}qla\PYGZus{}host *ha)
\PYGZob{}
    struct device\PYGZus{}reg *reg;

    reg = ha\PYGZhy{}\PYGZgt{}iobase;
    /* disable risc and host interrupts */
    WRT\PYGZus{}REG\PYGZus{}WORD(\PYGZam{}reg\PYGZhy{}\PYGZgt{}ictrl, 0);
    /*
     * The following read will ensure that the above write
     * has been received by the device before we return from this
     * function.
     */
    RD\PYGZus{}REG\PYGZus{}WORD(\PYGZam{}reg\PYGZhy{}\PYGZgt{}ictrl);
    ha\PYGZhy{}\PYGZgt{}flags.ints\PYGZus{}enabled = 0;
\PYGZcb{}
\end{Verbatim}

In addition to write posting, on some large multiprocessing systems
(e.g. SGI Challenge, Origin and Altix machines) posted writes won't be
strongly ordered coming from different CPUs. Thus it's important to
properly protect parts of your driver that do memory-mapped writes with
locks and use the \code{mmiowb()} to make sure they arrive in the
order intended. Issuing a regular readX() will also ensure write ordering,
but should only be used when the
driver has to be sure that the write has actually arrived at the device
(not that it's simply ordered with respect to other writes), since a
full readX() is a relatively expensive operation.

Generally, one should use \code{mmiowb()} prior to releasing a spinlock
that protects regions using \code{writeb()} or similar functions that
aren't surrounded by readb() calls, which will ensure ordering
and flushing. The following pseudocode illustrates what might occur if
write ordering isn't guaranteed via \code{mmiowb()} or one of the
readX() functions:

\begin{Verbatim}[commandchars=\\\{\}]
CPU A:  spin\PYGZus{}lock\PYGZus{}irqsave(\PYGZam{}dev\PYGZus{}lock, flags)
CPU A:  ...
CPU A:  writel(newval, ring\PYGZus{}ptr);
CPU A:  spin\PYGZus{}unlock\PYGZus{}irqrestore(\PYGZam{}dev\PYGZus{}lock, flags)
        ...
CPU B:  spin\PYGZus{}lock\PYGZus{}irqsave(\PYGZam{}dev\PYGZus{}lock, flags)
CPU B:  writel(newval2, ring\PYGZus{}ptr);
CPU B:  ...
CPU B:  spin\PYGZus{}unlock\PYGZus{}irqrestore(\PYGZam{}dev\PYGZus{}lock, flags)
\end{Verbatim}

In the case above, newval2 could be written to ring\_ptr before newval.
Fixing it is easy though:

\begin{Verbatim}[commandchars=\\\{\}]
CPU A:  spin\PYGZus{}lock\PYGZus{}irqsave(\PYGZam{}dev\PYGZus{}lock, flags)
CPU A:  ...
CPU A:  writel(newval, ring\PYGZus{}ptr);
CPU A:  mmiowb(); /* ensure no other writes beat us to the device */
CPU A:  spin\PYGZus{}unlock\PYGZus{}irqrestore(\PYGZam{}dev\PYGZus{}lock, flags)
        ...
CPU B:  spin\PYGZus{}lock\PYGZus{}irqsave(\PYGZam{}dev\PYGZus{}lock, flags)
CPU B:  writel(newval2, ring\PYGZus{}ptr);
CPU B:  ...
CPU B:  mmiowb();
CPU B:  spin\PYGZus{}unlock\PYGZus{}irqrestore(\PYGZam{}dev\PYGZus{}lock, flags)
\end{Verbatim}

See tg3.c for a real world example of how to use \code{mmiowb()}

PCI ordering rules also guarantee that PIO read responses arrive after any
outstanding DMA writes from that bus, since for some devices the result of
a readb() call may signal to the driver that a DMA transaction is
complete. In many cases, however, the driver may want to indicate that the
next readb() call has no relation to any previous DMA writes
performed by the device. The driver can use readb\_relaxed() for
these cases, although only some platforms will honor the relaxed
semantics. Using the relaxed read functions will provide significant
performance benefits on platforms that support it. The qla2xxx driver
provides examples of how to use readX\_relaxed(). In many cases, a majority
of the driver's readX() calls can safely be converted to readX\_relaxed()
calls, since only a few will indicate or depend on DMA completion.


\section{Port Space Accesses}
\label{driver-api/device-io:port-space-accesses}

\subsection{Port Space Explained}
\label{driver-api/device-io:port-space-explained}
Another form of IO commonly supported is Port Space. This is a range of
addresses separate to the normal memory address space. Access to these
addresses is generally not as fast as accesses to the memory mapped
addresses, and it also has a potentially smaller address space.

Unlike memory mapped IO, no preparation is required to access port
space.


\subsection{Accessing Port Space}
\label{driver-api/device-io:accessing-port-space}
Accesses to this space are provided through a set of functions which
allow 8-bit, 16-bit and 32-bit accesses; also known as byte, word and
long. These functions are \code{inb()}, \code{inw()},
\code{inl()}, \code{outb()}, \code{outw()} and
\code{outl()}.

Some variants are provided for these functions. Some devices require
that accesses to their ports are slowed down. This functionality is
provided by appending a \code{\_p} to the end of the function.
There are also equivalents to memcpy. The \code{ins()} and
\code{outs()} functions copy bytes, words or longs to the given
port.


\section{Public Functions Provided}
\label{driver-api/device-io:public-functions-provided}\index{virt\_to\_phys (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/device-io:c.virt_to_phys}\pysiglinewithargsret{phys\_addr\_t \bfcode{virt\_to\_phys}}{volatile void *\emph{ address}}{}
map virtual addresses to physical

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{volatile void * address}}] \leavevmode
address to remap

\end{description}

\textbf{Description}
\begin{quote}

The returned physical address is the physical (CPU) mapping for
the memory address given. It is only valid to use this function on
addresses directly mapped or allocated via kmalloc.

This function does not give bus mappings for DMA transfers. In
almost all conceivable cases a device driver should not be using
this function
\end{quote}
\index{phys\_to\_virt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/device-io:c.phys_to_virt}\pysiglinewithargsret{void * \bfcode{phys\_to\_virt}}{phys\_addr\_t\emph{ address}}{}
map physical address to virtual

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{phys\_addr\_t address}}] \leavevmode
address to remap

\end{description}

\textbf{Description}
\begin{quote}

The returned virtual address is a current CPU mapping for
the memory address given. It is only valid to use this function on
addresses that have a kernel mapping

This function does not handle bus mappings for DMA transfers. In
almost all conceivable cases a device driver should not be using
this function
\end{quote}
\index{ioremap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/device-io:c.ioremap}\pysiglinewithargsret{void \_\_iomem * \bfcode{ioremap}}{resource\_size\_t\emph{ offset}, unsigned long\emph{ size}}{}
map bus memory into CPU space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{resource\_size\_t offset}}] \leavevmode
bus address of the memory

\item[{\code{unsigned long size}}] \leavevmode
size of the resource to map

\end{description}

\textbf{Description}

ioremap performs a platform specific sequence of operations to
make bus memory CPU accessible via the readb/readw/readl/writeb/
writew/writel functions and the other mmio helpers. The returned
address is not guaranteed to be usable directly as a virtual
address.

If the area you are trying to map is a PCI BAR you should have a
look at {\hyperref[driver\string-api/device\string-io:c.pci_iomap]{\emph{\code{pci\_iomap()}}}}.
\index{pci\_iomap\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/device-io:c.pci_iomap_range}\pysiglinewithargsret{void \_\_iomem * \bfcode{pci\_iomap\_range}}{struct pci\_dev *\emph{ dev}, int\emph{ bar}, unsigned long\emph{ offset}, unsigned long\emph{ maxlen}}{}
create a virtual mapping cookie for a PCI BAR

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device that owns the BAR

\item[{\code{int bar}}] \leavevmode
BAR number

\item[{\code{unsigned long offset}}] \leavevmode
map memory at the given offset in BAR

\item[{\code{unsigned long maxlen}}] \leavevmode
max length of the memory to map

\end{description}

\textbf{Description}

Using this function you will get a \_\_iomem address to your device BAR.
You can access it using ioread*() and iowrite*(). These functions hide
the details if this is a MMIO or PIO address space and will just do what
you expect from them in the correct way.

\textbf{maxlen} specifies the maximum length to map. If you want to get access to
the complete BAR from offset to the end, pass \code{0} here.
\index{pci\_iomap\_wc\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/device-io:c.pci_iomap_wc_range}\pysiglinewithargsret{void \_\_iomem * \bfcode{pci\_iomap\_wc\_range}}{struct pci\_dev *\emph{ dev}, int\emph{ bar}, unsigned long\emph{ offset}, unsigned long\emph{ maxlen}}{}
create a virtual WC mapping cookie for a PCI BAR

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device that owns the BAR

\item[{\code{int bar}}] \leavevmode
BAR number

\item[{\code{unsigned long offset}}] \leavevmode
map memory at the given offset in BAR

\item[{\code{unsigned long maxlen}}] \leavevmode
max length of the memory to map

\end{description}

\textbf{Description}

Using this function you will get a \_\_iomem address to your device BAR.
You can access it using ioread*() and iowrite*(). These functions hide
the details if this is a MMIO or PIO address space and will just do what
you expect from them in the correct way. When possible write combining
is used.

\textbf{maxlen} specifies the maximum length to map. If you want to get access to
the complete BAR from offset to the end, pass \code{0} here.
\index{pci\_iomap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/device-io:c.pci_iomap}\pysiglinewithargsret{void \_\_iomem * \bfcode{pci\_iomap}}{struct pci\_dev *\emph{ dev}, int\emph{ bar}, unsigned long\emph{ maxlen}}{}
create a virtual mapping cookie for a PCI BAR

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device that owns the BAR

\item[{\code{int bar}}] \leavevmode
BAR number

\item[{\code{unsigned long maxlen}}] \leavevmode
length of the memory to map

\end{description}

\textbf{Description}

Using this function you will get a \_\_iomem address to your device BAR.
You can access it using ioread*() and iowrite*(). These functions hide
the details if this is a MMIO or PIO address space and will just do what
you expect from them in the correct way.

\textbf{maxlen} specifies the maximum length to map. If you want to get access to
the complete BAR without checking for its length first, pass \code{0} here.
\index{pci\_iomap\_wc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/device-io:c.pci_iomap_wc}\pysiglinewithargsret{void \_\_iomem * \bfcode{pci\_iomap\_wc}}{struct pci\_dev *\emph{ dev}, int\emph{ bar}, unsigned long\emph{ maxlen}}{}
create a virtual WC mapping cookie for a PCI BAR

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device that owns the BAR

\item[{\code{int bar}}] \leavevmode
BAR number

\item[{\code{unsigned long maxlen}}] \leavevmode
length of the memory to map

\end{description}

\textbf{Description}

Using this function you will get a \_\_iomem address to your device BAR.
You can access it using ioread*() and iowrite*(). These functions hide
the details if this is a MMIO or PIO address space and will just do what
you expect from them in the correct way. When possible write combining
is used.

\textbf{maxlen} specifies the maximum length to map. If you want to get access to
the complete BAR without checking for its length first, pass \code{0} here.


\chapter{Buffer Sharing and Synchronization}
\label{driver-api/dma-buf:buffer-sharing-and-synchronization}\label{driver-api/dma-buf::doc}
The dma-buf subsystem provides the framework for sharing buffers for
hardware (DMA) access across multiple device drivers and subsystems, and
for synchronizing asynchronous hardware access.

This is used, for example, by drm ``prime'' multi-GPU support, but is of
course not limited to GPU use cases.

The three main components of this are: (1) dma-buf, representing a
sg\_table and exposed to userspace as a file descriptor to allow passing
between devices, (2) fence, which provides a mechanism to signal when
one device as finished access, and (3) reservation, which manages the
shared or exclusive fence(s) associated with the buffer.


\section{Shared DMA Buffers}
\label{driver-api/dma-buf:shared-dma-buffers}
This document serves as a guide to device-driver writers on what is the dma-buf
buffer sharing API, how to use it for exporting and using shared buffers.

Any device driver which wishes to be a part of DMA buffer sharing, can do so as
either the `exporter' of buffers, or the `user' or `importer' of buffers.

Say a driver A wants to use buffers created by driver B, then we call B as the
exporter, and A as buffer-user/importer.

The exporter
\begin{itemize}
\item {} 
implements and manages operations in {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_ops]{\emph{\code{struct dma\_buf\_ops}}}} for the buffer,

\item {} 
allows other users to share the buffer by using dma\_buf sharing APIs,

\item {} 
manages the details of buffer allocation, wrapped int a {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{\code{struct
dma\_buf}}}},

\item {} 
decides about the actual backing storage where this allocation happens,

\item {} 
and takes care of any migration of scatterlist - for all (shared) users of
this buffer.

\end{itemize}

The buffer-user
\begin{itemize}
\item {} 
is one of (many) sharing users of the buffer.

\item {} 
doesn't need to worry about how the buffer is allocated, or where.

\item {} 
and needs a mechanism to get access to the scatterlist that makes up this
buffer in memory, mapped into its own address space, so it can access the
same area of memory. This interface is provided by {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_attachment]{\emph{\code{struct
dma\_buf\_attachment}}}}.

\end{itemize}

Any exporters or users of the dma-buf buffer sharing framework must have a
`select DMA\_SHARED\_BUFFER' in their respective Kconfigs.


\subsection{Userspace Interface Notes}
\label{driver-api/dma-buf:userspace-interface-notes}
Mostly a DMA buffer file descriptor is simply an opaque object for userspace,
and hence the generic interface exposed is very minimal. There's a few things to
consider though:
\begin{itemize}
\item {} 
Since kernel 3.12 the dma-buf FD supports the llseek system call, but only
with offset=0 and whence=SEEK\_END\textbar{}SEEK\_SET. SEEK\_SET is supported to allow
the usual size discover pattern size = SEEK\_END(0); SEEK\_SET(0). Every other
llseek operation will report -EINVAL.

If llseek on dma-buf FDs isn't support the kernel will report -ESPIPE for all
cases. Userspace can use this to detect support for discovering the dma-buf
size using llseek.

\item {} 
In order to avoid fd leaks on exec, the FD\_CLOEXEC flag must be set
on the file descriptor.  This is not just a resource leak, but a
potential security hole.  It could give the newly exec'd application
access to buffers, via the leaked fd, to which it should otherwise
not be permitted access.

The problem with doing this via a separate fcntl() call, versus doing it
atomically when the fd is created, is that this is inherently racy in a
multi-threaded app{[}3{]}.  The issue is made worse when it is library code
opening/creating the file descriptor, as the application may not even be
aware of the fd's.

To avoid this problem, userspace must have a way to request O\_CLOEXEC
flag be set when the dma-buf fd is created.  So any API provided by
the exporting driver to create a dmabuf fd must provide a way to let
userspace control setting of O\_CLOEXEC flag passed in to dma\_buf\_fd().

\item {} 
Memory mapping the contents of the DMA buffer is also supported. See the
discussion below on {\hyperref[driver\string-api/dma\string-buf:cpu\string-access\string-to\string-dma\string-buffer\string-objects]{\emph{CPU Access to DMA Buffer Objects}}} for the full details.

\item {} 
The DMA buffer FD is also pollable, see {\hyperref[driver\string-api/dma\string-buf:fence\string-poll\string-support]{\emph{Fence Poll Support}}} below for
details.

\end{itemize}


\subsection{Basic Operation and Device DMA Access}
\label{driver-api/dma-buf:basic-operation-and-device-dma-access}
For device DMA access to a shared DMA buffer the usual sequence of operations
is fairly simple:
\begin{enumerate}
\item {} 
The exporter defines his exporter instance using
{\hyperref[driver\string-api/dma\string-buf:c.DEFINE_DMA_BUF_EXPORT_INFO]{\emph{\code{DEFINE\_DMA\_BUF\_EXPORT\_INFO()}}}} and calls {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_export]{\emph{\code{dma\_buf\_export()}}}} to wrap a private
buffer object into a {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{\code{dma\_buf}}}}. It then exports that {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{\code{dma\_buf}}}} to userspace
as a file descriptor by calling {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_fd]{\emph{\code{dma\_buf\_fd()}}}}.

\item {} 
Userspace passes this file-descriptors to all drivers it wants this buffer
to share with: First the filedescriptor is converted to a {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{\code{dma\_buf}}}} using
{\hyperref[driver\string-api/dma\string-buf:c.dma_buf_get]{\emph{\code{dma\_buf\_get()}}}}. Then the buffer is attached to the device using
{\hyperref[driver\string-api/dma\string-buf:c.dma_buf_attach]{\emph{\code{dma\_buf\_attach()}}}}.

Up to this stage the exporter is still free to migrate or reallocate the
backing storage.

\item {} 
Once the buffer is attached to all devices userspace can initiate DMA
access to the shared buffer. In the kernel this is done by calling
{\hyperref[driver\string-api/dma\string-buf:c.dma_buf_map_attachment]{\emph{\code{dma\_buf\_map\_attachment()}}}} and {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_unmap_attachment]{\emph{\code{dma\_buf\_unmap\_attachment()}}}}.

\item {} 
Once a driver is done with a shared buffer it needs to call
{\hyperref[driver\string-api/dma\string-buf:c.dma_buf_detach]{\emph{\code{dma\_buf\_detach()}}}} (after cleaning up any mappings) and then release the
reference acquired with dma\_buf\_get by calling {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_put]{\emph{\code{dma\_buf\_put()}}}}.

\end{enumerate}

For the detailed semantics exporters are expected to implement see
{\hyperref[driver\string-api/dma\string-buf:c.dma_buf_ops]{\emph{\code{dma\_buf\_ops}}}}.


\subsection{CPU Access to DMA Buffer Objects}
\label{driver-api/dma-buf:cpu-access-to-dma-buffer-objects}
There are mutliple reasons for supporting CPU access to a dma buffer object:
\begin{itemize}
\item {} 
Fallback operations in the kernel, for example when a device is connected
over USB and the kernel needs to shuffle the data around first before
sending it away. Cache coherency is handled by braketing any transactions
with calls to {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_begin_cpu_access]{\emph{\code{dma\_buf\_begin\_cpu\_access()}}}} and {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_end_cpu_access]{\emph{\code{dma\_buf\_end\_cpu\_access()}}}}
access.

To support dma\_buf objects residing in highmem cpu access is page-based
using an api similar to kmap. Accessing a dma\_buf is done in aligned chunks
of PAGE\_SIZE size. Before accessing a chunk it needs to be mapped, which
returns a pointer in kernel virtual address space. Afterwards the chunk
needs to be unmapped again. There is no limit on how often a given chunk
can be mapped and unmapped, i.e. the importer does not need to call
begin\_cpu\_access again before mapping the same chunk again.
\begin{description}
\item[{Interfaces::}] \leavevmode
void *dma\_buf\_kmap(struct dma\_buf *, unsigned long);
void dma\_buf\_kunmap(struct dma\_buf *, unsigned long, void *);

\end{description}

There are also atomic variants of these interfaces. Like for kmap they
facilitate non-blocking fast-paths. Neither the importer nor the exporter
(in the callback) is allowed to block when using these.
\begin{description}
\item[{Interfaces::}] \leavevmode
void *dma\_buf\_kmap\_atomic(struct dma\_buf *, unsigned long);
void dma\_buf\_kunmap\_atomic(struct dma\_buf *, unsigned long, void *);

\end{description}

For importers all the restrictions of using kmap apply, like the limited
supply of kmap\_atomic slots. Hence an importer shall only hold onto at
max 2 atomic dma\_buf kmaps at the same time (in any given process context).

dma\_buf kmap calls outside of the range specified in begin\_cpu\_access are
undefined. If the range is not PAGE\_SIZE aligned, kmap needs to succeed on
the partial chunks at the beginning and end but may return stale or bogus
data outside of the range (in these partial chunks).

Note that these calls need to always succeed. The exporter needs to
complete any preparations that might fail in begin\_cpu\_access.

For some cases the overhead of kmap can be too high, a vmap interface
is introduced. This interface should be used very carefully, as vmalloc
space is a limited resources on many architectures.
\begin{description}
\item[{Interfaces::}] \leavevmode
void *dma\_buf\_vmap(struct dma\_buf *dmabuf)
void dma\_buf\_vunmap(struct dma\_buf *dmabuf, void *vaddr)

\end{description}

The vmap call can fail if there is no vmap support in the exporter, or if
it runs out of vmalloc space. Fallback to kmap should be implemented. Note
that the dma-buf layer keeps a reference count for all vmap access and
calls down into the exporter's vmap function only when no vmapping exists,
and only unmaps it once. Protection against concurrent vmap/vunmap calls is
provided by taking the dma\_buf-\textgreater{}lock mutex.

\item {} 
For full compatibility on the importer side with existing userspace
interfaces, which might already support mmap'ing buffers. This is needed in
many processing pipelines (e.g. feeding a software rendered image into a
hardware pipeline, thumbnail creation, snapshots, ...). Also, Android's ION
framework already supported this and for DMA buffer file descriptors to
replace ION buffers mmap support was needed.

There is no special interfaces, userspace simply calls mmap on the dma-buf
fd. But like for CPU access there's a need to braket the actual access,
which is handled by the ioctl (DMA\_BUF\_IOCTL\_SYNC). Note that
DMA\_BUF\_IOCTL\_SYNC can fail with -EAGAIN or -EINTR, in which case it must
be restarted.

Some systems might need some sort of cache coherency management e.g. when
CPU and GPU domains are being accessed through dma-buf at the same time.
To circumvent this problem there are begin/end coherency markers, that
forward directly to existing dma-buf device drivers vfunc hooks. Userspace
can make use of those markers through the DMA\_BUF\_IOCTL\_SYNC ioctl. The
sequence would be used like following:
\begin{quote}
\begin{itemize}
\item {} 
mmap dma-buf fd

\item {} 
for each drawing/upload cycle in CPU 1. SYNC\_START ioctl, 2. read/write
to mmap area 3. SYNC\_END ioctl. This can be repeated as often as you
want (with the new data being consumed by say the GPU or the scanout
device)

\item {} 
munmap once you don't need the buffer any more

\end{itemize}

For correctness and optimal performance, it is always required to use
SYNC\_START and SYNC\_END before and after, respectively, when accessing the
mapped address. Userspace cannot rely on coherent access, even when there
are systems where it just works without calling these ioctls.
\end{quote}

\item {} 
And as a CPU fallback in userspace processing pipelines.

Similar to the motivation for kernel cpu access it is again important that
the userspace code of a given importing subsystem can use the same
interfaces with a imported dma-buf buffer object as with a native buffer
object. This is especially important for drm where the userspace part of
contemporary OpenGL, X, and other drivers is huge, and reworking them to
use a different way to mmap a buffer rather invasive.

The assumption in the current dma-buf interfaces is that redirecting the
initial mmap is all that's needed. A survey of some of the existing
subsystems shows that no driver seems to do any nefarious thing like
syncing up with outstanding asynchronous processing on the device or
allocating special resources at fault time. So hopefully this is good
enough, since adding interfaces to intercept pagefaults and allow pte
shootdowns would increase the complexity quite a bit.
\begin{description}
\item[{Interface::}] \leavevmode\begin{description}
\item[{int dma\_buf\_mmap(struct dma\_buf *, struct vm\_area\_struct *,}] \leavevmode
unsigned long);

\end{description}

\end{description}

If the importing subsystem simply provides a special-purpose mmap call to
set up a mapping in userspace, calling do\_mmap with dma\_buf-\textgreater{}file will
equally achieve that for a dma-buf object.

\end{itemize}


\subsection{Fence Poll Support}
\label{driver-api/dma-buf:fence-poll-support}
To support cross-device and cross-driver synchronization of buffer access
implicit fences (represented internally in the kernel with \code{struct fence}) can
be attached to a {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{\code{dma\_buf}}}}. The glue for that and a few related things are
provided in the {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{\code{reservation\_object}}}} structure.

Userspace can query the state of these implicitly tracked fences using \code{poll()}
and related system calls:
\begin{itemize}
\item {} 
Checking for EPOLLIN, i.e. read access, can be use to query the state of the
most recent write or exclusive fence.

\item {} 
Checking for EPOLLOUT, i.e. write access, can be used to query the state of
all attached fences, shared and exclusive ones.

\end{itemize}

Note that this only signals the completion of the respective fences, i.e. the
DMA transfers are complete. Cache flushing and any other necessary
preparations before CPU access can begin still need to happen.


\subsection{Kernel Functions and Structures Reference}
\label{driver-api/dma-buf:kernel-functions-and-structures-reference}\index{dma\_buf\_export (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_export}\pysiglinewithargsret{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{dma\_buf}}} * \bfcode{dma\_buf\_export}}{const struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_export_info]{\emph{dma\_buf\_export\_info}}} *\emph{ exp\_info}}{}
Creates a new dma\_buf, and associates an anon file with this buffer, so it can be exported. Also connect the allocator specific data and ops to the buffer. Additionally, provide a name string for exporter; useful in debugging.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct dma\_buf\_export\_info * exp\_info}}] \leavevmode
{[}in{]}    holds all the export related information provided
by the exporter. see {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_export_info]{\emph{\code{struct dma\_buf\_export\_info}}}}
for further details.

\end{description}

\textbf{Description}

Returns, on success, a newly created dma\_buf object, which wraps the
supplied private data and operations for dma\_buf\_ops. On either missing
ops, or error in allocating struct dma\_buf, will return negative error.

For most cases the easiest way to create \textbf{exp\_info} is through the
\code{DEFINE\_DMA\_BUF\_EXPORT\_INFO} macro.
\index{dma\_buf\_fd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_fd}\pysiglinewithargsret{int \bfcode{dma\_buf\_fd}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{dma\_buf}}} *\emph{ dmabuf}, int\emph{ flags}}{}
returns a file descriptor for the given dma\_buf

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_buf * dmabuf}}] \leavevmode
{[}in{]}    pointer to dma\_buf for which fd is required.

\item[{\code{int flags}}] \leavevmode
{[}in{]}    flags to give to fd

\end{description}

\textbf{Description}

On success, returns an associated `fd'. Else, returns error.
\index{dma\_buf\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_get}\pysiglinewithargsret{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{dma\_buf}}} * \bfcode{dma\_buf\_get}}{int\emph{ fd}}{}
returns the dma\_buf structure related to an fd

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int fd}}] \leavevmode
{[}in{]}    fd associated with the dma\_buf to be returned

\end{description}

\textbf{Description}

On success, returns the dma\_buf structure associated with an fd; uses
file's refcounting done by fget to increase refcount. returns ERR\_PTR
otherwise.
\index{dma\_buf\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_put}\pysiglinewithargsret{void \bfcode{dma\_buf\_put}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{dma\_buf}}} *\emph{ dmabuf}}{}
decreases refcount of the buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_buf * dmabuf}}] \leavevmode
{[}in{]}    buffer to reduce refcount of

\end{description}

\textbf{Description}

Uses file's refcounting done implicitly by \code{fput()}.

If, as a result of this call, the refcount becomes 0, the `release' file
operation related to this fd is called. It calls {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_ops]{\emph{\code{dma\_buf\_ops.release}}}} vfunc
in turn, and frees the memory allocated for dmabuf when exported.
\index{dma\_buf\_attach (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_attach}\pysiglinewithargsret{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_attachment]{\emph{dma\_buf\_attachment}}} * \bfcode{dma\_buf\_attach}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{dma\_buf}}} *\emph{ dmabuf}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
Add the device to dma\_buf's attachments list; optionally, calls \code{attach()} of dma\_buf\_ops to allow device-specific attach functionality

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_buf * dmabuf}}] \leavevmode
{[}in{]}    buffer to attach device to.

\item[{\code{struct device * dev}}] \leavevmode
{[}in{]}    device to be attached.

\end{description}

\textbf{Description}

Returns struct dma\_buf\_attachment pointer for this attachment. Attachments
must be cleaned up by calling {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_detach]{\emph{\code{dma\_buf\_detach()}}}}.

\textbf{Return}

A pointer to newly created {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_attachment]{\emph{\code{dma\_buf\_attachment}}}} on success, or a negative
error code wrapped into a pointer on failure.

Note that this can fail if the backing storage of \textbf{dmabuf} is in a place not
accessible to \textbf{dev}, and cannot be moved to a more suitable place. This is
indicated with the error code -EBUSY.
\index{dma\_buf\_detach (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_detach}\pysiglinewithargsret{void \bfcode{dma\_buf\_detach}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{dma\_buf}}} *\emph{ dmabuf}, struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_attachment]{\emph{dma\_buf\_attachment}}} *\emph{ attach}}{}
Remove the given attachment from dmabuf's attachments list; optionally calls \code{detach()} of dma\_buf\_ops for device-specific detach

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_buf * dmabuf}}] \leavevmode
{[}in{]}    buffer to detach from.

\item[{\code{struct dma\_buf\_attachment * attach}}] \leavevmode
{[}in{]}    attachment to be detached; is free'd after this call.

\end{description}

\textbf{Description}

Clean up a device attachment obtained by calling {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_attach]{\emph{\code{dma\_buf\_attach()}}}}.
\index{dma\_buf\_map\_attachment (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_map_attachment}\pysiglinewithargsret{struct sg\_table * \bfcode{dma\_buf\_map\_attachment}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_attachment]{\emph{dma\_buf\_attachment}}} *\emph{ attach}, enum dma\_data\_direction\emph{ direction}}{}
Returns the scatterlist table of the attachment; mapped into \_device\_ address space. Is a wrapper for \code{map\_dma\_buf()} of the dma\_buf\_ops.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_buf\_attachment * attach}}] \leavevmode
{[}in{]}    attachment whose scatterlist is to be returned

\item[{\code{enum dma\_data\_direction direction}}] \leavevmode
{[}in{]}    direction of DMA transfer

\end{description}

\textbf{Description}

Returns sg\_table containing the scatterlist to be returned; returns ERR\_PTR
on error. May return -EINTR if it is interrupted by a signal.

A mapping must be unmapped by using {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_unmap_attachment]{\emph{\code{dma\_buf\_unmap\_attachment()}}}}. Note that
the underlying backing storage is pinned for as long as a mapping exists,
therefore users/importers should not hold onto a mapping for undue amounts of
time.
\index{dma\_buf\_unmap\_attachment (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_unmap_attachment}\pysiglinewithargsret{void \bfcode{dma\_buf\_unmap\_attachment}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_attachment]{\emph{dma\_buf\_attachment}}} *\emph{ attach}, struct sg\_table *\emph{ sg\_table}, enum dma\_data\_direction\emph{ direction}}{}
unmaps and decreases usecount of the buffer;might deallocate the scatterlist associated. Is a wrapper for \code{unmap\_dma\_buf()} of dma\_buf\_ops.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_buf\_attachment * attach}}] \leavevmode
{[}in{]}    attachment to unmap buffer from

\item[{\code{struct sg\_table * sg\_table}}] \leavevmode
{[}in{]}    scatterlist info of the buffer to unmap

\item[{\code{enum dma\_data\_direction direction}}] \leavevmode
{[}in{]}    direction of DMA transfer

\end{description}

\textbf{Description}

This unmaps a DMA mapping for \textbf{attached} obtained by {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_map_attachment]{\emph{\code{dma\_buf\_map\_attachment()}}}}.
\index{dma\_buf\_begin\_cpu\_access (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_begin_cpu_access}\pysiglinewithargsret{int \bfcode{dma\_buf\_begin\_cpu\_access}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{dma\_buf}}} *\emph{ dmabuf}, enum dma\_data\_direction\emph{ direction}}{}
Must be called before accessing a dma\_buf from the cpu in the kernel context. Calls begin\_cpu\_access to allow exporter-specific preparations. Coherency is only guaranteed in the specified range for the specified access direction.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_buf * dmabuf}}] \leavevmode
{[}in{]}    buffer to prepare cpu access for.

\item[{\code{enum dma\_data\_direction direction}}] \leavevmode
{[}in{]}    length of range for cpu access.

\end{description}

\textbf{Description}

After the cpu access is complete the caller should call
{\hyperref[driver\string-api/dma\string-buf:c.dma_buf_end_cpu_access]{\emph{\code{dma\_buf\_end\_cpu\_access()}}}}. Only when cpu access is braketed by both calls is
it guaranteed to be coherent with other DMA access.

Can return negative error values, returns 0 on success.
\index{dma\_buf\_end\_cpu\_access (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_end_cpu_access}\pysiglinewithargsret{int \bfcode{dma\_buf\_end\_cpu\_access}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{dma\_buf}}} *\emph{ dmabuf}, enum dma\_data\_direction\emph{ direction}}{}
Must be called after accessing a dma\_buf from the cpu in the kernel context. Calls end\_cpu\_access to allow exporter-specific actions. Coherency is only guaranteed in the specified range for the specified access direction.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_buf * dmabuf}}] \leavevmode
{[}in{]}    buffer to complete cpu access for.

\item[{\code{enum dma\_data\_direction direction}}] \leavevmode
{[}in{]}    length of range for cpu access.

\end{description}

\textbf{Description}

This terminates CPU access started with {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_begin_cpu_access]{\emph{\code{dma\_buf\_begin\_cpu\_access()}}}}.

Can return negative error values, returns 0 on success.
\index{dma\_buf\_kmap\_atomic (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_kmap_atomic}\pysiglinewithargsret{void * \bfcode{dma\_buf\_kmap\_atomic}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{dma\_buf}}} *\emph{ dmabuf}, unsigned long\emph{ page\_num}}{}
Map a page of the buffer object into kernel address space. The same restrictions as for kmap\_atomic and friends apply.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_buf * dmabuf}}] \leavevmode
{[}in{]}    buffer to map page from.

\item[{\code{unsigned long page\_num}}] \leavevmode
{[}in{]}    page in PAGE\_SIZE units to map.

\end{description}

\textbf{Description}

This call must always succeed, any necessary preparations that might fail
need to be done in begin\_cpu\_access.
\index{dma\_buf\_kunmap\_atomic (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_kunmap_atomic}\pysiglinewithargsret{void \bfcode{dma\_buf\_kunmap\_atomic}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{dma\_buf}}} *\emph{ dmabuf}, unsigned long\emph{ page\_num}, void *\emph{ vaddr}}{}
Unmap a page obtained by dma\_buf\_kmap\_atomic.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_buf * dmabuf}}] \leavevmode
{[}in{]}    buffer to unmap page from.

\item[{\code{unsigned long page\_num}}] \leavevmode
{[}in{]}    page in PAGE\_SIZE units to unmap.

\item[{\code{void * vaddr}}] \leavevmode
{[}in{]}    kernel space pointer obtained from dma\_buf\_kmap\_atomic.

\end{description}

\textbf{Description}

This call must always succeed.
\index{dma\_buf\_kmap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_kmap}\pysiglinewithargsret{void * \bfcode{dma\_buf\_kmap}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{dma\_buf}}} *\emph{ dmabuf}, unsigned long\emph{ page\_num}}{}
Map a page of the buffer object into kernel address space. The same restrictions as for kmap and friends apply.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_buf * dmabuf}}] \leavevmode
{[}in{]}    buffer to map page from.

\item[{\code{unsigned long page\_num}}] \leavevmode
{[}in{]}    page in PAGE\_SIZE units to map.

\end{description}

\textbf{Description}

This call must always succeed, any necessary preparations that might fail
need to be done in begin\_cpu\_access.
\index{dma\_buf\_kunmap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_kunmap}\pysiglinewithargsret{void \bfcode{dma\_buf\_kunmap}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{dma\_buf}}} *\emph{ dmabuf}, unsigned long\emph{ page\_num}, void *\emph{ vaddr}}{}
Unmap a page obtained by dma\_buf\_kmap.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_buf * dmabuf}}] \leavevmode
{[}in{]}    buffer to unmap page from.

\item[{\code{unsigned long page\_num}}] \leavevmode
{[}in{]}    page in PAGE\_SIZE units to unmap.

\item[{\code{void * vaddr}}] \leavevmode
{[}in{]}    kernel space pointer obtained from dma\_buf\_kmap.

\end{description}

\textbf{Description}

This call must always succeed.
\index{dma\_buf\_mmap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_mmap}\pysiglinewithargsret{int \bfcode{dma\_buf\_mmap}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{dma\_buf}}} *\emph{ dmabuf}, struct vm\_area\_struct *\emph{ vma}, unsigned long\emph{ pgoff}}{}
Setup up a userspace mmap with the given vma

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_buf * dmabuf}}] \leavevmode
{[}in{]}    buffer that should back the vma

\item[{\code{struct vm\_area\_struct * vma}}] \leavevmode
{[}in{]}    vma for the mmap

\item[{\code{unsigned long pgoff}}] \leavevmode
{[}in{]}    offset in pages where this mmap should start within the
dma-buf buffer.

\end{description}

\textbf{Description}

This function adjusts the passed in vma so that it points at the file of the
dma\_buf operation. It also adjusts the starting pgoff and does bounds
checking on the size of the vma. Then it calls the exporters mmap function to
set up the mapping.

Can return negative error values, returns 0 on success.
\index{dma\_buf\_vmap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_vmap}\pysiglinewithargsret{void * \bfcode{dma\_buf\_vmap}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{dma\_buf}}} *\emph{ dmabuf}}{}
Create virtual mapping for the buffer object into kernel address space. Same restrictions as for vmap and friends apply.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_buf * dmabuf}}] \leavevmode
{[}in{]}    buffer to vmap

\end{description}

\textbf{Description}

This call may fail due to lack of virtual mapping address space.
These calls are optional in drivers. The intended use for them
is for mapping objects linear in kernel space for high use objects.
Please attempt to use kmap/kunmap before thinking about these interfaces.

Returns NULL on error.
\index{dma\_buf\_vunmap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_vunmap}\pysiglinewithargsret{void \bfcode{dma\_buf\_vunmap}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{dma\_buf}}} *\emph{ dmabuf}, void *\emph{ vaddr}}{}
Unmap a vmap obtained by dma\_buf\_vmap.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_buf * dmabuf}}] \leavevmode
{[}in{]}    buffer to vunmap

\item[{\code{void * vaddr}}] \leavevmode
{[}in{]}    vmap to vunmap

\end{description}
\index{dma\_buf\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_ops}\pysigline{struct \bfcode{dma\_buf\_ops}}
operations possible on struct dma\_buf

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dma\PYGZus{}buf\PYGZus{}ops \PYGZob{}
  int (*attach)(struct dma\PYGZus{}buf *, struct device *, struct dma\PYGZus{}buf\PYGZus{}attachment *);
  void (*detach)(struct dma\PYGZus{}buf *, struct dma\PYGZus{}buf\PYGZus{}attachment *);
  struct sg\PYGZus{}table * (*map\PYGZus{}dma\PYGZus{}buf)(struct dma\PYGZus{}buf\PYGZus{}attachment *, enum dma\PYGZus{}data\PYGZus{}direction);
  void (*unmap\PYGZus{}dma\PYGZus{}buf)(struct dma\PYGZus{}buf\PYGZus{}attachment *,struct sg\PYGZus{}table *, enum dma\PYGZus{}data\PYGZus{}direction);
  void (*release)(struct dma\PYGZus{}buf *);
  int (*begin\PYGZus{}cpu\PYGZus{}access)(struct dma\PYGZus{}buf *, enum dma\PYGZus{}data\PYGZus{}direction);
  int (*end\PYGZus{}cpu\PYGZus{}access)(struct dma\PYGZus{}buf *, enum dma\PYGZus{}data\PYGZus{}direction);
  void *(*map\PYGZus{}atomic)(struct dma\PYGZus{}buf *, unsigned long);
  void (*unmap\PYGZus{}atomic)(struct dma\PYGZus{}buf *, unsigned long, void *);
  void *(*map)(struct dma\PYGZus{}buf *, unsigned long);
  void (*unmap)(struct dma\PYGZus{}buf *, unsigned long, void *);
  int (*mmap)(struct dma\PYGZus{}buf *, struct vm\PYGZus{}area\PYGZus{}struct *vma);
  void *(*vmap)(struct dma\PYGZus{}buf *);
  void (*vunmap)(struct dma\PYGZus{}buf *, void *vaddr);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{attach}}] \leavevmode
This is called from {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_attach]{\emph{\code{dma\_buf\_attach()}}}} to make sure that a given
{\hyperref[driver\string-api/infrastructure:c.device]{\emph{\code{device}}}} can access the provided {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{\code{dma\_buf}}}}. Exporters which support
buffer objects in special locations like VRAM or device-specific
carveout areas should check whether the buffer could be move to
system memory (or directly accessed by the provided device), and
otherwise need to fail the attach operation.

The exporter should also in general check whether the current
allocation fullfills the DMA constraints of the new device. If this
is not the case, and the allocation cannot be moved, it should also
fail the attach operation.

Any exporter-private housekeeping data can be stored in the
{\hyperref[driver\string-api/dma\string-buf:c.dma_buf_attachment]{\emph{\code{dma\_buf\_attachment.priv}}}} pointer.

This callback is optional.

Returns:

0 on success, negative error code on failure. It might return -EBUSY
to signal that backing storage is already allocated and incompatible
with the requirements of requesting device.

\item[{\code{detach}}] \leavevmode
This is called by {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_detach]{\emph{\code{dma\_buf\_detach()}}}} to release a {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_attachment]{\emph{\code{dma\_buf\_attachment}}}}.
Provided so that exporters can clean up any housekeeping for an
{\hyperref[driver\string-api/dma\string-buf:c.dma_buf_attachment]{\emph{\code{dma\_buf\_attachment}}}}.

This callback is optional.

\item[{\code{map\_dma\_buf}}] \leavevmode
This is called by {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_map_attachment]{\emph{\code{dma\_buf\_map\_attachment()}}}} and is used to map a
shared {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{\code{dma\_buf}}}} into device address space, and it is mandatory. It
can only be called if \textbf{attach} has been called successfully. This
essentially pins the DMA buffer into place, and it cannot be moved
any more

This call may sleep, e.g. when the backing storage first needs to be
allocated, or moved to a location suitable for all currently attached
devices.

Note that any specific buffer attributes required for this function
should get added to device\_dma\_parameters accessible via
{\hyperref[driver\string-api/infrastructure:c.device]{\emph{\code{device.dma\_params}}}} from the {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_attachment]{\emph{\code{dma\_buf\_attachment}}}}. The \textbf{attach} callback
should also check these constraints.

If this is being called for the first time, the exporter can now
choose to scan through the list of attachments for this buffer,
collate the requirements of the attached devices, and choose an
appropriate backing storage for the buffer.

Based on enum dma\_data\_direction, it might be possible to have
multiple users accessing at the same time (for reading, maybe), or
any other kind of sharing that the exporter might wish to make
available to buffer-users.

Returns:

A \code{sg\_table} scatter list of or the backing storage of the DMA buffer,
already mapped into the device address space of the {\hyperref[driver\string-api/infrastructure:c.device]{\emph{\code{device}}}} attached
with the provided {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_attachment]{\emph{\code{dma\_buf\_attachment}}}}.

On failure, returns a negative error value wrapped into a pointer.
May also return -EINTR when a signal was received while being
blocked.

\item[{\code{unmap\_dma\_buf}}] \leavevmode
This is called by {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_unmap_attachment]{\emph{\code{dma\_buf\_unmap\_attachment()}}}} and should unmap and
release the \code{sg\_table} allocated in \textbf{map\_dma\_buf}, and it is mandatory.
It should also unpin the backing storage if this is the last mapping
of the DMA buffer, it the exporter supports backing storage
migration.

\item[{\code{release}}] \leavevmode
Called after the last dma\_buf\_put to release the {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{\code{dma\_buf}}}}, and
mandatory.

\item[{\code{begin\_cpu\_access}}] \leavevmode
This is called from {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_begin_cpu_access]{\emph{\code{dma\_buf\_begin\_cpu\_access()}}}} and allows the
exporter to ensure that the memory is actually available for cpu
access - the exporter might need to allocate or swap-in and pin the
backing storage. The exporter also needs to ensure that cpu access is
coherent for the access direction. The direction can be used by the
exporter to optimize the cache flushing, i.e. access with a different
direction (read instead of write) might return stale or even bogus
data (e.g. when the exporter needs to copy the data to temporary
storage).

This callback is optional.

FIXME: This is both called through the DMA\_BUF\_IOCTL\_SYNC command
from userspace (where storage shouldn't be pinned to avoid handing
de-factor mlock rights to userspace) and for the kernel-internal
users of the various kmap interfaces, where the backing storage must
be pinned to guarantee that the atomic kmap calls can succeed. Since
there's no in-kernel users of the kmap interfaces yet this isn't a
real problem.

Returns:

0 on success or a negative error code on failure. This can for
example fail when the backing storage can't be allocated. Can also
return -ERESTARTSYS or -EINTR when the call has been interrupted and
needs to be restarted.

\item[{\code{end\_cpu\_access}}] \leavevmode
This is called from {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_end_cpu_access]{\emph{\code{dma\_buf\_end\_cpu\_access()}}}} when the importer is
done accessing the CPU. The exporter can use this to flush caches and
unpin any resources pinned in \textbf{begin\_cpu\_access}.
The result of any dma\_buf kmap calls after end\_cpu\_access is
undefined.

This callback is optional.

Returns:

0 on success or a negative error code on failure. Can return
-ERESTARTSYS or -EINTR when the call has been interrupted and needs
to be restarted.

\item[{\code{map\_atomic}}] \leavevmode
maps a page from the buffer into kernel address
space, users may not block until the subsequent unmap call.
This callback must not sleep.

\item[{\code{unmap\_atomic}}] \leavevmode
{[}optional{]} unmaps a atomically mapped page from the buffer.
This Callback must not sleep.

\item[{\code{map}}] \leavevmode
maps a page from the buffer into kernel address space.

\item[{\code{unmap}}] \leavevmode
{[}optional{]} unmaps a page from the buffer.

\item[{\code{mmap}}] \leavevmode
This callback is used by the {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_mmap]{\emph{\code{dma\_buf\_mmap()}}}} function

Note that the mapping needs to be incoherent, userspace is expected
to braket CPU access using the DMA\_BUF\_IOCTL\_SYNC interface.

Because dma-buf buffers have invariant size over their lifetime, the
dma-buf core checks whether a vma is too large and rejects such
mappings. The exporter hence does not need to duplicate this check.
Drivers do not need to check this themselves.

If an exporter needs to manually flush caches and hence needs to fake
coherency for mmap support, it needs to be able to zap all the ptes
pointing at the backing storage. Now linux mm needs a struct
address\_space associated with the struct file stored in vma-\textgreater{}vm\_file
to do that with the function unmap\_mapping\_range. But the dma\_buf
framework only backs every dma\_buf fd with the anon\_file struct file,
i.e. all dma\_bufs share the same file.

Hence exporters need to setup their own file (and address\_space)
association by setting vma-\textgreater{}vm\_file and adjusting vma-\textgreater{}vm\_pgoff in
the dma\_buf mmap callback. In the specific case of a gem driver the
exporter could use the shmem file already provided by gem (and set
vm\_pgoff = 0). Exporters can then zap ptes by unmapping the
corresponding range of the struct address\_space associated with their
own file.

This callback is optional.

Returns:

0 on success or a negative error code on failure.

\item[{\code{vmap}}] \leavevmode
{[}optional{]} creates a virtual mapping for the buffer into kernel
address space. Same restrictions as for vmap and friends apply.

\item[{\code{vunmap}}] \leavevmode
{[}optional{]} unmaps a vmap from the buffer

\end{description}
\index{dma\_buf (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf}\pysigline{struct \bfcode{dma\_buf}}
shared buffer object

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dma\PYGZus{}buf \PYGZob{}
  size\PYGZus{}t size;
  struct file *file;
  struct list\PYGZus{}head attachments;
  const struct dma\PYGZus{}buf\PYGZus{}ops *ops;
  struct mutex lock;
  unsigned vmapping\PYGZus{}counter;
  void *vmap\PYGZus{}ptr;
  const char *exp\PYGZus{}name;
  struct module *owner;
  struct list\PYGZus{}head list\PYGZus{}node;
  void *priv;
  struct reservation\PYGZus{}object *resv;
  wait\PYGZus{}queue\PYGZus{}head\PYGZus{}t poll;
  struct dma\PYGZus{}buf\PYGZus{}poll\PYGZus{}cb\PYGZus{}t \PYGZob{}
    struct dma\PYGZus{}fence\PYGZus{}cb cb;
    wait\PYGZus{}queue\PYGZus{}head\PYGZus{}t *poll;
    \PYGZus{}\PYGZus{}poll\PYGZus{}t active;
  \PYGZcb{} cb\PYGZus{}excl, cb\PYGZus{}shared;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{size}}] \leavevmode
size of the buffer

\item[{\code{file}}] \leavevmode
file pointer used for sharing buffers across, and for refcounting.

\item[{\code{attachments}}] \leavevmode
list of dma\_buf\_attachment that denotes all devices attached.

\item[{\code{ops}}] \leavevmode
dma\_buf\_ops associated with this buffer object.

\item[{\code{lock}}] \leavevmode
used internally to serialize list manipulation, attach/detach and vmap/unmap

\item[{\code{vmapping\_counter}}] \leavevmode
used internally to refcnt the vmaps

\item[{\code{vmap\_ptr}}] \leavevmode
the current vmap ptr if vmapping\_counter \textgreater{} 0

\item[{\code{exp\_name}}] \leavevmode
name of the exporter; useful for debugging.

\item[{\code{owner}}] \leavevmode
pointer to exporter module; used for refcounting when exporter is a
kernel module.

\item[{\code{list\_node}}] \leavevmode
node for dma\_buf accounting and debugging.

\item[{\code{priv}}] \leavevmode
exporter specific private data for this buffer object.

\item[{\code{resv}}] \leavevmode
reservation object linked to this dma-buf

\item[{\code{poll}}] \leavevmode
for userspace poll support

\item[{\code{cb\_excl}}] \leavevmode
for userspace poll support

\item[{\code{cb\_shared}}] \leavevmode
for userspace poll support

\end{description}

\textbf{Description}

This represents a shared buffer, created by calling {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_export]{\emph{\code{dma\_buf\_export()}}}}. The
userspace representation is a normal file descriptor, which can be created by
calling {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_fd]{\emph{\code{dma\_buf\_fd()}}}}.

Shared dma buffers are reference counted using {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_put]{\emph{\code{dma\_buf\_put()}}}} and
{\hyperref[driver\string-api/dma\string-buf:c.get_dma_buf]{\emph{\code{get\_dma\_buf()}}}}.

Device DMA access is handled by the separate {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_attachment]{\emph{\code{struct dma\_buf\_attachment}}}}.
\index{dma\_buf\_attachment (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_attachment}\pysigline{struct \bfcode{dma\_buf\_attachment}}
holds device-buffer attachment data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dma\PYGZus{}buf\PYGZus{}attachment \PYGZob{}
  struct dma\PYGZus{}buf *dmabuf;
  struct device *dev;
  struct list\PYGZus{}head node;
  void *priv;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dmabuf}}] \leavevmode
buffer for this attachment.

\item[{\code{dev}}] \leavevmode
device attached to the buffer.

\item[{\code{node}}] \leavevmode
list of dma\_buf\_attachment.

\item[{\code{priv}}] \leavevmode
exporter specific attachment data.

\end{description}

\textbf{Description}

This structure holds the attachment information between the dma\_buf buffer
and its user device(s). The list contains one attachment struct per device
attached to the buffer.

An attachment is created by calling {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_attach]{\emph{\code{dma\_buf\_attach()}}}}, and released again by
calling {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_detach]{\emph{\code{dma\_buf\_detach()}}}}. The DMA mapping itself needed to initiate a
transfer is created by {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_map_attachment]{\emph{\code{dma\_buf\_map\_attachment()}}}} and freed again by calling
{\hyperref[driver\string-api/dma\string-buf:c.dma_buf_unmap_attachment]{\emph{\code{dma\_buf\_unmap\_attachment()}}}}.
\index{dma\_buf\_export\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_buf_export_info}\pysigline{struct \bfcode{dma\_buf\_export\_info}}
holds information needed to export a dma\_buf

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dma\PYGZus{}buf\PYGZus{}export\PYGZus{}info \PYGZob{}
  const char *exp\PYGZus{}name;
  struct module *owner;
  const struct dma\PYGZus{}buf\PYGZus{}ops *ops;
  size\PYGZus{}t size;
  int flags;
  struct reservation\PYGZus{}object *resv;
  void *priv;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{exp\_name}}] \leavevmode
name of the exporter - useful for debugging.

\item[{\code{owner}}] \leavevmode
pointer to exporter module - used for refcounting kernel module

\item[{\code{ops}}] \leavevmode
Attach allocator-defined dma buf ops to the new buffer

\item[{\code{size}}] \leavevmode
Size of the buffer

\item[{\code{flags}}] \leavevmode
mode flags for the file

\item[{\code{resv}}] \leavevmode
reservation-object, NULL to allocate default one

\item[{\code{priv}}] \leavevmode
Attach private data of allocator to this buffer

\end{description}

\textbf{Description}

This structure holds the information required to export the buffer. Used
with {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_export]{\emph{\code{dma\_buf\_export()}}}} only.
\index{DEFINE\_DMA\_BUF\_EXPORT\_INFO (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.DEFINE_DMA_BUF_EXPORT_INFO}\pysiglinewithargsret{\bfcode{DEFINE\_DMA\_BUF\_EXPORT\_INFO}}{\emph{name}}{}
helper macro for exporters

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{name}}] \leavevmode
export-info name

\end{description}

\textbf{Description}

DEFINE\_DMA\_BUF\_EXPORT\_INFO macro defines the {\hyperref[driver\string-api/dma\string-buf:c.dma_buf_export_info]{\emph{\code{struct dma\_buf\_export\_info}}}},
zeroes it out and pre-populates exp\_name in it.
\index{get\_dma\_buf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.get_dma_buf}\pysiglinewithargsret{void \bfcode{get\_dma\_buf}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{dma\_buf}}} *\emph{ dmabuf}}{}
convenience wrapper for get\_file.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_buf * dmabuf}}] \leavevmode
{[}in{]}    pointer to dma\_buf

\end{description}

\textbf{Description}

Increments the reference count on the dma-buf, needed in case of drivers
that either need to create additional references to the dmabuf on the
kernel side.  For example, an exporter that needs to keep a dmabuf ptr
so that subsequent exports don't create a new dmabuf.


\section{Reservation Objects}
\label{driver-api/dma-buf:reservation-objects}
The reservation object provides a mechanism to manage shared and
exclusive fences associated with a buffer.  A reservation object
can have attached one exclusive fence (normally associated with
write operations) or N shared fences (read operations).  The RCU
mechanism is used to protect read access to fences from locked
write-side updates.
\index{reservation\_object\_reserve\_shared (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object_reserve_shared}\pysiglinewithargsret{int \bfcode{reservation\_object\_reserve\_shared}}{struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{reservation\_object}}} *\emph{ obj}}{}
Reserve space to add a shared fence to a reservation\_object.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct reservation\_object * obj}}] \leavevmode
reservation object

\end{description}

\textbf{Description}

Should be called before {\hyperref[driver\string-api/dma\string-buf:c.reservation_object_add_shared_fence]{\emph{\code{reservation\_object\_add\_shared\_fence()}}}}.  Must
be called with obj-\textgreater{}lock held.

RETURNS
Zero for success, or -errno
\index{reservation\_object\_add\_shared\_fence (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object_add_shared_fence}\pysiglinewithargsret{void \bfcode{reservation\_object\_add\_shared\_fence}}{struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{reservation\_object}}} *\emph{ obj}, struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}}{}
Add a fence to a shared slot

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct reservation\_object * obj}}] \leavevmode
the reservation object

\item[{\code{struct dma\_fence * fence}}] \leavevmode
the shared fence to add

\end{description}

\textbf{Description}

Add a fence to a shared slot, obj-\textgreater{}lock must be held, and
{\hyperref[driver\string-api/dma\string-buf:c.reservation_object_reserve_shared]{\emph{\code{reservation\_object\_reserve\_shared()}}}} has been called.
\index{reservation\_object\_add\_excl\_fence (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object_add_excl_fence}\pysiglinewithargsret{void \bfcode{reservation\_object\_add\_excl\_fence}}{struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{reservation\_object}}} *\emph{ obj}, struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}}{}
Add an exclusive fence.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct reservation\_object * obj}}] \leavevmode
the reservation object

\item[{\code{struct dma\_fence * fence}}] \leavevmode
the shared fence to add

\end{description}

\textbf{Description}

Add a fence to the exclusive slot.  The obj-\textgreater{}lock must be held.
\index{reservation\_object\_copy\_fences (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object_copy_fences}\pysiglinewithargsret{int \bfcode{reservation\_object\_copy\_fences}}{struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{reservation\_object}}} *\emph{ dst}, struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{reservation\_object}}} *\emph{ src}}{}
Copy all fences from src to dst.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct reservation\_object * dst}}] \leavevmode
the destination reservation object

\item[{\code{struct reservation\_object * src}}] \leavevmode
the source reservation object

\end{description}

\textbf{Description}

Copy all fences from src to dst. dst-lock must be held.
\index{reservation\_object\_get\_fences\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object_get_fences_rcu}\pysiglinewithargsret{int \bfcode{reservation\_object\_get\_fences\_rcu}}{struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{reservation\_object}}} *\emph{ obj}, struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} **\emph{ pfence\_excl}, unsigned *\emph{ pshared\_count}, struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} ***\emph{ pshared}}{}
Get an object's shared and exclusive fences without update side lock held

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct reservation\_object * obj}}] \leavevmode
the reservation object

\item[{\code{struct dma\_fence ** pfence\_excl}}] \leavevmode
the returned exclusive fence (or NULL)

\item[{\code{unsigned * pshared\_count}}] \leavevmode
the number of shared fences returned

\item[{\code{struct dma\_fence *** pshared}}] \leavevmode
the array of shared fence ptrs returned (array is krealloc'd to
the required size, and must be freed by caller)

\end{description}

\textbf{Description}

RETURNS
Zero or -errno
\index{reservation\_object\_wait\_timeout\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object_wait_timeout_rcu}\pysiglinewithargsret{long \bfcode{reservation\_object\_wait\_timeout\_rcu}}{struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{reservation\_object}}} *\emph{ obj}, bool\emph{ wait\_all}, bool\emph{ intr}, unsigned long\emph{ timeout}}{}
Wait on reservation's objects shared and/or exclusive fences.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct reservation\_object * obj}}] \leavevmode
the reservation object

\item[{\code{bool wait\_all}}] \leavevmode
if true, wait on all fences, else wait on just exclusive fence

\item[{\code{bool intr}}] \leavevmode
if true, do interruptible wait

\item[{\code{unsigned long timeout}}] \leavevmode
timeout value in jiffies or zero to return immediately

\end{description}

\textbf{Description}

RETURNS
Returns -ERESTARTSYS if interrupted, 0 if the wait timed out, or
greater than zer on success.
\index{reservation\_object\_test\_signaled\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object_test_signaled_rcu}\pysiglinewithargsret{bool \bfcode{reservation\_object\_test\_signaled\_rcu}}{struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{reservation\_object}}} *\emph{ obj}, bool\emph{ test\_all}}{}
Test if a reservation object's fences have been signaled.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct reservation\_object * obj}}] \leavevmode
the reservation object

\item[{\code{bool test\_all}}] \leavevmode
if true, test all fences, otherwise only test the exclusive
fence

\end{description}

\textbf{Description}

RETURNS
true if all fences signaled, else false
\index{reservation\_object\_list (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object_list}\pysigline{struct \bfcode{reservation\_object\_list}}
a list of shared fences

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct reservation\PYGZus{}object\PYGZus{}list \PYGZob{}
  struct rcu\PYGZus{}head rcu;
  u32 shared\PYGZus{}count, shared\PYGZus{}max;
  struct dma\PYGZus{}fence \PYGZus{}\PYGZus{}rcu *shared[];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{rcu}}] \leavevmode
for internal use

\item[{\code{shared\_count}}] \leavevmode
table of shared fences

\item[{\code{shared\_max}}] \leavevmode
for growing shared fence table

\item[{\code{shared}}] \leavevmode
shared fence table

\end{description}
\index{reservation\_object (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object}\pysigline{struct \bfcode{reservation\_object}}
a reservation object manages fences for a buffer

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct reservation\PYGZus{}object \PYGZob{}
  struct ww\PYGZus{}mutex lock;
  seqcount\PYGZus{}t seq;
  struct dma\PYGZus{}fence \PYGZus{}\PYGZus{}rcu *fence\PYGZus{}excl;
  struct reservation\PYGZus{}object\PYGZus{}list \PYGZus{}\PYGZus{}rcu *fence;
  struct reservation\PYGZus{}object\PYGZus{}list *staged;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{lock}}] \leavevmode
update side lock

\item[{\code{seq}}] \leavevmode
sequence count for managing RCU read-side synchronization

\item[{\code{fence\_excl}}] \leavevmode
the exclusive fence, if there is one currently

\item[{\code{fence}}] \leavevmode
list of current shared fences

\item[{\code{staged}}] \leavevmode
staged copy of shared fences for RCU updates

\end{description}
\index{reservation\_object\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object_init}\pysiglinewithargsret{void \bfcode{reservation\_object\_init}}{struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{reservation\_object}}} *\emph{ obj}}{}
initialize a reservation object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct reservation\_object * obj}}] \leavevmode
the reservation object

\end{description}
\index{reservation\_object\_fini (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object_fini}\pysiglinewithargsret{void \bfcode{reservation\_object\_fini}}{struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{reservation\_object}}} *\emph{ obj}}{}
destroys a reservation object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct reservation\_object * obj}}] \leavevmode
the reservation object

\end{description}
\index{reservation\_object\_get\_list (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object_get_list}\pysiglinewithargsret{struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object_list]{\emph{reservation\_object\_list}}} * \bfcode{reservation\_object\_get\_list}}{struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{reservation\_object}}} *\emph{ obj}}{}
get the reservation object's shared fence list, with update-side lock held

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct reservation\_object * obj}}] \leavevmode
the reservation object

\end{description}

\textbf{Description}

Returns the shared fence list.  Does NOT take references to
the fence.  The obj-\textgreater{}lock must be held.
\index{reservation\_object\_lock (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object_lock}\pysiglinewithargsret{int \bfcode{reservation\_object\_lock}}{struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{reservation\_object}}} *\emph{ obj}, struct ww\_acquire\_ctx *\emph{ ctx}}{}
lock the reservation object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct reservation\_object * obj}}] \leavevmode
the reservation object

\item[{\code{struct ww\_acquire\_ctx * ctx}}] \leavevmode
the locking context

\end{description}

\textbf{Description}

Locks the reservation object for exclusive access and modification. Note,
that the lock is only against other writers, readers will run concurrently
with a writer under RCU. The seqlock is used to notify readers if they
overlap with a writer.

As the reservation object may be locked by multiple parties in an
undefined order, a \#ww\_acquire\_ctx is passed to unwind if a cycle
is detected. See \code{ww\_mutex\_lock()} and \code{ww\_acquire\_init()}. A reservation
object may be locked by itself by passing NULL as \textbf{ctx}.
\index{reservation\_object\_lock\_interruptible (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object_lock_interruptible}\pysiglinewithargsret{int \bfcode{reservation\_object\_lock\_interruptible}}{struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{reservation\_object}}} *\emph{ obj}, struct ww\_acquire\_ctx *\emph{ ctx}}{}
lock the reservation object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct reservation\_object * obj}}] \leavevmode
the reservation object

\item[{\code{struct ww\_acquire\_ctx * ctx}}] \leavevmode
the locking context

\end{description}

\textbf{Description}

Locks the reservation object interruptible for exclusive access and
modification. Note, that the lock is only against other writers, readers
will run concurrently with a writer under RCU. The seqlock is used to
notify readers if they overlap with a writer.

As the reservation object may be locked by multiple parties in an
undefined order, a \#ww\_acquire\_ctx is passed to unwind if a cycle
is detected. See \code{ww\_mutex\_lock()} and \code{ww\_acquire\_init()}. A reservation
object may be locked by itself by passing NULL as \textbf{ctx}.
\index{reservation\_object\_trylock (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object_trylock}\pysiglinewithargsret{bool \bfcode{reservation\_object\_trylock}}{struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{reservation\_object}}} *\emph{ obj}}{}
trylock the reservation object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct reservation\_object * obj}}] \leavevmode
the reservation object

\end{description}

\textbf{Description}

Tries to lock the reservation object for exclusive access and modification.
Note, that the lock is only against other writers, readers will run
concurrently with a writer under RCU. The seqlock is used to notify readers
if they overlap with a writer.

Also note that since no context is provided, no deadlock protection is
possible.

Returns true if the lock was acquired, false otherwise.
\index{reservation\_object\_unlock (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object_unlock}\pysiglinewithargsret{void \bfcode{reservation\_object\_unlock}}{struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{reservation\_object}}} *\emph{ obj}}{}
unlock the reservation object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct reservation\_object * obj}}] \leavevmode
the reservation object

\end{description}

\textbf{Description}

Unlocks the reservation object following exclusive access.
\index{reservation\_object\_get\_excl (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object_get_excl}\pysiglinewithargsret{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} * \bfcode{reservation\_object\_get\_excl}}{struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{reservation\_object}}} *\emph{ obj}}{}
get the reservation object's exclusive fence, with update-side lock held

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct reservation\_object * obj}}] \leavevmode
the reservation object

\end{description}

\textbf{Description}

Returns the exclusive fence (if any).  Does NOT take a
reference.  The obj-\textgreater{}lock must be held.

RETURNS
The exclusive fence or NULL
\index{reservation\_object\_get\_excl\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.reservation_object_get_excl_rcu}\pysiglinewithargsret{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} * \bfcode{reservation\_object\_get\_excl\_rcu}}{struct {\hyperref[driver\string-api/dma\string-buf:c.reservation_object]{\emph{reservation\_object}}} *\emph{ obj}}{}
get the reservation object's exclusive fence, without lock held.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct reservation\_object * obj}}] \leavevmode
the reservation object

\end{description}

\textbf{Description}

If there is an exclusive fence, this atomically increments it's
reference count and returns it.

RETURNS
The exclusive fence or NULL if none


\section{DMA Fences}
\label{driver-api/dma-buf:dma-fences}\index{dma\_fence\_context\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_context_alloc}\pysiglinewithargsret{u64 \bfcode{dma\_fence\_context\_alloc}}{unsigned\emph{ num}}{}
allocate an array of fence contexts

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned num}}] \leavevmode
{[}in{]}    amount of contexts to allocate

\end{description}

\textbf{Description}

This function will return the first index of the number of fences allocated.
The fence context is used for setting fence-\textgreater{}context to a unique number.
\index{dma\_fence\_signal\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_signal_locked}\pysiglinewithargsret{int \bfcode{dma\_fence\_signal\_locked}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}}{}
signal completion of a fence

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
the fence to signal

\end{description}

\textbf{Description}

Signal completion for software callbacks on a fence, this will unblock
{\hyperref[driver\string-api/dma\string-buf:c.dma_fence_wait]{\emph{\code{dma\_fence\_wait()}}}} calls and run all the callbacks added with
{\hyperref[driver\string-api/dma\string-buf:c.dma_fence_add_callback]{\emph{\code{dma\_fence\_add\_callback()}}}}. Can be called multiple times, but since a fence
can only go from unsignaled to signaled state, it will only be effective
the first time.

Unlike dma\_fence\_signal, this function must be called with fence-\textgreater{}lock held.
\index{dma\_fence\_signal (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_signal}\pysiglinewithargsret{int \bfcode{dma\_fence\_signal}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}}{}
signal completion of a fence

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
the fence to signal

\end{description}

\textbf{Description}

Signal completion for software callbacks on a fence, this will unblock
{\hyperref[driver\string-api/dma\string-buf:c.dma_fence_wait]{\emph{\code{dma\_fence\_wait()}}}} calls and run all the callbacks added with
{\hyperref[driver\string-api/dma\string-buf:c.dma_fence_add_callback]{\emph{\code{dma\_fence\_add\_callback()}}}}. Can be called multiple times, but since a fence
can only go from unsignaled to signaled state, it will only be effective
the first time.
\index{dma\_fence\_wait\_timeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_wait_timeout}\pysiglinewithargsret{signed long \bfcode{dma\_fence\_wait\_timeout}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}, bool\emph{ intr}, signed long\emph{ timeout}}{}
sleep until the fence gets signaled or until timeout elapses

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
{[}in{]}    the fence to wait on

\item[{\code{bool intr}}] \leavevmode
{[}in{]}    if true, do an interruptible wait

\item[{\code{signed long timeout}}] \leavevmode
{[}in{]}    timeout value in jiffies, or MAX\_SCHEDULE\_TIMEOUT

\end{description}

\textbf{Description}

Returns -ERESTARTSYS if interrupted, 0 if the wait timed out, or the
remaining timeout in jiffies on success. Other error values may be
returned on custom implementations.

Performs a synchronous wait on this fence. It is assumed the caller
directly or indirectly (buf-mgr between reservation and committing)
holds a reference to the fence, otherwise the fence might be
freed before return, resulting in undefined behavior.
\index{dma\_fence\_enable\_sw\_signaling (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_enable_sw_signaling}\pysiglinewithargsret{void \bfcode{dma\_fence\_enable\_sw\_signaling}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}}{}
enable signaling on fence

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
{[}in{]}    the fence to enable

\end{description}

\textbf{Description}

this will request for sw signaling to be enabled, to make the fence
complete as soon as possible
\index{dma\_fence\_add\_callback (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_add_callback}\pysiglinewithargsret{int \bfcode{dma\_fence\_add\_callback}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}, struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence_cb]{\emph{dma\_fence\_cb}}} *\emph{ cb}, dma\_fence\_func\_t\emph{ func}}{}
add a callback to be called when the fence is signaled

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
{[}in{]}    the fence to wait on

\item[{\code{struct dma\_fence\_cb * cb}}] \leavevmode
{[}in{]}    the callback to register

\item[{\code{dma\_fence\_func\_t func}}] \leavevmode
{[}in{]}    the function to call

\end{description}

\textbf{Description}

cb will be initialized by dma\_fence\_add\_callback, no initialization
by the caller is required. Any number of callbacks can be registered
to a fence, but a callback can only be registered to one fence at a time.

Note that the callback can be called from an atomic context.  If
fence is already signaled, this function will return -ENOENT (and
\emph{not} call the callback)

Add a software callback to the fence. Same restrictions apply to
refcount as it does to dma\_fence\_wait, however the caller doesn't need to
keep a refcount to fence afterwards: when software access is enabled,
the creator of the fence is required to keep the fence alive until
after it signals with dma\_fence\_signal. The callback itself can be called
from irq context.

Returns 0 in case of success, -ENOENT if the fence is already signaled
and -EINVAL in case of error.
\index{dma\_fence\_get\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_get_status}\pysiglinewithargsret{int \bfcode{dma\_fence\_get\_status}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}}{}
returns the status upon completion

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
{[}in{]} the dma\_fence to query

\end{description}

\textbf{Description}

This wraps {\hyperref[driver\string-api/dma\string-buf:c.dma_fence_get_status_locked]{\emph{\code{dma\_fence\_get\_status\_locked()}}}} to return the error status
condition on a signaled fence. See {\hyperref[driver\string-api/dma\string-buf:c.dma_fence_get_status_locked]{\emph{\code{dma\_fence\_get\_status\_locked()}}}} for more
details.

Returns 0 if the fence has not yet been signaled, 1 if the fence has
been signaled without an error condition, or a negative error code
if the fence has been completed in err.
\index{dma\_fence\_remove\_callback (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_remove_callback}\pysiglinewithargsret{bool \bfcode{dma\_fence\_remove\_callback}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}, struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence_cb]{\emph{dma\_fence\_cb}}} *\emph{ cb}}{}
remove a callback from the signaling list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
{[}in{]}    the fence to wait on

\item[{\code{struct dma\_fence\_cb * cb}}] \leavevmode
{[}in{]}    the callback to remove

\end{description}

\textbf{Description}

Remove a previously queued callback from the fence. This function returns
true if the callback is successfully removed, or false if the fence has
already been signaled.

\emph{WARNING}:
Cancelling a callback should only be done if you really know what you're
doing, since deadlocks and race conditions could occur all too easily. For
this reason, it should only ever be done on hardware lockup recovery,
with a reference held to the fence.
\index{dma\_fence\_default\_wait (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_default_wait}\pysiglinewithargsret{signed long \bfcode{dma\_fence\_default\_wait}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}, bool\emph{ intr}, signed long\emph{ timeout}}{}
default sleep until the fence gets signaled or until timeout elapses

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
{[}in{]}    the fence to wait on

\item[{\code{bool intr}}] \leavevmode
{[}in{]}    if true, do an interruptible wait

\item[{\code{signed long timeout}}] \leavevmode
{[}in{]}    timeout value in jiffies, or MAX\_SCHEDULE\_TIMEOUT

\end{description}

\textbf{Description}

Returns -ERESTARTSYS if interrupted, 0 if the wait timed out, or the
remaining timeout in jiffies on success. If timeout is zero the value one is
returned if the fence is already signaled for consistency with other
functions taking a jiffies timeout.
\index{dma\_fence\_wait\_any\_timeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_wait_any_timeout}\pysiglinewithargsret{signed long \bfcode{dma\_fence\_wait\_any\_timeout}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} **\emph{ fences}, uint32\_t\emph{ count}, bool\emph{ intr}, signed long\emph{ timeout}, uint32\_t *\emph{ idx}}{}
sleep until any fence gets signaled or until timeout elapses

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence ** fences}}] \leavevmode
{[}in{]}    array of fences to wait on

\item[{\code{uint32\_t count}}] \leavevmode
{[}in{]}    number of fences to wait on

\item[{\code{bool intr}}] \leavevmode
{[}in{]}    if true, do an interruptible wait

\item[{\code{signed long timeout}}] \leavevmode
{[}in{]}    timeout value in jiffies, or MAX\_SCHEDULE\_TIMEOUT

\item[{\code{uint32\_t * idx}}] \leavevmode
{[}out{]}    the first signaled fence index, meaningful only on
positive return

\end{description}

\textbf{Description}

Returns -EINVAL on custom fence wait implementation, -ERESTARTSYS if
interrupted, 0 if the wait timed out, or the remaining timeout in jiffies
on success.

Synchronous waits for the first fence in the array to be signaled. The
caller needs to hold a reference to all fences in the array, otherwise a
fence might be freed before return, resulting in undefined behavior.
\index{dma\_fence\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_init}\pysiglinewithargsret{void \bfcode{dma\_fence\_init}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}, const struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence_ops]{\emph{dma\_fence\_ops}}} *\emph{ ops}, spinlock\_t *\emph{ lock}, u64\emph{ context}, unsigned\emph{ seqno}}{}
Initialize a custom fence.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
{[}in{]}    the fence to initialize

\item[{\code{const struct dma\_fence\_ops * ops}}] \leavevmode
{[}in{]}    the dma\_fence\_ops for operations on this fence

\item[{\code{spinlock\_t * lock}}] \leavevmode
{[}in{]}    the irqsafe spinlock to use for locking this fence

\item[{\code{u64 context}}] \leavevmode
{[}in{]}    the execution context this fence is run on

\item[{\code{unsigned seqno}}] \leavevmode
{[}in{]}    a linear increasing sequence number for this context

\end{description}

\textbf{Description}

Initializes an allocated fence, the caller doesn't have to keep its
refcount after committing with this fence, but it will need to hold a
refcount again if dma\_fence\_ops.enable\_signaling gets called. This can
be used for other implementing other types of fence.

context and seqno are used for easy comparison between fences, allowing
to check which fence is later by simply using dma\_fence\_later.
\index{dma\_fence (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence}\pysigline{struct \bfcode{dma\_fence}}
software synchronization primitive

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dma\PYGZus{}fence \PYGZob{}
  struct kref refcount;
  const struct dma\PYGZus{}fence\PYGZus{}ops *ops;
  struct rcu\PYGZus{}head rcu;
  struct list\PYGZus{}head cb\PYGZus{}list;
  spinlock\PYGZus{}t *lock;
  u64 context;
  unsigned seqno;
  unsigned long flags;
  ktime\PYGZus{}t timestamp;
  int error;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{refcount}}] \leavevmode
refcount for this fence

\item[{\code{ops}}] \leavevmode
dma\_fence\_ops associated with this fence

\item[{\code{rcu}}] \leavevmode
used for releasing fence with kfree\_rcu

\item[{\code{cb\_list}}] \leavevmode
list of all callbacks to call

\item[{\code{lock}}] \leavevmode
spin\_lock\_irqsave used for locking

\item[{\code{context}}] \leavevmode
execution context this fence belongs to, returned by
{\hyperref[driver\string-api/dma\string-buf:c.dma_fence_context_alloc]{\emph{\code{dma\_fence\_context\_alloc()}}}}

\item[{\code{seqno}}] \leavevmode
the sequence number of this fence inside the execution context,
can be compared to decide which fence would be signaled later.

\item[{\code{flags}}] \leavevmode
A mask of DMA\_FENCE\_FLAG\_* defined below

\item[{\code{timestamp}}] \leavevmode
Timestamp when the fence was signaled.

\item[{\code{error}}] \leavevmode
Optional, only valid if \textless{} 0, must be set before calling
dma\_fence\_signal, indicates that the fence has completed with an error.

\end{description}

\textbf{Description}

the flags member must be manipulated and read using the appropriate
atomic ops (bit\_*), so taking the spinlock will not be needed most
of the time.

DMA\_FENCE\_FLAG\_SIGNALED\_BIT - fence is already signaled
DMA\_FENCE\_FLAG\_TIMESTAMP\_BIT - timestamp recorded for fence signaling
DMA\_FENCE\_FLAG\_ENABLE\_SIGNAL\_BIT - enable\_signaling might have been called
DMA\_FENCE\_FLAG\_USER\_BITS - start of the unused bits, can be used by the
implementer of the fence for its own purposes. Can be used in different
ways by different fence implementers, so do not rely on this.

Since atomic bitops are used, this is not guaranteed to be the case.
Particularly, if the bit was set, but dma\_fence\_signal was called right
before this bit was set, it would have been able to set the
DMA\_FENCE\_FLAG\_SIGNALED\_BIT, before enable\_signaling was called.
Adding a check for DMA\_FENCE\_FLAG\_SIGNALED\_BIT after setting
DMA\_FENCE\_FLAG\_ENABLE\_SIGNAL\_BIT closes this race, and makes sure that
after dma\_fence\_signal was called, any enable\_signaling call will have either
been completed, or never called at all.
\index{dma\_fence\_cb (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_cb}\pysigline{struct \bfcode{dma\_fence\_cb}}
callback for dma\_fence\_add\_callback

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dma\PYGZus{}fence\PYGZus{}cb \PYGZob{}
  struct list\PYGZus{}head node;
  dma\PYGZus{}fence\PYGZus{}func\PYGZus{}t func;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{node}}] \leavevmode
used by dma\_fence\_add\_callback to append this struct to fence::cb\_list

\item[{\code{func}}] \leavevmode
dma\_fence\_func\_t to call

\end{description}

\textbf{Description}

This struct will be initialized by dma\_fence\_add\_callback, additional
data can be passed along by embedding dma\_fence\_cb in another struct.
\index{dma\_fence\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_ops}\pysigline{struct \bfcode{dma\_fence\_ops}}
operations implemented for fence

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dma\PYGZus{}fence\PYGZus{}ops \PYGZob{}
  const char * (*get\PYGZus{}driver\PYGZus{}name)(struct dma\PYGZus{}fence *fence);
  const char * (*get\PYGZus{}timeline\PYGZus{}name)(struct dma\PYGZus{}fence *fence);
  bool (*enable\PYGZus{}signaling)(struct dma\PYGZus{}fence *fence);
  bool (*signaled)(struct dma\PYGZus{}fence *fence);
  signed long (*wait)(struct dma\PYGZus{}fence *fence, bool intr, signed long timeout);
  void (*release)(struct dma\PYGZus{}fence *fence);
  int (*fill\PYGZus{}driver\PYGZus{}data)(struct dma\PYGZus{}fence *fence, void *data, int size);
  void (*fence\PYGZus{}value\PYGZus{}str)(struct dma\PYGZus{}fence *fence, char *str, int size);
  void (*timeline\PYGZus{}value\PYGZus{}str)(struct dma\PYGZus{}fence *fence, char *str, int size);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{get\_driver\_name}}] \leavevmode
returns the driver name.

\item[{\code{get\_timeline\_name}}] \leavevmode
return the name of the context this fence belongs to.

\item[{\code{enable\_signaling}}] \leavevmode
enable software signaling of fence.

\item[{\code{signaled}}] \leavevmode
{[}optional{]} peek whether the fence is signaled, can be null.

\item[{\code{wait}}] \leavevmode
custom wait implementation, or dma\_fence\_default\_wait.

\item[{\code{release}}] \leavevmode
{[}optional{]} called on destruction of fence, can be null

\item[{\code{fill\_driver\_data}}] \leavevmode
{[}optional{]} callback to fill in free-form debug info
Returns amount of bytes filled, or -errno.

\item[{\code{fence\_value\_str}}] \leavevmode
{[}optional{]} fills in the value of the fence as a string

\item[{\code{timeline\_value\_str}}] \leavevmode
{[}optional{]} fills in the current value of the timeline
as a string

\end{description}

\textbf{Description}

Notes on enable\_signaling:
For fence implementations that have the capability for hw-\textgreater{}hw
signaling, they can implement this op to enable the necessary
irqs, or insert commands into cmdstream, etc.  This is called
in the first \code{wait()} or \code{add\_callback()} path to let the fence
implementation know that there is another driver waiting on
the signal (ie. hw-\textgreater{}sw case).

This function can be called from atomic context, but not
from irq context, so normal spinlocks can be used.

A return value of false indicates the fence already passed,
or some failure occurred that made it impossible to enable
signaling. True indicates successful enabling.

fence-\textgreater{}error may be set in enable\_signaling, but only when false is
returned.

Calling dma\_fence\_signal before enable\_signaling is called allows
for a tiny race window in which enable\_signaling is called during,
before, or after dma\_fence\_signal. To fight this, it is recommended
that before enable\_signaling returns true an extra reference is
taken on the fence, to be released when the fence is signaled.
This will mean dma\_fence\_signal will still be called twice, but
the second time will be a noop since it was already signaled.

Notes on signaled:
May set fence-\textgreater{}error if returning true.

Notes on wait:
Must not be NULL, set to dma\_fence\_default\_wait for default implementation.
the dma\_fence\_default\_wait implementation should work for any fence, as long
as enable\_signaling works correctly.

Must return -ERESTARTSYS if the wait is intr = true and the wait was
interrupted, and remaining jiffies if fence has signaled, or 0 if wait
timed out. Can also return other error values on custom implementations,
which should be treated as if the fence is signaled. For example a hardware
lockup could be reported like that.

Notes on release:
Can be NULL, this function allows additional commands to run on
destruction of the fence. Can be called from irq context.
If pointer is set to NULL, kfree will get called instead.
\index{dma\_fence\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_put}\pysiglinewithargsret{void \bfcode{dma\_fence\_put}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}}{}
decreases refcount of the fence

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
{[}in{]}    fence to reduce refcount of

\end{description}
\index{dma\_fence\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_get}\pysiglinewithargsret{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} * \bfcode{dma\_fence\_get}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}}{}
increases refcount of the fence

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
{[}in{]}    fence to increase refcount of

\end{description}

\textbf{Description}

Returns the same fence, with refcount increased by 1.
\index{dma\_fence\_get\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_get_rcu}\pysiglinewithargsret{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} * \bfcode{dma\_fence\_get\_rcu}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}}{}
get a fence from a reservation\_object\_list with rcu read lock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
{[}in{]}    fence to increase refcount of

\end{description}

\textbf{Description}

Function returns NULL if no refcount could be obtained, or the fence.
\index{dma\_fence\_get\_rcu\_safe (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_get_rcu_safe}\pysiglinewithargsret{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} * \bfcode{dma\_fence\_get\_rcu\_safe}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} \_\_rcu **\emph{ fencep}}{}
acquire a reference to an RCU tracked fence

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence \_\_rcu ** fencep}}] \leavevmode
{[}in{]}    pointer to fence to increase refcount of

\end{description}

\textbf{Description}

Function returns NULL if no refcount could be obtained, or the fence.
This function handles acquiring a reference to a fence that may be
reallocated within the RCU grace period (such as with SLAB\_TYPESAFE\_BY\_RCU),
so long as the caller is using RCU on the pointer to the fence.

An alternative mechanism is to employ a seqlock to protect a bunch of
fences, such as used by struct reservation\_object. When using a seqlock,
the seqlock must be taken before and checked after a reference to the
fence is acquired (as shown here).

The caller is required to hold the RCU read lock.
\index{dma\_fence\_is\_signaled\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_is_signaled_locked}\pysiglinewithargsret{bool \bfcode{dma\_fence\_is\_signaled\_locked}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}}{}
Return an indication if the fence is signaled yet.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
{[}in{]}    the fence to check

\end{description}

\textbf{Description}

Returns true if the fence was already signaled, false if not. Since this
function doesn't enable signaling, it is not guaranteed to ever return
true if dma\_fence\_add\_callback, dma\_fence\_wait or
dma\_fence\_enable\_sw\_signaling haven't been called before.

This function requires fence-\textgreater{}lock to be held.
\index{dma\_fence\_is\_signaled (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_is_signaled}\pysiglinewithargsret{bool \bfcode{dma\_fence\_is\_signaled}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}}{}
Return an indication if the fence is signaled yet.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
{[}in{]}    the fence to check

\end{description}

\textbf{Description}

Returns true if the fence was already signaled, false if not. Since this
function doesn't enable signaling, it is not guaranteed to ever return
true if dma\_fence\_add\_callback, dma\_fence\_wait or
dma\_fence\_enable\_sw\_signaling haven't been called before.

It's recommended for seqno fences to call dma\_fence\_signal when the
operation is complete, it makes it possible to prevent issues from
wraparound between time of issue and time of use by checking the return
value of this function before calling hardware-specific wait instructions.
\index{\_\_dma\_fence\_is\_later (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.__dma_fence_is_later}\pysiglinewithargsret{bool \bfcode{\_\_dma\_fence\_is\_later}}{u32\emph{ f1}, u32\emph{ f2}}{}
return if f1 is chronologically later than f2

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u32 f1}}] \leavevmode
{[}in{]}    the first fence's seqno

\item[{\code{u32 f2}}] \leavevmode
{[}in{]}    the second fence's seqno from the same context

\end{description}

\textbf{Description}

Returns true if f1 is chronologically later than f2. Both fences must be
from the same context, since a seqno is not common across contexts.
\index{dma\_fence\_is\_later (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_is_later}\pysiglinewithargsret{bool \bfcode{dma\_fence\_is\_later}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ f1}, struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ f2}}{}
return if f1 is chronologically later than f2

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * f1}}] \leavevmode
{[}in{]}    the first fence from the same context

\item[{\code{struct dma\_fence * f2}}] \leavevmode
{[}in{]}    the second fence from the same context

\end{description}

\textbf{Description}

Returns true if f1 is chronologically later than f2. Both fences must be
from the same context, since a seqno is not re-used across contexts.
\index{dma\_fence\_later (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_later}\pysiglinewithargsret{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} * \bfcode{dma\_fence\_later}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ f1}, struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ f2}}{}
return the chronologically later fence

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * f1}}] \leavevmode
{[}in{]}    the first fence from the same context

\item[{\code{struct dma\_fence * f2}}] \leavevmode
{[}in{]}    the second fence from the same context

\end{description}

\textbf{Description}

Returns NULL if both fences are signaled, otherwise the fence that would be
signaled last. Both fences must be from the same context, since a seqno is
not re-used across contexts.
\index{dma\_fence\_get\_status\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_get_status_locked}\pysiglinewithargsret{int \bfcode{dma\_fence\_get\_status\_locked}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}}{}
returns the status upon completion

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
{[}in{]} the dma\_fence to query

\end{description}

\textbf{Description}

Drivers can supply an optional error status condition before they signal
the fence (to indicate whether the fence was completed due to an error
rather than success). The value of the status condition is only valid
if the fence has been signaled, {\hyperref[driver\string-api/dma\string-buf:c.dma_fence_get_status_locked]{\emph{\code{dma\_fence\_get\_status\_locked()}}}} first checks
the signal state before reporting the error status.

Returns 0 if the fence has not yet been signaled, 1 if the fence has
been signaled without an error condition, or a negative error code
if the fence has been completed in err.
\index{dma\_fence\_set\_error (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_set_error}\pysiglinewithargsret{void \bfcode{dma\_fence\_set\_error}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}, int\emph{ error}}{}
flag an error condition on the fence

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
{[}in{]} the dma\_fence

\item[{\code{int error}}] \leavevmode
{[}in{]} the error to store

\end{description}

\textbf{Description}

Drivers can supply an optional error status condition before they signal
the fence, to indicate that the fence was completed due to an error
rather than success. This must be set before signaling (so that the value
is visible before any waiters on the signal callback are woken). This
helper exists to help catching erroneous setting of \#dma\_fence.error.
\index{dma\_fence\_wait (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_wait}\pysiglinewithargsret{signed long \bfcode{dma\_fence\_wait}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}, bool\emph{ intr}}{}
sleep until the fence gets signaled

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
{[}in{]}    the fence to wait on

\item[{\code{bool intr}}] \leavevmode
{[}in{]}    if true, do an interruptible wait

\end{description}

\textbf{Description}

This function will return -ERESTARTSYS if interrupted by a signal,
or 0 if the fence was signaled. Other error values may be
returned on custom implementations.

Performs a synchronous wait on this fence. It is assumed the caller
directly or indirectly holds a reference to the fence, otherwise the
fence might be freed before return, resulting in undefined behavior.


\subsection{Seqno Hardware Fences}
\label{driver-api/dma-buf:seqno-hardware-fences}\index{to\_seqno\_fence (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.to_seqno_fence}\pysiglinewithargsret{struct seqno\_fence * \bfcode{to\_seqno\_fence}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}}{}
cast a fence to a seqno\_fence

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
fence to cast to a seqno\_fence

\end{description}

\textbf{Description}

Returns NULL if the fence is not a seqno\_fence,
or the seqno\_fence otherwise.
\index{seqno\_fence\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.seqno_fence_init}\pysiglinewithargsret{void \bfcode{seqno\_fence\_init}}{struct seqno\_fence *\emph{ fence}, spinlock\_t *\emph{ lock}, struct {\hyperref[driver\string-api/dma\string-buf:c.dma_buf]{\emph{dma\_buf}}} *\emph{ sync\_buf}, uint32\_t\emph{ context}, uint32\_t\emph{ seqno\_ofs}, uint32\_t\emph{ seqno}, enum seqno\_fence\_condition\emph{ cond}, const struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence_ops]{\emph{dma\_fence\_ops}}} *\emph{ ops}}{}
initialize a seqno fence

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct seqno\_fence * fence}}] \leavevmode
seqno\_fence to initialize

\item[{\code{spinlock\_t * lock}}] \leavevmode
pointer to spinlock to use for fence

\item[{\code{struct dma\_buf * sync\_buf}}] \leavevmode
buffer containing the memory location to signal on

\item[{\code{uint32\_t context}}] \leavevmode
the execution context this fence is a part of

\item[{\code{uint32\_t seqno\_ofs}}] \leavevmode
the offset within \textbf{sync\_buf}

\item[{\code{uint32\_t seqno}}] \leavevmode
the sequence \# to signal on

\item[{\code{enum seqno\_fence\_condition cond}}] \leavevmode
fence wait condition

\item[{\code{const struct dma\_fence\_ops * ops}}] \leavevmode
the fence\_ops for operations on this seqno fence

\end{description}

\textbf{Description}

This function initializes a struct seqno\_fence with passed parameters,
and takes a reference on sync\_buf which is released on fence destruction.

A seqno\_fence is a dma\_fence which can complete in software when
enable\_signaling is called, but it also completes when
(s32)((sync\_buf){[}seqno\_ofs{]} - seqno) \textgreater{}= 0 is true

The seqno\_fence will take a refcount on the sync\_buf until it's
destroyed, but actual lifetime of sync\_buf may be longer if one of the
callers take a reference to it.

Certain hardware have instructions to insert this type of wait condition
in the command stream, so no intervention from software would be needed.
This type of fence can be destroyed before completed, however a reference
on the sync\_buf dma-buf can be taken. It is encouraged to re-use the same
dma-buf for sync\_buf, since mapping or unmapping the sync\_buf to the
device's vm can be expensive.

It is recommended for creators of seqno\_fence to call {\hyperref[driver\string-api/dma\string-buf:c.dma_fence_signal]{\emph{\code{dma\_fence\_signal()}}}}
before destruction. This will prevent possible issues from wraparound at
time of issue vs time of check, since users can check {\hyperref[driver\string-api/dma\string-buf:c.dma_fence_is_signaled]{\emph{\code{dma\_fence\_is\_signaled()}}}}
before submitting instructions for the hardware to wait on the fence.
However, when ops.enable\_signaling is not called, it doesn't have to be
done as soon as possible, just before there's any real danger of seqno
wraparound.


\subsection{DMA Fence Array}
\label{driver-api/dma-buf:dma-fence-array}\index{dma\_fence\_array\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_array_create}\pysiglinewithargsret{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence_array]{\emph{dma\_fence\_array}}} * \bfcode{dma\_fence\_array\_create}}{int\emph{ num\_fences}, struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} **\emph{ fences}, u64\emph{ context}, unsigned\emph{ seqno}, bool\emph{ signal\_on\_any}}{}
Create a custom fence array

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int num\_fences}}] \leavevmode
{[}in{]}    number of fences to add in the array

\item[{\code{struct dma\_fence ** fences}}] \leavevmode
{[}in{]}    array containing the fences

\item[{\code{u64 context}}] \leavevmode
{[}in{]}    fence context to use

\item[{\code{unsigned seqno}}] \leavevmode
{[}in{]}    sequence number to use

\item[{\code{bool signal\_on\_any}}] \leavevmode
{[}in{]}    signal on any fence in the array

\end{description}

\textbf{Description}

Allocate a dma\_fence\_array object and initialize the base fence with
{\hyperref[driver\string-api/dma\string-buf:c.dma_fence_init]{\emph{\code{dma\_fence\_init()}}}}.
In case of error it returns NULL.

The caller should allocate the fences array with num\_fences size
and fill it with the fences it wants to add to the object. Ownership of this
array is taken and {\hyperref[driver\string-api/dma\string-buf:c.dma_fence_put]{\emph{\code{dma\_fence\_put()}}}} is used on each fence on release.

If \textbf{signal\_on\_any} is true the fence array signals if any fence in the array
signals, otherwise it signals when all fences in the array signal.
\index{dma\_fence\_match\_context (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_match_context}\pysiglinewithargsret{bool \bfcode{dma\_fence\_match\_context}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}, u64\emph{ context}}{}
Check if all fences are from the given context

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
{[}in{]}    fence or fence array

\item[{\code{u64 context}}] \leavevmode
{[}in{]}    fence context to check all fences against

\end{description}

\textbf{Description}

Checks the provided fence or, for a fence array, all fences in the array
against the given context. Returns false if any fence is from a different
context.
\index{dma\_fence\_array\_cb (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_array_cb}\pysigline{struct \bfcode{dma\_fence\_array\_cb}}
callback helper for fence array

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dma\PYGZus{}fence\PYGZus{}array\PYGZus{}cb \PYGZob{}
  struct dma\PYGZus{}fence\PYGZus{}cb cb;
  struct dma\PYGZus{}fence\PYGZus{}array *array;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{cb}}] \leavevmode
fence callback structure for signaling

\item[{\code{array}}] \leavevmode
reference to the parent fence array object

\end{description}
\index{dma\_fence\_array (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_array}\pysigline{struct \bfcode{dma\_fence\_array}}
fence to represent an array of fences

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dma\PYGZus{}fence\PYGZus{}array \PYGZob{}
  struct dma\PYGZus{}fence base;
  spinlock\PYGZus{}t lock;
  unsigned num\PYGZus{}fences;
  atomic\PYGZus{}t num\PYGZus{}pending;
  struct dma\PYGZus{}fence **fences;
  struct irq\PYGZus{}work work;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{base}}] \leavevmode
fence base class

\item[{\code{lock}}] \leavevmode
spinlock for fence handling

\item[{\code{num\_fences}}] \leavevmode
number of fences in the array

\item[{\code{num\_pending}}] \leavevmode
fences in the array still pending

\item[{\code{fences}}] \leavevmode
array of the fences

\end{description}
\index{dma\_fence\_is\_array (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.dma_fence_is_array}\pysiglinewithargsret{bool \bfcode{dma\_fence\_is\_array}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}}{}
check if a fence is from the array subsclass

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
fence to test

\end{description}

\textbf{Description}

Return true if it is a dma\_fence\_array and false otherwise.
\index{to\_dma\_fence\_array (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.to_dma_fence_array}\pysiglinewithargsret{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence_array]{\emph{dma\_fence\_array}}} * \bfcode{to\_dma\_fence\_array}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}}{}
cast a fence to a dma\_fence\_array

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
fence to cast to a dma\_fence\_array

\end{description}

\textbf{Description}

Returns NULL if the fence is not a dma\_fence\_array,
or the dma\_fence\_array otherwise.


\subsection{DMA Fence uABI/Sync File}
\label{driver-api/dma-buf:dma-fence-uabi-sync-file}\index{sync\_file\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.sync_file_create}\pysiglinewithargsret{struct {\hyperref[driver\string-api/dma\string-buf:c.sync_file]{\emph{sync\_file}}} * \bfcode{sync\_file\_create}}{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} *\emph{ fence}}{}
creates a sync file

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_fence * fence}}] \leavevmode
fence to add to the sync\_fence

\end{description}

\textbf{Description}

Creates a sync\_file containg \textbf{fence}. This function acquires and additional
reference of \textbf{fence} for the newly-created {\hyperref[driver\string-api/dma\string-buf:c.sync_file]{\emph{\code{sync\_file}}}}, if it succeeds. The
sync\_file can be released with fput(sync\_file-\textgreater{}file). Returns the
sync\_file or NULL in case of error.
\index{sync\_file\_get\_fence (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.sync_file_get_fence}\pysiglinewithargsret{struct {\hyperref[driver\string-api/dma\string-buf:c.dma_fence]{\emph{dma\_fence}}} * \bfcode{sync\_file\_get\_fence}}{int\emph{ fd}}{}
get the fence related to the sync\_file fd

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int fd}}] \leavevmode
sync\_file fd to get the fence from

\end{description}

\textbf{Description}

Ensures \textbf{fd} references a valid sync\_file and returns a fence that
represents all fence in the sync\_file. On error NULL is returned.
\index{sync\_file (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/dma-buf:c.sync_file}\pysigline{struct \bfcode{sync\_file}}
sync file to export to the userspace

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct sync\PYGZus{}file \PYGZob{}
  struct file             *file;
  char user\PYGZus{}name[32];
\PYGZsh{}ifdef CONFIG\PYGZus{}DEBUG\PYGZus{}FS;
  struct list\PYGZus{}head        sync\PYGZus{}file\PYGZus{}list;
\PYGZsh{}endif;
  wait\PYGZus{}queue\PYGZus{}head\PYGZus{}t wq;
  unsigned long           flags;
  struct dma\PYGZus{}fence        *fence;
  struct dma\PYGZus{}fence\PYGZus{}cb cb;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{file}}] \leavevmode
file representing this fence

\item[{\code{user\_name}}] \leavevmode
Name of the sync file provided by userspace, for merged fences.
Otherwise generated through driver callbacks (in which case the
entire array is 0).

\item[{\code{sync\_file\_list}}] \leavevmode
membership in global file list

\item[{\code{wq}}] \leavevmode
wait queue for fence signaling

\item[{\code{flags}}] \leavevmode
flags for the sync\_file

\item[{\code{fence}}] \leavevmode
fence with the fences in the sync\_file

\item[{\code{cb}}] \leavevmode
fence callback information

\end{description}

\textbf{Description}

flags:
POLL\_ENABLED: whether userspace is currently \code{poll()}`ing or not


\chapter{Device links}
\label{driver-api/device_link::doc}\label{driver-api/device_link:device-links}
By default, the driver core only enforces dependencies between devices
that are borne out of a parent/child relationship within the device
hierarchy: When suspending, resuming or shutting down the system, devices
are ordered based on this relationship, i.e. children are always suspended
before their parent, and the parent is always resumed before its children.

Sometimes there is a need to represent device dependencies beyond the
mere parent/child relationship, e.g. between siblings, and have the
driver core automatically take care of them.

Secondly, the driver core by default does not enforce any driver presence
dependencies, i.e. that one device must be bound to a driver before
another one can probe or function correctly.

Often these two dependency types come together, so a device depends on
another one both with regards to driver presence \emph{and} with regards to
suspend/resume and shutdown ordering.

Device links allow representation of such dependencies in the driver core.

In its standard form, a device link combines \emph{both} dependency types:
It guarantees correct suspend/resume and shutdown ordering between a
``supplier'' device and its ``consumer'' devices, and it guarantees driver
presence on the supplier.  The consumer devices are not probed before the
supplier is bound to a driver, and they're unbound before the supplier
is unbound.

When driver presence on the supplier is irrelevant and only correct
suspend/resume and shutdown ordering is needed, the device link may
simply be set up with the \code{DL\_FLAG\_STATELESS} flag.  In other words,
enforcing driver presence on the supplier is optional.

Another optional feature is runtime PM integration:  By setting the
\code{DL\_FLAG\_PM\_RUNTIME} flag on addition of the device link, the PM core
is instructed to runtime resume the supplier and keep it active
whenever and for as long as the consumer is runtime resumed.


\section{Usage}
\label{driver-api/device_link:usage}
The earliest point in time when device links can be added is after
{\hyperref[driver\string-api/infrastructure:c.device_add]{\emph{\code{device\_add()}}}} has been called for the supplier and
{\hyperref[driver\string-api/infrastructure:c.device_initialize]{\emph{\code{device\_initialize()}}}} has been called for the consumer.

It is legal to add them later, but care must be taken that the system
remains in a consistent state:  E.g. a device link cannot be added in
the midst of a suspend/resume transition, so either commencement of
such a transition needs to be prevented with \code{lock\_system\_sleep()},
or the device link needs to be added from a function which is guaranteed
not to run in parallel to a suspend/resume transition, such as from a
device \code{-\textgreater{}probe} callback or a boot-time PCI quirk.

Another example for an inconsistent state would be a device link that
represents a driver presence dependency, yet is added from the consumer's
\code{-\textgreater{}probe} callback while the supplier hasn't probed yet:  Had the driver
core known about the device link earlier, it wouldn't have probed the
consumer in the first place.  The onus is thus on the consumer to check
presence of the supplier after adding the link, and defer probing on
non-presence.

If a device link is added in the \code{-\textgreater{}probe} callback of the supplier or
consumer driver, it is typically deleted in its \code{-\textgreater{}remove} callback for
symmetry.  That way, if the driver is compiled as a module, the device
link is added on module load and orderly deleted on unload.  The same
restrictions that apply to device link addition (e.g. exclusion of a
parallel suspend/resume transition) apply equally to deletion.

Several flags may be specified on device link addition, two of which
have already been mentioned above:  \code{DL\_FLAG\_STATELESS} to express that no
driver presence dependency is needed (but only correct suspend/resume and
shutdown ordering) and \code{DL\_FLAG\_PM\_RUNTIME} to express that runtime PM
integration is desired.

Two other flags are specifically targeted at use cases where the device
link is added from the consumer's \code{-\textgreater{}probe} callback:  \code{DL\_FLAG\_RPM\_ACTIVE}
can be specified to runtime resume the supplier upon addition of the
device link.  \code{DL\_FLAG\_AUTOREMOVE} causes the device link to be automatically
purged when the consumer fails to probe or later unbinds.  This obviates
the need to explicitly delete the link in the \code{-\textgreater{}remove} callback or in
the error path of the \code{-\textgreater{}probe} callback.


\section{Limitations}
\label{driver-api/device_link:limitations}
Driver authors should be aware that a driver presence dependency (i.e. when
\code{DL\_FLAG\_STATELESS} is not specified on link addition) may cause probing of
the consumer to be deferred indefinitely.  This can become a problem if the
consumer is required to probe before a certain initcall level is reached.
Worse, if the supplier driver is blacklisted or missing, the consumer will
never be probed.

Sometimes drivers depend on optional resources.  They are able to operate
in a degraded mode (reduced feature set or performance) when those resources
are not present.  An example is an SPI controller that can use a DMA engine
or work in PIO mode.  The controller can determine presence of the optional
resources at probe time but on non-presence there is no way to know whether
they will become available in the near future (due to a supplier driver
probing) or never.  Consequently it cannot be determined whether to defer
probing or not.  It would be possible to notify drivers when optional
resources become available after probing, but it would come at a high cost
for drivers as switching between modes of operation at runtime based on the
availability of such resources would be much more complex than a mechanism
based on probe deferral.  In any case optional resources are beyond the
scope of device links.


\section{Examples}
\label{driver-api/device_link:examples}\begin{itemize}
\item {} 
An MMU device exists alongside a busmaster device, both are in the same
power domain.  The MMU implements DMA address translation for the busmaster
device and shall be runtime resumed and kept active whenever and as long
as the busmaster device is active.  The busmaster device's driver shall
not bind before the MMU is bound.  To achieve this, a device link with
runtime PM integration is added from the busmaster device (consumer)
to the MMU device (supplier).  The effect with regards to runtime PM
is the same as if the MMU was the parent of the master device.

The fact that both devices share the same power domain would normally
suggest usage of a {\hyperref[driver\string-api/pm/types:c.dev_pm_domain]{\emph{\code{struct dev\_pm\_domain}}}} or \code{struct generic\_pm\_domain},
however these are not independent devices that happen to share a power
switch, but rather the MMU device serves the busmaster device and is
useless without it.  A device link creates a synthetic hierarchical
relationship between the devices and is thus more apt.

\item {} 
A Thunderbolt host controller comprises a number of PCIe hotplug ports
and an NHI device to manage the PCIe switch.  On resume from system sleep,
the NHI device needs to re-establish PCI tunnels to attached devices
before the hotplug ports can resume.  If the hotplug ports were children
of the NHI, this resume order would automatically be enforced by the
PM core, but unfortunately they're aunts.  The solution is to add
device links from the hotplug ports (consumers) to the NHI device
(supplier).  A driver presence dependency is not necessary for this
use case.

\item {} 
Discrete GPUs in hybrid graphics laptops often feature an HDA controller
for HDMI/DP audio.  In the device hierarchy the HDA controller is a sibling
of the VGA device, yet both share the same power domain and the HDA
controller is only ever needed when an HDMI/DP display is attached to the
VGA device.  A device link from the HDA controller (consumer) to the
VGA device (supplier) aptly represents this relationship.

\item {} 
ACPI allows definition of a device start order by way of \_DEP objects.
A classical example is when ACPI power management methods on one device
are implemented in terms of I$^{\text{2}}$C accesses and require a specific
I$^{\text{2}}$C controller to be present and functional for the power
management of the device in question to work.

\item {} 
In some SoCs a functional dependency exists from display, video codec and
video processing IP cores on transparent memory access IP cores that handle
burst access and compression/decompression.

\end{itemize}


\section{Alternatives}
\label{driver-api/device_link:alternatives}\begin{itemize}
\item {} 
A {\hyperref[driver\string-api/pm/types:c.dev_pm_domain]{\emph{\code{struct dev\_pm\_domain}}}} can be used to override the bus,
class or device type callbacks.  It is intended for devices sharing
a single on/off switch, however it does not guarantee a specific
suspend/resume ordering, this needs to be implemented separately.
It also does not by itself track the runtime PM status of the involved
devices and turn off the power switch only when all of them are runtime
suspended.  Furthermore it cannot be used to enforce a specific shutdown
ordering or a driver presence dependency.

\item {} 
A \code{struct generic\_pm\_domain} is a lot more heavyweight than a
device link and does not allow for shutdown ordering or driver presence
dependencies.  It also cannot be used on ACPI systems.

\end{itemize}


\section{Implementation}
\label{driver-api/device_link:implementation}
The device hierarchy, which -- as the name implies -- is a tree,
becomes a directed acyclic graph once device links are added.

Ordering of these devices during suspend/resume is determined by the
dpm\_list.  During shutdown it is determined by the devices\_kset.  With
no device links present, the two lists are a flattened, one-dimensional
representations of the device tree such that a device is placed behind
all its ancestors.  That is achieved by traversing the ACPI namespace
or OpenFirmware device tree top-down and appending devices to the lists
as they are discovered.

Once device links are added, the lists need to satisfy the additional
constraint that a device is placed behind all its suppliers, recursively.
To ensure this, upon addition of the device link the consumer and the
entire sub-graph below it (all children and consumers of the consumer)
are moved to the end of the list.  (Call to \code{device\_reorder\_to\_tail()}
from {\hyperref[driver\string-api/infrastructure:c.device_link_add]{\emph{\code{device\_link\_add()}}}}.)

To prevent introduction of dependency loops into the graph, it is
verified upon device link addition that the supplier is not dependent
on the consumer or any children or consumers of the consumer.
(Call to \code{device\_is\_dependent()} from {\hyperref[driver\string-api/infrastructure:c.device_link_add]{\emph{\code{device\_link\_add()}}}}.)
If that constraint is violated, {\hyperref[driver\string-api/infrastructure:c.device_link_add]{\emph{\code{device\_link\_add()}}}} will return
\code{NULL} and a \code{WARNING} will be logged.

Notably this also prevents the addition of a device link from a parent
device to a child.  However the converse is allowed, i.e. a device link
from a child to a parent.  Since the driver core already guarantees
correct suspend/resume and shutdown ordering between parent and child,
such a device link only makes sense if a driver presence dependency is
needed on top of that.  In this case driver authors should weigh
carefully if a device link is at all the right tool for the purpose.
A more suitable approach might be to simply use deferred probing or
add a device flag causing the parent driver to be probed before the
child one.


\section{State machine}
\label{driver-api/device_link:state-machine}\index{device\_link\_state (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/device_link:c.device_link_state}\pysigline{enum \bfcode{device\_link\_state}}
Device link states.

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{DL\_STATE\_NONE}}] \leavevmode
The presence of the drivers is not being tracked.

\item[{\code{DL\_STATE\_DORMANT}}] \leavevmode
None of the supplier/consumer drivers is present.

\item[{\code{DL\_STATE\_AVAILABLE}}] \leavevmode
The supplier driver is present, but the consumer is not.

\item[{\code{DL\_STATE\_CONSUMER\_PROBE}}] \leavevmode
The consumer is probing (supplier driver present).

\item[{\code{DL\_STATE\_ACTIVE}}] \leavevmode
Both the supplier and consumer drivers are present.

\item[{\code{DL\_STATE\_SUPPLIER\_UNBIND}}] \leavevmode
The supplier driver is unbinding.

\end{description}

\begin{Verbatim}[commandchars=\\\{\}]
                .=============================.
                \textbar{}                             \textbar{}
                v                             \textbar{}
DORMANT \PYGZlt{}=\PYGZgt{} AVAILABLE \PYGZlt{}=\PYGZgt{} CONSUMER\PYGZus{}PROBE =\PYGZgt{} ACTIVE
   \PYGZca{}                                          \textbar{}
   \textbar{}                                          \textbar{}
   \PYGZsq{}============ SUPPLIER\PYGZus{}UNBIND \PYGZlt{}============\PYGZsq{}
\end{Verbatim}
\begin{itemize}
\item {} 
The initial state of a device link is automatically determined by
{\hyperref[driver\string-api/infrastructure:c.device_link_add]{\emph{\code{device\_link\_add()}}}} based on the driver presence on the supplier
and consumer.  If the link is created before any devices are probed, it
is set to \code{DL\_STATE\_DORMANT}.

\item {} 
When a supplier device is bound to a driver, links to its consumers
progress to \code{DL\_STATE\_AVAILABLE}.
(Call to \code{device\_links\_driver\_bound()} from
\code{driver\_bound()}.)

\item {} 
Before a consumer device is probed, presence of supplier drivers is
verified by checking that links to suppliers are in \code{DL\_STATE\_AVAILABLE}
state.  The state of the links is updated to \code{DL\_STATE\_CONSUMER\_PROBE}.
(Call to \code{device\_links\_check\_suppliers()} from
\code{really\_probe()}.)
This prevents the supplier from unbinding.
(Call to {\hyperref[driver\string-api/infrastructure:c.wait_for_device_probe]{\emph{\code{wait\_for\_device\_probe()}}}} from
\code{device\_links\_unbind\_consumers()}.)

\item {} 
If the probe fails, links to suppliers revert back to \code{DL\_STATE\_AVAILABLE}.
(Call to \code{device\_links\_no\_driver()} from \code{really\_probe()}.)

\item {} 
If the probe succeeds, links to suppliers progress to \code{DL\_STATE\_ACTIVE}.
(Call to \code{device\_links\_driver\_bound()} from \code{driver\_bound()}.)

\item {} 
When the consumer's driver is later on removed, links to suppliers revert
back to \code{DL\_STATE\_AVAILABLE}.
(Call to \code{\_\_device\_links\_no\_driver()} from
\code{device\_links\_driver\_cleanup()}, which in turn is called from
\code{\_\_device\_release\_driver()}.)

\item {} 
Before a supplier's driver is removed, links to consumers that are not
bound to a driver are updated to \code{DL\_STATE\_SUPPLIER\_UNBIND}.
(Call to \code{device\_links\_busy()} from
\code{\_\_device\_release\_driver()}.)
This prevents the consumers from binding.
(Call to \code{device\_links\_check\_suppliers()} from
\code{really\_probe()}.)
Consumers that are bound are freed from their driver; consumers that are
probing are waited for until they are done.
(Call to \code{device\_links\_unbind\_consumers()} from
\code{\_\_device\_release\_driver()}.)
Once all links to consumers are in \code{DL\_STATE\_SUPPLIER\_UNBIND} state,
the supplier driver is released and the links revert to \code{DL\_STATE\_DORMANT}.
(Call to \code{device\_links\_driver\_cleanup()} from
\code{\_\_device\_release\_driver()}.)

\end{itemize}


\section{API}
\label{driver-api/device_link:api}\index{device\_link\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/device_link:c.device_link_add}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device_link]{\emph{device\_link}}} * \bfcode{device\_link\_add}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ consumer}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ supplier}, u32\emph{ flags}}{}
Create a link between two devices.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * consumer}}] \leavevmode
Consumer end of the link.

\item[{\code{struct device * supplier}}] \leavevmode
Supplier end of the link.

\item[{\code{u32 flags}}] \leavevmode
Link flags.

\end{description}

\textbf{Description}

The caller is responsible for the proper synchronization of the link creation
with runtime PM.  First, setting the DL\_FLAG\_PM\_RUNTIME flag will cause the
runtime PM framework to take the link into account.  Second, if the
DL\_FLAG\_RPM\_ACTIVE flag is set in addition to it, the supplier devices will
be forced into the active metastate and reference-counted upon the creation
of the link.  If DL\_FLAG\_PM\_RUNTIME is not set, DL\_FLAG\_RPM\_ACTIVE will be
ignored.

If the DL\_FLAG\_AUTOREMOVE is set, the link will be removed automatically
when the consumer device driver unbinds from it.  The combination of both
DL\_FLAG\_AUTOREMOVE and DL\_FLAG\_STATELESS set is invalid and will cause NULL
to be returned.

A side effect of the link creation is re-ordering of dpm\_list and the
devices\_kset list by moving the consumer device and all devices depending
on it to the ends of these lists (that does not happen to devices that have
not been registered when this function is called).

The supplier device is required to be registered when this function is called
and NULL will be returned if that is not the case.  The consumer device need
not be registered, however.
\index{device\_link\_del (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/device_link:c.device_link_del}\pysiglinewithargsret{void \bfcode{device\_link\_del}}{struct {\hyperref[driver\string-api/infrastructure:c.device_link]{\emph{device\_link}}} *\emph{ link}}{}
Delete a link between two devices.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device\_link * link}}] \leavevmode
Device link to delete.

\end{description}

\textbf{Description}

The caller must ensure proper synchronization of this function with runtime
PM.


\chapter{Message-based devices}
\label{driver-api/message-based:message-based-devices}\label{driver-api/message-based::doc}

\section{Fusion message devices}
\label{driver-api/message-based:fusion-message-devices}\index{mpt\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_register}\pysiglinewithargsret{u8 \bfcode{mpt\_register}}{MPT\_CALLBACK\emph{ cbfunc}, MPT\_DRIVER\_CLASS\emph{ dclass}, char *\emph{ func\_name}}{}
Register protocol-specific main callback handler.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_CALLBACK cbfunc}}] \leavevmode
callback function pointer

\item[{\code{MPT\_DRIVER\_CLASS dclass}}] \leavevmode
Protocol driver's class (\code{MPT\_DRIVER\_CLASS} enum value)

\item[{\code{char * func\_name}}] \leavevmode
call function's name

\end{description}

\textbf{Description}
\begin{quote}

This routine is called by a protocol-specific driver (SCSI host,
LAN, SCSI target) to register its reply callback routine.  Each
protocol-specific driver must do this before it will be able to
use any IOC resources, such as obtaining request frames.
\end{quote}

\textbf{NOTES}
\begin{description}
\item[{The SCSI protocol driver currently calls this routine thrice}] \leavevmode
in order to register separate callbacks; one for ``normal'' SCSI IO;
one for MptScsiTaskMgmt requests; one for Scan/DV requests.

Returns u8 valued ``handle'' in the range (and S.O.D. order)
\{N,...,7,6,5,...,1\} if successful.
A return value of MPT\_MAX\_PROTOCOL\_DRIVERS (including zero!) should be
considered an error by the caller.

\end{description}
\index{mpt\_deregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_deregister}\pysiglinewithargsret{void \bfcode{mpt\_deregister}}{u8\emph{ cb\_idx}}{}
Deregister a protocol drivers resources.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 cb\_idx}}] \leavevmode
previously registered callback handle

\end{description}

\textbf{Description}
\begin{quote}

Each protocol-specific driver should call this routine when its
module is unloaded.
\end{quote}
\index{mpt\_event\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_event_register}\pysiglinewithargsret{int \bfcode{mpt\_event\_register}}{u8\emph{ cb\_idx}, MPT\_EVHANDLER\emph{ ev\_cbfunc}}{}
Register protocol-specific event callback handler.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 cb\_idx}}] \leavevmode
previously registered (via mpt\_register) callback handle

\item[{\code{MPT\_EVHANDLER ev\_cbfunc}}] \leavevmode
callback function

\end{description}

\textbf{Description}
\begin{quote}

This routine can be called by one or more protocol-specific drivers
if/when they choose to be notified of MPT events.

Returns 0 for success.
\end{quote}
\index{mpt\_event\_deregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_event_deregister}\pysiglinewithargsret{void \bfcode{mpt\_event\_deregister}}{u8\emph{ cb\_idx}}{}
Deregister protocol-specific event callback handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 cb\_idx}}] \leavevmode
previously registered callback handle

\end{description}

\textbf{Description}
\begin{quote}

Each protocol-specific driver should call this routine
when it does not (or can no longer) handle events,
or when its module is unloaded.
\end{quote}
\index{mpt\_reset\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_reset_register}\pysiglinewithargsret{int \bfcode{mpt\_reset\_register}}{u8\emph{ cb\_idx}, MPT\_RESETHANDLER\emph{ reset\_func}}{}
Register protocol-specific IOC reset handler.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 cb\_idx}}] \leavevmode
previously registered (via mpt\_register) callback handle

\item[{\code{MPT\_RESETHANDLER reset\_func}}] \leavevmode
reset function

\end{description}

\textbf{Description}
\begin{quote}

This routine can be called by one or more protocol-specific drivers
if/when they choose to be notified of IOC resets.

Returns 0 for success.
\end{quote}
\index{mpt\_reset\_deregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_reset_deregister}\pysiglinewithargsret{void \bfcode{mpt\_reset\_deregister}}{u8\emph{ cb\_idx}}{}
Deregister protocol-specific IOC reset handler.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 cb\_idx}}] \leavevmode
previously registered callback handle

\end{description}

\textbf{Description}
\begin{quote}

Each protocol-specific driver should call this routine
when it does not (or can no longer) handle IOC reset handling,
or when its module is unloaded.
\end{quote}
\index{mpt\_device\_driver\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_device_driver_register}\pysiglinewithargsret{int \bfcode{mpt\_device\_driver\_register}}{struct mpt\_pci\_driver *\emph{ dd\_cbfunc}, u8\emph{ cb\_idx}}{}
Register device driver hooks

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mpt\_pci\_driver * dd\_cbfunc}}] \leavevmode
driver callbacks struct

\item[{\code{u8 cb\_idx}}] \leavevmode
MPT protocol driver index

\end{description}
\index{mpt\_device\_driver\_deregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_device_driver_deregister}\pysiglinewithargsret{void \bfcode{mpt\_device\_driver\_deregister}}{u8\emph{ cb\_idx}}{}
DeRegister device driver hooks

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 cb\_idx}}] \leavevmode
MPT protocol driver index

\end{description}
\index{mpt\_get\_msg\_frame (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_get_msg_frame}\pysiglinewithargsret{MPT\_FRAME\_HDR* \bfcode{mpt\_get\_msg\_frame}}{u8\emph{ cb\_idx}, MPT\_ADAPTER *\emph{ ioc}}{}
Obtain an MPT request frame from the pool

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 cb\_idx}}] \leavevmode
Handle of registered MPT protocol driver

\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to MPT adapter structure

\end{description}

\textbf{Description}
\begin{quote}

Obtain an MPT request frame from the pool (of 1024) that are
allocated per MPT adapter.

Returns pointer to a MPT request frame or \code{NULL} if none are available
or IOC is not active.
\end{quote}
\index{mpt\_put\_msg\_frame (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_put_msg_frame}\pysiglinewithargsret{void \bfcode{mpt\_put\_msg\_frame}}{u8\emph{ cb\_idx}, MPT\_ADAPTER *\emph{ ioc}, MPT\_FRAME\_HDR *\emph{ mf}}{}
Send a protocol-specific MPT request frame to an IOC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 cb\_idx}}] \leavevmode
Handle of registered MPT protocol driver

\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to MPT adapter structure

\item[{\code{MPT\_FRAME\_HDR * mf}}] \leavevmode
Pointer to MPT request frame

\end{description}

\textbf{Description}
\begin{quote}

This routine posts an MPT request frame to the request post FIFO of a
specific MPT adapter.
\end{quote}
\index{mpt\_put\_msg\_frame\_hi\_pri (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_put_msg_frame_hi_pri}\pysiglinewithargsret{void \bfcode{mpt\_put\_msg\_frame\_hi\_pri}}{u8\emph{ cb\_idx}, MPT\_ADAPTER *\emph{ ioc}, MPT\_FRAME\_HDR *\emph{ mf}}{}
Send a hi-pri protocol-specific MPT request frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 cb\_idx}}] \leavevmode
Handle of registered MPT protocol driver

\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to MPT adapter structure

\item[{\code{MPT\_FRAME\_HDR * mf}}] \leavevmode
Pointer to MPT request frame

\end{description}

\textbf{Description}
\begin{quote}

Send a protocol-specific MPT request frame to an IOC using
hi-priority request queue.

This routine posts an MPT request frame to the request post FIFO of a
specific MPT adapter.
\end{quote}
\index{mpt\_free\_msg\_frame (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_free_msg_frame}\pysiglinewithargsret{void \bfcode{mpt\_free\_msg\_frame}}{MPT\_ADAPTER *\emph{ ioc}, MPT\_FRAME\_HDR *\emph{ mf}}{}
Place MPT request frame back on FreeQ.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to MPT adapter structure

\item[{\code{MPT\_FRAME\_HDR * mf}}] \leavevmode
Pointer to MPT request frame

\end{description}

\textbf{Description}
\begin{quote}

This routine places a MPT request frame back on the MPT adapter's
FreeQ.
\end{quote}
\index{mpt\_send\_handshake\_request (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_send_handshake_request}\pysiglinewithargsret{int \bfcode{mpt\_send\_handshake\_request}}{u8\emph{ cb\_idx}, MPT\_ADAPTER *\emph{ ioc}, int\emph{ reqBytes}, u32 *\emph{ req}, int\emph{ sleepFlag}}{}
Send MPT request via doorbell handshake method.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 cb\_idx}}] \leavevmode
Handle of registered MPT protocol driver

\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to MPT adapter structure

\item[{\code{int reqBytes}}] \leavevmode
Size of the request in bytes

\item[{\code{u32 * req}}] \leavevmode
Pointer to MPT request frame

\item[{\code{int sleepFlag}}] \leavevmode
Use schedule if CAN\_SLEEP else use udelay.

\end{description}

\textbf{Description}
\begin{quote}

This routine is used exclusively to send MptScsiTaskMgmt
requests since they are required to be sent via doorbell handshake.
\end{quote}

\textbf{NOTE}
\begin{description}
\item[{It is the callers responsibility to byte-swap fields in the}] \leavevmode
request which are greater than 1 byte in size.

Returns 0 for success, non-zero for failure.

\end{description}
\index{mpt\_verify\_adapter (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_verify_adapter}\pysiglinewithargsret{int \bfcode{mpt\_verify\_adapter}}{int\emph{ iocid}, MPT\_ADAPTER **\emph{ iocpp}}{}
Given IOC identifier, set pointer to its adapter structure.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int iocid}}] \leavevmode
IOC unique identifier (integer)

\item[{\code{MPT\_ADAPTER ** iocpp}}] \leavevmode
Pointer to pointer to IOC adapter

\end{description}

\textbf{Description}
\begin{quote}

Given a unique IOC identifier, set pointer to the associated MPT
adapter structure.

Returns iocid and sets iocpp if iocid is found.
Returns -1 if iocid is not found.
\end{quote}
\index{mpt\_attach (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_attach}\pysiglinewithargsret{int \bfcode{mpt\_attach}}{struct pci\_dev *\emph{ pdev}, const struct pci\_device\_id *\emph{ id}}{}
Install a PCI intelligent MPT adapter.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
Pointer to pci\_dev structure

\item[{\code{const struct pci\_device\_id * id}}] \leavevmode
PCI device ID information

\end{description}

\textbf{Description}
\begin{quote}

This routine performs all the steps necessary to bring the IOC of
a MPT adapter to a OPERATIONAL state.  This includes registering
memory regions, registering the interrupt, and allocating request
and reply memory pools.

This routine also pre-fetches the LAN MAC address of a Fibre Channel
MPT adapter.

Returns 0 for success, non-zero for failure.

TODO: Add support for polled controllers
\end{quote}
\index{mpt\_detach (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_detach}\pysiglinewithargsret{void \bfcode{mpt\_detach}}{struct pci\_dev *\emph{ pdev}}{}
Remove a PCI intelligent MPT adapter.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
Pointer to pci\_dev structure

\end{description}
\index{mpt\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_suspend}\pysiglinewithargsret{int \bfcode{mpt\_suspend}}{struct pci\_dev *\emph{ pdev}, pm\_message\_t\emph{ state}}{}
Fusion MPT base driver suspend routine.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
Pointer to pci\_dev structure

\item[{\code{pm\_message\_t state}}] \leavevmode
new state to enter

\end{description}
\index{mpt\_resume (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_resume}\pysiglinewithargsret{int \bfcode{mpt\_resume}}{struct pci\_dev *\emph{ pdev}}{}
Fusion MPT base driver resume routine.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
Pointer to pci\_dev structure

\end{description}
\index{mpt\_GetIocState (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_GetIocState}\pysiglinewithargsret{u32 \bfcode{mpt\_GetIocState}}{MPT\_ADAPTER *\emph{ ioc}, int\emph{ cooked}}{}
Get the current state of a MPT adapter.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to MPT\_ADAPTER structure

\item[{\code{int cooked}}] \leavevmode
Request raw or cooked IOC state

\end{description}

\textbf{Description}
\begin{quote}

Returns all IOC Doorbell register bits if cooked==0, else just the
Doorbell bits in MPI\_IOC\_STATE\_MASK.
\end{quote}
\index{mpt\_alloc\_fw\_memory (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_alloc_fw_memory}\pysiglinewithargsret{int \bfcode{mpt\_alloc\_fw\_memory}}{MPT\_ADAPTER *\emph{ ioc}, int\emph{ size}}{}
allocate firmware memory

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to MPT\_ADAPTER structure

\item[{\code{int size}}] \leavevmode
total FW bytes

\end{description}

\textbf{Description}
\begin{quote}

If memory has already been allocated, the same (cached) value
is returned.

Return 0 if successful, or non-zero for failure
\end{quote}
\index{mpt\_free\_fw\_memory (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_free_fw_memory}\pysiglinewithargsret{void \bfcode{mpt\_free\_fw\_memory}}{MPT\_ADAPTER *\emph{ ioc}}{}
free firmware memory

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to MPT\_ADAPTER structure

\end{description}

\textbf{Description}
\begin{quote}

If alt\_img is NULL, delete from ioc structure.
Else, delete a secondary image in same format.
\end{quote}
\index{mptbase\_sas\_persist\_operation (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mptbase_sas_persist_operation}\pysiglinewithargsret{int \bfcode{mptbase\_sas\_persist\_operation}}{MPT\_ADAPTER *\emph{ ioc}, u8\emph{ persist\_opcode}}{}
Perform operation on SAS Persistent Table

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to MPT\_ADAPTER structure

\item[{\code{u8 persist\_opcode}}] \leavevmode
see below

\end{description}

\textbf{Description}
\begin{quote}
\begin{description}
\item[{MPI\_SAS\_OP\_CLEAR\_NOT\_PRESENT - Free all persist TargetID mappings for}] \leavevmode
devices not currently present.

\end{description}

MPI\_SAS\_OP\_CLEAR\_ALL\_PERSISTENT - Clear al persist TargetID mappings
\end{quote}

\textbf{NOTE}

Don't use not this function during interrupt time.
\begin{quote}

Returns 0 for success, non-zero error
\end{quote}
\index{mpt\_raid\_phys\_disk\_pg0 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_raid_phys_disk_pg0}\pysiglinewithargsret{int \bfcode{mpt\_raid\_phys\_disk\_pg0}}{MPT\_ADAPTER *\emph{ ioc}, u8\emph{ phys\_disk\_num}, RaidPhysDiskPage0\_t *\emph{ phys\_disk}}{}
returns phys disk page zero

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to a Adapter Structure

\item[{\code{u8 phys\_disk\_num}}] \leavevmode
io unit unique phys disk num generated by the ioc

\item[{\code{RaidPhysDiskPage0\_t * phys\_disk}}] \leavevmode
requested payload data returned

\end{description}

\textbf{Return}
\begin{quote}

0 on success
-EFAULT if read of config page header fails or data pointer not NULL
-ENOMEM if pci\_alloc failed
\end{quote}
\index{mpt\_raid\_phys\_disk\_get\_num\_paths (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_raid_phys_disk_get_num_paths}\pysiglinewithargsret{int \bfcode{mpt\_raid\_phys\_disk\_get\_num\_paths}}{MPT\_ADAPTER *\emph{ ioc}, u8\emph{ phys\_disk\_num}}{}
returns number paths associated to this phys\_num

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to a Adapter Structure

\item[{\code{u8 phys\_disk\_num}}] \leavevmode
io unit unique phys disk num generated by the ioc

\end{description}

\textbf{Return}
\begin{quote}

returns number paths
\end{quote}
\index{mpt\_raid\_phys\_disk\_pg1 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_raid_phys_disk_pg1}\pysiglinewithargsret{int \bfcode{mpt\_raid\_phys\_disk\_pg1}}{MPT\_ADAPTER *\emph{ ioc}, u8\emph{ phys\_disk\_num}, RaidPhysDiskPage1\_t *\emph{ phys\_disk}}{}
returns phys disk page 1

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to a Adapter Structure

\item[{\code{u8 phys\_disk\_num}}] \leavevmode
io unit unique phys disk num generated by the ioc

\item[{\code{RaidPhysDiskPage1\_t * phys\_disk}}] \leavevmode
requested payload data returned

\end{description}

\textbf{Return}
\begin{quote}

0 on success
-EFAULT if read of config page header fails or data pointer not NULL
-ENOMEM if pci\_alloc failed
\end{quote}
\index{mpt\_findImVolumes (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_findImVolumes}\pysiglinewithargsret{int \bfcode{mpt\_findImVolumes}}{MPT\_ADAPTER *\emph{ ioc}}{}
Identify IDs of hidden disks and RAID Volumes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to a Adapter Strucutre

\end{description}

\textbf{Return}
\begin{quote}

0 on success
-EFAULT if read of config page header fails or data pointer not NULL
-ENOMEM if pci\_alloc failed
\end{quote}
\index{mpt\_config (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_config}\pysiglinewithargsret{int \bfcode{mpt\_config}}{MPT\_ADAPTER *\emph{ ioc}, CONFIGPARMS *\emph{ pCfg}}{}
Generic function to issue config message

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to an adapter structure

\item[{\code{CONFIGPARMS * pCfg}}] \leavevmode
Pointer to a configuration structure. Struct contains
action, page address, direction, physical address
and pointer to a configuration page header
Page header is updated.

\end{description}

\textbf{Description}
\begin{quote}

Returns 0 for success
-EPERM if not allowed due to ISR context
-EAGAIN if no msg frames currently available
-EFAULT for non-successful reply or no reply (timeout)
\end{quote}
\index{mpt\_print\_ioc\_summary (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_print_ioc_summary}\pysiglinewithargsret{void \bfcode{mpt\_print\_ioc\_summary}}{MPT\_ADAPTER *\emph{ ioc}, char *\emph{ buffer}, int *\emph{ size}, int\emph{ len}, int\emph{ showlan}}{}
Write ASCII summary of IOC to a buffer.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to MPT\_ADAPTER structure

\item[{\code{char * buffer}}] \leavevmode
Pointer to buffer where IOC summary info should be written

\item[{\code{int * size}}] \leavevmode
Pointer to number of bytes we wrote (set by this routine)

\item[{\code{int len}}] \leavevmode
Offset at which to start writing in buffer

\item[{\code{int showlan}}] \leavevmode
Display LAN stuff?

\end{description}

\textbf{Description}
\begin{quote}

This routine writes (english readable) ASCII text, which represents
a summary of IOC information, to a buffer.
\end{quote}
\index{mpt\_set\_taskmgmt\_in\_progress\_flag (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_set_taskmgmt_in_progress_flag}\pysiglinewithargsret{int \bfcode{mpt\_set\_taskmgmt\_in\_progress\_flag}}{MPT\_ADAPTER *\emph{ ioc}}{}
set flags associated with task management

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to MPT\_ADAPTER structure

\end{description}

\textbf{Description}
\begin{quote}

Returns 0 for SUCCESS or -1 if FAILED.

If -1 is return, then it was not possible to set the flags
\end{quote}
\index{mpt\_clear\_taskmgmt\_in\_progress\_flag (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_clear_taskmgmt_in_progress_flag}\pysiglinewithargsret{void \bfcode{mpt\_clear\_taskmgmt\_in\_progress\_flag}}{MPT\_ADAPTER *\emph{ ioc}}{}
clear flags associated with task management

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to MPT\_ADAPTER structure

\end{description}
\index{mpt\_halt\_firmware (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_halt_firmware}\pysiglinewithargsret{void \bfcode{mpt\_halt\_firmware}}{MPT\_ADAPTER *\emph{ ioc}}{}
Halts the firmware if it is operational and panic the kernel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to MPT\_ADAPTER structure

\end{description}
\index{mpt\_Soft\_Hard\_ResetHandler (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_Soft_Hard_ResetHandler}\pysiglinewithargsret{int \bfcode{mpt\_Soft\_Hard\_ResetHandler}}{MPT\_ADAPTER *\emph{ ioc}, int\emph{ sleepFlag}}{}
Try less expensive reset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to MPT\_ADAPTER structure

\item[{\code{int sleepFlag}}] \leavevmode
Indicates if sleep or schedule must be called.

\end{description}

\textbf{Description}
\begin{quote}

Returns 0 for SUCCESS or -1 if FAILED.
Try for softreset first, only if it fails go for expensive
HardReset.
\end{quote}
\index{mpt\_HardResetHandler (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mpt_HardResetHandler}\pysiglinewithargsret{int \bfcode{mpt\_HardResetHandler}}{MPT\_ADAPTER *\emph{ ioc}, int\emph{ sleepFlag}}{}
Generic reset handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to MPT\_ADAPTER structure

\item[{\code{int sleepFlag}}] \leavevmode
Indicates if sleep or schedule must be called.

\end{description}

\textbf{Description}
\begin{quote}

Issues SCSI Task Management call based on input arg values.
If TaskMgmt fails, returns associated SCSI request.

Remark: \_HardResetHandler can be invoked from an interrupt thread (timer)
or a non-interrupt thread.  In the former, must not call \code{schedule()}.
\end{quote}

\textbf{Note}
\begin{description}
\item[{A return of -1 is a FATAL error case, as it means a}] \leavevmode
FW reload/initialization failed.

Returns 0 for SUCCESS or -1 if FAILED.

\end{description}
\index{mptscsih\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mptscsih_info}\pysiglinewithargsret{const char * \bfcode{mptscsih\_info}}{struct Scsi\_Host *\emph{ SChost}}{}
Return information about MPT adapter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * SChost}}] \leavevmode
Pointer to Scsi\_Host structure

\end{description}

\textbf{Description}
\begin{quote}

(linux scsi\_host\_template.info routine)

Returns pointer to buffer where information was written.
\end{quote}
\index{mptscsih\_qcmd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mptscsih_qcmd}\pysiglinewithargsret{int \bfcode{mptscsih\_qcmd}}{struct scsi\_cmnd *\emph{ SCpnt}}{}
Primary Fusion MPT SCSI initiator IO start routine.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * SCpnt}}] \leavevmode
Pointer to scsi\_cmnd structure

\end{description}

\textbf{Description}
\begin{quote}

(linux scsi\_host\_template.queuecommand routine)
This is the primary SCSI IO start routine.  Create a MPI SCSIIORequest
from a linux scsi\_cmnd request and send it to the IOC.

Returns 0. (rtn value discarded by linux scsi mid-layer)
\end{quote}
\index{mptscsih\_IssueTaskMgmt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mptscsih_IssueTaskMgmt}\pysiglinewithargsret{int \bfcode{mptscsih\_IssueTaskMgmt}}{MPT\_SCSI\_HOST *\emph{ hd}, u8\emph{ type}, u8\emph{ channel}, u8\emph{ id}, u64\emph{ lun}, int\emph{ ctx2abort}, ulong\emph{ timeout}}{}
Generic send Task Management function.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_SCSI\_HOST * hd}}] \leavevmode
Pointer to MPT\_SCSI\_HOST structure

\item[{\code{u8 type}}] \leavevmode
Task Management type

\item[{\code{u8 channel}}] \leavevmode
channel number for task management

\item[{\code{u8 id}}] \leavevmode
Logical Target ID for reset (if appropriate)

\item[{\code{u64 lun}}] \leavevmode
Logical Unit for reset (if appropriate)

\item[{\code{int ctx2abort}}] \leavevmode
Context for the task to be aborted (if appropriate)

\item[{\code{ulong timeout}}] \leavevmode
timeout for task management control

\end{description}

\textbf{Description}
\begin{quote}

Remark: \_HardResetHandler can be invoked from an interrupt thread (timer)
or a non-interrupt thread.  In the former, must not call \code{schedule()}.

Not all fields are meaningfull for all task types.

Returns 0 for SUCCESS, or FAILED.
\end{quote}
\index{mptscsih\_abort (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mptscsih_abort}\pysiglinewithargsret{int \bfcode{mptscsih\_abort}}{struct scsi\_cmnd *\emph{ SCpnt}}{}
Abort linux scsi\_cmnd routine, new\_eh variant

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * SCpnt}}] \leavevmode
Pointer to scsi\_cmnd structure, IO to be aborted

\end{description}

\textbf{Description}
\begin{quote}

(linux scsi\_host\_template.eh\_abort\_handler routine)

Returns SUCCESS or FAILED.
\end{quote}
\index{mptscsih\_dev\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mptscsih_dev_reset}\pysiglinewithargsret{int \bfcode{mptscsih\_dev\_reset}}{struct scsi\_cmnd *\emph{ SCpnt}}{}
Perform a SCSI TARGET\_RESET! new\_eh variant

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * SCpnt}}] \leavevmode
Pointer to scsi\_cmnd structure, IO which reset is due to

\end{description}

\textbf{Description}
\begin{quote}

(linux scsi\_host\_template.eh\_dev\_reset\_handler routine)

Returns SUCCESS or FAILED.
\end{quote}
\index{mptscsih\_bus\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mptscsih_bus_reset}\pysiglinewithargsret{int \bfcode{mptscsih\_bus\_reset}}{struct scsi\_cmnd *\emph{ SCpnt}}{}
Perform a SCSI BUS\_RESET! new\_eh variant

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * SCpnt}}] \leavevmode
Pointer to scsi\_cmnd structure, IO which reset is due to

\end{description}

\textbf{Description}
\begin{quote}

(linux scsi\_host\_template.eh\_bus\_reset\_handler routine)

Returns SUCCESS or FAILED.
\end{quote}
\index{mptscsih\_host\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mptscsih_host_reset}\pysiglinewithargsret{int \bfcode{mptscsih\_host\_reset}}{struct scsi\_cmnd *\emph{ SCpnt}}{}
Perform a SCSI host adapter RESET (new\_eh variant)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * SCpnt}}] \leavevmode
Pointer to scsi\_cmnd structure, IO which reset is due to

\end{description}

\textbf{Description}
\begin{quote}

(linux scsi\_host\_template.eh\_host\_reset\_handler routine)

Returns SUCCESS or FAILED.
\end{quote}
\index{mptscsih\_taskmgmt\_complete (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mptscsih_taskmgmt_complete}\pysiglinewithargsret{int \bfcode{mptscsih\_taskmgmt\_complete}}{MPT\_ADAPTER *\emph{ ioc}, MPT\_FRAME\_HDR *\emph{ mf}, MPT\_FRAME\_HDR *\emph{ mr}}{}
Registered with Fusion MPT base driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to MPT\_ADAPTER structure

\item[{\code{MPT\_FRAME\_HDR * mf}}] \leavevmode
Pointer to SCSI task mgmt request frame

\item[{\code{MPT\_FRAME\_HDR * mr}}] \leavevmode
Pointer to SCSI task mgmt reply frame

\end{description}

\textbf{Description}
\begin{quote}

This routine is called from mptbase.c::\code{mpt\_interrupt()} at the completion
of any SCSI task management request.
This routine is registered with the MPT (base) driver at driver
load/init time via the {\hyperref[driver\string-api/message\string-based:c.mpt_register]{\emph{\code{mpt\_register()}}}} API call.

Returns 1 indicating alloc'd request frame ptr should be freed.
\end{quote}
\index{mptscsih\_get\_scsi\_lookup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/message-based:c.mptscsih_get_scsi_lookup}\pysiglinewithargsret{struct scsi\_cmnd * \bfcode{mptscsih\_get\_scsi\_lookup}}{MPT\_ADAPTER *\emph{ ioc}, int\emph{ i}}{}
retrieves scmd entry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{MPT\_ADAPTER * ioc}}] \leavevmode
Pointer to MPT\_ADAPTER structure

\item[{\code{int i}}] \leavevmode
index into the array

\end{description}

\textbf{Description}

Returns the scsi\_cmd pointer


\chapter{Sound Devices}
\label{driver-api/sound::doc}\label{driver-api/sound:sound-devices}\index{snd\_printk (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_printk}\pysiglinewithargsret{\bfcode{snd\_printk}}{\emph{fmt}, \emph{...}}{}
printk wrapper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{fmt}}] \leavevmode
format string

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

Works like {\hyperref[driver\string-api/basics:c.printk]{\emph{\code{printk()}}}} but prints the file and the line of the caller
when configured with CONFIG\_SND\_VERBOSE\_PRINTK.
\index{snd\_printd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_printd}\pysiglinewithargsret{\bfcode{snd\_printd}}{\emph{fmt}, \emph{...}}{}
debug printk

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{fmt}}] \leavevmode
format string

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

Works like {\hyperref[driver\string-api/sound:c.snd_printk]{\emph{\code{snd\_printk()}}}} for debugging purposes.
Ignored when CONFIG\_SND\_DEBUG is not set.
\index{snd\_BUG (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_BUG}\pysiglinewithargsret{\bfcode{snd\_BUG}}{}{}
give a BUG warning message and stack trace

\end{fulllineitems}


\textbf{Parameters}

\textbf{Description}

Calls \code{WARN()} if CONFIG\_SND\_DEBUG is set.
Ignored when CONFIG\_SND\_DEBUG is not set.
\index{snd\_printd\_ratelimit (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_printd_ratelimit}\pysiglinewithargsret{\bfcode{snd\_printd\_ratelimit}}{}{}
\end{fulllineitems}


\textbf{Parameters}
\index{snd\_BUG\_ON (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_BUG_ON}\pysiglinewithargsret{\bfcode{snd\_BUG\_ON}}{\emph{cond}}{}
debugging check macro

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{cond}}] \leavevmode
condition to evaluate

\end{description}

\textbf{Description}

Has the same behavior as WARN\_ON when CONFIG\_SND\_DEBUG is set,
otherwise just evaluates the conditional and returns the value.
\index{snd\_printdd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_printdd}\pysiglinewithargsret{\bfcode{snd\_printdd}}{\emph{format}, \emph{...}}{}
debug printk

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{format}}] \leavevmode
format string

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

Works like {\hyperref[driver\string-api/sound:c.snd_printk]{\emph{\code{snd\_printk()}}}} for debugging purposes.
Ignored when CONFIG\_SND\_DEBUG\_VERBOSE is not set.
\index{register\_sound\_special\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.register_sound_special_device}\pysiglinewithargsret{int \bfcode{register\_sound\_special\_device}}{const struct file\_operations *\emph{ fops}, int\emph{ unit}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
register a special sound node

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct file\_operations * fops}}] \leavevmode
File operations for the driver

\item[{\code{int unit}}] \leavevmode
Unit number to allocate

\item[{\code{struct device * dev}}] \leavevmode
device pointer

\end{description}

\textbf{Description}
\begin{quote}

Allocate a special sound device by minor number from the sound
subsystem.
\end{quote}

\textbf{Return}
\begin{description}
\item[{The allocated number is returned on success. On failure,}] \leavevmode
a negative error code is returned.

\end{description}
\index{register\_sound\_mixer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.register_sound_mixer}\pysiglinewithargsret{int \bfcode{register\_sound\_mixer}}{const struct file\_operations *\emph{ fops}, int\emph{ dev}}{}
register a mixer device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct file\_operations * fops}}] \leavevmode
File operations for the driver

\item[{\code{int dev}}] \leavevmode
Unit number to allocate

\end{description}

\textbf{Description}
\begin{quote}

Allocate a mixer device. Unit is the number of the mixer requested.
Pass -1 to request the next free mixer unit.
\end{quote}

\textbf{Return}
\begin{description}
\item[{On success, the allocated number is returned. On failure,}] \leavevmode
a negative error code is returned.

\end{description}
\index{register\_sound\_dsp (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.register_sound_dsp}\pysiglinewithargsret{int \bfcode{register\_sound\_dsp}}{const struct file\_operations *\emph{ fops}, int\emph{ dev}}{}
register a DSP device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct file\_operations * fops}}] \leavevmode
File operations for the driver

\item[{\code{int dev}}] \leavevmode
Unit number to allocate

\end{description}

\textbf{Description}
\begin{quote}

Allocate a DSP device. Unit is the number of the DSP requested.
Pass -1 to request the next free DSP unit.

This function allocates both the audio and dsp device entries together
and will always allocate them as a matching pair - eg dsp3/audio3
\end{quote}

\textbf{Return}
\begin{description}
\item[{On success, the allocated number is returned. On failure,}] \leavevmode
a negative error code is returned.

\end{description}
\index{unregister\_sound\_special (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.unregister_sound_special}\pysiglinewithargsret{void \bfcode{unregister\_sound\_special}}{int\emph{ unit}}{}
unregister a special sound device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int unit}}] \leavevmode
unit number to allocate

\end{description}

\textbf{Description}
\begin{quote}

Release a sound device that was allocated with
\code{register\_sound\_special()}. The unit passed is the return value from
the register function.
\end{quote}
\index{unregister\_sound\_mixer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.unregister_sound_mixer}\pysiglinewithargsret{void \bfcode{unregister\_sound\_mixer}}{int\emph{ unit}}{}
unregister a mixer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int unit}}] \leavevmode
unit number to allocate

\end{description}

\textbf{Description}
\begin{quote}

Release a sound device that was allocated with {\hyperref[driver\string-api/sound:c.register_sound_mixer]{\emph{\code{register\_sound\_mixer()}}}}.
The unit passed is the return value from the register function.
\end{quote}
\index{unregister\_sound\_dsp (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.unregister_sound_dsp}\pysiglinewithargsret{void \bfcode{unregister\_sound\_dsp}}{int\emph{ unit}}{}
unregister a DSP device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int unit}}] \leavevmode
unit number to allocate

\end{description}

\textbf{Description}
\begin{quote}

Release a sound device that was allocated with {\hyperref[driver\string-api/sound:c.register_sound_dsp]{\emph{\code{register\_sound\_dsp()}}}}.
The unit passed is the return value from the register function.

Both of the allocated units are released together automatically.
\end{quote}
\index{snd\_pcm\_stream\_linked (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_stream_linked}\pysiglinewithargsret{int \bfcode{snd\_pcm\_stream\_linked}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Check whether the substream is linked with others

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
substream to check

\end{description}

\textbf{Description}

Returns true if the given substream is being linked with others.
\index{snd\_pcm\_stream\_lock\_irqsave (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_stream_lock_irqsave}\pysiglinewithargsret{\bfcode{snd\_pcm\_stream\_lock\_irqsave}}{\emph{substream}, \emph{flags}}{}
Lock the PCM stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{substream}}] \leavevmode
PCM substream

\item[{\code{flags}}] \leavevmode
irq flags

\end{description}

\textbf{Description}

This locks the PCM stream like {\hyperref[driver\string-api/sound:c.snd_pcm_stream_lock]{\emph{\code{snd\_pcm\_stream\_lock()}}}} but with the local
IRQ (only when nonatomic is false).  In nonatomic case, this is identical
as {\hyperref[driver\string-api/sound:c.snd_pcm_stream_lock]{\emph{\code{snd\_pcm\_stream\_lock()}}}}.
\index{snd\_pcm\_group\_for\_each\_entry (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_group_for_each_entry}\pysiglinewithargsret{\bfcode{snd\_pcm\_group\_for\_each\_entry}}{\emph{s}, \emph{substream}}{}
iterate over the linked substreams

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{s}}] \leavevmode
the iterator

\item[{\code{substream}}] \leavevmode
the substream

\end{description}

\textbf{Description}

Iterate over the all linked substreams to the given \textbf{substream}.
When \textbf{substream} isn't linked with any others, this gives returns \textbf{substream}
itself once.
\index{snd\_pcm\_running (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_running}\pysiglinewithargsret{int \bfcode{snd\_pcm\_running}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Check whether the substream is in a running state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
substream to check

\end{description}

\textbf{Description}

Returns true if the given substream is in the state RUNNING, or in the
state DRAINING for playback.
\index{bytes\_to\_samples (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.bytes_to_samples}\pysiglinewithargsret{ssize\_t \bfcode{bytes\_to\_samples}}{struct snd\_pcm\_runtime *\emph{ runtime}, ssize\_t\emph{ size}}{}
Unit conversion of the size from bytes to samples

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{ssize\_t size}}] \leavevmode
size in bytes

\end{description}
\index{bytes\_to\_frames (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.bytes_to_frames}\pysiglinewithargsret{snd\_pcm\_sframes\_t \bfcode{bytes\_to\_frames}}{struct snd\_pcm\_runtime *\emph{ runtime}, ssize\_t\emph{ size}}{}
Unit conversion of the size from bytes to frames

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{ssize\_t size}}] \leavevmode
size in bytes

\end{description}
\index{samples\_to\_bytes (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.samples_to_bytes}\pysiglinewithargsret{ssize\_t \bfcode{samples\_to\_bytes}}{struct snd\_pcm\_runtime *\emph{ runtime}, ssize\_t\emph{ size}}{}
Unit conversion of the size from samples to bytes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{ssize\_t size}}] \leavevmode
size in samples

\end{description}
\index{frames\_to\_bytes (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.frames_to_bytes}\pysiglinewithargsret{ssize\_t \bfcode{frames\_to\_bytes}}{struct snd\_pcm\_runtime *\emph{ runtime}, snd\_pcm\_sframes\_t\emph{ size}}{}
Unit conversion of the size from frames to bytes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{snd\_pcm\_sframes\_t size}}] \leavevmode
size in frames

\end{description}
\index{frame\_aligned (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.frame_aligned}\pysiglinewithargsret{int \bfcode{frame\_aligned}}{struct snd\_pcm\_runtime *\emph{ runtime}, ssize\_t\emph{ bytes}}{}
Check whether the byte size is aligned to frames

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{ssize\_t bytes}}] \leavevmode
size in bytes

\end{description}
\index{snd\_pcm\_lib\_buffer\_bytes (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_lib_buffer_bytes}\pysiglinewithargsret{size\_t \bfcode{snd\_pcm\_lib\_buffer\_bytes}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Get the buffer size of the current PCM in bytes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\end{description}
\index{snd\_pcm\_lib\_period\_bytes (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_lib_period_bytes}\pysiglinewithargsret{size\_t \bfcode{snd\_pcm\_lib\_period\_bytes}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Get the period size of the current PCM in bytes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\end{description}
\index{snd\_pcm\_playback\_avail (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_playback_avail}\pysiglinewithargsret{snd\_pcm\_uframes\_t \bfcode{snd\_pcm\_playback\_avail}}{struct snd\_pcm\_runtime *\emph{ runtime}}{}
Get the available (writable) space for playback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\end{description}

\textbf{Description}

Result is between 0 ... (boundary - 1)
\index{snd\_pcm\_capture\_avail (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_capture_avail}\pysiglinewithargsret{snd\_pcm\_uframes\_t \bfcode{snd\_pcm\_capture\_avail}}{struct snd\_pcm\_runtime *\emph{ runtime}}{}
Get the available (readable) space for capture

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\end{description}

\textbf{Description}

Result is between 0 ... (boundary - 1)
\index{snd\_pcm\_playback\_hw\_avail (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_playback_hw_avail}\pysiglinewithargsret{snd\_pcm\_sframes\_t \bfcode{snd\_pcm\_playback\_hw\_avail}}{struct snd\_pcm\_runtime *\emph{ runtime}}{}
Get the queued space for playback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\end{description}
\index{snd\_pcm\_capture\_hw\_avail (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_capture_hw_avail}\pysiglinewithargsret{snd\_pcm\_sframes\_t \bfcode{snd\_pcm\_capture\_hw\_avail}}{struct snd\_pcm\_runtime *\emph{ runtime}}{}
Get the free space for capture

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\end{description}
\index{snd\_pcm\_playback\_ready (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_playback_ready}\pysiglinewithargsret{int \bfcode{snd\_pcm\_playback\_ready}}{struct snd\_pcm\_substream *\emph{ substream}}{}
check whether the playback buffer is available

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\end{description}

\textbf{Description}

Checks whether enough free space is available on the playback buffer.

\textbf{Return}

Non-zero if available, or zero if not.
\index{snd\_pcm\_capture\_ready (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_capture_ready}\pysiglinewithargsret{int \bfcode{snd\_pcm\_capture\_ready}}{struct snd\_pcm\_substream *\emph{ substream}}{}
check whether the capture buffer is available

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\end{description}

\textbf{Description}

Checks whether enough capture data is available on the capture buffer.

\textbf{Return}

Non-zero if available, or zero if not.
\index{snd\_pcm\_playback\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_playback_data}\pysiglinewithargsret{int \bfcode{snd\_pcm\_playback\_data}}{struct snd\_pcm\_substream *\emph{ substream}}{}
check whether any data exists on the playback buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\end{description}

\textbf{Description}

Checks whether any data exists on the playback buffer.

\textbf{Return}

Non-zero if any data exists, or zero if not. If stop\_threshold
is bigger or equal to boundary, then this function returns always non-zero.
\index{snd\_pcm\_playback\_empty (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_playback_empty}\pysiglinewithargsret{int \bfcode{snd\_pcm\_playback\_empty}}{struct snd\_pcm\_substream *\emph{ substream}}{}
check whether the playback buffer is empty

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\end{description}

\textbf{Description}

Checks whether the playback buffer is empty.

\textbf{Return}

Non-zero if empty, or zero if not.
\index{snd\_pcm\_capture\_empty (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_capture_empty}\pysiglinewithargsret{int \bfcode{snd\_pcm\_capture\_empty}}{struct snd\_pcm\_substream *\emph{ substream}}{}
check whether the capture buffer is empty

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\end{description}

\textbf{Description}

Checks whether the capture buffer is empty.

\textbf{Return}

Non-zero if empty, or zero if not.
\index{snd\_pcm\_trigger\_done (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_trigger_done}\pysiglinewithargsret{void \bfcode{snd\_pcm\_trigger\_done}}{struct snd\_pcm\_substream *\emph{ substream}, struct snd\_pcm\_substream *\emph{ master}}{}
Mark the master substream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\item[{\code{struct snd\_pcm\_substream * master}}] \leavevmode
the linked master substream

\end{description}

\textbf{Description}

When multiple substreams of the same card are linked and the hardware
supports the single-shot operation, the driver calls this in the loop
in {\hyperref[driver\string-api/sound:c.snd_pcm_group_for_each_entry]{\emph{\code{snd\_pcm\_group\_for\_each\_entry()}}}} for marking the substream as ``done''.
Then most of trigger operations are performed only to the given master
substream.

The trigger\_master mark is cleared at timestamp updates at the end
of trigger operations.
\index{params\_channels (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.params_channels}\pysiglinewithargsret{unsigned int \bfcode{params\_channels}}{const struct snd\_pcm\_hw\_params *\emph{ p}}{}
Get the number of channels from the hw params

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_pcm\_hw\_params * p}}] \leavevmode
hw params

\end{description}
\index{params\_rate (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.params_rate}\pysiglinewithargsret{unsigned int \bfcode{params\_rate}}{const struct snd\_pcm\_hw\_params *\emph{ p}}{}
Get the sample rate from the hw params

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_pcm\_hw\_params * p}}] \leavevmode
hw params

\end{description}
\index{params\_period\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.params_period_size}\pysiglinewithargsret{unsigned int \bfcode{params\_period\_size}}{const struct snd\_pcm\_hw\_params *\emph{ p}}{}
Get the period size (in frames) from the hw params

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_pcm\_hw\_params * p}}] \leavevmode
hw params

\end{description}
\index{params\_periods (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.params_periods}\pysiglinewithargsret{unsigned int \bfcode{params\_periods}}{const struct snd\_pcm\_hw\_params *\emph{ p}}{}
Get the number of periods from the hw params

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_pcm\_hw\_params * p}}] \leavevmode
hw params

\end{description}
\index{params\_buffer\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.params_buffer_size}\pysiglinewithargsret{unsigned int \bfcode{params\_buffer\_size}}{const struct snd\_pcm\_hw\_params *\emph{ p}}{}
Get the buffer size (in frames) from the hw params

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_pcm\_hw\_params * p}}] \leavevmode
hw params

\end{description}
\index{params\_buffer\_bytes (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.params_buffer_bytes}\pysiglinewithargsret{unsigned int \bfcode{params\_buffer\_bytes}}{const struct snd\_pcm\_hw\_params *\emph{ p}}{}
Get the buffer size (in bytes) from the hw params

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_pcm\_hw\_params * p}}] \leavevmode
hw params

\end{description}
\index{snd\_pcm\_hw\_constraint\_single (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_hw_constraint_single}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_single}}{struct snd\_pcm\_runtime *\emph{ runtime}, snd\_pcm\_hw\_param\_t\emph{ var}, unsigned int\emph{ val}}{}
Constrain parameter to a single value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
The hw\_params variable to constrain

\item[{\code{unsigned int val}}] \leavevmode
The value to constrain to

\end{description}

\textbf{Return}

Positive if the value is changed, zero if it's not changed, or a
negative error code.
\index{snd\_pcm\_format\_cpu\_endian (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_format_cpu_endian}\pysiglinewithargsret{int \bfcode{snd\_pcm\_format\_cpu\_endian}}{snd\_pcm\_format\_t\emph{ format}}{}
Check the PCM format is CPU-endian

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_pcm\_format\_t format}}] \leavevmode
the format to check

\end{description}

\textbf{Return}

1 if the given PCM format is CPU-endian, 0 if
opposite, or a negative error code if endian not specified.
\index{snd\_pcm\_set\_runtime\_buffer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_set_runtime_buffer}\pysiglinewithargsret{void \bfcode{snd\_pcm\_set\_runtime\_buffer}}{struct snd\_pcm\_substream *\emph{ substream}, struct snd\_dma\_buffer *\emph{ bufp}}{}
Set the PCM runtime buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream to set

\item[{\code{struct snd\_dma\_buffer * bufp}}] \leavevmode
the buffer information, NULL to clear

\end{description}

\textbf{Description}

Copy the buffer information to runtime-\textgreater{}dma\_buffer when \textbf{bufp} is non-NULL.
Otherwise it clears the current buffer information.
\index{snd\_pcm\_gettime (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_gettime}\pysiglinewithargsret{void \bfcode{snd\_pcm\_gettime}}{struct snd\_pcm\_runtime *\emph{ runtime}, struct timespec *\emph{ tv}}{}
Fill the timespec depending on the timestamp mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{struct timespec * tv}}] \leavevmode
timespec to fill

\end{description}
\index{snd\_pcm\_lib\_alloc\_vmalloc\_buffer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_lib_alloc_vmalloc_buffer}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_alloc\_vmalloc\_buffer}}{struct snd\_pcm\_substream *\emph{ substream}, size\_t\emph{ size}}{}
allocate virtual DMA buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the substream to allocate the buffer to

\item[{\code{size\_t size}}] \leavevmode
the requested buffer size, in bytes

\end{description}

\textbf{Description}

Allocates the PCM substream buffer using \code{vmalloc()}, i.e., the memory is
contiguous in kernel virtual space, but not in physical memory.  Use this
if the buffer is accessed by kernel code but not by device DMA.

\textbf{Return}

1 if the buffer was changed, 0 if not changed, or a negative error
code.
\index{snd\_pcm\_lib\_alloc\_vmalloc\_32\_buffer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_lib_alloc_vmalloc_32_buffer}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_alloc\_vmalloc\_32\_buffer}}{struct snd\_pcm\_substream *\emph{ substream}, size\_t\emph{ size}}{}
allocate 32-bit-addressable buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the substream to allocate the buffer to

\item[{\code{size\_t size}}] \leavevmode
the requested buffer size, in bytes

\end{description}

\textbf{Description}

This function works like {\hyperref[driver\string-api/sound:c.snd_pcm_lib_alloc_vmalloc_buffer]{\emph{\code{snd\_pcm\_lib\_alloc\_vmalloc\_buffer()}}}}, but uses
\code{vmalloc\_32()}, i.e., the pages are allocated from 32-bit-addressable memory.

\textbf{Return}

1 if the buffer was changed, 0 if not changed, or a negative error
code.
\index{snd\_pcm\_sgbuf\_get\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_sgbuf_get_addr}\pysiglinewithargsret{dma\_addr\_t \bfcode{snd\_pcm\_sgbuf\_get\_addr}}{struct snd\_pcm\_substream *\emph{ substream}, unsigned int\emph{ ofs}}{}
Get the DMA address at the corresponding offset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{unsigned int ofs}}] \leavevmode
byte offset

\end{description}
\index{snd\_pcm\_sgbuf\_get\_ptr (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_sgbuf_get_ptr}\pysiglinewithargsret{void * \bfcode{snd\_pcm\_sgbuf\_get\_ptr}}{struct snd\_pcm\_substream *\emph{ substream}, unsigned int\emph{ ofs}}{}
Get the virtual address at the corresponding offset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{unsigned int ofs}}] \leavevmode
byte offset

\end{description}
\index{snd\_pcm\_sgbuf\_get\_chunk\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_sgbuf_get_chunk_size}\pysiglinewithargsret{unsigned int \bfcode{snd\_pcm\_sgbuf\_get\_chunk\_size}}{struct snd\_pcm\_substream *\emph{ substream}, unsigned int\emph{ ofs}, unsigned int\emph{ size}}{}
Compute the max size that fits within the contig. page from the given size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{unsigned int ofs}}] \leavevmode
byte offset

\item[{\code{unsigned int size}}] \leavevmode
byte size to examine

\end{description}
\index{snd\_pcm\_mmap\_data\_open (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_mmap_data_open}\pysiglinewithargsret{void \bfcode{snd\_pcm\_mmap\_data\_open}}{struct vm\_area\_struct *\emph{ area}}{}
increase the mmap counter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vm\_area\_struct * area}}] \leavevmode
VMA

\end{description}

\textbf{Description}

PCM mmap callback should handle this counter properly
\index{snd\_pcm\_mmap\_data\_close (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_mmap_data_close}\pysiglinewithargsret{void \bfcode{snd\_pcm\_mmap\_data\_close}}{struct vm\_area\_struct *\emph{ area}}{}
decrease the mmap counter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vm\_area\_struct * area}}] \leavevmode
VMA

\end{description}

\textbf{Description}

PCM mmap callback should handle this counter properly
\index{snd\_pcm\_limit\_isa\_dma\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_limit_isa_dma_size}\pysiglinewithargsret{void \bfcode{snd\_pcm\_limit\_isa\_dma\_size}}{int\emph{ dma}, size\_t *\emph{ max}}{}
Get the max size fitting with ISA DMA transfer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int dma}}] \leavevmode
DMA number

\item[{\code{size\_t * max}}] \leavevmode
pointer to store the max size

\end{description}
\index{snd\_pcm\_stream\_str (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_stream_str}\pysiglinewithargsret{const char * \bfcode{snd\_pcm\_stream\_str}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Get a string naming the direction of a stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\end{description}

\textbf{Return}

A string naming the direction of the stream.
\index{snd\_pcm\_chmap\_substream (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_chmap_substream}\pysiglinewithargsret{struct snd\_pcm\_substream * \bfcode{snd\_pcm\_chmap\_substream}}{struct snd\_pcm\_chmap *\emph{ info}, unsigned int\emph{ idx}}{}
get the PCM substream assigned to the given chmap info

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_chmap * info}}] \leavevmode
chmap information

\item[{\code{unsigned int idx}}] \leavevmode
the substream number index

\end{description}
\index{pcm\_format\_to\_bits (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.pcm_format_to_bits}\pysiglinewithargsret{u64 \bfcode{pcm\_format\_to\_bits}}{snd\_pcm\_format\_t\emph{ pcm\_format}}{}
Strong-typed conversion of pcm\_format to bitwise

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_pcm\_format\_t pcm\_format}}] \leavevmode
PCM format

\end{description}
\index{snd\_pcm\_format\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_format_name}\pysiglinewithargsret{const char * \bfcode{snd\_pcm\_format\_name}}{snd\_pcm\_format\_t\emph{ format}}{}
Return a name string for the given PCM format

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_pcm\_format\_t format}}] \leavevmode
PCM format

\end{description}
\index{snd\_pcm\_new\_stream (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_new_stream}\pysiglinewithargsret{int \bfcode{snd\_pcm\_new\_stream}}{struct snd\_pcm *\emph{ pcm}, int\emph{ stream}, int\emph{ substream\_count}}{}
create a new PCM stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm * pcm}}] \leavevmode
the pcm instance

\item[{\code{int stream}}] \leavevmode
the stream direction, SNDRV\_PCM\_STREAM\_XXX

\item[{\code{int substream\_count}}] \leavevmode
the number of substreams

\end{description}

\textbf{Description}

Creates a new stream for the pcm.
The corresponding stream on the pcm must have been empty before
calling this, i.e. zero must be given to the argument of
{\hyperref[driver\string-api/sound:c.snd_pcm_new]{\emph{\code{snd\_pcm\_new()}}}}.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_new (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_new}\pysiglinewithargsret{int \bfcode{snd\_pcm\_new}}{struct snd\_card *\emph{ card}, const char *\emph{ id}, int\emph{ device}, int\emph{ playback\_count}, int\emph{ capture\_count}, struct snd\_pcm **\emph{ rpcm}}{}
create a new PCM instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{const char * id}}] \leavevmode
the id string

\item[{\code{int device}}] \leavevmode
the device index (zero based)

\item[{\code{int playback\_count}}] \leavevmode
the number of substreams for playback

\item[{\code{int capture\_count}}] \leavevmode
the number of substreams for capture

\item[{\code{struct snd\_pcm ** rpcm}}] \leavevmode
the pointer to store the new pcm instance

\end{description}

\textbf{Description}

Creates a new PCM instance.

The pcm operators have to be set afterwards to the new instance
via {\hyperref[driver\string-api/sound:c.snd_pcm_set_ops]{\emph{\code{snd\_pcm\_set\_ops()}}}}.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_new\_internal (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_new_internal}\pysiglinewithargsret{int \bfcode{snd\_pcm\_new\_internal}}{struct snd\_card *\emph{ card}, const char *\emph{ id}, int\emph{ device}, int\emph{ playback\_count}, int\emph{ capture\_count}, struct snd\_pcm **\emph{ rpcm}}{}
create a new internal PCM instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{const char * id}}] \leavevmode
the id string

\item[{\code{int device}}] \leavevmode
the device index (zero based - shared with normal PCMs)

\item[{\code{int playback\_count}}] \leavevmode
the number of substreams for playback

\item[{\code{int capture\_count}}] \leavevmode
the number of substreams for capture

\item[{\code{struct snd\_pcm ** rpcm}}] \leavevmode
the pointer to store the new pcm instance

\end{description}

\textbf{Description}

Creates a new internal PCM instance with no userspace device or procfs
entries. This is used by ASoC Back End PCMs in order to create a PCM that
will only be used internally by kernel drivers. i.e. it cannot be opened
by userspace. It provides existing ASoC components drivers with a substream
and access to any private data.

The pcm operators have to be set afterwards to the new instance
via {\hyperref[driver\string-api/sound:c.snd_pcm_set_ops]{\emph{\code{snd\_pcm\_set\_ops()}}}}.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_notify (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_notify}\pysiglinewithargsret{int \bfcode{snd\_pcm\_notify}}{struct {\hyperref[driver\string-api/sound:c.snd_pcm_notify]{\emph{snd\_pcm\_notify}}} *\emph{ notify}, int\emph{ nfree}}{}
Add/remove the notify list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_notify * notify}}] \leavevmode
PCM notify list

\item[{\code{int nfree}}] \leavevmode
0 = register, 1 = unregister

\end{description}

\textbf{Description}

This adds the given notifier to the global list so that the callback is
called for each registered PCM devices.  This exists only for PCM OSS
emulation, so far.
\index{snd\_device\_new (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_device_new}\pysiglinewithargsret{int \bfcode{snd\_device\_new}}{struct snd\_card *\emph{ card}, enum snd\_device\_type\emph{ type}, void *\emph{ device\_data}, struct snd\_device\_ops *\emph{ ops}}{}
create an ALSA device component

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{enum snd\_device\_type type}}] \leavevmode
the device type, SNDRV\_DEV\_XXX

\item[{\code{void * device\_data}}] \leavevmode
the data pointer of this device

\item[{\code{struct snd\_device\_ops * ops}}] \leavevmode
the operator table

\end{description}

\textbf{Description}

Creates a new device component for the given data pointer.
The device will be assigned to the card and managed together
by the card.

The data pointer plays a role as the identifier, too, so the
pointer address must be unique and unchanged.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_device\_disconnect (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_device_disconnect}\pysiglinewithargsret{void \bfcode{snd\_device\_disconnect}}{struct snd\_card *\emph{ card}, void *\emph{ device\_data}}{}
disconnect the device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{void * device\_data}}] \leavevmode
the data pointer to disconnect

\end{description}

\textbf{Description}

Turns the device into the disconnection state, invoking
dev\_disconnect callback, if the device was already registered.

Usually called from {\hyperref[driver\string-api/sound:c.snd_card_disconnect]{\emph{\code{snd\_card\_disconnect()}}}}.

\textbf{Return}

Zero if successful, or a negative error code on failure or if the
device not found.
\index{snd\_device\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_device_free}\pysiglinewithargsret{void \bfcode{snd\_device\_free}}{struct snd\_card *\emph{ card}, void *\emph{ device\_data}}{}
release the device from the card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{void * device\_data}}] \leavevmode
the data pointer to release

\end{description}

\textbf{Description}

Removes the device from the list on the card and invokes the
callbacks, dev\_disconnect and dev\_free, corresponding to the state.
Then release the device.
\index{snd\_device\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_device_register}\pysiglinewithargsret{int \bfcode{snd\_device\_register}}{struct snd\_card *\emph{ card}, void *\emph{ device\_data}}{}
register the device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{void * device\_data}}] \leavevmode
the data pointer to register

\end{description}

\textbf{Description}

Registers the device which was already created via
{\hyperref[driver\string-api/sound:c.snd_device_new]{\emph{\code{snd\_device\_new()}}}}.  Usually this is called from {\hyperref[driver\string-api/sound:c.snd_card_register]{\emph{\code{snd\_card\_register()}}}},
but it can be called later if any new devices are created after
invocation of {\hyperref[driver\string-api/sound:c.snd_card_register]{\emph{\code{snd\_card\_register()}}}}.

\textbf{Return}

Zero if successful, or a negative error code on failure or if the
device not found.
\index{snd\_info\_get\_line (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_info_get_line}\pysiglinewithargsret{int \bfcode{snd\_info\_get\_line}}{struct snd\_info\_buffer *\emph{ buffer}, char *\emph{ line}, int\emph{ len}}{}
read one line from the procfs buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_info\_buffer * buffer}}] \leavevmode
the procfs buffer

\item[{\code{char * line}}] \leavevmode
the buffer to store

\item[{\code{int len}}] \leavevmode
the max. buffer size

\end{description}

\textbf{Description}

Reads one line from the buffer and stores the string.

\textbf{Return}

Zero if successful, or 1 if error or EOF.
\index{snd\_info\_get\_str (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_info_get_str}\pysiglinewithargsret{const char * \bfcode{snd\_info\_get\_str}}{char *\emph{ dest}, const char *\emph{ src}, int\emph{ len}}{}
parse a string token

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{char * dest}}] \leavevmode
the buffer to store the string token

\item[{\code{const char * src}}] \leavevmode
the original string

\item[{\code{int len}}] \leavevmode
the max. length of token - 1

\end{description}

\textbf{Description}

Parses the original string and copy a token to the given
string buffer.

\textbf{Return}

The updated pointer of the original string so that
it can be used for the next call.
\index{snd\_info\_create\_module\_entry (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_info_create_module_entry}\pysiglinewithargsret{struct snd\_info\_entry * \bfcode{snd\_info\_create\_module\_entry}}{struct module *\emph{ module}, const char *\emph{ name}, struct snd\_info\_entry *\emph{ parent}}{}
create an info entry for the given module

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct module * module}}] \leavevmode
the module pointer

\item[{\code{const char * name}}] \leavevmode
the file name

\item[{\code{struct snd\_info\_entry * parent}}] \leavevmode
the parent directory

\end{description}

\textbf{Description}

Creates a new info entry and assigns it to the given module.

\textbf{Return}

The pointer of the new instance, or \code{NULL} on failure.
\index{snd\_info\_create\_card\_entry (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_info_create_card_entry}\pysiglinewithargsret{struct snd\_info\_entry * \bfcode{snd\_info\_create\_card\_entry}}{struct snd\_card *\emph{ card}, const char *\emph{ name}, struct snd\_info\_entry *\emph{ parent}}{}
create an info entry for the given card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{const char * name}}] \leavevmode
the file name

\item[{\code{struct snd\_info\_entry * parent}}] \leavevmode
the parent directory

\end{description}

\textbf{Description}

Creates a new info entry and assigns it to the given card.

\textbf{Return}

The pointer of the new instance, or \code{NULL} on failure.
\index{snd\_info\_free\_entry (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_info_free_entry}\pysiglinewithargsret{void \bfcode{snd\_info\_free\_entry}}{struct snd\_info\_entry *\emph{ entry}}{}
release the info entry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_info\_entry * entry}}] \leavevmode
the info entry

\end{description}

\textbf{Description}

Releases the info entry.
\index{snd\_info\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_info_register}\pysiglinewithargsret{int \bfcode{snd\_info\_register}}{struct snd\_info\_entry *\emph{ entry}}{}
register the info entry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_info\_entry * entry}}] \leavevmode
the info entry

\end{description}

\textbf{Description}

Registers the proc info entry.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_rawmidi\_receive (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_rawmidi_receive}\pysiglinewithargsret{int \bfcode{snd\_rawmidi\_receive}}{struct snd\_rawmidi\_substream *\emph{ substream}, const unsigned char *\emph{ buffer}, int\emph{ count}}{}
receive the input data from the device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_rawmidi\_substream * substream}}] \leavevmode
the rawmidi substream

\item[{\code{const unsigned char * buffer}}] \leavevmode
the buffer pointer

\item[{\code{int count}}] \leavevmode
the data size to read

\end{description}

\textbf{Description}

Reads the data from the internal buffer.

\textbf{Return}

The size of read data, or a negative error code on failure.
\index{snd\_rawmidi\_transmit\_empty (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_rawmidi_transmit_empty}\pysiglinewithargsret{int \bfcode{snd\_rawmidi\_transmit\_empty}}{struct snd\_rawmidi\_substream *\emph{ substream}}{}
check whether the output buffer is empty

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_rawmidi\_substream * substream}}] \leavevmode
the rawmidi substream

\end{description}

\textbf{Return}

1 if the internal output buffer is empty, 0 if not.
\index{\_\_snd\_rawmidi\_transmit\_peek (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.__snd_rawmidi_transmit_peek}\pysiglinewithargsret{int \bfcode{\_\_snd\_rawmidi\_transmit\_peek}}{struct snd\_rawmidi\_substream *\emph{ substream}, unsigned char *\emph{ buffer}, int\emph{ count}}{}
copy data from the internal buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_rawmidi\_substream * substream}}] \leavevmode
the rawmidi substream

\item[{\code{unsigned char * buffer}}] \leavevmode
the buffer pointer

\item[{\code{int count}}] \leavevmode
data size to transfer

\end{description}

\textbf{Description}

This is a variant of {\hyperref[driver\string-api/sound:c.snd_rawmidi_transmit_peek]{\emph{\code{snd\_rawmidi\_transmit\_peek()}}}} without spinlock.
\index{snd\_rawmidi\_transmit\_peek (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_rawmidi_transmit_peek}\pysiglinewithargsret{int \bfcode{snd\_rawmidi\_transmit\_peek}}{struct snd\_rawmidi\_substream *\emph{ substream}, unsigned char *\emph{ buffer}, int\emph{ count}}{}
copy data from the internal buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_rawmidi\_substream * substream}}] \leavevmode
the rawmidi substream

\item[{\code{unsigned char * buffer}}] \leavevmode
the buffer pointer

\item[{\code{int count}}] \leavevmode
data size to transfer

\end{description}

\textbf{Description}

Copies data from the internal output buffer to the given buffer.

Call this in the interrupt handler when the midi output is ready,
and call {\hyperref[driver\string-api/sound:c.snd_rawmidi_transmit_ack]{\emph{\code{snd\_rawmidi\_transmit\_ack()}}}} after the transmission is
finished.

\textbf{Return}

The size of copied data, or a negative error code on failure.
\index{\_\_snd\_rawmidi\_transmit\_ack (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.__snd_rawmidi_transmit_ack}\pysiglinewithargsret{int \bfcode{\_\_snd\_rawmidi\_transmit\_ack}}{struct snd\_rawmidi\_substream *\emph{ substream}, int\emph{ count}}{}
acknowledge the transmission

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_rawmidi\_substream * substream}}] \leavevmode
the rawmidi substream

\item[{\code{int count}}] \leavevmode
the transferred count

\end{description}

\textbf{Description}

This is a variant of {\hyperref[driver\string-api/sound:c.__snd_rawmidi_transmit_ack]{\emph{\code{\_\_snd\_rawmidi\_transmit\_ack()}}}} without spinlock.
\index{snd\_rawmidi\_transmit\_ack (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_rawmidi_transmit_ack}\pysiglinewithargsret{int \bfcode{snd\_rawmidi\_transmit\_ack}}{struct snd\_rawmidi\_substream *\emph{ substream}, int\emph{ count}}{}
acknowledge the transmission

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_rawmidi\_substream * substream}}] \leavevmode
the rawmidi substream

\item[{\code{int count}}] \leavevmode
the transferred count

\end{description}

\textbf{Description}

Advances the hardware pointer for the internal output buffer with
the given size and updates the condition.
Call after the transmission is finished.

\textbf{Return}

The advanced size if successful, or a negative error code on failure.
\index{snd\_rawmidi\_transmit (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_rawmidi_transmit}\pysiglinewithargsret{int \bfcode{snd\_rawmidi\_transmit}}{struct snd\_rawmidi\_substream *\emph{ substream}, unsigned char *\emph{ buffer}, int\emph{ count}}{}
copy from the buffer to the device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_rawmidi\_substream * substream}}] \leavevmode
the rawmidi substream

\item[{\code{unsigned char * buffer}}] \leavevmode
the buffer pointer

\item[{\code{int count}}] \leavevmode
the data size to transfer

\end{description}

\textbf{Description}

Copies data from the buffer to the device and advances the pointer.

\textbf{Return}

The copied size if successful, or a negative error code on failure.
\index{snd\_rawmidi\_new (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_rawmidi_new}\pysiglinewithargsret{int \bfcode{snd\_rawmidi\_new}}{struct snd\_card *\emph{ card}, char *\emph{ id}, int\emph{ device}, int\emph{ output\_count}, int\emph{ input\_count}, struct snd\_rawmidi **\emph{ rrawmidi}}{}
create a rawmidi instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{char * id}}] \leavevmode
the id string

\item[{\code{int device}}] \leavevmode
the device index

\item[{\code{int output\_count}}] \leavevmode
the number of output streams

\item[{\code{int input\_count}}] \leavevmode
the number of input streams

\item[{\code{struct snd\_rawmidi ** rrawmidi}}] \leavevmode
the pointer to store the new rawmidi instance

\end{description}

\textbf{Description}

Creates a new rawmidi instance.
Use {\hyperref[driver\string-api/sound:c.snd_rawmidi_set_ops]{\emph{\code{snd\_rawmidi\_set\_ops()}}}} to set the operators to the new instance.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_rawmidi\_set\_ops (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_rawmidi_set_ops}\pysiglinewithargsret{void \bfcode{snd\_rawmidi\_set\_ops}}{struct snd\_rawmidi *\emph{ rmidi}, int\emph{ stream}, const struct snd\_rawmidi\_ops *\emph{ ops}}{}
set the rawmidi operators

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_rawmidi * rmidi}}] \leavevmode
the rawmidi instance

\item[{\code{int stream}}] \leavevmode
the stream direction, SNDRV\_RAWMIDI\_STREAM\_XXX

\item[{\code{const struct snd\_rawmidi\_ops * ops}}] \leavevmode
the operator table

\end{description}

\textbf{Description}

Sets the rawmidi operators for the given stream direction.
\index{snd\_request\_card (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_request_card}\pysiglinewithargsret{void \bfcode{snd\_request\_card}}{int\emph{ card}}{}
try to load the card module

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int card}}] \leavevmode
the card number

\end{description}

\textbf{Description}

Tries to load the module ``snd-card-X'' for the given card number
via request\_module.  Returns immediately if already loaded.
\index{snd\_lookup\_minor\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_lookup_minor_data}\pysiglinewithargsret{void * \bfcode{snd\_lookup\_minor\_data}}{unsigned int\emph{ minor}, int\emph{ type}}{}
get user data of a registered device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int minor}}] \leavevmode
the minor number

\item[{\code{int type}}] \leavevmode
device type (SNDRV\_DEVICE\_TYPE\_XXX)

\end{description}

\textbf{Description}

Checks that a minor device with the specified type is registered, and returns
its user data pointer.

This function increments the reference counter of the card instance
if an associated instance with the given minor number and type is found.
The caller must call \code{snd\_card\_unref()} appropriately later.

\textbf{Return}

The user data pointer if the specified device is found. \code{NULL}
otherwise.
\index{snd\_register\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_register_device}\pysiglinewithargsret{int \bfcode{snd\_register\_device}}{int\emph{ type}, struct snd\_card *\emph{ card}, int\emph{ dev}, const struct file\_operations *\emph{ f\_ops}, void *\emph{ private\_data}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ device}}{}
Register the ALSA device file for the card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int type}}] \leavevmode
the device type, SNDRV\_DEVICE\_TYPE\_XXX

\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{int dev}}] \leavevmode
the device index

\item[{\code{const struct file\_operations * f\_ops}}] \leavevmode
the file operations

\item[{\code{void * private\_data}}] \leavevmode
user pointer for f\_ops-\textgreater{}:c:func:\emph{open()}

\item[{\code{struct device * device}}] \leavevmode
the device to register

\end{description}

\textbf{Description}

Registers an ALSA device file for the given card.
The operators have to be set in reg parameter.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_unregister\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_unregister_device}\pysiglinewithargsret{int \bfcode{snd\_unregister\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
unregister the device on the given card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
the device instance

\end{description}

\textbf{Description}

Unregisters the device file already registered via
{\hyperref[driver\string-api/sound:c.snd_register_device]{\emph{\code{snd\_register\_device()}}}}.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{copy\_to\_user\_fromio (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.copy_to_user_fromio}\pysiglinewithargsret{int \bfcode{copy\_to\_user\_fromio}}{void \_\_user *\emph{ dst}, const volatile void \_\_iomem *\emph{ src}, size\_t\emph{ count}}{}
copy data from mmio-space to user-space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void \_\_user * dst}}] \leavevmode
the destination pointer on user-space

\item[{\code{const volatile void \_\_iomem * src}}] \leavevmode
the source pointer on mmio

\item[{\code{size\_t count}}] \leavevmode
the data size to copy in bytes

\end{description}

\textbf{Description}

Copies the data from mmio-space to user-space.

\textbf{Return}

Zero if successful, or non-zero on failure.
\index{copy\_from\_user\_toio (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.copy_from_user_toio}\pysiglinewithargsret{int \bfcode{copy\_from\_user\_toio}}{volatile void \_\_iomem *\emph{ dst}, const void \_\_user *\emph{ src}, size\_t\emph{ count}}{}
copy data from user-space to mmio-space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{volatile void \_\_iomem * dst}}] \leavevmode
the destination pointer on mmio-space

\item[{\code{const void \_\_user * src}}] \leavevmode
the source pointer on user-space

\item[{\code{size\_t count}}] \leavevmode
the data size to copy in bytes

\end{description}

\textbf{Description}

Copies the data from user-space to mmio-space.

\textbf{Return}

Zero if successful, or non-zero on failure.
\index{snd\_pcm\_lib\_preallocate\_free\_for\_all (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_lib_preallocate_free_for_all}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_preallocate\_free\_for\_all}}{struct snd\_pcm *\emph{ pcm}}{}
release all pre-allocated buffers on the pcm

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm * pcm}}] \leavevmode
the pcm instance

\end{description}

\textbf{Description}

Releases all the pre-allocated buffers on the given pcm.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_lib\_preallocate\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_lib_preallocate_pages}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_preallocate\_pages}}{struct snd\_pcm\_substream *\emph{ substream}, int\emph{ type}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ data}, size\_t\emph{ size}, size\_t\emph{ max}}{}
pre-allocation for the given DMA type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\item[{\code{int type}}] \leavevmode
DMA type (SNDRV\_DMA\_TYPE\_*)

\item[{\code{struct device * data}}] \leavevmode
DMA type dependent data

\item[{\code{size\_t size}}] \leavevmode
the requested pre-allocation size in bytes

\item[{\code{size\_t max}}] \leavevmode
the max. allowed pre-allocation size

\end{description}

\textbf{Description}

Do pre-allocation for the given DMA buffer type.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_lib\_preallocate\_pages\_for\_all (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_lib_preallocate_pages_for_all}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_preallocate\_pages\_for\_all}}{struct snd\_pcm *\emph{ pcm}, int\emph{ type}, void *\emph{ data}, size\_t\emph{ size}, size\_t\emph{ max}}{}
pre-allocation for continuous memory type (all substreams)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm * pcm}}] \leavevmode
the pcm instance

\item[{\code{int type}}] \leavevmode
DMA type (SNDRV\_DMA\_TYPE\_*)

\item[{\code{void * data}}] \leavevmode
DMA type dependent data

\item[{\code{size\_t size}}] \leavevmode
the requested pre-allocation size in bytes

\item[{\code{size\_t max}}] \leavevmode
the max. allowed pre-allocation size

\end{description}

\textbf{Description}

Do pre-allocation to all substreams of the given pcm for the
specified DMA type.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_sgbuf\_ops\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_sgbuf_ops_page}\pysiglinewithargsret{struct page * \bfcode{snd\_pcm\_sgbuf\_ops\_page}}{struct snd\_pcm\_substream *\emph{ substream}, unsigned long\emph{ offset}}{}
get the page struct at the given offset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\item[{\code{unsigned long offset}}] \leavevmode
the buffer offset

\end{description}

\textbf{Description}

Used as the page callback of PCM ops.

\textbf{Return}

The page struct at the given buffer offset. \code{NULL} on failure.
\index{snd\_pcm\_lib\_malloc\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_lib_malloc_pages}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_malloc\_pages}}{struct snd\_pcm\_substream *\emph{ substream}, size\_t\emph{ size}}{}
allocate the DMA buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the substream to allocate the DMA buffer to

\item[{\code{size\_t size}}] \leavevmode
the requested buffer size in bytes

\end{description}

\textbf{Description}

Allocates the DMA buffer on the BUS type given earlier to
\code{snd\_pcm\_lib\_preallocate\_xxx\_pages()}.

\textbf{Return}

1 if the buffer is changed, 0 if not changed, or a negative
code on failure.
\index{snd\_pcm\_lib\_free\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_lib_free_pages}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_free\_pages}}{struct snd\_pcm\_substream *\emph{ substream}}{}
release the allocated DMA buffer.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the substream to release the DMA buffer

\end{description}

\textbf{Description}

Releases the DMA buffer allocated via {\hyperref[driver\string-api/sound:c.snd_pcm_lib_malloc_pages]{\emph{\code{snd\_pcm\_lib\_malloc\_pages()}}}}.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_lib\_free\_vmalloc\_buffer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_lib_free_vmalloc_buffer}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_free\_vmalloc\_buffer}}{struct snd\_pcm\_substream *\emph{ substream}}{}
free vmalloc buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the substream with a buffer allocated by
{\hyperref[driver\string-api/sound:c.snd_pcm_lib_alloc_vmalloc_buffer]{\emph{\code{snd\_pcm\_lib\_alloc\_vmalloc\_buffer()}}}}

\end{description}

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_lib\_get\_vmalloc\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_lib_get_vmalloc_page}\pysiglinewithargsret{struct page * \bfcode{snd\_pcm\_lib\_get\_vmalloc\_page}}{struct snd\_pcm\_substream *\emph{ substream}, unsigned long\emph{ offset}}{}
map vmalloc buffer offset to page struct

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the substream with a buffer allocated by
{\hyperref[driver\string-api/sound:c.snd_pcm_lib_alloc_vmalloc_buffer]{\emph{\code{snd\_pcm\_lib\_alloc\_vmalloc\_buffer()}}}}

\item[{\code{unsigned long offset}}] \leavevmode
offset in the buffer

\end{description}

\textbf{Description}

This function is to be used as the page callback in the PCM ops.

\textbf{Return}

The page struct, or \code{NULL} on failure.
\index{snd\_device\_initialize (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_device_initialize}\pysiglinewithargsret{void \bfcode{snd\_device\_initialize}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct snd\_card *\emph{ card}}{}
Initialize struct device for sound devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device to initialize

\item[{\code{struct snd\_card * card}}] \leavevmode
card to assign, optional

\end{description}
\index{snd\_card\_new (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_card_new}\pysiglinewithargsret{int \bfcode{snd\_card\_new}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ parent}, int\emph{ idx}, const char *\emph{ xid}, struct module *\emph{ module}, int\emph{ extra\_size}, struct snd\_card **\emph{ card\_ret}}{}
create and initialize a soundcard structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * parent}}] \leavevmode
the parent device object

\item[{\code{int idx}}] \leavevmode
card index (address) {[}0 ... (SNDRV\_CARDS-1){]}

\item[{\code{const char * xid}}] \leavevmode
card identification (ASCII string)

\item[{\code{struct module * module}}] \leavevmode
top level module for locking

\item[{\code{int extra\_size}}] \leavevmode
allocate this extra size after the main soundcard structure

\item[{\code{struct snd\_card ** card\_ret}}] \leavevmode
the pointer to store the created card instance

\end{description}

\textbf{Description}
\begin{quote}

Creates and initializes a soundcard structure.

The function allocates snd\_card instance via kzalloc with the given
space for the driver to use freely.  The allocated struct is stored
in the given card\_ret pointer.
\end{quote}

\textbf{Return}

Zero if successful or a negative error code.
\index{snd\_card\_disconnect (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_card_disconnect}\pysiglinewithargsret{int \bfcode{snd\_card\_disconnect}}{struct snd\_card *\emph{ card}}{}
disconnect all APIs from the file-operations (user space)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\end{description}

\textbf{Description}
\begin{quote}

Disconnects all APIs from the file-operations (user space).
\end{quote}

\textbf{Return}

Zero, otherwise a negative error code.

\textbf{Note}
\begin{description}
\item[{The current implementation replaces all active file-\textgreater{}f\_op with special}] \leavevmode
dummy file operations (they do nothing except release).

\end{description}
\index{snd\_card\_disconnect\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_card_disconnect_sync}\pysiglinewithargsret{void \bfcode{snd\_card\_disconnect\_sync}}{struct snd\_card *\emph{ card}}{}
disconnect card and wait until files get closed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
card object to disconnect

\end{description}

\textbf{Description}

This calls {\hyperref[driver\string-api/sound:c.snd_card_disconnect]{\emph{\code{snd\_card\_disconnect()}}}} for disconnecting all belonging components
and waits until all pending files get closed.
It assures that all accesses from user-space finished so that the driver
can release its resources gracefully.
\index{snd\_card\_free\_when\_closed (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_card_free_when_closed}\pysiglinewithargsret{int \bfcode{snd\_card\_free\_when\_closed}}{struct snd\_card *\emph{ card}}{}
Disconnect the card, free it later eventually

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\end{description}

\textbf{Description}

Unlike {\hyperref[driver\string-api/sound:c.snd_card_free]{\emph{\code{snd\_card\_free()}}}}, this function doesn't try to release the card
resource immediately, but tries to disconnect at first.  When the card
is still in use, the function returns before freeing the resources.
The card resources will be freed when the refcount gets to zero.
\index{snd\_card\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_card_free}\pysiglinewithargsret{int \bfcode{snd\_card\_free}}{struct snd\_card *\emph{ card}}{}
frees given soundcard structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\end{description}

\textbf{Description}

This function releases the soundcard structure and the all assigned
devices automatically.  That is, you don't have to release the devices
by yourself.

This function waits until the all resources are properly released.

\textbf{Return}

Zero. Frees all associated devices and frees the control
interface associated to given soundcard.
\index{snd\_card\_set\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_card_set_id}\pysiglinewithargsret{void \bfcode{snd\_card\_set\_id}}{struct snd\_card *\emph{ card}, const char *\emph{ nid}}{}
set card identification name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\item[{\code{const char * nid}}] \leavevmode
new identification string

\end{description}

\textbf{Description}
\begin{quote}

This function sets the card identification and checks for name
collisions.
\end{quote}
\index{snd\_card\_add\_dev\_attr (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_card_add_dev_attr}\pysiglinewithargsret{int \bfcode{snd\_card\_add\_dev\_attr}}{struct snd\_card *\emph{ card}, const struct attribute\_group *\emph{ group}}{}
Append a new sysfs attribute group to card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
card instance

\item[{\code{const struct attribute\_group * group}}] \leavevmode
attribute group to append

\end{description}
\index{snd\_card\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_card_register}\pysiglinewithargsret{int \bfcode{snd\_card\_register}}{struct snd\_card *\emph{ card}}{}
register the soundcard

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\end{description}

\textbf{Description}
\begin{quote}

This function registers all the devices assigned to the soundcard.
Until calling this, the ALSA control interface is blocked from the
external accesses.  Thus, you should call this function at the end
of the initialization of the card.
\end{quote}

\textbf{Return}

Zero otherwise a negative error code if the registration failed.
\index{snd\_component\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_component_add}\pysiglinewithargsret{int \bfcode{snd\_component\_add}}{struct snd\_card *\emph{ card}, const char *\emph{ component}}{}
add a component string

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\item[{\code{const char * component}}] \leavevmode
the component id string

\end{description}

\textbf{Description}
\begin{quote}

This function adds the component id string to the supported list.
The component can be referred from the alsa-lib.
\end{quote}

\textbf{Return}

Zero otherwise a negative error code.
\index{snd\_card\_file\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_card_file_add}\pysiglinewithargsret{int \bfcode{snd\_card\_file\_add}}{struct snd\_card *\emph{ card}, struct file *\emph{ file}}{}
add the file to the file list of the card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\item[{\code{struct file * file}}] \leavevmode
file pointer

\end{description}

\textbf{Description}
\begin{quote}

This function adds the file to the file linked-list of the card.
This linked-list is used to keep tracking the connection state,
and to avoid the release of busy resources by hotplug.
\end{quote}

\textbf{Return}

zero or a negative error code.
\index{snd\_card\_file\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_card_file_remove}\pysiglinewithargsret{int \bfcode{snd\_card\_file\_remove}}{struct snd\_card *\emph{ card}, struct file *\emph{ file}}{}
remove the file from the file list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\item[{\code{struct file * file}}] \leavevmode
file pointer

\end{description}

\textbf{Description}
\begin{quote}

This function removes the file formerly added to the card via
{\hyperref[driver\string-api/sound:c.snd_card_file_add]{\emph{\code{snd\_card\_file\_add()}}}} function.
If all files are removed and {\hyperref[driver\string-api/sound:c.snd_card_free_when_closed]{\emph{\code{snd\_card\_free\_when\_closed()}}}} was
called beforehand, it processes the pending release of
resources.
\end{quote}

\textbf{Return}

Zero or a negative error code.
\index{snd\_power\_wait (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_power_wait}\pysiglinewithargsret{int \bfcode{snd\_power\_wait}}{struct snd\_card *\emph{ card}, unsigned int\emph{ power\_state}}{}
wait until the power-state is changed.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\item[{\code{unsigned int power\_state}}] \leavevmode
expected power state

\end{description}

\textbf{Description}
\begin{quote}

Waits until the power-state is changed.
\end{quote}

\textbf{Return}

Zero if successful, or a negative error code.
\index{snd\_dma\_program (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_dma_program}\pysiglinewithargsret{void \bfcode{snd\_dma\_program}}{unsigned long\emph{ dma}, unsigned long\emph{ addr}, unsigned int\emph{ size}, unsigned short\emph{ mode}}{}
program an ISA DMA transfer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long dma}}] \leavevmode
the dma number

\item[{\code{unsigned long addr}}] \leavevmode
the physical address of the buffer

\item[{\code{unsigned int size}}] \leavevmode
the DMA transfer size

\item[{\code{unsigned short mode}}] \leavevmode
the DMA transfer mode, DMA\_MODE\_XXX

\end{description}

\textbf{Description}

Programs an ISA DMA transfer for the given buffer.
\index{snd\_dma\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_dma_disable}\pysiglinewithargsret{void \bfcode{snd\_dma\_disable}}{unsigned long\emph{ dma}}{}
stop the ISA DMA transfer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long dma}}] \leavevmode
the dma number

\end{description}

\textbf{Description}

Stops the ISA DMA transfer.
\index{snd\_dma\_pointer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_dma_pointer}\pysiglinewithargsret{unsigned int \bfcode{snd\_dma\_pointer}}{unsigned long\emph{ dma}, unsigned int\emph{ size}}{}
return the current pointer to DMA transfer buffer in bytes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long dma}}] \leavevmode
the dma number

\item[{\code{unsigned int size}}] \leavevmode
the dma transfer size

\end{description}

\textbf{Return}

The current pointer in DMA transfer buffer in bytes.
\index{snd\_ctl\_notify (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_notify}\pysiglinewithargsret{void \bfcode{snd\_ctl\_notify}}{struct snd\_card *\emph{ card}, unsigned int\emph{ mask}, struct snd\_ctl\_elem\_id *\emph{ id}}{}
Send notification to user-space for a control change

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card to send notification

\item[{\code{unsigned int mask}}] \leavevmode
the event mask, SNDRV\_CTL\_EVENT\_*

\item[{\code{struct snd\_ctl\_elem\_id * id}}] \leavevmode
the ctl element id to send notification

\end{description}

\textbf{Description}

This function adds an event record with the given id and mask, appends
to the list and wakes up the user-space for notification.  This can be
called in the atomic context.
\index{snd\_ctl\_new1 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_new1}\pysiglinewithargsret{struct snd\_kcontrol * \bfcode{snd\_ctl\_new1}}{const struct snd\_kcontrol\_new *\emph{ ncontrol}, void *\emph{ private\_data}}{}
create a control instance from the template

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_kcontrol\_new * ncontrol}}] \leavevmode
the initialization record

\item[{\code{void * private\_data}}] \leavevmode
the private data to set

\end{description}

\textbf{Description}

Allocates a new struct snd\_kcontrol instance and initialize from the given
template.  When the access field of ncontrol is 0, it's assumed as
READWRITE access. When the count field is 0, it's assumes as one.

\textbf{Return}

The pointer of the newly generated instance, or \code{NULL} on failure.
\index{snd\_ctl\_free\_one (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_free_one}\pysiglinewithargsret{void \bfcode{snd\_ctl\_free\_one}}{struct snd\_kcontrol *\emph{ kcontrol}}{}
release the control instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
the control instance

\end{description}

\textbf{Description}

Releases the control instance created via \code{snd\_ctl\_new()}
or {\hyperref[driver\string-api/sound:c.snd_ctl_new1]{\emph{\code{snd\_ctl\_new1()}}}}.
Don't call this after the control was added to the card.
\index{snd\_ctl\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_add}\pysiglinewithargsret{int \bfcode{snd\_ctl\_add}}{struct snd\_card *\emph{ card}, struct snd\_kcontrol *\emph{ kcontrol}}{}
add the control instance to the card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
the control instance to add

\end{description}

\textbf{Description}

Adds the control instance created via \code{snd\_ctl\_new()} or
{\hyperref[driver\string-api/sound:c.snd_ctl_new1]{\emph{\code{snd\_ctl\_new1()}}}} to the given card. Assigns also an unique
numid used for fast search.

It frees automatically the control which cannot be added.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_ctl\_replace (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_replace}\pysiglinewithargsret{int \bfcode{snd\_ctl\_replace}}{struct snd\_card *\emph{ card}, struct snd\_kcontrol *\emph{ kcontrol}, bool\emph{ add\_on\_replace}}{}
replace the control instance of the card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
the control instance to replace

\item[{\code{bool add\_on\_replace}}] \leavevmode
add the control if not already added

\end{description}

\textbf{Description}

Replaces the given control.  If the given control does not exist
and the add\_on\_replace flag is set, the control is added.  If the
control exists, it is destroyed first.

It frees automatically the control which cannot be added or replaced.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_ctl\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_remove}\pysiglinewithargsret{int \bfcode{snd\_ctl\_remove}}{struct snd\_card *\emph{ card}, struct snd\_kcontrol *\emph{ kcontrol}}{}
remove the control from the card and release it

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
the control instance to remove

\end{description}

\textbf{Description}

Removes the control from the card and then releases the instance.
You don't need to call {\hyperref[driver\string-api/sound:c.snd_ctl_free_one]{\emph{\code{snd\_ctl\_free\_one()}}}}. You must be in
the write lock - down\_write(\code{card-\textgreater{}controls\_rwsem}).

\textbf{Return}

0 if successful, or a negative error code on failure.
\index{snd\_ctl\_remove\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_remove_id}\pysiglinewithargsret{int \bfcode{snd\_ctl\_remove\_id}}{struct snd\_card *\emph{ card}, struct snd\_ctl\_elem\_id *\emph{ id}}{}
remove the control of the given id and release it

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{struct snd\_ctl\_elem\_id * id}}] \leavevmode
the control id to remove

\end{description}

\textbf{Description}

Finds the control instance with the given id, removes it from the
card list and releases it.

\textbf{Return}

0 if successful, or a negative error code on failure.
\index{snd\_ctl\_activate\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_activate_id}\pysiglinewithargsret{int \bfcode{snd\_ctl\_activate\_id}}{struct snd\_card *\emph{ card}, struct snd\_ctl\_elem\_id *\emph{ id}, int\emph{ active}}{}
activate/inactivate the control of the given id

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{struct snd\_ctl\_elem\_id * id}}] \leavevmode
the control id to activate/inactivate

\item[{\code{int active}}] \leavevmode
non-zero to activate

\end{description}

\textbf{Description}

Finds the control instance with the given id, and activate or
inactivate the control together with notification, if changed.
The given ID data is filled with full information.

\textbf{Return}

0 if unchanged, 1 if changed, or a negative error code on failure.
\index{snd\_ctl\_rename\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_rename_id}\pysiglinewithargsret{int \bfcode{snd\_ctl\_rename\_id}}{struct snd\_card *\emph{ card}, struct snd\_ctl\_elem\_id *\emph{ src\_id}, struct snd\_ctl\_elem\_id *\emph{ dst\_id}}{}
replace the id of a control on the card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{struct snd\_ctl\_elem\_id * src\_id}}] \leavevmode
the old id

\item[{\code{struct snd\_ctl\_elem\_id * dst\_id}}] \leavevmode
the new id

\end{description}

\textbf{Description}

Finds the control with the old id from the card, and replaces the
id with the new one.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_ctl\_find\_numid (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_find_numid}\pysiglinewithargsret{struct snd\_kcontrol * \bfcode{snd\_ctl\_find\_numid}}{struct snd\_card *\emph{ card}, unsigned int\emph{ numid}}{}
find the control instance with the given number-id

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{unsigned int numid}}] \leavevmode
the number-id to search

\end{description}

\textbf{Description}

Finds the control instance with the given number-id from the card.

The caller must down card-\textgreater{}controls\_rwsem before calling this function
(if the race condition can happen).

\textbf{Return}

The pointer of the instance if found, or \code{NULL} if not.
\index{snd\_ctl\_find\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_find_id}\pysiglinewithargsret{struct snd\_kcontrol * \bfcode{snd\_ctl\_find\_id}}{struct snd\_card *\emph{ card}, struct snd\_ctl\_elem\_id *\emph{ id}}{}
find the control instance with the given id

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{struct snd\_ctl\_elem\_id * id}}] \leavevmode
the id to search

\end{description}

\textbf{Description}

Finds the control instance with the given id from the card.

The caller must down card-\textgreater{}controls\_rwsem before calling this function
(if the race condition can happen).

\textbf{Return}

The pointer of the instance if found, or \code{NULL} if not.
\index{snd\_ctl\_register\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_register_ioctl}\pysiglinewithargsret{int \bfcode{snd\_ctl\_register\_ioctl}}{snd\_kctl\_ioctl\_func\_t\emph{ fcn}}{}
register the device-specific control-ioctls

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_kctl\_ioctl\_func\_t fcn}}] \leavevmode
ioctl callback function

\end{description}

\textbf{Description}

called from each device manager like pcm.c, hwdep.c, etc.
\index{snd\_ctl\_register\_ioctl\_compat (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_register_ioctl_compat}\pysiglinewithargsret{int \bfcode{snd\_ctl\_register\_ioctl\_compat}}{snd\_kctl\_ioctl\_func\_t\emph{ fcn}}{}
register the device-specific 32bit compat control-ioctls

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_kctl\_ioctl\_func\_t fcn}}] \leavevmode
ioctl callback function

\end{description}
\index{snd\_ctl\_unregister\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_unregister_ioctl}\pysiglinewithargsret{int \bfcode{snd\_ctl\_unregister\_ioctl}}{snd\_kctl\_ioctl\_func\_t\emph{ fcn}}{}
de-register the device-specific control-ioctls

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_kctl\_ioctl\_func\_t fcn}}] \leavevmode
ioctl callback function to unregister

\end{description}
\index{snd\_ctl\_unregister\_ioctl\_compat (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_unregister_ioctl_compat}\pysiglinewithargsret{int \bfcode{snd\_ctl\_unregister\_ioctl\_compat}}{snd\_kctl\_ioctl\_func\_t\emph{ fcn}}{}
de-register the device-specific compat 32bit control-ioctls

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_kctl\_ioctl\_func\_t fcn}}] \leavevmode
ioctl callback function to unregister

\end{description}
\index{snd\_ctl\_boolean\_mono\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_boolean_mono_info}\pysiglinewithargsret{int \bfcode{snd\_ctl\_boolean\_mono\_info}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_info *\emph{ uinfo}}{}
Helper function for a standard boolean info callback with a mono channel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
the kcontrol instance

\item[{\code{struct snd\_ctl\_elem\_info * uinfo}}] \leavevmode
info to store

\end{description}

\textbf{Description}

This is a function that can be used as info callback for a standard
boolean control with a single mono channel.
\index{snd\_ctl\_boolean\_stereo\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_boolean_stereo_info}\pysiglinewithargsret{int \bfcode{snd\_ctl\_boolean\_stereo\_info}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_info *\emph{ uinfo}}{}
Helper function for a standard boolean info callback with stereo two channels

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
the kcontrol instance

\item[{\code{struct snd\_ctl\_elem\_info * uinfo}}] \leavevmode
info to store

\end{description}

\textbf{Description}

This is a function that can be used as info callback for a standard
boolean control with stereo two channels.
\index{snd\_ctl\_enum\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_ctl_enum_info}\pysiglinewithargsret{int \bfcode{snd\_ctl\_enum\_info}}{struct snd\_ctl\_elem\_info *\emph{ info}, unsigned int\emph{ channels}, unsigned int\emph{ items}, const char *const\emph{ names}}{}
fills the info structure for an enumerated control

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_ctl\_elem\_info * info}}] \leavevmode
the structure to be filled

\item[{\code{unsigned int channels}}] \leavevmode
the number of the control's channels; often one

\item[{\code{unsigned int items}}] \leavevmode
the number of control values; also the size of \textbf{names}

\item[{\code{const char *const names}}] \leavevmode
an array containing the names of all control values

\end{description}

\textbf{Description}

Sets all required fields in \textbf{info} to their appropriate values.
If the control's accessibility is not the default (readable and writable),
the caller has to fill \textbf{info}-\textgreater{}access.

\textbf{Return}

Zero.
\index{snd\_pcm\_set\_ops (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_set_ops}\pysiglinewithargsret{void \bfcode{snd\_pcm\_set\_ops}}{struct snd\_pcm *\emph{ pcm}, int\emph{ direction}, const struct snd\_pcm\_ops *\emph{ ops}}{}
set the PCM operators

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm * pcm}}] \leavevmode
the pcm instance

\item[{\code{int direction}}] \leavevmode
stream direction, SNDRV\_PCM\_STREAM\_XXX

\item[{\code{const struct snd\_pcm\_ops * ops}}] \leavevmode
the operator table

\end{description}

\textbf{Description}

Sets the given PCM operators to the pcm instance.
\index{snd\_pcm\_set\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_set_sync}\pysiglinewithargsret{void \bfcode{snd\_pcm\_set\_sync}}{struct snd\_pcm\_substream *\emph{ substream}}{}
set the PCM sync id

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream

\end{description}

\textbf{Description}

Sets the PCM sync identifier for the card.
\index{snd\_interval\_refine (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_interval_refine}\pysiglinewithargsret{int \bfcode{snd\_interval\_refine}}{struct snd\_interval *\emph{ i}, const struct snd\_interval *\emph{ v}}{}
refine the interval value of configurator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_interval * i}}] \leavevmode
the interval value to refine

\item[{\code{const struct snd\_interval * v}}] \leavevmode
the interval value to refer to

\end{description}

\textbf{Description}

Refines the interval value with the reference value.
The interval is changed to the range satisfying both intervals.
The interval status (min, max, integer, etc.) are evaluated.

\textbf{Return}

Positive if the value is changed, zero if it's not changed, or a
negative error code.
\index{snd\_interval\_ratnum (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_interval_ratnum}\pysiglinewithargsret{int \bfcode{snd\_interval\_ratnum}}{struct snd\_interval *\emph{ i}, unsigned int\emph{ rats\_count}, const struct snd\_ratnum *\emph{ rats}, unsigned int *\emph{ nump}, unsigned int *\emph{ denp}}{}
refine the interval value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_interval * i}}] \leavevmode
interval to refine

\item[{\code{unsigned int rats\_count}}] \leavevmode
number of ratnum\_t

\item[{\code{const struct snd\_ratnum * rats}}] \leavevmode
ratnum\_t array

\item[{\code{unsigned int * nump}}] \leavevmode
pointer to store the resultant numerator

\item[{\code{unsigned int * denp}}] \leavevmode
pointer to store the resultant denominator

\end{description}

\textbf{Return}

Positive if the value is changed, zero if it's not changed, or a
negative error code.
\index{snd\_interval\_list (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_interval_list}\pysiglinewithargsret{int \bfcode{snd\_interval\_list}}{struct snd\_interval *\emph{ i}, unsigned int\emph{ count}, const unsigned int *\emph{ list}, unsigned int\emph{ mask}}{}
refine the interval value from the list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_interval * i}}] \leavevmode
the interval value to refine

\item[{\code{unsigned int count}}] \leavevmode
the number of elements in the list

\item[{\code{const unsigned int * list}}] \leavevmode
the value list

\item[{\code{unsigned int mask}}] \leavevmode
the bit-mask to evaluate

\end{description}

\textbf{Description}

Refines the interval value from the list.
When mask is non-zero, only the elements corresponding to bit 1 are
evaluated.

\textbf{Return}

Positive if the value is changed, zero if it's not changed, or a
negative error code.
\index{snd\_interval\_ranges (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_interval_ranges}\pysiglinewithargsret{int \bfcode{snd\_interval\_ranges}}{struct snd\_interval *\emph{ i}, unsigned int\emph{ count}, const struct snd\_interval *\emph{ ranges}, unsigned int\emph{ mask}}{}
refine the interval value from the list of ranges

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_interval * i}}] \leavevmode
the interval value to refine

\item[{\code{unsigned int count}}] \leavevmode
the number of elements in the list of ranges

\item[{\code{const struct snd\_interval * ranges}}] \leavevmode
the ranges list

\item[{\code{unsigned int mask}}] \leavevmode
the bit-mask to evaluate

\end{description}

\textbf{Description}

Refines the interval value from the list of ranges.
When mask is non-zero, only the elements corresponding to bit 1 are
evaluated.

\textbf{Return}

Positive if the value is changed, zero if it's not changed, or a
negative error code.
\index{snd\_pcm\_hw\_rule\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_hw_rule_add}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_rule\_add}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ cond}, int\emph{ var}, snd\_pcm\_hw\_rule\_func\_t\emph{ func}, void *\emph{ private}, int\emph{ dep}, ...}{}
add the hw-constraint rule

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
the pcm runtime instance

\item[{\code{unsigned int cond}}] \leavevmode
condition bits

\item[{\code{int var}}] \leavevmode
the variable to evaluate

\item[{\code{snd\_pcm\_hw\_rule\_func\_t func}}] \leavevmode
the evaluation function

\item[{\code{void * private}}] \leavevmode
the private data pointer passed to function

\item[{\code{int dep}}] \leavevmode
the dependent variables

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_constraint\_mask64 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_hw_constraint_mask64}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_mask64}}{struct snd\_pcm\_runtime *\emph{ runtime}, snd\_pcm\_hw\_param\_t\emph{ var}, u\_int64\_t\emph{ mask}}{}
apply the given bitmap mask constraint

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the mask

\item[{\code{u\_int64\_t mask}}] \leavevmode
the 64bit bitmap mask

\end{description}

\textbf{Description}

Apply the constraint of the given bitmap mask to a 64-bit mask parameter.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_constraint\_integer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_hw_constraint_integer}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_integer}}{struct snd\_pcm\_runtime *\emph{ runtime}, snd\_pcm\_hw\_param\_t\emph{ var}}{}
apply an integer constraint to an interval

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the integer constraint

\end{description}

\textbf{Description}

Apply the constraint of integer to an interval parameter.

\textbf{Return}

Positive if the value is changed, zero if it's not changed, or a
negative error code.
\index{snd\_pcm\_hw\_constraint\_minmax (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_hw_constraint_minmax}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_minmax}}{struct snd\_pcm\_runtime *\emph{ runtime}, snd\_pcm\_hw\_param\_t\emph{ var}, unsigned int\emph{ min}, unsigned int\emph{ max}}{}
apply a min/max range constraint to an interval

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the range

\item[{\code{unsigned int min}}] \leavevmode
the minimal value

\item[{\code{unsigned int max}}] \leavevmode
the maximal value

\end{description}

\textbf{Description}

Apply the min/max range constraint to an interval parameter.

\textbf{Return}

Positive if the value is changed, zero if it's not changed, or a
negative error code.
\index{snd\_pcm\_hw\_constraint\_list (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_hw_constraint_list}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_list}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ cond}, snd\_pcm\_hw\_param\_t\emph{ var}, const struct {\hyperref[driver\string-api/sound:c.snd_pcm_hw_constraint_list]{\emph{snd\_pcm\_hw\_constraint\_list}}} *\emph{ l}}{}
apply a list of constraints to a parameter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{unsigned int cond}}] \leavevmode
condition bits

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the list constraint

\item[{\code{const struct snd\_pcm\_hw\_constraint\_list * l}}] \leavevmode
list

\end{description}

\textbf{Description}

Apply the list of constraints to an interval parameter.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_constraint\_ranges (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_hw_constraint_ranges}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_ranges}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ cond}, snd\_pcm\_hw\_param\_t\emph{ var}, const struct {\hyperref[driver\string-api/sound:c.snd_pcm_hw_constraint_ranges]{\emph{snd\_pcm\_hw\_constraint\_ranges}}} *\emph{ r}}{}
apply list of range constraints to a parameter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{unsigned int cond}}] \leavevmode
condition bits

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the list of range constraints

\item[{\code{const struct snd\_pcm\_hw\_constraint\_ranges * r}}] \leavevmode
ranges

\end{description}

\textbf{Description}

Apply the list of range constraints to an interval parameter.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_constraint\_ratnums (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_hw_constraint_ratnums}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_ratnums}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ cond}, snd\_pcm\_hw\_param\_t\emph{ var}, const struct {\hyperref[driver\string-api/sound:c.snd_pcm_hw_constraint_ratnums]{\emph{snd\_pcm\_hw\_constraint\_ratnums}}} *\emph{ r}}{}
apply ratnums constraint to a parameter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{unsigned int cond}}] \leavevmode
condition bits

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the ratnums constraint

\item[{\code{const struct snd\_pcm\_hw\_constraint\_ratnums * r}}] \leavevmode
struct snd\_ratnums constriants

\end{description}

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_constraint\_ratdens (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_hw_constraint_ratdens}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_ratdens}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ cond}, snd\_pcm\_hw\_param\_t\emph{ var}, const struct {\hyperref[driver\string-api/sound:c.snd_pcm_hw_constraint_ratdens]{\emph{snd\_pcm\_hw\_constraint\_ratdens}}} *\emph{ r}}{}
apply ratdens constraint to a parameter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{unsigned int cond}}] \leavevmode
condition bits

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the ratdens constraint

\item[{\code{const struct snd\_pcm\_hw\_constraint\_ratdens * r}}] \leavevmode
struct snd\_ratdens constriants

\end{description}

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_constraint\_msbits (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_hw_constraint_msbits}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_msbits}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ cond}, unsigned int\emph{ width}, unsigned int\emph{ msbits}}{}
add a hw constraint msbits rule

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{unsigned int cond}}] \leavevmode
condition bits

\item[{\code{unsigned int width}}] \leavevmode
sample bits width

\item[{\code{unsigned int msbits}}] \leavevmode
msbits width

\end{description}

\textbf{Description}

This constraint will set the number of most significant bits (msbits) if a
sample format with the specified width has been select. If width is set to 0
the msbits will be set for any sample format with a width larger than the
specified msbits.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_constraint\_step (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_hw_constraint_step}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_step}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ cond}, snd\_pcm\_hw\_param\_t\emph{ var}, unsigned long\emph{ step}}{}
add a hw constraint step rule

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{unsigned int cond}}] \leavevmode
condition bits

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the step constraint

\item[{\code{unsigned long step}}] \leavevmode
step size

\end{description}

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_constraint\_pow2 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_hw_constraint_pow2}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_pow2}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ cond}, snd\_pcm\_hw\_param\_t\emph{ var}}{}
add a hw constraint power-of-2 rule

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{unsigned int cond}}] \leavevmode
condition bits

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the power-of-2 constraint

\end{description}

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_rule\_noresample (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_hw_rule_noresample}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_rule\_noresample}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ base\_rate}}{}
add a rule to allow disabling hw resampling

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{unsigned int base\_rate}}] \leavevmode
the rate at which the hardware does not resample

\end{description}

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_param\_value (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_hw_param_value}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_param\_value}}{const struct snd\_pcm\_hw\_params *\emph{ params}, snd\_pcm\_hw\_param\_t\emph{ var}, int *\emph{ dir}}{}
return \textbf{params} field \textbf{var} value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_pcm\_hw\_params * params}}] \leavevmode
the hw\_params instance

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
parameter to retrieve

\item[{\code{int * dir}}] \leavevmode
pointer to the direction (-1,0,1) or \code{NULL}

\end{description}

\textbf{Return}

The value for field \textbf{var} if it's fixed in configuration space
defined by \textbf{params}. -\code{EINVAL} otherwise.
\index{snd\_pcm\_hw\_param\_first (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_hw_param_first}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_param\_first}}{struct snd\_pcm\_substream *\emph{ pcm}, struct snd\_pcm\_hw\_params *\emph{ params}, snd\_pcm\_hw\_param\_t\emph{ var}, int *\emph{ dir}}{}
refine config space and return minimum value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * pcm}}] \leavevmode
PCM instance

\item[{\code{struct snd\_pcm\_hw\_params * params}}] \leavevmode
the hw\_params instance

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
parameter to retrieve

\item[{\code{int * dir}}] \leavevmode
pointer to the direction (-1,0,1) or \code{NULL}

\end{description}

\textbf{Description}

Inside configuration space defined by \textbf{params} remove from \textbf{var} all
values \textgreater{} minimum. Reduce configuration space accordingly.

\textbf{Return}

The minimum, or a negative error code on failure.
\index{snd\_pcm\_hw\_param\_last (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_hw_param_last}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_param\_last}}{struct snd\_pcm\_substream *\emph{ pcm}, struct snd\_pcm\_hw\_params *\emph{ params}, snd\_pcm\_hw\_param\_t\emph{ var}, int *\emph{ dir}}{}
refine config space and return maximum value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * pcm}}] \leavevmode
PCM instance

\item[{\code{struct snd\_pcm\_hw\_params * params}}] \leavevmode
the hw\_params instance

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
parameter to retrieve

\item[{\code{int * dir}}] \leavevmode
pointer to the direction (-1,0,1) or \code{NULL}

\end{description}

\textbf{Description}

Inside configuration space defined by \textbf{params} remove from \textbf{var} all
values \textless{} maximum. Reduce configuration space accordingly.

\textbf{Return}

The maximum, or a negative error code on failure.
\index{snd\_pcm\_lib\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_lib_ioctl}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_ioctl}}{struct snd\_pcm\_substream *\emph{ substream}, unsigned int\emph{ cmd}, void *\emph{ arg}}{}
a generic PCM ioctl callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\item[{\code{unsigned int cmd}}] \leavevmode
ioctl command

\item[{\code{void * arg}}] \leavevmode
ioctl argument

\end{description}

\textbf{Description}

Processes the generic ioctl commands for PCM.
Can be passed as the ioctl callback for PCM ops.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_period\_elapsed (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_period_elapsed}\pysiglinewithargsret{void \bfcode{snd\_pcm\_period\_elapsed}}{struct snd\_pcm\_substream *\emph{ substream}}{}
update the pcm status for the next period

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\end{description}

\textbf{Description}

This function is called from the interrupt handler when the
PCM has processed the period size.  It will update the current
pointer, wake up sleepers, etc.

Even if more than one periods have elapsed since the last call, you
have to call this only once.
\index{snd\_pcm\_add\_chmap\_ctls (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_add_chmap_ctls}\pysiglinewithargsret{int \bfcode{snd\_pcm\_add\_chmap\_ctls}}{struct snd\_pcm *\emph{ pcm}, int\emph{ stream}, const struct snd\_pcm\_chmap\_elem *\emph{ chmap}, int\emph{ max\_channels}, unsigned long\emph{ private\_value}, struct snd\_pcm\_chmap **\emph{ info\_ret}}{}
create channel-mapping control elements

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm * pcm}}] \leavevmode
the assigned PCM instance

\item[{\code{int stream}}] \leavevmode
stream direction

\item[{\code{const struct snd\_pcm\_chmap\_elem * chmap}}] \leavevmode
channel map elements (for query)

\item[{\code{int max\_channels}}] \leavevmode
the max number of channels for the stream

\item[{\code{unsigned long private\_value}}] \leavevmode
the value passed to each kcontrol's private\_value field

\item[{\code{struct snd\_pcm\_chmap ** info\_ret}}] \leavevmode
store struct snd\_pcm\_chmap instance if non-NULL

\end{description}

\textbf{Description}

Create channel-mapping control elements assigned to the given PCM stream(s).

\textbf{Return}

Zero if successful, or a negative error value.
\index{snd\_hwdep\_new (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_hwdep_new}\pysiglinewithargsret{int \bfcode{snd\_hwdep\_new}}{struct snd\_card *\emph{ card}, char *\emph{ id}, int\emph{ device}, struct snd\_hwdep **\emph{ rhwdep}}{}
create a new hwdep instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{char * id}}] \leavevmode
the id string

\item[{\code{int device}}] \leavevmode
the device index (zero-based)

\item[{\code{struct snd\_hwdep ** rhwdep}}] \leavevmode
the pointer to store the new hwdep instance

\end{description}

\textbf{Description}

Creates a new hwdep instance with the given index on the card.
The callbacks (hwdep-\textgreater{}ops) must be set on the returned instance
after this call manually by the caller.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_stream\_lock (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_stream_lock}\pysiglinewithargsret{void \bfcode{snd\_pcm\_stream\_lock}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Lock the PCM stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\end{description}

\textbf{Description}

This locks the PCM stream's spinlock or mutex depending on the nonatomic
flag of the given substream.  This also takes the global link rw lock
(or rw sem), too, for avoiding the race with linked streams.
\index{snd\_pcm\_stream\_unlock (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_stream_unlock}\pysiglinewithargsret{void \bfcode{snd\_pcm\_stream\_unlock}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Unlock the PCM stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\end{description}

\textbf{Description}

This unlocks the PCM stream that has been locked via {\hyperref[driver\string-api/sound:c.snd_pcm_stream_lock]{\emph{\code{snd\_pcm\_stream\_lock()}}}}.
\index{snd\_pcm\_stream\_lock\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_stream_lock_irq}\pysiglinewithargsret{void \bfcode{snd\_pcm\_stream\_lock\_irq}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Lock the PCM stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\end{description}

\textbf{Description}

This locks the PCM stream like {\hyperref[driver\string-api/sound:c.snd_pcm_stream_lock]{\emph{\code{snd\_pcm\_stream\_lock()}}}} and disables the local
IRQ (only when nonatomic is false).  In nonatomic case, this is identical
as {\hyperref[driver\string-api/sound:c.snd_pcm_stream_lock]{\emph{\code{snd\_pcm\_stream\_lock()}}}}.
\index{snd\_pcm\_stream\_unlock\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_stream_unlock_irq}\pysiglinewithargsret{void \bfcode{snd\_pcm\_stream\_unlock\_irq}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Unlock the PCM stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\end{description}

\textbf{Description}

This is a counter-part of {\hyperref[driver\string-api/sound:c.snd_pcm_stream_lock_irq]{\emph{\code{snd\_pcm\_stream\_lock\_irq()}}}}.
\index{snd\_pcm\_stream\_unlock\_irqrestore (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_stream_unlock_irqrestore}\pysiglinewithargsret{void \bfcode{snd\_pcm\_stream\_unlock\_irqrestore}}{struct snd\_pcm\_substream *\emph{ substream}, unsigned long\emph{ flags}}{}
Unlock the PCM stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{unsigned long flags}}] \leavevmode
irq flags

\end{description}

\textbf{Description}

This is a counter-part of {\hyperref[driver\string-api/sound:c.snd_pcm_stream_lock_irqsave]{\emph{\code{snd\_pcm\_stream\_lock\_irqsave()}}}}.
\index{snd\_pcm\_stop (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_stop}\pysiglinewithargsret{int \bfcode{snd\_pcm\_stop}}{struct snd\_pcm\_substream *\emph{ substream}, snd\_pcm\_state\_t\emph{ state}}{}
try to stop all running streams in the substream group

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the PCM substream instance

\item[{\code{snd\_pcm\_state\_t state}}] \leavevmode
PCM state after stopping the stream

\end{description}

\textbf{Description}

The state of each stream is then changed to the given state unconditionally.

\textbf{Return}

Zero if successful, or a negative error code.
\index{snd\_pcm\_stop\_xrun (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_stop_xrun}\pysiglinewithargsret{int \bfcode{snd\_pcm\_stop\_xrun}}{struct snd\_pcm\_substream *\emph{ substream}}{}
stop the running streams as XRUN

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the PCM substream instance

\end{description}

\textbf{Description}

This stops the given running substream (and all linked substreams) as XRUN.
Unlike {\hyperref[driver\string-api/sound:c.snd_pcm_stop]{\emph{\code{snd\_pcm\_stop()}}}}, this function takes the substream lock by itself.

\textbf{Return}

Zero if successful, or a negative error code.
\index{snd\_pcm\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_suspend}\pysiglinewithargsret{int \bfcode{snd\_pcm\_suspend}}{struct snd\_pcm\_substream *\emph{ substream}}{}
trigger SUSPEND to all linked streams

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the PCM substream

\end{description}

\textbf{Description}

After this call, all streams are changed to SUSPENDED state.

\textbf{Return}

Zero if successful (or \textbf{substream} is \code{NULL}), or a negative error
code.
\index{snd\_pcm\_suspend\_all (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_suspend_all}\pysiglinewithargsret{int \bfcode{snd\_pcm\_suspend\_all}}{struct snd\_pcm *\emph{ pcm}}{}
trigger SUSPEND to all substreams in the given pcm

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm * pcm}}] \leavevmode
the PCM instance

\end{description}

\textbf{Description}

After this call, all streams are changed to SUSPENDED state.

\textbf{Return}

Zero if successful (or \textbf{pcm} is \code{NULL}), or a negative error code.
\index{snd\_pcm\_kernel\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_kernel_ioctl}\pysiglinewithargsret{int \bfcode{snd\_pcm\_kernel\_ioctl}}{struct snd\_pcm\_substream *\emph{ substream}, unsigned int\emph{ cmd}, void *\emph{ arg}}{}
Execute PCM ioctl in the kernel-space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{unsigned int cmd}}] \leavevmode
IOCTL cmd

\item[{\code{void * arg}}] \leavevmode
IOCTL argument

\end{description}

\textbf{Description}

The function is provided primarily for OSS layer and USB gadget drivers,
and it allows only the limited set of ioctls (hw\_params, sw\_params,
prepare, start, drain, drop, forward).
\index{snd\_pcm\_lib\_default\_mmap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_lib_default_mmap}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_default\_mmap}}{struct snd\_pcm\_substream *\emph{ substream}, struct vm\_area\_struct *\emph{ area}}{}
Default PCM data mmap function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{struct vm\_area\_struct * area}}] \leavevmode
VMA

\end{description}

\textbf{Description}

This is the default mmap handler for PCM data.  When mmap pcm\_ops is NULL,
this function is invoked implicitly.
\index{snd\_pcm\_lib\_mmap\_iomem (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_pcm_lib_mmap_iomem}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_mmap\_iomem}}{struct snd\_pcm\_substream *\emph{ substream}, struct vm\_area\_struct *\emph{ area}}{}
Default PCM data mmap function for I/O mem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{struct vm\_area\_struct * area}}] \leavevmode
VMA

\end{description}

\textbf{Description}

When your hardware uses the iomapped pages as the hardware buffer and
wants to mmap it, pass this function as mmap pcm\_ops.  Note that this
is supposed to work only on limited architectures.
\index{snd\_malloc\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_malloc_pages}\pysiglinewithargsret{void * \bfcode{snd\_malloc\_pages}}{size\_t\emph{ size}, gfp\_t\emph{ gfp\_flags}}{}
allocate pages with the given size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{size\_t size}}] \leavevmode
the size to allocate in bytes

\item[{\code{gfp\_t gfp\_flags}}] \leavevmode
the allocation conditions, GFP\_XXX

\end{description}

\textbf{Description}

Allocates the physically contiguous pages with the given size.

\textbf{Return}

The pointer of the buffer, or \code{NULL} if no enough memory.
\index{snd\_free\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_free_pages}\pysiglinewithargsret{void \bfcode{snd\_free\_pages}}{void *\emph{ ptr}, size\_t\emph{ size}}{}
release the pages

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * ptr}}] \leavevmode
the buffer pointer to release

\item[{\code{size\_t size}}] \leavevmode
the allocated buffer size

\end{description}

\textbf{Description}

Releases the buffer allocated via {\hyperref[driver\string-api/sound:c.snd_malloc_pages]{\emph{\code{snd\_malloc\_pages()}}}}.
\index{snd\_dma\_alloc\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_dma_alloc_pages}\pysiglinewithargsret{int \bfcode{snd\_dma\_alloc\_pages}}{int\emph{ type}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ device}, size\_t\emph{ size}, struct snd\_dma\_buffer *\emph{ dmab}}{}
allocate the buffer area according to the given type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int type}}] \leavevmode
the DMA buffer type

\item[{\code{struct device * device}}] \leavevmode
the device pointer

\item[{\code{size\_t size}}] \leavevmode
the buffer size to allocate

\item[{\code{struct snd\_dma\_buffer * dmab}}] \leavevmode
buffer allocation record to store the allocated data

\end{description}

\textbf{Description}

Calls the memory-allocator function for the corresponding
buffer type.

\textbf{Return}

Zero if the buffer with the given size is allocated successfully,
otherwise a negative value on error.
\index{snd\_dma\_alloc\_pages\_fallback (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_dma_alloc_pages_fallback}\pysiglinewithargsret{int \bfcode{snd\_dma\_alloc\_pages\_fallback}}{int\emph{ type}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ device}, size\_t\emph{ size}, struct snd\_dma\_buffer *\emph{ dmab}}{}
allocate the buffer area according to the given type with fallback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int type}}] \leavevmode
the DMA buffer type

\item[{\code{struct device * device}}] \leavevmode
the device pointer

\item[{\code{size\_t size}}] \leavevmode
the buffer size to allocate

\item[{\code{struct snd\_dma\_buffer * dmab}}] \leavevmode
buffer allocation record to store the allocated data

\end{description}

\textbf{Description}

Calls the memory-allocator function for the corresponding
buffer type.  When no space is left, this function reduces the size and
tries to allocate again.  The size actually allocated is stored in
res\_size argument.

\textbf{Return}

Zero if the buffer with the given size is allocated successfully,
otherwise a negative value on error.
\index{snd\_dma\_free\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/sound:c.snd_dma_free_pages}\pysiglinewithargsret{void \bfcode{snd\_dma\_free\_pages}}{struct snd\_dma\_buffer *\emph{ dmab}}{}
release the allocated buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_dma\_buffer * dmab}}] \leavevmode
the buffer allocation record to release

\end{description}

\textbf{Description}

Releases the allocated buffer via {\hyperref[driver\string-api/sound:c.snd_dma_alloc_pages]{\emph{\code{snd\_dma\_alloc\_pages()}}}}.


\chapter{Frame Buffer Library}
\label{driver-api/frame-buffer:frame-buffer-library}\label{driver-api/frame-buffer::doc}
The frame buffer drivers depend heavily on four data structures. These
structures are declared in include/linux/fb.h. They are fb\_info,
fb\_var\_screeninfo, fb\_fix\_screeninfo and fb\_monospecs. The last
three can be made available to and from userland.

fb\_info defines the current state of a particular video card. Inside
fb\_info, there exists a fb\_ops structure which is a collection of
needed functions to make fbdev and fbcon work. fb\_info is only visible
to the kernel.

fb\_var\_screeninfo is used to describe the features of a video card
that are user defined. With fb\_var\_screeninfo, things such as depth
and the resolution may be defined.

The next structure is fb\_fix\_screeninfo. This defines the properties
of a card that are created when a mode is set and can't be changed
otherwise. A good example of this is the start of the frame buffer
memory. This ``locks'' the address of the frame buffer memory, so that it
cannot be changed or moved.

The last structure is fb\_monospecs. In the old API, there was little
importance for fb\_monospecs. This allowed for forbidden things such as
setting a mode of 800x600 on a fix frequency monitor. With the new API,
fb\_monospecs prevents such things, and if used correctly, can prevent a
monitor from being cooked. fb\_monospecs will not be useful until
kernels 2.5.x.


\section{Frame Buffer Memory}
\label{driver-api/frame-buffer:frame-buffer-memory}\index{register\_framebuffer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.register_framebuffer}\pysiglinewithargsret{int \bfcode{register\_framebuffer}}{struct fb\_info *\emph{ fb\_info}}{}
registers a frame buffer device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * fb\_info}}] \leavevmode
frame buffer info structure

\end{description}

\textbf{Description}
\begin{quote}

Registers a frame buffer device \textbf{fb\_info}.

Returns negative errno on error, or zero for success.
\end{quote}
\index{unregister\_framebuffer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.unregister_framebuffer}\pysiglinewithargsret{int \bfcode{unregister\_framebuffer}}{struct fb\_info *\emph{ fb\_info}}{}
releases a frame buffer device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * fb\_info}}] \leavevmode
frame buffer info structure

\end{description}

\textbf{Description}
\begin{quote}

Unregisters a frame buffer device \textbf{fb\_info}.

Returns negative errno on error, or zero for success.

This function will also notify the framebuffer console
to release the driver.

This is meant to be called within a driver's {\hyperref[driver\string-api/basics:c.module_exit]{\emph{\code{module\_exit()}}}}
function. If this is called outside {\hyperref[driver\string-api/basics:c.module_exit]{\emph{\code{module\_exit()}}}}, ensure
that the driver implements \code{fb\_open()} and \code{fb\_release()} to
check that no processes are using the device.
\end{quote}
\index{fb\_set\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_set_suspend}\pysiglinewithargsret{void \bfcode{fb\_set\_suspend}}{struct fb\_info *\emph{ info}, int\emph{ state}}{}
low level driver signals suspend

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_info * info}}] \leavevmode
framebuffer affected

\item[{\code{int state}}] \leavevmode
0 = resuming, !=0 = suspending

\end{description}

\textbf{Description}
\begin{quote}

This is meant to be used by low level drivers to
signal suspend/resume to the core \& clients.
It must be called with the console semaphore held
\end{quote}


\section{Frame Buffer Colormap}
\label{driver-api/frame-buffer:frame-buffer-colormap}\index{fb\_dealloc\_cmap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_dealloc_cmap}\pysiglinewithargsret{void \bfcode{fb\_dealloc\_cmap}}{struct fb\_cmap *\emph{ cmap}}{}
deallocate a colormap

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_cmap * cmap}}] \leavevmode
frame buffer colormap structure

\end{description}

\textbf{Description}
\begin{quote}

Deallocates a colormap that was previously allocated with
\code{fb\_alloc\_cmap()}.
\end{quote}
\index{fb\_copy\_cmap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_copy_cmap}\pysiglinewithargsret{int \bfcode{fb\_copy\_cmap}}{const struct fb\_cmap *\emph{ from}, struct fb\_cmap *\emph{ to}}{}
copy a colormap

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct fb\_cmap * from}}] \leavevmode
frame buffer colormap structure

\item[{\code{struct fb\_cmap * to}}] \leavevmode
frame buffer colormap structure

\end{description}

\textbf{Description}
\begin{quote}

Copy contents of colormap from \textbf{from} to \textbf{to}.
\end{quote}
\index{fb\_set\_cmap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_set_cmap}\pysiglinewithargsret{int \bfcode{fb\_set\_cmap}}{struct fb\_cmap *\emph{ cmap}, struct fb\_info *\emph{ info}}{}
set the colormap

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_cmap * cmap}}] \leavevmode
frame buffer colormap structure

\item[{\code{struct fb\_info * info}}] \leavevmode
frame buffer info structure

\end{description}

\textbf{Description}
\begin{quote}

Sets the colormap \textbf{cmap} for a screen of device \textbf{info}.

Returns negative errno on error, or zero on success.
\end{quote}
\index{fb\_default\_cmap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_default_cmap}\pysiglinewithargsret{const struct fb\_cmap * \bfcode{fb\_default\_cmap}}{int\emph{ len}}{}
get default colormap

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int len}}] \leavevmode
size of palette for a depth

\end{description}

\textbf{Description}
\begin{quote}

Gets the default colormap for a specific screen depth.  \textbf{len}
is the size of the palette for a particular screen depth.

Returns pointer to a frame buffer colormap structure.
\end{quote}
\index{fb\_invert\_cmaps (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_invert_cmaps}\pysiglinewithargsret{void \bfcode{fb\_invert\_cmaps}}{void}{}
invert all defaults colormaps

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}
\begin{quote}

Invert all default colormaps.
\end{quote}


\section{Frame Buffer Video Mode Database}
\label{driver-api/frame-buffer:frame-buffer-video-mode-database}\index{fb\_try\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_try_mode}\pysiglinewithargsret{int \bfcode{fb\_try\_mode}}{struct fb\_var\_screeninfo *\emph{ var}, struct fb\_info *\emph{ info}, const struct fb\_videomode *\emph{ mode}, unsigned int\emph{ bpp}}{}
test a video mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_var\_screeninfo * var}}] \leavevmode
frame buffer user defined part of display

\item[{\code{struct fb\_info * info}}] \leavevmode
frame buffer info structure

\item[{\code{const struct fb\_videomode * mode}}] \leavevmode
frame buffer video mode structure

\item[{\code{unsigned int bpp}}] \leavevmode
color depth in bits per pixel

\end{description}

\textbf{Description}
\begin{quote}

Tries a video mode to test it's validity for device \textbf{info}.

Returns 1 on success.
\end{quote}
\index{fb\_delete\_videomode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_delete_videomode}\pysiglinewithargsret{void \bfcode{fb\_delete\_videomode}}{const struct fb\_videomode *\emph{ mode}, struct list\_head *\emph{ head}}{}
removed videomode entry from modelist

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct fb\_videomode * mode}}] \leavevmode
videomode to remove

\item[{\code{struct list\_head * head}}] \leavevmode
struct list\_head of modelist

\end{description}

\textbf{NOTES}

Will remove all matching mode entries
\index{fb\_find\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_find_mode}\pysiglinewithargsret{int \bfcode{fb\_find\_mode}}{struct fb\_var\_screeninfo *\emph{ var}, struct fb\_info *\emph{ info}, const char *\emph{ mode\_option}, const struct fb\_videomode *\emph{ db}, unsigned int\emph{ dbsize}, const struct fb\_videomode *\emph{ default\_mode}, unsigned int\emph{ default\_bpp}}{}
finds a valid video mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_var\_screeninfo * var}}] \leavevmode
frame buffer user defined part of display

\item[{\code{struct fb\_info * info}}] \leavevmode
frame buffer info structure

\item[{\code{const char * mode\_option}}] \leavevmode
string video mode to find

\item[{\code{const struct fb\_videomode * db}}] \leavevmode
video mode database

\item[{\code{unsigned int dbsize}}] \leavevmode
size of \textbf{db}

\item[{\code{const struct fb\_videomode * default\_mode}}] \leavevmode
default video mode to fall back to

\item[{\code{unsigned int default\_bpp}}] \leavevmode
default color depth in bits per pixel

\end{description}

\textbf{Description}
\begin{quote}

Finds a suitable video mode, starting with the specified mode
in \textbf{mode\_option} with fallback to \textbf{default\_mode}.  If
\textbf{default\_mode} fails, all modes in the video mode database will
be tried.

Valid mode specifiers for \textbf{mode\_option}:

\textless{}xres\textgreater{}x\textless{}yres\textgreater{}{[}M{]}{[}R{]}{[}-\textless{}bpp\textgreater{}{]}{[}{\color{red}\bfseries{}**}{\color{red}\bfseries{}**}\textless{}refresh\textgreater{}{]}{[}i{]}{[}m{]} or
\textless{}name\textgreater{}{[}-\textless{}bpp\textgreater{}{]}{[}{\color{red}\bfseries{}**}{\color{red}\bfseries{}**}\textless{}refresh\textgreater{}{]}

with \textless{}xres\textgreater{}, \textless{}yres\textgreater{}, \textless{}bpp\textgreater{} and \textless{}refresh\textgreater{} decimal numbers and
\textless{}name\textgreater{} a string.
\begin{quote}

If `M' is present after yres (and before refresh/bpp if present),
the function will compute the timings using VESA(tm) Coordinated
Video Timings (CVT).  If `R' is present after `M', will compute with
reduced blanking (for flatpanels).  If `i' is present, compute
interlaced mode.  If `m' is present, add margins equal to 1.8\%
of xres rounded down to 8 pixels, and 1.8\% of yres. The char
`i' and `m' must be after `M' and `R'. Example:

1024x768MR-8**60m** - Reduced blank with margins at 60Hz.
\end{quote}
\end{quote}

\textbf{NOTE}
\begin{description}
\item[{The passed struct \textbf{var} is \_not\_ cleared!  This allows you}] \leavevmode
to supply values for e.g. the grayscale and accel\_flags fields.

Returns zero for failure, 1 if using specified \textbf{mode\_option},
2 if using specified \textbf{mode\_option} with an ignored refresh rate,
3 if default mode is used, 4 if fall back to any valid mode.

\end{description}
\index{fb\_var\_to\_videomode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_var_to_videomode}\pysiglinewithargsret{void \bfcode{fb\_var\_to\_videomode}}{struct fb\_videomode *\emph{ mode}, const struct fb\_var\_screeninfo *\emph{ var}}{}
convert fb\_var\_screeninfo to fb\_videomode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_videomode * mode}}] \leavevmode
pointer to struct fb\_videomode

\item[{\code{const struct fb\_var\_screeninfo * var}}] \leavevmode
pointer to struct fb\_var\_screeninfo

\end{description}
\index{fb\_videomode\_to\_var (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_videomode_to_var}\pysiglinewithargsret{void \bfcode{fb\_videomode\_to\_var}}{struct fb\_var\_screeninfo *\emph{ var}, const struct fb\_videomode *\emph{ mode}}{}
convert fb\_videomode to fb\_var\_screeninfo

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_var\_screeninfo * var}}] \leavevmode
pointer to struct fb\_var\_screeninfo

\item[{\code{const struct fb\_videomode * mode}}] \leavevmode
pointer to struct fb\_videomode

\end{description}
\index{fb\_mode\_is\_equal (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_mode_is_equal}\pysiglinewithargsret{int \bfcode{fb\_mode\_is\_equal}}{const struct fb\_videomode *\emph{ mode1}, const struct fb\_videomode *\emph{ mode2}}{}
compare 2 videomodes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct fb\_videomode * mode1}}] \leavevmode
first videomode

\item[{\code{const struct fb\_videomode * mode2}}] \leavevmode
second videomode

\end{description}

\textbf{Return}

1 if equal, 0 if not
\index{fb\_find\_best\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_find_best_mode}\pysiglinewithargsret{const struct fb\_videomode * \bfcode{fb\_find\_best\_mode}}{const struct fb\_var\_screeninfo *\emph{ var}, struct list\_head *\emph{ head}}{}
find best matching videomode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct fb\_var\_screeninfo * var}}] \leavevmode
pointer to struct fb\_var\_screeninfo

\item[{\code{struct list\_head * head}}] \leavevmode
pointer to struct list\_head of modelist

\end{description}

\textbf{Return}

struct fb\_videomode, NULL if none found

IMPORTANT:
This function assumes that all modelist entries in
info-\textgreater{}modelist are valid.

\textbf{NOTES}

Finds best matching videomode which has an equal or greater dimension than
var-\textgreater{}xres and var-\textgreater{}yres.  If more than 1 videomode is found, will return
the videomode with the highest refresh rate
\index{fb\_find\_nearest\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_find_nearest_mode}\pysiglinewithargsret{const struct fb\_videomode * \bfcode{fb\_find\_nearest\_mode}}{const struct fb\_videomode *\emph{ mode}, struct list\_head *\emph{ head}}{}
find closest videomode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct fb\_videomode * mode}}] \leavevmode
pointer to struct fb\_videomode

\item[{\code{struct list\_head * head}}] \leavevmode
pointer to modelist

\end{description}

\textbf{Description}

Finds best matching videomode, smaller or greater in dimension.
If more than 1 videomode is found, will return the videomode with
the closest refresh rate.
\index{fb\_match\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_match_mode}\pysiglinewithargsret{const struct fb\_videomode * \bfcode{fb\_match\_mode}}{const struct fb\_var\_screeninfo *\emph{ var}, struct list\_head *\emph{ head}}{}
find a videomode which exactly matches the timings in var

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct fb\_var\_screeninfo * var}}] \leavevmode
pointer to struct fb\_var\_screeninfo

\item[{\code{struct list\_head * head}}] \leavevmode
pointer to struct list\_head of modelist

\end{description}

\textbf{Return}

struct fb\_videomode, NULL if none found
\index{fb\_add\_videomode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_add_videomode}\pysiglinewithargsret{int \bfcode{fb\_add\_videomode}}{const struct fb\_videomode *\emph{ mode}, struct list\_head *\emph{ head}}{}
adds videomode entry to modelist

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct fb\_videomode * mode}}] \leavevmode
videomode to add

\item[{\code{struct list\_head * head}}] \leavevmode
struct list\_head of modelist

\end{description}

\textbf{NOTES}

Will only add unmatched mode entries
\index{fb\_destroy\_modelist (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_destroy_modelist}\pysiglinewithargsret{void \bfcode{fb\_destroy\_modelist}}{struct list\_head *\emph{ head}}{}
destroy modelist

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct list\_head * head}}] \leavevmode
struct list\_head of modelist

\end{description}
\index{fb\_videomode\_to\_modelist (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.fb_videomode_to_modelist}\pysiglinewithargsret{void \bfcode{fb\_videomode\_to\_modelist}}{const struct fb\_videomode *\emph{ modedb}, int\emph{ num}, struct list\_head *\emph{ head}}{}
convert mode array to mode list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct fb\_videomode * modedb}}] \leavevmode
array of struct fb\_videomode

\item[{\code{int num}}] \leavevmode
number of entries in array

\item[{\code{struct list\_head * head}}] \leavevmode
struct list\_head of modelist

\end{description}


\section{Frame Buffer Macintosh Video Mode Database}
\label{driver-api/frame-buffer:frame-buffer-macintosh-video-mode-database}\index{mac\_vmode\_to\_var (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.mac_vmode_to_var}\pysiglinewithargsret{int \bfcode{mac\_vmode\_to\_var}}{int\emph{ vmode}, int\emph{ cmode}, struct fb\_var\_screeninfo *\emph{ var}}{}
converts vmode/cmode pair to var structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int vmode}}] \leavevmode
MacOS video mode

\item[{\code{int cmode}}] \leavevmode
MacOS color mode

\item[{\code{struct fb\_var\_screeninfo * var}}] \leavevmode
frame buffer video mode structure

\end{description}

\textbf{Description}
\begin{quote}

Converts a MacOS vmode/cmode pair to a frame buffer video
mode structure.

Returns negative errno on error, or zero for success.
\end{quote}
\index{mac\_map\_monitor\_sense (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.mac_map_monitor_sense}\pysiglinewithargsret{int \bfcode{mac\_map\_monitor\_sense}}{int\emph{ sense}}{}
Convert monitor sense to vmode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int sense}}] \leavevmode
Macintosh monitor sense number

\end{description}

\textbf{Description}
\begin{quote}

Converts a Macintosh monitor sense number to a MacOS
vmode number.

Returns MacOS vmode video mode number.
\end{quote}
\index{mac\_find\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/frame-buffer:c.mac_find_mode}\pysiglinewithargsret{int \bfcode{mac\_find\_mode}}{struct fb\_var\_screeninfo *\emph{ var}, struct fb\_info *\emph{ info}, const char *\emph{ mode\_option}, unsigned int\emph{ default\_bpp}}{}
find a video mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fb\_var\_screeninfo * var}}] \leavevmode
frame buffer user defined part of display

\item[{\code{struct fb\_info * info}}] \leavevmode
frame buffer info structure

\item[{\code{const char * mode\_option}}] \leavevmode
video mode name (see mac\_modedb{[}{]})

\item[{\code{unsigned int default\_bpp}}] \leavevmode
default color depth in bits per pixel

\end{description}

\textbf{Description}
\begin{quote}

Finds a suitable video mode.  Tries to set mode specified
by \textbf{mode\_option}.  If the name of the wanted mode begins with
`mac', the Mac video mode database will be used, otherwise it
will fall back to the standard video mode database.
\end{quote}

\textbf{Note}
\begin{description}
\item[{Function marked as \_\_init and can only be used during}] \leavevmode
system boot.

Returns error code from fb\_find\_mode (see fb\_find\_mode
function).

\end{description}


\section{Frame Buffer Fonts}
\label{driver-api/frame-buffer:frame-buffer-fonts}
Refer to the file lib/fonts/fonts.c for more information.


\chapter{Voltage and current regulator API}
\label{driver-api/regulator::doc}\label{driver-api/regulator:voltage-and-current-regulator-api}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Liam Girdwood

\item[{Author}] \leavevmode
Mark Brown

\end{description}\end{quote}


\section{Introduction}
\label{driver-api/regulator:introduction}
This framework is designed to provide a standard kernel interface to
control voltage and current regulators.

The intention is to allow systems to dynamically control regulator power
output in order to save power and prolong battery life. This applies to
both voltage regulators (where voltage output is controllable) and
current sinks (where current limit is controllable).

Note that additional (and currently more complete) documentation is
available in the Linux kernel source under
\code{Documentation/power/regulator}.


\subsection{Glossary}
\label{driver-api/regulator:glossary}
The regulator API uses a number of terms which may not be familiar:

Regulator
\begin{quote}

Electronic device that supplies power to other devices. Most regulators
can enable and disable their output and some can also control their
output voltage or current.
\end{quote}

Consumer
\begin{quote}

Electronic device which consumes power provided by a regulator. These
may either be static, requiring only a fixed supply, or dynamic,
requiring active management of the regulator at runtime.
\end{quote}

Power Domain
\begin{quote}

The electronic circuit supplied by a given regulator, including the
regulator and all consumer devices. The configuration of the regulator
is shared between all the components in the circuit.
\end{quote}

Power Management Integrated Circuit (PMIC)
\begin{quote}

An IC which contains numerous regulators and often also other
subsystems. In an embedded system the primary PMIC is often equivalent
to a combination of the PSU and southbridge in a desktop system.
\end{quote}


\section{Consumer driver interface}
\label{driver-api/regulator:consumer-driver-interface}
This offers a similar API to the kernel clock framework. Consumer
drivers use {\hyperref[driver\string-api/regulator:API\string-regulator\string-get]{\emph{get}}} and
{\hyperref[driver\string-api/regulator:API\string-regulator\string-put]{\emph{put}}} operations to acquire and release
regulators. Functions are provided to {\hyperref[driver\string-api/regulator:API\string-regulator\string-enable]{\emph{enable}}}
and {\hyperref[driver\string-api/regulator:API\string-regulator\string-disable]{\emph{disable}}} the regulator and to get and
set the runtime parameters of the regulator.

When requesting regulators consumers use symbolic names for their
supplies, such as ``Vcc'', which are mapped into actual regulator devices
by the machine interface.

A stub version of this API is provided when the regulator framework is
not in use in order to minimise the need to use ifdefs.


\subsection{Enabling and disabling}
\label{driver-api/regulator:enabling-and-disabling}
The regulator API provides reference counted enabling and disabling of
regulators. Consumer devices use the {\hyperref[driver\string-api/regulator:c.regulator_enable]{\emph{\code{regulator\_enable()}}}} and
{\hyperref[driver\string-api/regulator:c.regulator_disable]{\emph{\code{regulator\_disable()}}}} functions to enable and disable
regulators. Calls to the two functions must be balanced.

Note that since multiple consumers may be using a regulator and machine
constraints may not allow the regulator to be disabled there is no
guarantee that calling {\hyperref[driver\string-api/regulator:c.regulator_disable]{\emph{\code{regulator\_disable()}}}} will actually
cause the supply provided by the regulator to be disabled. Consumer
drivers should assume that the regulator may be enabled at all times.


\subsection{Configuration}
\label{driver-api/regulator:configuration}
Some consumer devices may need to be able to dynamically configure their
supplies. For example, MMC drivers may need to select the correct
operating voltage for their cards. This may be done while the regulator
is enabled or disabled.

The {\hyperref[driver\string-api/regulator:c.regulator_set_voltage]{\emph{\code{regulator\_set\_voltage()}}}} and
{\hyperref[driver\string-api/regulator:c.regulator_set_current_limit]{\emph{\code{regulator\_set\_current\_limit()}}}} functions provide the primary
interface for this. Both take ranges of voltages and currents, supporting
drivers that do not require a specific value (eg, CPU frequency scaling
normally permits the CPU to use a wider range of supply voltages at lower
frequencies but does not require that the supply voltage be lowered). Where
an exact value is required both minimum and maximum values should be
identical.


\subsection{Callbacks}
\label{driver-api/regulator:callbacks}
Callbacks may also be registered for events such as regulation failures.


\section{Regulator driver interface}
\label{driver-api/regulator:regulator-driver-interface}
Drivers for regulator chips register the regulators with the regulator
core, providing operations structures to the core. A notifier interface
allows error conditions to be reported to the core.

Registration should be triggered by explicit setup done by the platform,
supplying a struct {\hyperref[driver\string-api/regulator:c.regulator_init_data]{\emph{\code{regulator\_init\_data}}}} for the regulator
containing constraint and supply information.


\section{Machine interface}
\label{driver-api/regulator:machine-interface}
This interface provides a way to define how regulators are connected to
consumers on a given system and what the valid operating parameters are
for the system.


\subsection{Supplies}
\label{driver-api/regulator:supplies}
Regulator supplies are specified using struct
{\hyperref[driver\string-api/regulator:c.regulator_consumer_supply]{\emph{\code{regulator\_consumer\_supply}}}}. This is done at driver registration
time as part of the machine constraints.


\subsection{Constraints}
\label{driver-api/regulator:constraints}
As well as defining the connections the machine interface also provides
constraints defining the operations that clients are allowed to perform
and the parameters that may be set. This is required since generally
regulator devices will offer more flexibility than it is safe to use on
a given system, for example supporting higher supply voltages than the
consumers are rated for.

This is done at driver registration time{}` by providing a
struct {\hyperref[driver\string-api/regulator:c.regulation_constraints]{\emph{\code{regulation\_constraints}}}}.

The constraints may also specify an initial configuration for the
regulator in the constraints, which is particularly useful for use with
static consumers.


\section{API reference}
\label{driver-api/regulator:api-reference}
Due to limitations of the kernel documentation framework and the
existing layout of the source code the entire regulator API is
documented here.
\index{pre\_voltage\_change\_data (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.pre_voltage_change_data}\pysigline{struct \bfcode{pre\_voltage\_change\_data}}
Data sent with PRE\_VOLTAGE\_CHANGE event

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct pre\PYGZus{}voltage\PYGZus{}change\PYGZus{}data \PYGZob{}
  unsigned long old\PYGZus{}uV;
  unsigned long min\PYGZus{}uV;
  unsigned long max\PYGZus{}uV;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{old\_uV}}] \leavevmode
Current voltage before change.

\item[{\code{min\_uV}}] \leavevmode
Min voltage we'll change to.

\item[{\code{max\_uV}}] \leavevmode
Max voltage we'll change to.

\end{description}
\index{regulator\_bulk\_data (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_bulk_data}\pysigline{struct \bfcode{regulator\_bulk\_data}}
Data used for bulk regulator operations.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct regulator\PYGZus{}bulk\PYGZus{}data \PYGZob{}
  const char *supply;
  struct regulator *consumer;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{supply}}] \leavevmode
The name of the supply.  Initialised by the user before
using the bulk regulator APIs.

\item[{\code{consumer}}] \leavevmode
The regulator consumer for the supply.  This will be managed
by the bulk API.

\end{description}

\textbf{Description}

The regulator APIs provide a series of \code{regulator\_bulk\_()} API calls as
a convenience to consumers which require multiple supplies.  This
structure is used to manage data for these calls.
\index{regulator\_state (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_state}\pysigline{struct \bfcode{regulator\_state}}
regulator state during low power system states

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct regulator\PYGZus{}state \PYGZob{}
  int uV;
  int min\PYGZus{}uV;
  int max\PYGZus{}uV;
  unsigned int mode;
  int enabled;
  bool changeable;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{uV}}] \leavevmode
Default operating voltage during suspend, it can be adjusted
among \textless{}min\_uV, max\_uV\textgreater{}.

\item[{\code{min\_uV}}] \leavevmode
Minimum suspend voltage may be set.

\item[{\code{max\_uV}}] \leavevmode
Maximum suspend voltage may be set.

\item[{\code{mode}}] \leavevmode
Operating mode during suspend.

\item[{\code{enabled}}] \leavevmode
operations during suspend.
- DO\_NOTHING\_IN\_SUSPEND
- DISABLE\_IN\_SUSPEND
- ENABLE\_IN\_SUSPEND

\item[{\code{changeable}}] \leavevmode
Is this state can be switched between enabled/disabled,

\end{description}

\textbf{Description}

This describes a regulators state during a system wide low power
state.  One of enabled or disabled must be set for the
configuration to be applied.
\index{regulation\_constraints (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulation_constraints}\pysigline{struct \bfcode{regulation\_constraints}}
regulator operating constraints.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct regulation\PYGZus{}constraints \PYGZob{}
  const char *name;
  int min\PYGZus{}uV;
  int max\PYGZus{}uV;
  int uV\PYGZus{}offset;
  int min\PYGZus{}uA;
  int max\PYGZus{}uA;
  int ilim\PYGZus{}uA;
  int system\PYGZus{}load;
  unsigned int valid\PYGZus{}modes\PYGZus{}mask;
  unsigned int valid\PYGZus{}ops\PYGZus{}mask;
  int input\PYGZus{}uV;
  struct regulator\PYGZus{}state state\PYGZus{}disk;
  struct regulator\PYGZus{}state state\PYGZus{}mem;
  struct regulator\PYGZus{}state state\PYGZus{}standby;
  suspend\PYGZus{}state\PYGZus{}t initial\PYGZus{}state;
  unsigned int initial\PYGZus{}mode;
  unsigned int ramp\PYGZus{}delay;
  unsigned int settling\PYGZus{}time;
  unsigned int settling\PYGZus{}time\PYGZus{}up;
  unsigned int settling\PYGZus{}time\PYGZus{}down;
  unsigned int enable\PYGZus{}time;
  unsigned int active\PYGZus{}discharge;
  unsigned always\PYGZus{}on:1;
  unsigned boot\PYGZus{}on:1;
  unsigned apply\PYGZus{}uV:1;
  unsigned ramp\PYGZus{}disable:1;
  unsigned soft\PYGZus{}start:1;
  unsigned pull\PYGZus{}down:1;
  unsigned over\PYGZus{}current\PYGZus{}protection:1;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
Descriptive name for the constraints, used for display purposes.

\item[{\code{min\_uV}}] \leavevmode
Smallest voltage consumers may set.

\item[{\code{max\_uV}}] \leavevmode
Largest voltage consumers may set.

\item[{\code{uV\_offset}}] \leavevmode
Offset applied to voltages from consumer to compensate for
voltage drops.

\item[{\code{min\_uA}}] \leavevmode
Smallest current consumers may set.

\item[{\code{max\_uA}}] \leavevmode
Largest current consumers may set.

\item[{\code{ilim\_uA}}] \leavevmode
Maximum input current.

\item[{\code{system\_load}}] \leavevmode
Load that isn't captured by any consumer requests.

\item[{\code{valid\_modes\_mask}}] \leavevmode
Mask of modes which may be configured by consumers.

\item[{\code{valid\_ops\_mask}}] \leavevmode
Operations which may be performed by consumers.

\item[{\code{input\_uV}}] \leavevmode
Input voltage for regulator when supplied by another regulator.

\item[{\code{state\_disk}}] \leavevmode
State for regulator when system is suspended in disk mode.

\item[{\code{state\_mem}}] \leavevmode
State for regulator when system is suspended in mem mode.

\item[{\code{state\_standby}}] \leavevmode
State for regulator when system is suspended in standby
mode.

\item[{\code{initial\_state}}] \leavevmode
Suspend state to set by default.

\item[{\code{initial\_mode}}] \leavevmode
Mode to set at startup.

\item[{\code{ramp\_delay}}] \leavevmode
Time to settle down after voltage change (unit: uV/us)

\item[{\code{settling\_time}}] \leavevmode
Time to settle down after voltage change when voltage
change is non-linear (unit: microseconds).

\item[{\code{settling\_time\_up}}] \leavevmode
Time to settle down after voltage increase when voltage
change is non-linear (unit: microseconds).

\item[{\code{settling\_time\_down}}] \leavevmode
Time to settle down after voltage decrease when
voltage change is non-linear (unit: microseconds).

\item[{\code{enable\_time}}] \leavevmode
Turn-on time of the rails (unit: microseconds)

\item[{\code{active\_discharge}}] \leavevmode
Enable/disable active discharge. The enum
regulator\_active\_discharge values are used for
initialisation.

\item[{\code{always\_on}}] \leavevmode
Set if the regulator should never be disabled.

\item[{\code{boot\_on}}] \leavevmode
Set if the regulator is enabled when the system is initially
started.  If the regulator is not enabled by the hardware or
bootloader then it will be enabled when the constraints are
applied.

\item[{\code{apply\_uV}}] \leavevmode
Apply the voltage constraint when initialising.

\item[{\code{ramp\_disable}}] \leavevmode
Disable ramp delay when initialising or when setting voltage.

\item[{\code{soft\_start}}] \leavevmode
Enable soft start so that voltage ramps slowly.

\item[{\code{pull\_down}}] \leavevmode
Enable pull down when regulator is disabled.

\item[{\code{over\_current\_protection}}] \leavevmode
Auto disable on over current event.

\end{description}

\textbf{Description}

This struct describes regulator and board/machine specific constraints.
\index{regulator\_consumer\_supply (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_consumer_supply}\pysigline{struct \bfcode{regulator\_consumer\_supply}}
supply -\textgreater{} device mapping

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct regulator\PYGZus{}consumer\PYGZus{}supply \PYGZob{}
  const char *dev\PYGZus{}name;
  const char *supply;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev\_name}}] \leavevmode
Result of \code{dev\_name()} for the consumer.

\item[{\code{supply}}] \leavevmode
Name for the supply.

\end{description}

\textbf{Description}

This maps a supply name to a device. Use of dev\_name allows support for
buses which make struct device available late such as I2C.
\index{regulator\_init\_data (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_init_data}\pysigline{struct \bfcode{regulator\_init\_data}}
regulator platform initialisation data.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct regulator\PYGZus{}init\PYGZus{}data \PYGZob{}
  const char *supply\PYGZus{}regulator;
  struct regulation\PYGZus{}constraints constraints;
  int num\PYGZus{}consumer\PYGZus{}supplies;
  struct regulator\PYGZus{}consumer\PYGZus{}supply *consumer\PYGZus{}supplies;
  int (*regulator\PYGZus{}init)(void *driver\PYGZus{}data);
  void *driver\PYGZus{}data;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{supply\_regulator}}] \leavevmode
Parent regulator.  Specified using the regulator name
as it appears in the name field in sysfs, which can
be explicitly set using the constraints field `name'.

\item[{\code{constraints}}] \leavevmode
Constraints.  These must be specified for the regulator to
be usable.

\item[{\code{num\_consumer\_supplies}}] \leavevmode
Number of consumer device supplies.

\item[{\code{consumer\_supplies}}] \leavevmode
Consumer device supply configuration.

\item[{\code{regulator\_init}}] \leavevmode
Callback invoked when the regulator has been registered.

\item[{\code{driver\_data}}] \leavevmode
Data passed to regulator\_init.

\end{description}

\textbf{Description}

Initialisation constraints, our supply and consumers supplies.
\index{regulator\_linear\_range (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_linear_range}\pysigline{struct \bfcode{regulator\_linear\_range}}
specify linear voltage ranges

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct regulator\PYGZus{}linear\PYGZus{}range \PYGZob{}
  unsigned int min\PYGZus{}uV;
  unsigned int min\PYGZus{}sel;
  unsigned int max\PYGZus{}sel;
  unsigned int uV\PYGZus{}step;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{min\_uV}}] \leavevmode
Lowest voltage in range

\item[{\code{min\_sel}}] \leavevmode
Lowest selector for range

\item[{\code{max\_sel}}] \leavevmode
Highest selector for range

\item[{\code{uV\_step}}] \leavevmode
Step size

\end{description}

\textbf{Description}

Specify a range of voltages for \code{regulator\_map\_linar\_range()} and
\code{regulator\_list\_linear\_range()}.
\index{regulator\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_ops}\pysigline{struct \bfcode{regulator\_ops}}
regulator operations.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct regulator\PYGZus{}ops \PYGZob{}
  int (*list\PYGZus{}voltage) (struct regulator\PYGZus{}dev *, unsigned selector);
  int (*set\PYGZus{}voltage) (struct regulator\PYGZus{}dev *, int min\PYGZus{}uV, int max\PYGZus{}uV, unsigned *selector);
  int (*map\PYGZus{}voltage)(struct regulator\PYGZus{}dev *, int min\PYGZus{}uV, int max\PYGZus{}uV);
  int (*set\PYGZus{}voltage\PYGZus{}sel) (struct regulator\PYGZus{}dev *, unsigned selector);
  int (*get\PYGZus{}voltage) (struct regulator\PYGZus{}dev *);
  int (*get\PYGZus{}voltage\PYGZus{}sel) (struct regulator\PYGZus{}dev *);
  int (*set\PYGZus{}current\PYGZus{}limit) (struct regulator\PYGZus{}dev *, int min\PYGZus{}uA, int max\PYGZus{}uA);
  int (*get\PYGZus{}current\PYGZus{}limit) (struct regulator\PYGZus{}dev *);
  int (*set\PYGZus{}input\PYGZus{}current\PYGZus{}limit) (struct regulator\PYGZus{}dev *, int lim\PYGZus{}uA);
  int (*set\PYGZus{}over\PYGZus{}current\PYGZus{}protection) (struct regulator\PYGZus{}dev *);
  int (*set\PYGZus{}active\PYGZus{}discharge) (struct regulator\PYGZus{}dev *, bool enable);
  int (*enable) (struct regulator\PYGZus{}dev *);
  int (*disable) (struct regulator\PYGZus{}dev *);
  int (*is\PYGZus{}enabled) (struct regulator\PYGZus{}dev *);
  int (*set\PYGZus{}mode) (struct regulator\PYGZus{}dev *, unsigned int mode);
  unsigned int (*get\PYGZus{}mode) (struct regulator\PYGZus{}dev *);
  int (*get\PYGZus{}error\PYGZus{}flags)(struct regulator\PYGZus{}dev *, unsigned int *flags);
  int (*enable\PYGZus{}time) (struct regulator\PYGZus{}dev *);
  int (*set\PYGZus{}ramp\PYGZus{}delay) (struct regulator\PYGZus{}dev *, int ramp\PYGZus{}delay);
  int (*set\PYGZus{}voltage\PYGZus{}time) (struct regulator\PYGZus{}dev *, int old\PYGZus{}uV, int new\PYGZus{}uV);
  int (*set\PYGZus{}voltage\PYGZus{}time\PYGZus{}sel) (struct regulator\PYGZus{}dev *,unsigned int old\PYGZus{}selector, unsigned int new\PYGZus{}selector);
  int (*set\PYGZus{}soft\PYGZus{}start) (struct regulator\PYGZus{}dev *);
  int (*get\PYGZus{}status)(struct regulator\PYGZus{}dev *);
  unsigned int (*get\PYGZus{}optimum\PYGZus{}mode) (struct regulator\PYGZus{}dev *, int input\PYGZus{}uV, int output\PYGZus{}uV, int load\PYGZus{}uA);
  int (*set\PYGZus{}load)(struct regulator\PYGZus{}dev *, int load\PYGZus{}uA);
  int (*set\PYGZus{}bypass)(struct regulator\PYGZus{}dev *dev, bool enable);
  int (*get\PYGZus{}bypass)(struct regulator\PYGZus{}dev *dev, bool *enable);
  int (*set\PYGZus{}suspend\PYGZus{}voltage) (struct regulator\PYGZus{}dev *, int uV);
  int (*set\PYGZus{}suspend\PYGZus{}enable) (struct regulator\PYGZus{}dev *);
  int (*set\PYGZus{}suspend\PYGZus{}disable) (struct regulator\PYGZus{}dev *);
  int (*set\PYGZus{}suspend\PYGZus{}mode) (struct regulator\PYGZus{}dev *, unsigned int mode);
  int (*resume\PYGZus{}early)(struct regulator\PYGZus{}dev *rdev);
  int (*set\PYGZus{}pull\PYGZus{}down) (struct regulator\PYGZus{}dev *);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{list\_voltage}}] \leavevmode
Return one of the supported voltages, in microvolts; zero
if the selector indicates a voltage that is unusable on this system;
or negative errno.  Selectors range from zero to one less than
regulator\_desc.n\_voltages.  Voltages may be reported in any order.

\item[{\code{set\_voltage}}] \leavevmode
Set the voltage for the regulator within the range specified.
The driver should select the voltage closest to min\_uV.

\item[{\code{map\_voltage}}] \leavevmode
Convert a voltage into a selector

\item[{\code{set\_voltage\_sel}}] \leavevmode
Set the voltage for the regulator using the specified
selector.

\item[{\code{get\_voltage}}] \leavevmode
Return the currently configured voltage for the regulator.

\item[{\code{get\_voltage\_sel}}] \leavevmode
Return the currently configured voltage selector for the
regulator.

\item[{\code{set\_current\_limit}}] \leavevmode
Configure a limit for a current-limited regulator.
The driver should select the current closest to max\_uA.

\item[{\code{get\_current\_limit}}] \leavevmode
Get the configured limit for a current-limited regulator.

\item[{\code{set\_input\_current\_limit}}] \leavevmode
Configure an input limit.

\item[{\code{set\_over\_current\_protection}}] \leavevmode
Support capability of automatically shutting
down when detecting an over current event.

\item[{\code{set\_active\_discharge}}] \leavevmode
Set active discharge enable/disable of regulators.

\item[{\code{enable}}] \leavevmode
Configure the regulator as enabled.

\item[{\code{disable}}] \leavevmode
Configure the regulator as disabled.

\item[{\code{is\_enabled}}] \leavevmode
Return 1 if the regulator is enabled, 0 if not.
May also return negative errno.

\item[{\code{set\_mode}}] \leavevmode
Set the configured operating mode for the regulator.

\item[{\code{get\_mode}}] \leavevmode
Get the configured operating mode for the regulator.

\item[{\code{get\_error\_flags}}] \leavevmode
Get the current error(s) for the regulator.

\item[{\code{enable\_time}}] \leavevmode
Time taken for the regulator voltage output voltage to
stabilise after being enabled, in microseconds.

\item[{\code{set\_ramp\_delay}}] \leavevmode
Set the ramp delay for the regulator. The driver should
select ramp delay equal to or less than(closest) ramp\_delay.

\item[{\code{set\_voltage\_time}}] \leavevmode
Time taken for the regulator voltage output voltage
to stabilise after being set to a new value, in microseconds.
The function receives the from and to voltage as input, it
should return the worst case.

\item[{\code{set\_voltage\_time\_sel}}] \leavevmode
Time taken for the regulator voltage output voltage
to stabilise after being set to a new value, in microseconds.
The function receives the from and to voltage selector as
input, it should return the worst case.

\item[{\code{set\_soft\_start}}] \leavevmode
Enable soft start for the regulator.

\item[{\code{get\_status}}] \leavevmode
Return actual (not as-configured) status of regulator, as a
REGULATOR\_STATUS value (or negative errno)

\item[{\code{get\_optimum\_mode}}] \leavevmode
Get the most efficient operating mode for the regulator
when running with the specified parameters.

\item[{\code{set\_load}}] \leavevmode
Set the load for the regulator.

\item[{\code{set\_bypass}}] \leavevmode
Set the regulator in bypass mode.

\item[{\code{get\_bypass}}] \leavevmode
Get the regulator bypass mode state.

\item[{\code{set\_suspend\_voltage}}] \leavevmode
Set the voltage for the regulator when the system
is suspended.

\item[{\code{set\_suspend\_enable}}] \leavevmode
Mark the regulator as enabled when the system is
suspended.

\item[{\code{set\_suspend\_disable}}] \leavevmode
Mark the regulator as disabled when the system is
suspended.

\item[{\code{set\_suspend\_mode}}] \leavevmode
Set the operating mode for the regulator when the
system is suspended.

\item[{\code{set\_pull\_down}}] \leavevmode
Configure the regulator to pull down when the regulator
is disabled.

\end{description}

\textbf{Description}

This struct describes regulator operations which can be implemented by
regulator chip drivers.
\index{regulator\_desc (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_desc}\pysigline{struct \bfcode{regulator\_desc}}
Static regulator descriptor

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct regulator\PYGZus{}desc \PYGZob{}
  const char *name;
  const char *supply\PYGZus{}name;
  const char *of\PYGZus{}match;
  const char *regulators\PYGZus{}node;
  int (*of\PYGZus{}parse\PYGZus{}cb)(struct device\PYGZus{}node *,const struct regulator\PYGZus{}desc *, struct regulator\PYGZus{}config *);
  int id;
  unsigned int continuous\PYGZus{}voltage\PYGZus{}range:1;
  unsigned n\PYGZus{}voltages;
  const struct regulator\PYGZus{}ops *ops;
  int irq;
  enum regulator\PYGZus{}type type;
  struct module *owner;
  unsigned int min\PYGZus{}uV;
  unsigned int uV\PYGZus{}step;
  unsigned int linear\PYGZus{}min\PYGZus{}sel;
  int fixed\PYGZus{}uV;
  unsigned int ramp\PYGZus{}delay;
  int min\PYGZus{}dropout\PYGZus{}uV;
  const struct regulator\PYGZus{}linear\PYGZus{}range *linear\PYGZus{}ranges;
  int n\PYGZus{}linear\PYGZus{}ranges;
  const unsigned int *volt\PYGZus{}table;
  unsigned int vsel\PYGZus{}reg;
  unsigned int vsel\PYGZus{}mask;
  unsigned int csel\PYGZus{}reg;
  unsigned int csel\PYGZus{}mask;
  unsigned int apply\PYGZus{}reg;
  unsigned int apply\PYGZus{}bit;
  unsigned int enable\PYGZus{}reg;
  unsigned int enable\PYGZus{}mask;
  unsigned int enable\PYGZus{}val;
  unsigned int disable\PYGZus{}val;
  bool enable\PYGZus{}is\PYGZus{}inverted;
  unsigned int bypass\PYGZus{}reg;
  unsigned int bypass\PYGZus{}mask;
  unsigned int bypass\PYGZus{}val\PYGZus{}on;
  unsigned int bypass\PYGZus{}val\PYGZus{}off;
  unsigned int active\PYGZus{}discharge\PYGZus{}on;
  unsigned int active\PYGZus{}discharge\PYGZus{}off;
  unsigned int active\PYGZus{}discharge\PYGZus{}mask;
  unsigned int active\PYGZus{}discharge\PYGZus{}reg;
  unsigned int soft\PYGZus{}start\PYGZus{}reg;
  unsigned int soft\PYGZus{}start\PYGZus{}mask;
  unsigned int soft\PYGZus{}start\PYGZus{}val\PYGZus{}on;
  unsigned int pull\PYGZus{}down\PYGZus{}reg;
  unsigned int pull\PYGZus{}down\PYGZus{}mask;
  unsigned int pull\PYGZus{}down\PYGZus{}val\PYGZus{}on;
  unsigned int enable\PYGZus{}time;
  unsigned int off\PYGZus{}on\PYGZus{}delay;
  unsigned int (*of\PYGZus{}map\PYGZus{}mode)(unsigned int mode);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
Identifying name for the regulator.

\item[{\code{supply\_name}}] \leavevmode
Identifying the regulator supply

\item[{\code{of\_match}}] \leavevmode
Name used to identify regulator in DT.

\item[{\code{regulators\_node}}] \leavevmode
Name of node containing regulator definitions in DT.

\item[{\code{of\_parse\_cb}}] \leavevmode
Optional callback called only if of\_match is present.
Will be called for each regulator parsed from DT, during
init\_data parsing.
The regulator\_config passed as argument to the callback will
be a copy of config passed to regulator\_register, valid only
for this particular call. Callback may freely change the
config but it cannot store it for later usage.
Callback should return 0 on success or negative ERRNO
indicating failure.

\item[{\code{id}}] \leavevmode
Numerical identifier for the regulator.

\item[{\code{continuous\_voltage\_range}}] \leavevmode
Indicates if the regulator can set any
voltage within constrains range.

\item[{\code{n\_voltages}}] \leavevmode
Number of selectors available for ops.:c:func:\emph{list\_voltage()}.

\item[{\code{ops}}] \leavevmode
Regulator operations table.

\item[{\code{irq}}] \leavevmode
Interrupt number for the regulator.

\item[{\code{type}}] \leavevmode
Indicates if the regulator is a voltage or current regulator.

\item[{\code{owner}}] \leavevmode
Module providing the regulator, used for refcounting.

\item[{\code{min\_uV}}] \leavevmode
Voltage given by the lowest selector (if linear mapping)

\item[{\code{uV\_step}}] \leavevmode
Voltage increase with each selector (if linear mapping)

\item[{\code{linear\_min\_sel}}] \leavevmode
Minimal selector for starting linear mapping

\item[{\code{fixed\_uV}}] \leavevmode
Fixed voltage of rails.

\item[{\code{ramp\_delay}}] \leavevmode
Time to settle down after voltage change (unit: uV/us)

\item[{\code{min\_dropout\_uV}}] \leavevmode
The minimum dropout voltage this regulator can handle

\item[{\code{linear\_ranges}}] \leavevmode
A constant table of possible voltage ranges.

\item[{\code{n\_linear\_ranges}}] \leavevmode
Number of entries in the \textbf{linear\_ranges} table.

\item[{\code{volt\_table}}] \leavevmode
Voltage mapping table (if table based mapping)

\item[{\code{vsel\_reg}}] \leavevmode
Register for selector when using {\color{red}\bfseries{}regulator\_regmap\_X\_voltage\_}

\item[{\code{vsel\_mask}}] \leavevmode
Mask for register bitfield used for selector

\item[{\code{csel\_reg}}] \leavevmode
Register for TPS65218 LS3 current regulator

\item[{\code{csel\_mask}}] \leavevmode
Mask for TPS65218 LS3 current regulator

\item[{\code{apply\_reg}}] \leavevmode
Register for initiate voltage change on the output when
using regulator\_set\_voltage\_sel\_regmap

\item[{\code{apply\_bit}}] \leavevmode
Register bitfield used for initiate voltage change on the
output when using regulator\_set\_voltage\_sel\_regmap

\item[{\code{enable\_reg}}] \leavevmode
Register for control when using regmap enable/disable ops

\item[{\code{enable\_mask}}] \leavevmode
Mask for control when using regmap enable/disable ops

\item[{\code{enable\_val}}] \leavevmode
Enabling value for control when using regmap enable/disable ops

\item[{\code{disable\_val}}] \leavevmode
Disabling value for control when using regmap enable/disable ops

\item[{\code{enable\_is\_inverted}}] \leavevmode
A flag to indicate set enable\_mask bits to disable
when using regulator\_enable\_regmap and friends APIs.

\item[{\code{bypass\_reg}}] \leavevmode
Register for control when using regmap set\_bypass

\item[{\code{bypass\_mask}}] \leavevmode
Mask for control when using regmap set\_bypass

\item[{\code{bypass\_val\_on}}] \leavevmode
Enabling value for control when using regmap set\_bypass

\item[{\code{bypass\_val\_off}}] \leavevmode
Disabling value for control when using regmap set\_bypass

\item[{\code{active\_discharge\_on}}] \leavevmode
Disabling value for control when using regmap
set\_active\_discharge

\item[{\code{active\_discharge\_off}}] \leavevmode
Enabling value for control when using regmap
set\_active\_discharge

\item[{\code{active\_discharge\_mask}}] \leavevmode
Mask for control when using regmap
set\_active\_discharge

\item[{\code{active\_discharge\_reg}}] \leavevmode
Register for control when using regmap
set\_active\_discharge

\item[{\code{soft\_start\_reg}}] \leavevmode
Register for control when using regmap set\_soft\_start

\item[{\code{soft\_start\_mask}}] \leavevmode
Mask for control when using regmap set\_soft\_start

\item[{\code{soft\_start\_val\_on}}] \leavevmode
Enabling value for control when using regmap
set\_soft\_start

\item[{\code{pull\_down\_reg}}] \leavevmode
Register for control when using regmap set\_pull\_down

\item[{\code{pull\_down\_mask}}] \leavevmode
Mask for control when using regmap set\_pull\_down

\item[{\code{pull\_down\_val\_on}}] \leavevmode
Enabling value for control when using regmap
set\_pull\_down

\item[{\code{enable\_time}}] \leavevmode
Time taken for initial enable of regulator (in uS).

\item[{\code{off\_on\_delay}}] \leavevmode
guard time (in uS), before re-enabling a regulator

\item[{\code{of\_map\_mode}}] \leavevmode
Maps a hardware mode defined in a DeviceTree to a standard mode

\end{description}

\textbf{Description}

Each regulator registered with the core is described with a
structure of this type and a struct regulator\_config.  This
structure contains the non-varying parts of the regulator
description.
\index{regulator\_config (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_config}\pysigline{struct \bfcode{regulator\_config}}
Dynamic regulator descriptor

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct regulator\PYGZus{}config \PYGZob{}
  struct device *dev;
  const struct regulator\PYGZus{}init\PYGZus{}data *init\PYGZus{}data;
  void *driver\PYGZus{}data;
  struct device\PYGZus{}node *of\PYGZus{}node;
  struct regmap *regmap;
  bool ena\PYGZus{}gpio\PYGZus{}initialized;
  int ena\PYGZus{}gpio;
  unsigned int ena\PYGZus{}gpio\PYGZus{}invert:1;
  unsigned int ena\PYGZus{}gpio\PYGZus{}flags;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev}}] \leavevmode
struct device for the regulator

\item[{\code{init\_data}}] \leavevmode
platform provided init data, passed through by driver

\item[{\code{driver\_data}}] \leavevmode
private regulator data

\item[{\code{of\_node}}] \leavevmode
OpenFirmware node to parse for device tree bindings (may be
NULL).

\item[{\code{regmap}}] \leavevmode
regmap to use for core regmap helpers if \code{dev\_get\_regmap()} is
insufficient.

\item[{\code{ena\_gpio\_initialized}}] \leavevmode
GPIO controlling regulator enable was properly
initialized, meaning that \textgreater{}= 0 is a valid gpio
identifier and \textless{} 0 is a non existent gpio.

\item[{\code{ena\_gpio}}] \leavevmode
GPIO controlling regulator enable.

\item[{\code{ena\_gpio\_invert}}] \leavevmode
Sense for GPIO enable control.

\item[{\code{ena\_gpio\_flags}}] \leavevmode
Flags to use when calling {\hyperref[driver\string-api/gpio:c.gpio_request_one]{\emph{\code{gpio\_request\_one()}}}}

\end{description}

\textbf{Description}

Each regulator registered with the core is described with a
structure of this type and a struct regulator\_desc.  This structure
contains the runtime variable parts of the regulator description.
\index{regulator\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_get}\pysiglinewithargsret{struct regulator * \bfcode{regulator\_get}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ id}}{}
lookup and obtain a reference to a regulator.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device for regulator ``consumer''

\item[{\code{const char * id}}] \leavevmode
Supply name or regulator ID.

\end{description}

\textbf{Description}

Returns a struct regulator corresponding to the regulator producer,
or \code{IS\_ERR()} condition containing errno.

Use of supply names configured via \code{regulator\_set\_device\_supply()} is
strongly encouraged.  It is recommended that the supply name used
should match the name used for the supply and/or the relevant
device pins in the datasheet.
\index{regulator\_get\_exclusive (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_get_exclusive}\pysiglinewithargsret{struct regulator * \bfcode{regulator\_get\_exclusive}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ id}}{}
obtain exclusive access to a regulator.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device for regulator ``consumer''

\item[{\code{const char * id}}] \leavevmode
Supply name or regulator ID.

\end{description}

\textbf{Description}

Returns a struct regulator corresponding to the regulator producer,
or \code{IS\_ERR()} condition containing errno.  Other consumers will be
unable to obtain this regulator while this reference is held and the
use count for the regulator will be initialised to reflect the current
state of the regulator.

This is intended for use by consumers which cannot tolerate shared
use of the regulator such as those which need to force the
regulator off for correct operation of the hardware they are
controlling.

Use of supply names configured via \code{regulator\_set\_device\_supply()} is
strongly encouraged.  It is recommended that the supply name used
should match the name used for the supply and/or the relevant
device pins in the datasheet.
\index{regulator\_get\_optional (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_get_optional}\pysiglinewithargsret{struct regulator * \bfcode{regulator\_get\_optional}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ id}}{}
obtain optional access to a regulator.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device for regulator ``consumer''

\item[{\code{const char * id}}] \leavevmode
Supply name or regulator ID.

\end{description}

\textbf{Description}

Returns a struct regulator corresponding to the regulator producer,
or \code{IS\_ERR()} condition containing errno.

This is intended for use by consumers for devices which can have
some supplies unconnected in normal use, such as some MMC devices.
It can allow the regulator core to provide stub supplies for other
supplies requested using normal {\hyperref[driver\string-api/regulator:c.regulator_get]{\emph{\code{regulator\_get()}}}} calls without
disrupting the operation of drivers that can handle absent
supplies.

Use of supply names configured via \code{regulator\_set\_device\_supply()} is
strongly encouraged.  It is recommended that the supply name used
should match the name used for the supply and/or the relevant
device pins in the datasheet.
\index{regulator\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_put}\pysiglinewithargsret{void \bfcode{regulator\_put}}{struct regulator *\emph{ regulator}}{}
``free'' the regulator source

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\end{description}

\textbf{Note}

drivers must ensure that all regulator\_enable calls made on this
regulator source are balanced by regulator\_disable calls prior to calling
this function.
\index{regulator\_register\_supply\_alias (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_register_supply_alias}\pysiglinewithargsret{int \bfcode{regulator\_register\_supply\_alias}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ id}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ alias\_dev}, const char *\emph{ alias\_id}}{}
Provide device alias for supply lookup

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device that will be given as the regulator ``consumer''

\item[{\code{const char * id}}] \leavevmode
Supply name or regulator ID

\item[{\code{struct device * alias\_dev}}] \leavevmode
device that should be used to lookup the supply

\item[{\code{const char * alias\_id}}] \leavevmode
Supply name or regulator ID that should be used to lookup the
supply

\end{description}

\textbf{Description}

All lookups for id on dev will instead be conducted for alias\_id on
alias\_dev.
\index{regulator\_unregister\_supply\_alias (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_unregister_supply_alias}\pysiglinewithargsret{void \bfcode{regulator\_unregister\_supply\_alias}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ id}}{}
Remove device alias

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device that will be given as the regulator ``consumer''

\item[{\code{const char * id}}] \leavevmode
Supply name or regulator ID

\end{description}

\textbf{Description}

Remove a lookup alias if one exists for id on dev.
\index{regulator\_bulk\_register\_supply\_alias (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_bulk_register_supply_alias}\pysiglinewithargsret{int \bfcode{regulator\_bulk\_register\_supply\_alias}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *const *\emph{ id}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ alias\_dev}, const char *const *\emph{ alias\_id}, int\emph{ num\_id}}{}
register multiple aliases

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device that will be given as the regulator ``consumer''

\item[{\code{const char *const * id}}] \leavevmode
List of supply names or regulator IDs

\item[{\code{struct device * alias\_dev}}] \leavevmode
device that should be used to lookup the supply

\item[{\code{const char *const * alias\_id}}] \leavevmode
List of supply names or regulator IDs that should be used to
lookup the supply

\item[{\code{int num\_id}}] \leavevmode
Number of aliases to register

\end{description}

\textbf{Description}

\textbf{return} 0 on success, an errno on failure.

This helper function allows drivers to register several supply
aliases in one operation.  If any of the aliases cannot be
registered any aliases that were registered will be removed
before returning to the caller.
\index{regulator\_bulk\_unregister\_supply\_alias (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_bulk_unregister_supply_alias}\pysiglinewithargsret{void \bfcode{regulator\_bulk\_unregister\_supply\_alias}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *const *\emph{ id}, int\emph{ num\_id}}{}
unregister multiple aliases

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device that will be given as the regulator ``consumer''

\item[{\code{const char *const * id}}] \leavevmode
List of supply names or regulator IDs

\item[{\code{int num\_id}}] \leavevmode
Number of aliases to unregister

\end{description}

\textbf{Description}

This helper function allows drivers to unregister several supply
aliases in one operation.
\index{regulator\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_enable}\pysiglinewithargsret{int \bfcode{regulator\_enable}}{struct regulator *\emph{ regulator}}{}
enable regulator output

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\end{description}

\textbf{Description}

Request that the regulator be enabled with the regulator output at
the predefined voltage or current value.  Calls to {\hyperref[driver\string-api/regulator:c.regulator_enable]{\emph{\code{regulator\_enable()}}}}
must be balanced with calls to {\hyperref[driver\string-api/regulator:c.regulator_disable]{\emph{\code{regulator\_disable()}}}}.

\textbf{NOTE}

the output value can be set by other drivers, boot loader or may be
hardwired in the regulator.
\index{regulator\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_disable}\pysiglinewithargsret{int \bfcode{regulator\_disable}}{struct regulator *\emph{ regulator}}{}
disable regulator output

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\end{description}

\textbf{Description}

Disable the regulator output voltage or current.  Calls to
{\hyperref[driver\string-api/regulator:c.regulator_enable]{\emph{\code{regulator\_enable()}}}} must be balanced with calls to
{\hyperref[driver\string-api/regulator:c.regulator_disable]{\emph{\code{regulator\_disable()}}}}.

\textbf{NOTE}

this will only disable the regulator output if no other consumer
devices have it enabled, the regulator device supports disabling and
machine constraints permit this operation.
\index{regulator\_force\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_force_disable}\pysiglinewithargsret{int \bfcode{regulator\_force\_disable}}{struct regulator *\emph{ regulator}}{}
force disable regulator output

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\end{description}

\textbf{Description}

Forcibly disable the regulator output voltage or current.

\textbf{NOTE}

this \emph{will} disable the regulator output even if other consumer
devices have it enabled. This should be used for situations when device
damage will likely occur if the regulator is not disabled (e.g. over temp).
\index{regulator\_disable\_deferred (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_disable_deferred}\pysiglinewithargsret{int \bfcode{regulator\_disable\_deferred}}{struct regulator *\emph{ regulator}, int\emph{ ms}}{}
disable regulator output with delay

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\item[{\code{int ms}}] \leavevmode
miliseconds until the regulator is disabled

\end{description}

\textbf{Description}

Execute {\hyperref[driver\string-api/regulator:c.regulator_disable]{\emph{\code{regulator\_disable()}}}} on the regulator after a delay.  This
is intended for use with devices that require some time to quiesce.

\textbf{NOTE}

this will only disable the regulator output if no other consumer
devices have it enabled, the regulator device supports disabling and
machine constraints permit this operation.
\index{regulator\_is\_enabled (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_is_enabled}\pysiglinewithargsret{int \bfcode{regulator\_is\_enabled}}{struct regulator *\emph{ regulator}}{}
is the regulator output enabled

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\end{description}

\textbf{Description}

Returns positive if the regulator driver backing the source/client
has requested that the device be enabled, zero if it hasn't, else a
negative errno code.

Note that the device backing this regulator handle can have multiple
users, so it might be enabled even if {\hyperref[driver\string-api/regulator:c.regulator_enable]{\emph{\code{regulator\_enable()}}}} was never
called for this particular source.
\index{regulator\_count\_voltages (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_count_voltages}\pysiglinewithargsret{int \bfcode{regulator\_count\_voltages}}{struct regulator *\emph{ regulator}}{}
count {\hyperref[driver\string-api/regulator:c.regulator_list_voltage]{\emph{\code{regulator\_list\_voltage()}}}} selectors

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\end{description}

\textbf{Description}

Returns number of selectors, or negative errno.  Selectors are
numbered starting at zero, and typically correspond to bitfields
in hardware registers.
\index{regulator\_list\_voltage (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_list_voltage}\pysiglinewithargsret{int \bfcode{regulator\_list\_voltage}}{struct regulator *\emph{ regulator}, unsigned\emph{ selector}}{}
enumerate supported voltages

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\item[{\code{unsigned selector}}] \leavevmode
identify voltage to list

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

Returns a voltage that can be passed to \textbf{regulator\_set\_voltage()},
zero if this selector code can't be used on this system, or a
negative errno.
\index{regulator\_get\_hardware\_vsel\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_get_hardware_vsel_register}\pysiglinewithargsret{int \bfcode{regulator\_get\_hardware\_vsel\_register}}{struct regulator *\emph{ regulator}, unsigned *\emph{ vsel\_reg}, unsigned *\emph{ vsel\_mask}}{}
get the HW voltage selector register

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\item[{\code{unsigned * vsel\_reg}}] \leavevmode
voltage selector register, output parameter

\item[{\code{unsigned * vsel\_mask}}] \leavevmode
mask for voltage selector bitfield, output parameter

\end{description}

\textbf{Description}

Returns the hardware register offset and bitmask used for setting the
regulator voltage. This might be useful when configuring voltage-scaling
hardware or firmware that can make I2C requests behind the kernel's back,
for example.

On success, the output parameters \textbf{vsel\_reg} and \textbf{vsel\_mask} are filled in
and 0 is returned, otherwise a negative errno is returned.
\index{regulator\_list\_hardware\_vsel (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_list_hardware_vsel}\pysiglinewithargsret{int \bfcode{regulator\_list\_hardware\_vsel}}{struct regulator *\emph{ regulator}, unsigned\emph{ selector}}{}
get the HW-specific register value for a selector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\item[{\code{unsigned selector}}] \leavevmode
identify voltage to list

\end{description}

\textbf{Description}

Converts the selector to a hardware-specific voltage selector that can be
directly written to the regulator registers. The address of the voltage
register can be determined by calling \textbf{regulator\_get\_hardware\_vsel\_register}.

On error a negative errno is returned.
\index{regulator\_get\_linear\_step (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_get_linear_step}\pysiglinewithargsret{unsigned int \bfcode{regulator\_get\_linear\_step}}{struct regulator *\emph{ regulator}}{}
return the voltage step size between VSEL values

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\end{description}

\textbf{Description}

Returns the voltage step size between VSEL values for linear
regulators, or return 0 if the regulator isn't a linear regulator.
\index{regulator\_is\_supported\_voltage (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_is_supported_voltage}\pysiglinewithargsret{int \bfcode{regulator\_is\_supported\_voltage}}{struct regulator *\emph{ regulator}, int\emph{ min\_uV}, int\emph{ max\_uV}}{}
check if a voltage range can be supported

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
Regulator to check.

\item[{\code{int min\_uV}}] \leavevmode
Minimum required voltage in uV.

\item[{\code{int max\_uV}}] \leavevmode
Maximum required voltage in uV.

\end{description}

\textbf{Description}

Returns a boolean or a negative error code.
\index{regulator\_set\_voltage (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_set_voltage}\pysiglinewithargsret{int \bfcode{regulator\_set\_voltage}}{struct regulator *\emph{ regulator}, int\emph{ min\_uV}, int\emph{ max\_uV}}{}
set regulator output voltage

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\item[{\code{int min\_uV}}] \leavevmode
Minimum required voltage in uV

\item[{\code{int max\_uV}}] \leavevmode
Maximum acceptable voltage in uV

\end{description}

\textbf{Description}

Sets a voltage regulator to the desired output voltage. This can be set
during any regulator state. IOW, regulator can be disabled or enabled.

If the regulator is enabled then the voltage will change to the new value
immediately otherwise if the regulator is disabled the regulator will
output at the new voltage when enabled.

\textbf{NOTE}

If the regulator is shared between several devices then the lowest
request voltage that meets the system constraints will be used.
Regulator system constraints must be set for this regulator before
calling this function otherwise this call will fail.
\index{regulator\_set\_voltage\_time (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_set_voltage_time}\pysiglinewithargsret{int \bfcode{regulator\_set\_voltage\_time}}{struct regulator *\emph{ regulator}, int\emph{ old\_uV}, int\emph{ new\_uV}}{}
get raise/fall time

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\item[{\code{int old\_uV}}] \leavevmode
starting voltage in microvolts

\item[{\code{int new\_uV}}] \leavevmode
target voltage in microvolts

\end{description}

\textbf{Description}

Provided with the starting and ending voltage, this function attempts to
calculate the time in microseconds required to rise or fall to this new
voltage.
\index{regulator\_set\_voltage\_time\_sel (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_set_voltage_time_sel}\pysiglinewithargsret{int \bfcode{regulator\_set\_voltage\_time\_sel}}{struct regulator\_dev *\emph{ rdev}, unsigned int\emph{ old\_selector}, unsigned int\emph{ new\_selector}}{}
get raise/fall time

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator\_dev * rdev}}] \leavevmode
regulator source device

\item[{\code{unsigned int old\_selector}}] \leavevmode
selector for starting voltage

\item[{\code{unsigned int new\_selector}}] \leavevmode
selector for target voltage

\end{description}

\textbf{Description}

Provided with the starting and target voltage selectors, this function
returns time in microseconds required to rise or fall to this new voltage

Drivers providing ramp\_delay in regulation\_constraints can use this as their
\code{set\_voltage\_time\_sel()} operation.
\index{regulator\_sync\_voltage (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_sync_voltage}\pysiglinewithargsret{int \bfcode{regulator\_sync\_voltage}}{struct regulator *\emph{ regulator}}{}
re-apply last regulator output voltage

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\end{description}

\textbf{Description}

Re-apply the last configured voltage.  This is intended to be used
where some external control source the consumer is cooperating with
has caused the configured voltage to change.
\index{regulator\_get\_voltage (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_get_voltage}\pysiglinewithargsret{int \bfcode{regulator\_get\_voltage}}{struct regulator *\emph{ regulator}}{}
get regulator output voltage

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\end{description}

\textbf{Description}

This returns the current regulator voltage in uV.

\textbf{NOTE}

If the regulator is disabled it will return the voltage value. This
function should not be used to determine regulator state.
\index{regulator\_set\_current\_limit (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_set_current_limit}\pysiglinewithargsret{int \bfcode{regulator\_set\_current\_limit}}{struct regulator *\emph{ regulator}, int\emph{ min\_uA}, int\emph{ max\_uA}}{}
set regulator output current limit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\item[{\code{int min\_uA}}] \leavevmode
Minimum supported current in uA

\item[{\code{int max\_uA}}] \leavevmode
Maximum supported current in uA

\end{description}

\textbf{Description}

Sets current sink to the desired output current. This can be set during
any regulator state. IOW, regulator can be disabled or enabled.

If the regulator is enabled then the current will change to the new value
immediately otherwise if the regulator is disabled the regulator will
output at the new current when enabled.

\textbf{NOTE}

Regulator system constraints must be set for this regulator before
calling this function otherwise this call will fail.
\index{regulator\_get\_current\_limit (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_get_current_limit}\pysiglinewithargsret{int \bfcode{regulator\_get\_current\_limit}}{struct regulator *\emph{ regulator}}{}
get regulator output current

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\end{description}

\textbf{Description}

This returns the current supplied by the specified current sink in uA.

\textbf{NOTE}

If the regulator is disabled it will return the current value. This
function should not be used to determine regulator state.
\index{regulator\_set\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_set_mode}\pysiglinewithargsret{int \bfcode{regulator\_set\_mode}}{struct regulator *\emph{ regulator}, unsigned int\emph{ mode}}{}
set regulator operating mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\item[{\code{unsigned int mode}}] \leavevmode
operating mode - one of the REGULATOR\_MODE constants

\end{description}

\textbf{Description}

Set regulator operating mode to increase regulator efficiency or improve
regulation performance.

\textbf{NOTE}

Regulator system constraints must be set for this regulator before
calling this function otherwise this call will fail.
\index{regulator\_get\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_get_mode}\pysiglinewithargsret{unsigned int \bfcode{regulator\_get\_mode}}{struct regulator *\emph{ regulator}}{}
get regulator operating mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\end{description}

\textbf{Description}

Get the current regulator operating mode.
\index{regulator\_get\_error\_flags (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_get_error_flags}\pysiglinewithargsret{int \bfcode{regulator\_get\_error\_flags}}{struct regulator *\emph{ regulator}, unsigned int *\emph{ flags}}{}
get regulator error information

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\item[{\code{unsigned int * flags}}] \leavevmode
pointer to store error flags

\end{description}

\textbf{Description}

Get the current regulator error information.
\index{regulator\_set\_load (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_set_load}\pysiglinewithargsret{int \bfcode{regulator\_set\_load}}{struct regulator *\emph{ regulator}, int\emph{ uA\_load}}{}
set regulator load

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\item[{\code{int uA\_load}}] \leavevmode
load current

\end{description}

\textbf{Description}

Notifies the regulator core of a new device load. This is then used by
DRMS (if enabled by constraints) to set the most efficient regulator
operating mode for the new regulator loading.

Consumer devices notify their supply regulator of the maximum power
they will require (can be taken from device datasheet in the power
consumption tables) when they change operational status and hence power
state. Examples of operational state changes that can affect power
consumption are :-
\begin{quote}

o Device is opened / closed.
o Device I/O is about to begin or has just finished.
o Device is idling in between work.
\end{quote}

This information is also exported via sysfs to userspace.

DRMS will sum the total requested load on the regulator and change
to the most efficient operating mode if platform constraints allow.

On error a negative errno is returned.
\index{regulator\_allow\_bypass (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_allow_bypass}\pysiglinewithargsret{int \bfcode{regulator\_allow\_bypass}}{struct regulator *\emph{ regulator}, bool\emph{ enable}}{}
allow the regulator to go into bypass mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
Regulator to configure

\item[{\code{bool enable}}] \leavevmode
enable or disable bypass mode

\end{description}

\textbf{Description}

Allow the regulator to go into bypass mode if all other consumers
for the regulator also enable bypass mode and the machine
constraints allow this.  Bypass mode means that the regulator is
simply passing the input directly to the output with no regulation.
\index{regulator\_register\_notifier (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_register_notifier}\pysiglinewithargsret{int \bfcode{regulator\_register\_notifier}}{struct regulator *\emph{ regulator}, struct notifier\_block *\emph{ nb}}{}
register regulator event notifier

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\item[{\code{struct notifier\_block * nb}}] \leavevmode
notifier block

\end{description}

\textbf{Description}

Register notifier block to receive regulator events.
\index{regulator\_unregister\_notifier (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_unregister_notifier}\pysiglinewithargsret{int \bfcode{regulator\_unregister\_notifier}}{struct regulator *\emph{ regulator}, struct notifier\_block *\emph{ nb}}{}
unregister regulator event notifier

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator source

\item[{\code{struct notifier\_block * nb}}] \leavevmode
notifier block

\end{description}

\textbf{Description}

Unregister regulator event notifier block.
\index{regulator\_bulk\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_bulk_get}\pysiglinewithargsret{int \bfcode{regulator\_bulk\_get}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, int\emph{ num\_consumers}, struct {\hyperref[driver\string-api/regulator:c.regulator_bulk_data]{\emph{regulator\_bulk\_data}}} *\emph{ consumers}}{}
get multiple regulator consumers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to supply

\item[{\code{int num\_consumers}}] \leavevmode
Number of consumers to register

\item[{\code{struct regulator\_bulk\_data * consumers}}] \leavevmode
Configuration of consumers; clients are stored here.

\end{description}

\textbf{Description}

\textbf{return} 0 on success, an errno on failure.

This helper function allows drivers to get several regulator
consumers in one operation.  If any of the regulators cannot be
acquired then any regulators that were allocated will be freed
before returning to the caller.
\index{regulator\_bulk\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_bulk_enable}\pysiglinewithargsret{int \bfcode{regulator\_bulk\_enable}}{int\emph{ num\_consumers}, struct {\hyperref[driver\string-api/regulator:c.regulator_bulk_data]{\emph{regulator\_bulk\_data}}} *\emph{ consumers}}{}
enable multiple regulator consumers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int num\_consumers}}] \leavevmode
Number of consumers

\item[{\code{struct regulator\_bulk\_data * consumers}}] \leavevmode
Consumer data; clients are stored here.
\textbf{return}         0 on success, an errno on failure

\end{description}

\textbf{Description}

This convenience API allows consumers to enable multiple regulator
clients in a single API call.  If any consumers cannot be enabled
then any others that were enabled will be disabled again prior to
return.
\index{regulator\_bulk\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_bulk_disable}\pysiglinewithargsret{int \bfcode{regulator\_bulk\_disable}}{int\emph{ num\_consumers}, struct {\hyperref[driver\string-api/regulator:c.regulator_bulk_data]{\emph{regulator\_bulk\_data}}} *\emph{ consumers}}{}
disable multiple regulator consumers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int num\_consumers}}] \leavevmode
Number of consumers

\item[{\code{struct regulator\_bulk\_data * consumers}}] \leavevmode
Consumer data; clients are stored here.
\textbf{return}         0 on success, an errno on failure

\end{description}

\textbf{Description}

This convenience API allows consumers to disable multiple regulator
clients in a single API call.  If any consumers cannot be disabled
then any others that were disabled will be enabled again prior to
return.
\index{regulator\_bulk\_force\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_bulk_force_disable}\pysiglinewithargsret{int \bfcode{regulator\_bulk\_force\_disable}}{int\emph{ num\_consumers}, struct {\hyperref[driver\string-api/regulator:c.regulator_bulk_data]{\emph{regulator\_bulk\_data}}} *\emph{ consumers}}{}
force disable multiple regulator consumers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int num\_consumers}}] \leavevmode
Number of consumers

\item[{\code{struct regulator\_bulk\_data * consumers}}] \leavevmode
Consumer data; clients are stored here.
\textbf{return}         0 on success, an errno on failure

\end{description}

\textbf{Description}

This convenience API allows consumers to forcibly disable multiple regulator
clients in a single API call.

\textbf{NOTE}

This should be used for situations when device damage will
likely occur if the regulators are not disabled (e.g. over temp).
Although regulator\_force\_disable function call for some consumers can
return error numbers, the function is called for all consumers.
\index{regulator\_bulk\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_bulk_free}\pysiglinewithargsret{void \bfcode{regulator\_bulk\_free}}{int\emph{ num\_consumers}, struct {\hyperref[driver\string-api/regulator:c.regulator_bulk_data]{\emph{regulator\_bulk\_data}}} *\emph{ consumers}}{}
free multiple regulator consumers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int num\_consumers}}] \leavevmode
Number of consumers

\item[{\code{struct regulator\_bulk\_data * consumers}}] \leavevmode
Consumer data; clients are stored here.

\end{description}

\textbf{Description}

This convenience API allows consumers to free multiple regulator
clients in a single API call.
\index{regulator\_notifier\_call\_chain (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_notifier_call_chain}\pysiglinewithargsret{int \bfcode{regulator\_notifier\_call\_chain}}{struct regulator\_dev *\emph{ rdev}, unsigned long\emph{ event}, void *\emph{ data}}{}
call regulator event notifier

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator\_dev * rdev}}] \leavevmode
regulator source

\item[{\code{unsigned long event}}] \leavevmode
notifier block

\item[{\code{void * data}}] \leavevmode
callback-specific data.

\end{description}

\textbf{Description}

Called by regulator drivers to notify clients a regulator event has
occurred. We also notify regulator clients downstream.
Note lock must be held by caller.
\index{regulator\_mode\_to\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_mode_to_status}\pysiglinewithargsret{int \bfcode{regulator\_mode\_to\_status}}{unsigned int\emph{ mode}}{}
convert a regulator mode into a status

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int mode}}] \leavevmode
Mode to convert

\end{description}

\textbf{Description}

Convert a regulator mode into a status.
\index{regulator\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_register}\pysiglinewithargsret{struct regulator\_dev * \bfcode{regulator\_register}}{const struct {\hyperref[driver\string-api/regulator:c.regulator_desc]{\emph{regulator\_desc}}} *\emph{ regulator\_desc}, const struct {\hyperref[driver\string-api/regulator:c.regulator_config]{\emph{regulator\_config}}} *\emph{ cfg}}{}
register regulator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct regulator\_desc * regulator\_desc}}] \leavevmode
regulator to register

\item[{\code{const struct regulator\_config * cfg}}] \leavevmode
runtime configuration for regulator

\end{description}

\textbf{Description}

Called by regulator drivers to register a regulator.
Returns a valid pointer to struct regulator\_dev on success
or an \code{ERR\_PTR()} on error.
\index{regulator\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_unregister}\pysiglinewithargsret{void \bfcode{regulator\_unregister}}{struct regulator\_dev *\emph{ rdev}}{}
unregister regulator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator\_dev * rdev}}] \leavevmode
regulator to unregister

\end{description}

\textbf{Description}

Called by regulator drivers to unregister a regulator.
\index{regulator\_has\_full\_constraints (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_has_full_constraints}\pysiglinewithargsret{void \bfcode{regulator\_has\_full\_constraints}}{void}{}
the system has fully specified constraints

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Calling this function will cause the regulator API to disable all
regulators which have a zero use count and don't have an always\_on
constraint in a late\_initcall.

The intention is that this will become the default behaviour in a
future kernel release so users are encouraged to use this facility
now.
\index{rdev\_get\_drvdata (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.rdev_get_drvdata}\pysiglinewithargsret{void * \bfcode{rdev\_get\_drvdata}}{struct regulator\_dev *\emph{ rdev}}{}
get rdev regulator driver data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator\_dev * rdev}}] \leavevmode
regulator

\end{description}

\textbf{Description}

Get rdev regulator driver private data. This call can be used in the
regulator driver context.
\index{regulator\_get\_drvdata (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_get_drvdata}\pysiglinewithargsret{void * \bfcode{regulator\_get\_drvdata}}{struct regulator *\emph{ regulator}}{}
get regulator driver data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator

\end{description}

\textbf{Description}

Get regulator driver private data. This call can be used in the consumer
driver context when non API regulator specific functions need to be called.
\index{regulator\_set\_drvdata (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.regulator_set_drvdata}\pysiglinewithargsret{void \bfcode{regulator\_set\_drvdata}}{struct regulator *\emph{ regulator}, void *\emph{ data}}{}
set regulator driver data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator * regulator}}] \leavevmode
regulator

\item[{\code{void * data}}] \leavevmode
data

\end{description}
\index{rdev\_get\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/regulator:c.rdev_get_id}\pysiglinewithargsret{int \bfcode{rdev\_get\_id}}{struct regulator\_dev *\emph{ rdev}}{}
get regulator ID

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct regulator\_dev * rdev}}] \leavevmode
regulator

\end{description}


\chapter{Industrial I/O}
\label{driver-api/iio/index::doc}\label{driver-api/iio/index:industrial-i-o}
\textbf{Copyright} © 2015 Intel Corporation

Contents:


\section{Introduction}
\label{driver-api/iio/intro:introduction}\label{driver-api/iio/intro::doc}
The main purpose of the Industrial I/O subsystem (IIO) is to provide support
for devices that in some sense perform either
analog-to-digital conversion (ADC) or digital-to-analog conversion (DAC)
or both. The aim is to fill the gap between the somewhat similar hwmon and
{\hyperref[driver\string-api/input::doc]{\emph{\emph{input}}}} subsystems. Hwmon is directed at low sample rate
sensors used to monitor and control the system itself, like fan speed control
or temperature measurement. {\hyperref[driver\string-api/input::doc]{\emph{\emph{Input}}}} is, as its name suggests,
focused on human interaction input devices (keyboard, mouse, touchscreen).
In some cases there is considerable overlap between these and IIO.

Devices that fall into this category include:
\begin{itemize}
\item {} 
analog to digital converters (ADCs)

\item {} 
accelerometers

\item {} 
capacitance to digital converters (CDCs)

\item {} 
digital to analog converters (DACs)

\item {} 
gyroscopes

\item {} 
inertial measurement units (IMUs)

\item {} 
color and light sensors

\item {} 
magnetometers

\item {} 
pressure sensors

\item {} 
proximity sensors

\item {} 
temperature sensors

\end{itemize}

Usually these sensors are connected via {\hyperref[driver\string-api/spi::doc]{\emph{\emph{SPI}}}} or
{\hyperref[driver\string-api/i2c::doc]{\emph{\emph{I2C}}}}. A common use case of the sensors devices is to have
combined functionality (e.g. light plus proximity sensor).


\section{Core elements}
\label{driver-api/iio/core:core-elements}\label{driver-api/iio/core::doc}
The Industrial I/O core offers a unified framework for writing drivers for
many different types of embedded sensors. a standard interface to user space
applications manipulating sensors. The implementation can be found under
\code{drivers/iio/industrialio-*}


\subsection{Industrial I/O Devices}
\label{driver-api/iio/core:industrial-i-o-devices}\begin{itemize}
\item {} 
struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{\code{iio\_dev}}}} - industrial I/O device

\item {} 
{\hyperref[driver\string-api/iio/core:c.iio_device_alloc]{\emph{\code{iio\_device\_alloc()}}}} - alocate an {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{\code{iio\_dev}}}} from a driver

\item {} 
{\hyperref[driver\string-api/iio/core:c.iio_device_free]{\emph{\code{iio\_device\_free()}}}} - free an {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{\code{iio\_dev}}}} from a driver

\item {} 
{\hyperref[driver\string-api/iio/core:c.iio_device_register]{\emph{\code{iio\_device\_register()}}}} - register a device with the IIO subsystem

\item {} 
{\hyperref[driver\string-api/iio/core:c.iio_device_unregister]{\emph{\code{iio\_device\_unregister()}}}} - unregister a device from the IIO
subsystem

\end{itemize}

An IIO device usually corresponds to a single hardware sensor and it
provides all the information needed by a driver handling a device.
Let's first have a look at the functionality embedded in an IIO device
then we will show how a device driver makes use of an IIO device.

There are two ways for a user space application to interact with an IIO driver.
\begin{enumerate}
\item {} 
\code{/sys/bus/iio/iio:device\emph{X}/}, this represents a hardware sensor
and groups together the data channels of the same chip.

\item {} 
\code{/dev/iio:device\emph{X}}, character device node interface used for
buffered data transfer and for events information retrieval.

\end{enumerate}

A typical IIO driver will register itself as an {\hyperref[driver\string-api/i2c::doc]{\emph{\emph{I2C}}}} or
{\hyperref[driver\string-api/spi::doc]{\emph{\emph{SPI}}}} driver and will create two routines, probe and remove.

At probe:
\begin{enumerate}
\item {} 
Call {\hyperref[driver\string-api/iio/core:c.iio_device_alloc]{\emph{\code{iio\_device\_alloc()}}}}, which allocates memory for an IIO device.

\item {} 
Initialize IIO device fields with driver specific information (e.g.
device name, device channels).

\item {} 
Call {\hyperref[driver\string-api/iio/core:c.iio_device_register]{\emph{\code{iio\_device\_register()}}}}, this registers the device with the
IIO core. After this call the device is ready to accept requests from user
space applications.

\end{enumerate}

At remove, we free the resources allocated in probe in reverse order:
\begin{enumerate}
\item {} 
{\hyperref[driver\string-api/iio/core:c.iio_device_unregister]{\emph{\code{iio\_device\_unregister()}}}}, unregister the device from the IIO core.

\item {} 
{\hyperref[driver\string-api/iio/core:c.iio_device_free]{\emph{\code{iio\_device\_free()}}}}, free the memory allocated for the IIO device.

\end{enumerate}


\subsubsection{IIO device sysfs interface}
\label{driver-api/iio/core:iio-device-sysfs-interface}
Attributes are sysfs files used to expose chip info and also allowing
applications to set various configuration parameters. For device with
index X, attributes can be found under /sys/bus/iio/iio:deviceX/ directory.
Common attributes are:
\begin{itemize}
\item {} 
\code{name}, description of the physical chip.

\item {} 
\code{dev}, shows the major:minor pair associated with
\code{/dev/iio:deviceX} node.

\item {} 
\code{sampling\_frequency\_available}, available discrete set of sampling
frequency values for device.

\item {} 
Available standard attributes for IIO devices are described in the
\code{Documentation/ABI/testing/sysfs-bus-iio} file in the Linux kernel
sources.

\end{itemize}


\subsubsection{IIO device channels}
\label{driver-api/iio/core:iio-device-channels}
struct {\hyperref[driver\string-api/iio/core:c.iio_chan_spec]{\emph{\code{iio\_chan\_spec}}}} - specification of a single channel

An IIO device channel is a representation of a data channel. An IIO device can
have one or multiple channels. For example:
\begin{itemize}
\item {} 
a thermometer sensor has one channel representing the temperature measurement.

\item {} 
a light sensor with two channels indicating the measurements in the visible
and infrared spectrum.

\item {} 
an accelerometer can have up to 3 channels representing acceleration on X, Y
and Z axes.

\end{itemize}

An IIO channel is described by the struct {\hyperref[driver\string-api/iio/core:c.iio_chan_spec]{\emph{\code{iio\_chan\_spec}}}}.
A thermometer driver for the temperature sensor in the example above would
have to describe its channel as follows:

\begin{Verbatim}[commandchars=\\\{\}]
static const struct iio\PYGZus{}chan\PYGZus{}spec temp\PYGZus{}channel[] = \PYGZob{}
     \PYGZob{}
         .type = IIO\PYGZus{}TEMP,
         .info\PYGZus{}mask\PYGZus{}separate = BIT(IIO\PYGZus{}CHAN\PYGZus{}INFO\PYGZus{}PROCESSED),
     \PYGZcb{},
\PYGZcb{};
\end{Verbatim}

Channel sysfs attributes exposed to userspace are specified in the form of
bitmasks. Depending on their shared info, attributes can be set in one of the
following masks:
\begin{itemize}
\item {} 
\textbf{info\_mask\_separate}, attributes will be specific to
this channel

\item {} 
\textbf{info\_mask\_shared\_by\_type}, attributes are shared by all channels of the
same type

\item {} 
\textbf{info\_mask\_shared\_by\_dir}, attributes are shared by all channels of the same
direction

\item {} 
\textbf{info\_mask\_shared\_by\_all}, attributes are shared by all channels

\end{itemize}

When there are multiple data channels per channel type we have two ways to
distinguish between them:
\begin{itemize}
\item {} 
set \textbf{.modified} field of {\hyperref[driver\string-api/iio/core:c.iio_chan_spec]{\emph{\code{iio\_chan\_spec}}}} to 1. Modifiers are
specified using \textbf{.channel2} field of the same {\hyperref[driver\string-api/iio/core:c.iio_chan_spec]{\emph{\code{iio\_chan\_spec}}}}
structure and are used to indicate a physically unique characteristic of the
channel such as its direction or spectral response. For example, a light
sensor can have two channels, one for infrared light and one for both
infrared and visible light.

\item {} 
set \textbf{.indexed} field of {\hyperref[driver\string-api/iio/core:c.iio_chan_spec]{\emph{\code{iio\_chan\_spec}}}} to 1. In this case the
channel is simply another instance with an index specified by the \textbf{.channel}
field.

\end{itemize}

Here is how we can make use of the channel's modifiers:

\begin{Verbatim}[commandchars=\\\{\}]
static const struct iio\PYGZus{}chan\PYGZus{}spec light\PYGZus{}channels[] = \PYGZob{}
        \PYGZob{}
                .type = IIO\PYGZus{}INTENSITY,
                .modified = 1,
                .channel2 = IIO\PYGZus{}MOD\PYGZus{}LIGHT\PYGZus{}IR,
                .info\PYGZus{}mask\PYGZus{}separate = BIT(IIO\PYGZus{}CHAN\PYGZus{}INFO\PYGZus{}RAW),
                .info\PYGZus{}mask\PYGZus{}shared = BIT(IIO\PYGZus{}CHAN\PYGZus{}INFO\PYGZus{}SAMP\PYGZus{}FREQ),
        \PYGZcb{},
        \PYGZob{}
                .type = IIO\PYGZus{}INTENSITY,
                .modified = 1,
                .channel2 = IIO\PYGZus{}MOD\PYGZus{}LIGHT\PYGZus{}BOTH,
                .info\PYGZus{}mask\PYGZus{}separate = BIT(IIO\PYGZus{}CHAN\PYGZus{}INFO\PYGZus{}RAW),
                .info\PYGZus{}mask\PYGZus{}shared = BIT(IIO\PYGZus{}CHAN\PYGZus{}INFO\PYGZus{}SAMP\PYGZus{}FREQ),
        \PYGZcb{},
        \PYGZob{}
                .type = IIO\PYGZus{}LIGHT,
                .info\PYGZus{}mask\PYGZus{}separate = BIT(IIO\PYGZus{}CHAN\PYGZus{}INFO\PYGZus{}PROCESSED),
                .info\PYGZus{}mask\PYGZus{}shared = BIT(IIO\PYGZus{}CHAN\PYGZus{}INFO\PYGZus{}SAMP\PYGZus{}FREQ),
        \PYGZcb{},
   \PYGZcb{}
\end{Verbatim}

This channel's definition will generate two separate sysfs files for raw data
retrieval:
\begin{itemize}
\item {} 
\code{/sys/bus/iio/iio:device\emph{X}/in\_intensity\_ir\_raw}

\item {} 
\code{/sys/bus/iio/iio:device\emph{X}/in\_intensity\_both\_raw}

\end{itemize}

one file for processed data:
\begin{itemize}
\item {} 
\code{/sys/bus/iio/iio:device\emph{X}/in\_illuminance\_input}

\end{itemize}

and one shared sysfs file for sampling frequency:
\begin{itemize}
\item {} 
\code{/sys/bus/iio/iio:device\emph{X}/sampling\_frequency}.

\end{itemize}

Here is how we can make use of the channel's indexing:

\begin{Verbatim}[commandchars=\\\{\}]
static const struct iio\PYGZus{}chan\PYGZus{}spec light\PYGZus{}channels[] = \PYGZob{}
        \PYGZob{}
                .type = IIO\PYGZus{}VOLTAGE,
                .indexed = 1,
                .channel = 0,
                .info\PYGZus{}mask\PYGZus{}separate = BIT(IIO\PYGZus{}CHAN\PYGZus{}INFO\PYGZus{}RAW),
        \PYGZcb{},
        \PYGZob{}
                .type = IIO\PYGZus{}VOLTAGE,
                .indexed = 1,
                .channel = 1,
                .info\PYGZus{}mask\PYGZus{}separate = BIT(IIO\PYGZus{}CHAN\PYGZus{}INFO\PYGZus{}RAW),
        \PYGZcb{},
\PYGZcb{}
\end{Verbatim}

This will generate two separate attributes files for raw data retrieval:
\begin{itemize}
\item {} 
\code{/sys/bus/iio/devices/iio:device\emph{X}/in\_voltage0\_raw}, representing
voltage measurement for channel 0.

\item {} 
\code{/sys/bus/iio/devices/iio:device\emph{X}/in\_voltage1\_raw}, representing
voltage measurement for channel 1.

\end{itemize}


\subsubsection{More details}
\label{driver-api/iio/core:more-details}\index{iio\_chan\_spec\_ext\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_chan_spec_ext_info}\pysigline{struct \bfcode{iio\_chan\_spec\_ext\_info}}
Extended channel info attribute

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct iio\PYGZus{}chan\PYGZus{}spec\PYGZus{}ext\PYGZus{}info \PYGZob{}
  const char *name;
  enum iio\PYGZus{}shared\PYGZus{}by shared;
  ssize\PYGZus{}t (*read)(struct iio\PYGZus{}dev *, uintptr\PYGZus{}t private, struct iio\PYGZus{}chan\PYGZus{}spec const *, char *buf);
  ssize\PYGZus{}t (*write)(struct iio\PYGZus{}dev *, uintptr\PYGZus{}t private,struct iio\PYGZus{}chan\PYGZus{}spec const *, const char *buf, size\PYGZus{}t len);
  uintptr\PYGZus{}t private;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
Info attribute name

\item[{\code{shared}}] \leavevmode
Whether this attribute is shared between all channels.

\item[{\code{read}}] \leavevmode
Read callback for this info attribute, may be NULL.

\item[{\code{write}}] \leavevmode
Write callback for this info attribute, may be NULL.

\item[{\code{private}}] \leavevmode
Data private to the driver.

\end{description}
\index{iio\_enum (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_enum}\pysigline{struct \bfcode{iio\_enum}}
Enum channel info attribute

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct iio\PYGZus{}enum \PYGZob{}
  const char * const *items;
  unsigned int num\PYGZus{}items;
  int (*set)(struct iio\PYGZus{}dev *, const struct iio\PYGZus{}chan\PYGZus{}spec *, unsigned int);
  int (*get)(struct iio\PYGZus{}dev *, const struct iio\PYGZus{}chan\PYGZus{}spec *);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{items}}] \leavevmode
An array of strings.

\item[{\code{num\_items}}] \leavevmode
Length of the item array.

\item[{\code{set}}] \leavevmode
Set callback function, may be NULL.

\item[{\code{get}}] \leavevmode
Get callback function, may be NULL.

\end{description}

\textbf{Description}

The iio\_enum struct can be used to implement enum style channel attributes.
Enum style attributes are those which have a set of strings which map to
unsigned integer values. The IIO enum helper code takes care of mapping
between value and string as well as generating a ``\_available'' file which
contains a list of all available items. The set callback will be called when
the attribute is updated. The last parameter is the index to the newly
activated item. The get callback will be used to query the currently active
item and is supposed to return the index for it.
\index{IIO\_ENUM (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.IIO_ENUM}\pysiglinewithargsret{\bfcode{IIO\_ENUM}}{\emph{\_name}, \emph{\_shared}, \emph{\_e}}{}
Initialize enum extended channel attribute

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_name}}] \leavevmode
Attribute name

\item[{\code{\_shared}}] \leavevmode
Whether the attribute is shared between all channels

\item[{\code{\_e}}] \leavevmode
Pointer to an iio\_enum struct

\end{description}

\textbf{Description}

This should usually be used together with {\hyperref[driver\string-api/iio/core:c.IIO_ENUM_AVAILABLE]{\emph{\code{IIO\_ENUM\_AVAILABLE()}}}}
\index{IIO\_ENUM\_AVAILABLE (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.IIO_ENUM_AVAILABLE}\pysiglinewithargsret{\bfcode{IIO\_ENUM\_AVAILABLE}}{\emph{\_name}, \emph{\_e}}{}
Initialize enum available extended channel attribute

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_name}}] \leavevmode
Attribute name (``\_available'' will be appended to the name)

\item[{\code{\_e}}] \leavevmode
Pointer to an iio\_enum struct

\end{description}

\textbf{Description}

Creates a read only attribute which lists all the available enum items in a
space separated list. This should usually be used together with {\hyperref[driver\string-api/iio/core:c.IIO_ENUM]{\emph{\code{IIO\_ENUM()}}}}
\index{iio\_mount\_matrix (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_mount_matrix}\pysigline{struct \bfcode{iio\_mount\_matrix}}
iio mounting matrix

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct iio\PYGZus{}mount\PYGZus{}matrix \PYGZob{}
  const char *rotation[9];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{rotation}}] \leavevmode
3 dimensional space rotation matrix defining sensor alignment with
main hardware

\end{description}
\index{IIO\_MOUNT\_MATRIX (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.IIO_MOUNT_MATRIX}\pysiglinewithargsret{\bfcode{IIO\_MOUNT\_MATRIX}}{\emph{\_shared}, \emph{\_get}}{}
Initialize mount matrix extended channel attribute

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_shared}}] \leavevmode
Whether the attribute is shared between all channels

\item[{\code{\_get}}] \leavevmode
Pointer to an iio\_get\_mount\_matrix\_t accessor

\end{description}
\index{iio\_event\_spec (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_event_spec}\pysigline{struct \bfcode{iio\_event\_spec}}
specification for a channel event

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct iio\PYGZus{}event\PYGZus{}spec \PYGZob{}
  enum iio\PYGZus{}event\PYGZus{}type type;
  enum iio\PYGZus{}event\PYGZus{}direction dir;
  unsigned long mask\PYGZus{}separate;
  unsigned long mask\PYGZus{}shared\PYGZus{}by\PYGZus{}type;
  unsigned long mask\PYGZus{}shared\PYGZus{}by\PYGZus{}dir;
  unsigned long mask\PYGZus{}shared\PYGZus{}by\PYGZus{}all;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{type}}] \leavevmode
Type of the event

\item[{\code{dir}}] \leavevmode
Direction of the event

\item[{\code{mask\_separate}}] \leavevmode
Bit mask of enum iio\_event\_info values. Attributes
set in this mask will be registered per channel.

\item[{\code{mask\_shared\_by\_type}}] \leavevmode
Bit mask of enum iio\_event\_info values. Attributes
set in this mask will be shared by channel type.

\item[{\code{mask\_shared\_by\_dir}}] \leavevmode
Bit mask of enum iio\_event\_info values. Attributes
set in this mask will be shared by channel type and
direction.

\item[{\code{mask\_shared\_by\_all}}] \leavevmode
Bit mask of enum iio\_event\_info values. Attributes
set in this mask will be shared by all channels.

\end{description}
\index{iio\_chan\_spec (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_chan_spec}\pysigline{struct \bfcode{iio\_chan\_spec}}
specification of a single channel

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct iio\PYGZus{}chan\PYGZus{}spec \PYGZob{}
  enum iio\PYGZus{}chan\PYGZus{}type      type;
  int channel;
  int channel2;
  unsigned long           address;
  int scan\PYGZus{}index;
  struct \PYGZob{}
    char sign;
    u8 realbits;
    u8 storagebits;
    u8 shift;
    u8 repeat;
    enum iio\PYGZus{}endian endianness;
  \PYGZcb{} scan\PYGZus{}type;
  long info\PYGZus{}mask\PYGZus{}separate;
  long info\PYGZus{}mask\PYGZus{}separate\PYGZus{}available;
  long info\PYGZus{}mask\PYGZus{}shared\PYGZus{}by\PYGZus{}type;
  long info\PYGZus{}mask\PYGZus{}shared\PYGZus{}by\PYGZus{}type\PYGZus{}available;
  long info\PYGZus{}mask\PYGZus{}shared\PYGZus{}by\PYGZus{}dir;
  long info\PYGZus{}mask\PYGZus{}shared\PYGZus{}by\PYGZus{}dir\PYGZus{}available;
  long info\PYGZus{}mask\PYGZus{}shared\PYGZus{}by\PYGZus{}all;
  long info\PYGZus{}mask\PYGZus{}shared\PYGZus{}by\PYGZus{}all\PYGZus{}available;
  const struct iio\PYGZus{}event\PYGZus{}spec *event\PYGZus{}spec;
  unsigned int            num\PYGZus{}event\PYGZus{}specs;
  const struct iio\PYGZus{}chan\PYGZus{}spec\PYGZus{}ext\PYGZus{}info *ext\PYGZus{}info;
  const char              *extend\PYGZus{}name;
  const char              *datasheet\PYGZus{}name;
  unsigned modified:1;
  unsigned indexed:1;
  unsigned output:1;
  unsigned differential:1;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{type}}] \leavevmode
What type of measurement is the channel making.

\item[{\code{channel}}] \leavevmode
What number do we wish to assign the channel.

\item[{\code{channel2}}] \leavevmode
If there is a second number for a differential
channel then this is it. If modified is set then the
value here specifies the modifier.

\item[{\code{address}}] \leavevmode
Driver specific identifier.

\item[{\code{scan\_index}}] \leavevmode
Monotonic index to give ordering in scans when read
from a buffer.

\item[{\code{scan\_type}}] \leavevmode
sign:           `s' or `u' to specify signed or unsigned
realbits:       Number of valid bits of data
storagebits:    Realbits + padding
shift:          Shift right by this before masking out
\begin{quote}

realbits.
\end{quote}
\begin{description}
\item[{repeat:         Number of times real/storage bits}] \leavevmode
repeats. When the repeat element is
more than 1, then the type element in
sysfs will show a repeat value.
Otherwise, the number of repetitions is
omitted.

\end{description}

endianness:     little or big endian

\item[{\code{info\_mask\_separate}}] \leavevmode
What information is to be exported that is specific to
this channel.

\item[{\code{info\_mask\_separate\_available}}] \leavevmode
What availability information is to be
exported that is specific to this channel.

\item[{\code{info\_mask\_shared\_by\_type}}] \leavevmode
What information is to be exported that is shared
by all channels of the same type.

\item[{\code{info\_mask\_shared\_by\_type\_available}}] \leavevmode
What availability information is to be
exported that is shared by all channels of the same
type.

\item[{\code{info\_mask\_shared\_by\_dir}}] \leavevmode
What information is to be exported that is shared
by all channels of the same direction.

\item[{\code{info\_mask\_shared\_by\_dir\_available}}] \leavevmode
What availability information is to be
exported that is shared by all channels of the same
direction.

\item[{\code{info\_mask\_shared\_by\_all}}] \leavevmode
What information is to be exported that is shared
by all channels.

\item[{\code{info\_mask\_shared\_by\_all\_available}}] \leavevmode
What availability information is to be
exported that is shared by all channels.

\item[{\code{event\_spec}}] \leavevmode
Array of events which should be registered for this
channel.

\item[{\code{num\_event\_specs}}] \leavevmode
Size of the event\_spec array.

\item[{\code{ext\_info}}] \leavevmode
Array of extended info attributes for this channel.
The array is NULL terminated, the last element should
have its name field set to NULL.

\item[{\code{extend\_name}}] \leavevmode
Allows labeling of channel attributes with an
informative name. Note this has no effect codes etc,
unlike modifiers.

\item[{\code{datasheet\_name}}] \leavevmode
A name used in in-kernel mapping of channels. It should
correspond to the first name that the channel is referred
to by in the datasheet (e.g. IND), or the nearest
possible compound name (e.g. IND-INC).

\item[{\code{modified}}] \leavevmode
Does a modifier apply to this channel. What these are
depends on the channel type.  Modifier is set in
channel2. Examples are IIO\_MOD\_X for axial sensors about
the `x' axis.

\item[{\code{indexed}}] \leavevmode
Specify the channel has a numerical index. If not,
the channel index number will be suppressed for sysfs
attributes but not for event codes.

\item[{\code{output}}] \leavevmode
Channel is output.

\item[{\code{differential}}] \leavevmode
Channel is differential.

\end{description}
\index{iio\_channel\_has\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_channel_has_info}\pysiglinewithargsret{bool \bfcode{iio\_channel\_has\_info}}{const struct {\hyperref[driver\string-api/iio/core:c.iio_chan_spec]{\emph{iio\_chan\_spec}}} *\emph{ chan}, enum iio\_chan\_info\_enum\emph{ type}}{}
Checks whether a channel supports a info attribute

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct iio\_chan\_spec * chan}}] \leavevmode
The channel to be queried

\item[{\code{enum iio\_chan\_info\_enum type}}] \leavevmode
Type of the info attribute to be checked

\end{description}

\textbf{Description}

Returns true if the channels supports reporting values for the given info
attribute type, false otherwise.
\index{iio\_channel\_has\_available (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_channel_has_available}\pysiglinewithargsret{bool \bfcode{iio\_channel\_has\_available}}{const struct {\hyperref[driver\string-api/iio/core:c.iio_chan_spec]{\emph{iio\_chan\_spec}}} *\emph{ chan}, enum iio\_chan\_info\_enum\emph{ type}}{}
Checks if a channel has an available attribute

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct iio\_chan\_spec * chan}}] \leavevmode
The channel to be queried

\item[{\code{enum iio\_chan\_info\_enum type}}] \leavevmode
Type of the available attribute to be checked

\end{description}

\textbf{Description}

Returns true if the channel supports reporting available values for the
given attribute type, false otherwise.
\index{iio\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_info}\pysigline{struct \bfcode{iio\_info}}
constant information about device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct iio\PYGZus{}info \PYGZob{}
  const struct attribute\PYGZus{}group    *event\PYGZus{}attrs;
  const struct attribute\PYGZus{}group    *attrs;
  int (*read\PYGZus{}raw)(struct iio\PYGZus{}dev *indio\PYGZus{}dev,struct iio\PYGZus{}chan\PYGZus{}spec const *chan,int *val,int *val2, long mask);
  int (*read\PYGZus{}raw\PYGZus{}multi)(struct iio\PYGZus{}dev *indio\PYGZus{}dev,struct iio\PYGZus{}chan\PYGZus{}spec const *chan,int max\PYGZus{}len,int *vals,int *val\PYGZus{}len, long mask);
  int (*read\PYGZus{}avail)(struct iio\PYGZus{}dev *indio\PYGZus{}dev,struct iio\PYGZus{}chan\PYGZus{}spec const *chan,const int **vals,int *type,int *length, long mask);
  int (*write\PYGZus{}raw)(struct iio\PYGZus{}dev *indio\PYGZus{}dev,struct iio\PYGZus{}chan\PYGZus{}spec const *chan,int val,int val2, long mask);
  int (*write\PYGZus{}raw\PYGZus{}get\PYGZus{}fmt)(struct iio\PYGZus{}dev *indio\PYGZus{}dev,struct iio\PYGZus{}chan\PYGZus{}spec const *chan, long mask);
  int (*read\PYGZus{}event\PYGZus{}config)(struct iio\PYGZus{}dev *indio\PYGZus{}dev,const struct iio\PYGZus{}chan\PYGZus{}spec *chan,enum iio\PYGZus{}event\PYGZus{}type type, enum iio\PYGZus{}event\PYGZus{}direction dir);
  int (*write\PYGZus{}event\PYGZus{}config)(struct iio\PYGZus{}dev *indio\PYGZus{}dev,const struct iio\PYGZus{}chan\PYGZus{}spec *chan,enum iio\PYGZus{}event\PYGZus{}type type,enum iio\PYGZus{}event\PYGZus{}direction dir, int state);
  int (*read\PYGZus{}event\PYGZus{}value)(struct iio\PYGZus{}dev *indio\PYGZus{}dev,const struct iio\PYGZus{}chan\PYGZus{}spec *chan,enum iio\PYGZus{}event\PYGZus{}type type,enum iio\PYGZus{}event\PYGZus{}direction dir, enum iio\PYGZus{}event\PYGZus{}info info, int *val, int *val2);
  int (*write\PYGZus{}event\PYGZus{}value)(struct iio\PYGZus{}dev *indio\PYGZus{}dev,const struct iio\PYGZus{}chan\PYGZus{}spec *chan,enum iio\PYGZus{}event\PYGZus{}type type,enum iio\PYGZus{}event\PYGZus{}direction dir, enum iio\PYGZus{}event\PYGZus{}info info, int val, int val2);
  int (*validate\PYGZus{}trigger)(struct iio\PYGZus{}dev *indio\PYGZus{}dev, struct iio\PYGZus{}trigger *trig);
  int (*update\PYGZus{}scan\PYGZus{}mode)(struct iio\PYGZus{}dev *indio\PYGZus{}dev, const unsigned long *scan\PYGZus{}mask);
  int (*debugfs\PYGZus{}reg\PYGZus{}access)(struct iio\PYGZus{}dev *indio\PYGZus{}dev,unsigned reg, unsigned writeval, unsigned *readval);
  int (*of\PYGZus{}xlate)(struct iio\PYGZus{}dev *indio\PYGZus{}dev, const struct of\PYGZus{}phandle\PYGZus{}args *iiospec);
  int (*hwfifo\PYGZus{}set\PYGZus{}watermark)(struct iio\PYGZus{}dev *indio\PYGZus{}dev, unsigned val);
  int (*hwfifo\PYGZus{}flush\PYGZus{}to\PYGZus{}buffer)(struct iio\PYGZus{}dev *indio\PYGZus{}dev, unsigned count);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{event\_attrs}}] \leavevmode
event control attributes

\item[{\code{attrs}}] \leavevmode
general purpose device attributes

\item[{\code{read\_raw}}] \leavevmode
function to request a value from the device.
mask specifies which value. Note 0 means a reading of
the channel in question.  Return value will specify the
type of value returned by the device. val and val2 will
contain the elements making up the returned value.

\item[{\code{read\_raw\_multi}}] \leavevmode
function to return values from the device.
mask specifies which value. Note 0 means a reading of
the channel in question.  Return value will specify the
type of value returned by the device. vals pointer
contain the elements making up the returned value.
max\_len specifies maximum number of elements
vals pointer can contain. val\_len is used to return
length of valid elements in vals.

\item[{\code{read\_avail}}] \leavevmode
function to return the available values from the device.
mask specifies which value. Note 0 means the available
values for the channel in question.  Return value
specifies if a IIO\_AVAIL\_LIST or a IIO\_AVAIL\_RANGE is
returned in vals. The type of the vals are returned in
type and the number of vals is returned in length. For
ranges, there are always three vals returned; min, step
and max. For lists, all possible values are enumerated.

\item[{\code{write\_raw}}] \leavevmode
function to write a value to the device.
Parameters are the same as for read\_raw.

\item[{\code{write\_raw\_get\_fmt}}] \leavevmode
callback function to query the expected
format/precision. If not set by the driver, write\_raw
returns IIO\_VAL\_INT\_PLUS\_MICRO.

\item[{\code{read\_event\_config}}] \leavevmode
find out if the event is enabled.

\item[{\code{write\_event\_config}}] \leavevmode
set if the event is enabled.

\item[{\code{read\_event\_value}}] \leavevmode
read a configuration value associated with the event.

\item[{\code{write\_event\_value}}] \leavevmode
write a configuration value for the event.

\item[{\code{validate\_trigger}}] \leavevmode
function to validate the trigger when the
current trigger gets changed.

\item[{\code{update\_scan\_mode}}] \leavevmode
function to configure device and scan buffer when
channels have changed

\item[{\code{debugfs\_reg\_access}}] \leavevmode
function to read or write register value of device

\item[{\code{of\_xlate}}] \leavevmode
function pointer to obtain channel specifier index.
When \#iio-cells is greater than `0', the driver could
provide a custom of\_xlate function that reads the
\emph{args} and returns the appropriate index in registered
IIO channels array.

\item[{\code{hwfifo\_set\_watermark}}] \leavevmode
function pointer to set the current hardware
fifo watermark level; see hwfifo\_* entries in
Documentation/ABI/testing/sysfs-bus-iio for details on
how the hardware fifo operates

\item[{\code{hwfifo\_flush\_to\_buffer}}] \leavevmode
function pointer to flush the samples stored
in the hardware fifo to the device buffer. The driver
should not flush more than count samples. The function
must return the number of samples flushed, 0 if no
samples were flushed or a negative integer if no samples
were flushed and there was an error.

\end{description}
\index{iio\_buffer\_setup\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_buffer_setup_ops}\pysigline{struct \bfcode{iio\_buffer\_setup\_ops}}
buffer setup related callbacks

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct iio\PYGZus{}buffer\PYGZus{}setup\PYGZus{}ops \PYGZob{}
  int (*preenable)(struct iio\PYGZus{}dev *);
  int (*postenable)(struct iio\PYGZus{}dev *);
  int (*predisable)(struct iio\PYGZus{}dev *);
  int (*postdisable)(struct iio\PYGZus{}dev *);
  bool (*validate\PYGZus{}scan\PYGZus{}mask)(struct iio\PYGZus{}dev *indio\PYGZus{}dev, const unsigned long *scan\PYGZus{}mask);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{preenable}}] \leavevmode
{[}DRIVER{]} function to run prior to marking buffer enabled

\item[{\code{postenable}}] \leavevmode
{[}DRIVER{]} function to run after marking buffer enabled

\item[{\code{predisable}}] \leavevmode
{[}DRIVER{]} function to run prior to marking buffer
disabled

\item[{\code{postdisable}}] \leavevmode
{[}DRIVER{]} function to run after marking buffer disabled

\item[{\code{validate\_scan\_mask}}] \leavevmode
{[}DRIVER{]} function callback to check whether a given
scan mask is valid for the device.

\end{description}
\index{iio\_dev (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_dev}\pysigline{struct \bfcode{iio\_dev}}
industrial I/O device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct iio\PYGZus{}dev \PYGZob{}
  int id;
  struct module                   *driver\PYGZus{}module;
  int modes;
  int currentmode;
  struct device                   dev;
  struct iio\PYGZus{}event\PYGZus{}interface      *event\PYGZus{}interface;
  struct iio\PYGZus{}buffer               *buffer;
  struct list\PYGZus{}head                buffer\PYGZus{}list;
  int scan\PYGZus{}bytes;
  struct mutex                    mlock;
  const unsigned long             *available\PYGZus{}scan\PYGZus{}masks;
  unsigned masklength;
  const unsigned long             *active\PYGZus{}scan\PYGZus{}mask;
  bool scan\PYGZus{}timestamp;
  unsigned scan\PYGZus{}index\PYGZus{}timestamp;
  struct iio\PYGZus{}trigger              *trig;
  bool trig\PYGZus{}readonly;
  struct iio\PYGZus{}poll\PYGZus{}func            *pollfunc;
  struct iio\PYGZus{}poll\PYGZus{}func            *pollfunc\PYGZus{}event;
  struct iio\PYGZus{}chan\PYGZus{}spec const      *channels;
  int num\PYGZus{}channels;
  struct list\PYGZus{}head                channel\PYGZus{}attr\PYGZus{}list;
  struct attribute\PYGZus{}group          chan\PYGZus{}attr\PYGZus{}group;
  const char                      *name;
  const struct iio\PYGZus{}info           *info;
  clockid\PYGZus{}t clock\PYGZus{}id;
  struct mutex                    info\PYGZus{}exist\PYGZus{}lock;
  const struct iio\PYGZus{}buffer\PYGZus{}setup\PYGZus{}ops       *setup\PYGZus{}ops;
  struct cdev                     chrdev;
\PYGZsh{}define IIO\PYGZus{}MAX\PYGZus{}GROUPS 6;
  const struct attribute\PYGZus{}group    *groups[IIO\PYGZus{}MAX\PYGZus{}GROUPS + 1];
  int groupcounter;
  unsigned long                   flags;
\PYGZsh{}if defined(CONFIG\PYGZus{}DEBUG\PYGZus{}FS);
  struct dentry                   *debugfs\PYGZus{}dentry;
  unsigned cached\PYGZus{}reg\PYGZus{}addr;
\PYGZsh{}endif;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{id}}] \leavevmode
{[}INTERN{]} used to identify device internally

\item[{\code{driver\_module}}] \leavevmode
{[}INTERN{]} used to make it harder to undercut users

\item[{\code{modes}}] \leavevmode
{[}DRIVER{]} operating modes supported by device

\item[{\code{currentmode}}] \leavevmode
{[}DRIVER{]} current operating mode

\item[{\code{dev}}] \leavevmode
{[}DRIVER{]} device structure, should be assigned a parent
and owner

\item[{\code{event\_interface}}] \leavevmode
{[}INTERN{]} event chrdevs associated with interrupt lines

\item[{\code{buffer}}] \leavevmode
{[}DRIVER{]} any buffer present

\item[{\code{buffer\_list}}] \leavevmode
{[}INTERN{]} list of all buffers currently attached

\item[{\code{scan\_bytes}}] \leavevmode
{[}INTERN{]} num bytes captured to be fed to buffer demux

\item[{\code{mlock}}] \leavevmode
{[}DRIVER{]} lock used to prevent simultaneous device state
changes

\item[{\code{available\_scan\_masks}}] \leavevmode
{[}DRIVER{]} optional array of allowed bitmasks

\item[{\code{masklength}}] \leavevmode
{[}INTERN{]} the length of the mask established from
channels

\item[{\code{active\_scan\_mask}}] \leavevmode
{[}INTERN{]} union of all scan masks requested by buffers

\item[{\code{scan\_timestamp}}] \leavevmode
{[}INTERN{]} set if any buffers have requested timestamp

\item[{\code{scan\_index\_timestamp}}] \leavevmode
{[}INTERN{]} cache of the index to the timestamp

\item[{\code{trig}}] \leavevmode
{[}INTERN{]} current device trigger (buffer modes)

\item[{\code{trig\_readonly}}] \leavevmode
{[}INTERN{]} mark the current trigger immutable

\item[{\code{pollfunc}}] \leavevmode
{[}DRIVER{]} function run on trigger being received

\item[{\code{pollfunc\_event}}] \leavevmode
{[}DRIVER{]} function run on events trigger being received

\item[{\code{channels}}] \leavevmode
{[}DRIVER{]} channel specification structure table

\item[{\code{num\_channels}}] \leavevmode
{[}DRIVER{]} number of channels specified in \textbf{channels}.

\item[{\code{channel\_attr\_list}}] \leavevmode
{[}INTERN{]} keep track of automatically created channel
attributes

\item[{\code{chan\_attr\_group}}] \leavevmode
{[}INTERN{]} group for all attrs in base directory

\item[{\code{name}}] \leavevmode
{[}DRIVER{]} name of the device.

\item[{\code{info}}] \leavevmode
{[}DRIVER{]} callbacks and constant info from driver

\item[{\code{clock\_id}}] \leavevmode
{[}INTERN{]} timestamping clock posix identifier

\item[{\code{info\_exist\_lock}}] \leavevmode
{[}INTERN{]} lock to prevent use during removal

\item[{\code{setup\_ops}}] \leavevmode
{[}DRIVER{]} callbacks to call before and after buffer
enable/disable

\item[{\code{chrdev}}] \leavevmode
{[}INTERN{]} associated character device

\item[{\code{groups}}] \leavevmode
{[}INTERN{]} attribute groups

\item[{\code{groupcounter}}] \leavevmode
{[}INTERN{]} index of next attribute group

\item[{\code{flags}}] \leavevmode
{[}INTERN{]} file ops related flags including busy flag.

\item[{\code{debugfs\_dentry}}] \leavevmode
{[}INTERN{]} device specific debugfs dentry.

\item[{\code{cached\_reg\_addr}}] \leavevmode
{[}INTERN{]} cached register address for debugfs reads.

\end{description}
\index{iio\_device\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_device_register}\pysiglinewithargsret{\bfcode{iio\_device\_register}}{\emph{indio\_dev}}{}
register a device with the IIO subsystem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{indio\_dev}}] \leavevmode
Device structure filled by the device driver

\end{description}
\index{devm\_iio\_device\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.devm_iio_device_register}\pysiglinewithargsret{\bfcode{devm\_iio\_device\_register}}{\emph{dev}, \emph{indio\_dev}}{}
Resource-managed {\hyperref[driver\string-api/iio/core:c.iio_device_register]{\emph{\code{iio\_device\_register()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{dev}}] \leavevmode
Device to allocate iio\_dev for

\item[{\code{indio\_dev}}] \leavevmode
Device structure filled by the device driver

\end{description}

\textbf{Description}

Managed iio\_device\_register.  The IIO device registered with this
function is automatically unregistered on driver detach. This function
calls {\hyperref[driver\string-api/iio/core:c.iio_device_register]{\emph{\code{iio\_device\_register()}}}} internally. Refer to that function for more
information.

If an iio\_dev registered with this function needs to be unregistered
separately, {\hyperref[driver\string-api/iio/core:c.devm_iio_device_unregister]{\emph{\code{devm\_iio\_device\_unregister()}}}} must be used.

\textbf{Return}

0 on success, negative error number on failure.
\index{iio\_device\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_device_put}\pysiglinewithargsret{void \bfcode{iio\_device\_put}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}}{}
reference counted deallocation of struct device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
IIO device structure containing the device

\end{description}
\index{iio\_device\_get\_clock (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_device_get_clock}\pysiglinewithargsret{clockid\_t \bfcode{iio\_device\_get\_clock}}{const struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}}{}
Retrieve current timestamping clock for the device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct iio\_dev * indio\_dev}}] \leavevmode
IIO device structure containing the device

\end{description}
\index{dev\_to\_iio\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.dev_to_iio_dev}\pysiglinewithargsret{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} * \bfcode{dev\_to\_iio\_dev}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
Get IIO device struct from a device struct

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
The device embedded in the IIO device

\end{description}

\textbf{Note}

The device must be a IIO device, otherwise the result is undefined.
\index{iio\_device\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_device_get}\pysiglinewithargsret{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} * \bfcode{iio\_device\_get}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}}{}
increment reference count for the device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
IIO device structure

\end{description}

\textbf{Return}

The passed IIO device
\index{iio\_device\_set\_drvdata (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_device_set_drvdata}\pysiglinewithargsret{void \bfcode{iio\_device\_set\_drvdata}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}, void *\emph{ data}}{}
Set device driver data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
IIO device structure

\item[{\code{void * data}}] \leavevmode
Driver specific data

\end{description}

\textbf{Description}

Allows to attach an arbitrary pointer to an IIO device, which can later be
retrieved by {\hyperref[driver\string-api/iio/core:c.iio_device_get_drvdata]{\emph{\code{iio\_device\_get\_drvdata()}}}}.
\index{iio\_device\_get\_drvdata (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_device_get_drvdata}\pysiglinewithargsret{void * \bfcode{iio\_device\_get\_drvdata}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}}{}
Get device driver data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
IIO device structure

\end{description}

\textbf{Description}

Returns the data previously set with {\hyperref[driver\string-api/iio/core:c.iio_device_set_drvdata]{\emph{\code{iio\_device\_set\_drvdata()}}}}
\index{iio\_buffer\_enabled (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_buffer_enabled}\pysiglinewithargsret{bool \bfcode{iio\_buffer\_enabled}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}}{}
helper function to test if the buffer is enabled

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
IIO device structure for device

\end{description}
\index{iio\_get\_debugfs\_dentry (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_get_debugfs_dentry}\pysiglinewithargsret{struct dentry * \bfcode{iio\_get\_debugfs\_dentry}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}}{}
helper function to get the debugfs\_dentry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
IIO device structure for device

\end{description}
\index{IIO\_DEGREE\_TO\_RAD (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.IIO_DEGREE_TO_RAD}\pysiglinewithargsret{\bfcode{IIO\_DEGREE\_TO\_RAD}}{\emph{deg}}{}
Convert degree to rad

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{deg}}] \leavevmode
A value in degree

\end{description}

\textbf{Description}

Returns the given value converted from degree to rad
\index{IIO\_RAD\_TO\_DEGREE (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.IIO_RAD_TO_DEGREE}\pysiglinewithargsret{\bfcode{IIO\_RAD\_TO\_DEGREE}}{\emph{rad}}{}
Convert rad to degree

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{rad}}] \leavevmode
A value in rad

\end{description}

\textbf{Description}

Returns the given value converted from rad to degree
\index{IIO\_G\_TO\_M\_S\_2 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.IIO_G_TO_M_S_2}\pysiglinewithargsret{\bfcode{IIO\_G\_TO\_M\_S\_2}}{\emph{g}}{}
Convert g to meter / second**2

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{g}}] \leavevmode
A value in g

\end{description}

\textbf{Description}

Returns the given value converted from g to meter / second**2
\index{IIO\_M\_S\_2\_TO\_G (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.IIO_M_S_2_TO_G}\pysiglinewithargsret{\bfcode{IIO\_M\_S\_2\_TO\_G}}{\emph{ms2}}{}
Convert meter / second**2 to g

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{ms2}}] \leavevmode
A value in meter / second**2

\end{description}

\textbf{Description}

Returns the given value converted from meter / second**2 to g
\index{iio\_get\_time\_ns (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_get_time_ns}\pysiglinewithargsret{s64 \bfcode{iio\_get\_time\_ns}}{const struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}}{}
utility function to get a time stamp for events etc

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct iio\_dev * indio\_dev}}] \leavevmode
device

\end{description}
\index{iio\_get\_time\_res (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_get_time_res}\pysiglinewithargsret{unsigned int \bfcode{iio\_get\_time\_res}}{const struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}}{}
utility function to get time stamp clock resolution in nano seconds.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct iio\_dev * indio\_dev}}] \leavevmode
device

\end{description}
\index{of\_iio\_read\_mount\_matrix (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.of_iio_read_mount_matrix}\pysiglinewithargsret{int \bfcode{of\_iio\_read\_mount\_matrix}}{const struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ propname}, struct {\hyperref[driver\string-api/iio/core:c.iio_mount_matrix]{\emph{iio\_mount\_matrix}}} *\emph{ matrix}}{}
retrieve iio device mounting matrix from device-tree ``mount-matrix'' property

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct device * dev}}] \leavevmode
device the mounting matrix property is assigned to

\item[{\code{const char * propname}}] \leavevmode
device specific mounting matrix property name

\item[{\code{struct iio\_mount\_matrix * matrix}}] \leavevmode
where to store retrieved matrix

\end{description}

\textbf{Description}

If device is assigned no mounting matrix property, a default 3x3 identity
matrix will be filled in.

\textbf{Return}

0 if success, or a negative error code on failure.
\index{iio\_format\_value (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_format_value}\pysiglinewithargsret{ssize\_t \bfcode{iio\_format\_value}}{char *\emph{ buf}, unsigned int\emph{ type}, int\emph{ size}, int *\emph{ vals}}{}
Formats a IIO value into its string representation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{char * buf}}] \leavevmode
The buffer to which the formatted value gets written
which is assumed to be big enough (i.e. PAGE\_SIZE).

\item[{\code{unsigned int type}}] \leavevmode
One of the IIO\_VAL\_* constants. This decides how the val
and val2 parameters are formatted.

\item[{\code{int size}}] \leavevmode
Number of IIO value entries contained in vals

\item[{\code{int * vals}}] \leavevmode
Pointer to the values, exact meaning depends on the
type parameter.

\end{description}

\textbf{Return}
\begin{description}
\item[{0 by default, a negative number on failure or the}] \leavevmode
total number of characters written for a type that belongs
to the IIO\_VAL\_* constant.

\end{description}
\index{iio\_str\_to\_fixpoint (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_str_to_fixpoint}\pysiglinewithargsret{int \bfcode{iio\_str\_to\_fixpoint}}{const char *\emph{ str}, int\emph{ fract\_mult}, int *\emph{ integer}, int *\emph{ fract}}{}
Parse a fixed-point number from a string

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * str}}] \leavevmode
The string to parse

\item[{\code{int fract\_mult}}] \leavevmode
Multiplier for the first decimal place, should be a power of 10

\item[{\code{int * integer}}] \leavevmode
The integer part of the number

\item[{\code{int * fract}}] \leavevmode
The fractional part of the number

\end{description}

\textbf{Description}

Returns 0 on success, or a negative error code if the string could not be
parsed.
\index{iio\_device\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_device_alloc}\pysiglinewithargsret{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} * \bfcode{iio\_device\_alloc}}{int\emph{ sizeof\_priv}}{}
allocate an iio\_dev from a driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int sizeof\_priv}}] \leavevmode
Space to allocate for private structure.

\end{description}
\index{iio\_device\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_device_free}\pysiglinewithargsret{void \bfcode{iio\_device\_free}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ dev}}{}
free an iio\_dev from a driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * dev}}] \leavevmode
the iio\_dev associated with the device

\end{description}
\index{devm\_iio\_device\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.devm_iio_device_alloc}\pysiglinewithargsret{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} * \bfcode{devm\_iio\_device\_alloc}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, int\emph{ sizeof\_priv}}{}
Resource-managed {\hyperref[driver\string-api/iio/core:c.iio_device_alloc]{\emph{\code{iio\_device\_alloc()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to allocate iio\_dev for

\item[{\code{int sizeof\_priv}}] \leavevmode
Space to allocate for private structure.

\end{description}

\textbf{Description}

Managed iio\_device\_alloc. iio\_dev allocated with this function is
automatically freed on driver detach.

If an iio\_dev allocated with this function needs to be freed separately,
{\hyperref[driver\string-api/iio/core:c.devm_iio_device_free]{\emph{\code{devm\_iio\_device\_free()}}}} must be used.

\textbf{Return}

Pointer to allocated iio\_dev on success, NULL on failure.
\index{devm\_iio\_device\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.devm_iio_device_free}\pysiglinewithargsret{void \bfcode{devm\_iio\_device\_free}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ iio\_dev}}{}
Resource-managed {\hyperref[driver\string-api/iio/core:c.iio_device_free]{\emph{\code{iio\_device\_free()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device this iio\_dev belongs to

\item[{\code{struct iio\_dev * iio\_dev}}] \leavevmode
the iio\_dev associated with the device

\end{description}

\textbf{Description}

Free iio\_dev allocated with {\hyperref[driver\string-api/iio/core:c.devm_iio_device_alloc]{\emph{\code{devm\_iio\_device\_alloc()}}}}.
\index{iio\_device\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_device_unregister}\pysiglinewithargsret{void \bfcode{iio\_device\_unregister}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}}{}
unregister a device from the IIO subsystem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
Device structure representing the device.

\end{description}
\index{devm\_iio\_device\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.devm_iio_device_unregister}\pysiglinewithargsret{void \bfcode{devm\_iio\_device\_unregister}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}}{}
Resource-managed {\hyperref[driver\string-api/iio/core:c.iio_device_unregister]{\emph{\code{iio\_device\_unregister()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device this iio\_dev belongs to

\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
the iio\_dev associated with the device

\end{description}

\textbf{Description}

Unregister iio\_dev registered with {\hyperref[driver\string-api/iio/core:c.devm_iio_device_register]{\emph{\code{devm\_iio\_device\_register()}}}}.
\index{iio\_device\_claim\_direct\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_device_claim_direct_mode}\pysiglinewithargsret{int \bfcode{iio\_device\_claim\_direct\_mode}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}}{}
Keep device in direct mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
the iio\_dev associated with the device

\end{description}

\textbf{Description}

If the device is in direct mode it is guaranteed to stay
that way until {\hyperref[driver\string-api/iio/core:c.iio_device_release_direct_mode]{\emph{\code{iio\_device\_release\_direct\_mode()}}}} is called.

Use with {\hyperref[driver\string-api/iio/core:c.iio_device_release_direct_mode]{\emph{\code{iio\_device\_release\_direct\_mode()}}}}

\textbf{Return}

0 on success, -EBUSY on failure
\index{iio\_device\_release\_direct\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/core:c.iio_device_release_direct_mode}\pysiglinewithargsret{void \bfcode{iio\_device\_release\_direct\_mode}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}}{}
releases claim on direct mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
the iio\_dev associated with the device

\end{description}

\textbf{Description}

Release the claim. Device is no longer guaranteed to stay
in direct mode.

Use with {\hyperref[driver\string-api/iio/core:c.iio_device_claim_direct_mode]{\emph{\code{iio\_device\_claim\_direct\_mode()}}}}


\section{Buffers}
\label{driver-api/iio/buffers::doc}\label{driver-api/iio/buffers:buffers}\begin{itemize}
\item {} 
struct \code{iio\_buffer} — general buffer structure

\item {} 
{\hyperref[driver\string-api/iio/buffers:c.iio_validate_scan_mask_onehot]{\emph{\code{iio\_validate\_scan\_mask\_onehot()}}}} — Validates that exactly one channel
is selected

\item {} 
{\hyperref[driver\string-api/iio/buffers:c.iio_buffer_get]{\emph{\code{iio\_buffer\_get()}}}} — Grab a reference to the buffer

\item {} 
{\hyperref[driver\string-api/iio/buffers:c.iio_buffer_put]{\emph{\code{iio\_buffer\_put()}}}} — Release the reference to the buffer

\end{itemize}

The Industrial I/O core offers a way for continuous data capture based on a
trigger source. Multiple data channels can be read at once from
\code{/dev/iio:device\emph{X}} character device node, thus reducing the CPU load.


\subsection{IIO buffer sysfs interface}
\label{driver-api/iio/buffers:iio-buffer-sysfs-interface}
An IIO buffer has an associated attributes directory under
\code{/sys/bus/iio/iio:device\emph{X}/buffer/*}. Here are some of the existing
attributes:
\begin{itemize}
\item {} 
\code{length}, the total number of data samples (capacity) that can be
stored by the buffer.

\item {} 
\code{enable}, activate buffer capture.

\end{itemize}


\subsection{IIO buffer setup}
\label{driver-api/iio/buffers:iio-buffer-setup}
The meta information associated with a channel reading placed in a buffer is
called a scan element . The important bits configuring scan elements are
exposed to userspace applications via the
\code{/sys/bus/iio/iio:device\emph{X}/scan\_elements/*} directory. This file contains
attributes of the following form:
\begin{itemize}
\item {} 
\code{enable}, used for enabling a channel. If and only if its attribute
is non \emph{zero}, then a triggered capture will contain data samples for this
channel.

\item {} 
\code{type}, description of the scan element data storage within the buffer
and hence the form in which it is read from user space.
Format is {[}be\textbar{}le{]}:{[}s\textbar{}u{]}bits/storagebitsXrepeat{[}\textgreater{}\textgreater{}shift{]} .
* \emph{be} or \emph{le}, specifies big or little endian.
* \emph{s} or \emph{u}, specifies if signed (2's complement) or unsigned.
* \emph{bits}, is the number of valid data bits.
* \emph{storagebits}, is the number of bits (after padding) that it occupies in the
buffer.
* \emph{shift}, if specified, is the shift that needs to be applied prior to
masking out unused bits.
* \emph{repeat}, specifies the number of bits/storagebits repetitions. When the
repeat element is 0 or 1, then the repeat value is omitted.

\end{itemize}

For example, a driver for a 3-axis accelerometer with 12 bit resolution where
data is stored in two 8-bits registers as follows:

\begin{Verbatim}[commandchars=\\\{\}]
  7   6   5   4   3   2   1   0
+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\textbar{}D3 \textbar{}D2 \textbar{}D1 \textbar{}D0 \textbar{} X \textbar{} X \textbar{} X \textbar{} X \textbar{} (LOW byte, address 0x06)
+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+

  7   6   5   4   3   2   1   0
+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\textbar{}D11\textbar{}D10\textbar{}D9 \textbar{}D8 \textbar{}D7 \textbar{}D6 \textbar{}D5 \textbar{}D4 \textbar{} (HIGH byte, address 0x07)
+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{Verbatim}

will have the following scan element type for each axis:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} cat /sys/bus/iio/devices/iio:device0/scan\PYGZus{}elements/in\PYGZus{}accel\PYGZus{}y\PYGZus{}type
le:s12/16\PYGZgt{}\PYGZgt{}4
\end{Verbatim}

A user space application will interpret data samples read from the buffer as
two byte little endian signed data, that needs a 4 bits right shift before
masking out the 12 valid bits of data.

For implementing buffer support a driver should initialize the following
fields in iio\_chan\_spec definition:

\begin{Verbatim}[commandchars=\\\{\}]
struct iio\PYGZus{}chan\PYGZus{}spec \PYGZob{}
/* other members */
        int scan\PYGZus{}index
        struct \PYGZob{}
                char sign;
                u8 realbits;
                u8 storagebits;
                u8 shift;
                u8 repeat;
                enum iio\PYGZus{}endian endianness;
               \PYGZcb{} scan\PYGZus{}type;
       \PYGZcb{};
\end{Verbatim}

The driver implementing the accelerometer described above will have the
following channel definition:

\begin{Verbatim}[commandchars=\\\{\}]
struct struct iio\PYGZus{}chan\PYGZus{}spec accel\PYGZus{}channels[] = \PYGZob{}
        \PYGZob{}
                .type = IIO\PYGZus{}ACCEL,
                .modified = 1,
                .channel2 = IIO\PYGZus{}MOD\PYGZus{}X,
                /* other stuff here */
                .scan\PYGZus{}index = 0,
                .scan\PYGZus{}type = \PYGZob{}
                        .sign = \PYGZsq{}s\PYGZsq{},
                        .realbits = 12,
                        .storagebits = 16,
                        .shift = 4,
                        .endianness = IIO\PYGZus{}LE,
                \PYGZcb{},
        \PYGZcb{}
        /* similar for Y (with channel2 = IIO\PYGZus{}MOD\PYGZus{}Y, scan\PYGZus{}index = 1)
         * and Z (with channel2 = IIO\PYGZus{}MOD\PYGZus{}Z, scan\PYGZus{}index = 2) axis
         */
 \PYGZcb{}
\end{Verbatim}

Here \textbf{scan\_index} defines the order in which the enabled channels are placed
inside the buffer. Channels with a lower \textbf{scan\_index} will be placed before
channels with a higher index. Each channel needs to have a unique
\textbf{scan\_index}.

Setting \textbf{scan\_index} to -1 can be used to indicate that the specific channel
does not support buffered capture. In this case no entries will be created for
the channel in the scan\_elements directory.


\subsection{More details}
\label{driver-api/iio/buffers:more-details}\index{iio\_push\_to\_buffers\_with\_timestamp (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/buffers:c.iio_push_to_buffers_with_timestamp}\pysiglinewithargsret{int \bfcode{iio\_push\_to\_buffers\_with\_timestamp}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}, void *\emph{ data}, int64\_t\emph{ timestamp}}{}
push data and timestamp to buffers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
iio\_dev structure for device.

\item[{\code{void * data}}] \leavevmode
sample data

\item[{\code{int64\_t timestamp}}] \leavevmode
timestamp for the sample data

\end{description}

\textbf{Description}

Pushes data to the IIO device's buffers. If timestamps are enabled for the
device the function will store the supplied timestamp as the last element in
the sample data buffer before pushing it to the device buffers. The sample
data buffer needs to be large enough to hold the additional timestamp
(usually the buffer should be indio-\textgreater{}scan\_bytes bytes large).

Returns 0 on success, a negative error code otherwise.
\index{iio\_buffer\_set\_attrs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/buffers:c.iio_buffer_set_attrs}\pysiglinewithargsret{void \bfcode{iio\_buffer\_set\_attrs}}{struct iio\_buffer *\emph{ buffer}, const struct attribute **\emph{ attrs}}{}
Set buffer specific attributes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_buffer * buffer}}] \leavevmode
The buffer for which we are setting attributes

\item[{\code{const struct attribute ** attrs}}] \leavevmode
Pointer to a null terminated list of pointers to attributes

\end{description}
\index{iio\_validate\_scan\_mask\_onehot (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/buffers:c.iio_validate_scan_mask_onehot}\pysiglinewithargsret{bool \bfcode{iio\_validate\_scan\_mask\_onehot}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}, const unsigned long *\emph{ mask}}{}
Validates that exactly one channel is selected

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
the iio device

\item[{\code{const unsigned long * mask}}] \leavevmode
scan mask to be checked

\end{description}

\textbf{Description}

Return true if exactly one bit is set in the scan mask, false otherwise. It
can be used for devices where only one channel can be active for sampling at
a time.
\index{iio\_push\_to\_buffers (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/buffers:c.iio_push_to_buffers}\pysiglinewithargsret{int \bfcode{iio\_push\_to\_buffers}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}, const void *\emph{ data}}{}
push to a registered buffer.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
iio\_dev structure for device.

\item[{\code{const void * data}}] \leavevmode
Full scan.

\end{description}
\index{iio\_buffer\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/buffers:c.iio_buffer_get}\pysiglinewithargsret{struct iio\_buffer * \bfcode{iio\_buffer\_get}}{struct iio\_buffer *\emph{ buffer}}{}
Grab a reference to the buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_buffer * buffer}}] \leavevmode
The buffer to grab a reference for, may be NULL

\end{description}

\textbf{Description}

Returns the pointer to the buffer that was passed into the function.
\index{iio\_buffer\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/buffers:c.iio_buffer_put}\pysiglinewithargsret{void \bfcode{iio\_buffer\_put}}{struct iio\_buffer *\emph{ buffer}}{}
Release the reference to the buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_buffer * buffer}}] \leavevmode
The buffer to release the reference for, may be NULL

\end{description}
\index{iio\_device\_attach\_buffer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/buffers:c.iio_device_attach_buffer}\pysiglinewithargsret{void \bfcode{iio\_device\_attach\_buffer}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}, struct iio\_buffer *\emph{ buffer}}{}
Attach a buffer to a IIO device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
The device the buffer should be attached to

\item[{\code{struct iio\_buffer * buffer}}] \leavevmode
The buffer to attach to the device

\end{description}

\textbf{Description}

This function attaches a buffer to a IIO device. The buffer stays attached to
the device until the device is freed. The function should only be called at
most once per device.


\section{Triggers}
\label{driver-api/iio/triggers::doc}\label{driver-api/iio/triggers:triggers}\begin{itemize}
\item {} 
struct {\hyperref[driver\string-api/iio/triggers:c.iio_trigger]{\emph{\code{iio\_trigger}}}} — industrial I/O trigger device

\item {} 
{\hyperref[driver\string-api/iio/triggers:c.devm_iio_trigger_alloc]{\emph{\code{devm\_iio\_trigger\_alloc()}}}} — Resource-managed iio\_trigger\_alloc

\item {} 
{\hyperref[driver\string-api/iio/triggers:c.devm_iio_trigger_free]{\emph{\code{devm\_iio\_trigger\_free()}}}} — Resource-managed iio\_trigger\_free

\item {} 
\code{devm\_iio\_trigger\_register()} — Resource-managed iio\_trigger\_register

\item {} 
{\hyperref[driver\string-api/iio/triggers:c.devm_iio_trigger_unregister]{\emph{\code{devm\_iio\_trigger\_unregister()}}}} — Resource-managed
iio\_trigger\_unregister

\item {} 
{\hyperref[driver\string-api/iio/triggers:c.iio_trigger_validate_own_device]{\emph{\code{iio\_trigger\_validate\_own\_device()}}}} — Check if a trigger and IIO
device belong to the same device

\end{itemize}

In many situations it is useful for a driver to be able to capture data based
on some external event (trigger) as opposed to periodically polling for data.
An IIO trigger can be provided by a device driver that also has an IIO device
based on hardware generated events (e.g. data ready or threshold exceeded) or
provided by a separate driver from an independent interrupt source (e.g. GPIO
line connected to some external system, timer interrupt or user space writing
a specific file in sysfs). A trigger may initiate data capture for a number of
sensors and also it may be completely unrelated to the sensor itself.


\subsection{IIO trigger sysfs interface}
\label{driver-api/iio/triggers:iio-trigger-sysfs-interface}
There are two locations in sysfs related to triggers:
\begin{itemize}
\item {} 
\code{/sys/bus/iio/devices/trigger\emph{Y}/*}, this file is created once an
IIO trigger is registered with the IIO core and corresponds to trigger
with index Y.
Because triggers can be very different depending on type there are few
standard attributes that we can describe here:
\begin{itemize}
\item {} 
\code{name}, trigger name that can be later used for association with a
device.

\item {} 
\code{sampling\_frequency}, some timer based triggers use this attribute to
specify the frequency for trigger calls.

\end{itemize}

\item {} 
\code{/sys/bus/iio/devices/iio:device\emph{X}/trigger/*}, this directory is
created once the device supports a triggered buffer. We can associate a
trigger with our  device by writing the trigger's name in the
\code{current\_trigger} file.

\end{itemize}


\subsection{IIO trigger setup}
\label{driver-api/iio/triggers:iio-trigger-setup}
Let's see a simple example of how to setup a trigger to be used by a driver:

\begin{Verbatim}[commandchars=\\\{\}]
struct iio\PYGZus{}trigger\PYGZus{}ops trigger\PYGZus{}ops = \PYGZob{}
    .set\PYGZus{}trigger\PYGZus{}state = sample\PYGZus{}trigger\PYGZus{}state,
    .validate\PYGZus{}device = sample\PYGZus{}validate\PYGZus{}device,
\PYGZcb{}

struct iio\PYGZus{}trigger *trig;

/* first, allocate memory for our trigger */
trig = iio\PYGZus{}trigger\PYGZus{}alloc(dev, \PYGZdq{}trig\PYGZhy{}\PYGZpc{}s\PYGZhy{}\PYGZpc{}d\PYGZdq{}, name, idx);

/* setup trigger operations field */
trig\PYGZhy{}\PYGZgt{}ops = \PYGZam{}trigger\PYGZus{}ops;

/* now register the trigger with the IIO core */
iio\PYGZus{}trigger\PYGZus{}register(trig);
\end{Verbatim}


\subsection{IIO trigger ops}
\label{driver-api/iio/triggers:iio-trigger-ops}\begin{itemize}
\item {} 
struct {\hyperref[driver\string-api/iio/triggers:c.iio_trigger_ops]{\emph{\code{iio\_trigger\_ops}}}} — operations structure for an iio\_trigger.

\end{itemize}

Notice that a trigger has a set of operations attached:
\begin{itemize}
\item {} 
\code{set\_trigger\_state}, switch the trigger on/off on demand.

\item {} 
\code{validate\_device}, function to validate the device when the current
trigger gets changed.

\end{itemize}


\subsection{More details}
\label{driver-api/iio/triggers:more-details}\index{iio\_trigger\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/triggers:c.iio_trigger_ops}\pysigline{struct \bfcode{iio\_trigger\_ops}}
operations structure for an iio\_trigger.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct iio\PYGZus{}trigger\PYGZus{}ops \PYGZob{}
  int (*set\PYGZus{}trigger\PYGZus{}state)(struct iio\PYGZus{}trigger *trig, bool state);
  int (*try\PYGZus{}reenable)(struct iio\PYGZus{}trigger *trig);
  int (*validate\PYGZus{}device)(struct iio\PYGZus{}trigger *trig, struct iio\PYGZus{}dev *indio\PYGZus{}dev);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{set\_trigger\_state}}] \leavevmode
switch on/off the trigger on demand

\item[{\code{try\_reenable}}] \leavevmode
function to reenable the trigger when the
use count is zero (may be NULL)

\item[{\code{validate\_device}}] \leavevmode
function to validate the device when the
current trigger gets changed.

\end{description}

\textbf{Description}

This is typically static const within a driver and shared by
instances of a given device.
\index{iio\_trigger (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/triggers:c.iio_trigger}\pysigline{struct \bfcode{iio\_trigger}}
industrial I/O trigger device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct iio\PYGZus{}trigger \PYGZob{}
  const struct iio\PYGZus{}trigger\PYGZus{}ops    *ops;
  struct module                   *owner;
  int id;
  const char                      *name;
  struct device                   dev;
  struct list\PYGZus{}head                list;
  struct list\PYGZus{}head                alloc\PYGZus{}list;
  atomic\PYGZus{}t use\PYGZus{}count;
  struct irq\PYGZus{}chip                 subirq\PYGZus{}chip;
  int subirq\PYGZus{}base;
  struct iio\PYGZus{}subirq subirqs[CONFIG\PYGZus{}IIO\PYGZus{}CONSUMERS\PYGZus{}PER\PYGZus{}TRIGGER];
  unsigned long pool[BITS\PYGZus{}TO\PYGZus{}LONGS(CONFIG\PYGZus{}IIO\PYGZus{}CONSUMERS\PYGZus{}PER\PYGZus{}TRIGGER)];
  struct mutex                    pool\PYGZus{}lock;
  bool attached\PYGZus{}own\PYGZus{}device;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{ops}}] \leavevmode
{[}DRIVER{]} operations structure

\item[{\code{owner}}] \leavevmode
{[}INTERN{]} owner of this driver module

\item[{\code{id}}] \leavevmode
{[}INTERN{]} unique id number

\item[{\code{name}}] \leavevmode
{[}DRIVER{]} unique name

\item[{\code{dev}}] \leavevmode
{[}DRIVER{]} associated device (if relevant)

\item[{\code{list}}] \leavevmode
{[}INTERN{]} used in maintenance of global trigger list

\item[{\code{alloc\_list}}] \leavevmode
{[}DRIVER{]} used for driver specific trigger list

\item[{\code{use\_count}}] \leavevmode
{[}INTERN{]} use count for the trigger.

\item[{\code{subirq\_chip}}] \leavevmode
{[}INTERN{]} associate `virtual' irq chip.

\item[{\code{subirq\_base}}] \leavevmode
{[}INTERN{]} base number for irqs provided by trigger.

\item[{\code{subirqs}}] \leavevmode
{[}INTERN{]} information about the `child' irqs.

\item[{\code{pool}}] \leavevmode
{[}INTERN{]} bitmap of irqs currently in use.

\item[{\code{pool\_lock}}] \leavevmode
{[}INTERN{]} protection of the irq pool.

\item[{\code{attached\_own\_device}}] \leavevmode
{[}INTERN{]} if we are using our own device as trigger,
i.e. if we registered a poll function to the same
device as the one providing the trigger.

\end{description}
\index{iio\_trigger\_set\_drvdata (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/triggers:c.iio_trigger_set_drvdata}\pysiglinewithargsret{void \bfcode{iio\_trigger\_set\_drvdata}}{struct {\hyperref[driver\string-api/iio/triggers:c.iio_trigger]{\emph{iio\_trigger}}} *\emph{ trig}, void *\emph{ data}}{}
Set trigger driver data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_trigger * trig}}] \leavevmode
IIO trigger structure

\item[{\code{void * data}}] \leavevmode
Driver specific data

\end{description}

\textbf{Description}

Allows to attach an arbitrary pointer to an IIO trigger, which can later be
retrieved by {\hyperref[driver\string-api/iio/triggers:c.iio_trigger_get_drvdata]{\emph{\code{iio\_trigger\_get\_drvdata()}}}}.
\index{iio\_trigger\_get\_drvdata (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/triggers:c.iio_trigger_get_drvdata}\pysiglinewithargsret{void * \bfcode{iio\_trigger\_get\_drvdata}}{struct {\hyperref[driver\string-api/iio/triggers:c.iio_trigger]{\emph{iio\_trigger}}} *\emph{ trig}}{}
Get trigger driver data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_trigger * trig}}] \leavevmode
IIO trigger structure

\end{description}

\textbf{Description}

Returns the data previously set with {\hyperref[driver\string-api/iio/triggers:c.iio_trigger_set_drvdata]{\emph{\code{iio\_trigger\_set\_drvdata()}}}}
\index{iio\_trigger\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/triggers:c.iio_trigger_register}\pysiglinewithargsret{\bfcode{iio\_trigger\_register}}{\emph{trig\_info}}{}
register a trigger with the IIO core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{trig\_info}}] \leavevmode
trigger to be registered

\end{description}
\index{iio\_trigger\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/triggers:c.iio_trigger_unregister}\pysiglinewithargsret{void \bfcode{iio\_trigger\_unregister}}{struct {\hyperref[driver\string-api/iio/triggers:c.iio_trigger]{\emph{iio\_trigger}}} *\emph{ trig\_info}}{}
unregister a trigger from the core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_trigger * trig\_info}}] \leavevmode
trigger to be unregistered

\end{description}
\index{iio\_trigger\_set\_immutable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/triggers:c.iio_trigger_set_immutable}\pysiglinewithargsret{int \bfcode{iio\_trigger\_set\_immutable}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}, struct {\hyperref[driver\string-api/iio/triggers:c.iio_trigger]{\emph{iio\_trigger}}} *\emph{ trig}}{}
set an immutable trigger on destination

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
IIO device structure containing the device

\item[{\code{struct iio\_trigger * trig}}] \leavevmode
trigger to assign to device

\end{description}
\index{iio\_trigger\_poll (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/triggers:c.iio_trigger_poll}\pysiglinewithargsret{void \bfcode{iio\_trigger\_poll}}{struct {\hyperref[driver\string-api/iio/triggers:c.iio_trigger]{\emph{iio\_trigger}}} *\emph{ trig}}{}
called on a trigger occurring

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_trigger * trig}}] \leavevmode
trigger which occurred

\end{description}

\textbf{Description}

Typically called in relevant hardware interrupt handler.
\index{iio\_trigger\_using\_own (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/triggers:c.iio_trigger_using_own}\pysiglinewithargsret{bool \bfcode{iio\_trigger\_using\_own}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}}{}
tells us if we use our own HW trigger ourselves

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
device to check

\end{description}
\index{devm\_iio\_trigger\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/triggers:c.devm_iio_trigger_alloc}\pysiglinewithargsret{struct {\hyperref[driver\string-api/iio/triggers:c.iio_trigger]{\emph{iio\_trigger}}} * \bfcode{devm\_iio\_trigger\_alloc}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ fmt}, ...}{}
Resource-managed \code{iio\_trigger\_alloc()}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to allocate iio\_trigger for

\item[{\code{const char * fmt}}] \leavevmode
trigger name format. If it includes format
specifiers, the additional arguments following
format are formatted and inserted in the resulting
string replacing their respective specifiers.

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

Managed iio\_trigger\_alloc.  iio\_trigger allocated with this function is
automatically freed on driver detach.

If an iio\_trigger allocated with this function needs to be freed separately,
{\hyperref[driver\string-api/iio/triggers:c.devm_iio_trigger_free]{\emph{\code{devm\_iio\_trigger\_free()}}}} must be used.

\textbf{Return}

Pointer to allocated iio\_trigger on success, NULL on failure.
\index{devm\_iio\_trigger\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/triggers:c.devm_iio_trigger_free}\pysiglinewithargsret{void \bfcode{devm\_iio\_trigger\_free}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct {\hyperref[driver\string-api/iio/triggers:c.iio_trigger]{\emph{iio\_trigger}}} *\emph{ iio\_trig}}{}
Resource-managed \code{iio\_trigger\_free()}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device this iio\_dev belongs to

\item[{\code{struct iio\_trigger * iio\_trig}}] \leavevmode
the iio\_trigger associated with the device

\end{description}

\textbf{Description}

Free iio\_trigger allocated with {\hyperref[driver\string-api/iio/triggers:c.devm_iio_trigger_alloc]{\emph{\code{devm\_iio\_trigger\_alloc()}}}}.
\index{\_\_devm\_iio\_trigger\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/triggers:c.__devm_iio_trigger_register}\pysiglinewithargsret{int \bfcode{\_\_devm\_iio\_trigger\_register}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct {\hyperref[driver\string-api/iio/triggers:c.iio_trigger]{\emph{iio\_trigger}}} *\emph{ trig\_info}, struct module *\emph{ this\_mod}}{}
Resource-managed {\hyperref[driver\string-api/iio/triggers:c.iio_trigger_register]{\emph{\code{iio\_trigger\_register()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device this trigger was allocated for

\item[{\code{struct iio\_trigger * trig\_info}}] \leavevmode
trigger to register

\item[{\code{struct module * this\_mod}}] \leavevmode
module registering the trigger

\end{description}

\textbf{Description}

Managed {\hyperref[driver\string-api/iio/triggers:c.iio_trigger_register]{\emph{\code{iio\_trigger\_register()}}}}.  The IIO trigger registered with this
function is automatically unregistered on driver detach. This function
calls {\hyperref[driver\string-api/iio/triggers:c.iio_trigger_register]{\emph{\code{iio\_trigger\_register()}}}} internally. Refer to that function for more
information.

If an iio\_trigger registered with this function needs to be unregistered
separately, {\hyperref[driver\string-api/iio/triggers:c.devm_iio_trigger_unregister]{\emph{\code{devm\_iio\_trigger\_unregister()}}}} must be used.

\textbf{Return}

0 on success, negative error number on failure.
\index{devm\_iio\_trigger\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/triggers:c.devm_iio_trigger_unregister}\pysiglinewithargsret{void \bfcode{devm\_iio\_trigger\_unregister}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct {\hyperref[driver\string-api/iio/triggers:c.iio_trigger]{\emph{iio\_trigger}}} *\emph{ trig\_info}}{}
Resource-managed {\hyperref[driver\string-api/iio/triggers:c.iio_trigger_unregister]{\emph{\code{iio\_trigger\_unregister()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device this iio\_trigger belongs to

\item[{\code{struct iio\_trigger * trig\_info}}] \leavevmode
the trigger associated with the device

\end{description}

\textbf{Description}

Unregister trigger registered with \code{devm\_iio\_trigger\_register()}.
\index{iio\_trigger\_validate\_own\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/triggers:c.iio_trigger_validate_own_device}\pysiglinewithargsret{int \bfcode{iio\_trigger\_validate\_own\_device}}{struct {\hyperref[driver\string-api/iio/triggers:c.iio_trigger]{\emph{iio\_trigger}}} *\emph{ trig}, struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}}{}
Check if a trigger and IIO device belong to the same device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_trigger * trig}}] \leavevmode
The IIO trigger to check

\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
the IIO device to check

\end{description}

\textbf{Description}

This function can be used as the validate\_device callback for triggers that
can only be attached to their own device.

\textbf{Return}

0 if both the trigger and the IIO device belong to the same
device, -EINVAL otherwise.


\section{Triggered Buffers}
\label{driver-api/iio/triggered-buffers:triggered-buffers}\label{driver-api/iio/triggered-buffers::doc}
Now that we know what buffers and triggers are let's see how they work together.


\subsection{IIO triggered buffer setup}
\label{driver-api/iio/triggered-buffers:iio-triggered-buffer-setup}\begin{itemize}
\item {} 
{\hyperref[driver\string-api/iio/triggered\string-buffers:c.iio_triggered_buffer_setup]{\emph{\code{iio\_triggered\_buffer\_setup()}}}} — Setup triggered buffer and pollfunc

\item {} 
{\hyperref[driver\string-api/iio/triggered\string-buffers:c.iio_triggered_buffer_cleanup]{\emph{\code{iio\_triggered\_buffer\_cleanup()}}}} — Free resources allocated by
{\hyperref[driver\string-api/iio/triggered\string-buffers:c.iio_triggered_buffer_setup]{\emph{\code{iio\_triggered\_buffer\_setup()}}}}

\item {} 
struct {\hyperref[driver\string-api/iio/core:c.iio_buffer_setup_ops]{\emph{\code{iio\_buffer\_setup\_ops}}}} — buffer setup related callbacks

\end{itemize}

A typical triggered buffer setup looks like this:

\begin{Verbatim}[commandchars=\\\{\}]
const struct iio\PYGZus{}buffer\PYGZus{}setup\PYGZus{}ops sensor\PYGZus{}buffer\PYGZus{}setup\PYGZus{}ops = \PYGZob{}
  .preenable    = sensor\PYGZus{}buffer\PYGZus{}preenable,
  .postenable   = sensor\PYGZus{}buffer\PYGZus{}postenable,
  .postdisable  = sensor\PYGZus{}buffer\PYGZus{}postdisable,
  .predisable   = sensor\PYGZus{}buffer\PYGZus{}predisable,
\PYGZcb{};

irqreturn\PYGZus{}t sensor\PYGZus{}iio\PYGZus{}pollfunc(int irq, void *p)
\PYGZob{}
    pf\PYGZhy{}\PYGZgt{}timestamp = iio\PYGZus{}get\PYGZus{}time\PYGZus{}ns((struct indio\PYGZus{}dev *)p);
    return IRQ\PYGZus{}WAKE\PYGZus{}THREAD;
\PYGZcb{}

irqreturn\PYGZus{}t sensor\PYGZus{}trigger\PYGZus{}handler(int irq, void *p)
\PYGZob{}
    u16 buf[8];
    int i = 0;

    /* read data for each active channel */
    for\PYGZus{}each\PYGZus{}set\PYGZus{}bit(bit, active\PYGZus{}scan\PYGZus{}mask, masklength)
        buf[i++] = sensor\PYGZus{}get\PYGZus{}data(bit)

    iio\PYGZus{}push\PYGZus{}to\PYGZus{}buffers\PYGZus{}with\PYGZus{}timestamp(indio\PYGZus{}dev, buf, timestamp);

    iio\PYGZus{}trigger\PYGZus{}notify\PYGZus{}done(trigger);
    return IRQ\PYGZus{}HANDLED;
\PYGZcb{}

/* setup triggered buffer, usually in probe function */
iio\PYGZus{}triggered\PYGZus{}buffer\PYGZus{}setup(indio\PYGZus{}dev, sensor\PYGZus{}iio\PYGZus{}polfunc,
                           sensor\PYGZus{}trigger\PYGZus{}handler,
                           sensor\PYGZus{}buffer\PYGZus{}setup\PYGZus{}ops);
\end{Verbatim}

The important things to notice here are:
\begin{itemize}
\item {} 
{\hyperref[driver\string-api/iio/core:c.iio_buffer_setup_ops]{\emph{\code{iio\_buffer\_setup\_ops}}}}, the buffer setup functions to be called at
predefined points in the buffer configuration sequence (e.g. before enable,
after disable). If not specified, the IIO core uses the default
iio\_triggered\_buffer\_setup\_ops.

\item {} 
\textbf{sensor\_iio\_pollfunc}, the function that will be used as top half of poll
function. It should do as little processing as possible, because it runs in
interrupt context. The most common operation is recording of the current
timestamp and for this reason one can use the IIO core defined
\code{iio\_pollfunc\_store\_time()} function.

\item {} 
\textbf{sensor\_trigger\_handler}, the function that will be used as bottom half of
the poll function. This runs in the context of a kernel thread and all the
processing takes place here. It usually reads data from the device and
stores it in the internal buffer together with the timestamp recorded in the
top half.

\end{itemize}


\subsection{More details}
\label{driver-api/iio/triggered-buffers:more-details}\index{iio\_triggered\_buffer\_setup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/triggered-buffers:c.iio_triggered_buffer_setup}\pysiglinewithargsret{int \bfcode{iio\_triggered\_buffer\_setup}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}, irqreturn\_t (*h) (int\emph{ irq}, void\emph{ *p}, irqreturn\_t (*thread) (int\emph{ irq}, void\emph{ *p}, const struct {\hyperref[driver\string-api/iio/core:c.iio_buffer_setup_ops]{\emph{iio\_buffer\_setup\_ops}}} *\emph{ setup\_ops}}{}
Setup triggered buffer and pollfunc

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
IIO device structure

\item[{\code{irqreturn\_t (*)(int irq, void *p) h}}] \leavevmode
Function which will be used as pollfunc top half

\item[{\code{irqreturn\_t (*)(int irq, void *p) thread}}] \leavevmode
Function which will be used as pollfunc bottom half

\item[{\code{const struct iio\_buffer\_setup\_ops * setup\_ops}}] \leavevmode
Buffer setup functions to use for this device.
If NULL the default setup functions for triggered
buffers will be used.

\end{description}

\textbf{Description}

This function combines some common tasks which will normally be performed
when setting up a triggered buffer. It will allocate the buffer and the
pollfunc.

Before calling this function the indio\_dev structure should already be
completely initialized, but not yet registered. In practice this means that
this function should be called right before {\hyperref[driver\string-api/iio/core:c.iio_device_register]{\emph{\code{iio\_device\_register()}}}}.

To free the resources allocated by this function call
{\hyperref[driver\string-api/iio/triggered\string-buffers:c.iio_triggered_buffer_cleanup]{\emph{\code{iio\_triggered\_buffer\_cleanup()}}}}.
\index{iio\_triggered\_buffer\_cleanup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/triggered-buffers:c.iio_triggered_buffer_cleanup}\pysiglinewithargsret{void \bfcode{iio\_triggered\_buffer\_cleanup}}{struct {\hyperref[driver\string-api/iio/core:c.iio_dev]{\emph{iio\_dev}}} *\emph{ indio\_dev}}{}
Free resources allocated by {\hyperref[driver\string-api/iio/triggered\string-buffers:c.iio_triggered_buffer_setup]{\emph{\code{iio\_triggered\_buffer\_setup()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_dev * indio\_dev}}] \leavevmode
IIO device structure

\end{description}


\section{HW consumer}
\label{driver-api/iio/hw-consumer::doc}\label{driver-api/iio/hw-consumer:hw-consumer}
An IIO device can be directly connected to another device in hardware. in this
case the buffers between IIO provider and IIO consumer are handled by hardware.
The Industrial I/O HW consumer offers a way to bond these IIO devices without
software buffer for data. The implementation can be found under
\code{drivers/iio/buffer/hw-consumer.c}
\begin{itemize}
\item {} 
struct \code{iio\_hw\_consumer} — Hardware consumer structure

\item {} 
{\hyperref[driver\string-api/iio/hw\string-consumer:c.iio_hw_consumer_alloc]{\emph{\code{iio\_hw\_consumer\_alloc()}}}} — Allocate IIO hardware consumer

\item {} 
{\hyperref[driver\string-api/iio/hw\string-consumer:c.iio_hw_consumer_free]{\emph{\code{iio\_hw\_consumer\_free()}}}} — Free IIO hardware consumer

\item {} 
{\hyperref[driver\string-api/iio/hw\string-consumer:c.iio_hw_consumer_enable]{\emph{\code{iio\_hw\_consumer\_enable()}}}} — Enable IIO hardware consumer

\item {} 
{\hyperref[driver\string-api/iio/hw\string-consumer:c.iio_hw_consumer_disable]{\emph{\code{iio\_hw\_consumer\_disable()}}}} — Disable IIO hardware consumer

\end{itemize}


\subsection{HW consumer setup}
\label{driver-api/iio/hw-consumer:hw-consumer-setup}
As standard IIO device the implementation is based on IIO provider/consumer.
A typical IIO HW consumer setup looks like this:

\begin{Verbatim}[commandchars=\\\{\}]
static struct iio\PYGZus{}hw\PYGZus{}consumer *hwc;

static const struct iio\PYGZus{}info adc\PYGZus{}info = \PYGZob{}
        .read\PYGZus{}raw = adc\PYGZus{}read\PYGZus{}raw,
\PYGZcb{};

static int adc\PYGZus{}read\PYGZus{}raw(struct iio\PYGZus{}dev *indio\PYGZus{}dev,
                        struct iio\PYGZus{}chan\PYGZus{}spec const *chan, int *val,
                        int *val2, long mask)
\PYGZob{}
        ret = iio\PYGZus{}hw\PYGZus{}consumer\PYGZus{}enable(hwc);

        /* Acquire data */

        ret = iio\PYGZus{}hw\PYGZus{}consumer\PYGZus{}disable(hwc);
\PYGZcb{}

static int adc\PYGZus{}probe(struct platform\PYGZus{}device *pdev)
\PYGZob{}
        hwc = devm\PYGZus{}iio\PYGZus{}hw\PYGZus{}consumer\PYGZus{}alloc(\PYGZam{}iio\PYGZhy{}\PYGZgt{}dev);
\PYGZcb{}
\end{Verbatim}


\subsection{More details}
\label{driver-api/iio/hw-consumer:more-details}\index{iio\_hw\_consumer\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/hw-consumer:c.iio_hw_consumer_alloc}\pysiglinewithargsret{struct iio\_hw\_consumer * \bfcode{iio\_hw\_consumer\_alloc}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
Allocate IIO hardware consumer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Pointer to consumer device.

\end{description}

\textbf{Description}

Returns a valid iio\_hw\_consumer on success or a \code{ERR\_PTR()} on failure.
\index{iio\_hw\_consumer\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/hw-consumer:c.iio_hw_consumer_free}\pysiglinewithargsret{void \bfcode{iio\_hw\_consumer\_free}}{struct iio\_hw\_consumer *\emph{ hwc}}{}
Free IIO hardware consumer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_hw\_consumer * hwc}}] \leavevmode
hw consumer to free.

\end{description}
\index{devm\_iio\_hw\_consumer\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/hw-consumer:c.devm_iio_hw_consumer_alloc}\pysiglinewithargsret{struct iio\_hw\_consumer * \bfcode{devm\_iio\_hw\_consumer\_alloc}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
Resource-managed {\hyperref[driver\string-api/iio/hw\string-consumer:c.iio_hw_consumer_alloc]{\emph{\code{iio\_hw\_consumer\_alloc()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Pointer to consumer device.

\end{description}

\textbf{Description}

Managed iio\_hw\_consumer\_alloc. iio\_hw\_consumer allocated with this function
is automatically freed on driver detach.

If an iio\_hw\_consumer allocated with this function needs to be freed
separately, {\hyperref[driver\string-api/iio/hw\string-consumer:c.devm_iio_hw_consumer_free]{\emph{\code{devm\_iio\_hw\_consumer\_free()}}}} must be used.

returns pointer to allocated iio\_hw\_consumer on success, NULL on failure.
\index{devm\_iio\_hw\_consumer\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/hw-consumer:c.devm_iio_hw_consumer_free}\pysiglinewithargsret{void \bfcode{devm\_iio\_hw\_consumer\_free}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct iio\_hw\_consumer *\emph{ hwc}}{}
Resource-managed {\hyperref[driver\string-api/iio/hw\string-consumer:c.iio_hw_consumer_free]{\emph{\code{iio\_hw\_consumer\_free()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Pointer to consumer device.

\item[{\code{struct iio\_hw\_consumer * hwc}}] \leavevmode
iio\_hw\_consumer to free.

\end{description}

\textbf{Description}

Free iio\_hw\_consumer allocated with {\hyperref[driver\string-api/iio/hw\string-consumer:c.devm_iio_hw_consumer_alloc]{\emph{\code{devm\_iio\_hw\_consumer\_alloc()}}}}.
\index{iio\_hw\_consumer\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/hw-consumer:c.iio_hw_consumer_enable}\pysiglinewithargsret{int \bfcode{iio\_hw\_consumer\_enable}}{struct iio\_hw\_consumer *\emph{ hwc}}{}
Enable IIO hardware consumer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_hw\_consumer * hwc}}] \leavevmode
iio\_hw\_consumer to enable.

\end{description}

\textbf{Description}

Returns 0 on success.
\index{iio\_hw\_consumer\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/iio/hw-consumer:c.iio_hw_consumer_disable}\pysiglinewithargsret{void \bfcode{iio\_hw\_consumer\_disable}}{struct iio\_hw\_consumer *\emph{ hwc}}{}
Disable IIO hardware consumer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iio\_hw\_consumer * hwc}}] \leavevmode
iio\_hw\_consumer to disable.

\end{description}


\chapter{Input Subsystem}
\label{driver-api/input::doc}\label{driver-api/input:input-subsystem}

\section{Input core}
\label{driver-api/input:input-core}\index{input\_value (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_value}\pysigline{struct \bfcode{input\_value}}
input value representation

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct input\PYGZus{}value \PYGZob{}
  \PYGZus{}\PYGZus{}u16 type;
  \PYGZus{}\PYGZus{}u16 code;
  \PYGZus{}\PYGZus{}s32 value;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{type}}] \leavevmode
type of value (EV\_KEY, EV\_ABS, etc)

\item[{\code{code}}] \leavevmode
the value code

\item[{\code{value}}] \leavevmode
the value

\end{description}
\index{input\_dev (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_dev}\pysigline{struct \bfcode{input\_dev}}
represents an input device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct input\PYGZus{}dev \PYGZob{}
  const char *name;
  const char *phys;
  const char *uniq;
  struct input\PYGZus{}id id;
  unsigned long propbit[BITS\PYGZus{}TO\PYGZus{}LONGS(INPUT\PYGZus{}PROP\PYGZus{}CNT)];
  unsigned long evbit[BITS\PYGZus{}TO\PYGZus{}LONGS(EV\PYGZus{}CNT)];
  unsigned long keybit[BITS\PYGZus{}TO\PYGZus{}LONGS(KEY\PYGZus{}CNT)];
  unsigned long relbit[BITS\PYGZus{}TO\PYGZus{}LONGS(REL\PYGZus{}CNT)];
  unsigned long absbit[BITS\PYGZus{}TO\PYGZus{}LONGS(ABS\PYGZus{}CNT)];
  unsigned long mscbit[BITS\PYGZus{}TO\PYGZus{}LONGS(MSC\PYGZus{}CNT)];
  unsigned long ledbit[BITS\PYGZus{}TO\PYGZus{}LONGS(LED\PYGZus{}CNT)];
  unsigned long sndbit[BITS\PYGZus{}TO\PYGZus{}LONGS(SND\PYGZus{}CNT)];
  unsigned long ffbit[BITS\PYGZus{}TO\PYGZus{}LONGS(FF\PYGZus{}CNT)];
  unsigned long swbit[BITS\PYGZus{}TO\PYGZus{}LONGS(SW\PYGZus{}CNT)];
  unsigned int hint\PYGZus{}events\PYGZus{}per\PYGZus{}packet;
  unsigned int keycodemax;
  unsigned int keycodesize;
  void *keycode;
  int (*setkeycode)(struct input\PYGZus{}dev *dev,const struct input\PYGZus{}keymap\PYGZus{}entry *ke, unsigned int *old\PYGZus{}keycode);
  int (*getkeycode)(struct input\PYGZus{}dev *dev, struct input\PYGZus{}keymap\PYGZus{}entry *ke);
  struct ff\PYGZus{}device *ff;
  unsigned int repeat\PYGZus{}key;
  struct timer\PYGZus{}list timer;
  int rep[REP\PYGZus{}CNT];
  struct input\PYGZus{}mt *mt;
  struct input\PYGZus{}absinfo *absinfo;
  unsigned long key[BITS\PYGZus{}TO\PYGZus{}LONGS(KEY\PYGZus{}CNT)];
  unsigned long led[BITS\PYGZus{}TO\PYGZus{}LONGS(LED\PYGZus{}CNT)];
  unsigned long snd[BITS\PYGZus{}TO\PYGZus{}LONGS(SND\PYGZus{}CNT)];
  unsigned long sw[BITS\PYGZus{}TO\PYGZus{}LONGS(SW\PYGZus{}CNT)];
  int (*open)(struct input\PYGZus{}dev *dev);
  void (*close)(struct input\PYGZus{}dev *dev);
  int (*flush)(struct input\PYGZus{}dev *dev, struct file *file);
  int (*event)(struct input\PYGZus{}dev *dev, unsigned int type, unsigned int code, int value);
  struct input\PYGZus{}handle \PYGZus{}\PYGZus{}rcu *grab;
  spinlock\PYGZus{}t event\PYGZus{}lock;
  struct mutex mutex;
  unsigned int users;
  bool going\PYGZus{}away;
  struct device dev;
  struct list\PYGZus{}head        h\PYGZus{}list;
  struct list\PYGZus{}head        node;
  unsigned int num\PYGZus{}vals;
  unsigned int max\PYGZus{}vals;
  struct input\PYGZus{}value *vals;
  bool devres\PYGZus{}managed;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
name of the device

\item[{\code{phys}}] \leavevmode
physical path to the device in the system hierarchy

\item[{\code{uniq}}] \leavevmode
unique identification code for the device (if device has it)

\item[{\code{id}}] \leavevmode
id of the device (struct input\_id)

\item[{\code{propbit}}] \leavevmode
bitmap of device properties and quirks

\item[{\code{evbit}}] \leavevmode
bitmap of types of events supported by the device (EV\_KEY,
EV\_REL, etc.)

\item[{\code{keybit}}] \leavevmode
bitmap of keys/buttons this device has

\item[{\code{relbit}}] \leavevmode
bitmap of relative axes for the device

\item[{\code{absbit}}] \leavevmode
bitmap of absolute axes for the device

\item[{\code{mscbit}}] \leavevmode
bitmap of miscellaneous events supported by the device

\item[{\code{ledbit}}] \leavevmode
bitmap of leds present on the device

\item[{\code{sndbit}}] \leavevmode
bitmap of sound effects supported by the device

\item[{\code{ffbit}}] \leavevmode
bitmap of force feedback effects supported by the device

\item[{\code{swbit}}] \leavevmode
bitmap of switches present on the device

\item[{\code{hint\_events\_per\_packet}}] \leavevmode
average number of events generated by the
device in a packet (between EV\_SYN/SYN\_REPORT events). Used by
event handlers to estimate size of the buffer needed to hold
events.

\item[{\code{keycodemax}}] \leavevmode
size of keycode table

\item[{\code{keycodesize}}] \leavevmode
size of elements in keycode table

\item[{\code{keycode}}] \leavevmode
map of scancodes to keycodes for this device

\item[{\code{setkeycode}}] \leavevmode
optional method to alter current keymap, used to implement
sparse keymaps. If not supplied default mechanism will be used.
The method is being called while holding event\_lock and thus must
not sleep

\item[{\code{getkeycode}}] \leavevmode
optional legacy method to retrieve current keymap.

\item[{\code{ff}}] \leavevmode
force feedback structure associated with the device if device
supports force feedback effects

\item[{\code{repeat\_key}}] \leavevmode
stores key code of the last key pressed; used to implement
software autorepeat

\item[{\code{timer}}] \leavevmode
timer for software autorepeat

\item[{\code{rep}}] \leavevmode
current values for autorepeat parameters (delay, rate)

\item[{\code{mt}}] \leavevmode
pointer to multitouch state

\item[{\code{absinfo}}] \leavevmode
array of \code{struct input\_absinfo} elements holding information
about absolute axes (current value, min, max, flat, fuzz,
resolution)

\item[{\code{key}}] \leavevmode
reflects current state of device's keys/buttons

\item[{\code{led}}] \leavevmode
reflects current state of device's LEDs

\item[{\code{snd}}] \leavevmode
reflects current state of sound effects

\item[{\code{sw}}] \leavevmode
reflects current state of device's switches

\item[{\code{open}}] \leavevmode
this method is called when the very first user calls
{\hyperref[driver\string-api/input:c.input_open_device]{\emph{\code{input\_open\_device()}}}}. The driver must prepare the device
to start generating events (start polling thread,
request an IRQ, submit URB, etc.)

\item[{\code{close}}] \leavevmode
this method is called when the very last user calls
{\hyperref[driver\string-api/input:c.input_close_device]{\emph{\code{input\_close\_device()}}}}.

\item[{\code{flush}}] \leavevmode
purges the device. Most commonly used to get rid of force
feedback effects loaded into the device when disconnecting
from it

\item[{\code{event}}] \leavevmode
event handler for events sent \_to\_ the device, like EV\_LED
or EV\_SND. The device is expected to carry out the requested
action (turn on a LED, play sound, etc.) The call is protected
by \textbf{event\_lock} and must not sleep

\item[{\code{grab}}] \leavevmode
input handle that currently has the device grabbed (via
EVIOCGRAB ioctl). When a handle grabs a device it becomes sole
recipient for all input events coming from the device

\item[{\code{event\_lock}}] \leavevmode
this spinlock is taken when input core receives
and processes a new event for the device (in {\hyperref[driver\string-api/input:c.input_event]{\emph{\code{input\_event()}}}}).
Code that accesses and/or modifies parameters of a device
(such as keymap or absmin, absmax, absfuzz, etc.) after device
has been registered with input core must take this lock.

\item[{\code{mutex}}] \leavevmode
serializes calls to \code{open()}, \code{close()} and \code{flush()} methods

\item[{\code{users}}] \leavevmode
stores number of users (input handlers) that opened this
device. It is used by {\hyperref[driver\string-api/input:c.input_open_device]{\emph{\code{input\_open\_device()}}}} and {\hyperref[driver\string-api/input:c.input_close_device]{\emph{\code{input\_close\_device()}}}}
to make sure that dev-\textgreater{}:c:func:\emph{open()} is only called when the first
user opens device and dev-\textgreater{}:c:func:\emph{close()} is called when the very
last user closes the device

\item[{\code{going\_away}}] \leavevmode
marks devices that are in a middle of unregistering and
causes input\_open\_device*() fail with -ENODEV.

\item[{\code{dev}}] \leavevmode
driver model's view of this device

\item[{\code{h\_list}}] \leavevmode
list of input handles associated with the device. When
accessing the list dev-\textgreater{}mutex must be held

\item[{\code{node}}] \leavevmode
used to place the device onto input\_dev\_list

\item[{\code{num\_vals}}] \leavevmode
number of values queued in the current frame

\item[{\code{max\_vals}}] \leavevmode
maximum number of values queued in a frame

\item[{\code{vals}}] \leavevmode
array of values queued in the current frame

\item[{\code{devres\_managed}}] \leavevmode
indicates that devices is managed with devres framework
and needs not be explicitly unregistered or freed.

\end{description}
\index{input\_handler (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_handler}\pysigline{struct \bfcode{input\_handler}}
implements one of interfaces for input devices

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct input\PYGZus{}handler \PYGZob{}
  void *private;
  void (*event)(struct input\PYGZus{}handle *handle, unsigned int type, unsigned int code, int value);
  void (*events)(struct input\PYGZus{}handle *handle, const struct input\PYGZus{}value *vals, unsigned int count);
  bool (*filter)(struct input\PYGZus{}handle *handle, unsigned int type, unsigned int code, int value);
  bool (*match)(struct input\PYGZus{}handler *handler, struct input\PYGZus{}dev *dev);
  int (*connect)(struct input\PYGZus{}handler *handler, struct input\PYGZus{}dev *dev, const struct input\PYGZus{}device\PYGZus{}id *id);
  void (*disconnect)(struct input\PYGZus{}handle *handle);
  void (*start)(struct input\PYGZus{}handle *handle);
  bool legacy\PYGZus{}minors;
  int minor;
  const char *name;
  const struct input\PYGZus{}device\PYGZus{}id *id\PYGZus{}table;
  struct list\PYGZus{}head        h\PYGZus{}list;
  struct list\PYGZus{}head        node;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{private}}] \leavevmode
driver-specific data

\item[{\code{event}}] \leavevmode
event handler. This method is being called by input core with
interrupts disabled and dev-\textgreater{}event\_lock spinlock held and so
it may not sleep

\item[{\code{events}}] \leavevmode
event sequence handler. This method is being called by
input core with interrupts disabled and dev-\textgreater{}event\_lock
spinlock held and so it may not sleep

\item[{\code{filter}}] \leavevmode
similar to \textbf{event}; separates normal event handlers from
``filters''.

\item[{\code{match}}] \leavevmode
called after comparing device's id with handler's id\_table
to perform fine-grained matching between device and handler

\item[{\code{connect}}] \leavevmode
called when attaching a handler to an input device

\item[{\code{disconnect}}] \leavevmode
disconnects a handler from input device

\item[{\code{start}}] \leavevmode
starts handler for given handle. This function is called by
input core right after \code{connect()} method and also when a process
that ``grabbed'' a device releases it

\item[{\code{legacy\_minors}}] \leavevmode
set to \code{true} by drivers using legacy minor ranges

\item[{\code{minor}}] \leavevmode
beginning of range of 32 legacy minors for devices this driver
can provide

\item[{\code{name}}] \leavevmode
name of the handler, to be shown in /proc/bus/input/handlers

\item[{\code{id\_table}}] \leavevmode
pointer to a table of input\_device\_ids this driver can
handle

\item[{\code{h\_list}}] \leavevmode
list of input handles associated with the handler

\item[{\code{node}}] \leavevmode
for placing the driver onto input\_handler\_list

\end{description}

\textbf{Description}

Input handlers attach to input devices and create input handles. There
are likely several handlers attached to any given input device at the
same time. All of them will get their copy of input event generated by
the device.

The very same structure is used to implement input filters. Input core
allows filters to run first and will not pass event to regular handlers
if any of the filters indicate that the event should be filtered (by
returning \code{true} from their \code{filter()} method).

Note that input core serializes calls to \code{connect()} and \code{disconnect()}
methods.
\index{input\_handle (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_handle}\pysigline{struct \bfcode{input\_handle}}
links input device with an input handler

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct input\PYGZus{}handle \PYGZob{}
  void *private;
  int open;
  const char *name;
  struct input\PYGZus{}dev *dev;
  struct input\PYGZus{}handler *handler;
  struct list\PYGZus{}head        d\PYGZus{}node;
  struct list\PYGZus{}head        h\PYGZus{}node;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{private}}] \leavevmode
handler-specific data

\item[{\code{open}}] \leavevmode
counter showing whether the handle is `open', i.e. should deliver
events from its device

\item[{\code{name}}] \leavevmode
name given to the handle by handler that created it

\item[{\code{dev}}] \leavevmode
input device the handle is attached to

\item[{\code{handler}}] \leavevmode
handler that works with the device through this handle

\item[{\code{d\_node}}] \leavevmode
used to put the handle on device's list of attached handles

\item[{\code{h\_node}}] \leavevmode
used to put the handle on handler's list of handles from which
it gets events

\end{description}
\index{input\_set\_events\_per\_packet (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_set_events_per_packet}\pysiglinewithargsret{void \bfcode{input\_set\_events\_per\_packet}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, int\emph{ n\_events}}{}
tell handlers about the driver event rate

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
the input device used by the driver

\item[{\code{int n\_events}}] \leavevmode
the average number of events between calls to \code{input\_sync()}

\end{description}

\textbf{Description}

If the event rate sent from a device is unusually large, use this
function to set the expected event rate. This will allow handlers
to set up an appropriate buffer size for the event stream, in order
to minimize information loss.
\index{ff\_device (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.ff_device}\pysigline{struct \bfcode{ff\_device}}
force-feedback part of an input device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ff\PYGZus{}device \PYGZob{}
  int (*upload)(struct input\PYGZus{}dev *dev, struct ff\PYGZus{}effect *effect, struct ff\PYGZus{}effect *old);
  int (*erase)(struct input\PYGZus{}dev *dev, int effect\PYGZus{}id);
  int (*playback)(struct input\PYGZus{}dev *dev, int effect\PYGZus{}id, int value);
  void (*set\PYGZus{}gain)(struct input\PYGZus{}dev *dev, u16 gain);
  void (*set\PYGZus{}autocenter)(struct input\PYGZus{}dev *dev, u16 magnitude);
  void (*destroy)(struct ff\PYGZus{}device *);
  void *private;
  unsigned long ffbit[BITS\PYGZus{}TO\PYGZus{}LONGS(FF\PYGZus{}CNT)];
  struct mutex mutex;
  int max\PYGZus{}effects;
  struct ff\PYGZus{}effect *effects;
  struct file *effect\PYGZus{}owners[];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{upload}}] \leavevmode
Called to upload an new effect into device

\item[{\code{erase}}] \leavevmode
Called to erase an effect from device

\item[{\code{playback}}] \leavevmode
Called to request device to start playing specified effect

\item[{\code{set\_gain}}] \leavevmode
Called to set specified gain

\item[{\code{set\_autocenter}}] \leavevmode
Called to auto-center device

\item[{\code{destroy}}] \leavevmode
called by input core when parent input device is being
destroyed

\item[{\code{private}}] \leavevmode
driver-specific data, will be freed automatically

\item[{\code{ffbit}}] \leavevmode
bitmap of force feedback capabilities truly supported by
device (not emulated like ones in input\_dev-\textgreater{}ffbit)

\item[{\code{mutex}}] \leavevmode
mutex for serializing access to the device

\item[{\code{max\_effects}}] \leavevmode
maximum number of effects supported by device

\item[{\code{effects}}] \leavevmode
pointer to an array of effects currently loaded into device

\item[{\code{effect\_owners}}] \leavevmode
array of effect owners; when file handle owning
an effect gets closed the effect is automatically erased

\end{description}

\textbf{Description}

Every force-feedback device must implement \code{upload()} and \code{playback()}
methods; \code{erase()} is optional. \code{set\_gain()} and \code{set\_autocenter()} need
only be implemented if driver sets up FF\_GAIN and FF\_AUTOCENTER
bits.

Note that \code{playback()}, \code{set\_gain()} and \code{set\_autocenter()} are called with
dev-\textgreater{}event\_lock spinlock held and interrupts off and thus may not
sleep.
\index{input\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_event}\pysiglinewithargsret{void \bfcode{input\_event}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, unsigned int\emph{ type}, unsigned int\emph{ code}, int\emph{ value}}{}
report new input event

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
device that generated the event

\item[{\code{unsigned int type}}] \leavevmode
type of the event

\item[{\code{unsigned int code}}] \leavevmode
event code

\item[{\code{int value}}] \leavevmode
value of the event

\end{description}

\textbf{Description}

This function should be used by drivers implementing various input
devices to report input events. See also {\hyperref[driver\string-api/input:c.input_inject_event]{\emph{\code{input\_inject\_event()}}}}.

\textbf{NOTE}

{\hyperref[driver\string-api/input:c.input_event]{\emph{\code{input\_event()}}}} may be safely used right after input device was
allocated with {\hyperref[driver\string-api/input:c.input_allocate_device]{\emph{\code{input\_allocate\_device()}}}}, even before it is registered
with {\hyperref[driver\string-api/input:c.input_register_device]{\emph{\code{input\_register\_device()}}}}, but the event will not reach any of the
input handlers. Such early invocation of {\hyperref[driver\string-api/input:c.input_event]{\emph{\code{input\_event()}}}} may be used
to `seed' initial state of a switch or initial position of absolute
axis, etc.
\index{input\_inject\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_inject_event}\pysiglinewithargsret{void \bfcode{input\_inject\_event}}{struct {\hyperref[driver\string-api/input:c.input_handle]{\emph{input\_handle}}} *\emph{ handle}, unsigned int\emph{ type}, unsigned int\emph{ code}, int\emph{ value}}{}
send input event from input handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_handle * handle}}] \leavevmode
input handle to send event through

\item[{\code{unsigned int type}}] \leavevmode
type of the event

\item[{\code{unsigned int code}}] \leavevmode
event code

\item[{\code{int value}}] \leavevmode
value of the event

\end{description}

\textbf{Description}

Similar to {\hyperref[driver\string-api/input:c.input_event]{\emph{\code{input\_event()}}}} but will ignore event if device is
``grabbed'' and handle injecting event is not the one that owns
the device.
\index{input\_alloc\_absinfo (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_alloc_absinfo}\pysiglinewithargsret{void \bfcode{input\_alloc\_absinfo}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}}{}
allocates array of input\_absinfo structs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
the input device emitting absolute events

\end{description}

\textbf{Description}

If the absinfo struct the caller asked for is already allocated, this
functions will not do anything.
\index{input\_grab\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_grab_device}\pysiglinewithargsret{int \bfcode{input\_grab\_device}}{struct {\hyperref[driver\string-api/input:c.input_handle]{\emph{input\_handle}}} *\emph{ handle}}{}
grabs device for exclusive use

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_handle * handle}}] \leavevmode
input handle that wants to own the device

\end{description}

\textbf{Description}

When a device is grabbed by an input handle all events generated by
the device are delivered only to this handle. Also events injected
by other input handles are ignored while device is grabbed.
\index{input\_release\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_release_device}\pysiglinewithargsret{void \bfcode{input\_release\_device}}{struct {\hyperref[driver\string-api/input:c.input_handle]{\emph{input\_handle}}} *\emph{ handle}}{}
release previously grabbed device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_handle * handle}}] \leavevmode
input handle that owns the device

\end{description}

\textbf{Description}

Releases previously grabbed device so that other input handles can
start receiving input events. Upon release all handlers attached
to the device have their \code{start()} method called so they have a change
to synchronize device state with the rest of the system.
\index{input\_open\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_open_device}\pysiglinewithargsret{int \bfcode{input\_open\_device}}{struct {\hyperref[driver\string-api/input:c.input_handle]{\emph{input\_handle}}} *\emph{ handle}}{}
open input device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_handle * handle}}] \leavevmode
handle through which device is being accessed

\end{description}

\textbf{Description}

This function should be called by input handlers when they
want to start receive events from given input device.
\index{input\_close\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_close_device}\pysiglinewithargsret{void \bfcode{input\_close\_device}}{struct {\hyperref[driver\string-api/input:c.input_handle]{\emph{input\_handle}}} *\emph{ handle}}{}
close input device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_handle * handle}}] \leavevmode
handle through which device is being accessed

\end{description}

\textbf{Description}

This function should be called by input handlers when they
want to stop receive events from given input device.
\index{input\_scancode\_to\_scalar (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_scancode_to_scalar}\pysiglinewithargsret{int \bfcode{input\_scancode\_to\_scalar}}{const struct input\_keymap\_entry *\emph{ ke}, unsigned int *\emph{ scancode}}{}
converts scancode in \code{struct input\_keymap\_entry}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct input\_keymap\_entry * ke}}] \leavevmode
keymap entry containing scancode to be converted.

\item[{\code{unsigned int * scancode}}] \leavevmode
pointer to the location where converted scancode should
be stored.

\end{description}

\textbf{Description}

This function is used to convert scancode stored in \code{struct keymap\_entry}
into scalar form understood by legacy keymap handling methods. These
methods expect scancodes to be represented as `unsigned int'.
\index{input\_get\_keycode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_get_keycode}\pysiglinewithargsret{int \bfcode{input\_get\_keycode}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, struct input\_keymap\_entry *\emph{ ke}}{}
retrieve keycode currently mapped to a given scancode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device which keymap is being queried

\item[{\code{struct input\_keymap\_entry * ke}}] \leavevmode
keymap entry

\end{description}

\textbf{Description}

This function should be called by anyone interested in retrieving current
keymap. Presently evdev handlers use it.
\index{input\_set\_keycode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_set_keycode}\pysiglinewithargsret{int \bfcode{input\_set\_keycode}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, const struct input\_keymap\_entry *\emph{ ke}}{}
attribute a keycode to a given scancode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device which keymap is being updated

\item[{\code{const struct input\_keymap\_entry * ke}}] \leavevmode
new keymap entry

\end{description}

\textbf{Description}

This function should be called by anyone needing to update current
keymap. Presently keyboard and evdev handlers use it.
\index{input\_reset\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_reset_device}\pysiglinewithargsret{void \bfcode{input\_reset\_device}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}}{}
reset/restore the state of input device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device whose state needs to be reset

\end{description}

\textbf{Description}

This function tries to reset the state of an opened input device and
bring internal state and state if the hardware in sync with each other.
We mark all keys as released, restore LED state, repeat rate, etc.
\index{input\_allocate\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_allocate_device}\pysiglinewithargsret{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} * \bfcode{input\_allocate\_device}}{void}{}
allocate memory for new input device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Returns prepared struct input\_dev or \code{NULL}.

\textbf{NOTE}

Use {\hyperref[driver\string-api/input:c.input_free_device]{\emph{\code{input\_free\_device()}}}} to free devices that have not been
registered; {\hyperref[driver\string-api/input:c.input_unregister_device]{\emph{\code{input\_unregister\_device()}}}} should be used for already
registered devices.
\index{devm\_input\_allocate\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.devm_input_allocate_device}\pysiglinewithargsret{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} * \bfcode{devm\_input\_allocate\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
allocate managed input device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device owning the input device being created

\end{description}

\textbf{Description}

Returns prepared struct input\_dev or \code{NULL}.

Managed input devices do not need to be explicitly unregistered or
freed as it will be done automatically when owner device unbinds from
its driver (or binding fails). Once managed input device is allocated,
it is ready to be set up and registered in the same fashion as regular
input device. There are no special devm\_input\_device\_{[}un{]}:c:func:\emph{register()}
variants, regular ones work with both managed and unmanaged devices,
should you need them. In most cases however, managed input device need
not be explicitly unregistered or freed.

\textbf{NOTE}

the owner device is set up as parent of input device and users
should not override it.
\index{input\_free\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_free_device}\pysiglinewithargsret{void \bfcode{input\_free\_device}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}}{}
free memory occupied by input\_dev structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device to free

\end{description}

\textbf{Description}

This function should only be used if {\hyperref[driver\string-api/input:c.input_register_device]{\emph{\code{input\_register\_device()}}}}
was not called yet or if it failed. Once device was registered
use {\hyperref[driver\string-api/input:c.input_unregister_device]{\emph{\code{input\_unregister\_device()}}}} and memory will be freed once last
reference to the device is dropped.

Device should be allocated by {\hyperref[driver\string-api/input:c.input_allocate_device]{\emph{\code{input\_allocate\_device()}}}}.

\textbf{NOTE}

If there are references to the input device then memory
will not be freed until last reference is dropped.
\index{input\_set\_capability (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_set_capability}\pysiglinewithargsret{void \bfcode{input\_set\_capability}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, unsigned int\emph{ type}, unsigned int\emph{ code}}{}
mark device as capable of a certain event

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
device that is capable of emitting or accepting event

\item[{\code{unsigned int type}}] \leavevmode
type of the event (EV\_KEY, EV\_REL, etc...)

\item[{\code{unsigned int code}}] \leavevmode
event code

\end{description}

\textbf{Description}

In addition to setting up corresponding bit in appropriate capability
bitmap the function also adjusts dev-\textgreater{}evbit.
\index{input\_enable\_softrepeat (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_enable_softrepeat}\pysiglinewithargsret{void \bfcode{input\_enable\_softrepeat}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, int\emph{ delay}, int\emph{ period}}{}
enable software autorepeat

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device

\item[{\code{int delay}}] \leavevmode
repeat delay

\item[{\code{int period}}] \leavevmode
repeat period

\end{description}

\textbf{Description}

Enable software autorepeat on the input device.
\index{input\_register\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_register_device}\pysiglinewithargsret{int \bfcode{input\_register\_device}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}}{}
register device with input core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
device to be registered

\end{description}

\textbf{Description}

This function registers device with input core. The device must be
allocated with {\hyperref[driver\string-api/input:c.input_allocate_device]{\emph{\code{input\_allocate\_device()}}}} and all it's capabilities
set up before registering.
If function fails the device must be freed with {\hyperref[driver\string-api/input:c.input_free_device]{\emph{\code{input\_free\_device()}}}}.
Once device has been successfully registered it can be unregistered
with {\hyperref[driver\string-api/input:c.input_unregister_device]{\emph{\code{input\_unregister\_device()}}}}; {\hyperref[driver\string-api/input:c.input_free_device]{\emph{\code{input\_free\_device()}}}} should not be
called in this case.

Note that this function is also used to register managed input devices
(ones allocated with {\hyperref[driver\string-api/input:c.devm_input_allocate_device]{\emph{\code{devm\_input\_allocate\_device()}}}}). Such managed input
devices need not be explicitly unregistered or freed, their tear down
is controlled by the devres infrastructure. It is also worth noting
that tear down of managed input devices is internally a 2-step process:
registered managed input device is first unregistered, but stays in
memory and can still handle {\hyperref[driver\string-api/input:c.input_event]{\emph{\code{input\_event()}}}} calls (although events will
not be delivered anywhere). The freeing of managed input device will
happen later, when devres stack is unwound to the point where device
allocation was made.
\index{input\_unregister\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_unregister_device}\pysiglinewithargsret{void \bfcode{input\_unregister\_device}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}}{}
unregister previously registered device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
device to be unregistered

\end{description}

\textbf{Description}

This function unregisters an input device. Once device is unregistered
the caller should not try to access it as it may get freed at any moment.
\index{input\_register\_handler (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_register_handler}\pysiglinewithargsret{int \bfcode{input\_register\_handler}}{struct {\hyperref[driver\string-api/input:c.input_handler]{\emph{input\_handler}}} *\emph{ handler}}{}
register a new input handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_handler * handler}}] \leavevmode
handler to be registered

\end{description}

\textbf{Description}

This function registers a new input handler (interface) for input
devices in the system and attaches it to all input devices that
are compatible with the handler.
\index{input\_unregister\_handler (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_unregister_handler}\pysiglinewithargsret{void \bfcode{input\_unregister\_handler}}{struct {\hyperref[driver\string-api/input:c.input_handler]{\emph{input\_handler}}} *\emph{ handler}}{}
unregisters an input handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_handler * handler}}] \leavevmode
handler to be unregistered

\end{description}

\textbf{Description}

This function disconnects a handler from its input devices and
removes it from lists of known handlers.
\index{input\_handler\_for\_each\_handle (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_handler_for_each_handle}\pysiglinewithargsret{int \bfcode{input\_handler\_for\_each\_handle}}{struct {\hyperref[driver\string-api/input:c.input_handler]{\emph{input\_handler}}} *\emph{ handler}, void *\emph{ data}, int (*fn) (struct {\hyperref[driver\string-api/input:c.input_handle]{\emph{input\_handle}}}\emph{ *}, void\emph{ *}}{}
handle iterator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_handler * handler}}] \leavevmode
input handler to iterate

\item[{\code{void * data}}] \leavevmode
data for the callback

\item[{\code{int (*)(struct input\_handle *, void *) fn}}] \leavevmode
function to be called for each handle

\end{description}

\textbf{Description}

Iterate over \textbf{bus}`s list of devices, and call \textbf{fn} for each, passing
it \textbf{data} and stop when \textbf{fn} returns a non-zero value. The function is
using RCU to traverse the list and therefore may be using in atomic
contexts. The \textbf{fn} callback is invoked from RCU critical section and
thus must not sleep.
\index{input\_register\_handle (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_register_handle}\pysiglinewithargsret{int \bfcode{input\_register\_handle}}{struct {\hyperref[driver\string-api/input:c.input_handle]{\emph{input\_handle}}} *\emph{ handle}}{}
register a new input handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_handle * handle}}] \leavevmode
handle to register

\end{description}

\textbf{Description}

This function puts a new input handle onto device's
and handler's lists so that events can flow through
it once it is opened using {\hyperref[driver\string-api/input:c.input_open_device]{\emph{\code{input\_open\_device()}}}}.

This function is supposed to be called from handler's
\code{connect()} method.
\index{input\_unregister\_handle (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_unregister_handle}\pysiglinewithargsret{void \bfcode{input\_unregister\_handle}}{struct {\hyperref[driver\string-api/input:c.input_handle]{\emph{input\_handle}}} *\emph{ handle}}{}
unregister an input handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_handle * handle}}] \leavevmode
handle to unregister

\end{description}

\textbf{Description}

This function removes input handle from device's
and handler's lists.

This function is supposed to be called from handler's
\code{disconnect()} method.
\index{input\_get\_new\_minor (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_get_new_minor}\pysiglinewithargsret{int \bfcode{input\_get\_new\_minor}}{int\emph{ legacy\_base}, unsigned int\emph{ legacy\_num}, bool\emph{ allow\_dynamic}}{}
allocates a new input minor number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int legacy\_base}}] \leavevmode
beginning or the legacy range to be searched

\item[{\code{unsigned int legacy\_num}}] \leavevmode
size of legacy range

\item[{\code{bool allow\_dynamic}}] \leavevmode
whether we can also take ID from the dynamic range

\end{description}

\textbf{Description}

This function allocates a new device minor for from input major namespace.
Caller can request legacy minor by specifying \textbf{legacy\_base} and \textbf{legacy\_num}
parameters and whether ID can be allocated from dynamic range if there are
no free IDs in legacy range.
\index{input\_free\_minor (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_free_minor}\pysiglinewithargsret{void \bfcode{input\_free\_minor}}{unsigned int\emph{ minor}}{}
release previously allocated minor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int minor}}] \leavevmode
minor to be released

\end{description}

\textbf{Description}

This function releases previously allocated input minor so that it can be
reused later.
\index{input\_ff\_upload (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_ff_upload}\pysiglinewithargsret{int \bfcode{input\_ff\_upload}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, struct ff\_effect *\emph{ effect}, struct file *\emph{ file}}{}
upload effect into force-feedback device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device

\item[{\code{struct ff\_effect * effect}}] \leavevmode
effect to be uploaded

\item[{\code{struct file * file}}] \leavevmode
owner of the effect

\end{description}
\index{input\_ff\_erase (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_ff_erase}\pysiglinewithargsret{int \bfcode{input\_ff\_erase}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, int\emph{ effect\_id}, struct file *\emph{ file}}{}
erase a force-feedback effect from device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device to erase effect from

\item[{\code{int effect\_id}}] \leavevmode
id of the effect to be erased

\item[{\code{struct file * file}}] \leavevmode
purported owner of the request

\end{description}

\textbf{Description}

This function erases a force-feedback effect from specified device.
The effect will only be erased if it was uploaded through the same
file handle that is requesting erase.
\index{input\_ff\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_ff_event}\pysiglinewithargsret{int \bfcode{input\_ff\_event}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, unsigned int\emph{ type}, unsigned int\emph{ code}, int\emph{ value}}{}
generic handler for force-feedback events

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device to send the effect to

\item[{\code{unsigned int type}}] \leavevmode
event type (anything but EV\_FF is ignored)

\item[{\code{unsigned int code}}] \leavevmode
event code

\item[{\code{int value}}] \leavevmode
event value

\end{description}
\index{input\_ff\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_ff_create}\pysiglinewithargsret{int \bfcode{input\_ff\_create}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, unsigned int\emph{ max\_effects}}{}
create force-feedback device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device supporting force-feedback

\item[{\code{unsigned int max\_effects}}] \leavevmode
maximum number of effects supported by the device

\end{description}

\textbf{Description}

This function allocates all necessary memory for a force feedback
portion of an input device and installs all default handlers.
\textbf{dev}-\textgreater{}ffbit should be already set up before calling this function.
Once ff device is created you need to setup its upload, erase,
playback and other handlers before registering input device
\index{input\_ff\_destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_ff_destroy}\pysiglinewithargsret{void \bfcode{input\_ff\_destroy}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}}{}
frees force feedback portion of input device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device supporting force feedback

\end{description}

\textbf{Description}

This function is only needed in error path as input core will
automatically free force feedback structures when device is
destroyed.
\index{input\_ff\_create\_memless (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_ff_create_memless}\pysiglinewithargsret{int \bfcode{input\_ff\_create\_memless}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, void *\emph{ data}, int (*play\_effect) (struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}}\emph{ *}, void\emph{ *}, struct ff\_effect\emph{ *}}{}
create memoryless force-feedback device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device supporting force-feedback

\item[{\code{void * data}}] \leavevmode
driver-specific data to be passed into \textbf{play\_effect}

\item[{\code{int (*)(struct input\_dev *, void *, struct ff\_effect *) play\_effect}}] \leavevmode
driver-specific method for playing FF effect

\end{description}


\section{Multitouch Library}
\label{driver-api/input:multitouch-library}\index{input\_mt\_slot (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_mt_slot}\pysigline{struct \bfcode{input\_mt\_slot}}
represents the state of an input MT slot

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct input\PYGZus{}mt\PYGZus{}slot \PYGZob{}
  int abs[ABS\PYGZus{}MT\PYGZus{}LAST \PYGZhy{} ABS\PYGZus{}MT\PYGZus{}FIRST + 1];
  unsigned int frame;
  unsigned int key;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{abs}}] \leavevmode
holds current values of ABS\_MT axes for this slot

\item[{\code{frame}}] \leavevmode
last frame at which {\hyperref[driver\string-api/input:c.input_mt_report_slot_state]{\emph{\code{input\_mt\_report\_slot\_state()}}}} was called

\item[{\code{key}}] \leavevmode
optional driver designation of this slot

\end{description}
\index{input\_mt (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_mt}\pysigline{struct \bfcode{input\_mt}}
state of tracked contacts

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct input\PYGZus{}mt \PYGZob{}
  int trkid;
  int num\PYGZus{}slots;
  int slot;
  unsigned int flags;
  unsigned int frame;
  int *red;
  struct input\PYGZus{}mt\PYGZus{}slot slots[];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{trkid}}] \leavevmode
stores MT tracking ID for the next contact

\item[{\code{num\_slots}}] \leavevmode
number of MT slots the device uses

\item[{\code{slot}}] \leavevmode
MT slot currently being transmitted

\item[{\code{flags}}] \leavevmode
input\_mt operation flags

\item[{\code{frame}}] \leavevmode
increases every time {\hyperref[driver\string-api/input:c.input_mt_sync_frame]{\emph{\code{input\_mt\_sync\_frame()}}}} is called

\item[{\code{red}}] \leavevmode
reduced cost matrix for in-kernel tracking

\item[{\code{slots}}] \leavevmode
array of slots holding current values of tracked contacts

\end{description}
\index{input\_mt\_pos (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_mt_pos}\pysigline{struct \bfcode{input\_mt\_pos}}
contact position

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct input\PYGZus{}mt\PYGZus{}pos \PYGZob{}
  s16 x, y;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{x}}] \leavevmode
horizontal coordinate

\item[{\code{y}}] \leavevmode
vertical coordinate

\end{description}
\index{input\_mt\_init\_slots (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_mt_init_slots}\pysiglinewithargsret{int \bfcode{input\_mt\_init\_slots}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, unsigned int\emph{ num\_slots}, unsigned int\emph{ flags}}{}
initialize MT input slots

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device supporting MT events and finger tracking

\item[{\code{unsigned int num\_slots}}] \leavevmode
number of slots used by the device

\item[{\code{unsigned int flags}}] \leavevmode
mt tasks to handle in core

\end{description}

\textbf{Description}

This function allocates all necessary memory for MT slot handling
in the input device, prepares the ABS\_MT\_SLOT and
ABS\_MT\_TRACKING\_ID events for use and sets up appropriate buffers.
Depending on the flags set, it also performs pointer emulation and
frame synchronization.

May be called repeatedly. Returns -EINVAL if attempting to
reinitialize with a different number of slots.
\index{input\_mt\_destroy\_slots (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_mt_destroy_slots}\pysiglinewithargsret{void \bfcode{input\_mt\_destroy\_slots}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}}{}
frees the MT slots of the input device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device with allocated MT slots

\end{description}

\textbf{Description}

This function is only needed in error path as the input core will
automatically free the MT slots when the device is destroyed.
\index{input\_mt\_report\_slot\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_mt_report_slot_state}\pysiglinewithargsret{void \bfcode{input\_mt\_report\_slot\_state}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, unsigned int\emph{ tool\_type}, bool\emph{ active}}{}
report contact state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device with allocated MT slots

\item[{\code{unsigned int tool\_type}}] \leavevmode
the tool type to use in this slot

\item[{\code{bool active}}] \leavevmode
true if contact is active, false otherwise

\end{description}

\textbf{Description}

Reports a contact via ABS\_MT\_TRACKING\_ID, and optionally
ABS\_MT\_TOOL\_TYPE. If active is true and the slot is currently
inactive, or if the tool type is changed, a new tracking id is
assigned to the slot. The tool type is only reported if the
corresponding absbit field is set.
\index{input\_mt\_report\_finger\_count (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_mt_report_finger_count}\pysiglinewithargsret{void \bfcode{input\_mt\_report\_finger\_count}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, int\emph{ count}}{}
report contact count

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device with allocated MT slots

\item[{\code{int count}}] \leavevmode
the number of contacts

\end{description}

\textbf{Description}

Reports the contact count via BTN\_TOOL\_FINGER, BTN\_TOOL\_DOUBLETAP,
BTN\_TOOL\_TRIPLETAP and BTN\_TOOL\_QUADTAP.

The input core ensures only the KEY events already setup for
this device will produce output.
\index{input\_mt\_report\_pointer\_emulation (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_mt_report_pointer_emulation}\pysiglinewithargsret{void \bfcode{input\_mt\_report\_pointer\_emulation}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, bool\emph{ use\_count}}{}
common pointer emulation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device with allocated MT slots

\item[{\code{bool use\_count}}] \leavevmode
report number of active contacts as finger count

\end{description}

\textbf{Description}

Performs legacy pointer emulation via BTN\_TOUCH, ABS\_X, ABS\_Y and
ABS\_PRESSURE. Touchpad finger count is emulated if use\_count is true.

The input core ensures only the KEY and ABS axes already setup for
this device will produce output.
\index{input\_mt\_drop\_unused (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_mt_drop_unused}\pysiglinewithargsret{void \bfcode{input\_mt\_drop\_unused}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}}{}
Inactivate slots not seen in this frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device with allocated MT slots

\end{description}

\textbf{Description}

Lift all slots not seen since the last call to this function.
\index{input\_mt\_sync\_frame (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_mt_sync_frame}\pysiglinewithargsret{void \bfcode{input\_mt\_sync\_frame}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}}{}
synchronize mt frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device with allocated MT slots

\end{description}

\textbf{Description}

Close the frame and prepare the internal state for a new one.
Depending on the flags, marks unused slots as inactive and performs
pointer emulation.
\index{input\_mt\_assign\_slots (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_mt_assign_slots}\pysiglinewithargsret{int \bfcode{input\_mt\_assign\_slots}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, int *\emph{ slots}, const struct {\hyperref[driver\string-api/input:c.input_mt_pos]{\emph{input\_mt\_pos}}} *\emph{ pos}, int\emph{ num\_pos}, int\emph{ dmax}}{}
perform a best-match assignment

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device with allocated MT slots

\item[{\code{int * slots}}] \leavevmode
the slot assignment to be filled

\item[{\code{const struct input\_mt\_pos * pos}}] \leavevmode
the position array to match

\item[{\code{int num\_pos}}] \leavevmode
number of positions

\item[{\code{int dmax}}] \leavevmode
maximum ABS\_MT\_POSITION displacement (zero for infinite)

\end{description}

\textbf{Description}

Performs a best match against the current contacts and returns
the slot assignment list. New contacts are assigned to unused
slots.

The assignments are balanced so that all coordinate displacements are
below the euclidian distance dmax. If no such assignment can be found,
some contacts are assigned to unused slots.

Returns zero on success, or negative error in case of failure.
\index{input\_mt\_get\_slot\_by\_key (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_mt_get_slot_by_key}\pysiglinewithargsret{int \bfcode{input\_mt\_get\_slot\_by\_key}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, int\emph{ key}}{}
return slot matching key

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
input device with allocated MT slots

\item[{\code{int key}}] \leavevmode
the key of the sought slot

\end{description}

\textbf{Description}

Returns the slot of the given key, if it exists, otherwise
set the key on the first unused slot and return.

If no available slot can be found, -1 is returned.
Note that for this function to work properly, {\hyperref[driver\string-api/input:c.input_mt_sync_frame]{\emph{\code{input\_mt\_sync\_frame()}}}} has
to be called at each frame.


\section{Polled input devices}
\label{driver-api/input:polled-input-devices}\index{input\_polled\_dev (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_polled_dev}\pysigline{struct \bfcode{input\_polled\_dev}}
simple polled input device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct input\PYGZus{}polled\PYGZus{}dev \PYGZob{}
  void *private;
  void (*open)(struct input\PYGZus{}polled\PYGZus{}dev *dev);
  void (*close)(struct input\PYGZus{}polled\PYGZus{}dev *dev);
  void (*poll)(struct input\PYGZus{}polled\PYGZus{}dev *dev);
  unsigned int poll\PYGZus{}interval;
  unsigned int poll\PYGZus{}interval\PYGZus{}max;
  unsigned int poll\PYGZus{}interval\PYGZus{}min;
  struct input\PYGZus{}dev *input;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{private}}] \leavevmode
private driver data.

\item[{\code{open}}] \leavevmode
driver-supplied method that prepares device for polling
(enabled the device and maybe flushes device state).

\item[{\code{close}}] \leavevmode
driver-supplied method that is called when device is no
longer being polled. Used to put device into low power mode.

\item[{\code{poll}}] \leavevmode
driver-supplied method that polls the device and posts
input events (mandatory).

\item[{\code{poll\_interval}}] \leavevmode
specifies how often the \code{poll()} method should be called.
Defaults to 500 msec unless overridden when registering the device.

\item[{\code{poll\_interval\_max}}] \leavevmode
specifies upper bound for the poll interval.
Defaults to the initial value of \textbf{poll\_interval}.

\item[{\code{poll\_interval\_min}}] \leavevmode
specifies lower bound for the poll interval.
Defaults to 0.

\item[{\code{input}}] \leavevmode
input device structure associated with the polled device.
Must be properly initialized by the driver (id, name, phys, bits).

\end{description}

\textbf{Description}

Polled input device provides a skeleton for supporting simple input
devices that do not raise interrupts but have to be periodically
scanned or polled to detect changes in their state.
\index{input\_allocate\_polled\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_allocate_polled_device}\pysiglinewithargsret{struct {\hyperref[driver\string-api/input:c.input_polled_dev]{\emph{input\_polled\_dev}}} * \bfcode{input\_allocate\_polled\_device}}{void}{}
allocate memory for polled device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

The function allocates memory for a polled device and also
for an input device associated with this polled device.
\index{devm\_input\_allocate\_polled\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.devm_input_allocate_polled_device}\pysiglinewithargsret{struct {\hyperref[driver\string-api/input:c.input_polled_dev]{\emph{input\_polled\_dev}}} * \bfcode{devm\_input\_allocate\_polled\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
allocate managed polled device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device owning the polled device being created

\end{description}

\textbf{Description}

Returns prepared {\hyperref[driver\string-api/input:c.input_polled_dev]{\emph{\code{struct input\_polled\_dev}}}} or \code{NULL}.

Managed polled input devices do not need to be explicitly unregistered
or freed as it will be done automatically when owner device unbinds
from * its driver (or binding fails). Once such managed polled device
is allocated, it is ready to be set up and registered in the same
fashion as regular polled input devices (using
{\hyperref[driver\string-api/input:c.input_register_polled_device]{\emph{\code{input\_register\_polled\_device()}}}} function).

If you want to manually unregister and free such managed polled devices,
it can be still done by calling {\hyperref[driver\string-api/input:c.input_unregister_polled_device]{\emph{\code{input\_unregister\_polled\_device()}}}} and
{\hyperref[driver\string-api/input:c.input_free_polled_device]{\emph{\code{input\_free\_polled\_device()}}}}, although it is rarely needed.

\textbf{NOTE}

the owner device is set up as parent of input device and users
should not override it.
\index{input\_free\_polled\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_free_polled_device}\pysiglinewithargsret{void \bfcode{input\_free\_polled\_device}}{struct {\hyperref[driver\string-api/input:c.input_polled_dev]{\emph{input\_polled\_dev}}} *\emph{ dev}}{}
free memory allocated for polled device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_polled\_dev * dev}}] \leavevmode
device to free

\end{description}

\textbf{Description}

The function frees memory allocated for polling device and drops
reference to the associated input device.
\index{input\_register\_polled\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_register_polled_device}\pysiglinewithargsret{int \bfcode{input\_register\_polled\_device}}{struct {\hyperref[driver\string-api/input:c.input_polled_dev]{\emph{input\_polled\_dev}}} *\emph{ dev}}{}
register polled device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_polled\_dev * dev}}] \leavevmode
device to register

\end{description}

\textbf{Description}

The function registers previously initialized polled input device
with input layer. The device should be allocated with call to
{\hyperref[driver\string-api/input:c.input_allocate_polled_device]{\emph{\code{input\_allocate\_polled\_device()}}}}. Callers should also set up \code{poll()}
method and set up capabilities (id, name, phys, bits) of the
corresponding input\_dev structure.
\index{input\_unregister\_polled\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.input_unregister_polled_device}\pysiglinewithargsret{void \bfcode{input\_unregister\_polled\_device}}{struct {\hyperref[driver\string-api/input:c.input_polled_dev]{\emph{input\_polled\_dev}}} *\emph{ dev}}{}
unregister polled device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_polled\_dev * dev}}] \leavevmode
device to unregister

\end{description}

\textbf{Description}

The function unregisters previously registered polled input
device from input layer. Polling is stopped and device is
ready to be freed with call to {\hyperref[driver\string-api/input:c.input_free_polled_device]{\emph{\code{input\_free\_polled\_device()}}}}.


\section{Matrix keyboards/keypads}
\label{driver-api/input:matrix-keyboards-keypads}\index{matrix\_keymap\_data (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.matrix_keymap_data}\pysigline{struct \bfcode{matrix\_keymap\_data}}
keymap for matrix keyboards

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct matrix\PYGZus{}keymap\PYGZus{}data \PYGZob{}
  const uint32\PYGZus{}t *keymap;
  unsigned int    keymap\PYGZus{}size;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{keymap}}] \leavevmode
pointer to array of uint32 values encoded with \code{KEY()} macro
representing keymap

\item[{\code{keymap\_size}}] \leavevmode
number of entries (initialized) in this keymap

\end{description}

\textbf{Description}

This structure is supposed to be used by platform code to supply
keymaps to drivers that implement matrix-like keypads/keyboards.
\index{matrix\_keypad\_platform\_data (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.matrix_keypad_platform_data}\pysigline{struct \bfcode{matrix\_keypad\_platform\_data}}
platform-dependent keypad data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct matrix\PYGZus{}keypad\PYGZus{}platform\PYGZus{}data \PYGZob{}
  const struct matrix\PYGZus{}keymap\PYGZus{}data *keymap\PYGZus{}data;
  const unsigned int *row\PYGZus{}gpios;
  const unsigned int *col\PYGZus{}gpios;
  unsigned int    num\PYGZus{}row\PYGZus{}gpios;
  unsigned int    num\PYGZus{}col\PYGZus{}gpios;
  unsigned int    col\PYGZus{}scan\PYGZus{}delay\PYGZus{}us;
  unsigned int    debounce\PYGZus{}ms;
  unsigned int    clustered\PYGZus{}irq;
  unsigned int    clustered\PYGZus{}irq\PYGZus{}flags;
  bool active\PYGZus{}low;
  bool wakeup;
  bool no\PYGZus{}autorepeat;
  bool drive\PYGZus{}inactive\PYGZus{}cols;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{keymap\_data}}] \leavevmode
pointer to {\hyperref[driver\string-api/input:c.matrix_keymap_data]{\emph{\code{matrix\_keymap\_data}}}}

\item[{\code{row\_gpios}}] \leavevmode
pointer to array of gpio numbers representing rows

\item[{\code{col\_gpios}}] \leavevmode
pointer to array of gpio numbers reporesenting colums

\item[{\code{num\_row\_gpios}}] \leavevmode
actual number of row gpios used by device

\item[{\code{num\_col\_gpios}}] \leavevmode
actual number of col gpios used by device

\item[{\code{col\_scan\_delay\_us}}] \leavevmode
delay, measured in microseconds, that is
needed before we can keypad after activating column gpio

\item[{\code{debounce\_ms}}] \leavevmode
debounce interval in milliseconds

\item[{\code{clustered\_irq}}] \leavevmode
may be specified if interrupts of all row/column GPIOs
are bundled to one single irq

\item[{\code{clustered\_irq\_flags}}] \leavevmode
flags that are needed for the clustered irq

\item[{\code{active\_low}}] \leavevmode
gpio polarity

\item[{\code{wakeup}}] \leavevmode
controls whether the device should be set up as wakeup
source

\item[{\code{no\_autorepeat}}] \leavevmode
disable key autorepeat

\item[{\code{drive\_inactive\_cols}}] \leavevmode
drive inactive columns during scan, rather than
making them inputs.

\end{description}

\textbf{Description}

This structure represents platform-specific data that use used by
matrix\_keypad driver to perform proper initialization.


\section{Sparse keymap support}
\label{driver-api/input:sparse-keymap-support}\index{key\_entry (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.key_entry}\pysigline{struct \bfcode{key\_entry}}
keymap entry for use in sparse keymap

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct key\PYGZus{}entry \PYGZob{}
  int type;
  u32 code;
  union \PYGZob{}
    u16 keycode;
    struct \PYGZob{}
      u8 code;
      u8 value;
    \PYGZcb{} sw;
  \PYGZcb{};
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{type}}] \leavevmode
Type of the key entry (KE\_KEY, KE\_SW, KE\_VSW, KE\_END);
drivers are allowed to extend the list with their own
private definitions.

\item[{\code{code}}] \leavevmode
Device-specific data identifying the button/switch

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{keycode}}] \leavevmode
KEY\_* code assigned to a key/button

\item[{\code{sw.code}}] \leavevmode
SW\_* code assigned to a switch

\item[{\code{sw.value}}] \leavevmode
Value that should be sent in an input even when KE\_SW
switch is toggled. KE\_VSW switches ignore this field and
expect driver to supply value for the event.

\end{description}

\textbf{Description}

This structure defines an entry in a sparse keymap used by some
input devices for which traditional table-based approach is not
suitable.
\index{sparse\_keymap\_entry\_from\_scancode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.sparse_keymap_entry_from_scancode}\pysiglinewithargsret{struct {\hyperref[driver\string-api/input:c.key_entry]{\emph{key\_entry}}} * \bfcode{sparse\_keymap\_entry\_from\_scancode}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, unsigned int\emph{ code}}{}
perform sparse keymap lookup

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
Input device using sparse keymap

\item[{\code{unsigned int code}}] \leavevmode
Scan code

\end{description}

\textbf{Description}

This function is used to perform {\hyperref[driver\string-api/input:c.key_entry]{\emph{\code{struct key\_entry}}}} lookup in an
input device using sparse keymap.
\index{sparse\_keymap\_entry\_from\_keycode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.sparse_keymap_entry_from_keycode}\pysiglinewithargsret{struct {\hyperref[driver\string-api/input:c.key_entry]{\emph{key\_entry}}} * \bfcode{sparse\_keymap\_entry\_from\_keycode}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, unsigned int\emph{ keycode}}{}
perform sparse keymap lookup

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
Input device using sparse keymap

\item[{\code{unsigned int keycode}}] \leavevmode
Key code

\end{description}

\textbf{Description}

This function is used to perform {\hyperref[driver\string-api/input:c.key_entry]{\emph{\code{struct key\_entry}}}} lookup in an
input device using sparse keymap.
\index{sparse\_keymap\_setup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.sparse_keymap_setup}\pysiglinewithargsret{int \bfcode{sparse\_keymap\_setup}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, const struct {\hyperref[driver\string-api/input:c.key_entry]{\emph{key\_entry}}} *\emph{ keymap}, int (*setup) (struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}}\emph{ *}, struct {\hyperref[driver\string-api/input:c.key_entry]{\emph{key\_entry}}}\emph{ *}}{}
set up sparse keymap for an input device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
Input device

\item[{\code{const struct key\_entry * keymap}}] \leavevmode
Keymap in form of array of {\hyperref[driver\string-api/input:c.key_entry]{\emph{\code{key\_entry}}}} structures ending
with \code{KE\_END} type entry

\item[{\code{int (*)(struct input\_dev *, struct key\_entry *) setup}}] \leavevmode
Function that can be used to adjust keymap entries
depending on device's needs, may be \code{NULL}

\end{description}

\textbf{Description}

The function calculates size and allocates copy of the original
keymap after which sets up input device event bits appropriately.
The allocated copy of the keymap is automatically freed when it
is no longer needed.
\index{sparse\_keymap\_report\_entry (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.sparse_keymap_report_entry}\pysiglinewithargsret{void \bfcode{sparse\_keymap\_report\_entry}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, const struct {\hyperref[driver\string-api/input:c.key_entry]{\emph{key\_entry}}} *\emph{ ke}, unsigned int\emph{ value}, bool\emph{ autorelease}}{}
report event corresponding to given key entry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
Input device for which event should be reported

\item[{\code{const struct key\_entry * ke}}] \leavevmode
key entry describing event

\item[{\code{unsigned int value}}] \leavevmode
Value that should be reported (ignored by \code{KE\_SW} entries)

\item[{\code{bool autorelease}}] \leavevmode
Signals whether release event should be emitted for \code{KE\_KEY}
entries right after reporting press event, ignored by all other
entries

\end{description}

\textbf{Description}

This function is used to report input event described by given
{\hyperref[driver\string-api/input:c.key_entry]{\emph{\code{struct key\_entry}}}}.
\index{sparse\_keymap\_report\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/input:c.sparse_keymap_report_event}\pysiglinewithargsret{bool \bfcode{sparse\_keymap\_report\_event}}{struct {\hyperref[driver\string-api/input:c.input_dev]{\emph{input\_dev}}} *\emph{ dev}, unsigned int\emph{ code}, unsigned int\emph{ value}, bool\emph{ autorelease}}{}
report event corresponding to given scancode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct input\_dev * dev}}] \leavevmode
Input device using sparse keymap

\item[{\code{unsigned int code}}] \leavevmode
Scan code

\item[{\code{unsigned int value}}] \leavevmode
Value that should be reported (ignored by \code{KE\_SW} entries)

\item[{\code{bool autorelease}}] \leavevmode
Signals whether release event should be emitted for \code{KE\_KEY}
entries right after reporting press event, ignored by all other
entries

\end{description}

\textbf{Description}

This function is used to perform lookup in an input device using sparse
keymap and report corresponding event. Returns \code{true} if lookup was
successful and \code{false} otherwise.


\chapter{Linux USB API}
\label{driver-api/usb/index::doc}\label{driver-api/usb/index:linux-usb-api}

\section{The Linux-USB Host Side API}
\label{driver-api/usb/usb:the-linux-usb-host-side-api}\label{driver-api/usb/usb:usb-hostside-api}\label{driver-api/usb/usb::doc}

\subsection{Introduction to USB on Linux}
\label{driver-api/usb/usb:introduction-to-usb-on-linux}
A Universal Serial Bus (USB) is used to connect a host, such as a PC or
workstation, to a number of peripheral devices. USB uses a tree
structure, with the host as the root (the system's master), hubs as
interior nodes, and peripherals as leaves (and slaves). Modern PCs
support several such trees of USB devices, usually
a few USB 3.0 (5 GBit/s) or USB 3.1 (10 GBit/s) and some legacy
USB 2.0 (480 MBit/s) busses just in case.

That master/slave asymmetry was designed-in for a number of reasons, one
being ease of use. It is not physically possible to mistake upstream and
downstream or it does not matter with a type C plug (or they are built into the
peripheral). Also, the host software doesn't need to deal with
distributed auto-configuration since the pre-designated master node
manages all that.

Kernel developers added USB support to Linux early in the 2.2 kernel
series and have been developing it further since then. Besides support
for each new generation of USB, various host controllers gained support,
new drivers for peripherals have been added and advanced features for latency
measurement and improved power management introduced.

Linux can run inside USB devices as well as on the hosts that control
the devices. But USB device drivers running inside those peripherals
don't do the same things as the ones running inside hosts, so they've
been given a different name: \emph{gadget drivers}. This document does not
cover gadget drivers.


\subsection{USB Host-Side API Model}
\label{driver-api/usb/usb:usb-host-side-api-model}
Host-side drivers for USB devices talk to the ``usbcore'' APIs. There are
two. One is intended for \emph{general-purpose} drivers (exposed through
driver frameworks), and the other is for drivers that are \emph{part of the
core}. Such core drivers include the \emph{hub} driver (which manages trees
of USB devices) and several different kinds of \emph{host controller
drivers}, which control individual busses.

The device model seen by USB drivers is relatively complex.
\begin{itemize}
\item {} 
USB supports four kinds of data transfers (control, bulk, interrupt,
and isochronous). Two of them (control and bulk) use bandwidth as
it's available, while the other two (interrupt and isochronous) are
scheduled to provide guaranteed bandwidth.

\item {} 
The device description model includes one or more ``configurations''
per device, only one of which is active at a time. Devices are supposed
to be capable of operating at lower than their top
speeds and may provide a BOS descriptor showing the lowest speed they
remain fully operational at.

\item {} 
From USB 3.0 on configurations have one or more ``functions'', which
provide a common functionality and are grouped together for purposes
of power management.

\item {} 
Configurations or functions have one or more ``interfaces'', each of which may have
``alternate settings''. Interfaces may be standardized by USB ``Class''
specifications, or may be specific to a vendor or device.

USB device drivers actually bind to interfaces, not devices. Think of
them as ``interface drivers'', though you may not see many devices
where the distinction is important. \emph{Most USB devices are simple,
with only one function, one configuration, one interface, and one alternate
setting.}

\item {} 
Interfaces have one or more ``endpoints'', each of which supports one
type and direction of data transfer such as ``bulk out'' or ``interrupt
in''. The entire configuration may have up to sixteen endpoints in
each direction, allocated as needed among all the interfaces.

\item {} 
Data transfer on USB is packetized; each endpoint has a maximum
packet size. Drivers must often be aware of conventions such as
flagging the end of bulk transfers using ``short'' (including zero
length) packets.

\item {} 
The Linux USB API supports synchronous calls for control and bulk
messages. It also supports asynchronous calls for all kinds of data
transfer, using request structures called ``URBs'' (USB Request
Blocks).

\end{itemize}

Accordingly, the USB Core API exposed to device drivers covers quite a
lot of territory. You'll probably need to consult the USB 3.0
specification, available online from www.usb.org at no cost, as well as
class or device specifications.

The only host-side drivers that actually touch hardware (reading/writing
registers, handling IRQs, and so on) are the HCDs. In theory, all HCDs
provide the same functionality through the same API. In practice, that's
becoming more true, but there are still differences
that crop up especially with fault handling on the less common controllers.
Different controllers don't
necessarily report the same aspects of failures, and recovery from
faults (including software-induced ones like unlinking an URB) isn't yet
fully consistent. Device driver authors should make a point of doing
disconnect testing (while the device is active) with each different host
controller driver, to make sure drivers don't have bugs of their own as
well as to make sure they aren't relying on some HCD-specific behavior.


\subsection{USB-Standard Types}
\label{driver-api/usb/usb:usb-standard-types}\label{driver-api/usb/usb:usb-chapter9}
In \code{\textless{}linux/usb/ch9.h\textgreater{}} you will find the USB data types defined in
chapter 9 of the USB specification. These data types are used throughout
USB, and in APIs including this host side API, gadget APIs, usb character
devices and debugfs interfaces.
\index{usb\_speed\_string (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_speed_string}\pysiglinewithargsret{const char * \bfcode{usb\_speed\_string}}{enum usb\_device\_speed\emph{ speed}}{}
Returns human readable-name of the speed.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{enum usb\_device\_speed speed}}] \leavevmode
The speed to return human-readable name for.  If it's not
any of the speeds defined in usb\_device\_speed enum, string for
USB\_SPEED\_UNKNOWN will be returned.

\end{description}
\index{usb\_get\_maximum\_speed (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_get_maximum_speed}\pysiglinewithargsret{enum usb\_device\_speed \bfcode{usb\_get\_maximum\_speed}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
Get maximum requested speed for a given USB controller.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Pointer to the given USB controller device

\end{description}

\textbf{Description}

The function gets the maximum speed string from property ``maximum-speed'',
and returns the corresponding enum usb\_device\_speed.
\index{usb\_state\_string (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_state_string}\pysiglinewithargsret{const char * \bfcode{usb\_state\_string}}{enum usb\_device\_state\emph{ state}}{}
Returns human readable name for the state.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{enum usb\_device\_state state}}] \leavevmode
The state to return a human-readable name for. If it's not
any of the states devices in usb\_device\_state\_string enum,
the string UNKNOWN will be returned.

\end{description}


\subsection{Host-Side Data Types and Macros}
\label{driver-api/usb/usb:usb-header}\label{driver-api/usb/usb:host-side-data-types-and-macros}
The host side API exposes several layers to drivers, some of which are
more necessary than others. These support lifecycle models for host side
drivers and devices, and support passing buffers through usbcore to some
HCD that performs the I/O for the device driver.
\index{usb\_host\_endpoint (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_host_endpoint}\pysigline{struct \bfcode{usb\_host\_endpoint}}
host-side endpoint descriptor and queue

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}host\PYGZus{}endpoint \PYGZob{}
  struct usb\PYGZus{}endpoint\PYGZus{}descriptor          desc;
  struct usb\PYGZus{}ss\PYGZus{}ep\PYGZus{}comp\PYGZus{}descriptor        ss\PYGZus{}ep\PYGZus{}comp;
  struct usb\PYGZus{}ssp\PYGZus{}isoc\PYGZus{}ep\PYGZus{}comp\PYGZus{}descriptor  ssp\PYGZus{}isoc\PYGZus{}ep\PYGZus{}comp;
  struct list\PYGZus{}head                urb\PYGZus{}list;
  void *hcpriv;
  struct ep\PYGZus{}device                *ep\PYGZus{}dev;
  unsigned char *extra;
  int extralen;
  int enabled;
  int streams;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{desc}}] \leavevmode
descriptor for this endpoint, wMaxPacketSize in native byteorder

\item[{\code{ss\_ep\_comp}}] \leavevmode
SuperSpeed companion descriptor for this endpoint

\item[{\code{ssp\_isoc\_ep\_comp}}] \leavevmode
SuperSpeedPlus isoc companion descriptor for this endpoint

\item[{\code{urb\_list}}] \leavevmode
urbs queued to this endpoint; maintained by usbcore

\item[{\code{hcpriv}}] \leavevmode
for use by HCD; typically holds hardware dma queue head (QH)
with one or more transfer descriptors (TDs) per urb

\item[{\code{ep\_dev}}] \leavevmode
ep\_device for sysfs info

\item[{\code{extra}}] \leavevmode
descriptors following this endpoint in the configuration

\item[{\code{extralen}}] \leavevmode
how many bytes of ``extra'' are valid

\item[{\code{enabled}}] \leavevmode
URBs may be submitted to this endpoint

\item[{\code{streams}}] \leavevmode
number of USB-3 streams allocated on the endpoint

\end{description}

\textbf{Description}

USB requests are always queued to a given endpoint, identified by a
descriptor within an active interface in a given USB configuration.
\index{usb\_interface (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_interface}\pysigline{struct \bfcode{usb\_interface}}
what usb device drivers talk to

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}interface \PYGZob{}
  struct usb\PYGZus{}host\PYGZus{}interface *altsetting;
  struct usb\PYGZus{}host\PYGZus{}interface *cur\PYGZus{}altsetting;
  unsigned num\PYGZus{}altsetting;
  struct usb\PYGZus{}interface\PYGZus{}assoc\PYGZus{}descriptor *intf\PYGZus{}assoc;
  int minor;
  enum usb\PYGZus{}interface\PYGZus{}condition condition;
  unsigned sysfs\PYGZus{}files\PYGZus{}created:1;
  unsigned ep\PYGZus{}devs\PYGZus{}created:1;
  unsigned unregistering:1;
  unsigned needs\PYGZus{}remote\PYGZus{}wakeup:1;
  unsigned needs\PYGZus{}altsetting0:1;
  unsigned needs\PYGZus{}binding:1;
  unsigned resetting\PYGZus{}device:1;
  unsigned authorized:1;
  struct device dev;
  struct device *usb\PYGZus{}dev;
  atomic\PYGZus{}t pm\PYGZus{}usage\PYGZus{}cnt;
  struct work\PYGZus{}struct reset\PYGZus{}ws;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{altsetting}}] \leavevmode
array of interface structures, one for each alternate
setting that may be selected.  Each one includes a set of
endpoint configurations.  They will be in no particular order.

\item[{\code{cur\_altsetting}}] \leavevmode
the current altsetting.

\item[{\code{num\_altsetting}}] \leavevmode
number of altsettings defined.

\item[{\code{intf\_assoc}}] \leavevmode
interface association descriptor

\item[{\code{minor}}] \leavevmode
the minor number assigned to this interface, if this
interface is bound to a driver that uses the USB major number.
If this interface does not use the USB major, this field should
be unused.  The driver should set this value in the \code{probe()}
function of the driver, after it has been assigned a minor
number from the USB core by calling {\hyperref[driver\string-api/usb/usb:c.usb_register_dev]{\emph{\code{usb\_register\_dev()}}}}.

\item[{\code{condition}}] \leavevmode
binding state of the interface: not bound, binding
(in \code{probe()}), bound to a driver, or unbinding (in \code{disconnect()})

\item[{\code{sysfs\_files\_created}}] \leavevmode
sysfs attributes exist

\item[{\code{ep\_devs\_created}}] \leavevmode
endpoint child pseudo-devices exist

\item[{\code{unregistering}}] \leavevmode
flag set when the interface is being unregistered

\item[{\code{needs\_remote\_wakeup}}] \leavevmode
flag set when the driver requires remote-wakeup
capability during autosuspend.

\item[{\code{needs\_altsetting0}}] \leavevmode
flag set when a set-interface request for altsetting 0
has been deferred.

\item[{\code{needs\_binding}}] \leavevmode
flag set when the driver should be re-probed or unbound
following a reset or suspend operation it doesn't support.

\item[{\code{resetting\_device}}] \leavevmode
USB core reset the device, so use alt setting 0 as
current; needs bandwidth alloc after reset.

\item[{\code{authorized}}] \leavevmode
This allows to (de)authorize individual interfaces instead
a whole device in contrast to the device authorization.

\item[{\code{dev}}] \leavevmode
driver model's view of this device

\item[{\code{usb\_dev}}] \leavevmode
if an interface is bound to the USB major, this will point
to the sysfs representation for that device.

\item[{\code{pm\_usage\_cnt}}] \leavevmode
PM usage counter for this interface

\item[{\code{reset\_ws}}] \leavevmode
Used for scheduling resets from atomic context.

\end{description}

\textbf{Description}

USB device drivers attach to interfaces on a physical device.  Each
interface encapsulates a single high level function, such as feeding
an audio stream to a speaker or reporting a change in a volume control.
Many USB devices only have one interface.  The protocol used to talk to
an interface's endpoints can be defined in a usb ``class'' specification,
or by a product's vendor.  The (default) control endpoint is part of
every interface, but is never listed among the interface's descriptors.

The driver that is bound to the interface can use standard driver model
calls such as \code{dev\_get\_drvdata()} on the dev member of this structure.

Each interface may have alternate settings.  The initial configuration
of a device sets altsetting 0, but the device driver can change
that setting using {\hyperref[driver\string-api/usb/usb:c.usb_set_interface]{\emph{\code{usb\_set\_interface()}}}}.  Alternate settings are often
used to control the use of periodic endpoints, such as by having
different endpoints use different amounts of reserved USB bandwidth.
All standards-conformant USB devices that use isochronous endpoints
will use them in non-default settings.

The USB specification says that alternate setting numbers must run from
0 to one less than the total number of alternate settings.  But some
devices manage to mess this up, and the structures aren't necessarily
stored in numerical order anyhow.  Use {\hyperref[driver\string-api/usb/usb:c.usb_altnum_to_altsetting]{\emph{\code{usb\_altnum\_to\_altsetting()}}}} to
look up an alternate setting in the altsetting array based on its number.
\index{usb\_interface\_cache (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_interface_cache}\pysigline{struct \bfcode{usb\_interface\_cache}}
long-term representation of a device interface

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}interface\PYGZus{}cache \PYGZob{}
  unsigned num\PYGZus{}altsetting;
  struct kref ref;
  struct usb\PYGZus{}host\PYGZus{}interface altsetting[0];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{num\_altsetting}}] \leavevmode
number of altsettings defined.

\item[{\code{ref}}] \leavevmode
reference counter.

\item[{\code{altsetting}}] \leavevmode
variable-length array of interface structures, one for
each alternate setting that may be selected.  Each one includes a
set of endpoint configurations.  They will be in no particular order.

\end{description}

\textbf{Description}

These structures persist for the lifetime of a usb\_device, unlike
struct usb\_interface (which persists only as long as its configuration
is installed).  The altsetting arrays can be accessed through these
structures at any time, permitting comparison of configurations and
providing support for the /sys/kernel/debug/usb/devices pseudo-file.
\index{usb\_host\_config (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_host_config}\pysigline{struct \bfcode{usb\_host\_config}}
representation of a device's configuration

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}host\PYGZus{}config \PYGZob{}
  struct usb\PYGZus{}config\PYGZus{}descriptor    desc;
  char *string;
  struct usb\PYGZus{}interface\PYGZus{}assoc\PYGZus{}descriptor *intf\PYGZus{}assoc[USB\PYGZus{}MAXIADS];
  struct usb\PYGZus{}interface *interface[USB\PYGZus{}MAXINTERFACES];
  struct usb\PYGZus{}interface\PYGZus{}cache *intf\PYGZus{}cache[USB\PYGZus{}MAXINTERFACES];
  unsigned char *extra;
  int extralen;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{desc}}] \leavevmode
the device's configuration descriptor.

\item[{\code{string}}] \leavevmode
pointer to the cached version of the iConfiguration string, if
present for this configuration.

\item[{\code{intf\_assoc}}] \leavevmode
list of any interface association descriptors in this config

\item[{\code{interface}}] \leavevmode
array of pointers to usb\_interface structures, one for each
interface in the configuration.  The number of interfaces is stored
in desc.bNumInterfaces.  These pointers are valid only while the
the configuration is active.

\item[{\code{intf\_cache}}] \leavevmode
array of pointers to usb\_interface\_cache structures, one
for each interface in the configuration.  These structures exist
for the entire life of the device.

\item[{\code{extra}}] \leavevmode
pointer to buffer containing all extra descriptors associated
with this configuration (those preceding the first interface
descriptor).

\item[{\code{extralen}}] \leavevmode
length of the extra descriptors buffer.

\end{description}

\textbf{Description}

USB devices may have multiple configurations, but only one can be active
at any time.  Each encapsulates a different operational environment;
for example, a dual-speed device would have separate configurations for
full-speed and high-speed operation.  The number of configurations
available is stored in the device descriptor as bNumConfigurations.

A configuration can contain multiple interfaces.  Each corresponds to
a different function of the USB device, and all are available whenever
the configuration is active.  The USB standard says that interfaces
are supposed to be numbered from 0 to desc.bNumInterfaces-1, but a lot
of devices get this wrong.  In addition, the interface array is not
guaranteed to be sorted in numerical order.  Use {\hyperref[driver\string-api/usb/usb:c.usb_ifnum_to_if]{\emph{\code{usb\_ifnum\_to\_if()}}}} to
look up an interface entry based on its number.

Device drivers should not attempt to activate configurations.  The choice
of which configuration to install is a policy decision based on such
considerations as available power, functionality provided, and the user's
desires (expressed through userspace tools).  However, drivers can call
{\hyperref[driver\string-api/usb/usb:c.usb_reset_configuration]{\emph{\code{usb\_reset\_configuration()}}}} to reinitialize the current configuration and
all its interfaces.
\index{usb\_device (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_device}\pysigline{struct \bfcode{usb\_device}}
kernel's representation of a USB device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}device \PYGZob{}
  int devnum;
  char devpath[16];
  u32 route;
  enum usb\PYGZus{}device\PYGZus{}state   state;
  enum usb\PYGZus{}device\PYGZus{}speed   speed;
  struct usb\PYGZus{}tt   *tt;
  int ttport;
  unsigned int toggle[2];
  struct usb\PYGZus{}device *parent;
  struct usb\PYGZus{}bus *bus;
  struct usb\PYGZus{}host\PYGZus{}endpoint ep0;
  struct device dev;
  struct usb\PYGZus{}device\PYGZus{}descriptor descriptor;
  struct usb\PYGZus{}host\PYGZus{}bos *bos;
  struct usb\PYGZus{}host\PYGZus{}config *config;
  struct usb\PYGZus{}host\PYGZus{}config *actconfig;
  struct usb\PYGZus{}host\PYGZus{}endpoint *ep\PYGZus{}in[16];
  struct usb\PYGZus{}host\PYGZus{}endpoint *ep\PYGZus{}out[16];
  char **rawdescriptors;
  unsigned short bus\PYGZus{}mA;
  u8 portnum;
  u8 level;
  unsigned can\PYGZus{}submit:1;
  unsigned persist\PYGZus{}enabled:1;
  unsigned have\PYGZus{}langid:1;
  unsigned authorized:1;
  unsigned authenticated:1;
  unsigned wusb:1;
  unsigned lpm\PYGZus{}capable:1;
  unsigned usb2\PYGZus{}hw\PYGZus{}lpm\PYGZus{}capable:1;
  unsigned usb2\PYGZus{}hw\PYGZus{}lpm\PYGZus{}besl\PYGZus{}capable:1;
  unsigned usb2\PYGZus{}hw\PYGZus{}lpm\PYGZus{}enabled:1;
  unsigned usb2\PYGZus{}hw\PYGZus{}lpm\PYGZus{}allowed:1;
  unsigned usb3\PYGZus{}lpm\PYGZus{}u1\PYGZus{}enabled:1;
  unsigned usb3\PYGZus{}lpm\PYGZus{}u2\PYGZus{}enabled:1;
  int string\PYGZus{}langid;
  char *product;
  char *manufacturer;
  char *serial;
  struct list\PYGZus{}head filelist;
  int maxchild;
  u32 quirks;
  atomic\PYGZus{}t urbnum;
  unsigned long active\PYGZus{}duration;
\PYGZsh{}ifdef CONFIG\PYGZus{}PM;
  unsigned long connect\PYGZus{}time;
  unsigned do\PYGZus{}remote\PYGZus{}wakeup:1;
  unsigned reset\PYGZus{}resume:1;
  unsigned port\PYGZus{}is\PYGZus{}suspended:1;
\PYGZsh{}endif;
  struct wusb\PYGZus{}dev *wusb\PYGZus{}dev;
  int slot\PYGZus{}id;
  enum usb\PYGZus{}device\PYGZus{}removable removable;
  struct usb2\PYGZus{}lpm\PYGZus{}parameters l1\PYGZus{}params;
  struct usb3\PYGZus{}lpm\PYGZus{}parameters u1\PYGZus{}params;
  struct usb3\PYGZus{}lpm\PYGZus{}parameters u2\PYGZus{}params;
  unsigned lpm\PYGZus{}disable\PYGZus{}count;
  u16 hub\PYGZus{}delay;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{devnum}}] \leavevmode
device number; address on a USB bus

\item[{\code{devpath}}] \leavevmode
device ID string for use in messages (e.g., /port/...)

\item[{\code{route}}] \leavevmode
tree topology hex string for use with xHCI

\item[{\code{state}}] \leavevmode
device state: configured, not attached, etc.

\item[{\code{speed}}] \leavevmode
device speed: high/full/low (or error)

\item[{\code{tt}}] \leavevmode
Transaction Translator info; used with low/full speed dev, highspeed hub

\item[{\code{ttport}}] \leavevmode
device port on that tt hub

\item[{\code{toggle}}] \leavevmode
one bit for each endpoint, with ({[}0{]} = IN, {[}1{]} = OUT) endpoints

\item[{\code{parent}}] \leavevmode
our hub, unless we're the root

\item[{\code{bus}}] \leavevmode
bus we're part of

\item[{\code{ep0}}] \leavevmode
endpoint 0 data (default control pipe)

\item[{\code{dev}}] \leavevmode
generic device interface

\item[{\code{descriptor}}] \leavevmode
USB device descriptor

\item[{\code{bos}}] \leavevmode
USB device BOS descriptor set

\item[{\code{config}}] \leavevmode
all of the device's configs

\item[{\code{actconfig}}] \leavevmode
the active configuration

\item[{\code{ep\_in}}] \leavevmode
array of IN endpoints

\item[{\code{ep\_out}}] \leavevmode
array of OUT endpoints

\item[{\code{rawdescriptors}}] \leavevmode
raw descriptors for each config

\item[{\code{bus\_mA}}] \leavevmode
Current available from the bus

\item[{\code{portnum}}] \leavevmode
parent port number (origin 1)

\item[{\code{level}}] \leavevmode
number of USB hub ancestors

\item[{\code{can\_submit}}] \leavevmode
URBs may be submitted

\item[{\code{persist\_enabled}}] \leavevmode
USB\_PERSIST enabled for this device

\item[{\code{have\_langid}}] \leavevmode
whether string\_langid is valid

\item[{\code{authorized}}] \leavevmode
policy has said we can use it;
(user space) policy determines if we authorize this device to be
used or not. By default, wired USB devices are authorized.
WUSB devices are not, until we authorize them from user space.
FIXME -- complete doc

\item[{\code{authenticated}}] \leavevmode
Crypto authentication passed

\item[{\code{wusb}}] \leavevmode
device is Wireless USB

\item[{\code{lpm\_capable}}] \leavevmode
device supports LPM

\item[{\code{usb2\_hw\_lpm\_capable}}] \leavevmode
device can perform USB2 hardware LPM

\item[{\code{usb2\_hw\_lpm\_besl\_capable}}] \leavevmode
device can perform USB2 hardware BESL LPM

\item[{\code{usb2\_hw\_lpm\_enabled}}] \leavevmode
USB2 hardware LPM is enabled

\item[{\code{usb2\_hw\_lpm\_allowed}}] \leavevmode
Userspace allows USB 2.0 LPM to be enabled

\item[{\code{usb3\_lpm\_u1\_enabled}}] \leavevmode
USB3 hardware U1 LPM enabled

\item[{\code{usb3\_lpm\_u2\_enabled}}] \leavevmode
USB3 hardware U2 LPM enabled

\item[{\code{string\_langid}}] \leavevmode
language ID for strings

\item[{\code{product}}] \leavevmode
iProduct string, if present (static)

\item[{\code{manufacturer}}] \leavevmode
iManufacturer string, if present (static)

\item[{\code{serial}}] \leavevmode
iSerialNumber string, if present (static)

\item[{\code{filelist}}] \leavevmode
usbfs files that are open to this device

\item[{\code{maxchild}}] \leavevmode
number of ports if hub

\item[{\code{quirks}}] \leavevmode
quirks of the whole device

\item[{\code{urbnum}}] \leavevmode
number of URBs submitted for the whole device

\item[{\code{active\_duration}}] \leavevmode
total time device is not suspended

\item[{\code{connect\_time}}] \leavevmode
time device was first connected

\item[{\code{do\_remote\_wakeup}}] \leavevmode
remote wakeup should be enabled

\item[{\code{reset\_resume}}] \leavevmode
needs reset instead of resume

\item[{\code{port\_is\_suspended}}] \leavevmode
the upstream port is suspended (L2 or U3)

\item[{\code{wusb\_dev}}] \leavevmode
if this is a Wireless USB device, link to the WUSB
specific data for the device.

\item[{\code{slot\_id}}] \leavevmode
Slot ID assigned by xHCI

\item[{\code{removable}}] \leavevmode
Device can be physically removed from this port

\item[{\code{l1\_params}}] \leavevmode
best effor service latency for USB2 L1 LPM state, and L1 timeout.

\item[{\code{u1\_params}}] \leavevmode
exit latencies for USB3 U1 LPM state, and hub-initiated timeout.

\item[{\code{u2\_params}}] \leavevmode
exit latencies for USB3 U2 LPM state, and hub-initiated timeout.

\item[{\code{lpm\_disable\_count}}] \leavevmode
Ref count used by \code{usb\_disable\_lpm()} and \code{usb\_enable\_lpm()}
to keep track of the number of functions that require USB 3.0 Link Power
Management to be disabled for this usb\_device.  This count should only
be manipulated by those functions, with the bandwidth\_mutex is held.

\item[{\code{hub\_delay}}] \leavevmode
cached value consisting of:
parent-\textgreater{}hub\_delay + wHubDelay + tTPTransmissionDelay (40ns)

\end{description}

\textbf{Description}
\begin{quote}

Will be used as wValue for SetIsochDelay requests.
\end{quote}

\textbf{Notes}

Usbcore drivers should not set usbdev-\textgreater{}state directly.  Instead use
{\hyperref[driver\string-api/usb/usb:c.usb_set_device_state]{\emph{\code{usb\_set\_device\_state()}}}}.
\index{usb\_hub\_for\_each\_child (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_hub_for_each_child}\pysiglinewithargsret{\bfcode{usb\_hub\_for\_each\_child}}{\emph{hdev}, \emph{port1}, \emph{child}}{}
iterate over all child devices on the hub

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{hdev}}] \leavevmode
USB device belonging to the usb hub

\item[{\code{port1}}] \leavevmode
portnum associated with child device

\item[{\code{child}}] \leavevmode
child device pointer

\end{description}
\index{usb\_interface\_claimed (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_interface_claimed}\pysiglinewithargsret{int \bfcode{usb\_interface\_claimed}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ iface}}{}
returns true iff an interface is claimed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_interface * iface}}] \leavevmode
the interface being checked

\end{description}

\textbf{Return}

\code{true} (nonzero) iff the interface is claimed, else \code{false}
(zero).

\textbf{Note}

Callers must own the driver model's usb bus readlock.  So driver
\code{probe()} entries don't need extra locking, but other call contexts
may need to explicitly claim that lock.
\index{usb\_make\_path (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_make_path}\pysiglinewithargsret{int \bfcode{usb\_make\_path}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, char *\emph{ buf}, size\_t\emph{ size}}{}
returns stable device path in the usb tree

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * dev}}] \leavevmode
the device whose path is being constructed

\item[{\code{char * buf}}] \leavevmode
where to put the string

\item[{\code{size\_t size}}] \leavevmode
how big is ``buf''?

\end{description}

\textbf{Return}

Length of the string (\textgreater{} 0) or negative if size was too small.

\textbf{Note}

This identifier is intended to be ``stable'', reflecting physical paths in
hardware such as physical bus addresses for host controllers or ports on
USB hubs.  That makes it stay the same until systems are physically
reconfigured, by re-cabling a tree of USB devices or by moving USB host
controllers.  Adding and removing devices, including virtual root hubs
in host controller driver modules, does not change these path identifiers;
neither does rebooting or re-enumerating.  These are more useful identifiers
than changeable (``unstable'') ones like bus numbers or device addresses.

With a partial exception for devices connected to USB 2.0 root hubs, these
identifiers are also predictable.  So long as the device tree isn't changed,
plugging any USB device into a given hub port always gives it the same path.
Because of the use of ``companion'' controllers, devices connected to ports on
USB 2.0 root hubs (EHCI host controllers) will get one path ID if they are
high speed, and a different one if they are full or low speed.
\index{USB\_DEVICE (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.USB_DEVICE}\pysiglinewithargsret{\bfcode{USB\_DEVICE}}{\emph{vend}, \emph{prod}}{}
macro used to describe a specific usb device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{vend}}] \leavevmode
the 16 bit USB Vendor ID

\item[{\code{prod}}] \leavevmode
the 16 bit USB Product ID

\end{description}

\textbf{Description}

This macro is used to create a struct usb\_device\_id that matches a
specific device.
\index{USB\_DEVICE\_VER (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.USB_DEVICE_VER}\pysiglinewithargsret{\bfcode{USB\_DEVICE\_VER}}{\emph{vend}, \emph{prod}, \emph{lo}, \emph{hi}}{}
describe a specific usb device with a version range

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{vend}}] \leavevmode
the 16 bit USB Vendor ID

\item[{\code{prod}}] \leavevmode
the 16 bit USB Product ID

\item[{\code{lo}}] \leavevmode
the bcdDevice\_lo value

\item[{\code{hi}}] \leavevmode
the bcdDevice\_hi value

\end{description}

\textbf{Description}

This macro is used to create a struct usb\_device\_id that matches a
specific device, with a version range.
\index{USB\_DEVICE\_INTERFACE\_CLASS (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.USB_DEVICE_INTERFACE_CLASS}\pysiglinewithargsret{\bfcode{USB\_DEVICE\_INTERFACE\_CLASS}}{\emph{vend}, \emph{prod}, \emph{cl}}{}
describe a usb device with a specific interface class

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{vend}}] \leavevmode
the 16 bit USB Vendor ID

\item[{\code{prod}}] \leavevmode
the 16 bit USB Product ID

\item[{\code{cl}}] \leavevmode
bInterfaceClass value

\end{description}

\textbf{Description}

This macro is used to create a struct usb\_device\_id that matches a
specific interface class of devices.
\index{USB\_DEVICE\_INTERFACE\_PROTOCOL (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.USB_DEVICE_INTERFACE_PROTOCOL}\pysiglinewithargsret{\bfcode{USB\_DEVICE\_INTERFACE\_PROTOCOL}}{\emph{vend}, \emph{prod}, \emph{pr}}{}
describe a usb device with a specific interface protocol

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{vend}}] \leavevmode
the 16 bit USB Vendor ID

\item[{\code{prod}}] \leavevmode
the 16 bit USB Product ID

\item[{\code{pr}}] \leavevmode
bInterfaceProtocol value

\end{description}

\textbf{Description}

This macro is used to create a struct usb\_device\_id that matches a
specific interface protocol of devices.
\index{USB\_DEVICE\_INTERFACE\_NUMBER (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.USB_DEVICE_INTERFACE_NUMBER}\pysiglinewithargsret{\bfcode{USB\_DEVICE\_INTERFACE\_NUMBER}}{\emph{vend}, \emph{prod}, \emph{num}}{}
describe a usb device with a specific interface number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{vend}}] \leavevmode
the 16 bit USB Vendor ID

\item[{\code{prod}}] \leavevmode
the 16 bit USB Product ID

\item[{\code{num}}] \leavevmode
bInterfaceNumber value

\end{description}

\textbf{Description}

This macro is used to create a struct usb\_device\_id that matches a
specific interface number of devices.
\index{USB\_DEVICE\_INFO (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.USB_DEVICE_INFO}\pysiglinewithargsret{\bfcode{USB\_DEVICE\_INFO}}{\emph{cl}, \emph{sc}, \emph{pr}}{}
macro used to describe a class of usb devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{cl}}] \leavevmode
bDeviceClass value

\item[{\code{sc}}] \leavevmode
bDeviceSubClass value

\item[{\code{pr}}] \leavevmode
bDeviceProtocol value

\end{description}

\textbf{Description}

This macro is used to create a struct usb\_device\_id that matches a
specific class of devices.
\index{USB\_INTERFACE\_INFO (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.USB_INTERFACE_INFO}\pysiglinewithargsret{\bfcode{USB\_INTERFACE\_INFO}}{\emph{cl}, \emph{sc}, \emph{pr}}{}
macro used to describe a class of usb interfaces

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{cl}}] \leavevmode
bInterfaceClass value

\item[{\code{sc}}] \leavevmode
bInterfaceSubClass value

\item[{\code{pr}}] \leavevmode
bInterfaceProtocol value

\end{description}

\textbf{Description}

This macro is used to create a struct usb\_device\_id that matches a
specific class of interfaces.
\index{USB\_DEVICE\_AND\_INTERFACE\_INFO (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.USB_DEVICE_AND_INTERFACE_INFO}\pysiglinewithargsret{\bfcode{USB\_DEVICE\_AND\_INTERFACE\_INFO}}{\emph{vend}, \emph{prod}, \emph{cl}, \emph{sc}, \emph{pr}}{}
describe a specific usb device with a class of usb interfaces

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{vend}}] \leavevmode
the 16 bit USB Vendor ID

\item[{\code{prod}}] \leavevmode
the 16 bit USB Product ID

\item[{\code{cl}}] \leavevmode
bInterfaceClass value

\item[{\code{sc}}] \leavevmode
bInterfaceSubClass value

\item[{\code{pr}}] \leavevmode
bInterfaceProtocol value

\end{description}

\textbf{Description}

This macro is used to create a struct usb\_device\_id that matches a
specific device with a specific class of interfaces.

This is especially useful when explicitly matching devices that have
vendor specific bDeviceClass values, but standards-compliant interfaces.
\index{USB\_VENDOR\_AND\_INTERFACE\_INFO (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.USB_VENDOR_AND_INTERFACE_INFO}\pysiglinewithargsret{\bfcode{USB\_VENDOR\_AND\_INTERFACE\_INFO}}{\emph{vend}, \emph{cl}, \emph{sc}, \emph{pr}}{}
describe a specific usb vendor with a class of usb interfaces

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{vend}}] \leavevmode
the 16 bit USB Vendor ID

\item[{\code{cl}}] \leavevmode
bInterfaceClass value

\item[{\code{sc}}] \leavevmode
bInterfaceSubClass value

\item[{\code{pr}}] \leavevmode
bInterfaceProtocol value

\end{description}

\textbf{Description}

This macro is used to create a struct usb\_device\_id that matches a
specific vendor with a specific class of interfaces.

This is especially useful when explicitly matching devices that have
vendor specific bDeviceClass values, but standards-compliant interfaces.
\index{usbdrv\_wrap (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usbdrv_wrap}\pysigline{struct \bfcode{usbdrv\_wrap}}
wrapper for driver-model structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usbdrv\PYGZus{}wrap \PYGZob{}
  struct device\PYGZus{}driver driver;
  int for\PYGZus{}devices;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{driver}}] \leavevmode
The driver-model core driver structure.

\item[{\code{for\_devices}}] \leavevmode
Non-zero for device drivers, 0 for interface drivers.

\end{description}
\index{usb\_driver (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_driver}\pysigline{struct \bfcode{usb\_driver}}
identifies USB interface driver to usbcore

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}driver \PYGZob{}
  const char *name;
  int (*probe) (struct usb\PYGZus{}interface *intf, const struct usb\PYGZus{}device\PYGZus{}id *id);
  void (*disconnect) (struct usb\PYGZus{}interface *intf);
  int (*unlocked\PYGZus{}ioctl) (struct usb\PYGZus{}interface *intf, unsigned int code, void *buf);
  int (*suspend) (struct usb\PYGZus{}interface *intf, pm\PYGZus{}message\PYGZus{}t message);
  int (*resume) (struct usb\PYGZus{}interface *intf);
  int (*reset\PYGZus{}resume)(struct usb\PYGZus{}interface *intf);
  int (*pre\PYGZus{}reset)(struct usb\PYGZus{}interface *intf);
  int (*post\PYGZus{}reset)(struct usb\PYGZus{}interface *intf);
  const struct usb\PYGZus{}device\PYGZus{}id *id\PYGZus{}table;
  struct usb\PYGZus{}dynids dynids;
  struct usbdrv\PYGZus{}wrap drvwrap;
  unsigned int no\PYGZus{}dynamic\PYGZus{}id:1;
  unsigned int supports\PYGZus{}autosuspend:1;
  unsigned int disable\PYGZus{}hub\PYGZus{}initiated\PYGZus{}lpm:1;
  unsigned int soft\PYGZus{}unbind:1;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
The driver name should be unique among USB drivers,
and should normally be the same as the module name.

\item[{\code{probe}}] \leavevmode
Called to see if the driver is willing to manage a particular
interface on a device.  If it is, probe returns zero and uses
\code{usb\_set\_intfdata()} to associate driver-specific data with the
interface.  It may also use {\hyperref[driver\string-api/usb/usb:c.usb_set_interface]{\emph{\code{usb\_set\_interface()}}}} to specify the
appropriate altsetting.  If unwilling to manage the interface,
return -ENODEV, if genuine IO errors occurred, an appropriate
negative errno value.

\item[{\code{disconnect}}] \leavevmode
Called when the interface is no longer accessible, usually
because its device has been (or is being) disconnected or the
driver module is being unloaded.

\item[{\code{unlocked\_ioctl}}] \leavevmode
Used for drivers that want to talk to userspace through
the ``usbfs'' filesystem.  This lets devices provide ways to
expose information to user space regardless of where they
do (or don't) show up otherwise in the filesystem.

\item[{\code{suspend}}] \leavevmode
Called when the device is going to be suspended by the
system either from system sleep or runtime suspend context. The
return value will be ignored in system sleep context, so do NOT
try to continue using the device if suspend fails in this case.
Instead, let the resume or reset-resume routine recover from
the failure.

\item[{\code{resume}}] \leavevmode
Called when the device is being resumed by the system.

\item[{\code{reset\_resume}}] \leavevmode
Called when the suspended device has been reset instead
of being resumed.

\item[{\code{pre\_reset}}] \leavevmode
Called by {\hyperref[driver\string-api/usb/usb:c.usb_reset_device]{\emph{\code{usb\_reset\_device()}}}} when the device is about to be
reset.  This routine must not return until the driver has no active
URBs for the device, and no more URBs may be submitted until the
post\_reset method is called.

\item[{\code{post\_reset}}] \leavevmode
Called by {\hyperref[driver\string-api/usb/usb:c.usb_reset_device]{\emph{\code{usb\_reset\_device()}}}} after the device
has been reset

\item[{\code{id\_table}}] \leavevmode
USB drivers use ID table to support hotplugging.
Export this with MODULE\_DEVICE\_TABLE(usb,...).  This must be set
or your driver's probe function will never get called.

\item[{\code{dynids}}] \leavevmode
used internally to hold the list of dynamically added device
ids for this driver.

\item[{\code{drvwrap}}] \leavevmode
Driver-model core structure wrapper.

\item[{\code{no\_dynamic\_id}}] \leavevmode
if set to 1, the USB core will not allow dynamic ids to be
added to this driver by preventing the sysfs file from being created.

\item[{\code{supports\_autosuspend}}] \leavevmode
if set to 0, the USB core will not allow autosuspend
for interfaces bound to this driver.

\item[{\code{disable\_hub\_initiated\_lpm}}] \leavevmode
if set to 1, the USB core will not allow hubs
to initiate lower power link state transitions when an idle timeout
occurs.  Device-initiated USB 3.0 link PM will still be allowed.

\item[{\code{soft\_unbind}}] \leavevmode
if set to 1, the USB core will not kill URBs and disable
endpoints before calling the driver's disconnect method.

\end{description}

\textbf{Description}

USB interface drivers must provide a name, \code{probe()} and \code{disconnect()}
methods, and an id\_table.  Other driver fields are optional.

The id\_table is used in hotplugging.  It holds a set of descriptors,
and specialized data may be associated with each entry.  That table
is used by both user and kernel mode hotplugging support.

The \code{probe()} and \code{disconnect()} methods are called in a context where
they can sleep, but they should avoid abusing the privilege.  Most
work to connect to a device should be done when the device is opened,
and undone at the last close.  The disconnect code needs to address
concurrency issues with respect to \code{open()} and \code{close()} methods, as
well as forcing all pending I/O requests to complete (by unlinking
them as necessary, and blocking until the unlinks complete).
\index{usb\_device\_driver (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_device_driver}\pysigline{struct \bfcode{usb\_device\_driver}}
identifies USB device driver to usbcore

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}device\PYGZus{}driver \PYGZob{}
  const char *name;
  int (*probe) (struct usb\PYGZus{}device *udev);
  void (*disconnect) (struct usb\PYGZus{}device *udev);
  int (*suspend) (struct usb\PYGZus{}device *udev, pm\PYGZus{}message\PYGZus{}t message);
  int (*resume) (struct usb\PYGZus{}device *udev, pm\PYGZus{}message\PYGZus{}t message);
  struct usbdrv\PYGZus{}wrap drvwrap;
  unsigned int supports\PYGZus{}autosuspend:1;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
The driver name should be unique among USB drivers,
and should normally be the same as the module name.

\item[{\code{probe}}] \leavevmode
Called to see if the driver is willing to manage a particular
device.  If it is, probe returns zero and uses \code{dev\_set\_drvdata()}
to associate driver-specific data with the device.  If unwilling
to manage the device, return a negative errno value.

\item[{\code{disconnect}}] \leavevmode
Called when the device is no longer accessible, usually
because it has been (or is being) disconnected or the driver's
module is being unloaded.

\item[{\code{suspend}}] \leavevmode
Called when the device is going to be suspended by the system.

\item[{\code{resume}}] \leavevmode
Called when the device is being resumed by the system.

\item[{\code{drvwrap}}] \leavevmode
Driver-model core structure wrapper.

\item[{\code{supports\_autosuspend}}] \leavevmode
if set to 0, the USB core will not allow autosuspend
for devices bound to this driver.

\end{description}

\textbf{Description}

USB drivers must provide all the fields listed above except drvwrap.
\index{usb\_class\_driver (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_class_driver}\pysigline{struct \bfcode{usb\_class\_driver}}
identifies a USB driver that wants to use the USB major number

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}class\PYGZus{}driver \PYGZob{}
  char *name;
  char *(*devnode)(struct device *dev, umode\PYGZus{}t *mode);
  const struct file\PYGZus{}operations *fops;
  int minor\PYGZus{}base;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
the usb class device name for this driver.  Will show up in sysfs.

\item[{\code{devnode}}] \leavevmode
Callback to provide a naming hint for a possible
device node to create.

\item[{\code{fops}}] \leavevmode
pointer to the struct file\_operations of this driver.

\item[{\code{minor\_base}}] \leavevmode
the start of the minor range for this driver.

\end{description}

\textbf{Description}

This structure is used for the {\hyperref[driver\string-api/usb/usb:c.usb_register_dev]{\emph{\code{usb\_register\_dev()}}}} and
{\hyperref[driver\string-api/usb/usb:c.usb_deregister_dev]{\emph{\code{usb\_deregister\_dev()}}}} functions, to consolidate a number of the
parameters used for them.
\index{module\_usb\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.module_usb_driver}\pysiglinewithargsret{\bfcode{module\_usb\_driver}}{\emph{\_\_usb\_driver}}{}
Helper macro for registering a USB driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_usb\_driver}}] \leavevmode
usb\_driver struct

\end{description}

\textbf{Description}

Helper macro for USB drivers which do not do anything special in module
init/exit. This eliminates a lot of boilerplate. Each module may only
use this macro once, and calling it replaces {\hyperref[driver\string-api/basics:c.module_init]{\emph{\code{module\_init()}}}} and {\hyperref[driver\string-api/basics:c.module_exit]{\emph{\code{module\_exit()}}}}
\index{urb (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.urb}\pysigline{struct \bfcode{urb}}
USB Request Block

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct urb \PYGZob{}
  struct list\PYGZus{}head urb\PYGZus{}list;
  struct list\PYGZus{}head anchor\PYGZus{}list;
  struct usb\PYGZus{}anchor *anchor;
  struct usb\PYGZus{}device *dev;
  struct usb\PYGZus{}host\PYGZus{}endpoint *ep;
  unsigned int pipe;
  unsigned int stream\PYGZus{}id;
  int status;
  unsigned int transfer\PYGZus{}flags;
  void *transfer\PYGZus{}buffer;
  dma\PYGZus{}addr\PYGZus{}t transfer\PYGZus{}dma;
  struct scatterlist *sg;
  int num\PYGZus{}mapped\PYGZus{}sgs;
  int num\PYGZus{}sgs;
  u32 transfer\PYGZus{}buffer\PYGZus{}length;
  u32 actual\PYGZus{}length;
  unsigned char *setup\PYGZus{}packet;
  dma\PYGZus{}addr\PYGZus{}t setup\PYGZus{}dma;
  int start\PYGZus{}frame;
  int number\PYGZus{}of\PYGZus{}packets;
  int interval;
  int error\PYGZus{}count;
  void *context;
  usb\PYGZus{}complete\PYGZus{}t complete;
  struct usb\PYGZus{}iso\PYGZus{}packet\PYGZus{}descriptor iso\PYGZus{}frame\PYGZus{}desc[0];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{urb\_list}}] \leavevmode
For use by current owner of the URB.

\item[{\code{anchor\_list}}] \leavevmode
membership in the list of an anchor

\item[{\code{anchor}}] \leavevmode
to anchor URBs to a common mooring

\item[{\code{dev}}] \leavevmode
Identifies the USB device to perform the request.

\item[{\code{ep}}] \leavevmode
Points to the endpoint's data structure.  Will eventually
replace \textbf{pipe}.

\item[{\code{pipe}}] \leavevmode
Holds endpoint number, direction, type, and more.
Create these values with the eight macros available;
usb\_\{snd,rcv\}TYPEpipe(dev,endpoint), where the TYPE is ``ctrl''
(control), ``bulk'', ``int'' (interrupt), or ``iso'' (isochronous).
For example \code{usb\_sndbulkpipe()} or \code{usb\_rcvintpipe()}.  Endpoint
numbers range from zero to fifteen.  Note that ``in'' endpoint two
is a different endpoint (and pipe) from ``out'' endpoint two.
The current configuration controls the existence, type, and
maximum packet size of any given endpoint.

\item[{\code{stream\_id}}] \leavevmode
the endpoint's stream ID for bulk streams

\item[{\code{status}}] \leavevmode
This is read in non-iso completion functions to get the
status of the particular request.  ISO requests only use it
to tell whether the URB was unlinked; detailed status for
each frame is in the fields of the iso\_frame-desc.

\item[{\code{transfer\_flags}}] \leavevmode
A variety of flags may be used to affect how URB
submission, unlinking, or operation are handled.  Different
kinds of URB can use different flags.

\item[{\code{transfer\_buffer}}] \leavevmode
This identifies the buffer to (or from) which the I/O
request will be performed unless URB\_NO\_TRANSFER\_DMA\_MAP is set
(however, do not leave garbage in transfer\_buffer even then).
This buffer must be suitable for DMA; allocate it with
\code{kmalloc()} or equivalent.  For transfers to ``in'' endpoints, contents
of this buffer will be modified.  This buffer is used for the data
stage of control transfers.

\item[{\code{transfer\_dma}}] \leavevmode
When transfer\_flags includes URB\_NO\_TRANSFER\_DMA\_MAP,
the device driver is saying that it provided this DMA address,
which the host controller driver should use in preference to the
transfer\_buffer.

\item[{\code{sg}}] \leavevmode
scatter gather buffer list, the buffer size of each element in
the list (except the last) must be divisible by the endpoint's
max packet size if no\_sg\_constraint isn't set in `struct usb\_bus'

\item[{\code{num\_mapped\_sgs}}] \leavevmode
(internal) number of mapped sg entries

\item[{\code{num\_sgs}}] \leavevmode
number of entries in the sg list

\item[{\code{transfer\_buffer\_length}}] \leavevmode
How big is transfer\_buffer.  The transfer may
be broken up into chunks according to the current maximum packet
size for the endpoint, which is a function of the configuration
and is encoded in the pipe.  When the length is zero, neither
transfer\_buffer nor transfer\_dma is used.

\item[{\code{actual\_length}}] \leavevmode
This is read in non-iso completion functions, and
it tells how many bytes (out of transfer\_buffer\_length) were
transferred.  It will normally be the same as requested, unless
either an error was reported or a short read was performed.
The URB\_SHORT\_NOT\_OK transfer flag may be used to make such
short reads be reported as errors.

\item[{\code{setup\_packet}}] \leavevmode
Only used for control transfers, this points to eight bytes
of setup data.  Control transfers always start by sending this data
to the device.  Then transfer\_buffer is read or written, if needed.

\item[{\code{setup\_dma}}] \leavevmode
DMA pointer for the setup packet.  The caller must not use
this field; setup\_packet must point to a valid buffer.

\item[{\code{start\_frame}}] \leavevmode
Returns the initial frame for isochronous transfers.

\item[{\code{number\_of\_packets}}] \leavevmode
Lists the number of ISO transfer buffers.

\item[{\code{interval}}] \leavevmode
Specifies the polling interval for interrupt or isochronous
transfers.  The units are frames (milliseconds) for full and low
speed devices, and microframes (1/8 millisecond) for highspeed
and SuperSpeed devices.

\item[{\code{error\_count}}] \leavevmode
Returns the number of ISO transfers that reported errors.

\item[{\code{context}}] \leavevmode
For use in completion functions.  This normally points to
request-specific driver context.

\item[{\code{complete}}] \leavevmode
Completion handler. This URB is passed as the parameter to the
completion function.  The completion function may then do what
it likes with the URB, including resubmitting or freeing it.

\item[{\code{iso\_frame\_desc}}] \leavevmode
Used to provide arrays of ISO transfer buffers and to
collect the transfer status for each buffer.

\end{description}

\textbf{Description}

This structure identifies USB transfer requests.  URBs must be allocated by
calling {\hyperref[driver\string-api/usb/usb:c.usb_alloc_urb]{\emph{\code{usb\_alloc\_urb()}}}} and freed with a call to {\hyperref[driver\string-api/usb/usb:c.usb_free_urb]{\emph{\code{usb\_free\_urb()}}}}.
Initialization may be done using various usb\_fill\_*:c:func:\emph{\_urb()} functions.  URBs
are submitted using {\hyperref[driver\string-api/usb/usb:c.usb_submit_urb]{\emph{\code{usb\_submit\_urb()}}}}, and pending requests may be canceled
using {\hyperref[driver\string-api/usb/usb:c.usb_unlink_urb]{\emph{\code{usb\_unlink\_urb()}}}} or {\hyperref[driver\string-api/usb/usb:c.usb_kill_urb]{\emph{\code{usb\_kill\_urb()}}}}.

Data Transfer Buffers:

Normally drivers provide I/O buffers allocated with \code{kmalloc()} or otherwise
taken from the general page pool.  That is provided by transfer\_buffer
(control requests also use setup\_packet), and host controller drivers
perform a dma mapping (and unmapping) for each buffer transferred.  Those
mapping operations can be expensive on some platforms (perhaps using a dma
bounce buffer or talking to an IOMMU),
although they're cheap on commodity x86 and ppc hardware.

Alternatively, drivers may pass the URB\_NO\_TRANSFER\_DMA\_MAP transfer flag,
which tells the host controller driver that no such mapping is needed for
the transfer\_buffer since
the device driver is DMA-aware.  For example, a device driver might
allocate a DMA buffer with {\hyperref[driver\string-api/usb/usb:c.usb_alloc_coherent]{\emph{\code{usb\_alloc\_coherent()}}}} or call {\hyperref[driver\string-api/usb/usb:c.usb_buffer_map]{\emph{\code{usb\_buffer\_map()}}}}.
When this transfer flag is provided, host controller drivers will
attempt to use the dma address found in the transfer\_dma
field rather than determining a dma address themselves.

Note that transfer\_buffer must still be set if the controller
does not support DMA (as indicated by bus.uses\_dma) and when talking
to root hub. If you have to trasfer between highmem zone and the device
on such controller, create a bounce buffer or bail out with an error.
If transfer\_buffer cannot be set (is in highmem) and the controller is DMA
capable, assign NULL to it, so that usbmon knows not to use the value.
The setup\_packet must always be set, so it cannot be located in highmem.

Initialization:

All URBs submitted must initialize the dev, pipe, transfer\_flags (may be
zero), and complete fields.  All URBs must also initialize
transfer\_buffer and transfer\_buffer\_length.  They may provide the
URB\_SHORT\_NOT\_OK transfer flag, indicating that short reads are
to be treated as errors; that flag is invalid for write requests.

Bulk URBs may
use the URB\_ZERO\_PACKET transfer flag, indicating that bulk OUT transfers
should always terminate with a short packet, even if it means adding an
extra zero length packet.

Control URBs must provide a valid pointer in the setup\_packet field.
Unlike the transfer\_buffer, the setup\_packet may not be mapped for DMA
beforehand.

Interrupt URBs must provide an interval, saying how often (in milliseconds
or, for highspeed devices, 125 microsecond units)
to poll for transfers.  After the URB has been submitted, the interval
field reflects how the transfer was actually scheduled.
The polling interval may be more frequent than requested.
For example, some controllers have a maximum interval of 32 milliseconds,
while others support intervals of up to 1024 milliseconds.
Isochronous URBs also have transfer intervals.  (Note that for isochronous
endpoints, as well as high speed interrupt endpoints, the encoding of
the transfer interval in the endpoint descriptor is logarithmic.
Device drivers must convert that value to linear units themselves.)

If an isochronous endpoint queue isn't already running, the host
controller will schedule a new URB to start as soon as bandwidth
utilization allows.  If the queue is running then a new URB will be
scheduled to start in the first transfer slot following the end of the
preceding URB, if that slot has not already expired.  If the slot has
expired (which can happen when IRQ delivery is delayed for a long time),
the scheduling behavior depends on the URB\_ISO\_ASAP flag.  If the flag
is clear then the URB will be scheduled to start in the expired slot,
implying that some of its packets will not be transferred; if the flag
is set then the URB will be scheduled in the first unexpired slot,
breaking the queue's synchronization.  Upon URB completion, the
start\_frame field will be set to the (micro)frame number in which the
transfer was scheduled.  Ranges for frame counter values are HC-specific
and can go from as low as 256 to as high as 65536 frames.

Isochronous URBs have a different data transfer model, in part because
the quality of service is only ``best effort''.  Callers provide specially
allocated URBs, with number\_of\_packets worth of iso\_frame\_desc structures
at the end.  Each such packet is an individual ISO transfer.  Isochronous
URBs are normally queued, submitted by drivers to arrange that
transfers are at least double buffered, and then explicitly resubmitted
in completion handlers, so
that data (such as audio or video) streams at as constant a rate as the
host controller scheduler can support.

Completion Callbacks:

The completion callback is made \code{in\_interrupt()}, and one of the first
things that a completion handler should do is check the status field.
The status field is provided for all URBs.  It is used to report
unlinked URBs, and status for all non-ISO transfers.  It should not
be examined before the URB is returned to the completion handler.

The context field is normally used to link URBs back to the relevant
driver or request state.

When the completion callback is invoked for non-isochronous URBs, the
actual\_length field tells how many bytes were transferred.  This field
is updated even when the URB terminated with an error or was unlinked.

ISO transfer status is reported in the status and actual\_length fields
of the iso\_frame\_desc array, and the number of errors is reported in
error\_count.  Completion callbacks for ISO transfers will normally
(re)submit URBs to ensure a constant transfer rate.

Note that even fields marked ``public'' should not be touched by the driver
when the urb is owned by the hcd, that is, since the call to
{\hyperref[driver\string-api/usb/usb:c.usb_submit_urb]{\emph{\code{usb\_submit\_urb()}}}} till the entry into the completion routine.
\index{usb\_fill\_control\_urb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_fill_control_urb}\pysiglinewithargsret{void \bfcode{usb\_fill\_control\_urb}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}, struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, unsigned int\emph{ pipe}, unsigned char *\emph{ setup\_packet}, void *\emph{ transfer\_buffer}, int\emph{ buffer\_length}, usb\_complete\_t\emph{ complete\_fn}, void *\emph{ context}}{}
initializes a control urb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
pointer to the urb to initialize.

\item[{\code{struct usb\_device * dev}}] \leavevmode
pointer to the struct usb\_device for this urb.

\item[{\code{unsigned int pipe}}] \leavevmode
the endpoint pipe

\item[{\code{unsigned char * setup\_packet}}] \leavevmode
pointer to the setup\_packet buffer

\item[{\code{void * transfer\_buffer}}] \leavevmode
pointer to the transfer buffer

\item[{\code{int buffer\_length}}] \leavevmode
length of the transfer buffer

\item[{\code{usb\_complete\_t complete\_fn}}] \leavevmode
pointer to the usb\_complete\_t function

\item[{\code{void * context}}] \leavevmode
what to set the urb context to.

\end{description}

\textbf{Description}

Initializes a control urb with the proper information needed to submit
it to a device.
\index{usb\_fill\_bulk\_urb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_fill_bulk_urb}\pysiglinewithargsret{void \bfcode{usb\_fill\_bulk\_urb}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}, struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, unsigned int\emph{ pipe}, void *\emph{ transfer\_buffer}, int\emph{ buffer\_length}, usb\_complete\_t\emph{ complete\_fn}, void *\emph{ context}}{}
macro to help initialize a bulk urb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
pointer to the urb to initialize.

\item[{\code{struct usb\_device * dev}}] \leavevmode
pointer to the struct usb\_device for this urb.

\item[{\code{unsigned int pipe}}] \leavevmode
the endpoint pipe

\item[{\code{void * transfer\_buffer}}] \leavevmode
pointer to the transfer buffer

\item[{\code{int buffer\_length}}] \leavevmode
length of the transfer buffer

\item[{\code{usb\_complete\_t complete\_fn}}] \leavevmode
pointer to the usb\_complete\_t function

\item[{\code{void * context}}] \leavevmode
what to set the urb context to.

\end{description}

\textbf{Description}

Initializes a bulk urb with the proper information needed to submit it
to a device.
\index{usb\_fill\_int\_urb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_fill_int_urb}\pysiglinewithargsret{void \bfcode{usb\_fill\_int\_urb}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}, struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, unsigned int\emph{ pipe}, void *\emph{ transfer\_buffer}, int\emph{ buffer\_length}, usb\_complete\_t\emph{ complete\_fn}, void *\emph{ context}, int\emph{ interval}}{}
macro to help initialize a interrupt urb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
pointer to the urb to initialize.

\item[{\code{struct usb\_device * dev}}] \leavevmode
pointer to the struct usb\_device for this urb.

\item[{\code{unsigned int pipe}}] \leavevmode
the endpoint pipe

\item[{\code{void * transfer\_buffer}}] \leavevmode
pointer to the transfer buffer

\item[{\code{int buffer\_length}}] \leavevmode
length of the transfer buffer

\item[{\code{usb\_complete\_t complete\_fn}}] \leavevmode
pointer to the usb\_complete\_t function

\item[{\code{void * context}}] \leavevmode
what to set the urb context to.

\item[{\code{int interval}}] \leavevmode
what to set the urb interval to, encoded like
the endpoint descriptor's bInterval value.

\end{description}

\textbf{Description}

Initializes a interrupt urb with the proper information needed to submit
it to a device.

Note that High Speed and SuperSpeed(+) interrupt endpoints use a logarithmic
encoding of the endpoint interval, and express polling intervals in
microframes (eight per millisecond) rather than in frames (one per
millisecond).

Wireless USB also uses the logarithmic encoding, but specifies it in units of
128us instead of 125us.  For Wireless USB devices, the interval is passed
through to the host controller, rather than being translated into microframe
units.
\index{usb\_urb\_dir\_in (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_urb_dir_in}\pysiglinewithargsret{int \bfcode{usb\_urb\_dir\_in}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}}{}
check if an URB describes an IN transfer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
URB to be checked

\end{description}

\textbf{Return}

1 if \textbf{urb} describes an IN transfer (device-to-host),
otherwise 0.
\index{usb\_urb\_dir\_out (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_urb_dir_out}\pysiglinewithargsret{int \bfcode{usb\_urb\_dir\_out}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}}{}
check if an URB describes an OUT transfer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
URB to be checked

\end{description}

\textbf{Return}

1 if \textbf{urb} describes an OUT transfer (host-to-device),
otherwise 0.
\index{usb\_sg\_request (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_sg_request}\pysigline{struct \bfcode{usb\_sg\_request}}
support for scatter/gather I/O

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}sg\PYGZus{}request \PYGZob{}
  int status;
  size\PYGZus{}t bytes;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{status}}] \leavevmode
zero indicates success, else negative errno

\item[{\code{bytes}}] \leavevmode
counts bytes transferred.

\end{description}

\textbf{Description}

These requests are initialized using {\hyperref[driver\string-api/usb/usb:c.usb_sg_init]{\emph{\code{usb\_sg\_init()}}}}, and then are used
as request handles passed to {\hyperref[driver\string-api/usb/usb:c.usb_sg_wait]{\emph{\code{usb\_sg\_wait()}}}} or {\hyperref[driver\string-api/usb/usb:c.usb_sg_cancel]{\emph{\code{usb\_sg\_cancel()}}}}.  Most
members of the request object aren't for driver access.

The status and bytecount values are valid only after {\hyperref[driver\string-api/usb/usb:c.usb_sg_wait]{\emph{\code{usb\_sg\_wait()}}}}
returns.  If the status is zero, then the bytecount matches the total
from the request.

After an error completion, drivers may need to clear a halt condition
on the endpoint.


\subsection{USB Core APIs}
\label{driver-api/usb/usb:usb-core-apis}
There are two basic I/O models in the USB API. The most elemental one is
asynchronous: drivers submit requests in the form of an URB, and the
URB's completion callback handles the next step. All USB transfer types
support that model, although there are special cases for control URBs
(which always have setup and status stages, but may not have a data
stage) and isochronous URBs (which allow large packets and include
per-packet fault reports). Built on top of that is synchronous API
support, where a driver calls a routine that allocates one or more URBs,
submits them, and waits until they complete. There are synchronous
wrappers for single-buffer control and bulk transfers (which are awkward
to use in some driver disconnect scenarios), and for scatterlist based
streaming i/o (bulk or interrupt).

USB drivers need to provide buffers that can be used for DMA, although
they don't necessarily need to provide the DMA mapping themselves. There
are APIs to use used when allocating DMA buffers, which can prevent use
of bounce buffers on some systems. In some cases, drivers may be able to
rely on 64bit DMA to eliminate another kind of bounce buffer.
\index{usb\_init\_urb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_init_urb}\pysiglinewithargsret{void \bfcode{usb\_init\_urb}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}}{}
initializes a urb so that it can be used by a USB driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
pointer to the urb to initialize

\end{description}

\textbf{Description}

Initializes a urb so that the USB subsystem can use it properly.

If a urb is created with a call to {\hyperref[driver\string-api/usb/usb:c.usb_alloc_urb]{\emph{\code{usb\_alloc\_urb()}}}} it is not
necessary to call this function.  Only use this if you allocate the
space for a struct urb on your own.  If you call this function, be
careful when freeing the memory for your urb that it is no longer in
use by the USB core.

Only use this function if you \_really\_ understand what you are doing.
\index{usb\_alloc\_urb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_alloc_urb}\pysiglinewithargsret{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} * \bfcode{usb\_alloc\_urb}}{int\emph{ iso\_packets}, gfp\_t\emph{ mem\_flags}}{}
creates a new urb for a USB driver to use

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int iso\_packets}}] \leavevmode
number of iso packets for this urb

\item[{\code{gfp\_t mem\_flags}}] \leavevmode
the type of memory to allocate, see \code{kmalloc()} for a list of
valid options for this.

\end{description}

\textbf{Description}

Creates an urb for the USB driver to use, initializes a few internal
structures, increments the usage counter, and returns a pointer to it.

If the driver want to use this urb for interrupt, control, or bulk
endpoints, pass `0' as the number of iso packets.

The driver must call {\hyperref[driver\string-api/usb/usb:c.usb_free_urb]{\emph{\code{usb\_free\_urb()}}}} when it is finished with the urb.

\textbf{Return}

A pointer to the new urb, or \code{NULL} if no memory is available.
\index{usb\_free\_urb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_free_urb}\pysiglinewithargsret{void \bfcode{usb\_free\_urb}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}}{}
frees the memory used by a urb when all users of it are finished

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
pointer to the urb to free, may be NULL

\end{description}

\textbf{Description}

Must be called when a user of a urb is finished with it.  When the last user
of the urb calls this function, the memory of the urb is freed.

\textbf{Note}

The transfer buffer associated with the urb is not freed unless the
URB\_FREE\_BUFFER transfer flag is set.
\index{usb\_get\_urb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_get_urb}\pysiglinewithargsret{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} * \bfcode{usb\_get\_urb}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}}{}
increments the reference count of the urb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
pointer to the urb to modify, may be NULL

\end{description}

\textbf{Description}

This must be  called whenever a urb is transferred from a device driver to a
host controller driver.  This allows proper reference counting to happen
for urbs.

\textbf{Return}

A pointer to the urb with the incremented reference counter.
\index{usb\_anchor\_urb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_anchor_urb}\pysiglinewithargsret{void \bfcode{usb\_anchor\_urb}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}, struct usb\_anchor *\emph{ anchor}}{}
anchors an URB while it is processed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
pointer to the urb to anchor

\item[{\code{struct usb\_anchor * anchor}}] \leavevmode
pointer to the anchor

\end{description}

\textbf{Description}

This can be called to have access to URBs which are to be executed
without bothering to track them
\index{usb\_unanchor\_urb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_unanchor_urb}\pysiglinewithargsret{void \bfcode{usb\_unanchor\_urb}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}}{}
unanchors an URB

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
pointer to the urb to anchor

\end{description}

\textbf{Description}

Call this to stop the system keeping track of this URB
\index{usb\_urb\_ep\_type\_check (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_urb_ep_type_check}\pysiglinewithargsret{int \bfcode{usb\_urb\_ep\_type\_check}}{const struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}}{}
sanity check of endpoint in the given urb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct urb * urb}}] \leavevmode
urb to be checked

\end{description}

\textbf{Description}

This performs a light-weight sanity check for the endpoint in the
given urb.  It returns 0 if the urb contains a valid endpoint, otherwise
a negative error code.
\index{usb\_submit\_urb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_submit_urb}\pysiglinewithargsret{int \bfcode{usb\_submit\_urb}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}, gfp\_t\emph{ mem\_flags}}{}
issue an asynchronous transfer request for an endpoint

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
pointer to the urb describing the request

\item[{\code{gfp\_t mem\_flags}}] \leavevmode
the type of memory to allocate, see \code{kmalloc()} for a list
of valid options for this.

\end{description}

\textbf{Description}

This submits a transfer request, and transfers control of the URB
describing that request to the USB subsystem.  Request completion will
be indicated later, asynchronously, by calling the completion handler.
The three types of completion are success, error, and unlink
(a software-induced fault, also called ``request cancellation'').

URBs may be submitted in interrupt context.

The caller must have correctly initialized the URB before submitting
it.  Functions such as {\hyperref[driver\string-api/usb/usb:c.usb_fill_bulk_urb]{\emph{\code{usb\_fill\_bulk\_urb()}}}} and {\hyperref[driver\string-api/usb/usb:c.usb_fill_control_urb]{\emph{\code{usb\_fill\_control\_urb()}}}} are
available to ensure that most fields are correctly initialized, for
the particular kind of transfer, although they will not initialize
any transfer flags.

If the submission is successful, the \code{complete()} callback from the URB
will be called exactly once, when the USB core and Host Controller Driver
(HCD) are finished with the URB.  When the completion function is called,
control of the URB is returned to the device driver which issued the
request.  The completion handler may then immediately free or reuse that
URB.

With few exceptions, USB device drivers should never access URB fields
provided by usbcore or the HCD until its \code{complete()} is called.
The exceptions relate to periodic transfer scheduling.  For both
interrupt and isochronous urbs, as part of successful URB submission
urb-\textgreater{}interval is modified to reflect the actual transfer period used
(normally some power of two units).  And for isochronous urbs,
urb-\textgreater{}start\_frame is modified to reflect when the URB's transfers were
scheduled to start.

Not all isochronous transfer scheduling policies will work, but most
host controller drivers should easily handle ISO queues going from now
until 10-200 msec into the future.  Drivers should try to keep at
least one or two msec of data in the queue; many controllers require
that new transfers start at least 1 msec in the future when they are
added.  If the driver is unable to keep up and the queue empties out,
the behavior for new submissions is governed by the URB\_ISO\_ASAP flag.
If the flag is set, or if the queue is idle, then the URB is always
assigned to the first available (and not yet expired) slot in the
endpoint's schedule.  If the flag is not set and the queue is active
then the URB is always assigned to the next slot in the schedule
following the end of the endpoint's previous URB, even if that slot is
in the past.  When a packet is assigned in this way to a slot that has
already expired, the packet is not transmitted and the corresponding
usb\_iso\_packet\_descriptor's status field will return -EXDEV.  If this
would happen to all the packets in the URB, submission fails with a
-EXDEV error code.

For control endpoints, the synchronous {\hyperref[driver\string-api/usb/usb:c.usb_control_msg]{\emph{\code{usb\_control\_msg()}}}} call is
often used (in non-interrupt context) instead of this call.
That is often used through convenience wrappers, for the requests
that are standardized in the USB 2.0 specification.  For bulk
endpoints, a synchronous {\hyperref[driver\string-api/usb/usb:c.usb_bulk_msg]{\emph{\code{usb\_bulk\_msg()}}}} call is available.

\textbf{Return}

0 on successful submissions. A negative error number otherwise.

Request Queuing:

URBs may be submitted to endpoints before previous ones complete, to
minimize the impact of interrupt latencies and system overhead on data
throughput.  With that queuing policy, an endpoint's queue would never
be empty.  This is required for continuous isochronous data streams,
and may also be required for some kinds of interrupt transfers. Such
queuing also maximizes bandwidth utilization by letting USB controllers
start work on later requests before driver software has finished the
completion processing for earlier (successful) requests.

As of Linux 2.6, all USB endpoint transfer queues support depths greater
than one.  This was previously a HCD-specific behavior, except for ISO
transfers.  Non-isochronous endpoint queues are inactive during cleanup
after faults (transfer errors or cancellation).

Reserved Bandwidth Transfers:

Periodic transfers (interrupt or isochronous) are performed repeatedly,
using the interval specified in the urb.  Submitting the first urb to
the endpoint reserves the bandwidth necessary to make those transfers.
If the USB subsystem can't allocate sufficient bandwidth to perform
the periodic request, submitting such a periodic request should fail.

For devices under xHCI, the bandwidth is reserved at configuration time, or
when the alt setting is selected.  If there is not enough bus bandwidth, the
configuration/alt setting request will fail.  Therefore, submissions to
periodic endpoints on devices under xHCI should never fail due to bandwidth
constraints.

Device drivers must explicitly request that repetition, by ensuring that
some URB is always on the endpoint's queue (except possibly for short
periods during completion callbacks).  When there is no longer an urb
queued, the endpoint's bandwidth reservation is canceled.  This means
drivers can use their completion handlers to ensure they keep bandwidth
they need, by reinitializing and resubmitting the just-completed urb
until the driver longer needs that periodic bandwidth.

Memory Flags:

The general rules for how to decide which mem\_flags to use
are the same as for kmalloc.  There are four
different possible values; GFP\_KERNEL, GFP\_NOFS, GFP\_NOIO and
GFP\_ATOMIC.

GFP\_NOFS is not ever used, as it has not been implemented yet.
\begin{description}
\item[{GFP\_ATOMIC is used when}] \leavevmode\begin{enumerate}
\item {} 
you are inside a completion handler, an interrupt, bottom half,
tasklet or timer, or

\item {} 
you are holding a spinlock or rwlock (does not apply to
semaphores), or

\item {} 
current-\textgreater{}state != TASK\_RUNNING, this is the case only after
you've changed it.

\end{enumerate}

\end{description}

GFP\_NOIO is used in the block io path and error handling of storage
devices.

All other situations use GFP\_KERNEL.
\begin{description}
\item[{Some more specific rules for mem\_flags can be inferred, such as}] \leavevmode\begin{enumerate}
\item {} 
start\_xmit, timeout, and receive methods of network drivers must
use GFP\_ATOMIC (they are called with a spinlock held);

\item {} 
queuecommand methods of scsi drivers must use GFP\_ATOMIC (also
called with a spinlock held);

\item {} 
If you use a kernel thread with a network driver you must use
GFP\_NOIO, unless (b) or (c) apply;

\item {} 
after you have done a \code{down()} you can use GFP\_KERNEL, unless (b) or (c)
apply or your are in a storage driver's block io path;

\item {} 
USB probe and disconnect can use GFP\_KERNEL unless (b) or (c) apply; and

\item {} 
changing firmware on a running storage or net device uses
GFP\_NOIO, unless b) or c) apply

\end{enumerate}

\end{description}
\index{usb\_unlink\_urb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_unlink_urb}\pysiglinewithargsret{int \bfcode{usb\_unlink\_urb}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}}{}
abort/cancel a transfer request for an endpoint

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
pointer to urb describing a previously submitted request,
may be NULL

\end{description}

\textbf{Description}

This routine cancels an in-progress request.  URBs complete only once
per submission, and may be canceled only once per submission.
Successful cancellation means termination of \textbf{urb} will be expedited
and the completion handler will be called with a status code
indicating that the request has been canceled (rather than any other
code).

Drivers should not call this routine or related routines, such as
{\hyperref[driver\string-api/usb/usb:c.usb_kill_urb]{\emph{\code{usb\_kill\_urb()}}}} or {\hyperref[driver\string-api/usb/usb:c.usb_unlink_anchored_urbs]{\emph{\code{usb\_unlink\_anchored\_urbs()}}}}, after their disconnect
method has returned.  The disconnect function should synchronize with
a driver's I/O routines to insure that all URB-related activity has
completed before it returns.

This request is asynchronous, however the HCD might call the -\textgreater{}:c:func:\emph{complete()}
callback during unlink. Therefore when drivers call {\hyperref[driver\string-api/usb/usb:c.usb_unlink_urb]{\emph{\code{usb\_unlink\_urb()}}}}, they
must not hold any locks that may be taken by the completion function.
Success is indicated by returning -EINPROGRESS, at which time the URB will
probably not yet have been given back to the device driver. When it is
eventually called, the completion function will see \textbf{urb}-\textgreater{}status ==
-ECONNRESET.
Failure is indicated by {\hyperref[driver\string-api/usb/usb:c.usb_unlink_urb]{\emph{\code{usb\_unlink\_urb()}}}} returning any other value.
Unlinking will fail when \textbf{urb} is not currently ``linked'' (i.e., it was
never submitted, or it was unlinked before, or the hardware is already
finished with it), even if the completion handler has not yet run.

The URB must not be deallocated while this routine is running.  In
particular, when a driver calls this routine, it must insure that the
completion handler cannot deallocate the URB.

\textbf{Return}

-EINPROGRESS on success. See description for other values on
failure.

Unlinking and Endpoint Queues:

{[}The behaviors and guarantees described below do not apply to virtual
root hubs but only to endpoint queues for physical USB devices.{]}

Host Controller Drivers (HCDs) place all the URBs for a particular
endpoint in a queue.  Normally the queue advances as the controller
hardware processes each request.  But when an URB terminates with an
error its queue generally stops (see below), at least until that URB's
completion routine returns.  It is guaranteed that a stopped queue
will not restart until all its unlinked URBs have been fully retired,
with their completion routines run, even if that's not until some time
after the original completion handler returns.  The same behavior and
guarantee apply when an URB terminates because it was unlinked.

Bulk and interrupt endpoint queues are guaranteed to stop whenever an
URB terminates with any sort of error, including -ECONNRESET, -ENOENT,
and -EREMOTEIO.  Control endpoint queues behave the same way except
that they are not guaranteed to stop for -EREMOTEIO errors.  Queues
for isochronous endpoints are treated differently, because they must
advance at fixed rates.  Such queues do not stop when an URB
encounters an error or is unlinked.  An unlinked isochronous URB may
leave a gap in the stream of packets; it is undefined whether such
gaps can be filled in.

Note that early termination of an URB because a short packet was
received will generate a -EREMOTEIO error if and only if the
URB\_SHORT\_NOT\_OK flag is set.  By setting this flag, USB device
drivers can build deep queues for large or complex bulk transfers
and clean them up reliably after any sort of aborted transfer by
unlinking all pending URBs at the first fault.

When a control URB terminates with an error other than -EREMOTEIO, it
is quite likely that the status stage of the transfer will not take
place.
\index{usb\_kill\_urb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_kill_urb}\pysiglinewithargsret{void \bfcode{usb\_kill\_urb}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}}{}
cancel a transfer request and wait for it to finish

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
pointer to URB describing a previously submitted request,
may be NULL

\end{description}

\textbf{Description}

This routine cancels an in-progress request.  It is guaranteed that
upon return all completion handlers will have finished and the URB
will be totally idle and available for reuse.  These features make
this an ideal way to stop I/O in a \code{disconnect()} callback or \code{close()}
function.  If the request has not already finished or been unlinked
the completion handler will see urb-\textgreater{}status == -ENOENT.

While the routine is running, attempts to resubmit the URB will fail
with error -EPERM.  Thus even if the URB's completion handler always
tries to resubmit, it will not succeed and the URB will become idle.

The URB must not be deallocated while this routine is running.  In
particular, when a driver calls this routine, it must insure that the
completion handler cannot deallocate the URB.

This routine may not be used in an interrupt context (such as a bottom
half or a completion handler), or when holding a spinlock, or in other
situations where the caller can't \code{schedule()}.

This routine should not be called by a driver after its disconnect
method has returned.
\index{usb\_poison\_urb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_poison_urb}\pysiglinewithargsret{void \bfcode{usb\_poison\_urb}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}}{}
reliably kill a transfer and prevent further use of an URB

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
pointer to URB describing a previously submitted request,
may be NULL

\end{description}

\textbf{Description}

This routine cancels an in-progress request.  It is guaranteed that
upon return all completion handlers will have finished and the URB
will be totally idle and cannot be reused.  These features make
this an ideal way to stop I/O in a \code{disconnect()} callback.
If the request has not already finished or been unlinked
the completion handler will see urb-\textgreater{}status == -ENOENT.

After and while the routine runs, attempts to resubmit the URB will fail
with error -EPERM.  Thus even if the URB's completion handler always
tries to resubmit, it will not succeed and the URB will become idle.

The URB must not be deallocated while this routine is running.  In
particular, when a driver calls this routine, it must insure that the
completion handler cannot deallocate the URB.

This routine may not be used in an interrupt context (such as a bottom
half or a completion handler), or when holding a spinlock, or in other
situations where the caller can't \code{schedule()}.

This routine should not be called by a driver after its disconnect
method has returned.
\index{usb\_block\_urb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_block_urb}\pysiglinewithargsret{void \bfcode{usb\_block\_urb}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}}{}
reliably prevent further use of an URB

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
pointer to URB to be blocked, may be NULL

\end{description}

\textbf{Description}

After the routine has run, attempts to resubmit the URB will fail
with error -EPERM.  Thus even if the URB's completion handler always
tries to resubmit, it will not succeed and the URB will become idle.

The URB must not be deallocated while this routine is running.  In
particular, when a driver calls this routine, it must insure that the
completion handler cannot deallocate the URB.
\index{usb\_kill\_anchored\_urbs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_kill_anchored_urbs}\pysiglinewithargsret{void \bfcode{usb\_kill\_anchored\_urbs}}{struct usb\_anchor *\emph{ anchor}}{}
cancel transfer requests en masse

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_anchor * anchor}}] \leavevmode
anchor the requests are bound to

\end{description}

\textbf{Description}

this allows all outstanding URBs to be killed starting
from the back of the queue

This routine should not be called by a driver after its disconnect
method has returned.
\index{usb\_poison\_anchored\_urbs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_poison_anchored_urbs}\pysiglinewithargsret{void \bfcode{usb\_poison\_anchored\_urbs}}{struct usb\_anchor *\emph{ anchor}}{}
cease all traffic from an anchor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_anchor * anchor}}] \leavevmode
anchor the requests are bound to

\end{description}

\textbf{Description}

this allows all outstanding URBs to be poisoned starting
from the back of the queue. Newly added URBs will also be
poisoned

This routine should not be called by a driver after its disconnect
method has returned.
\index{usb\_unpoison\_anchored\_urbs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_unpoison_anchored_urbs}\pysiglinewithargsret{void \bfcode{usb\_unpoison\_anchored\_urbs}}{struct usb\_anchor *\emph{ anchor}}{}
let an anchor be used successfully again

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_anchor * anchor}}] \leavevmode
anchor the requests are bound to

\end{description}

\textbf{Description}

Reverses the effect of usb\_poison\_anchored\_urbs
the anchor can be used normally after it returns
\index{usb\_unlink\_anchored\_urbs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_unlink_anchored_urbs}\pysiglinewithargsret{void \bfcode{usb\_unlink\_anchored\_urbs}}{struct usb\_anchor *\emph{ anchor}}{}
asynchronously cancel transfer requests en masse

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_anchor * anchor}}] \leavevmode
anchor the requests are bound to

\end{description}

\textbf{Description}

this allows all outstanding URBs to be unlinked starting
from the back of the queue. This function is asynchronous.
The unlinking is just triggered. It may happen after this
function has returned.

This routine should not be called by a driver after its disconnect
method has returned.
\index{usb\_anchor\_suspend\_wakeups (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_anchor_suspend_wakeups}\pysiglinewithargsret{void \bfcode{usb\_anchor\_suspend\_wakeups}}{struct usb\_anchor *\emph{ anchor}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_anchor * anchor}}] \leavevmode
the anchor you want to suspend wakeups on

\end{description}

\textbf{Description}

Call this to stop the last urb being unanchored from waking up any
usb\_wait\_anchor\_empty\_timeout waiters. This is used in the hcd urb give-
back path to delay waking up until after the completion handler has run.
\index{usb\_anchor\_resume\_wakeups (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_anchor_resume_wakeups}\pysiglinewithargsret{void \bfcode{usb\_anchor\_resume\_wakeups}}{struct usb\_anchor *\emph{ anchor}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_anchor * anchor}}] \leavevmode
the anchor you want to resume wakeups on

\end{description}

\textbf{Description}

Allow usb\_wait\_anchor\_empty\_timeout waiters to be woken up again, and
wake up any current waiters if the anchor is empty.
\index{usb\_wait\_anchor\_empty\_timeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_wait_anchor_empty_timeout}\pysiglinewithargsret{int \bfcode{usb\_wait\_anchor\_empty\_timeout}}{struct usb\_anchor *\emph{ anchor}, unsigned int\emph{ timeout}}{}
wait for an anchor to be unused

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_anchor * anchor}}] \leavevmode
the anchor you want to become unused

\item[{\code{unsigned int timeout}}] \leavevmode
how long you are willing to wait in milliseconds

\end{description}

\textbf{Description}

Call this is you want to be sure all an anchor's
URBs have finished

\textbf{Return}

Non-zero if the anchor became unused. Zero on timeout.
\index{usb\_get\_from\_anchor (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_get_from_anchor}\pysiglinewithargsret{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} * \bfcode{usb\_get\_from\_anchor}}{struct usb\_anchor *\emph{ anchor}}{}
get an anchor's oldest urb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_anchor * anchor}}] \leavevmode
the anchor whose urb you want

\end{description}

\textbf{Description}

This will take the oldest urb from an anchor,
unanchor and return it

\textbf{Return}

The oldest urb from \textbf{anchor}, or \code{NULL} if \textbf{anchor} has no
urbs associated with it.
\index{usb\_scuttle\_anchored\_urbs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_scuttle_anchored_urbs}\pysiglinewithargsret{void \bfcode{usb\_scuttle\_anchored\_urbs}}{struct usb\_anchor *\emph{ anchor}}{}
unanchor all an anchor's urbs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_anchor * anchor}}] \leavevmode
the anchor whose urbs you want to unanchor

\end{description}

\textbf{Description}

use this to get rid of all an anchor's urbs
\index{usb\_anchor\_empty (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_anchor_empty}\pysiglinewithargsret{int \bfcode{usb\_anchor\_empty}}{struct usb\_anchor *\emph{ anchor}}{}
is an anchor empty

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_anchor * anchor}}] \leavevmode
the anchor you want to query

\end{description}

\textbf{Return}

1 if the anchor has no urbs associated with it.
\index{usb\_control\_msg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_control_msg}\pysiglinewithargsret{int \bfcode{usb\_control\_msg}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, unsigned int\emph{ pipe}, \_\_u8\emph{ request}, \_\_u8\emph{ requesttype}, \_\_u16\emph{ value}, \_\_u16\emph{ index}, void *\emph{ data}, \_\_u16\emph{ size}, int\emph{ timeout}}{}
Builds a control urb, sends it off and waits for completion

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * dev}}] \leavevmode
pointer to the usb device to send the message to

\item[{\code{unsigned int pipe}}] \leavevmode
endpoint ``pipe'' to send the message to

\item[{\code{\_\_u8 request}}] \leavevmode
USB message request value

\item[{\code{\_\_u8 requesttype}}] \leavevmode
USB message request type value

\item[{\code{\_\_u16 value}}] \leavevmode
USB message value

\item[{\code{\_\_u16 index}}] \leavevmode
USB message index value

\item[{\code{void * data}}] \leavevmode
pointer to the data to send

\item[{\code{\_\_u16 size}}] \leavevmode
length in bytes of the data to send

\item[{\code{int timeout}}] \leavevmode
time in msecs to wait for the message to complete before timing
out (if 0 the wait is forever)

\end{description}

\textbf{Context}

!in\_interrupt ()

\textbf{Description}

This function sends a simple control message to a specified endpoint and
waits for the message to complete, or timeout.

Don't use this function from within an interrupt context. If you need
an asynchronous message, or need to send a message from within interrupt
context, use {\hyperref[driver\string-api/usb/usb:c.usb_submit_urb]{\emph{\code{usb\_submit\_urb()}}}}. If a thread in your driver uses this call,
make sure your \code{disconnect()} method can wait for it to complete. Since you
don't have a handle on the URB used, you can't cancel the request.

\textbf{Return}

If successful, the number of bytes transferred. Otherwise, a negative
error number.
\index{usb\_interrupt\_msg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_interrupt_msg}\pysiglinewithargsret{int \bfcode{usb\_interrupt\_msg}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ usb\_dev}, unsigned int\emph{ pipe}, void *\emph{ data}, int\emph{ len}, int *\emph{ actual\_length}, int\emph{ timeout}}{}
Builds an interrupt urb, sends it off and waits for completion

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * usb\_dev}}] \leavevmode
pointer to the usb device to send the message to

\item[{\code{unsigned int pipe}}] \leavevmode
endpoint ``pipe'' to send the message to

\item[{\code{void * data}}] \leavevmode
pointer to the data to send

\item[{\code{int len}}] \leavevmode
length in bytes of the data to send

\item[{\code{int * actual\_length}}] \leavevmode
pointer to a location to put the actual length transferred
in bytes

\item[{\code{int timeout}}] \leavevmode
time in msecs to wait for the message to complete before
timing out (if 0 the wait is forever)

\end{description}

\textbf{Context}

!in\_interrupt ()

\textbf{Description}

This function sends a simple interrupt message to a specified endpoint and
waits for the message to complete, or timeout.

Don't use this function from within an interrupt context. If you need
an asynchronous message, or need to send a message from within interrupt
context, use {\hyperref[driver\string-api/usb/usb:c.usb_submit_urb]{\emph{\code{usb\_submit\_urb()}}}} If a thread in your driver uses this call,
make sure your \code{disconnect()} method can wait for it to complete. Since you
don't have a handle on the URB used, you can't cancel the request.

\textbf{Return}

If successful, 0. Otherwise a negative error number. The number of actual
bytes transferred will be stored in the \textbf{actual\_length} parameter.
\index{usb\_bulk\_msg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_bulk_msg}\pysiglinewithargsret{int \bfcode{usb\_bulk\_msg}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ usb\_dev}, unsigned int\emph{ pipe}, void *\emph{ data}, int\emph{ len}, int *\emph{ actual\_length}, int\emph{ timeout}}{}
Builds a bulk urb, sends it off and waits for completion

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * usb\_dev}}] \leavevmode
pointer to the usb device to send the message to

\item[{\code{unsigned int pipe}}] \leavevmode
endpoint ``pipe'' to send the message to

\item[{\code{void * data}}] \leavevmode
pointer to the data to send

\item[{\code{int len}}] \leavevmode
length in bytes of the data to send

\item[{\code{int * actual\_length}}] \leavevmode
pointer to a location to put the actual length transferred
in bytes

\item[{\code{int timeout}}] \leavevmode
time in msecs to wait for the message to complete before
timing out (if 0 the wait is forever)

\end{description}

\textbf{Context}

!in\_interrupt ()

\textbf{Description}

This function sends a simple bulk message to a specified endpoint
and waits for the message to complete, or timeout.

Don't use this function from within an interrupt context. If you need
an asynchronous message, or need to send a message from within interrupt
context, use {\hyperref[driver\string-api/usb/usb:c.usb_submit_urb]{\emph{\code{usb\_submit\_urb()}}}} If a thread in your driver uses this call,
make sure your \code{disconnect()} method can wait for it to complete. Since you
don't have a handle on the URB used, you can't cancel the request.

Because there is no {\hyperref[driver\string-api/usb/usb:c.usb_interrupt_msg]{\emph{\code{usb\_interrupt\_msg()}}}} and no USBDEVFS\_INTERRUPT ioctl,
users are forced to abuse this routine by using it to submit URBs for
interrupt endpoints.  We will take the liberty of creating an interrupt URB
(with the default interval) if the target is an interrupt endpoint.

\textbf{Return}

If successful, 0. Otherwise a negative error number. The number of actual
bytes transferred will be stored in the \textbf{actual\_length} parameter.
\index{usb\_sg\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_sg_init}\pysiglinewithargsret{int \bfcode{usb\_sg\_init}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_sg_request]{\emph{usb\_sg\_request}}} *\emph{ io}, struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, unsigned\emph{ pipe}, unsigned\emph{ period}, struct scatterlist *\emph{ sg}, int\emph{ nents}, size\_t\emph{ length}, gfp\_t\emph{ mem\_flags}}{}
initializes scatterlist-based bulk/interrupt I/O request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_sg\_request * io}}] \leavevmode
request block being initialized.  until {\hyperref[driver\string-api/usb/usb:c.usb_sg_wait]{\emph{\code{usb\_sg\_wait()}}}} returns,
treat this as a pointer to an opaque block of memory,

\item[{\code{struct usb\_device * dev}}] \leavevmode
the usb device that will send or receive the data

\item[{\code{unsigned pipe}}] \leavevmode
endpoint ``pipe'' used to transfer the data

\item[{\code{unsigned period}}] \leavevmode
polling rate for interrupt endpoints, in frames or
(for high speed endpoints) microframes; ignored for bulk

\item[{\code{struct scatterlist * sg}}] \leavevmode
scatterlist entries

\item[{\code{int nents}}] \leavevmode
how many entries in the scatterlist

\item[{\code{size\_t length}}] \leavevmode
how many bytes to send from the scatterlist, or zero to
send every byte identified in the list.

\item[{\code{gfp\_t mem\_flags}}] \leavevmode
SLAB\_* flags affecting memory allocations in this call

\end{description}

\textbf{Description}

This initializes a scatter/gather request, allocating resources such as
I/O mappings and urb memory (except maybe memory used by USB controller
drivers).

The request must be issued using {\hyperref[driver\string-api/usb/usb:c.usb_sg_wait]{\emph{\code{usb\_sg\_wait()}}}}, which waits for the I/O to
complete (or to be canceled) and then cleans up all resources allocated by
{\hyperref[driver\string-api/usb/usb:c.usb_sg_init]{\emph{\code{usb\_sg\_init()}}}}.

The request may be canceled with {\hyperref[driver\string-api/usb/usb:c.usb_sg_cancel]{\emph{\code{usb\_sg\_cancel()}}}}, either before or after
{\hyperref[driver\string-api/usb/usb:c.usb_sg_wait]{\emph{\code{usb\_sg\_wait()}}}} is called.

\textbf{Return}

Zero for success, else a negative errno value.
\index{usb\_sg\_wait (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_sg_wait}\pysiglinewithargsret{void \bfcode{usb\_sg\_wait}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_sg_request]{\emph{usb\_sg\_request}}} *\emph{ io}}{}
synchronously execute scatter/gather request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_sg\_request * io}}] \leavevmode
request block handle, as initialized with {\hyperref[driver\string-api/usb/usb:c.usb_sg_init]{\emph{\code{usb\_sg\_init()}}}}.
some fields become accessible when this call returns.

\end{description}

\textbf{Context}

!in\_interrupt ()

\textbf{Description}

This function blocks until the specified I/O operation completes.  It
leverages the grouping of the related I/O requests to get good transfer
rates, by queueing the requests.  At higher speeds, such queuing can
significantly improve USB throughput.

There are three kinds of completion for this function.
\begin{enumerate}
\item {} 
success, where io-\textgreater{}status is zero.  The number of io-\textgreater{}bytes
transferred is as requested.

\item {} 
error, where io-\textgreater{}status is a negative errno value.  The number
of io-\textgreater{}bytes transferred before the error is usually less
than requested, and can be nonzero.

\item {} 
cancellation, a type of error with status -ECONNRESET that
is initiated by {\hyperref[driver\string-api/usb/usb:c.usb_sg_cancel]{\emph{\code{usb\_sg\_cancel()}}}}.

\end{enumerate}

When this function returns, all memory allocated through {\hyperref[driver\string-api/usb/usb:c.usb_sg_init]{\emph{\code{usb\_sg\_init()}}}} or
this call will have been freed.  The request block parameter may still be
passed to {\hyperref[driver\string-api/usb/usb:c.usb_sg_cancel]{\emph{\code{usb\_sg\_cancel()}}}}, or it may be freed.  It could also be
reinitialized and then reused.

Data Transfer Rates:

Bulk transfers are valid for full or high speed endpoints.
The best full speed data rate is 19 packets of 64 bytes each
per frame, or 1216 bytes per millisecond.
The best high speed data rate is 13 packets of 512 bytes each
per microframe, or 52 KBytes per millisecond.

The reason to use interrupt transfers through this API would most likely
be to reserve high speed bandwidth, where up to 24 KBytes per millisecond
could be transferred.  That capability is less useful for low or full
speed interrupt endpoints, which allow at most one packet per millisecond,
of at most 8 or 64 bytes (respectively).

It is not necessary to call this function to reserve bandwidth for devices
under an xHCI host controller, as the bandwidth is reserved when the
configuration or interface alt setting is selected.
\index{usb\_sg\_cancel (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_sg_cancel}\pysiglinewithargsret{void \bfcode{usb\_sg\_cancel}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_sg_request]{\emph{usb\_sg\_request}}} *\emph{ io}}{}
stop scatter/gather i/o issued by {\hyperref[driver\string-api/usb/usb:c.usb_sg_wait]{\emph{\code{usb\_sg\_wait()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_sg\_request * io}}] \leavevmode
request block, initialized with {\hyperref[driver\string-api/usb/usb:c.usb_sg_init]{\emph{\code{usb\_sg\_init()}}}}

\end{description}

\textbf{Description}

This stops a request after it has been started by {\hyperref[driver\string-api/usb/usb:c.usb_sg_wait]{\emph{\code{usb\_sg\_wait()}}}}.
It can also prevents one initialized by {\hyperref[driver\string-api/usb/usb:c.usb_sg_init]{\emph{\code{usb\_sg\_init()}}}} from starting,
so that call just frees resources allocated to the request.
\index{usb\_get\_descriptor (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_get_descriptor}\pysiglinewithargsret{int \bfcode{usb\_get\_descriptor}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, unsigned char\emph{ type}, unsigned char\emph{ index}, void *\emph{ buf}, int\emph{ size}}{}
issues a generic GET\_DESCRIPTOR request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * dev}}] \leavevmode
the device whose descriptor is being retrieved

\item[{\code{unsigned char type}}] \leavevmode
the descriptor type (USB\_DT\_*)

\item[{\code{unsigned char index}}] \leavevmode
the number of the descriptor

\item[{\code{void * buf}}] \leavevmode
where to put the descriptor

\item[{\code{int size}}] \leavevmode
how big is ``buf''?

\end{description}

\textbf{Context}

!in\_interrupt ()

\textbf{Description}

Gets a USB descriptor.  Convenience functions exist to simplify
getting some types of descriptors.  Use
\code{usb\_get\_string()} or {\hyperref[driver\string-api/usb/usb:c.usb_string]{\emph{\code{usb\_string()}}}} for USB\_DT\_STRING.
Device (USB\_DT\_DEVICE) and configuration descriptors (USB\_DT\_CONFIG)
are part of the device structure.
In addition to a number of USB-standard descriptors, some
devices also use class-specific or vendor-specific descriptors.

This call is synchronous, and may not be used in an interrupt context.

\textbf{Return}

The number of bytes received on success, or else the status code
returned by the underlying {\hyperref[driver\string-api/usb/usb:c.usb_control_msg]{\emph{\code{usb\_control\_msg()}}}} call.
\index{usb\_string (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_string}\pysiglinewithargsret{int \bfcode{usb\_string}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, int\emph{ index}, char *\emph{ buf}, size\_t\emph{ size}}{}
returns UTF-8 version of a string descriptor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * dev}}] \leavevmode
the device whose string descriptor is being retrieved

\item[{\code{int index}}] \leavevmode
the number of the descriptor

\item[{\code{char * buf}}] \leavevmode
where to put the string

\item[{\code{size\_t size}}] \leavevmode
how big is ``buf''?

\end{description}

\textbf{Context}

!in\_interrupt ()

\textbf{Description}

This converts the UTF-16LE encoded strings returned by devices, from
\code{usb\_get\_string\_descriptor()}, to null-terminated UTF-8 encoded ones
that are more usable in most kernel contexts.  Note that this function
chooses strings in the first language supported by the device.

This call is synchronous, and may not be used in an interrupt context.

\textbf{Return}

length of the string (\textgreater{}= 0) or usb\_control\_msg status (\textless{} 0).
\index{usb\_get\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_get_status}\pysiglinewithargsret{int \bfcode{usb\_get\_status}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, int\emph{ recip}, int\emph{ type}, int\emph{ target}, void *\emph{ data}}{}
issues a GET\_STATUS call

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * dev}}] \leavevmode
the device whose status is being checked

\item[{\code{int recip}}] \leavevmode
USB\_RECIP\_*; for device, interface, or endpoint

\item[{\code{int type}}] \leavevmode
USB\_STATUS\_TYPE\_*; for standard or PTM status types

\item[{\code{int target}}] \leavevmode
zero (for device), else interface or endpoint number

\item[{\code{void * data}}] \leavevmode
pointer to two bytes of bitmap data

\end{description}

\textbf{Context}

!in\_interrupt ()

\textbf{Description}

Returns device, interface, or endpoint status.  Normally only of
interest to see if the device is self powered, or has enabled the
remote wakeup facility; or whether a bulk or interrupt endpoint
is halted (``stalled'').

Bits in these status bitmaps are set using the SET\_FEATURE request,
and cleared using the CLEAR\_FEATURE request.  The {\hyperref[driver\string-api/usb/usb:c.usb_clear_halt]{\emph{\code{usb\_clear\_halt()}}}}
function should be used to clear halt (``stall'') status.

This call is synchronous, and may not be used in an interrupt context.

Returns 0 and the status value in \textbf{*data} (in host byte order) on success,
or else the status code from the underlying {\hyperref[driver\string-api/usb/usb:c.usb_control_msg]{\emph{\code{usb\_control\_msg()}}}} call.
\index{usb\_clear\_halt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_clear_halt}\pysiglinewithargsret{int \bfcode{usb\_clear\_halt}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, int\emph{ pipe}}{}
tells device to clear endpoint halt/stall condition

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * dev}}] \leavevmode
device whose endpoint is halted

\item[{\code{int pipe}}] \leavevmode
endpoint ``pipe'' being cleared

\end{description}

\textbf{Context}

!in\_interrupt ()

\textbf{Description}

This is used to clear halt conditions for bulk and interrupt endpoints,
as reported by URB completion status.  Endpoints that are halted are
sometimes referred to as being ``stalled''.  Such endpoints are unable
to transmit or receive data until the halt status is cleared.  Any URBs
queued for such an endpoint should normally be unlinked by the driver
before clearing the halt condition, as described in sections 5.7.5
and 5.8.5 of the USB 2.0 spec.

Note that control and isochronous endpoints don't halt, although control
endpoints report ``protocol stall'' (for unsupported requests) using the
same status code used to report a true stall.

This call is synchronous, and may not be used in an interrupt context.

\textbf{Return}

Zero on success, or else the status code returned by the
underlying {\hyperref[driver\string-api/usb/usb:c.usb_control_msg]{\emph{\code{usb\_control\_msg()}}}} call.
\index{usb\_reset\_endpoint (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_reset_endpoint}\pysiglinewithargsret{void \bfcode{usb\_reset\_endpoint}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, unsigned int\emph{ epaddr}}{}
Reset an endpoint's state.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * dev}}] \leavevmode
the device whose endpoint is to be reset

\item[{\code{unsigned int epaddr}}] \leavevmode
the endpoint's address.  Endpoint number for output,
endpoint number + USB\_DIR\_IN for input

\end{description}

\textbf{Description}

Resets any host-side endpoint state such as the toggle bit,
sequence number or current window.
\index{usb\_set\_interface (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_set_interface}\pysiglinewithargsret{int \bfcode{usb\_set\_interface}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, int\emph{ interface}, int\emph{ alternate}}{}
Makes a particular alternate setting be current

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * dev}}] \leavevmode
the device whose interface is being updated

\item[{\code{int interface}}] \leavevmode
the interface being updated

\item[{\code{int alternate}}] \leavevmode
the setting being chosen.

\end{description}

\textbf{Context}

!in\_interrupt ()

\textbf{Description}

This is used to enable data transfers on interfaces that may not
be enabled by default.  Not all devices support such configurability.
Only the driver bound to an interface may change its setting.

Within any given configuration, each interface may have several
alternative settings.  These are often used to control levels of
bandwidth consumption.  For example, the default setting for a high
speed interrupt endpoint may not send more than 64 bytes per microframe,
while interrupt transfers of up to 3KBytes per microframe are legal.
Also, isochronous endpoints may never be part of an
interface's default setting.  To access such bandwidth, alternate
interface settings must be made current.

Note that in the Linux USB subsystem, bandwidth associated with
an endpoint in a given alternate setting is not reserved until an URB
is submitted that needs that bandwidth.  Some other operating systems
allocate bandwidth early, when a configuration is chosen.

This call is synchronous, and may not be used in an interrupt context.
Also, drivers must not change altsettings while urbs are scheduled for
endpoints in that interface; all such urbs must first be completed
(perhaps forced by unlinking).

\textbf{Return}

Zero on success, or else the status code returned by the
underlying {\hyperref[driver\string-api/usb/usb:c.usb_control_msg]{\emph{\code{usb\_control\_msg()}}}} call.
\index{usb\_reset\_configuration (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_reset_configuration}\pysiglinewithargsret{int \bfcode{usb\_reset\_configuration}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}}{}
lightweight device reset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * dev}}] \leavevmode
the device whose configuration is being reset

\end{description}

\textbf{Description}

This issues a standard SET\_CONFIGURATION request to the device using
the current configuration.  The effect is to reset most USB-related
state in the device, including interface altsettings (reset to zero),
endpoint halts (cleared), and endpoint state (only for bulk and interrupt
endpoints).  Other usbcore state is unchanged, including bindings of
usb device drivers to interfaces.

Because this affects multiple interfaces, avoid using this with composite
(multi-interface) devices.  Instead, the driver for each interface may
use {\hyperref[driver\string-api/usb/usb:c.usb_set_interface]{\emph{\code{usb\_set\_interface()}}}} on the interfaces it claims.  Be careful though;
some devices don't support the SET\_INTERFACE request, and others won't
reset all the interface state (notably endpoint state).  Resetting the whole
configuration would affect other drivers' interfaces.

The caller must own the device lock.

\textbf{Return}

Zero on success, else a negative error code.
\index{usb\_driver\_set\_configuration (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_driver_set_configuration}\pysiglinewithargsret{int \bfcode{usb\_driver\_set\_configuration}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ udev}, int\emph{ config}}{}
Provide a way for drivers to change device configurations

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * udev}}] \leavevmode
the device whose configuration is being updated

\item[{\code{int config}}] \leavevmode
the configuration being chosen.

\end{description}

\textbf{Context}

In process context, must be able to sleep

\textbf{Description}

Device interface drivers are not allowed to change device configurations.
This is because changing configurations will destroy the interface the
driver is bound to and create new ones; it would be like a floppy-disk
driver telling the computer to replace the floppy-disk drive with a
tape drive!

Still, in certain specialized circumstances the need may arise.  This
routine gets around the normal restrictions by using a work thread to
submit the change-config request.

\textbf{Return}

0 if the request was successfully queued, error code otherwise.
The caller has no way to know whether the queued request will eventually
succeed.
\index{cdc\_parse\_cdc\_header (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.cdc_parse_cdc_header}\pysiglinewithargsret{int \bfcode{cdc\_parse\_cdc\_header}}{struct usb\_cdc\_parsed\_header *\emph{ hdr}, struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ intf}, u8 *\emph{ buffer}, int\emph{ buflen}}{}
parse the extra headers present in CDC devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_cdc\_parsed\_header * hdr}}] \leavevmode
the place to put the results of the parsing

\item[{\code{struct usb\_interface * intf}}] \leavevmode
the interface for which parsing is requested

\item[{\code{u8 * buffer}}] \leavevmode
pointer to the extra headers to be parsed

\item[{\code{int buflen}}] \leavevmode
length of the extra headers

\end{description}

\textbf{Description}

This evaluates the extra headers present in CDC devices which
bind the interfaces for data and control and provide details
about the capabilities of the device.

\textbf{Return}

number of descriptors parsed or -EINVAL
if the header is contradictory beyond salvage
\index{usb\_register\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_register_dev}\pysiglinewithargsret{int \bfcode{usb\_register\_dev}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ intf}, struct {\hyperref[driver\string-api/usb/usb:c.usb_class_driver]{\emph{usb\_class\_driver}}} *\emph{ class\_driver}}{}
register a USB device, and ask for a minor number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_interface * intf}}] \leavevmode
pointer to the usb\_interface that is being registered

\item[{\code{struct usb\_class\_driver * class\_driver}}] \leavevmode
pointer to the usb\_class\_driver for this device

\end{description}

\textbf{Description}

This should be called by all USB drivers that use the USB major number.
If CONFIG\_USB\_DYNAMIC\_MINORS is enabled, the minor number will be
dynamically allocated out of the list of available ones.  If it is not
enabled, the minor number will be based on the next available free minor,
starting at the class\_driver-\textgreater{}minor\_base.

This function also creates a usb class device in the sysfs tree.

{\hyperref[driver\string-api/usb/usb:c.usb_deregister_dev]{\emph{\code{usb\_deregister\_dev()}}}} must be called when the driver is done with
the minor numbers given out by this function.

\textbf{Return}

-EINVAL if something bad happens with trying to register a
device, and 0 on success.
\index{usb\_deregister\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_deregister_dev}\pysiglinewithargsret{void \bfcode{usb\_deregister\_dev}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ intf}, struct {\hyperref[driver\string-api/usb/usb:c.usb_class_driver]{\emph{usb\_class\_driver}}} *\emph{ class\_driver}}{}
deregister a USB device's dynamic minor.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_interface * intf}}] \leavevmode
pointer to the usb\_interface that is being deregistered

\item[{\code{struct usb\_class\_driver * class\_driver}}] \leavevmode
pointer to the usb\_class\_driver for this device

\end{description}

\textbf{Description}

Used in conjunction with {\hyperref[driver\string-api/usb/usb:c.usb_register_dev]{\emph{\code{usb\_register\_dev()}}}}.  This function is called
when the USB driver is finished with the minor numbers gotten from a
call to {\hyperref[driver\string-api/usb/usb:c.usb_register_dev]{\emph{\code{usb\_register\_dev()}}}} (usually when the device is disconnected
from the system.)

This function also removes the usb class device from the sysfs tree.

This should be called by all drivers that use the USB major number.
\index{usb\_driver\_claim\_interface (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_driver_claim_interface}\pysiglinewithargsret{int \bfcode{usb\_driver\_claim\_interface}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_driver]{\emph{usb\_driver}}} *\emph{ driver}, struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ iface}, void *\emph{ priv}}{}
bind a driver to an interface

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_driver * driver}}] \leavevmode
the driver to be bound

\item[{\code{struct usb\_interface * iface}}] \leavevmode
the interface to which it will be bound; must be in the
usb device's active configuration

\item[{\code{void * priv}}] \leavevmode
driver data associated with that interface

\end{description}

\textbf{Description}

This is used by usb device drivers that need to claim more than one
interface on a device when probing (audio and acm are current examples).
No device driver should directly modify internal usb\_interface or
usb\_device structure members.

Few drivers should need to use this routine, since the most natural
way to bind to an interface is to return the private data from
the driver's \code{probe()} method.

Callers must own the device lock, so driver \code{probe()} entries don't need
extra locking, but other call contexts may need to explicitly claim that
lock.

\textbf{Return}

0 on success.
\index{usb\_driver\_release\_interface (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_driver_release_interface}\pysiglinewithargsret{void \bfcode{usb\_driver\_release\_interface}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_driver]{\emph{usb\_driver}}} *\emph{ driver}, struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ iface}}{}
unbind a driver from an interface

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_driver * driver}}] \leavevmode
the driver to be unbound

\item[{\code{struct usb\_interface * iface}}] \leavevmode
the interface from which it will be unbound

\end{description}

\textbf{Description}

This can be used by drivers to release an interface without waiting
for their \code{disconnect()} methods to be called.  In typical cases this
also causes the driver \code{disconnect()} method to be called.

This call is synchronous, and may not be used in an interrupt context.
Callers must own the device lock, so driver \code{disconnect()} entries don't
need extra locking, but other call contexts may need to explicitly claim
that lock.
\index{usb\_match\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_match_id}\pysiglinewithargsret{const struct {\hyperref[driver\string-api/basics:c.usb_device_id]{\emph{usb\_device\_id}}} * \bfcode{usb\_match\_id}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ interface}, const struct {\hyperref[driver\string-api/basics:c.usb_device_id]{\emph{usb\_device\_id}}} *\emph{ id}}{}
find first usb\_device\_id matching device or interface

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_interface * interface}}] \leavevmode
the interface of interest

\item[{\code{const struct usb\_device\_id * id}}] \leavevmode
array of usb\_device\_id structures, terminated by zero entry

\end{description}

\textbf{Description}

usb\_match\_id searches an array of usb\_device\_id's and returns
the first one matching the device or interface, or null.
This is used when binding (or rebinding) a driver to an interface.
Most USB device drivers will use this indirectly, through the usb core,
but some layered driver frameworks use it directly.
These device tables are exported with MODULE\_DEVICE\_TABLE, through
modutils, to support the driver loading functionality of USB hotplugging.

\textbf{Return}

The first matching usb\_device\_id, or \code{NULL}.

What Matches:

The ``match\_flags'' element in a usb\_device\_id controls which
members are used.  If the corresponding bit is set, the
value in the device\_id must match its corresponding member
in the device or interface descriptor, or else the device\_id
does not match.

``driver\_info'' is normally used only by device drivers,
but you can create a wildcard ``matches anything'' usb\_device\_id
as a driver's ``modules.usbmap'' entry if you provide an id with
only a nonzero ``driver\_info'' field.  If you do this, the USB device
driver's \code{probe()} routine should use additional intelligence to
decide whether to bind to the specified interface.

What Makes Good usb\_device\_id Tables:

The match algorithm is very simple, so that intelligence in
driver selection must come from smart driver id records.
Unless you have good reasons to use another selection policy,
provide match elements only in related groups, and order match
specifiers from specific to general.  Use the macros provided
for that purpose if you can.

The most specific match specifiers use device descriptor
data.  These are commonly used with product-specific matches;
the USB\_DEVICE macro lets you provide vendor and product IDs,
and you can also match against ranges of product revisions.
These are widely used for devices with application or vendor
specific bDeviceClass values.

Matches based on device class/subclass/protocol specifications
are slightly more general; use the USB\_DEVICE\_INFO macro, or
its siblings.  These are used with single-function devices
where bDeviceClass doesn't specify that each interface has
its own class.

Matches based on interface class/subclass/protocol are the
most general; they let drivers bind to any interface on a
multiple-function device.  Use the USB\_INTERFACE\_INFO
macro, or its siblings, to match class-per-interface style
devices (as recorded in bInterfaceClass).

Note that an entry created by USB\_INTERFACE\_INFO won't match
any interface if the device class is set to Vendor-Specific.
This is deliberate; according to the USB spec the meanings of
the interface class/subclass/protocol for these devices are also
vendor-specific, and hence matching against a standard product
class wouldn't work anyway.  If you really want to use an
interface-based match for such a device, create a match record
that also specifies the vendor ID.  (Unforunately there isn't a
standard macro for creating records like this.)

Within those groups, remember that not all combinations are
meaningful.  For example, don't give a product version range
without vendor and product IDs; or specify a protocol without
its associated class and subclass.
\index{usb\_register\_device\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_register_device_driver}\pysiglinewithargsret{int \bfcode{usb\_register\_device\_driver}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device_driver]{\emph{usb\_device\_driver}}} *\emph{ new\_udriver}, struct module *\emph{ owner}}{}
register a USB device (not interface) driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device\_driver * new\_udriver}}] \leavevmode
USB operations for the device driver

\item[{\code{struct module * owner}}] \leavevmode
module owner of this driver.

\end{description}

\textbf{Description}

Registers a USB device driver with the USB core.  The list of
unattached devices will be rescanned whenever a new driver is
added, allowing the new driver to attach to any recognized devices.

\textbf{Return}

A negative error code on failure and 0 on success.
\index{usb\_deregister\_device\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_deregister_device_driver}\pysiglinewithargsret{void \bfcode{usb\_deregister\_device\_driver}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device_driver]{\emph{usb\_device\_driver}}} *\emph{ udriver}}{}
unregister a USB device (not interface) driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device\_driver * udriver}}] \leavevmode
USB operations of the device driver to unregister

\end{description}

\textbf{Context}

must be able to sleep

\textbf{Description}

Unlinks the specified driver from the internal USB driver list.
\index{usb\_register\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_register_driver}\pysiglinewithargsret{int \bfcode{usb\_register\_driver}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_driver]{\emph{usb\_driver}}} *\emph{ new\_driver}, struct module *\emph{ owner}, const char *\emph{ mod\_name}}{}
register a USB interface driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_driver * new\_driver}}] \leavevmode
USB operations for the interface driver

\item[{\code{struct module * owner}}] \leavevmode
module owner of this driver.

\item[{\code{const char * mod\_name}}] \leavevmode
module name string

\end{description}

\textbf{Description}

Registers a USB interface driver with the USB core.  The list of
unattached interfaces will be rescanned whenever a new driver is
added, allowing the new driver to attach to any recognized interfaces.

\textbf{Return}

A negative error code on failure and 0 on success.

\textbf{NOTE}

if you want your driver to use the USB major number, you must call
{\hyperref[driver\string-api/usb/usb:c.usb_register_dev]{\emph{\code{usb\_register\_dev()}}}} to enable that functionality.  This function no longer
takes care of that.
\index{usb\_deregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_deregister}\pysiglinewithargsret{void \bfcode{usb\_deregister}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_driver]{\emph{usb\_driver}}} *\emph{ driver}}{}
unregister a USB interface driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_driver * driver}}] \leavevmode
USB operations of the interface driver to unregister

\end{description}

\textbf{Context}

must be able to sleep

\textbf{Description}

Unlinks the specified driver from the internal USB driver list.

\textbf{NOTE}

If you called {\hyperref[driver\string-api/usb/usb:c.usb_register_dev]{\emph{\code{usb\_register\_dev()}}}}, you still need to call
{\hyperref[driver\string-api/usb/usb:c.usb_deregister_dev]{\emph{\code{usb\_deregister\_dev()}}}} to clean up your driver's allocated minor numbers,
this * call will no longer do it for you.
\index{usb\_enable\_autosuspend (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_enable_autosuspend}\pysiglinewithargsret{void \bfcode{usb\_enable\_autosuspend}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ udev}}{}
allow a USB device to be autosuspended

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * udev}}] \leavevmode
the USB device which may be autosuspended

\end{description}

\textbf{Description}

This routine allows \textbf{udev} to be autosuspended.  An autosuspend won't
take place until the autosuspend\_delay has elapsed and all the other
necessary conditions are satisfied.

The caller must hold \textbf{udev}`s device lock.
\index{usb\_disable\_autosuspend (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_disable_autosuspend}\pysiglinewithargsret{void \bfcode{usb\_disable\_autosuspend}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ udev}}{}
prevent a USB device from being autosuspended

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * udev}}] \leavevmode
the USB device which may not be autosuspended

\end{description}

\textbf{Description}

This routine prevents \textbf{udev} from being autosuspended and wakes it up
if it is already autosuspended.

The caller must hold \textbf{udev}`s device lock.
\index{usb\_autopm\_put\_interface (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_autopm_put_interface}\pysiglinewithargsret{void \bfcode{usb\_autopm\_put\_interface}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ intf}}{}
decrement a USB interface's PM-usage counter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_interface * intf}}] \leavevmode
the usb\_interface whose counter should be decremented

\end{description}

\textbf{Description}

This routine should be called by an interface driver when it is
finished using \textbf{intf} and wants to allow it to autosuspend.  A typical
example would be a character-device driver when its device file is
closed.

The routine decrements \textbf{intf}`s usage counter.  When the counter reaches
0, a delayed autosuspend request for \textbf{intf}`s device is attempted.  The
attempt may fail (see \code{autosuspend\_check()}).

This routine can run only in process context.
\index{usb\_autopm\_put\_interface\_async (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_autopm_put_interface_async}\pysiglinewithargsret{void \bfcode{usb\_autopm\_put\_interface\_async}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ intf}}{}
decrement a USB interface's PM-usage counter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_interface * intf}}] \leavevmode
the usb\_interface whose counter should be decremented

\end{description}

\textbf{Description}

This routine does much the same thing as {\hyperref[driver\string-api/usb/usb:c.usb_autopm_put_interface]{\emph{\code{usb\_autopm\_put\_interface()}}}}:
It decrements \textbf{intf}`s usage counter and schedules a delayed
autosuspend request if the counter is \textless{}= 0.  The difference is that it
does not perform any synchronization; callers should hold a private
lock and handle all synchronization issues themselves.

Typically a driver would call this routine during an URB's completion
handler, if no more URBs were pending.

This routine can run in atomic context.
\index{usb\_autopm\_put\_interface\_no\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_autopm_put_interface_no_suspend}\pysiglinewithargsret{void \bfcode{usb\_autopm\_put\_interface\_no\_suspend}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ intf}}{}
decrement a USB interface's PM-usage counter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_interface * intf}}] \leavevmode
the usb\_interface whose counter should be decremented

\end{description}

\textbf{Description}

This routine decrements \textbf{intf}`s usage counter but does not carry out an
autosuspend.

This routine can run in atomic context.
\index{usb\_autopm\_get\_interface (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_autopm_get_interface}\pysiglinewithargsret{int \bfcode{usb\_autopm\_get\_interface}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ intf}}{}
increment a USB interface's PM-usage counter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_interface * intf}}] \leavevmode
the usb\_interface whose counter should be incremented

\end{description}

\textbf{Description}

This routine should be called by an interface driver when it wants to
use \textbf{intf} and needs to guarantee that it is not suspended.  In addition,
the routine prevents \textbf{intf} from being autosuspended subsequently.  (Note
that this will not prevent suspend events originating in the PM core.)
This prevention will persist until {\hyperref[driver\string-api/usb/usb:c.usb_autopm_put_interface]{\emph{\code{usb\_autopm\_put\_interface()}}}} is called
or \textbf{intf} is unbound.  A typical example would be a character-device
driver when its device file is opened.

\textbf{intf}`s usage counter is incremented to prevent subsequent autosuspends.
However if the autoresume fails then the counter is re-decremented.

This routine can run only in process context.

\textbf{Return}

0 on success.
\index{usb\_autopm\_get\_interface\_async (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_autopm_get_interface_async}\pysiglinewithargsret{int \bfcode{usb\_autopm\_get\_interface\_async}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ intf}}{}
increment a USB interface's PM-usage counter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_interface * intf}}] \leavevmode
the usb\_interface whose counter should be incremented

\end{description}

\textbf{Description}

This routine does much the same thing as
{\hyperref[driver\string-api/usb/usb:c.usb_autopm_get_interface]{\emph{\code{usb\_autopm\_get\_interface()}}}}: It increments \textbf{intf}`s usage counter and
queues an autoresume request if the device is suspended.  The
differences are that it does not perform any synchronization (callers
should hold a private lock and handle all synchronization issues
themselves), and it does not autoresume the device directly (it only
queues a request).  After a successful call, the device may not yet be
resumed.

This routine can run in atomic context.

\textbf{Return}

0 on success. A negative error code otherwise.
\index{usb\_autopm\_get\_interface\_no\_resume (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_autopm_get_interface_no_resume}\pysiglinewithargsret{void \bfcode{usb\_autopm\_get\_interface\_no\_resume}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ intf}}{}
increment a USB interface's PM-usage counter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_interface * intf}}] \leavevmode
the usb\_interface whose counter should be incremented

\end{description}

\textbf{Description}

This routine increments \textbf{intf}`s usage counter but does not carry out an
autoresume.

This routine can run in atomic context.
\index{usb\_find\_common\_endpoints (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_find_common_endpoints}\pysiglinewithargsret{int \bfcode{usb\_find\_common\_endpoints}}{struct usb\_host\_interface *\emph{ alt}, struct usb\_endpoint\_descriptor **\emph{ bulk\_in}, struct usb\_endpoint\_descriptor **\emph{ bulk\_out}, struct usb\_endpoint\_descriptor **\emph{ int\_in}, struct usb\_endpoint\_descriptor **\emph{ int\_out}}{}~\begin{itemize}
\item {} 
look up common endpoint descriptors

\end{itemize}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_host\_interface * alt}}] \leavevmode
alternate setting to search

\item[{\code{struct usb\_endpoint\_descriptor ** bulk\_in}}] \leavevmode
pointer to descriptor pointer, or NULL

\item[{\code{struct usb\_endpoint\_descriptor ** bulk\_out}}] \leavevmode
pointer to descriptor pointer, or NULL

\item[{\code{struct usb\_endpoint\_descriptor ** int\_in}}] \leavevmode
pointer to descriptor pointer, or NULL

\item[{\code{struct usb\_endpoint\_descriptor ** int\_out}}] \leavevmode
pointer to descriptor pointer, or NULL

\end{description}

\textbf{Description}

Search the alternate setting's endpoint descriptors for the first bulk-in,
bulk-out, interrupt-in and interrupt-out endpoints and return them in the
provided pointers (unless they are NULL).

If a requested endpoint is not found, the corresponding pointer is set to
NULL.

\textbf{Return}

Zero if all requested descriptors were found, or -ENXIO otherwise.
\index{usb\_find\_common\_endpoints\_reverse (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_find_common_endpoints_reverse}\pysiglinewithargsret{int \bfcode{usb\_find\_common\_endpoints\_reverse}}{struct usb\_host\_interface *\emph{ alt}, struct usb\_endpoint\_descriptor **\emph{ bulk\_in}, struct usb\_endpoint\_descriptor **\emph{ bulk\_out}, struct usb\_endpoint\_descriptor **\emph{ int\_in}, struct usb\_endpoint\_descriptor **\emph{ int\_out}}{}~\begin{itemize}
\item {} 
look up common endpoint descriptors

\end{itemize}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_host\_interface * alt}}] \leavevmode
alternate setting to search

\item[{\code{struct usb\_endpoint\_descriptor ** bulk\_in}}] \leavevmode
pointer to descriptor pointer, or NULL

\item[{\code{struct usb\_endpoint\_descriptor ** bulk\_out}}] \leavevmode
pointer to descriptor pointer, or NULL

\item[{\code{struct usb\_endpoint\_descriptor ** int\_in}}] \leavevmode
pointer to descriptor pointer, or NULL

\item[{\code{struct usb\_endpoint\_descriptor ** int\_out}}] \leavevmode
pointer to descriptor pointer, or NULL

\end{description}

\textbf{Description}

Search the alternate setting's endpoint descriptors for the last bulk-in,
bulk-out, interrupt-in and interrupt-out endpoints and return them in the
provided pointers (unless they are NULL).

If a requested endpoint is not found, the corresponding pointer is set to
NULL.

\textbf{Return}

Zero if all requested descriptors were found, or -ENXIO otherwise.
\index{usb\_find\_alt\_setting (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_find_alt_setting}\pysiglinewithargsret{struct usb\_host\_interface * \bfcode{usb\_find\_alt\_setting}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_host_config]{\emph{usb\_host\_config}}} *\emph{ config}, unsigned int\emph{ iface\_num}, unsigned int\emph{ alt\_num}}{}
Given a configuration, find the alternate setting for the given interface.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_host\_config * config}}] \leavevmode
the configuration to search (not necessarily the current config).

\item[{\code{unsigned int iface\_num}}] \leavevmode
interface number to search in

\item[{\code{unsigned int alt\_num}}] \leavevmode
alternate interface setting number to search for.

\end{description}

\textbf{Description}

Search the configuration's interface cache for the given alt setting.

\textbf{Return}

The alternate setting, if found. \code{NULL} otherwise.
\index{usb\_ifnum\_to\_if (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_ifnum_to_if}\pysiglinewithargsret{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} * \bfcode{usb\_ifnum\_to\_if}}{const struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, unsigned\emph{ ifnum}}{}
get the interface object with a given interface number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct usb\_device * dev}}] \leavevmode
the device whose current configuration is considered

\item[{\code{unsigned ifnum}}] \leavevmode
the desired interface

\end{description}

\textbf{Description}

This walks the device descriptor for the currently active configuration
to find the interface object with the particular interface number.

Note that configuration descriptors are not required to assign interface
numbers sequentially, so that it would be incorrect to assume that
the first interface in that descriptor corresponds to interface zero.
This routine helps device drivers avoid such mistakes.
However, you should make sure that you do the right thing with any
alternate settings available for this interfaces.

Don't call this function unless you are bound to one of the interfaces
on this device or you have locked the device!

\textbf{Return}

A pointer to the interface that has \textbf{ifnum} as interface number,
if found. \code{NULL} otherwise.
\index{usb\_altnum\_to\_altsetting (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_altnum_to_altsetting}\pysiglinewithargsret{struct usb\_host\_interface * \bfcode{usb\_altnum\_to\_altsetting}}{const struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ intf}, unsigned int\emph{ altnum}}{}
get the altsetting structure with a given alternate setting number.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct usb\_interface * intf}}] \leavevmode
the interface containing the altsetting in question

\item[{\code{unsigned int altnum}}] \leavevmode
the desired alternate setting number

\end{description}

\textbf{Description}

This searches the altsetting array of the specified interface for
an entry with the correct bAlternateSetting value.

Note that altsettings need not be stored sequentially by number, so
it would be incorrect to assume that the first altsetting entry in
the array corresponds to altsetting zero.  This routine helps device
drivers avoid such mistakes.

Don't call this function unless you are bound to the intf interface
or you have locked the device!

\textbf{Return}

A pointer to the entry of the altsetting array of \textbf{intf} that
has \textbf{altnum} as the alternate setting number. \code{NULL} if not found.
\index{usb\_find\_interface (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_find_interface}\pysiglinewithargsret{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} * \bfcode{usb\_find\_interface}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_driver]{\emph{usb\_driver}}} *\emph{ drv}, int\emph{ minor}}{}
find usb\_interface pointer for driver and device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_driver * drv}}] \leavevmode
the driver whose current configuration is considered

\item[{\code{int minor}}] \leavevmode
the minor number of the desired device

\end{description}

\textbf{Description}

This walks the bus device list and returns a pointer to the interface
with the matching minor and driver.  Note, this only works for devices
that share the USB major number.

\textbf{Return}

A pointer to the interface with the matching major and \textbf{minor}.
\index{usb\_for\_each\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_for_each_dev}\pysiglinewithargsret{int \bfcode{usb\_for\_each\_dev}}{void *\emph{ data}, int (*fn) (struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}}\emph{ *}, void\emph{ *}}{}
iterate over all USB devices in the system

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * data}}] \leavevmode
data pointer that will be handed to the callback function

\item[{\code{int (*)(struct usb\_device *, void *) fn}}] \leavevmode
callback function to be called for each USB device

\end{description}

\textbf{Description}

Iterate over all USB devices and call \textbf{fn} for each, passing it \textbf{data}. If it
returns anything other than 0, we break the iteration prematurely and return
that value.
\index{usb\_alloc\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_alloc_dev}\pysiglinewithargsret{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} * \bfcode{usb\_alloc\_dev}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ parent}, struct usb\_bus *\emph{ bus}, unsigned\emph{ port1}}{}
usb device constructor (usbcore-internal)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * parent}}] \leavevmode
hub to which device is connected; null to allocate a root hub

\item[{\code{struct usb\_bus * bus}}] \leavevmode
bus used to access the device

\item[{\code{unsigned port1}}] \leavevmode
one-based index of port; ignored for root hubs

\end{description}

\textbf{Context}

!:c:func:\emph{in\_interrupt()}

\textbf{Description}

Only hub drivers (including virtual root hub drivers for host
controllers) should ever call this.

This call may not be used in a non-sleeping context.

\textbf{Return}

On success, a pointer to the allocated usb device. \code{NULL} on
failure.
\index{usb\_get\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_get_dev}\pysiglinewithargsret{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} * \bfcode{usb\_get\_dev}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}}{}
increments the reference count of the usb device structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * dev}}] \leavevmode
the device being referenced

\end{description}

\textbf{Description}

Each live reference to a device should be refcounted.

Drivers for USB interfaces should normally record such references in
their \code{probe()} methods, when they bind to an interface, and release
them by calling {\hyperref[driver\string-api/usb/usb:c.usb_put_dev]{\emph{\code{usb\_put\_dev()}}}}, in their \code{disconnect()} methods.

\textbf{Return}

A pointer to the device with the incremented reference counter.
\index{usb\_put\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_put_dev}\pysiglinewithargsret{void \bfcode{usb\_put\_dev}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}}{}
release a use of the usb device structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * dev}}] \leavevmode
device that's been disconnected

\end{description}

\textbf{Description}

Must be called when a user of a device is finished with it.  When the last
user of the device calls this function, the memory of the device is freed.
\index{usb\_get\_intf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_get_intf}\pysiglinewithargsret{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} * \bfcode{usb\_get\_intf}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ intf}}{}
increments the reference count of the usb interface structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_interface * intf}}] \leavevmode
the interface being referenced

\end{description}

\textbf{Description}

Each live reference to a interface must be refcounted.

Drivers for USB interfaces should normally record such references in
their \code{probe()} methods, when they bind to an interface, and release
them by calling {\hyperref[driver\string-api/usb/usb:c.usb_put_intf]{\emph{\code{usb\_put\_intf()}}}}, in their \code{disconnect()} methods.

\textbf{Return}

A pointer to the interface with the incremented reference counter.
\index{usb\_put\_intf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_put_intf}\pysiglinewithargsret{void \bfcode{usb\_put\_intf}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ intf}}{}
release a use of the usb interface structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_interface * intf}}] \leavevmode
interface that's been decremented

\end{description}

\textbf{Description}

Must be called when a user of an interface is finished with it.  When the
last user of the interface calls this function, the memory of the interface
is freed.
\index{usb\_lock\_device\_for\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_lock_device_for_reset}\pysiglinewithargsret{int \bfcode{usb\_lock\_device\_for\_reset}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ udev}, const struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ iface}}{}
cautiously acquire the lock for a usb device structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * udev}}] \leavevmode
device that's being locked

\item[{\code{const struct usb\_interface * iface}}] \leavevmode
interface bound to the driver making the request (optional)

\end{description}

\textbf{Description}

Attempts to acquire the device lock, but fails if the device is
NOTATTACHED or SUSPENDED, or if iface is specified and the interface
is neither BINDING nor BOUND.  Rather than sleeping to wait for the
lock, the routine polls repeatedly.  This is to prevent deadlock with
disconnect; in some drivers (such as usb-storage) the \code{disconnect()}
or \code{suspend()} method will block waiting for a device reset to complete.

\textbf{Return}

A negative error code for failure, otherwise 0.
\index{usb\_get\_current\_frame\_number (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_get_current_frame_number}\pysiglinewithargsret{int \bfcode{usb\_get\_current\_frame\_number}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}}{}
return current bus frame number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * dev}}] \leavevmode
the device whose bus is being queried

\end{description}

\textbf{Return}

The current frame number for the USB host controller used
with the given USB device. This can be used when scheduling
isochronous requests.

\textbf{Note}

Different kinds of host controller have different ``scheduling
horizons''. While one type might support scheduling only 32 frames
into the future, others could support scheduling up to 1024 frames
into the future.
\index{usb\_alloc\_coherent (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_alloc_coherent}\pysiglinewithargsret{void * \bfcode{usb\_alloc\_coherent}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, size\_t\emph{ size}, gfp\_t\emph{ mem\_flags}, dma\_addr\_t *\emph{ dma}}{}
allocate dma-consistent buffer for URB\_NO\_xxx\_DMA\_MAP

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * dev}}] \leavevmode
device the buffer will be used with

\item[{\code{size\_t size}}] \leavevmode
requested buffer size

\item[{\code{gfp\_t mem\_flags}}] \leavevmode
affect whether allocation may block

\item[{\code{dma\_addr\_t * dma}}] \leavevmode
used to return DMA address of buffer

\end{description}

\textbf{Return}

Either null (indicating no buffer could be allocated), or the
cpu-space pointer to a buffer that may be used to perform DMA to the
specified device.  Such cpu-space buffers are returned along with the DMA
address (through the pointer provided).

\textbf{Note}

These buffers are used with URB\_NO\_xxx\_DMA\_MAP set in urb-\textgreater{}transfer\_flags
to avoid behaviors like using ``DMA bounce buffers'', or thrashing IOMMU
hardware during URB completion/resubmit.  The implementation varies between
platforms, depending on details of how DMA will work to this device.
Using these buffers also eliminates cacheline sharing problems on
architectures where CPU caches are not DMA-coherent.  On systems without
bus-snooping caches, these buffers are uncached.

When the buffer is no longer used, free it with {\hyperref[driver\string-api/usb/usb:c.usb_free_coherent]{\emph{\code{usb\_free\_coherent()}}}}.
\index{usb\_free\_coherent (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_free_coherent}\pysiglinewithargsret{void \bfcode{usb\_free\_coherent}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, size\_t\emph{ size}, void *\emph{ addr}, dma\_addr\_t\emph{ dma}}{}
free memory allocated with {\hyperref[driver\string-api/usb/usb:c.usb_alloc_coherent]{\emph{\code{usb\_alloc\_coherent()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * dev}}] \leavevmode
device the buffer was used with

\item[{\code{size\_t size}}] \leavevmode
requested buffer size

\item[{\code{void * addr}}] \leavevmode
CPU address of buffer

\item[{\code{dma\_addr\_t dma}}] \leavevmode
DMA address of buffer

\end{description}

\textbf{Description}

This reclaims an I/O buffer, letting it be reused.  The memory must have
been allocated using {\hyperref[driver\string-api/usb/usb:c.usb_alloc_coherent]{\emph{\code{usb\_alloc\_coherent()}}}}, and the parameters must match
those provided in that allocation request.
\index{usb\_buffer\_map (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_buffer_map}\pysiglinewithargsret{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} * \bfcode{usb\_buffer\_map}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}}{}
create DMA mapping(s) for an urb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
urb whose transfer\_buffer/setup\_packet will be mapped

\end{description}

\textbf{Description}

URB\_NO\_TRANSFER\_DMA\_MAP is added to urb-\textgreater{}transfer\_flags if the operation
succeeds. If the device is connected to this system through a non-DMA
controller, this operation always succeeds.

This call would normally be used for an urb which is reused, perhaps
as the target of a large periodic transfer, with {\hyperref[driver\string-api/usb/usb:c.usb_buffer_dmasync]{\emph{\code{usb\_buffer\_dmasync()}}}}
calls to synchronize memory and dma state.

Reverse the effect of this call with {\hyperref[driver\string-api/usb/usb:c.usb_buffer_unmap]{\emph{\code{usb\_buffer\_unmap()}}}}.

\textbf{Return}

Either \code{NULL} (indicating no buffer could be mapped), or \textbf{urb}.
\index{usb\_buffer\_dmasync (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_buffer_dmasync}\pysiglinewithargsret{void \bfcode{usb\_buffer\_dmasync}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}}{}
synchronize DMA and CPU view of buffer(s)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
urb whose transfer\_buffer/setup\_packet will be synchronized

\end{description}
\index{usb\_buffer\_unmap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_buffer_unmap}\pysiglinewithargsret{void \bfcode{usb\_buffer\_unmap}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}}{}
free DMA mapping(s) for an urb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
urb whose transfer\_buffer will be unmapped

\end{description}

\textbf{Description}

Reverses the effect of {\hyperref[driver\string-api/usb/usb:c.usb_buffer_map]{\emph{\code{usb\_buffer\_map()}}}}.
\index{usb\_buffer\_map\_sg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_buffer_map_sg}\pysiglinewithargsret{int \bfcode{usb\_buffer\_map\_sg}}{const struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, int\emph{ is\_in}, struct scatterlist *\emph{ sg}, int\emph{ nents}}{}
create scatterlist DMA mapping(s) for an endpoint

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct usb\_device * dev}}] \leavevmode
device to which the scatterlist will be mapped

\item[{\code{int is\_in}}] \leavevmode
mapping transfer direction

\item[{\code{struct scatterlist * sg}}] \leavevmode
the scatterlist to map

\item[{\code{int nents}}] \leavevmode
the number of entries in the scatterlist

\end{description}

\textbf{Return}

Either \textless{} 0 (indicating no buffers could be mapped), or the
number of DMA mapping array entries in the scatterlist.

\textbf{Note}

The caller is responsible for placing the resulting DMA addresses from
the scatterlist into URB transfer buffer pointers, and for setting the
URB\_NO\_TRANSFER\_DMA\_MAP transfer flag in each of those URBs.

Top I/O rates come from queuing URBs, instead of waiting for each one
to complete before starting the next I/O.   This is particularly easy
to do with scatterlists.  Just allocate and submit one URB for each DMA
mapping entry returned, stopping on the first error or when all succeed.
Better yet, use the usb\_sg\_*() calls, which do that (and more) for you.

This call would normally be used when translating scatterlist requests,
rather than {\hyperref[driver\string-api/usb/usb:c.usb_buffer_map]{\emph{\code{usb\_buffer\_map()}}}}, since on some hardware (with IOMMUs) it
may be able to coalesce mappings for improved I/O efficiency.

Reverse the effect of this call with {\hyperref[driver\string-api/usb/usb:c.usb_buffer_unmap_sg]{\emph{\code{usb\_buffer\_unmap\_sg()}}}}.
\index{usb\_buffer\_dmasync\_sg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_buffer_dmasync_sg}\pysiglinewithargsret{void \bfcode{usb\_buffer\_dmasync\_sg}}{const struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, int\emph{ is\_in}, struct scatterlist *\emph{ sg}, int\emph{ n\_hw\_ents}}{}
synchronize DMA and CPU view of scatterlist buffer(s)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct usb\_device * dev}}] \leavevmode
device to which the scatterlist will be mapped

\item[{\code{int is\_in}}] \leavevmode
mapping transfer direction

\item[{\code{struct scatterlist * sg}}] \leavevmode
the scatterlist to synchronize

\item[{\code{int n\_hw\_ents}}] \leavevmode
the positive return value from usb\_buffer\_map\_sg

\end{description}

\textbf{Description}

Use this when you are re-using a scatterlist's data buffers for
another USB request.
\index{usb\_buffer\_unmap\_sg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_buffer_unmap_sg}\pysiglinewithargsret{void \bfcode{usb\_buffer\_unmap\_sg}}{const struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ dev}, int\emph{ is\_in}, struct scatterlist *\emph{ sg}, int\emph{ n\_hw\_ents}}{}
free DMA mapping(s) for a scatterlist

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct usb\_device * dev}}] \leavevmode
device to which the scatterlist will be mapped

\item[{\code{int is\_in}}] \leavevmode
mapping transfer direction

\item[{\code{struct scatterlist * sg}}] \leavevmode
the scatterlist to unmap

\item[{\code{int n\_hw\_ents}}] \leavevmode
the positive return value from usb\_buffer\_map\_sg

\end{description}

\textbf{Description}

Reverses the effect of {\hyperref[driver\string-api/usb/usb:c.usb_buffer_map_sg]{\emph{\code{usb\_buffer\_map\_sg()}}}}.
\index{usb\_hub\_clear\_tt\_buffer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_hub_clear_tt_buffer}\pysiglinewithargsret{int \bfcode{usb\_hub\_clear\_tt\_buffer}}{struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}}{}
clear control/bulk TT state in high speed hub

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct urb * urb}}] \leavevmode
an URB associated with the failed or incomplete split transaction

\end{description}

\textbf{Description}

High speed HCDs use this to tell the hub driver that some split control or
bulk transaction failed in a way that requires clearing internal state of
a transaction translator.  This is normally detected (and reported) from
interrupt context.

It may not be possible for that hub to handle additional full (or low)
speed transactions until that state is fully cleared out.

\textbf{Return}

0 if successful. A negative error code otherwise.
\index{usb\_set\_device\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_set_device_state}\pysiglinewithargsret{void \bfcode{usb\_set\_device\_state}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ udev}, enum usb\_device\_state\emph{ new\_state}}{}
change a device's current state (usbcore, hcds)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * udev}}] \leavevmode
pointer to device whose state should be changed

\item[{\code{enum usb\_device\_state new\_state}}] \leavevmode
new state value to be stored

\end{description}

\textbf{Description}

udev-\textgreater{}state is \_not\_ fully protected by the device lock.  Although
most transitions are made only while holding the lock, the state can
can change to USB\_STATE\_NOTATTACHED at almost any time.  This
is so that devices can be marked as disconnected as soon as possible,
without having to wait for any semaphores to be released.  As a result,
all changes to any device's state must be protected by the
device\_state\_lock spinlock.

Once a device has been added to the device tree, all changes to its state
should be made using this routine.  The state should \_not\_ be set directly.

If udev-\textgreater{}state is already USB\_STATE\_NOTATTACHED then no change is made.
Otherwise udev-\textgreater{}state is set to new\_state, and if new\_state is
USB\_STATE\_NOTATTACHED then all of udev's descendants' states are also set
to USB\_STATE\_NOTATTACHED.
\index{usb\_root\_hub\_lost\_power (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_root_hub_lost_power}\pysiglinewithargsret{void \bfcode{usb\_root\_hub\_lost\_power}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ rhdev}}{}
called by HCD if the root hub lost Vbus power

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * rhdev}}] \leavevmode
struct usb\_device for the root hub

\end{description}

\textbf{Description}

The USB host controller driver calls this function when its root hub
is resumed and Vbus power has been interrupted or the controller
has been reset.  The routine marks \textbf{rhdev} as having lost power.
When the hub driver is resumed it will take notice and carry out
power-session recovery for all the ``USB-PERSIST''-enabled child devices;
the others will be disconnected.
\index{usb\_reset\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_reset_device}\pysiglinewithargsret{int \bfcode{usb\_reset\_device}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ udev}}{}
warn interface drivers and perform a USB port reset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * udev}}] \leavevmode
device to reset (not in SUSPENDED or NOTATTACHED state)

\end{description}

\textbf{Description}

Warns all drivers bound to registered interfaces (using their pre\_reset
method), performs the port reset, and then lets the drivers know that
the reset is over (using their post\_reset method).

\textbf{Return}

The same as for \code{usb\_reset\_and\_verify\_device()}.

\textbf{Note}

The caller must own the device lock.  For example, it's safe to use
this from a driver \code{probe()} routine after downloading new firmware.
For calls that might not occur during \code{probe()}, drivers should lock
the device using {\hyperref[driver\string-api/usb/usb:c.usb_lock_device_for_reset]{\emph{\code{usb\_lock\_device\_for\_reset()}}}}.

If an interface is currently being probed or disconnected, we assume
its driver knows how to handle resets.  For all other interfaces,
if the driver doesn't have pre\_reset and post\_reset methods then
we attempt to unbind it and rebind afterward.
\index{usb\_queue\_reset\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_queue_reset_device}\pysiglinewithargsret{void \bfcode{usb\_queue\_reset\_device}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ iface}}{}
Reset a USB device from an atomic context

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_interface * iface}}] \leavevmode
USB interface belonging to the device to reset

\end{description}

\textbf{Description}

This function can be used to reset a USB device from an atomic
context, where {\hyperref[driver\string-api/usb/usb:c.usb_reset_device]{\emph{\code{usb\_reset\_device()}}}} won't work (as it blocks).

Doing a reset via this method is functionally equivalent to calling
{\hyperref[driver\string-api/usb/usb:c.usb_reset_device]{\emph{\code{usb\_reset\_device()}}}}, except for the fact that it is delayed to a
workqueue. This means that any drivers bound to other interfaces
might be unbound, as well as users from usbfs in user space.

Corner cases:
\begin{itemize}
\item {} 
Scheduling two resets at the same time from two different drivers
attached to two different interfaces of the same device is
possible; depending on how the driver attached to each interface
handles -\textgreater{}:c:func:\emph{pre\_reset()}, the second reset might happen or not.

\item {} 
If the reset is delayed so long that the interface is unbound from
its driver, the reset will be skipped.

\item {} 
This function can be called during .:c:func:\emph{probe()}.  It can also be called
during .:c:func:\emph{disconnect()}, but doing so is pointless because the reset
will not occur.  If you really want to reset the device during
.:c:func:\emph{disconnect()}, call {\hyperref[driver\string-api/usb/usb:c.usb_reset_device]{\emph{\code{usb\_reset\_device()}}}} directly -- but watch out
for nested unbinding issues!

\end{itemize}
\index{usb\_hub\_find\_child (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_hub_find_child}\pysiglinewithargsret{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} * \bfcode{usb\_hub\_find\_child}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{usb\_device}}} *\emph{ hdev}, int\emph{ port1}}{}
Get the pointer of child device attached to the port which is specified by \textbf{port1}.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_device * hdev}}] \leavevmode
USB device belonging to the usb hub

\item[{\code{int port1}}] \leavevmode
port num to indicate which port the child device
is attached to.

\end{description}

\textbf{Description}

USB drivers call this function to get hub's child device
pointer.

\textbf{Return}

\code{NULL} if input param is invalid and
child's usb\_device pointer if non-NULL.


\subsection{Host Controller APIs}
\label{driver-api/usb/usb:host-controller-apis}
These APIs are only for use by host controller drivers, most of which
implement standard register interfaces such as XHCI, EHCI, OHCI, or UHCI. UHCI
was one of the first interfaces, designed by Intel and also used by VIA;
it doesn't do much in hardware. OHCI was designed later, to have the
hardware do more work (bigger transfers, tracking protocol state, and so
on). EHCI was designed with USB 2.0; its design has features that
resemble OHCI (hardware does much more work) as well as UHCI (some parts
of ISO support, TD list processing). XHCI was designed with USB 3.0. It
continues to shift support for functionality into hardware.

There are host controllers other than the ``big three'', although most PCI
based controllers (and a few non-PCI based ones) use one of those
interfaces. Not all host controllers use DMA; some use PIO, and there is
also a simulator and a virtual host controller to pipe USB over the network.

The same basic APIs are available to drivers for all those controllers.
For historical reasons they are in two layers: \code{struct
usb\_bus} is a rather thin layer that became available
in the 2.2 kernels, while \code{struct usb\_hcd}
is a more featureful layer
that lets HCDs share common code, to shrink driver size and
significantly reduce hcd-specific behaviors.
\index{usb\_calc\_bus\_time (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_calc_bus_time}\pysiglinewithargsret{long \bfcode{usb\_calc\_bus\_time}}{int\emph{ speed}, int\emph{ is\_input}, int\emph{ isoc}, int\emph{ bytecount}}{}
approximate periodic transaction time in nanoseconds

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int speed}}] \leavevmode
from dev-\textgreater{}speed; USB\_SPEED\_\{LOW,FULL,HIGH\}

\item[{\code{int is\_input}}] \leavevmode
true iff the transaction sends data to the host

\item[{\code{int isoc}}] \leavevmode
true for isochronous transactions, false for interrupt ones

\item[{\code{int bytecount}}] \leavevmode
how many bytes in the transaction.

\end{description}

\textbf{Return}

Approximate bus time in nanoseconds for a periodic transaction.

\textbf{Note}

See USB 2.0 spec section 5.11.3; only periodic transfers need to be
scheduled in software, this function is only used for such scheduling.
\index{usb\_hcd\_link\_urb\_to\_ep (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_hcd_link_urb_to_ep}\pysiglinewithargsret{int \bfcode{usb\_hcd\_link\_urb\_to\_ep}}{struct usb\_hcd *\emph{ hcd}, struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}}{}
add an URB to its endpoint queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_hcd * hcd}}] \leavevmode
host controller to which \textbf{urb} was submitted

\item[{\code{struct urb * urb}}] \leavevmode
URB being submitted

\end{description}

\textbf{Description}

Host controller drivers should call this routine in their \code{enqueue()}
method.  The HCD's private spinlock must be held and interrupts must
be disabled.  The actions carried out here are required for URB
submission, as well as for endpoint shutdown and for usb\_kill\_urb.

\textbf{Return}

0 for no error, otherwise a negative error code (in which case
the \code{enqueue()} method must fail).  If no error occurs but \code{enqueue()} fails
anyway, it must call {\hyperref[driver\string-api/usb/usb:c.usb_hcd_unlink_urb_from_ep]{\emph{\code{usb\_hcd\_unlink\_urb\_from\_ep()}}}} before releasing
the private spinlock and returning.
\index{usb\_hcd\_check\_unlink\_urb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_hcd_check_unlink_urb}\pysiglinewithargsret{int \bfcode{usb\_hcd\_check\_unlink\_urb}}{struct usb\_hcd *\emph{ hcd}, struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}, int\emph{ status}}{}
check whether an URB may be unlinked

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_hcd * hcd}}] \leavevmode
host controller to which \textbf{urb} was submitted

\item[{\code{struct urb * urb}}] \leavevmode
URB being checked for unlinkability

\item[{\code{int status}}] \leavevmode
error code to store in \textbf{urb} if the unlink succeeds

\end{description}

\textbf{Description}

Host controller drivers should call this routine in their \code{dequeue()}
method.  The HCD's private spinlock must be held and interrupts must
be disabled.  The actions carried out here are required for making
sure than an unlink is valid.

\textbf{Return}

0 for no error, otherwise a negative error code (in which case
the \code{dequeue()} method must fail).  The possible error codes are:
\begin{quote}
\begin{description}
\item[{-EIDRM: \textbf{urb} was not submitted or has already completed.}] \leavevmode
The completion function may not have been called yet.

\end{description}

-EBUSY: \textbf{urb} has already been unlinked.
\end{quote}
\index{usb\_hcd\_unlink\_urb\_from\_ep (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_hcd_unlink_urb_from_ep}\pysiglinewithargsret{void \bfcode{usb\_hcd\_unlink\_urb\_from\_ep}}{struct usb\_hcd *\emph{ hcd}, struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}}{}
remove an URB from its endpoint queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_hcd * hcd}}] \leavevmode
host controller to which \textbf{urb} was submitted

\item[{\code{struct urb * urb}}] \leavevmode
URB being unlinked

\end{description}

\textbf{Description}

Host controller drivers should call this routine before calling
{\hyperref[driver\string-api/usb/usb:c.usb_hcd_giveback_urb]{\emph{\code{usb\_hcd\_giveback\_urb()}}}}.  The HCD's private spinlock must be held and
interrupts must be disabled.  The actions carried out here are required
for URB completion.
\index{usb\_hcd\_giveback\_urb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_hcd_giveback_urb}\pysiglinewithargsret{void \bfcode{usb\_hcd\_giveback\_urb}}{struct usb\_hcd *\emph{ hcd}, struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{urb}}} *\emph{ urb}, int\emph{ status}}{}
return URB from HCD to device driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_hcd * hcd}}] \leavevmode
host controller returning the URB

\item[{\code{struct urb * urb}}] \leavevmode
urb being returned to the USB device driver.

\item[{\code{int status}}] \leavevmode
completion status code for the URB.

\end{description}

\textbf{Context}

\code{in\_interrupt()}

\textbf{Description}

This hands the URB from HCD to its USB device driver, using its
completion function.  The HCD has freed all per-urb resources
(and is done using urb-\textgreater{}hcpriv).  It also released all HCD locks;
the device driver won't cause problems if it frees, modifies,
or resubmits this URB.

If \textbf{urb} was unlinked, the value of \textbf{status} will be overridden by
\textbf{urb}-\textgreater{}unlinked.  Erroneous short transfers are detected in case
the HCD hasn't checked for them.
\index{usb\_alloc\_streams (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_alloc_streams}\pysiglinewithargsret{int \bfcode{usb\_alloc\_streams}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ interface}, struct {\hyperref[driver\string-api/usb/usb:c.usb_host_endpoint]{\emph{usb\_host\_endpoint}}} **\emph{ eps}, unsigned int\emph{ num\_eps}, unsigned int\emph{ num\_streams}, gfp\_t\emph{ mem\_flags}}{}
allocate bulk endpoint stream IDs.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_interface * interface}}] \leavevmode
alternate setting that includes all endpoints.

\item[{\code{struct usb\_host\_endpoint ** eps}}] \leavevmode
array of endpoints that need streams.

\item[{\code{unsigned int num\_eps}}] \leavevmode
number of endpoints in the array.

\item[{\code{unsigned int num\_streams}}] \leavevmode
number of streams to allocate.

\item[{\code{gfp\_t mem\_flags}}] \leavevmode
flags hcd should use to allocate memory.

\end{description}

\textbf{Description}

Sets up a group of bulk endpoints to have \textbf{num\_streams} stream IDs available.
Drivers may queue multiple transfers to different stream IDs, which may
complete in a different order than they were queued.

\textbf{Return}

On success, the number of allocated streams. On failure, a negative
error code.
\index{usb\_free\_streams (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_free_streams}\pysiglinewithargsret{int \bfcode{usb\_free\_streams}}{struct {\hyperref[driver\string-api/usb/usb:c.usb_interface]{\emph{usb\_interface}}} *\emph{ interface}, struct {\hyperref[driver\string-api/usb/usb:c.usb_host_endpoint]{\emph{usb\_host\_endpoint}}} **\emph{ eps}, unsigned int\emph{ num\_eps}, gfp\_t\emph{ mem\_flags}}{}
free bulk endpoint stream IDs.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_interface * interface}}] \leavevmode
alternate setting that includes all endpoints.

\item[{\code{struct usb\_host\_endpoint ** eps}}] \leavevmode
array of endpoints to remove streams from.

\item[{\code{unsigned int num\_eps}}] \leavevmode
number of endpoints in the array.

\item[{\code{gfp\_t mem\_flags}}] \leavevmode
flags hcd should use to allocate memory.

\end{description}

\textbf{Description}

Reverts a group of bulk endpoints back to not using stream IDs.
Can fail if we are given bad arguments, or HCD is broken.

\textbf{Return}

0 on success. On failure, a negative error code.
\index{usb\_hcd\_resume\_root\_hub (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_hcd_resume_root_hub}\pysiglinewithargsret{void \bfcode{usb\_hcd\_resume\_root\_hub}}{struct usb\_hcd *\emph{ hcd}}{}
called by HCD to resume its root hub

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_hcd * hcd}}] \leavevmode
host controller for this root hub

\end{description}

\textbf{Description}

The USB host controller calls this function when its root hub is
suspended (with the remote wakeup feature enabled) and a remote
wakeup request is received.  The routine submits a workqueue request
to resume the root hub (that is, manage its downstream ports again).
\index{usb\_bus\_start\_enum (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_bus_start_enum}\pysiglinewithargsret{int \bfcode{usb\_bus\_start\_enum}}{struct usb\_bus *\emph{ bus}, unsigned\emph{ port\_num}}{}
start immediate enumeration (for OTG)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_bus * bus}}] \leavevmode
the bus (must use hcd framework)

\item[{\code{unsigned port\_num}}] \leavevmode
1-based number of port; usually bus-\textgreater{}otg\_port

\end{description}

\textbf{Context}

\code{in\_interrupt()}

\textbf{Description}

Starts enumeration, with an immediate reset followed later by
hub\_wq identifying and possibly configuring the device.
This is needed by OTG controller drivers, where it helps meet
HNP protocol timing requirements for starting a port reset.

\textbf{Return}

0 if successful.
\index{usb\_hcd\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_hcd_irq}\pysiglinewithargsret{irqreturn\_t \bfcode{usb\_hcd\_irq}}{int\emph{ irq}, void *\emph{ \_\_hcd}}{}
hook IRQs to HCD framework (bus glue)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int irq}}] \leavevmode
the IRQ being raised

\item[{\code{void * \_\_hcd}}] \leavevmode
pointer to the HCD whose IRQ is being signaled

\end{description}

\textbf{Description}

If the controller isn't HALTed, calls the driver's irq handler.
Checks whether the controller is now dead.

\textbf{Return}

\code{IRQ\_HANDLED} if the IRQ was handled. \code{IRQ\_NONE} otherwise.
\index{usb\_hc\_died (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_hc_died}\pysiglinewithargsret{void \bfcode{usb\_hc\_died}}{struct usb\_hcd *\emph{ hcd}}{}
report abnormal shutdown of a host controller (bus glue)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_hcd * hcd}}] \leavevmode
pointer to the HCD representing the controller

\end{description}

\textbf{Description}

This is called by bus glue to report a USB host controller that died
while operations may still have been pending.  It's called automatically
by the PCI glue, so only glue for non-PCI busses should need to call it.

Only call this function with the primary HCD.
\index{usb\_create\_shared\_hcd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_create_shared_hcd}\pysiglinewithargsret{struct usb\_hcd * \bfcode{usb\_create\_shared\_hcd}}{const struct hc\_driver *\emph{ driver}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ bus\_name}, struct usb\_hcd *\emph{ primary\_hcd}}{}
create and initialize an HCD structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct hc\_driver * driver}}] \leavevmode
HC driver that will use this hcd

\item[{\code{struct device * dev}}] \leavevmode
device for this HC, stored in hcd-\textgreater{}self.controller

\item[{\code{const char * bus\_name}}] \leavevmode
value to store in hcd-\textgreater{}self.bus\_name

\item[{\code{struct usb\_hcd * primary\_hcd}}] \leavevmode
a pointer to the usb\_hcd structure that is sharing the
PCI device.  Only allocate certain resources for the primary HCD

\end{description}

\textbf{Context}

!:c:func:\emph{in\_interrupt()}

\textbf{Description}

Allocate a struct usb\_hcd, with extra space at the end for the
HC driver's private data.  Initialize the generic members of the
hcd structure.

\textbf{Return}

On success, a pointer to the created and initialized HCD structure.
On failure (e.g. if memory is unavailable), \code{NULL}.
\index{usb\_create\_hcd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_create_hcd}\pysiglinewithargsret{struct usb\_hcd * \bfcode{usb\_create\_hcd}}{const struct hc\_driver *\emph{ driver}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ bus\_name}}{}
create and initialize an HCD structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct hc\_driver * driver}}] \leavevmode
HC driver that will use this hcd

\item[{\code{struct device * dev}}] \leavevmode
device for this HC, stored in hcd-\textgreater{}self.controller

\item[{\code{const char * bus\_name}}] \leavevmode
value to store in hcd-\textgreater{}self.bus\_name

\end{description}

\textbf{Context}

!:c:func:\emph{in\_interrupt()}

\textbf{Description}

Allocate a struct usb\_hcd, with extra space at the end for the
HC driver's private data.  Initialize the generic members of the
hcd structure.

\textbf{Return}

On success, a pointer to the created and initialized HCD
structure. On failure (e.g. if memory is unavailable), \code{NULL}.
\index{usb\_add\_hcd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_add_hcd}\pysiglinewithargsret{int \bfcode{usb\_add\_hcd}}{struct usb\_hcd *\emph{ hcd}, unsigned int\emph{ irqnum}, unsigned long\emph{ irqflags}}{}
finish generic HCD structure initialization and register

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_hcd * hcd}}] \leavevmode
the usb\_hcd structure to initialize

\item[{\code{unsigned int irqnum}}] \leavevmode
Interrupt line to allocate

\item[{\code{unsigned long irqflags}}] \leavevmode
Interrupt type flags

\end{description}

\textbf{Description}

Finish the remaining parts of generic HCD initialization: allocate the
buffers of consistent memory, register the bus, request the IRQ line,
and call the driver's \code{reset()} and \code{start()} routines.
\index{usb\_remove\_hcd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_remove_hcd}\pysiglinewithargsret{void \bfcode{usb\_remove\_hcd}}{struct usb\_hcd *\emph{ hcd}}{}
shutdown processing for generic HCDs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_hcd * hcd}}] \leavevmode
the usb\_hcd structure to remove

\end{description}

\textbf{Context}

!:c:func:\emph{in\_interrupt()}

\textbf{Description}

Disconnects the root hub, then reverses the effects of {\hyperref[driver\string-api/usb/usb:c.usb_add_hcd]{\emph{\code{usb\_add\_hcd()}}}},
invoking the HCD's \code{stop()} method.
\index{usb\_hcd\_pci\_probe (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_hcd_pci_probe}\pysiglinewithargsret{int \bfcode{usb\_hcd\_pci\_probe}}{struct pci\_dev *\emph{ dev}, const struct pci\_device\_id *\emph{ id}}{}
initialize PCI-based HCDs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
USB Host Controller being probed

\item[{\code{const struct pci\_device\_id * id}}] \leavevmode
pci hotplug id connecting controller to HCD framework

\end{description}

\textbf{Context}

!:c:func:\emph{in\_interrupt()}

\textbf{Description}

Allocates basic PCI resources for this USB host controller, and
then invokes the \code{start()} method for the HCD associated with it
through the hotplug entry's driver\_data.

Store this function in the HCD's struct pci\_driver as \code{probe()}.

\textbf{Return}

0 if successful.
\index{usb\_hcd\_pci\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_hcd_pci_remove}\pysiglinewithargsret{void \bfcode{usb\_hcd\_pci\_remove}}{struct pci\_dev *\emph{ dev}}{}
shutdown processing for PCI-based HCDs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
USB Host Controller being removed

\end{description}

\textbf{Context}

!:c:func:\emph{in\_interrupt()}

\textbf{Description}

Reverses the effect of {\hyperref[driver\string-api/usb/usb:c.usb_hcd_pci_probe]{\emph{\code{usb\_hcd\_pci\_probe()}}}}, first invoking
the HCD's \code{stop()} method.  It is always called from a thread
context, normally ``rmmod'', ``apmd'', or something similar.

Store this function in the HCD's struct pci\_driver as \code{remove()}.
\index{usb\_hcd\_pci\_shutdown (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.usb_hcd_pci_shutdown}\pysiglinewithargsret{void \bfcode{usb\_hcd\_pci\_shutdown}}{struct pci\_dev *\emph{ dev}}{}
shutdown host controller

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
USB Host Controller being shutdown

\end{description}
\index{hcd\_buffer\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.hcd_buffer_create}\pysiglinewithargsret{int \bfcode{hcd\_buffer\_create}}{struct usb\_hcd *\emph{ hcd}}{}
initialize buffer pools

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_hcd * hcd}}] \leavevmode
the bus whose buffer pools are to be initialized

\end{description}

\textbf{Context}

!:c:func:\emph{in\_interrupt()}

\textbf{Description}

Call this as part of initializing a host controller that uses the dma
memory allocators.  It initializes some pools of dma-coherent memory that
will be shared by all drivers using that controller.

Call {\hyperref[driver\string-api/usb/usb:c.hcd_buffer_destroy]{\emph{\code{hcd\_buffer\_destroy()}}}} to clean up after using those pools.

\textbf{Return}

0 if successful. A negative errno value otherwise.
\index{hcd\_buffer\_destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/usb:c.hcd_buffer_destroy}\pysiglinewithargsret{void \bfcode{hcd\_buffer\_destroy}}{struct usb\_hcd *\emph{ hcd}}{}
deallocate buffer pools

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_hcd * hcd}}] \leavevmode
the bus whose buffer pools are to be destroyed

\end{description}

\textbf{Context}

!:c:func:\emph{in\_interrupt()}

\textbf{Description}

This frees the buffer pools created by {\hyperref[driver\string-api/usb/usb:c.hcd_buffer_create]{\emph{\code{hcd\_buffer\_create()}}}}.


\subsection{The USB character device nodes}
\label{driver-api/usb/usb:the-usb-character-device-nodes}
This chapter presents the Linux character device nodes. You may prefer
to avoid writing new kernel code for your USB driver. User mode device
drivers are usually packaged as applications or libraries, and may use
character devices through some programming library that wraps it.
Such libraries include:
\begin{itemize}
\item {} 
\href{http://libusb.sourceforge.net}{libusb} for C/C++, and

\item {} 
\href{http://jUSB.sourceforge.net}{jUSB} for Java.

\end{itemize}

Some old information about it can be seen at the ``USB Device Filesystem''
section of the USB Guide. The latest copy of the USB Guide can be found
at \href{http://www.linux-usb.org/}{http://www.linux-usb.org/}

\begin{notice}{note}{Note:}\begin{itemize}
\item {} 
They were used to be implemented via \emph{usbfs}, but this is not part of
the sysfs debug interface.

\end{itemize}
\begin{itemize}
\item {} 
This particular documentation is incomplete, especially with respect
to the asynchronous mode. As of kernel 2.5.66 the code and this
(new) documentation need to be cross-reviewed.

\end{itemize}
\end{notice}


\subsubsection{What files are in ``devtmpfs''?}
\label{driver-api/usb/usb:what-files-are-in-devtmpfs}
Conventionally mounted at \code{/dev/bus/usb/}, usbfs features include:
\begin{itemize}
\item {} 
\code{/dev/bus/usb/BBB/DDD} ... magic files exposing the each device's
configuration descriptors, and supporting a series of ioctls for
making device requests, including I/O to devices. (Purely for access
by programs.)

\end{itemize}

Each bus is given a number (\code{BBB}) based on when it was enumerated; within
each bus, each device is given a similar number (\code{DDD}). Those \code{BBB/DDD}
paths are not ``stable'' identifiers; expect them to change even if you
always leave the devices plugged in to the same hub port. \emph{Don't even
think of saving these in application configuration files.} Stable
identifiers are available, for user mode applications that want to use
them. HID and networking devices expose these stable IDs, so that for
example you can be sure that you told the right UPS to power down its
second server. Pleast note that it doesn't (yet) expose those IDs.


\subsubsection{/dev/bus/usb/BBB/DDD}
\label{driver-api/usb/usb:dev-bus-usb-bbb-ddd}
Use these files in one of these basic ways:
\begin{itemize}
\item {} 
\emph{They can be read,} producing first the device descriptor (18 bytes) and
then the descriptors for the current configuration. See the USB 2.0 spec
for details about those binary data formats. You'll need to convert most
multibyte values from little endian format to your native host byte
order, although a few of the fields in the device descriptor (both of
the BCD-encoded fields, and the vendor and product IDs) will be
byteswapped for you. Note that configuration descriptors include
descriptors for interfaces, altsettings, endpoints, and maybe additional
class descriptors.

\item {} 
\emph{Perform USB operations} using \emph{ioctl()} requests to make endpoint I/O
requests (synchronously or asynchronously) or manage the device. These
requests need the \code{CAP\_SYS\_RAWIO} capability, as well as filesystem
access permissions. Only one ioctl request can be made on one of these
device files at a time. This means that if you are synchronously reading
an endpoint from one thread, you won't be able to write to a different
endpoint from another thread until the read completes. This works for
\emph{half duplex} protocols, but otherwise you'd use asynchronous i/o
requests.

\end{itemize}

Each connected USB device has one file.  The \code{BBB} indicates the bus
number.  The \code{DDD} indicates the device address on that bus.  Both
of these numbers are assigned sequentially, and can be reused, so
you can't rely on them for stable access to devices.  For example,
it's relatively common for devices to re-enumerate while they are
still connected (perhaps someone jostled their power supply, hub,
or USB cable), so a device might be \code{002/027} when you first connect
it and \code{002/048} sometime later.

These files can be read as binary data.  The binary data consists
of first the device descriptor, then the descriptors for each
configuration of the device.  Multi-byte fields in the device descriptor
are converted to host endianness by the kernel.  The configuration
descriptors are in bus endian format! The configuration descriptor
are wTotalLength bytes apart. If a device returns less configuration
descriptor data than indicated by wTotalLength there will be a hole in
the file for the missing bytes.  This information is also shown
in text form by the \code{/sys/kernel/debug/usb/devices} file, described later.

These files may also be used to write user-level drivers for the USB
devices.  You would open the \code{/dev/bus/usb/BBB/DDD} file read/write,
read its descriptors to make sure it's the device you expect, and then
bind to an interface (or perhaps several) using an ioctl call.  You
would issue more ioctls to the device to communicate to it using
control, bulk, or other kinds of USB transfers.  The IOCTLs are
listed in the \code{\textless{}linux/usbdevice\_fs.h\textgreater{}} file, and at this writing the
source code (\code{linux/drivers/usb/core/devio.c}) is the primary reference
for how to access devices through those files.

Note that since by default these \code{BBB/DDD} files are writable only by
root, only root can write such user mode drivers.  You can selectively
grant read/write permissions to other users by using \code{chmod}.  Also,
usbfs mount options such as \code{devmode=0666} may be helpful.


\subsubsection{Life Cycle of User Mode Drivers}
\label{driver-api/usb/usb:life-cycle-of-user-mode-drivers}
Such a driver first needs to find a device file for a device it knows
how to handle. Maybe it was told about it because a \code{/sbin/hotplug}
event handling agent chose that driver to handle the new device. Or
maybe it's an application that scans all the \code{/dev/bus/usb} device files,
and ignores most devices. In either case, it should \code{read()}
all the descriptors from the device file, and check them against what it
knows how to handle. It might just reject everything except a particular
vendor and product ID, or need a more complex policy.

Never assume there will only be one such device on the system at a time!
If your code can't handle more than one device at a time, at least
detect when there's more than one, and have your users choose which
device to use.

Once your user mode driver knows what device to use, it interacts with
it in either of two styles. The simple style is to make only control
requests; some devices don't need more complex interactions than those.
(An example might be software using vendor-specific control requests for
some initialization or configuration tasks, with a kernel driver for the
rest.)

More likely, you need a more complex style driver: one using non-control
endpoints, reading or writing data and claiming exclusive use of an
interface. \emph{Bulk} transfers are easiest to use, but only their sibling
\emph{interrupt} transfers work with low speed devices. Both interrupt and
\emph{isochronous} transfers offer service guarantees because their bandwidth
is reserved. Such ``periodic'' transfers are awkward to use through usbfs,
unless you're using the asynchronous calls. However, interrupt transfers
can also be used in a synchronous ``one shot'' style.

Your user-mode driver should never need to worry about cleaning up
request state when the device is disconnected, although it should close
its open file descriptors as soon as it starts seeing the ENODEV errors.


\subsubsection{The ioctl() Requests}
\label{driver-api/usb/usb:the-ioctl-requests}
To use these ioctls, you need to include the following headers in your
userspace program:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}linux/usb.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}linux/usbdevice\PYGZus{}fs.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}asm/byteorder.h\PYGZgt{}
\end{Verbatim}

The standard USB device model requests, from ``Chapter 9'' of the USB 2.0
specification, are automatically included from the \code{\textless{}linux/usb/ch9.h\textgreater{}}
header.

Unless noted otherwise, the ioctl requests described here will update
the modification time on the usbfs file to which they are applied
(unless they fail). A return of zero indicates success; otherwise, a
standard USB error code is returned (These are documented in
{\hyperref[driver\string-api/usb/error\string-codes:usb\string-error\string-codes]{\emph{USB Error codes}}}).

Each of these files multiplexes access to several I/O streams, one per
endpoint. Each device has one control endpoint (endpoint zero) which
supports a limited RPC style RPC access. Devices are configured by
hub\_wq (in the kernel) setting a device-wide \emph{configuration} that
affects things like power consumption and basic functionality. The
endpoints are part of USB \emph{interfaces}, which may have \emph{altsettings}
affecting things like which endpoints are available. Many devices only
have a single configuration and interface, so drivers for them will
ignore configurations and altsettings.


\paragraph{Management/Status Requests}
\label{driver-api/usb/usb:management-status-requests}
A number of usbfs requests don't deal very directly with device I/O.
They mostly relate to device management and status. These are all
synchronous requests.
\begin{description}
\item[{USBDEVFS\_CLAIMINTERFACE}] \leavevmode
This is used to force usbfs to claim a specific interface, which has
not previously been claimed by usbfs or any other kernel driver. The
ioctl parameter is an integer holding the number of the interface
(bInterfaceNumber from descriptor).

Note that if your driver doesn't claim an interface before trying to
use one of its endpoints, and no other driver has bound to it, then
the interface is automatically claimed by usbfs.

This claim will be released by a RELEASEINTERFACE ioctl, or by
closing the file descriptor. File modification time is not updated
by this request.

\item[{USBDEVFS\_CONNECTINFO}] \leavevmode
Says whether the device is lowspeed. The ioctl parameter points to a
structure like this:

\begin{Verbatim}[commandchars=\\\{\}]
struct usbdevfs\PYGZus{}connectinfo \PYGZob{}
        unsigned int   devnum;
        unsigned char  slow;
\PYGZcb{};
\end{Verbatim}

File modification time is not updated by this request.

\emph{You can't tell whether a ``not slow'' device is connected at high
speed (480 MBit/sec) or just full speed (12 MBit/sec).} You should
know the devnum value already, it's the DDD value of the device file
name.

\item[{USBDEVFS\_GETDRIVER}] \leavevmode
Returns the name of the kernel driver bound to a given interface (a
string). Parameter is a pointer to this structure, which is
modified:

\begin{Verbatim}[commandchars=\\\{\}]
struct usbdevfs\PYGZus{}getdriver \PYGZob{}
        unsigned int  interface;
        char          driver[USBDEVFS\PYGZus{}MAXDRIVERNAME + 1];
\PYGZcb{};
\end{Verbatim}

File modification time is not updated by this request.

\item[{USBDEVFS\_IOCTL}] \leavevmode
Passes a request from userspace through to a kernel driver that has
an ioctl entry in the \emph{struct usb\_driver} it registered:

\begin{Verbatim}[commandchars=\\\{\}]
struct usbdevfs\PYGZus{}ioctl \PYGZob{}
        int     ifno;
        int     ioctl\PYGZus{}code;
        void    *data;
\PYGZcb{};

/* user mode call looks like this.
 * \PYGZsq{}request\PYGZsq{} becomes the driver\PYGZhy{}\PYGZgt{}ioctl() \PYGZsq{}code\PYGZsq{} parameter.
 * the size of \PYGZsq{}param\PYGZsq{} is encoded in \PYGZsq{}request\PYGZsq{}, and that data
 * is copied to or from the driver\PYGZhy{}\PYGZgt{}ioctl() \PYGZsq{}buf\PYGZsq{} parameter.
 */
static int
usbdev\PYGZus{}ioctl (int fd, int ifno, unsigned request, void *param)
\PYGZob{}
        struct usbdevfs\PYGZus{}ioctl   wrapper;

        wrapper.ifno = ifno;
        wrapper.ioctl\PYGZus{}code = request;
        wrapper.data = param;

        return ioctl (fd, USBDEVFS\PYGZus{}IOCTL, \PYGZam{}wrapper);
\PYGZcb{}
\end{Verbatim}

File modification time is not updated by this request.

This request lets kernel drivers talk to user mode code through
filesystem operations even when they don't create a character or
block special device. It's also been used to do things like ask
devices what device special file should be used. Two pre-defined
ioctls are used to disconnect and reconnect kernel drivers, so that
user mode code can completely manage binding and configuration of
devices.

\item[{USBDEVFS\_RELEASEINTERFACE}] \leavevmode
This is used to release the claim usbfs made on interface, either
implicitly or because of a USBDEVFS\_CLAIMINTERFACE call, before the
file descriptor is closed. The ioctl parameter is an integer holding
the number of the interface (bInterfaceNumber from descriptor); File
modification time is not updated by this request.

\begin{notice}{warning}{Warning:}
\emph{No security check is made to ensure that the task which made
the claim is the one which is releasing it. This means that user
mode driver may interfere other ones.}
\end{notice}

\item[{USBDEVFS\_RESETEP}] \leavevmode
Resets the data toggle value for an endpoint (bulk or interrupt) to
DATA0. The ioctl parameter is an integer endpoint number (1 to 15,
as identified in the endpoint descriptor), with USB\_DIR\_IN added
if the device's endpoint sends data to the host.

\begin{notice}{warning}{Warning:}
\emph{Avoid using this request. It should probably be removed.} Using
it typically means the device and driver will lose toggle
synchronization. If you really lost synchronization, you likely
need to completely handshake with the device, using a request
like CLEAR\_HALT or SET\_INTERFACE.
\end{notice}

\item[{USBDEVFS\_DROP\_PRIVILEGES}] \leavevmode
This is used to relinquish the ability to do certain operations
which are considered to be privileged on a usbfs file descriptor.
This includes claiming arbitrary interfaces, resetting a device on
which there are currently claimed interfaces from other users, and
issuing USBDEVFS\_IOCTL calls. The ioctl parameter is a 32 bit mask
of interfaces the user is allowed to claim on this file descriptor.
You may issue this ioctl more than one time to narrow said mask.

\end{description}


\paragraph{Synchronous I/O Support}
\label{driver-api/usb/usb:synchronous-i-o-support}
Synchronous requests involve the kernel blocking until the user mode
request completes, either by finishing successfully or by reporting an
error. In most cases this is the simplest way to use usbfs, although as
noted above it does prevent performing I/O to more than one endpoint at
a time.
\begin{description}
\item[{USBDEVFS\_BULK}] \leavevmode
Issues a bulk read or write request to the device. The ioctl
parameter is a pointer to this structure:

\begin{Verbatim}[commandchars=\\\{\}]
struct usbdevfs\PYGZus{}bulktransfer \PYGZob{}
        unsigned int  ep;
        unsigned int  len;
        unsigned int  timeout; /* in milliseconds */
        void          *data;
\PYGZcb{};
\end{Verbatim}

The \code{ep} value identifies a bulk endpoint number (1 to 15, as
identified in an endpoint descriptor), masked with USB\_DIR\_IN when
referring to an endpoint which sends data to the host from the
device. The length of the data buffer is identified by \code{len}; Recent
kernels support requests up to about 128KBytes. \emph{FIXME say how read
length is returned, and how short reads are handled.}.

\item[{USBDEVFS\_CLEAR\_HALT}] \leavevmode
Clears endpoint halt (stall) and resets the endpoint toggle. This is
only meaningful for bulk or interrupt endpoints. The ioctl parameter
is an integer endpoint number (1 to 15, as identified in an endpoint
descriptor), masked with USB\_DIR\_IN when referring to an endpoint
which sends data to the host from the device.

Use this on bulk or interrupt endpoints which have stalled,
returning \code{-EPIPE} status to a data transfer request. Do not issue
the control request directly, since that could invalidate the host's
record of the data toggle.

\item[{USBDEVFS\_CONTROL}] \leavevmode
Issues a control request to the device. The ioctl parameter points
to a structure like this:

\begin{Verbatim}[commandchars=\\\{\}]
struct usbdevfs\PYGZus{}ctrltransfer \PYGZob{}
        \PYGZus{}\PYGZus{}u8   bRequestType;
        \PYGZus{}\PYGZus{}u8   bRequest;
        \PYGZus{}\PYGZus{}u16  wValue;
        \PYGZus{}\PYGZus{}u16  wIndex;
        \PYGZus{}\PYGZus{}u16  wLength;
        \PYGZus{}\PYGZus{}u32  timeout;  /* in milliseconds */
        void   *data;
\PYGZcb{};
\end{Verbatim}

The first eight bytes of this structure are the contents of the
SETUP packet to be sent to the device; see the USB 2.0 specification
for details. The bRequestType value is composed by combining a
\code{USB\_TYPE\_*} value, a \code{USB\_DIR\_*} value, and a \code{USB\_RECIP\_*}
value (from \code{linux/usb.h}). If wLength is nonzero, it describes
the length of the data buffer, which is either written to the device
(USB\_DIR\_OUT) or read from the device (USB\_DIR\_IN).

At this writing, you can't transfer more than 4 KBytes of data to or
from a device; usbfs has a limit, and some host controller drivers
have a limit. (That's not usually a problem.) \emph{Also} there's no way
to say it's not OK to get a short read back from the device.

\item[{USBDEVFS\_RESET}] \leavevmode
Does a USB level device reset. The ioctl parameter is ignored. After
the reset, this rebinds all device interfaces. File modification
time is not updated by this request.

\end{description}

\begin{notice}{warning}{Warning:}
\emph{Avoid using this call} until some usbcore bugs get fixed, since
it does not fully synchronize device, interface, and driver (not
just usbfs) state.
\end{notice}
\begin{description}
\item[{USBDEVFS\_SETINTERFACE}] \leavevmode
Sets the alternate setting for an interface. The ioctl parameter is
a pointer to a structure like this:

\begin{Verbatim}[commandchars=\\\{\}]
struct usbdevfs\PYGZus{}setinterface \PYGZob{}
        unsigned int  interface;
        unsigned int  altsetting;
\PYGZcb{};
\end{Verbatim}

File modification time is not updated by this request.

Those struct members are from some interface descriptor applying to
the current configuration. The interface number is the
bInterfaceNumber value, and the altsetting number is the
bAlternateSetting value. (This resets each endpoint in the
interface.)

\item[{USBDEVFS\_SETCONFIGURATION}] \leavevmode
Issues the \code{usb\_set\_configuration()} call for the
device. The parameter is an integer holding the number of a
configuration (bConfigurationValue from descriptor). File
modification time is not updated by this request.

\end{description}

\begin{notice}{warning}{Warning:}
\emph{Avoid using this call} until some usbcore bugs get fixed, since
it does not fully synchronize device, interface, and driver (not
just usbfs) state.
\end{notice}


\paragraph{Asynchronous I/O Support}
\label{driver-api/usb/usb:asynchronous-i-o-support}
As mentioned above, there are situations where it may be important to
initiate concurrent operations from user mode code. This is particularly
important for periodic transfers (interrupt and isochronous), but it can
be used for other kinds of USB requests too. In such cases, the
asynchronous requests described here are essential. Rather than
submitting one request and having the kernel block until it completes,
the blocking is separate.

These requests are packaged into a structure that resembles the URB used
by kernel device drivers. (No POSIX Async I/O support here, sorry.) It
identifies the endpoint type (\code{USBDEVFS\_URB\_TYPE\_*}), endpoint
(number, masked with USB\_DIR\_IN as appropriate), buffer and length,
and a user ``context'' value serving to uniquely identify each request.
(It's usually a pointer to per-request data.) Flags can modify requests
(not as many as supported for kernel drivers).

Each request can specify a realtime signal number (between SIGRTMIN and
SIGRTMAX, inclusive) to request a signal be sent when the request
completes.

When usbfs returns these urbs, the status value is updated, and the
buffer may have been modified. Except for isochronous transfers, the
actual\_length is updated to say how many bytes were transferred; if the
USBDEVFS\_URB\_DISABLE\_SPD flag is set (``short packets are not OK''), if
fewer bytes were read than were requested then you get an error report:

\begin{Verbatim}[commandchars=\\\{\}]
struct usbdevfs\PYGZus{}iso\PYGZus{}packet\PYGZus{}desc \PYGZob{}
        unsigned int                     length;
        unsigned int                     actual\PYGZus{}length;
        unsigned int                     status;
\PYGZcb{};

struct usbdevfs\PYGZus{}urb \PYGZob{}
        unsigned char                    type;
        unsigned char                    endpoint;
        int                              status;
        unsigned int                     flags;
        void                             *buffer;
        int                              buffer\PYGZus{}length;
        int                              actual\PYGZus{}length;
        int                              start\PYGZus{}frame;
        int                              number\PYGZus{}of\PYGZus{}packets;
        int                              error\PYGZus{}count;
        unsigned int                     signr;
        void                             *usercontext;
        struct usbdevfs\PYGZus{}iso\PYGZus{}packet\PYGZus{}desc  iso\PYGZus{}frame\PYGZus{}desc[];
\PYGZcb{};
\end{Verbatim}

For these asynchronous requests, the file modification time reflects
when the request was initiated. This contrasts with their use with the
synchronous requests, where it reflects when requests complete.
\begin{description}
\item[{USBDEVFS\_DISCARDURB}] \leavevmode
\emph{TBS} File modification time is not updated by this request.

\item[{USBDEVFS\_DISCSIGNAL}] \leavevmode
\emph{TBS} File modification time is not updated by this request.

\item[{USBDEVFS\_REAPURB}] \leavevmode
\emph{TBS} File modification time is not updated by this request.

\item[{USBDEVFS\_REAPURBNDELAY}] \leavevmode
\emph{TBS} File modification time is not updated by this request.

\item[{USBDEVFS\_SUBMITURB}] \leavevmode
\emph{TBS}

\end{description}


\subsection{The USB devices}
\label{driver-api/usb/usb:the-usb-devices}
The USB devices are now exported via debugfs:
\begin{itemize}
\item {} 
\code{/sys/kernel/debug/usb/devices} ... a text file showing each of the USB
devices on known to the kernel, and their configuration descriptors.
You can also poll() this to learn about new devices.

\end{itemize}


\subsubsection{/sys/kernel/debug/usb/devices}
\label{driver-api/usb/usb:sys-kernel-debug-usb-devices}
This file is handy for status viewing tools in user mode, which can scan
the text format and ignore most of it. More detailed device status
(including class and vendor status) is available from device-specific
files. For information about the current format of this file, see below.

This file, in combination with the poll() system call, can also be used
to detect when devices are added or removed:

\begin{Verbatim}[commandchars=\\\{\}]
int fd;
struct pollfd pfd;

fd = open(\PYGZdq{}/sys/kernel/debug/usb/devices\PYGZdq{}, O\PYGZus{}RDONLY);
pfd = \PYGZob{} fd, POLLIN, 0 \PYGZcb{};
for (;;) \PYGZob{}
    /* The first time through, this call will return immediately. */
    poll(\PYGZam{}pfd, 1, \PYGZhy{}1);

    /* To see what\PYGZsq{}s changed, compare the file\PYGZsq{}s previous and current
       contents or scan the filesystem.  (Scanning is more precise.) */
\PYGZcb{}
\end{Verbatim}

Note that this behavior is intended to be used for informational and
debug purposes. It would be more appropriate to use programs such as
udev or HAL to initialize a device or start a user-mode helper program,
for instance.

In this file, each device's output has multiple lines of ASCII output.

I made it ASCII instead of binary on purpose, so that someone
can obtain some useful data from it without the use of an
auxiliary program.  However, with an auxiliary program, the numbers
in the first 4 columns of each \code{T:} line (topology info:
Lev, Prnt, Port, Cnt) can be used to build a USB topology diagram.

Each line is tagged with a one-character ID for that line:

\begin{Verbatim}[commandchars=\\\{\}]
T = Topology (etc.)
B = Bandwidth (applies only to USB host controllers, which are
virtualized as root hubs)
D = Device descriptor info.
P = Product ID info. (from Device descriptor, but they won\PYGZsq{}t fit
together on one line)
S = String descriptors.
C = Configuration descriptor info. (* = active configuration)
I = Interface descriptor info.
E = Endpoint descriptor info.
\end{Verbatim}


\paragraph{/sys/kernel/debug/usb/devices output format}
\label{driver-api/usb/usb:sys-kernel-debug-usb-devices-output-format}\begin{description}
\item[{Legend::}] \leavevmode
d = decimal number (may have leading spaces or 0's)
x = hexadecimal number (may have leading spaces or 0's)
s = string

\end{description}


\subparagraph{Topology info}
\label{driver-api/usb/usb:topology-info}
\begin{Verbatim}[commandchars=\\\{\}]
T:  Bus=dd Lev=dd Prnt=dd Port=dd Cnt=dd Dev\PYGZsh{}=ddd Spd=dddd MxCh=dd
\textbar{}   \textbar{}      \textbar{}      \textbar{}       \textbar{}       \textbar{}      \textbar{}        \textbar{}        \textbar{}\PYGZus{}\PYGZus{}MaxChildren
\textbar{}   \textbar{}      \textbar{}      \textbar{}       \textbar{}       \textbar{}      \textbar{}        \textbar{}\PYGZus{}\PYGZus{}Device Speed in Mbps
\textbar{}   \textbar{}      \textbar{}      \textbar{}       \textbar{}       \textbar{}      \textbar{}\PYGZus{}\PYGZus{}DeviceNumber
\textbar{}   \textbar{}      \textbar{}      \textbar{}       \textbar{}       \textbar{}\PYGZus{}\PYGZus{}Count of devices at this level
\textbar{}   \textbar{}      \textbar{}      \textbar{}       \textbar{}\PYGZus{}\PYGZus{}Connector/Port on Parent for this device
\textbar{}   \textbar{}      \textbar{}      \textbar{}\PYGZus{}\PYGZus{}Parent DeviceNumber
\textbar{}   \textbar{}      \textbar{}\PYGZus{}\PYGZus{}Level in topology for this bus
\textbar{}   \textbar{}\PYGZus{}\PYGZus{}Bus number
\textbar{}\PYGZus{}\PYGZus{}Topology info tag
\end{Verbatim}

Speed may be:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

1.5
 & 
Mbit/s for low speed USB
\\
\hline
12
 & 
Mbit/s for full speed USB
\\
\hline
480
 & 
Mbit/s for high speed USB (added for USB 2.0);
also used for Wireless USB, which has no fixed speed
\\
\hline
5000
 & 
Mbit/s for SuperSpeed USB (added for USB 3.0)
\\
\hline\end{tabulary}

\end{quote}

For reasons lost in the mists of time, the Port number is always
too low by 1.  For example, a device plugged into port 4 will
show up with \code{Port=03}.


\subparagraph{Bandwidth info}
\label{driver-api/usb/usb:bandwidth-info}
\begin{Verbatim}[commandchars=\\\{\}]
B:  Alloc=ddd/ddd us (xx\PYGZpc{}), \PYGZsh{}Int=ddd, \PYGZsh{}Iso=ddd
\textbar{}   \textbar{}                       \textbar{}         \textbar{}\PYGZus{}\PYGZus{}Number of isochronous requests
\textbar{}   \textbar{}                       \textbar{}\PYGZus{}\PYGZus{}Number of interrupt requests
\textbar{}   \textbar{}\PYGZus{}\PYGZus{}Total Bandwidth allocated to this bus
\textbar{}\PYGZus{}\PYGZus{}Bandwidth info tag
\end{Verbatim}

Bandwidth allocation is an approximation of how much of one frame
(millisecond) is in use.  It reflects only periodic transfers, which
are the only transfers that reserve bandwidth.  Control and bulk
transfers use all other bandwidth, including reserved bandwidth that
is not used for transfers (such as for short packets).

The percentage is how much of the ``reserved'' bandwidth is scheduled by
those transfers.  For a low or full speed bus (loosely, ``USB 1.1''),
90\% of the bus bandwidth is reserved.  For a high speed bus (loosely,
``USB 2.0'') 80\% is reserved.


\subparagraph{Device descriptor info \& Product ID info}
\label{driver-api/usb/usb:device-descriptor-info-product-id-info}
\begin{Verbatim}[commandchars=\\\{\}]
D:  Ver=x.xx Cls=xx(s) Sub=xx Prot=xx MxPS=dd \PYGZsh{}Cfgs=dd
P:  Vendor=xxxx ProdID=xxxx Rev=xx.xx
\end{Verbatim}

where:

\begin{Verbatim}[commandchars=\\\{\}]
D:  Ver=x.xx Cls=xx(sssss) Sub=xx Prot=xx MxPS=dd \PYGZsh{}Cfgs=dd
\textbar{}   \textbar{}        \textbar{}             \textbar{}      \textbar{}       \textbar{}       \textbar{}\PYGZus{}\PYGZus{}NumberConfigurations
\textbar{}   \textbar{}        \textbar{}             \textbar{}      \textbar{}       \textbar{}\PYGZus{}\PYGZus{}MaxPacketSize of Default Endpoint
\textbar{}   \textbar{}        \textbar{}             \textbar{}      \textbar{}\PYGZus{}\PYGZus{}DeviceProtocol
\textbar{}   \textbar{}        \textbar{}             \textbar{}\PYGZus{}\PYGZus{}DeviceSubClass
\textbar{}   \textbar{}        \textbar{}\PYGZus{}\PYGZus{}DeviceClass
\textbar{}   \textbar{}\PYGZus{}\PYGZus{}Device USB version
\textbar{}\PYGZus{}\PYGZus{}Device info tag \PYGZsh{}1
\end{Verbatim}

where:

\begin{Verbatim}[commandchars=\\\{\}]
P:  Vendor=xxxx ProdID=xxxx Rev=xx.xx
\textbar{}   \textbar{}           \textbar{}           \textbar{}\PYGZus{}\PYGZus{}Product revision number
\textbar{}   \textbar{}           \textbar{}\PYGZus{}\PYGZus{}Product ID code
\textbar{}   \textbar{}\PYGZus{}\PYGZus{}Vendor ID code
\textbar{}\PYGZus{}\PYGZus{}Device info tag \PYGZsh{}2
\end{Verbatim}


\subparagraph{String descriptor info}
\label{driver-api/usb/usb:string-descriptor-info}
\begin{Verbatim}[commandchars=\\\{\}]
S:  Manufacturer=ssss
\textbar{}   \textbar{}\PYGZus{}\PYGZus{}Manufacturer of this device as read from the device.
\textbar{}      For USB host controller drivers (virtual root hubs) this may
\textbar{}      be omitted, or (for newer drivers) will identify the kernel
\textbar{}      version and the driver which provides this hub emulation.
\textbar{}\PYGZus{}\PYGZus{}String info tag

S:  Product=ssss
\textbar{}   \textbar{}\PYGZus{}\PYGZus{}Product description of this device as read from the device.
\textbar{}      For older USB host controller drivers (virtual root hubs) this
\textbar{}      indicates the driver; for newer ones, it\PYGZsq{}s a product (and vendor)
\textbar{}      description that often comes from the kernel\PYGZsq{}s PCI ID database.
\textbar{}\PYGZus{}\PYGZus{}String info tag

S:  SerialNumber=ssss
\textbar{}   \textbar{}\PYGZus{}\PYGZus{}Serial Number of this device as read from the device.
\textbar{}      For USB host controller drivers (virtual root hubs) this is
\textbar{}      some unique ID, normally a bus ID (address or slot name) that
\textbar{}      can\PYGZsq{}t be shared with any other device.
\textbar{}\PYGZus{}\PYGZus{}String info tag
\end{Verbatim}


\subparagraph{Configuration descriptor info}
\label{driver-api/usb/usb:configuration-descriptor-info}
\begin{Verbatim}[commandchars=\\\{\}]
C:* \PYGZsh{}Ifs=dd Cfg\PYGZsh{}=dd Atr=xx MPwr=dddmA
\textbar{} \textbar{} \textbar{}       \textbar{}       \textbar{}      \textbar{}\PYGZus{}\PYGZus{}MaxPower in mA
\textbar{} \textbar{} \textbar{}       \textbar{}       \textbar{}\PYGZus{}\PYGZus{}Attributes
\textbar{} \textbar{} \textbar{}       \textbar{}\PYGZus{}\PYGZus{}ConfiguratioNumber
\textbar{} \textbar{} \textbar{}\PYGZus{}\PYGZus{}NumberOfInterfaces
\textbar{} \textbar{}\PYGZus{}\PYGZus{} \PYGZdq{}*\PYGZdq{} indicates the active configuration (others are \PYGZdq{} \PYGZdq{})
\textbar{}\PYGZus{}\PYGZus{}Config info tag
\end{Verbatim}

USB devices may have multiple configurations, each of which act
rather differently.  For example, a bus-powered configuration
might be much less capable than one that is self-powered.  Only
one device configuration can be active at a time; most devices
have only one configuration.

Each configuration consists of one or more interfaces.  Each
interface serves a distinct ``function'', which is typically bound
to a different USB device driver.  One common example is a USB
speaker with an audio interface for playback, and a HID interface
for use with software volume control.


\subparagraph{Interface descriptor info (can be multiple per Config)}
\label{driver-api/usb/usb:interface-descriptor-info-can-be-multiple-per-config}
\begin{Verbatim}[commandchars=\\\{\}]
I:* If\PYGZsh{}=dd Alt=dd \PYGZsh{}EPs=dd Cls=xx(sssss) Sub=xx Prot=xx Driver=ssss
\textbar{} \textbar{} \textbar{}      \textbar{}      \textbar{}       \textbar{}             \textbar{}      \textbar{}       \textbar{}\PYGZus{}\PYGZus{}Driver name
\textbar{} \textbar{} \textbar{}      \textbar{}      \textbar{}       \textbar{}             \textbar{}      \textbar{}          or \PYGZdq{}(none)\PYGZdq{}
\textbar{} \textbar{} \textbar{}      \textbar{}      \textbar{}       \textbar{}             \textbar{}      \textbar{}\PYGZus{}\PYGZus{}InterfaceProtocol
\textbar{} \textbar{} \textbar{}      \textbar{}      \textbar{}       \textbar{}             \textbar{}\PYGZus{}\PYGZus{}InterfaceSubClass
\textbar{} \textbar{} \textbar{}      \textbar{}      \textbar{}       \textbar{}\PYGZus{}\PYGZus{}InterfaceClass
\textbar{} \textbar{} \textbar{}      \textbar{}      \textbar{}\PYGZus{}\PYGZus{}NumberOfEndpoints
\textbar{} \textbar{} \textbar{}      \textbar{}\PYGZus{}\PYGZus{}AlternateSettingNumber
\textbar{} \textbar{} \textbar{}\PYGZus{}\PYGZus{}InterfaceNumber
\textbar{} \textbar{}\PYGZus{}\PYGZus{} \PYGZdq{}*\PYGZdq{} indicates the active altsetting (others are \PYGZdq{} \PYGZdq{})
\textbar{}\PYGZus{}\PYGZus{}Interface info tag
\end{Verbatim}

A given interface may have one or more ``alternate'' settings.
For example, default settings may not use more than a small
amount of periodic bandwidth.  To use significant fractions
of bus bandwidth, drivers must select a non-default altsetting.

Only one setting for an interface may be active at a time, and
only one driver may bind to an interface at a time.  Most devices
have only one alternate setting per interface.


\subparagraph{Endpoint descriptor info (can be multiple per Interface)}
\label{driver-api/usb/usb:endpoint-descriptor-info-can-be-multiple-per-interface}
\begin{Verbatim}[commandchars=\\\{\}]
E:  Ad=xx(s) Atr=xx(ssss) MxPS=dddd Ivl=dddss
\textbar{}   \textbar{}        \textbar{}            \textbar{}         \textbar{}\PYGZus{}\PYGZus{}Interval (max) between transfers
\textbar{}   \textbar{}        \textbar{}            \textbar{}\PYGZus{}\PYGZus{}EndpointMaxPacketSize
\textbar{}   \textbar{}        \textbar{}\PYGZus{}\PYGZus{}Attributes(EndpointType)
\textbar{}   \textbar{}\PYGZus{}\PYGZus{}EndpointAddress(I=In,O=Out)
\textbar{}\PYGZus{}\PYGZus{}Endpoint info tag
\end{Verbatim}

The interval is nonzero for all periodic (interrupt or isochronous)
endpoints.  For high speed endpoints the transfer interval may be
measured in microseconds rather than milliseconds.

For high speed periodic endpoints, the \code{EndpointMaxPacketSize} reflects
the per-microframe data transfer size.  For ``high bandwidth''
endpoints, that can reflect two or three packets (for up to
3KBytes every 125 usec) per endpoint.

With the Linux-USB stack, periodic bandwidth reservations use the
transfer intervals and sizes provided by URBs, which can be less
than those found in endpoint descriptor.


\paragraph{Usage examples}
\label{driver-api/usb/usb:usage-examples}
If a user or script is interested only in Topology info, for
example, use something like \code{grep \textasciicircum{}T: /sys/kernel/debug/usb/devices}
for only the Topology lines.  A command like
\code{grep -i \textasciicircum{}{[}tdp{]}: /sys/kernel/debug/usb/devices} can be used to list
only the lines that begin with the characters in square brackets,
where the valid characters are TDPCIE.  With a slightly more able
script, it can display any selected lines (for example, only T, D,
and P lines) and change their output format.  (The \code{procusb}
Perl script is the beginning of this idea.  It will list only
selected lines {[}selected from TBDPSCIE{]} or ``All'' lines from
\code{/sys/kernel/debug/usb/devices}.)

The Topology lines can be used to generate a graphic/pictorial
of the USB devices on a system's root hub.  (See more below
on how to do this.)

The Interface lines can be used to determine what driver is
being used for each device, and which altsetting it activated.

The Configuration lines could be used to list maximum power
(in milliamps) that a system's USB devices are using.
For example, \code{grep \textasciicircum{}C: /sys/kernel/debug/usb/devices}.

Here's an example, from a system which has a UHCI root hub,
an external hub connected to the root hub, and a mouse and
a serial converter connected to the external hub.

\begin{Verbatim}[commandchars=\\\{\}]
T:  Bus=00 Lev=00 Prnt=00 Port=00 Cnt=00 Dev\PYGZsh{}=  1 Spd=12   MxCh= 2
B:  Alloc= 28/900 us ( 3\PYGZpc{}), \PYGZsh{}Int=  2, \PYGZsh{}Iso=  0
D:  Ver= 1.00 Cls=09(hub  ) Sub=00 Prot=00 MxPS= 8 \PYGZsh{}Cfgs=  1
P:  Vendor=0000 ProdID=0000 Rev= 0.00
S:  Product=USB UHCI Root Hub
S:  SerialNumber=dce0
C:* \PYGZsh{}Ifs= 1 Cfg\PYGZsh{}= 1 Atr=40 MxPwr=  0mA
I:  If\PYGZsh{}= 0 Alt= 0 \PYGZsh{}EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
E:  Ad=81(I) Atr=03(Int.) MxPS=   8 Ivl=255ms

T:  Bus=00 Lev=01 Prnt=01 Port=00 Cnt=01 Dev\PYGZsh{}=  2 Spd=12   MxCh= 4
D:  Ver= 1.00 Cls=09(hub  ) Sub=00 Prot=00 MxPS= 8 \PYGZsh{}Cfgs=  1
P:  Vendor=0451 ProdID=1446 Rev= 1.00
C:* \PYGZsh{}Ifs= 1 Cfg\PYGZsh{}= 1 Atr=e0 MxPwr=100mA
I:  If\PYGZsh{}= 0 Alt= 0 \PYGZsh{}EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
E:  Ad=81(I) Atr=03(Int.) MxPS=   1 Ivl=255ms

T:  Bus=00 Lev=02 Prnt=02 Port=00 Cnt=01 Dev\PYGZsh{}=  3 Spd=1.5  MxCh= 0
D:  Ver= 1.00 Cls=00(\PYGZgt{}ifc ) Sub=00 Prot=00 MxPS= 8 \PYGZsh{}Cfgs=  1
P:  Vendor=04b4 ProdID=0001 Rev= 0.00
C:* \PYGZsh{}Ifs= 1 Cfg\PYGZsh{}= 1 Atr=80 MxPwr=100mA
I:  If\PYGZsh{}= 0 Alt= 0 \PYGZsh{}EPs= 1 Cls=03(HID  ) Sub=01 Prot=02 Driver=mouse
E:  Ad=81(I) Atr=03(Int.) MxPS=   3 Ivl= 10ms

T:  Bus=00 Lev=02 Prnt=02 Port=02 Cnt=02 Dev\PYGZsh{}=  4 Spd=12   MxCh= 0
D:  Ver= 1.00 Cls=00(\PYGZgt{}ifc ) Sub=00 Prot=00 MxPS= 8 \PYGZsh{}Cfgs=  1
P:  Vendor=0565 ProdID=0001 Rev= 1.08
S:  Manufacturer=Peracom Networks, Inc.
S:  Product=Peracom USB to Serial Converter
C:* \PYGZsh{}Ifs= 1 Cfg\PYGZsh{}= 1 Atr=a0 MxPwr=100mA
I:  If\PYGZsh{}= 0 Alt= 0 \PYGZsh{}EPs= 3 Cls=00(\PYGZgt{}ifc ) Sub=00 Prot=00 Driver=serial
E:  Ad=81(I) Atr=02(Bulk) MxPS=  64 Ivl= 16ms
E:  Ad=01(O) Atr=02(Bulk) MxPS=  16 Ivl= 16ms
E:  Ad=82(I) Atr=03(Int.) MxPS=   8 Ivl=  8ms
\end{Verbatim}

Selecting only the \code{T:} and \code{I:} lines from this (for example, by using
\code{procusb ti}), we have

\begin{Verbatim}[commandchars=\\\{\}]
T:  Bus=00 Lev=00 Prnt=00 Port=00 Cnt=00 Dev\PYGZsh{}=  1 Spd=12   MxCh= 2
T:  Bus=00 Lev=01 Prnt=01 Port=00 Cnt=01 Dev\PYGZsh{}=  2 Spd=12   MxCh= 4
I:  If\PYGZsh{}= 0 Alt= 0 \PYGZsh{}EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub
T:  Bus=00 Lev=02 Prnt=02 Port=00 Cnt=01 Dev\PYGZsh{}=  3 Spd=1.5  MxCh= 0
I:  If\PYGZsh{}= 0 Alt= 0 \PYGZsh{}EPs= 1 Cls=03(HID  ) Sub=01 Prot=02 Driver=mouse
T:  Bus=00 Lev=02 Prnt=02 Port=02 Cnt=02 Dev\PYGZsh{}=  4 Spd=12   MxCh= 0
I:  If\PYGZsh{}= 0 Alt= 0 \PYGZsh{}EPs= 3 Cls=00(\PYGZgt{}ifc ) Sub=00 Prot=00 Driver=serial
\end{Verbatim}

Physically this looks like (or could be converted to):

\begin{Verbatim}[commandchars=\\\{\}]
                    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
                    \textbar{}  PC/root\PYGZus{}hub (12)\textbar{}   Dev\PYGZsh{} = 1
                    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+   (nn) is Mbps.
  Level 0           \textbar{}  CN.0   \textbar{}  CN.1  \textbar{}   [CN = connector/port \PYGZsh{}]
                    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
                        /
                       /
          +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
Level 1   \textbar{} Dev\PYGZsh{}2: 4\PYGZhy{}port hub (12)\textbar{}
          +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
          \textbar{}CN.0 \textbar{}CN.1 \textbar{}CN.2 \textbar{}CN.3 \textbar{}
          +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
              \PYGZbs{}           \PYGZbs{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
               \PYGZbs{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}                          \PYGZbs{}
                     \PYGZbs{}                          \PYGZbs{}
             +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+      +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
Level 2      \textbar{} Dev\PYGZsh{} 3: mouse (1.5)\textbar{}      \textbar{} Dev\PYGZsh{} 4: serial (12)\textbar{}
             +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+      +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{Verbatim}

Or, in a more tree-like structure (ports {[}Connectors{]} without
connections could be omitted):

\begin{Verbatim}[commandchars=\\\{\}]
PC:  Dev\PYGZsh{} 1, root hub, 2 ports, 12 Mbps
\textbar{}\PYGZus{} CN.0:  Dev\PYGZsh{} 2, hub, 4 ports, 12 Mbps
     \textbar{}\PYGZus{} CN.0:  Dev \PYGZsh{}3, mouse, 1.5 Mbps
     \textbar{}\PYGZus{} CN.1:
     \textbar{}\PYGZus{} CN.2:  Dev \PYGZsh{}4, serial, 12 Mbps
     \textbar{}\PYGZus{} CN.3:
\textbar{}\PYGZus{} CN.1:
\end{Verbatim}


\section{USB Gadget API for Linux}
\label{driver-api/usb/gadget::doc}\label{driver-api/usb/gadget:usb-gadget-api-for-linux}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
David Brownell

\item[{Date}] \leavevmode
20 August 2004

\end{description}\end{quote}


\subsection{Introduction}
\label{driver-api/usb/gadget:introduction}
This document presents a Linux-USB ``Gadget'' kernel mode API, for use
within peripherals and other USB devices that embed Linux. It provides
an overview of the API structure, and shows how that fits into a system
development project. This is the first such API released on Linux to
address a number of important problems, including:
\begin{itemize}
\item {} 
Supports USB 2.0, for high speed devices which can stream data at
several dozen megabytes per second.

\item {} 
Handles devices with dozens of endpoints just as well as ones with
just two fixed-function ones. Gadget drivers can be written so
they're easy to port to new hardware.

\item {} 
Flexible enough to expose more complex USB device capabilities such
as multiple configurations, multiple interfaces, composite devices,
and alternate interface settings.

\item {} 
USB ``On-The-Go'' (OTG) support, in conjunction with updates to the
Linux-USB host side.

\item {} 
Sharing data structures and API models with the Linux-USB host side
API. This helps the OTG support, and looks forward to more-symmetric
frameworks (where the same I/O model is used by both host and device
side drivers).

\item {} 
Minimalist, so it's easier to support new device controller hardware.
I/O processing doesn't imply large demands for memory or CPU
resources.

\end{itemize}

Most Linux developers will not be able to use this API, since they have
USB \code{host} hardware in a PC, workstation, or server. Linux users with
embedded systems are more likely to have USB peripheral hardware. To
distinguish drivers running inside such hardware from the more familiar
Linux ``USB device drivers'', which are host side proxies for the real USB
devices, a different term is used: the drivers inside the peripherals
are ``USB gadget drivers''. In USB protocol interactions, the device
driver is the master (or ``client driver'') and the gadget driver is the
slave (or ``function driver'').

The gadget API resembles the host side Linux-USB API in that both use
queues of request objects to package I/O buffers, and those requests may
be submitted or canceled. They share common definitions for the standard
USB \emph{Chapter 9} messages, structures, and constants. Also, both APIs
bind and unbind drivers to devices. The APIs differ in detail, since the
host side's current URB framework exposes a number of implementation
details and assumptions that are inappropriate for a gadget API. While
the model for control transfers and configuration management is
necessarily different (one side is a hardware-neutral master, the other
is a hardware-aware slave), the endpoint I/0 API used here should also
be usable for an overhead-reduced host side API.


\subsection{Structure of Gadget Drivers}
\label{driver-api/usb/gadget:structure-of-gadget-drivers}
A system running inside a USB peripheral normally has at least three
layers inside the kernel to handle USB protocol processing, and may have
additional layers in user space code. The \code{gadget} API is used by the
middle layer to interact with the lowest level (which directly handles
hardware).

In Linux, from the bottom up, these layers are:
\begin{description}
\item[{\emph{USB Controller Driver}}] \leavevmode
This is the lowest software level. It is the only layer that talks
to hardware, through registers, fifos, dma, irqs, and the like. The
\code{\textless{}linux/usb/gadget.h\textgreater{}} API abstracts the peripheral controller
endpoint hardware. That hardware is exposed through endpoint
objects, which accept streams of IN/OUT buffers, and through
callbacks that interact with gadget drivers. Since normal USB
devices only have one upstream port, they only have one of these
drivers. The controller driver can support any number of different
gadget drivers, but only one of them can be used at a time.

Examples of such controller hardware include the PCI-based NetChip
2280 USB 2.0 high speed controller, the SA-11x0 or PXA-25x UDC
(found within many PDAs), and a variety of other products.

\item[{\emph{Gadget Driver}}] \leavevmode
The lower boundary of this driver implements hardware-neutral USB
functions, using calls to the controller driver. Because such
hardware varies widely in capabilities and restrictions, and is used
in embedded environments where space is at a premium, the gadget
driver is often configured at compile time to work with endpoints
supported by one particular controller. Gadget drivers may be
portable to several different controllers, using conditional
compilation. (Recent kernels substantially simplify the work
involved in supporting new hardware, by \emph{autoconfiguring} endpoints
automatically for many bulk-oriented drivers.) Gadget driver
responsibilities include:
\begin{itemize}
\item {} 
handling setup requests (ep0 protocol responses) possibly
including class-specific functionality

\item {} 
returning configuration and string descriptors

\item {} 
(re)setting configurations and interface altsettings, including
enabling and configuring endpoints

\item {} 
handling life cycle events, such as managing bindings to
hardware, USB suspend/resume, remote wakeup, and disconnection
from the USB host.

\item {} 
managing IN and OUT transfers on all currently enabled endpoints

\end{itemize}

Such drivers may be modules of proprietary code, although that
approach is discouraged in the Linux community.

\item[{\emph{Upper Level}}] \leavevmode
Most gadget drivers have an upper boundary that connects to some
Linux driver or framework in Linux. Through that boundary flows the
data which the gadget driver produces and/or consumes through
protocol transfers over USB. Examples include:
\begin{itemize}
\item {} 
user mode code, using generic (gadgetfs) or application specific
files in \code{/dev}

\item {} 
networking subsystem (for network gadgets, like the CDC Ethernet
Model gadget driver)

\item {} 
data capture drivers, perhaps video4Linux or a scanner driver; or
test and measurement hardware.

\item {} 
input subsystem (for HID gadgets)

\item {} 
sound subsystem (for audio gadgets)

\item {} 
file system (for PTP gadgets)

\item {} 
block i/o subsystem (for usb-storage gadgets)

\item {} 
... and more

\end{itemize}

\item[{\emph{Additional Layers}}] \leavevmode
Other layers may exist. These could include kernel layers, such as
network protocol stacks, as well as user mode applications building
on standard POSIX system call APIs such as \code{open()}, \code{close()},
\code{read()} and \code{write()}. On newer systems, POSIX Async I/O calls may
be an option. Such user mode code will not necessarily be subject to
the GNU General Public License (GPL).

\end{description}

OTG-capable systems will also need to include a standard Linux-USB host
side stack, with \code{usbcore}, one or more \emph{Host Controller Drivers}
(HCDs), \emph{USB Device Drivers} to support the OTG ``Targeted Peripheral
List'', and so forth. There will also be an \emph{OTG Controller Driver},
which is visible to gadget and device driver developers only indirectly.
That helps the host and device side USB controllers implement the two
new OTG protocols (HNP and SRP). Roles switch (host to peripheral, or
vice versa) using HNP during USB suspend processing, and SRP can be
viewed as a more battery-friendly kind of device wakeup protocol.

Over time, reusable utilities are evolving to help make some gadget
driver tasks simpler. For example, building configuration descriptors
from vectors of descriptors for the configurations interfaces and
endpoints is now automated, and many drivers now use autoconfiguration
to choose hardware endpoints and initialize their descriptors. A
potential example of particular interest is code implementing standard
USB-IF protocols for HID, networking, storage, or audio classes. Some
developers are interested in KDB or KGDB hooks, to let target hardware
be remotely debugged. Most such USB protocol code doesn't need to be
hardware-specific, any more than network protocols like X11, HTTP, or
NFS are. Such gadget-side interface drivers should eventually be
combined, to implement composite devices.


\subsection{Kernel Mode Gadget API}
\label{driver-api/usb/gadget:kernel-mode-gadget-api}
Gadget drivers declare themselves through a struct
{\hyperref[driver\string-api/usb/gadget:c.usb_gadget_driver]{\emph{\code{usb\_gadget\_driver}}}}, which is responsible for most parts of enumeration
for a struct {\hyperref[driver\string-api/usb/gadget:c.usb_gadget]{\emph{\code{usb\_gadget}}}}. The response to a set\_configuration usually
involves enabling one or more of the struct {\hyperref[driver\string-api/usb/gadget:c.usb_ep]{\emph{\code{usb\_ep}}}} objects exposed by
the gadget, and submitting one or more struct {\hyperref[driver\string-api/usb/gadget:c.usb_request]{\emph{\code{usb\_request}}}} buffers to
transfer data. Understand those four data types, and their operations,
and you will understand how this API works.

\begin{notice}{note}{Note:}
Other than the ``Chapter 9'' data types, most of the significant data
types and functions are described here.

However, some relevant information is likely omitted from what you
are reading. One example of such information is endpoint
autoconfiguration. You'll have to read the header file, and use
example source code (such as that for ``Gadget Zero''), to fully
understand the API.

The part of the API implementing some basic driver capabilities is
specific to the version of the Linux kernel that's in use. The 2.6
and upper kernel versions include a \emph{driver model} framework that has
no analogue on earlier kernels; so those parts of the gadget API are
not fully portable. (They are implemented on 2.4 kernels, but in a
different way.) The driver model state is another part of this API that is
ignored by the kerneldoc tools.
\end{notice}

The core API does not expose every possible hardware feature, only the
most widely available ones. There are significant hardware features,
such as device-to-device DMA (without temporary storage in a memory
buffer) that would be added using hardware-specific APIs.

This API allows drivers to use conditional compilation to handle
endpoint capabilities of different hardware, but doesn't require that.
Hardware tends to have arbitrary restrictions, relating to transfer
types, addressing, packet sizes, buffering, and availability. As a rule,
such differences only matter for ``endpoint zero'' logic that handles
device configuration and management. The API supports limited run-time
detection of capabilities, through naming conventions for endpoints.
Many drivers will be able to at least partially autoconfigure
themselves. In particular, driver init sections will often have endpoint
autoconfiguration logic that scans the hardware's list of endpoints to
find ones matching the driver requirements (relying on those
conventions), to eliminate some of the most common reasons for
conditional compilation.

Like the Linux-USB host side API, this API exposes the ``chunky'' nature
of USB messages: I/O requests are in terms of one or more ``packets'', and
packet boundaries are visible to drivers. Compared to RS-232 serial
protocols, USB resembles synchronous protocols like HDLC (N bytes per
frame, multipoint addressing, host as the primary station and devices as
secondary stations) more than asynchronous ones (tty style: 8 data bits
per frame, no parity, one stop bit). So for example the controller
drivers won't buffer two single byte writes into a single two-byte USB
IN packet, although gadget drivers may do so when they implement
protocols where packet boundaries (and ``short packets'') are not
significant.


\subsubsection{Driver Life Cycle}
\label{driver-api/usb/gadget:driver-life-cycle}
Gadget drivers make endpoint I/O requests to hardware without needing to
know many details of the hardware, but driver setup/configuration code
needs to handle some differences. Use the API like this:
\begin{enumerate}
\item {} 
Register a driver for the particular device side usb controller
hardware, such as the net2280 on PCI (USB 2.0), sa11x0 or pxa25x as
found in Linux PDAs, and so on. At this point the device is logically
in the USB ch9 initial state (\code{attached}), drawing no power and not
usable (since it does not yet support enumeration). Any host should
not see the device, since it's not activated the data line pullup
used by the host to detect a device, even if VBUS power is available.

\item {} 
Register a gadget driver that implements some higher level device
function. That will then bind() to a {\hyperref[driver\string-api/usb/gadget:c.usb_gadget]{\emph{\code{usb\_gadget}}}}, which activates
the data line pullup sometime after detecting VBUS.

\item {} 
The hardware driver can now start enumerating. The steps it handles
are to accept USB \code{power} and \code{set\_address} requests. Other steps are
handled by the gadget driver. If the gadget driver module is unloaded
before the host starts to enumerate, steps before step 7 are skipped.

\item {} 
The gadget driver's \code{setup()} call returns usb descriptors, based both
on what the bus interface hardware provides and on the functionality
being implemented. That can involve alternate settings or
configurations, unless the hardware prevents such operation. For OTG
devices, each configuration descriptor includes an OTG descriptor.

\item {} 
The gadget driver handles the last step of enumeration, when the USB
host issues a \code{set\_configuration} call. It enables all endpoints used
in that configuration, with all interfaces in their default settings.
That involves using a list of the hardware's endpoints, enabling each
endpoint according to its descriptor. It may also involve using
\code{usb\_gadget\_vbus\_draw} to let more power be drawn from VBUS, as
allowed by that configuration. For OTG devices, setting a
configuration may also involve reporting HNP capabilities through a
user interface.

\item {} 
Do real work and perform data transfers, possibly involving changes
to interface settings or switching to new configurations, until the
device is disconnect()ed from the host. Queue any number of transfer
requests to each endpoint. It may be suspended and resumed several
times before being disconnected. On disconnect, the drivers go back
to step 3 (above).

\item {} 
When the gadget driver module is being unloaded, the driver unbind()
callback is issued. That lets the controller driver be unloaded.

\end{enumerate}

Drivers will normally be arranged so that just loading the gadget driver
module (or statically linking it into a Linux kernel) allows the
peripheral device to be enumerated, but some drivers will defer
enumeration until some higher level component (like a user mode daemon)
enables it. Note that at this lowest level there are no policies about
how ep0 configuration logic is implemented, except that it should obey
USB specifications. Such issues are in the domain of gadget drivers,
including knowing about implementation constraints imposed by some USB
controllers or understanding that composite devices might happen to be
built by integrating reusable components.

Note that the lifecycle above can be slightly different for OTG devices.
Other than providing an additional OTG descriptor in each configuration,
only the HNP-related differences are particularly visible to driver
code. They involve reporting requirements during the \code{SET\_CONFIGURATION}
request, and the option to invoke HNP during some suspend callbacks.
Also, SRP changes the semantics of \code{usb\_gadget\_wakeup} slightly.


\subsubsection{USB 2.0 Chapter 9 Types and Constants}
\label{driver-api/usb/gadget:usb-2-0-chapter-9-types-and-constants}
Gadget drivers rely on common USB structures and constants defined in
the {\hyperref[driver\string-api/usb/usb:usb\string-chapter9]{\emph{linux/usb/ch9.h}}} header file, which is standard in
Linux 2.6+ kernels. These are the same types and constants used by host side
drivers (and usbcore).


\subsubsection{Core Objects and Methods}
\label{driver-api/usb/gadget:core-objects-and-methods}
These are declared in \code{\textless{}linux/usb/gadget.h\textgreater{}}, and are used by gadget
drivers to interact with USB peripheral controller drivers.
\index{usb\_request (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_request}\pysigline{struct \bfcode{usb\_request}}
describes one i/o request

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}request \PYGZob{}
  void *buf;
  unsigned length;
  dma\PYGZus{}addr\PYGZus{}t dma;
  struct scatterlist      *sg;
  unsigned num\PYGZus{}sgs;
  unsigned num\PYGZus{}mapped\PYGZus{}sgs;
  unsigned stream\PYGZus{}id:16;
  unsigned no\PYGZus{}interrupt:1;
  unsigned zero:1;
  unsigned short\PYGZus{}not\PYGZus{}ok:1;
  unsigned dma\PYGZus{}mapped:1;
  void (*complete)(struct usb\PYGZus{}ep *ep, struct usb\PYGZus{}request *req);
  void *context;
  struct list\PYGZus{}head        list;
  int status;
  unsigned actual;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{buf}}] \leavevmode
Buffer used for data.  Always provide this; some controllers
only use PIO, or don't use DMA for some endpoints.

\item[{\code{length}}] \leavevmode
Length of that data

\item[{\code{dma}}] \leavevmode
DMA address corresponding to `buf'.  If you don't set this
field, and the usb controller needs one, it is responsible
for mapping and unmapping the buffer.

\item[{\code{sg}}] \leavevmode
a scatterlist for SG-capable controllers.

\item[{\code{num\_sgs}}] \leavevmode
number of SG entries

\item[{\code{num\_mapped\_sgs}}] \leavevmode
number of SG entries mapped to DMA (internal)

\item[{\code{stream\_id}}] \leavevmode
The stream id, when USB3.0 bulk streams are being used

\item[{\code{no\_interrupt}}] \leavevmode
If true, hints that no completion irq is needed.
Helpful sometimes with deep request queues that are handled
directly by DMA controllers.

\item[{\code{zero}}] \leavevmode
If true, when writing data, makes the last packet be ``short''
by adding a zero length packet as needed;

\item[{\code{short\_not\_ok}}] \leavevmode
When reading data, makes short packets be
treated as errors (queue stops advancing till cleanup).

\item[{\code{dma\_mapped}}] \leavevmode
Indicates if request has been mapped to DMA (internal)

\item[{\code{complete}}] \leavevmode
Function called when request completes, so this request and
its buffer may be re-used.  The function will always be called with
interrupts disabled, and it must not sleep.
Reads terminate with a short packet, or when the buffer fills,
whichever comes first.  When writes terminate, some data bytes
will usually still be in flight (often in a hardware fifo).
Errors (for reads or writes) stop the queue from advancing
until the completion function returns, so that any transfers
invalidated by the error may first be dequeued.

\item[{\code{context}}] \leavevmode
For use by the completion callback

\item[{\code{list}}] \leavevmode
For use by the gadget driver.

\item[{\code{status}}] \leavevmode
Reports completion code, zero or a negative errno.
Normally, faults block the transfer queue from advancing until
the completion callback returns.
Code ``-ESHUTDOWN'' indicates completion caused by device disconnect,
or when the driver disabled the endpoint.

\item[{\code{actual}}] \leavevmode
Reports bytes transferred to/from the buffer.  For reads (OUT
transfers) this may be less than the requested length.  If the
short\_not\_ok flag is set, short reads are treated as errors
even when status otherwise indicates successful completion.
Note that for writes (IN transfers) some data bytes may still
reside in a device-side FIFO when the request is reported as
complete.

\end{description}

\textbf{Description}

These are allocated/freed through the endpoint they're used with.  The
hardware's driver can add extra per-request data to the memory it returns,
which often avoids separate memory allocations (potential failures),
later when the request is queued.

Request flags affect request handling, such as whether a zero length
packet is written (the ``zero'' flag), whether a short read should be
treated as an error (blocking request queue advance, the ``short\_not\_ok''
flag), or hinting that an interrupt is not required (the ``no\_interrupt''
flag, for use with deep request queues).

Bulk endpoints can use any size buffers, and can also be used for interrupt
transfers. interrupt-only endpoints can be much less functional.

\textbf{NOTE}

this is analogous to `struct urb' on the host side, except that
it's thinner and promotes more pre-allocation.
\index{usb\_ep\_caps (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_ep_caps}\pysigline{struct \bfcode{usb\_ep\_caps}}
endpoint capabilities description

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}ep\PYGZus{}caps \PYGZob{}
  unsigned type\PYGZus{}control:1;
  unsigned type\PYGZus{}iso:1;
  unsigned type\PYGZus{}bulk:1;
  unsigned type\PYGZus{}int:1;
  unsigned dir\PYGZus{}in:1;
  unsigned dir\PYGZus{}out:1;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{type\_control}}] \leavevmode
Endpoint supports control type (reserved for ep0).

\item[{\code{type\_iso}}] \leavevmode
Endpoint supports isochronous transfers.

\item[{\code{type\_bulk}}] \leavevmode
Endpoint supports bulk transfers.

\item[{\code{type\_int}}] \leavevmode
Endpoint supports interrupt transfers.

\item[{\code{dir\_in}}] \leavevmode
Endpoint supports IN direction.

\item[{\code{dir\_out}}] \leavevmode
Endpoint supports OUT direction.

\end{description}
\index{usb\_ep (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_ep}\pysigline{struct \bfcode{usb\_ep}}
device side representation of USB endpoint

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}ep \PYGZob{}
  void *driver\PYGZus{}data;
  const char              *name;
  const struct usb\PYGZus{}ep\PYGZus{}ops *ops;
  struct list\PYGZus{}head        ep\PYGZus{}list;
  struct usb\PYGZus{}ep\PYGZus{}caps      caps;
  bool claimed;
  bool enabled;
  unsigned maxpacket:16;
  unsigned maxpacket\PYGZus{}limit:16;
  unsigned max\PYGZus{}streams:16;
  unsigned mult:2;
  unsigned maxburst:5;
  u8 address;
  const struct usb\PYGZus{}endpoint\PYGZus{}descriptor    *desc;
  const struct usb\PYGZus{}ss\PYGZus{}ep\PYGZus{}comp\PYGZus{}descriptor  *comp\PYGZus{}desc;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{driver\_data}}] \leavevmode
for use by the gadget driver.

\item[{\code{name}}] \leavevmode
identifier for the endpoint, such as ``ep-a'' or ``ep9in-bulk''

\item[{\code{ops}}] \leavevmode
Function pointers used to access hardware-specific operations.

\item[{\code{ep\_list}}] \leavevmode
the gadget's ep\_list holds all of its endpoints

\item[{\code{caps}}] \leavevmode
The structure describing types and directions supported by endoint.

\item[{\code{claimed}}] \leavevmode
True if this endpoint is claimed by a function.

\item[{\code{enabled}}] \leavevmode
The current endpoint enabled/disabled state.

\item[{\code{maxpacket}}] \leavevmode
The maximum packet size used on this endpoint.  The initial
value can sometimes be reduced (hardware allowing), according to
the endpoint descriptor used to configure the endpoint.

\item[{\code{maxpacket\_limit}}] \leavevmode
The maximum packet size value which can be handled by this
endpoint. It's set once by UDC driver when endpoint is initialized, and
should not be changed. Should not be confused with maxpacket.

\item[{\code{max\_streams}}] \leavevmode
The maximum number of streams supported
by this EP (0 - 16, actual number is 2\textasciicircum{}n)

\item[{\code{mult}}] \leavevmode
multiplier, `mult' value for SS Isoc EPs

\item[{\code{maxburst}}] \leavevmode
the maximum number of bursts supported by this EP (for usb3)

\item[{\code{address}}] \leavevmode
used to identify the endpoint when finding descriptor that
matches connection speed

\item[{\code{desc}}] \leavevmode
endpoint descriptor.  This pointer is set before the endpoint is
enabled and remains valid until the endpoint is disabled.

\item[{\code{comp\_desc}}] \leavevmode
In case of SuperSpeed support, this is the endpoint companion
descriptor that is used to configure the endpoint

\end{description}

\textbf{Description}

the bus controller driver lists all the general purpose endpoints in
gadget-\textgreater{}ep\_list.  the control endpoint (gadget-\textgreater{}ep0) is not in that list,
and is accessed only in response to a driver \code{setup()} callback.
\index{usb\_gadget (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_gadget}\pysigline{struct \bfcode{usb\_gadget}}
represents a usb slave device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}gadget \PYGZob{}
  struct work\PYGZus{}struct              work;
  struct usb\PYGZus{}udc                  *udc;
  const struct usb\PYGZus{}gadget\PYGZus{}ops     *ops;
  struct usb\PYGZus{}ep                   *ep0;
  struct list\PYGZus{}head                ep\PYGZus{}list;
  enum usb\PYGZus{}device\PYGZus{}speed           speed;
  enum usb\PYGZus{}device\PYGZus{}speed           max\PYGZus{}speed;
  enum usb\PYGZus{}device\PYGZus{}state           state;
  const char                      *name;
  struct device                   dev;
  unsigned isoch\PYGZus{}delay;
  unsigned out\PYGZus{}epnum;
  unsigned in\PYGZus{}epnum;
  unsigned mA;
  struct usb\PYGZus{}otg\PYGZus{}caps             *otg\PYGZus{}caps;
  unsigned sg\PYGZus{}supported:1;
  unsigned is\PYGZus{}otg:1;
  unsigned is\PYGZus{}a\PYGZus{}peripheral:1;
  unsigned b\PYGZus{}hnp\PYGZus{}enable:1;
  unsigned a\PYGZus{}hnp\PYGZus{}support:1;
  unsigned a\PYGZus{}alt\PYGZus{}hnp\PYGZus{}support:1;
  unsigned hnp\PYGZus{}polling\PYGZus{}support:1;
  unsigned host\PYGZus{}request\PYGZus{}flag:1;
  unsigned quirk\PYGZus{}ep\PYGZus{}out\PYGZus{}aligned\PYGZus{}size:1;
  unsigned quirk\PYGZus{}altset\PYGZus{}not\PYGZus{}supp:1;
  unsigned quirk\PYGZus{}stall\PYGZus{}not\PYGZus{}supp:1;
  unsigned quirk\PYGZus{}zlp\PYGZus{}not\PYGZus{}supp:1;
  unsigned quirk\PYGZus{}avoids\PYGZus{}skb\PYGZus{}reserve:1;
  unsigned is\PYGZus{}selfpowered:1;
  unsigned deactivated:1;
  unsigned connected:1;
  unsigned lpm\PYGZus{}capable:1;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{work}}] \leavevmode
(internal use) Workqueue to be used for \code{sysfs\_notify()}

\item[{\code{udc}}] \leavevmode
struct usb\_udc pointer for this gadget

\item[{\code{ops}}] \leavevmode
Function pointers used to access hardware-specific operations.

\item[{\code{ep0}}] \leavevmode
Endpoint zero, used when reading or writing responses to
driver \code{setup()} requests

\item[{\code{ep\_list}}] \leavevmode
List of other endpoints supported by the device.

\item[{\code{speed}}] \leavevmode
Speed of current connection to USB host.

\item[{\code{max\_speed}}] \leavevmode
Maximal speed the UDC can handle.  UDC must support this
and all slower speeds.

\item[{\code{state}}] \leavevmode
the state we are now (attached, suspended, configured, etc)

\item[{\code{name}}] \leavevmode
Identifies the controller hardware type.  Used in diagnostics
and sometimes configuration.

\item[{\code{dev}}] \leavevmode
Driver model state for this abstract device.

\item[{\code{isoch\_delay}}] \leavevmode
value from Set Isoch Delay request. Only valid on SS/SSP

\item[{\code{out\_epnum}}] \leavevmode
last used out ep number

\item[{\code{in\_epnum}}] \leavevmode
last used in ep number

\item[{\code{mA}}] \leavevmode
last set mA value

\item[{\code{otg\_caps}}] \leavevmode
OTG capabilities of this gadget.

\item[{\code{sg\_supported}}] \leavevmode
true if we can handle scatter-gather

\item[{\code{is\_otg}}] \leavevmode
True if the USB device port uses a Mini-AB jack, so that the
gadget driver must provide a USB OTG descriptor.

\item[{\code{is\_a\_peripheral}}] \leavevmode
False unless is\_otg, the ``A'' end of a USB cable
is in the Mini-AB jack, and HNP has been used to switch roles
so that the ``A'' device currently acts as A-Peripheral, not A-Host.

\item[{\code{b\_hnp\_enable}}] \leavevmode
OTG device feature flag, indicating that the A-Host
enabled HNP support.

\item[{\code{a\_hnp\_support}}] \leavevmode
OTG device feature flag, indicating that the A-Host
supports HNP at this port.

\item[{\code{a\_alt\_hnp\_support}}] \leavevmode
OTG device feature flag, indicating that the A-Host
only supports HNP on a different root port.

\item[{\code{hnp\_polling\_support}}] \leavevmode
OTG device feature flag, indicating if the OTG device
in peripheral mode can support HNP polling.

\item[{\code{host\_request\_flag}}] \leavevmode
OTG device feature flag, indicating if A-Peripheral
or B-Peripheral wants to take host role.

\item[{\code{quirk\_ep\_out\_aligned\_size}}] \leavevmode
epout requires buffer size to be aligned to
MaxPacketSize.

\item[{\code{quirk\_altset\_not\_supp}}] \leavevmode
UDC controller doesn't support alt settings.

\item[{\code{quirk\_stall\_not\_supp}}] \leavevmode
UDC controller doesn't support stalling.

\item[{\code{quirk\_zlp\_not\_supp}}] \leavevmode
UDC controller doesn't support ZLP.

\item[{\code{quirk\_avoids\_skb\_reserve}}] \leavevmode
udc/platform wants to avoid \code{skb\_reserve()} in
u\_ether.c to improve performance.

\item[{\code{is\_selfpowered}}] \leavevmode
if the gadget is self-powered.

\item[{\code{deactivated}}] \leavevmode
True if gadget is deactivated - in deactivated state it cannot
be connected.

\item[{\code{connected}}] \leavevmode
True if gadget is connected.

\item[{\code{lpm\_capable}}] \leavevmode
If the gadget max\_speed is FULL or HIGH, this flag
indicates that it supports LPM as per the LPM ECN \& errata.

\end{description}

\textbf{Description}

Gadgets have a mostly-portable ``gadget driver'' implementing device
functions, handling all usb configurations and interfaces.  Gadget
drivers talk to hardware-specific code indirectly, through ops vectors.
That insulates the gadget driver from hardware details, and packages
the hardware endpoints through generic i/o queues.  The ``usb\_gadget''
and ``usb\_ep'' interfaces provide that insulation from the hardware.

Except for the driver data, all fields in this structure are
read-only to the gadget driver.  That driver data is part of the
``driver model'' infrastructure in 2.6 (and later) kernels, and for
earlier systems is grouped in a similar structure that's not known
to the rest of the kernel.

Values of the three OTG device feature flags are updated before the
\code{setup()} call corresponding to USB\_REQ\_SET\_CONFIGURATION, and before
driver \code{suspend()} calls.  They are valid only when is\_otg, and when the
device is acting as a B-Peripheral (so is\_a\_peripheral is false).
\index{usb\_ep\_align (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_ep_align}\pysiglinewithargsret{size\_t \bfcode{usb\_ep\_align}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_ep]{\emph{usb\_ep}}} *\emph{ ep}, size\_t\emph{ len}}{}
returns \textbf{len} aligned to ep's maxpacketsize.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_ep * ep}}] \leavevmode
the endpoint whose maxpacketsize is used to align \textbf{len}

\item[{\code{size\_t len}}] \leavevmode
buffer size's length to align to \textbf{ep}`s maxpacketsize

\end{description}

\textbf{Description}

This helper is used to align buffer's size to an ep's maxpacketsize.
\index{usb\_ep\_align\_maybe (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_ep_align_maybe}\pysiglinewithargsret{size\_t \bfcode{usb\_ep\_align\_maybe}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_gadget]{\emph{usb\_gadget}}} *\emph{ g}, struct {\hyperref[driver\string-api/usb/gadget:c.usb_ep]{\emph{usb\_ep}}} *\emph{ ep}, size\_t\emph{ len}}{}
returns \textbf{len} aligned to ep's maxpacketsize if gadget requires quirk\_ep\_out\_aligned\_size, otherwise returns len.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_gadget * g}}] \leavevmode
controller to check for quirk

\item[{\code{struct usb\_ep * ep}}] \leavevmode
the endpoint whose maxpacketsize is used to align \textbf{len}

\item[{\code{size\_t len}}] \leavevmode
buffer size's length to align to \textbf{ep}`s maxpacketsize

\end{description}

\textbf{Description}

This helper is used in case it's required for any reason to check and maybe
align buffer's size to an ep's maxpacketsize.
\index{gadget\_is\_altset\_supported (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.gadget_is_altset_supported}\pysiglinewithargsret{int \bfcode{gadget\_is\_altset\_supported}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_gadget]{\emph{usb\_gadget}}} *\emph{ g}}{}
return true iff the hardware supports altsettings

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_gadget * g}}] \leavevmode
controller to check for quirk

\end{description}
\index{gadget\_is\_stall\_supported (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.gadget_is_stall_supported}\pysiglinewithargsret{int \bfcode{gadget\_is\_stall\_supported}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_gadget]{\emph{usb\_gadget}}} *\emph{ g}}{}
return true iff the hardware supports stalling

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_gadget * g}}] \leavevmode
controller to check for quirk

\end{description}
\index{gadget\_is\_zlp\_supported (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.gadget_is_zlp_supported}\pysiglinewithargsret{int \bfcode{gadget\_is\_zlp\_supported}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_gadget]{\emph{usb\_gadget}}} *\emph{ g}}{}
return true iff the hardware supports zlp

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_gadget * g}}] \leavevmode
controller to check for quirk

\end{description}
\index{gadget\_avoids\_skb\_reserve (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.gadget_avoids_skb_reserve}\pysiglinewithargsret{int \bfcode{gadget\_avoids\_skb\_reserve}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_gadget]{\emph{usb\_gadget}}} *\emph{ g}}{}
return true iff the hardware would like to avoid skb\_reserve to improve performance.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_gadget * g}}] \leavevmode
controller to check for quirk

\end{description}
\index{gadget\_is\_dualspeed (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.gadget_is_dualspeed}\pysiglinewithargsret{int \bfcode{gadget\_is\_dualspeed}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_gadget]{\emph{usb\_gadget}}} *\emph{ g}}{}
return true iff the hardware handles high speed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_gadget * g}}] \leavevmode
controller that might support both high and full speeds

\end{description}
\index{gadget\_is\_superspeed (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.gadget_is_superspeed}\pysiglinewithargsret{int \bfcode{gadget\_is\_superspeed}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_gadget]{\emph{usb\_gadget}}} *\emph{ g}}{}
return true if the hardware handles superspeed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_gadget * g}}] \leavevmode
controller that might support superspeed

\end{description}
\index{gadget\_is\_superspeed\_plus (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.gadget_is_superspeed_plus}\pysiglinewithargsret{int \bfcode{gadget\_is\_superspeed\_plus}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_gadget]{\emph{usb\_gadget}}} *\emph{ g}}{}
return true if the hardware handles superspeed plus

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_gadget * g}}] \leavevmode
controller that might support superspeed plus

\end{description}
\index{gadget\_is\_otg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.gadget_is_otg}\pysiglinewithargsret{int \bfcode{gadget\_is\_otg}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_gadget]{\emph{usb\_gadget}}} *\emph{ g}}{}
return true iff the hardware is OTG-ready

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_gadget * g}}] \leavevmode
controller that might have a Mini-AB connector

\end{description}

\textbf{Description}

This is a runtime test, since kernels with a USB-OTG stack sometimes
run on boards which only have a Mini-B (or Mini-A) connector.
\index{usb\_gadget\_driver (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_gadget_driver}\pysigline{struct \bfcode{usb\_gadget\_driver}}
driver for usb `slave' devices

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}gadget\PYGZus{}driver \PYGZob{}
  char *function;
  enum usb\PYGZus{}device\PYGZus{}speed   max\PYGZus{}speed;
  int (*bind)(struct usb\PYGZus{}gadget *gadget, struct usb\PYGZus{}gadget\PYGZus{}driver *driver);
  void (*unbind)(struct usb\PYGZus{}gadget *);
  int (*setup)(struct usb\PYGZus{}gadget *, const struct usb\PYGZus{}ctrlrequest *);
  void (*disconnect)(struct usb\PYGZus{}gadget *);
  void (*suspend)(struct usb\PYGZus{}gadget *);
  void (*resume)(struct usb\PYGZus{}gadget *);
  void (*reset)(struct usb\PYGZus{}gadget *);
  struct device\PYGZus{}driver    driver;
  char *udc\PYGZus{}name;
  struct list\PYGZus{}head        pending;
  unsigned match\PYGZus{}existing\PYGZus{}only:1;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{function}}] \leavevmode
String describing the gadget's function

\item[{\code{max\_speed}}] \leavevmode
Highest speed the driver handles.

\item[{\code{bind}}] \leavevmode
the driver's bind callback

\item[{\code{unbind}}] \leavevmode
Invoked when the driver is unbound from a gadget,
usually from rmmod (after a disconnect is reported).
Called in a context that permits sleeping.

\item[{\code{setup}}] \leavevmode
Invoked for ep0 control requests that aren't handled by
the hardware level driver. Most calls must be handled by
the gadget driver, including descriptor and configuration
management.  The 16 bit members of the setup data are in
USB byte order. Called in\_interrupt; this may not sleep.  Driver
queues a response to ep0, or returns negative to stall.

\item[{\code{disconnect}}] \leavevmode
Invoked after all transfers have been stopped,
when the host is disconnected.  May be called in\_interrupt; this
may not sleep.  Some devices can't detect disconnect, so this might
not be called except as part of controller shutdown.

\item[{\code{suspend}}] \leavevmode
Invoked on USB suspend.  May be called in\_interrupt.

\item[{\code{resume}}] \leavevmode
Invoked on USB resume.  May be called in\_interrupt.

\item[{\code{reset}}] \leavevmode
Invoked on USB bus reset. It is mandatory for all gadget drivers
and should be called in\_interrupt.

\item[{\code{driver}}] \leavevmode
Driver model state for this driver.

\item[{\code{udc\_name}}] \leavevmode
A name of UDC this driver should be bound to. If udc\_name is NULL,
this driver will be bound to any available UDC.

\item[{\code{pending}}] \leavevmode
UDC core private data used for deferred probe of this driver.

\item[{\code{match\_existing\_only}}] \leavevmode
If udc is not found, return an error and don't add this
gadget driver to list of pending driver

\end{description}

\textbf{Description}

Devices are disabled till a gadget driver successfully \code{bind(){}`s, which
means the driver will handle :c:func:{}`setup()} requests needed to enumerate (and
meet ``chapter 9'' requirements) then do some useful work.

If gadget-\textgreater{}is\_otg is true, the gadget driver must provide an OTG
descriptor during enumeration, or else fail the \code{bind()} call.  In such
cases, no USB traffic may flow until both \code{bind()} returns without
having called \code{usb\_gadget\_disconnect()}, and the USB host stack has
initialized.

Drivers use hardware-specific knowledge to configure the usb hardware.
endpoint addressing is only one of several hardware characteristics that
are in descriptors the ep0 implementation returns from \code{setup()} calls.

Except for ep0 implementation, most driver code shouldn't need change to
run on top of different usb controllers.  It'll use endpoints set up by
that ep0 implementation.

The usb controller driver handles a few standard usb requests.  Those
include set\_address, and feature flags for devices, interfaces, and
endpoints (the get\_status, set\_feature, and clear\_feature requests).

Accordingly, the driver's \code{setup()} callback must always implement all
get\_descriptor requests, returning at least a device descriptor and
a configuration descriptor.  Drivers must make sure the endpoint
descriptors match any hardware constraints. Some hardware also constrains
other descriptors. (The pxa250 allows only configurations 1, 2, or 3).

The driver's \code{setup()} callback must also implement set\_configuration,
and should also implement set\_interface, get\_configuration, and
get\_interface.  Setting a configuration (or interface) is where
endpoints should be activated or (config 0) shut down.

(Note that only the default control endpoint is supported.  Neither
hosts nor devices generally support control traffic except to ep0.)

Most devices will ignore USB suspend/resume operations, and so will
not provide those callbacks.  However, some may need to change modes
when the host is not longer directing those activities.  For example,
local controls (buttons, dials, etc) may need to be re-enabled since
the (remote) host can't do that any longer; or an error state might
be cleared, to make the device behave identically whether or not
power is maintained.
\index{usb\_gadget\_probe\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_gadget_probe_driver}\pysiglinewithargsret{int \bfcode{usb\_gadget\_probe\_driver}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_gadget_driver]{\emph{usb\_gadget\_driver}}} *\emph{ driver}}{}
probe a gadget driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_gadget\_driver * driver}}] \leavevmode
the driver being registered

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

Call this in your gadget driver's module initialization function,
to tell the underlying usb controller driver about your driver.
The \textbf{bind()} function will be called to bind it to a gadget before this
registration call returns.  It's expected that the \textbf{bind()} function will
be in init sections.
\index{usb\_gadget\_unregister\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_gadget_unregister_driver}\pysiglinewithargsret{int \bfcode{usb\_gadget\_unregister\_driver}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_gadget_driver]{\emph{usb\_gadget\_driver}}} *\emph{ driver}}{}
unregister a gadget driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_gadget\_driver * driver}}] \leavevmode
the driver being unregistered

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

Call this in your gadget driver's module cleanup function,
to tell the underlying usb controller that your driver is
going away.  If the controller is connected to a USB host,
it will first \code{disconnect()}.  The driver is also requested
to \code{unbind()} and clean up any device state, before this procedure
finally returns.  It's expected that the \code{unbind()} functions
will in in exit sections, so may not be linked in some kernels.
\index{usb\_string (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_string}\pysigline{struct \bfcode{usb\_string}}
wraps a C string and its USB id

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}string \PYGZob{}
  u8 id;
  const char              *s;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{id}}] \leavevmode
the (nonzero) ID for this string

\item[{\code{s}}] \leavevmode
the string, in UTF-8 encoding

\end{description}

\textbf{Description}

If you're using {\hyperref[driver\string-api/usb/gadget:c.usb_gadget_get_string]{\emph{\code{usb\_gadget\_get\_string()}}}}, use this to wrap a string
together with its ID.
\index{usb\_gadget\_strings (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_gadget_strings}\pysigline{struct \bfcode{usb\_gadget\_strings}}
a set of USB strings in a given language

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}gadget\PYGZus{}strings \PYGZob{}
  u16 language;
  struct usb\PYGZus{}string       *strings;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{language}}] \leavevmode
identifies the strings' language (0x0409 for en-us)

\item[{\code{strings}}] \leavevmode
array of strings with their ids

\end{description}

\textbf{Description}

If you're using {\hyperref[driver\string-api/usb/gadget:c.usb_gadget_get_string]{\emph{\code{usb\_gadget\_get\_string()}}}}, use this to wrap all the
strings for a given language.
\index{usb\_free\_descriptors (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_free_descriptors}\pysiglinewithargsret{void \bfcode{usb\_free\_descriptors}}{struct usb\_descriptor\_header **\emph{ v}}{}
free descriptors returned by {\hyperref[driver\string-api/usb/gadget:c.usb_copy_descriptors]{\emph{\code{usb\_copy\_descriptors()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_descriptor\_header ** v}}] \leavevmode
vector of descriptors

\end{description}


\subsubsection{Optional Utilities}
\label{driver-api/usb/gadget:optional-utilities}
The core API is sufficient for writing a USB Gadget Driver, but some
optional utilities are provided to simplify common tasks. These
utilities include endpoint autoconfiguration.
\index{usb\_gadget\_get\_string (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_gadget_get_string}\pysiglinewithargsret{int \bfcode{usb\_gadget\_get\_string}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_gadget_strings]{\emph{usb\_gadget\_strings}}} *\emph{ table}, int\emph{ id}, u8 *\emph{ buf}}{}
fill out a string descriptor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_gadget\_strings * table}}] \leavevmode
of c strings encoded using UTF-8

\item[{\code{int id}}] \leavevmode
string id, from low byte of wValue in get string descriptor

\item[{\code{u8 * buf}}] \leavevmode
at least 256 bytes, must be 16-bit aligned

\end{description}

\textbf{Description}

Finds the UTF-8 string matching the ID, and converts it into a
string descriptor in utf16-le.
Returns length of descriptor (always even) or negative errno

If your driver needs stings in multiple languages, you'll probably
``switch (wIndex) \{ ... \}''  in your ep0 string descriptor logic,
using this routine after choosing which set of UTF-8 strings to use.
Note that US-ASCII is a strict subset of UTF-8; any string bytes with
the eighth bit set will be multibyte UTF-8 characters, not ISO-8859/1
characters (which are also widely used in C strings).
\index{usb\_descriptor\_fillbuf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_descriptor_fillbuf}\pysiglinewithargsret{int \bfcode{usb\_descriptor\_fillbuf}}{void *\emph{ buf}, unsigned\emph{ buflen}, const struct usb\_descriptor\_header **\emph{ src}}{}
fill buffer with descriptors

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * buf}}] \leavevmode
Buffer to be filled

\item[{\code{unsigned buflen}}] \leavevmode
Size of buf

\item[{\code{const struct usb\_descriptor\_header ** src}}] \leavevmode
Array of descriptor pointers, terminated by null pointer.

\end{description}

\textbf{Description}

Copies descriptors into the buffer, returning the length or a
negative error code if they can't all be copied.  Useful when
assembling descriptors for an associated set of interfaces used
as part of configuring a composite device; or in other cases where
sets of descriptors need to be marshaled.
\index{usb\_gadget\_config\_buf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_gadget_config_buf}\pysiglinewithargsret{int \bfcode{usb\_gadget\_config\_buf}}{const struct usb\_config\_descriptor *\emph{ config}, void *\emph{ buf}, unsigned\emph{ length}, const struct usb\_descriptor\_header **\emph{ desc}}{}
builts a complete configuration descriptor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct usb\_config\_descriptor * config}}] \leavevmode
Header for the descriptor, including characteristics such
as power requirements and number of interfaces.

\item[{\code{void * buf}}] \leavevmode
Buffer for the resulting configuration descriptor.

\item[{\code{unsigned length}}] \leavevmode
Length of buffer.  If this is not big enough to hold the
entire configuration descriptor, an error code will be returned.

\item[{\code{const struct usb\_descriptor\_header ** desc}}] \leavevmode
Null-terminated vector of pointers to the descriptors (interface,
endpoint, etc) defining all functions in this device configuration.

\end{description}

\textbf{Description}

This copies descriptors into the response buffer, building a descriptor
for that configuration.  It returns the buffer length or a negative
status code.  The config.wTotalLength field is set to match the length
of the result, but other descriptor fields (including power usage and
interface count) must be set by the caller.

Gadget drivers could use this when constructing a config descriptor
in response to USB\_REQ\_GET\_DESCRIPTOR.  They will need to patch the
resulting bDescriptorType value if USB\_DT\_OTHER\_SPEED\_CONFIG is needed.
\index{usb\_copy\_descriptors (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_copy_descriptors}\pysiglinewithargsret{struct usb\_descriptor\_header ** \bfcode{usb\_copy\_descriptors}}{struct usb\_descriptor\_header **\emph{ src}}{}
copy a vector of USB descriptors

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_descriptor\_header ** src}}] \leavevmode
null-terminated vector to copy

\end{description}

\textbf{Context}

initialization code, which may sleep

\textbf{Description}

This makes a copy of a vector of USB descriptors.  Its primary use
is to support usb\_function objects which can have multiple copies,
each needing different descriptors.  Functions may have static
tables of descriptors, which are used as templates and customized
with identifiers (for interfaces, strings, endpoints, and more)
as needed by a given function instance.


\subsubsection{Composite Device Framework}
\label{driver-api/usb/gadget:composite-device-framework}
The core API is sufficient for writing drivers for composite USB devices
(with more than one function in a given configuration), and also
multi-configuration devices (also more than one function, but not
necessarily sharing a given configuration). There is however an optional
framework which makes it easier to reuse and combine functions.

Devices using this framework provide a struct {\hyperref[driver\string-api/usb/gadget:c.usb_composite_driver]{\emph{\code{usb\_composite\_driver}}}},
which in turn provides one or more struct {\hyperref[driver\string-api/usb/gadget:c.usb_configuration]{\emph{\code{usb\_configuration}}}}
instances. Each such configuration includes at least one struct
{\hyperref[driver\string-api/usb/gadget:c.usb_function]{\emph{\code{usb\_function}}}}, which packages a user visible role such as ``network
link'' or ``mass storage device''. Management functions may also exist,
such as ``Device Firmware Upgrade''.
\index{usb\_os\_desc\_ext\_prop (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_os_desc_ext_prop}\pysigline{struct \bfcode{usb\_os\_desc\_ext\_prop}}
describes one ``Extended Property''

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}os\PYGZus{}desc\PYGZus{}ext\PYGZus{}prop \PYGZob{}
  struct list\PYGZus{}head        entry;
  u8 type;
  int name\PYGZus{}len;
  char *name;
  int data\PYGZus{}len;
  char *data;
  struct config\PYGZus{}item      item;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{entry}}] \leavevmode
used to keep a list of extended properties

\item[{\code{type}}] \leavevmode
Extended Property type

\item[{\code{name\_len}}] \leavevmode
Extended Property unicode name length, including terminating `0'

\item[{\code{name}}] \leavevmode
Extended Property name

\item[{\code{data\_len}}] \leavevmode
Length of Extended Property blob (for unicode store double len)

\item[{\code{data}}] \leavevmode
Extended Property blob

\item[{\code{item}}] \leavevmode
Represents this Extended Property in configfs

\end{description}
\index{usb\_os\_desc (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_os_desc}\pysigline{struct \bfcode{usb\_os\_desc}}
describes OS descriptors associated with one interface

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}os\PYGZus{}desc \PYGZob{}
  char *ext\PYGZus{}compat\PYGZus{}id;
  struct list\PYGZus{}head        ext\PYGZus{}prop;
  int ext\PYGZus{}prop\PYGZus{}len;
  int ext\PYGZus{}prop\PYGZus{}count;
  struct mutex            *opts\PYGZus{}mutex;
  struct config\PYGZus{}group     group;
  struct module           *owner;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{ext\_compat\_id}}] \leavevmode
16 bytes of ``Compatible ID'' and ``Subcompatible ID''

\item[{\code{ext\_prop}}] \leavevmode
Extended Properties list

\item[{\code{ext\_prop\_len}}] \leavevmode
Total length of Extended Properties blobs

\item[{\code{ext\_prop\_count}}] \leavevmode
Number of Extended Properties

\item[{\code{opts\_mutex}}] \leavevmode
Optional mutex protecting config data of a usb\_function\_instance

\item[{\code{group}}] \leavevmode
Represents OS descriptors associated with an interface in configfs

\item[{\code{owner}}] \leavevmode
Module associated with this OS descriptor

\end{description}
\index{usb\_os\_desc\_table (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_os_desc_table}\pysigline{struct \bfcode{usb\_os\_desc\_table}}
describes OS descriptors associated with one interface of a usb\_function

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}os\PYGZus{}desc\PYGZus{}table \PYGZob{}
  int if\PYGZus{}id;
  struct usb\PYGZus{}os\PYGZus{}desc      *os\PYGZus{}desc;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{if\_id}}] \leavevmode
Interface id

\item[{\code{os\_desc}}] \leavevmode
``Extended Compatibility ID'' and ``Extended Properties'' of the
interface

\end{description}

\textbf{Description}

Each interface can have at most one ``Extended Compatibility ID'' and a
number of ``Extended Properties''.
\index{usb\_function (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_function}\pysigline{struct \bfcode{usb\_function}}
describes one function of a configuration

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}function \PYGZob{}
  const char                      *name;
  struct usb\PYGZus{}gadget\PYGZus{}strings       **strings;
  struct usb\PYGZus{}descriptor\PYGZus{}header    **fs\PYGZus{}descriptors;
  struct usb\PYGZus{}descriptor\PYGZus{}header    **hs\PYGZus{}descriptors;
  struct usb\PYGZus{}descriptor\PYGZus{}header    **ss\PYGZus{}descriptors;
  struct usb\PYGZus{}descriptor\PYGZus{}header    **ssp\PYGZus{}descriptors;
  struct usb\PYGZus{}configuration        *config;
  struct usb\PYGZus{}os\PYGZus{}desc\PYGZus{}table        *os\PYGZus{}desc\PYGZus{}table;
  unsigned os\PYGZus{}desc\PYGZus{}n;
  int (*bind)(struct usb\PYGZus{}configuration *, struct usb\PYGZus{}function *);
  void (*unbind)(struct usb\PYGZus{}configuration *, struct usb\PYGZus{}function *);
  void (*free\PYGZus{}func)(struct usb\PYGZus{}function *f);
  struct module           *mod;
  int (*set\PYGZus{}alt)(struct usb\PYGZus{}function *, unsigned interface, unsigned alt);
  int (*get\PYGZus{}alt)(struct usb\PYGZus{}function *, unsigned interface);
  void (*disable)(struct usb\PYGZus{}function *);
  int (*setup)(struct usb\PYGZus{}function *, const struct usb\PYGZus{}ctrlrequest *);
  bool (*req\PYGZus{}match)(struct usb\PYGZus{}function *,const struct usb\PYGZus{}ctrlrequest *, bool config0);
  void (*suspend)(struct usb\PYGZus{}function *);
  void (*resume)(struct usb\PYGZus{}function *);
  int (*get\PYGZus{}status)(struct usb\PYGZus{}function *);
  int (*func\PYGZus{}suspend)(struct usb\PYGZus{}function *, u8 suspend\PYGZus{}opt);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
For diagnostics, identifies the function.

\item[{\code{strings}}] \leavevmode
tables of strings, keyed by identifiers assigned during \code{bind()}
and by language IDs provided in control requests

\item[{\code{fs\_descriptors}}] \leavevmode
Table of full (or low) speed descriptors, using interface and
string identifiers assigned during \textbf{bind()}.  If this pointer is null,
the function will not be available at full speed (or at low speed).

\item[{\code{hs\_descriptors}}] \leavevmode
Table of high speed descriptors, using interface and
string identifiers assigned during \textbf{bind()}.  If this pointer is null,
the function will not be available at high speed.

\item[{\code{ss\_descriptors}}] \leavevmode
Table of super speed descriptors, using interface and
string identifiers assigned during \textbf{bind()}. If this
pointer is null after initiation, the function will not
be available at super speed.

\item[{\code{ssp\_descriptors}}] \leavevmode
Table of super speed plus descriptors, using
interface and string identifiers assigned during \textbf{bind()}. If
this pointer is null after initiation, the function will not
be available at super speed plus.

\item[{\code{config}}] \leavevmode
assigned when \textbf{usb\_add\_function()} is called; this is the
configuration with which this function is associated.

\item[{\code{os\_desc\_table}}] \leavevmode
Table of (interface id, os descriptors) pairs. The function
can expose more than one interface. If an interface is a member of
an IAD, only the first interface of IAD has its entry in the table.

\item[{\code{os\_desc\_n}}] \leavevmode
Number of entries in os\_desc\_table

\item[{\code{bind}}] \leavevmode
Before the gadget can register, all of its functions \code{bind()} to the
available resources including string and interface identifiers used
in interface or class descriptors; endpoints; I/O buffers; and so on.

\item[{\code{unbind}}] \leavevmode
Reverses \textbf{bind}; called as a side effect of unregistering the
driver which added this function.

\item[{\code{free\_func}}] \leavevmode
free the struct usb\_function.

\item[{\code{mod}}] \leavevmode
(internal) points to the module that created this structure.

\item[{\code{set\_alt}}] \leavevmode
(REQUIRED) Reconfigures altsettings; function drivers may
initialize usb\_ep.driver data at this time (when it is used).
Note that setting an interface to its current altsetting resets
interface state, and that all interfaces have a disabled state.

\item[{\code{get\_alt}}] \leavevmode
Returns the active altsetting.  If this is not provided,
then only altsetting zero is supported.

\item[{\code{disable}}] \leavevmode
(REQUIRED) Indicates the function should be disabled.  Reasons
include host resetting or reconfiguring the gadget, and disconnection.

\item[{\code{setup}}] \leavevmode
Used for interface-specific control requests.

\item[{\code{req\_match}}] \leavevmode
Tests if a given class request can be handled by this function.

\item[{\code{suspend}}] \leavevmode
Notifies functions when the host stops sending USB traffic.

\item[{\code{resume}}] \leavevmode
Notifies functions when the host restarts USB traffic.

\item[{\code{get\_status}}] \leavevmode
Returns function status as a reply to
\code{GetStatus()} request when the recipient is Interface.

\item[{\code{func\_suspend}}] \leavevmode
callback to be called when
SetFeature(FUNCTION\_SUSPEND) is reseived

\end{description}

\textbf{Description}

A single USB function uses one or more interfaces, and should in most
cases support operation at both full and high speeds.  Each function is
associated by \textbf{usb\_add\_function()} with a one configuration; that function
causes \textbf{bind()} to be called so resources can be allocated as part of
setting up a gadget driver.  Those resources include endpoints, which
should be allocated using \textbf{usb\_ep\_autoconfig()}.

To support dual speed operation, a function driver provides descriptors
for both high and full speed operation.  Except in rare cases that don't
involve bulk endpoints, each speed needs different endpoint descriptors.

Function drivers choose their own strategies for managing instance data.
The simplest strategy just declares it ``static', which means the function
can only be activated once.  If the function needs to be exposed in more
than one configuration at a given speed, it needs to support multiple
usb\_function structures (one for each configuration).

A more complex strategy might encapsulate a \textbf{usb\_function} structure inside
a driver-specific instance structure to allows multiple activations.  An
example of multiple activations might be a CDC ACM function that supports
two or more distinct instances within the same configuration, providing
several independent logical data links to a USB host.
\index{usb\_configuration (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_configuration}\pysigline{struct \bfcode{usb\_configuration}}
represents one gadget configuration

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}configuration \PYGZob{}
  const char                      *label;
  struct usb\PYGZus{}gadget\PYGZus{}strings       **strings;
  const struct usb\PYGZus{}descriptor\PYGZus{}header **descriptors;
  void (*unbind)(struct usb\PYGZus{}configuration *);
  int (*setup)(struct usb\PYGZus{}configuration *, const struct usb\PYGZus{}ctrlrequest *);
  u8 bConfigurationValue;
  u8 iConfiguration;
  u8 bmAttributes;
  u16 MaxPower;
  struct usb\PYGZus{}composite\PYGZus{}dev        *cdev;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{label}}] \leavevmode
For diagnostics, describes the configuration.

\item[{\code{strings}}] \leavevmode
Tables of strings, keyed by identifiers assigned during \textbf{bind()}
and by language IDs provided in control requests.

\item[{\code{descriptors}}] \leavevmode
Table of descriptors preceding all function descriptors.
Examples include OTG and vendor-specific descriptors.

\item[{\code{unbind}}] \leavevmode
Reverses \textbf{bind}; called as a side effect of unregistering the
driver which added this configuration.

\item[{\code{setup}}] \leavevmode
Used to delegate control requests that aren't handled by standard
device infrastructure or directed at a specific interface.

\item[{\code{bConfigurationValue}}] \leavevmode
Copied into configuration descriptor.

\item[{\code{iConfiguration}}] \leavevmode
Copied into configuration descriptor.

\item[{\code{bmAttributes}}] \leavevmode
Copied into configuration descriptor.

\item[{\code{MaxPower}}] \leavevmode
Power consumtion in mA. Used to compute bMaxPower in the
configuration descriptor after considering the bus speed.

\item[{\code{cdev}}] \leavevmode
assigned by \textbf{usb\_add\_config()} before calling \textbf{bind()}; this is
the device associated with this configuration.

\end{description}

\textbf{Description}

Configurations are building blocks for gadget drivers structured around
function drivers.  Simple USB gadgets require only one function and one
configuration, and handle dual-speed hardware by always providing the same
functionality.  Slightly more complex gadgets may have more than one
single-function configuration at a given speed; or have configurations
that only work at one speed.

Composite devices are, by definition, ones with configurations which
include more than one function.

The lifecycle of a usb\_configuration includes allocation, initialization
of the fields described above, and calling \textbf{usb\_add\_config()} to set up
internal data and bind it to a specific device.  The configuration's
\textbf{bind()} method is then used to initialize all the functions and then
call \textbf{usb\_add\_function()} for them.

Those functions would normally be independent of each other, but that's
not mandatory.  CDC WMC devices are an example where functions often
depend on other functions, with some functions subsidiary to others.
Such interdependency may be managed in any way, so long as all of the
descriptors complete by the time the composite driver returns from
its \code{bind()} routine.
\index{usb\_composite\_driver (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_composite_driver}\pysigline{struct \bfcode{usb\_composite\_driver}}
groups configurations into a gadget

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}composite\PYGZus{}driver \PYGZob{}
  const char                              *name;
  const struct usb\PYGZus{}device\PYGZus{}descriptor      *dev;
  struct usb\PYGZus{}gadget\PYGZus{}strings               **strings;
  enum usb\PYGZus{}device\PYGZus{}speed                   max\PYGZus{}speed;
  unsigned needs\PYGZus{}serial:1;
  int (*bind)(struct usb\PYGZus{}composite\PYGZus{}dev *cdev);
  int (*unbind)(struct usb\PYGZus{}composite\PYGZus{}dev *);
  void (*disconnect)(struct usb\PYGZus{}composite\PYGZus{}dev *);
  void (*suspend)(struct usb\PYGZus{}composite\PYGZus{}dev *);
  void (*resume)(struct usb\PYGZus{}composite\PYGZus{}dev *);
  struct usb\PYGZus{}gadget\PYGZus{}driver                gadget\PYGZus{}driver;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
For diagnostics, identifies the driver.

\item[{\code{dev}}] \leavevmode
Template descriptor for the device, including default device
identifiers.

\item[{\code{strings}}] \leavevmode
tables of strings, keyed by identifiers assigned during \textbf{bind}
and language IDs provided in control requests. Note: The first entries
are predefined. The first entry that may be used is
USB\_GADGET\_FIRST\_AVAIL\_IDX

\item[{\code{max\_speed}}] \leavevmode
Highest speed the driver supports.

\item[{\code{needs\_serial}}] \leavevmode
set to 1 if the gadget needs userspace to provide
a serial number.  If one is not provided, warning will be printed.

\item[{\code{bind}}] \leavevmode
(REQUIRED) Used to allocate resources that are shared across the
whole device, such as string IDs, and add its configurations using
\textbf{usb\_add\_config()}. This may fail by returning a negative errno
value; it should return zero on successful initialization.

\item[{\code{unbind}}] \leavevmode
Reverses \textbf{bind}; called as a side effect of unregistering
this driver.

\item[{\code{disconnect}}] \leavevmode
optional driver disconnect method

\item[{\code{suspend}}] \leavevmode
Notifies when the host stops sending USB traffic,
after function notifications

\item[{\code{resume}}] \leavevmode
Notifies configuration when the host restarts USB traffic,
before function notifications

\item[{\code{gadget\_driver}}] \leavevmode
Gadget driver controlling this driver

\end{description}

\textbf{Description}

Devices default to reporting self powered operation.  Devices which rely
on bus powered operation should report this in their \textbf{bind} method.

Before returning from \textbf{bind}, various fields in the template descriptor
may be overridden.  These include the idVendor/idProduct/bcdDevice values
normally to bind the appropriate host side driver, and the three strings
(iManufacturer, iProduct, iSerialNumber) normally used to provide user
meaningful device identifiers.  (The strings will not be defined unless
they are defined in \textbf{dev} and \textbf{strings}.)  The correct ep0 maxpacket size
is also reported, as defined by the underlying controller driver.
\index{module\_usb\_composite\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.module_usb_composite_driver}\pysiglinewithargsret{\bfcode{module\_usb\_composite\_driver}}{\emph{\_\_usb\_composite\_driver}}{}
Helper macro for registering a USB gadget composite driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_usb\_composite\_driver}}] \leavevmode
usb\_composite\_driver struct

\end{description}

\textbf{Description}

Helper macro for USB gadget composite drivers which do not do anything
special in module init/exit. This eliminates a lot of boilerplate. Each
module may only use this macro once, and calling it replaces {\hyperref[driver\string-api/basics:c.module_init]{\emph{\code{module\_init()}}}}
and {\hyperref[driver\string-api/basics:c.module_exit]{\emph{\code{module\_exit()}}}}
\index{usb\_composite\_dev (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_composite_dev}\pysigline{struct \bfcode{usb\_composite\_dev}}
represents one composite usb gadget

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct usb\PYGZus{}composite\PYGZus{}dev \PYGZob{}
  struct usb\PYGZus{}gadget               *gadget;
  struct usb\PYGZus{}request              *req;
  struct usb\PYGZus{}request              *os\PYGZus{}desc\PYGZus{}req;
  struct usb\PYGZus{}configuration        *config;
  u8 qw\PYGZus{}sign[OS\PYGZus{}STRING\PYGZus{}QW\PYGZus{}SIGN\PYGZus{}LEN];
  u8 b\PYGZus{}vendor\PYGZus{}code;
  struct usb\PYGZus{}configuration        *os\PYGZus{}desc\PYGZus{}config;
  unsigned int                    use\PYGZus{}os\PYGZus{}string:1;
  unsigned int                    setup\PYGZus{}pending:1;
  unsigned int                    os\PYGZus{}desc\PYGZus{}pending:1;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{gadget}}] \leavevmode
read-only, abstracts the gadget's usb peripheral controller

\item[{\code{req}}] \leavevmode
used for control responses; buffer is pre-allocated

\item[{\code{os\_desc\_req}}] \leavevmode
used for OS descriptors responses; buffer is pre-allocated

\item[{\code{config}}] \leavevmode
the currently active configuration

\item[{\code{qw\_sign}}] \leavevmode
qwSignature part of the OS string

\item[{\code{b\_vendor\_code}}] \leavevmode
bMS\_VendorCode part of the OS string

\item[{\code{os\_desc\_config}}] \leavevmode
the configuration to be used with OS descriptors

\item[{\code{use\_os\_string}}] \leavevmode
false by default, interested gadgets set it

\item[{\code{setup\_pending}}] \leavevmode
true when setup request is queued but not completed

\item[{\code{os\_desc\_pending}}] \leavevmode
true when os\_desc request is queued but not completed

\end{description}

\textbf{Description}

One of these devices is allocated and initialized before the
associated device driver's \code{bind()} is called.

OPEN ISSUE:  it appears that some WUSB devices will need to be
built by combining a normal (wired) gadget with a wireless one.
This revision of the gadget framework should probably try to make
sure doing that won't hurt too much.

One notion for how to handle Wireless USB devices involves:
\begin{enumerate}
\item {} 
a second gadget here, discovery mechanism TBD, but likely
needing separate ``register/unregister WUSB gadget'' calls;

\item {} 
updates to usb\_gadget to include flags ``is it wireless'',
``is it wired'', plus (presumably in a wrapper structure)
bandgroup and PHY info;

\item {} 
presumably a wireless\_ep wrapping a usb\_ep, and reporting
wireless-specific parameters like maxburst and maxsequence;

\item {} 
configurations that are specific to wireless links;

\item {} 
function drivers that understand wireless configs and will
support wireless for (additional) function instances;

\item {} 
a function to support association setup (like CBAF), not
necessarily requiring a wireless adapter;

\item {} 
composite device setup that can create one or more wireless
configs, including appropriate association setup support;

\item {} 
more, TBD.

\end{enumerate}
\index{config\_ep\_by\_speed (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.config_ep_by_speed}\pysiglinewithargsret{int \bfcode{config\_ep\_by\_speed}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_gadget]{\emph{usb\_gadget}}} *\emph{ g}, struct {\hyperref[driver\string-api/usb/gadget:c.usb_function]{\emph{usb\_function}}} *\emph{ f}, struct {\hyperref[driver\string-api/usb/gadget:c.usb_ep]{\emph{usb\_ep}}} *\emph{ \_ep}}{}
configures the given endpoint according to gadget speed.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_gadget * g}}] \leavevmode
pointer to the gadget

\item[{\code{struct usb\_function * f}}] \leavevmode
usb function

\item[{\code{struct usb\_ep * \_ep}}] \leavevmode
the endpoint to configure

\end{description}

\textbf{Return}

error code, 0 on success

This function chooses the right descriptors for a given
endpoint according to gadget speed and saves it in the
endpoint desc field. If the endpoint already has a descriptor
assigned to it - overwrites it with currently corresponding
descriptor. The endpoint maxpacket field is updated according
to the chosen descriptor.

\textbf{Note}

the supplied function should hold all the descriptors
for supported speeds
\index{usb\_add\_function (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_add_function}\pysiglinewithargsret{int \bfcode{usb\_add\_function}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_configuration]{\emph{usb\_configuration}}} *\emph{ config}, struct {\hyperref[driver\string-api/usb/gadget:c.usb_function]{\emph{usb\_function}}} *\emph{ function}}{}
add a function to a configuration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_configuration * config}}] \leavevmode
the configuration

\item[{\code{struct usb\_function * function}}] \leavevmode
the function being added

\end{description}

\textbf{Context}

single threaded during gadget setup

\textbf{Description}

After initialization, each configuration must have one or more
functions added to it.  Adding a function involves calling its \textbf{bind()}
method to allocate resources such as interface and string identifiers
and endpoints.

This function returns the value of the function's \code{bind()}, which is
zero for success else a negative errno value.
\index{usb\_function\_deactivate (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_function_deactivate}\pysiglinewithargsret{int \bfcode{usb\_function\_deactivate}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_function]{\emph{usb\_function}}} *\emph{ function}}{}
prevent function and gadget enumeration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_function * function}}] \leavevmode
the function that isn't yet ready to respond

\end{description}

\textbf{Description}

Blocks response of the gadget driver to host enumeration by
preventing the data line pullup from being activated.  This is
normally called during \textbf{bind()} processing to change from the
initial ``ready to respond'' state, or when a required resource
becomes available.

For example, drivers that serve as a passthrough to a userspace
daemon can block enumeration unless that daemon (such as an OBEX,
MTP, or print server) is ready to handle host requests.

Not all systems support software control of their USB peripheral
data pullups.

Returns zero on success, else negative errno.
\index{usb\_function\_activate (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_function_activate}\pysiglinewithargsret{int \bfcode{usb\_function\_activate}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_function]{\emph{usb\_function}}} *\emph{ function}}{}
allow function and gadget enumeration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_function * function}}] \leavevmode
function on which {\hyperref[driver\string-api/usb/gadget:c.usb_function_activate]{\emph{\code{usb\_function\_activate()}}}} was called

\end{description}

\textbf{Description}

Reverses effect of {\hyperref[driver\string-api/usb/gadget:c.usb_function_deactivate]{\emph{\code{usb\_function\_deactivate()}}}}.  If no more functions
are delaying their activation, the gadget driver will respond to
host enumeration procedures.

Returns zero on success, else negative errno.
\index{usb\_interface\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_interface_id}\pysiglinewithargsret{int \bfcode{usb\_interface\_id}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_configuration]{\emph{usb\_configuration}}} *\emph{ config}, struct {\hyperref[driver\string-api/usb/gadget:c.usb_function]{\emph{usb\_function}}} *\emph{ function}}{}
allocate an unused interface ID

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_configuration * config}}] \leavevmode
configuration associated with the interface

\item[{\code{struct usb\_function * function}}] \leavevmode
function handling the interface

\end{description}

\textbf{Context}

single threaded during gadget setup

\textbf{Description}

{\hyperref[driver\string-api/usb/gadget:c.usb_interface_id]{\emph{\code{usb\_interface\_id()}}}} is called from usb\_function.:c:func:\emph{bind()} callbacks to
allocate new interface IDs.  The function driver will then store that
ID in interface, association, CDC union, and other descriptors.  It
will also handle any control requests targeted at that interface,
particularly changing its altsetting via \code{set\_alt()}.  There may
also be class-specific or vendor-specific requests to handle.

All interface identifier should be allocated using this routine, to
ensure that for example different functions don't wrongly assign
different meanings to the same identifier.  Note that since interface
identifiers are configuration-specific, functions used in more than
one configuration (or more than once in a given configuration) need
multiple versions of the relevant descriptors.

Returns the interface ID which was allocated; or -ENODEV if no
more interface IDs can be allocated.
\index{usb\_add\_config (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_add_config}\pysiglinewithargsret{int \bfcode{usb\_add\_config}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_composite_dev]{\emph{usb\_composite\_dev}}} *\emph{ cdev}, struct {\hyperref[driver\string-api/usb/gadget:c.usb_configuration]{\emph{usb\_configuration}}} *\emph{ config}, int (*bind) (struct {\hyperref[driver\string-api/usb/gadget:c.usb_configuration]{\emph{usb\_configuration}}}\emph{ *}}{}
add a configuration to a device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_composite\_dev * cdev}}] \leavevmode
wraps the USB gadget

\item[{\code{struct usb\_configuration * config}}] \leavevmode
the configuration, with bConfigurationValue assigned

\item[{\code{int (*)(struct usb\_configuration *) bind}}] \leavevmode
the configuration's bind function

\end{description}

\textbf{Context}

single threaded during gadget setup

\textbf{Description}

One of the main tasks of a composite \textbf{bind()} routine is to
add each of the configurations it supports, using this routine.

This function returns the value of the configuration's \textbf{bind()}, which
is zero for success else a negative errno value.  Binding configurations
assigns global resources including string IDs, and per-configuration
resources such as interface IDs and endpoints.
\index{usb\_string\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_string_id}\pysiglinewithargsret{int \bfcode{usb\_string\_id}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_composite_dev]{\emph{usb\_composite\_dev}}} *\emph{ cdev}}{}
allocate an unused string ID

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_composite\_dev * cdev}}] \leavevmode
the device whose string descriptor IDs are being allocated

\end{description}

\textbf{Context}

single threaded during gadget setup

\textbf{Description}

\textbf{usb\_string\_id()} is called from \code{bind()} callbacks to allocate
string IDs.  Drivers for functions, configurations, or gadgets will
then store that ID in the appropriate descriptors and string table.

All string identifier should be allocated using this,
\textbf{usb\_string\_ids\_tab()} or \textbf{usb\_string\_ids\_n()} routine, to ensure
that for example different functions don't wrongly assign different
meanings to the same identifier.
\index{usb\_string\_ids\_tab (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_string_ids_tab}\pysiglinewithargsret{int \bfcode{usb\_string\_ids\_tab}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_composite_dev]{\emph{usb\_composite\_dev}}} *\emph{ cdev}, struct {\hyperref[driver\string-api/usb/usb:c.usb_string]{\emph{usb\_string}}} *\emph{ str}}{}
allocate unused string IDs in batch

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_composite\_dev * cdev}}] \leavevmode
the device whose string descriptor IDs are being allocated

\item[{\code{struct usb\_string * str}}] \leavevmode
an array of usb\_string objects to assign numbers to

\end{description}

\textbf{Context}

single threaded during gadget setup

\textbf{Description}

\textbf{usb\_string\_ids()} is called from \code{bind()} callbacks to allocate
string IDs.  Drivers for functions, configurations, or gadgets will
then copy IDs from the string table to the appropriate descriptors
and string table for other languages.

All string identifier should be allocated using this,
\textbf{usb\_string\_id()} or \textbf{usb\_string\_ids\_n()} routine, to ensure that for
example different functions don't wrongly assign different meanings
to the same identifier.
\index{usb\_gstrings\_attach (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_gstrings_attach}\pysiglinewithargsret{struct {\hyperref[driver\string-api/usb/usb:c.usb_string]{\emph{usb\_string}}} * \bfcode{usb\_gstrings\_attach}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_composite_dev]{\emph{usb\_composite\_dev}}} *\emph{ cdev}, struct {\hyperref[driver\string-api/usb/gadget:c.usb_gadget_strings]{\emph{usb\_gadget\_strings}}} **\emph{ sp}, unsigned\emph{ n\_strings}}{}
attach gadget strings to a cdev and assign ids

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_composite\_dev * cdev}}] \leavevmode
the device whose string descriptor IDs are being allocated
and attached.

\item[{\code{struct usb\_gadget\_strings ** sp}}] \leavevmode
an array of usb\_gadget\_strings to attach.

\item[{\code{unsigned n\_strings}}] \leavevmode
number of entries in each usb\_strings array (sp{[}{]}-\textgreater{}strings)

\end{description}

\textbf{Description}

This function will create a deep copy of usb\_gadget\_strings and usb\_string
and attach it to the cdev. The actual string (usb\_string.s) will not be
copied but only a referenced will be made. The struct usb\_gadget\_strings
array may contain multiple languages and should be NULL terminated.
The -\textgreater{}language pointer of each struct usb\_gadget\_strings has to contain the
same amount of entries.
For instance: sp{[}0{]} is en-US, sp{[}1{]} is es-ES. It is expected that the first
usb\_string entry of es-ES contains the translation of the first usb\_string
entry of en-US. Therefore both entries become the same id assign.
\index{usb\_string\_ids\_n (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_string_ids_n}\pysiglinewithargsret{int \bfcode{usb\_string\_ids\_n}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_composite_dev]{\emph{usb\_composite\_dev}}} *\emph{ c}, unsigned\emph{ n}}{}
allocate unused string IDs in batch

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_composite\_dev * c}}] \leavevmode
the device whose string descriptor IDs are being allocated

\item[{\code{unsigned n}}] \leavevmode
number of string IDs to allocate

\end{description}

\textbf{Context}

single threaded during gadget setup

\textbf{Description}

Returns the first requested ID.  This ID and next \textbf{n}-1 IDs are now
valid IDs.  At least provided that \textbf{n} is non-zero because if it
is, returns last requested ID which is now very useful information.

\textbf{usb\_string\_ids\_n()} is called from \code{bind()} callbacks to allocate
string IDs.  Drivers for functions, configurations, or gadgets will
then store that ID in the appropriate descriptors and string table.

All string identifier should be allocated using this,
\textbf{usb\_string\_id()} or \textbf{usb\_string\_ids\_n()} routine, to ensure that for
example different functions don't wrongly assign different meanings
to the same identifier.
\index{usb\_composite\_probe (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_composite_probe}\pysiglinewithargsret{int \bfcode{usb\_composite\_probe}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_composite_driver]{\emph{usb\_composite\_driver}}} *\emph{ driver}}{}
register a composite driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_composite\_driver * driver}}] \leavevmode
the driver to register

\end{description}

\textbf{Context}

single threaded during gadget setup

\textbf{Description}

This function is used to register drivers using the composite driver
framework.  The return value is zero, or a negative errno value.
Those values normally come from the driver's \textbf{bind} method, which does
all the work of setting up the driver to match the hardware.

On successful return, the gadget is ready to respond to requests from
the host, unless one of its components invokes \code{usb\_gadget\_disconnect()}
while it was binding.  That would usually be done in order to wait for
some userspace participation.
\index{usb\_composite\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_composite_unregister}\pysiglinewithargsret{void \bfcode{usb\_composite\_unregister}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_composite_driver]{\emph{usb\_composite\_driver}}} *\emph{ driver}}{}
unregister a composite driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_composite\_driver * driver}}] \leavevmode
the driver to unregister

\end{description}

\textbf{Description}

This function is used to unregister drivers using the composite
driver framework.
\index{usb\_composite\_setup\_continue (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/gadget:c.usb_composite_setup_continue}\pysiglinewithargsret{void \bfcode{usb\_composite\_setup\_continue}}{struct {\hyperref[driver\string-api/usb/gadget:c.usb_composite_dev]{\emph{usb\_composite\_dev}}} *\emph{ cdev}}{}
Continue with the control transfer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct usb\_composite\_dev * cdev}}] \leavevmode
the composite device who's control transfer was kept waiting

\end{description}

\textbf{Description}

This function must be called by the USB function driver to continue
with the control transfer's data/status stage in case it had requested to
delay the data/status stages. A USB function's setup handler (e.g. \code{set\_alt()})
can request the composite framework to delay the setup request's data/status
stages by returning USB\_GADGET\_DELAYED\_STATUS.


\subsubsection{Composite Device Functions}
\label{driver-api/usb/gadget:composite-device-functions}
At this writing, a few of the current gadget drivers have been converted
to this framework. Near-term plans include converting all of them,
except for \code{gadgetfs}.


\subsection{Peripheral Controller Drivers}
\label{driver-api/usb/gadget:peripheral-controller-drivers}
The first hardware supporting this API was the NetChip 2280 controller,
which supports USB 2.0 high speed and is based on PCI. This is the
\code{net2280} driver module. The driver supports Linux kernel versions 2.4
and 2.6; contact NetChip Technologies for development boards and product
information.

Other hardware working in the \code{gadget} framework includes: Intel's PXA
25x and IXP42x series processors (\code{pxa2xx\_udc}), Toshiba TC86c001
``Goku-S'' (\code{goku\_udc}), Renesas SH7705/7727 (\code{sh\_udc}), MediaQ 11xx
(\code{mq11xx\_udc}), Hynix HMS30C7202 (\code{h7202\_udc}), National 9303/4
(\code{n9604\_udc}), Texas Instruments OMAP (\code{omap\_udc}), Sharp LH7A40x
(\code{lh7a40x\_udc}), and more. Most of those are full speed controllers.

At this writing, there are people at work on drivers in this framework
for several other USB device controllers, with plans to make many of
them be widely available.

A partial USB simulator, the \code{dummy\_hcd} driver, is available. It can
act like a net2280, a pxa25x, or an sa11x0 in terms of available
endpoints and device speeds; and it simulates control, bulk, and to some
extent interrupt transfers. That lets you develop some parts of a gadget
driver on a normal PC, without any special hardware, and perhaps with
the assistance of tools such as GDB running with User Mode Linux. At
least one person has expressed interest in adapting that approach,
hooking it up to a simulator for a microcontroller. Such simulators can
help debug subsystems where the runtime hardware is unfriendly to
software development, or is not yet available.

Support for other controllers is expected to be developed and
contributed over time, as this driver framework evolves.


\subsection{Gadget Drivers}
\label{driver-api/usb/gadget:gadget-drivers}
In addition to \emph{Gadget Zero} (used primarily for testing and development
with drivers for usb controller hardware), other gadget drivers exist.

There's an \code{ethernet} gadget driver, which implements one of the most
useful \emph{Communications Device Class} (CDC) models. One of the standards
for cable modem interoperability even specifies the use of this ethernet
model as one of two mandatory options. Gadgets using this code look to a
USB host as if they're an Ethernet adapter. It provides access to a
network where the gadget's CPU is one host, which could easily be
bridging, routing, or firewalling access to other networks. Since some
hardware can't fully implement the CDC Ethernet requirements, this
driver also implements a ``good parts only'' subset of CDC Ethernet. (That
subset doesn't advertise itself as CDC Ethernet, to avoid creating
problems.)

Support for Microsoft's \code{RNDIS} protocol has been contributed by
Pengutronix and Auerswald GmbH. This is like CDC Ethernet, but it runs
on more slightly USB hardware (but less than the CDC subset). However,
its main claim to fame is being able to connect directly to recent
versions of Windows, using drivers that Microsoft bundles and supports,
making it much simpler to network with Windows.

There is also support for user mode gadget drivers, using \code{gadgetfs}.
This provides a \emph{User Mode API} that presents each endpoint as a single
file descriptor. I/O is done using normal \code{read()} and \code{read()} calls.
Familiar tools like GDB and pthreads can be used to develop and debug
user mode drivers, so that once a robust controller driver is available
many applications for it won't require new kernel mode software. Linux
2.6 \emph{Async I/O (AIO)} support is available, so that user mode software
can stream data with only slightly more overhead than a kernel driver.

There's a USB Mass Storage class driver, which provides a different
solution for interoperability with systems such as MS-Windows and MacOS.
That \emph{Mass Storage} driver uses a file or block device as backing store
for a drive, like the \code{loop} driver. The USB host uses the BBB, CB, or
CBI versions of the mass storage class specification, using transparent
SCSI commands to access the data from the backing store.

There's a ``serial line'' driver, useful for TTY style operation over USB.
The latest version of that driver supports CDC ACM style operation, like
a USB modem, and so on most hardware it can interoperate easily with
MS-Windows. One interesting use of that driver is in boot firmware (like
a BIOS), which can sometimes use that model with very small systems
without real serial lines.

Support for other kinds of gadget is expected to be developed and
contributed over time, as this driver framework evolves.


\subsection{USB On-The-GO (OTG)}
\label{driver-api/usb/gadget:usb-on-the-go-otg}
USB OTG support on Linux 2.6 was initially developed by Texas
Instruments for \href{http://www.omap.com}{OMAP} 16xx and 17xx series
processors. Other OTG systems should work in similar ways, but the
hardware level details could be very different.

Systems need specialized hardware support to implement OTG, notably
including a special \emph{Mini-AB} jack and associated transceiver to support
\emph{Dual-Role} operation: they can act either as a host, using the standard
Linux-USB host side driver stack, or as a peripheral, using this
\code{gadget} framework. To do that, the system software relies on small
additions to those programming interfaces, and on a new internal
component (here called an ``OTG Controller'') affecting which driver stack
connects to the OTG port. In each role, the system can re-use the
existing pool of hardware-neutral drivers, layered on top of the
controller driver interfaces (\code{usb\_bus} or {\hyperref[driver\string-api/usb/gadget:c.usb_gadget]{\emph{\code{usb\_gadget}}}}).
Such drivers need at most minor changes, and most of the calls added to
support OTG can also benefit non-OTG products.
\begin{itemize}
\item {} 
Gadget drivers test the \code{is\_otg} flag, and use it to determine
whether or not to include an OTG descriptor in each of their
configurations.

\item {} 
Gadget drivers may need changes to support the two new OTG protocols,
exposed in new gadget attributes such as \code{b\_hnp\_enable} flag. HNP
support should be reported through a user interface (two LEDs could
suffice), and is triggered in some cases when the host suspends the
peripheral. SRP support can be user-initiated just like remote
wakeup, probably by pressing the same button.

\item {} 
On the host side, USB device drivers need to be taught to trigger HNP
at appropriate moments, using \code{usb\_suspend\_device()}. That also
conserves battery power, which is useful even for non-OTG
configurations.

\item {} 
Also on the host side, a driver must support the OTG ``Targeted
Peripheral List''. That's just a whitelist, used to reject peripherals
not supported with a given Linux OTG host. \emph{This whitelist is
product-specific; each product must modify} \code{otg\_whitelist.h} \emph{to
match its interoperability specification.}

Non-OTG Linux hosts, like PCs and workstations, normally have some
solution for adding drivers, so that peripherals that aren't
recognized can eventually be supported. That approach is unreasonable
for consumer products that may never have their firmware upgraded,
and where it's usually unrealistic to expect traditional
PC/workstation/server kinds of support model to work. For example,
it's often impractical to change device firmware once the product has
been distributed, so driver bugs can't normally be fixed if they're
found after shipment.

\end{itemize}

Additional changes are needed below those hardware-neutral \code{usb\_bus}
and {\hyperref[driver\string-api/usb/gadget:c.usb_gadget]{\emph{\code{usb\_gadget}}}} driver interfaces; those aren't discussed here in any
detail. Those affect the hardware-specific code for each USB Host or
Peripheral controller, and how the HCD initializes (since OTG can be
active only on a single port). They also involve what may be called an
\emph{OTG Controller Driver}, managing the OTG transceiver and the OTG state
machine logic as well as much of the root hub behavior for the OTG port.
The OTG controller driver needs to activate and deactivate USB
controllers depending on the relevant device role. Some related changes
were needed inside usbcore, so that it can identify OTG-capable devices
and respond appropriately to HNP or SRP protocols.


\section{USB Anchors}
\label{driver-api/usb/anchors:usb-anchors}\label{driver-api/usb/anchors::doc}

\subsection{What is anchor?}
\label{driver-api/usb/anchors:what-is-anchor}
A USB driver needs to support some callbacks requiring
a driver to cease all IO to an interface. To do so, a
driver has to keep track of the URBs it has submitted
to know they've all completed or to call usb\_kill\_urb
for them. The anchor is a data structure takes care of
keeping track of URBs and provides methods to deal with
multiple URBs.


\subsection{Allocation and Initialisation}
\label{driver-api/usb/anchors:allocation-and-initialisation}
There's no API to allocate an anchor. It is simply declared
as struct usb\_anchor. \code{init\_usb\_anchor()} must be called to
initialise the data structure.


\subsection{Deallocation}
\label{driver-api/usb/anchors:deallocation}
Once it has no more URBs associated with it, the anchor can be
freed with normal memory management operations.


\subsection{Association and disassociation of URBs with anchors}
\label{driver-api/usb/anchors:association-and-disassociation-of-urbs-with-anchors}
An association of URBs to an anchor is made by an explicit
call to {\hyperref[driver\string-api/usb/usb:c.usb_anchor_urb]{\emph{\code{usb\_anchor\_urb()}}}}. The association is maintained until
an URB is finished by (successful) completion. Thus disassociation
is automatic. A function is provided to forcibly finish (kill)
all URBs associated with an anchor.
Furthermore, disassociation can be made with {\hyperref[driver\string-api/usb/usb:c.usb_unanchor_urb]{\emph{\code{usb\_unanchor\_urb()}}}}


\subsection{Operations on multitudes of URBs}
\label{driver-api/usb/anchors:operations-on-multitudes-of-urbs}

\subsubsection{\texttt{usb\_kill\_anchored\_urbs()}}
\label{driver-api/usb/anchors:usb-kill-anchored-urbs}
This function kills all URBs associated with an anchor. The URBs
are called in the reverse temporal order they were submitted.
This way no data can be reordered.


\subsubsection{\texttt{usb\_unlink\_anchored\_urbs()}}
\label{driver-api/usb/anchors:usb-unlink-anchored-urbs}
This function unlinks all URBs associated with an anchor. The URBs
are processed in the reverse temporal order they were submitted.
This is similar to {\hyperref[driver\string-api/usb/usb:c.usb_kill_anchored_urbs]{\emph{\code{usb\_kill\_anchored\_urbs()}}}}, but it will not sleep.
Therefore no guarantee is made that the URBs have been unlinked when
the call returns. They may be unlinked later but will be unlinked in
finite time.


\subsubsection{\texttt{usb\_scuttle\_anchored\_urbs()}}
\label{driver-api/usb/anchors:usb-scuttle-anchored-urbs}
All URBs of an anchor are unanchored en masse.


\subsubsection{\texttt{usb\_wait\_anchor\_empty\_timeout()}}
\label{driver-api/usb/anchors:usb-wait-anchor-empty-timeout}
This function waits for all URBs associated with an anchor to finish
or a timeout, whichever comes first. Its return value will tell you
whether the timeout was reached.


\subsubsection{\texttt{usb\_anchor\_empty()}}
\label{driver-api/usb/anchors:usb-anchor-empty}
Returns true if no URBs are associated with an anchor. Locking
is the caller's responsibility.


\subsubsection{\texttt{usb\_get\_from\_anchor()}}
\label{driver-api/usb/anchors:usb-get-from-anchor}
Returns the oldest anchored URB of an anchor. The URB is unanchored
and returned with a reference. As you may mix URBs to several
destinations in one anchor you have no guarantee the chronologically
first submitted URB is returned.


\section{USB bulk streams}
\label{driver-api/usb/bulk-streams:usb-bulk-streams}\label{driver-api/usb/bulk-streams::doc}

\subsection{Background}
\label{driver-api/usb/bulk-streams:background}
Bulk endpoint streams were added in the USB 3.0 specification.  Streams allow a
device driver to overload a bulk endpoint so that multiple transfers can be
queued at once.

Streams are defined in sections 4.4.6.4 and 8.12.1.4 of the Universal Serial Bus
3.0 specification at \href{http://www.usb.org/developers/docs/}{http://www.usb.org/developers/docs/}  The USB Attached SCSI
Protocol, which uses streams to queue multiple SCSI commands, can be found on
the T10 website (\href{http://t10.org/}{http://t10.org/}).


\subsection{Device-side implications}
\label{driver-api/usb/bulk-streams:device-side-implications}
Once a buffer has been queued to a stream ring, the device is notified (through
an out-of-band mechanism on another endpoint) that data is ready for that stream
ID.  The device then tells the host which ``stream'' it wants to start.  The host
can also initiate a transfer on a stream without the device asking, but the
device can refuse that transfer.  Devices can switch between streams at any
time.


\subsection{Driver implications}
\label{driver-api/usb/bulk-streams:driver-implications}
\begin{Verbatim}[commandchars=\\\{\}]
int usb\PYGZus{}alloc\PYGZus{}streams(struct usb\PYGZus{}interface *interface,
              struct usb\PYGZus{}host\PYGZus{}endpoint **eps, unsigned int num\PYGZus{}eps,
              unsigned int num\PYGZus{}streams, gfp\PYGZus{}t mem\PYGZus{}flags);
\end{Verbatim}

Device drivers will call this API to request that the host controller driver
allocate memory so the driver can use up to num\_streams stream IDs.  They must
pass an array of usb\_host\_endpoints that need to be setup with similar stream
IDs.  This is to ensure that a UASP driver will be able to use the same stream
ID for the bulk IN and OUT endpoints used in a Bi-directional command sequence.

The return value is an error condition (if one of the endpoints doesn't support
streams, or the xHCI driver ran out of memory), or the number of streams the
host controller allocated for this endpoint.  The xHCI host controller hardware
declares how many stream IDs it can support, and each bulk endpoint on a
SuperSpeed device will say how many stream IDs it can handle.  Therefore,
drivers should be able to deal with being allocated less stream IDs than they
requested.

Do NOT call this function if you have URBs enqueued for any of the endpoints
passed in as arguments.  Do not call this function to request less than two
streams.

Drivers will only be allowed to call this API once for the same endpoint
without calling usb\_free\_streams().  This is a simplification for the xHCI host
controller driver, and may change in the future.


\subsection{Picking new Stream IDs to use}
\label{driver-api/usb/bulk-streams:picking-new-stream-ids-to-use}
Stream ID 0 is reserved, and should not be used to communicate with devices.  If
usb\_alloc\_streams() returns with a value of N, you may use streams 1 though N.
To queue an URB for a specific stream, set the urb-\textgreater{}stream\_id value.  If the
endpoint does not support streams, an error will be returned.

Note that new API to choose the next stream ID will have to be added if the xHCI
driver supports secondary stream IDs.


\subsection{Clean up}
\label{driver-api/usb/bulk-streams:clean-up}
If a driver wishes to stop using streams to communicate with the device, it
should call:

\begin{Verbatim}[commandchars=\\\{\}]
void usb\PYGZus{}free\PYGZus{}streams(struct usb\PYGZus{}interface *interface,
              struct usb\PYGZus{}host\PYGZus{}endpoint **eps, unsigned int num\PYGZus{}eps,
              gfp\PYGZus{}t mem\PYGZus{}flags);
\end{Verbatim}

All stream IDs will be deallocated when the driver releases the interface, to
ensure that drivers that don't support streams will be able to use the endpoint.


\section{USB core callbacks}
\label{driver-api/usb/callbacks:usb-core-callbacks}\label{driver-api/usb/callbacks::doc}

\subsection{What callbacks will usbcore do?}
\label{driver-api/usb/callbacks:what-callbacks-will-usbcore-do}
Usbcore will call into a driver through callbacks defined in the driver
structure and through the completion handler of URBs a driver submits.
Only the former are in the scope of this document. These two kinds of
callbacks are completely independent of each other. Information on the
completion callback can be found in {\hyperref[driver\string-api/usb/URB:usb\string-urb]{\emph{USB Request Block (URB)}}}.

The callbacks defined in the driver structure are:
\begin{enumerate}
\item {} 
Hotplugging callbacks:

\end{enumerate}
\begin{itemize}
\item {} \begin{description}
\item[{@probe:}] \leavevmode
Called to see if the driver is willing to manage a particular
interface on a device.

\end{description}

\item {} \begin{description}
\item[{@disconnect:}] \leavevmode
Called when the interface is no longer accessible, usually
because its device has been (or is being) disconnected or the
driver module is being unloaded.

\end{description}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Odd backdoor through usbfs:

\end{enumerate}
\begin{itemize}
\item {} \begin{description}
\item[{@ioctl:}] \leavevmode
Used for drivers that want to talk to userspace through
the ``usbfs'' filesystem.  This lets devices provide ways to
expose information to user space regardless of where they
do (or don't) show up otherwise in the filesystem.

\end{description}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Power management (PM) callbacks:

\end{enumerate}
\begin{itemize}
\item {} \begin{description}
\item[{@suspend:}] \leavevmode
Called when the device is going to be suspended.

\end{description}

\item {} \begin{description}
\item[{@resume:}] \leavevmode
Called when the device is being resumed.

\end{description}

\item {} \begin{description}
\item[{@reset\_resume:}] \leavevmode
Called when the suspended device has been reset instead
of being resumed.

\end{description}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
Device level operations:

\end{enumerate}
\begin{itemize}
\item {} \begin{description}
\item[{@pre\_reset:}] \leavevmode
Called when the device is about to be reset.

\end{description}

\item {} \begin{description}
\item[{@post\_reset:}] \leavevmode
Called after the device has been reset

\end{description}

\end{itemize}

The ioctl interface (2) should be used only if you have a very good
reason. Sysfs is preferred these days. The PM callbacks are covered
separately in {\hyperref[driver\string-api/usb/power\string-management:usb\string-power\string-management]{\emph{Power Management for USB}}}.


\subsection{Calling conventions}
\label{driver-api/usb/callbacks:calling-conventions}
All callbacks are mutually exclusive. There's no need for locking
against other USB callbacks. All callbacks are called from a task
context. You may sleep. However, it is important that all sleeps have a
small fixed upper limit in time. In particular you must not call out to
user space and await results.


\subsection{Hotplugging callbacks}
\label{driver-api/usb/callbacks:hotplugging-callbacks}
These callbacks are intended to associate and disassociate a driver with
an interface. A driver's bond to an interface is exclusive.


\subsubsection{The probe() callback}
\label{driver-api/usb/callbacks:the-probe-callback}
\begin{Verbatim}[commandchars=\\\{\}]
int (*probe) (struct usb\PYGZus{}interface *intf,
              const struct usb\PYGZus{}device\PYGZus{}id *id);
\end{Verbatim}

Accept or decline an interface. If you accept the device return 0,
otherwise -ENODEV or -ENXIO. Other error codes should be used only if a
genuine error occurred during initialisation which prevented a driver
from accepting a device that would else have been accepted.
You are strongly encouraged to use usbcore's facility,
usb\_set\_intfdata(), to associate a data structure with an interface, so
that you know which internal state and identity you associate with a
particular interface. The device will not be suspended and you may do IO
to the interface you are called for and endpoint 0 of the device. Device
initialisation that doesn't take too long is a good idea here.


\subsubsection{The disconnect() callback}
\label{driver-api/usb/callbacks:the-disconnect-callback}
\begin{Verbatim}[commandchars=\\\{\}]
void (*disconnect) (struct usb\PYGZus{}interface *intf);
\end{Verbatim}

This callback is a signal to break any connection with an interface.
You are not allowed any IO to a device after returning from this
callback. You also may not do any other operation that may interfere
with another driver bound the interface, eg. a power management
operation.
If you are called due to a physical disconnection, all your URBs will be
killed by usbcore. Note that in this case disconnect will be called some
time after the physical disconnection. Thus your driver must be prepared
to deal with failing IO even prior to the callback.


\subsection{Device level callbacks}
\label{driver-api/usb/callbacks:device-level-callbacks}

\subsubsection{pre\_reset}
\label{driver-api/usb/callbacks:pre-reset}
\begin{Verbatim}[commandchars=\\\{\}]
int (*pre\PYGZus{}reset)(struct usb\PYGZus{}interface *intf);
\end{Verbatim}

A driver or user space is triggering a reset on the device which
contains the interface passed as an argument. Cease IO, wait for all
outstanding URBs to complete, and save any device state you need to
restore.  No more URBs may be submitted until the post\_reset method
is called.

If you need to allocate memory here, use GFP\_NOIO or GFP\_ATOMIC, if you
are in atomic context.


\subsubsection{post\_reset}
\label{driver-api/usb/callbacks:post-reset}
\begin{Verbatim}[commandchars=\\\{\}]
int (*post\PYGZus{}reset)(struct usb\PYGZus{}interface *intf);
\end{Verbatim}

The reset has completed.  Restore any saved device state and begin
using the device again.

If you need to allocate memory here, use GFP\_NOIO or GFP\_ATOMIC, if you
are in atomic context.


\subsection{Call sequences}
\label{driver-api/usb/callbacks:call-sequences}
No callbacks other than probe will be invoked for an interface
that isn't bound to your driver.

Probe will never be called for an interface bound to a driver.
Hence following a successful probe, disconnect will be called
before there is another probe for the same interface.

Once your driver is bound to an interface, disconnect can be
called at any time except in between pre\_reset and post\_reset.
pre\_reset is always followed by post\_reset, even if the reset
failed or the device has been unplugged.

suspend is always followed by one of: resume, reset\_resume, or
disconnect.


\section{USB DMA}
\label{driver-api/usb/dma:usb-dma}\label{driver-api/usb/dma::doc}
In Linux 2.5 kernels (and later), USB device drivers have additional control
over how DMA may be used to perform I/O operations.  The APIs are detailed
in the kernel usb programming guide (kerneldoc, from the source code).


\subsection{API overview}
\label{driver-api/usb/dma:api-overview}
The big picture is that USB drivers can continue to ignore most DMA issues,
though they still must provide DMA-ready buffers (see
\code{Documentation/DMA-API-HOWTO.txt}).  That's how they've worked through
the 2.4 (and earlier) kernels, or they can now be DMA-aware.

DMA-aware usb drivers:
\begin{itemize}
\item {} 
New calls enable DMA-aware drivers, letting them allocate dma buffers and
manage dma mappings for existing dma-ready buffers (see below).

\item {} 
URBs have an additional ``transfer\_dma'' field, as well as a transfer\_flags
bit saying if it's valid.  (Control requests also have ``setup\_dma'', but
drivers must not use it.)

\item {} 
``usbcore'' will map this DMA address, if a DMA-aware driver didn't do
it first and set \code{URB\_NO\_TRANSFER\_DMA\_MAP}.  HCDs
don't manage dma mappings for URBs.

\item {} 
There's a new ``generic DMA API'', parts of which are usable by USB device
drivers.  Never use dma\_set\_mask() on any USB interface or device; that
would potentially break all devices sharing that bus.

\end{itemize}


\subsection{Eliminating copies}
\label{driver-api/usb/dma:eliminating-copies}
It's good to avoid making CPUs copy data needlessly.  The costs can add up,
and effects like cache-trashing can impose subtle penalties.
\begin{itemize}
\item {} 
If you're doing lots of small data transfers from the same buffer all
the time, that can really burn up resources on systems which use an
IOMMU to manage the DMA mappings.  It can cost MUCH more to set up and
tear down the IOMMU mappings with each request than perform the I/O!

For those specific cases, USB has primitives to allocate less expensive
memory.  They work like kmalloc and kfree versions that give you the right
kind of addresses to store in urb-\textgreater{}transfer\_buffer and urb-\textgreater{}transfer\_dma.
You'd also set \code{URB\_NO\_TRANSFER\_DMA\_MAP} in urb-\textgreater{}transfer\_flags:

\begin{Verbatim}[commandchars=\\\{\}]
void *usb\PYGZus{}alloc\PYGZus{}coherent (struct usb\PYGZus{}device *dev, size\PYGZus{}t size,
        int mem\PYGZus{}flags, dma\PYGZus{}addr\PYGZus{}t *dma);

void usb\PYGZus{}free\PYGZus{}coherent (struct usb\PYGZus{}device *dev, size\PYGZus{}t size,
        void *addr, dma\PYGZus{}addr\PYGZus{}t dma);
\end{Verbatim}

Most drivers should \textbf{NOT} be using these primitives; they don't need
to use this type of memory (``dma-coherent''), and memory returned from
\code{kmalloc()} will work just fine.

The memory buffer returned is ``dma-coherent''; sometimes you might need to
force a consistent memory access ordering by using memory barriers.  It's
not using a streaming DMA mapping, so it's good for small transfers on
systems where the I/O would otherwise thrash an IOMMU mapping.  (See
\code{Documentation/DMA-API-HOWTO.txt} for definitions of ``coherent'' and
``streaming'' DMA mappings.)

Asking for 1/Nth of a page (as well as asking for N pages) is reasonably
space-efficient.

On most systems the memory returned will be uncached, because the
semantics of dma-coherent memory require either bypassing CPU caches
or using cache hardware with bus-snooping support.  While x86 hardware
has such bus-snooping, many other systems use software to flush cache
lines to prevent DMA conflicts.

\item {} 
Devices on some EHCI controllers could handle DMA to/from high memory.

Unfortunately, the current Linux DMA infrastructure doesn't have a sane
way to expose these capabilities ... and in any case, HIGHMEM is mostly a
design wart specific to x86\_32.  So your best bet is to ensure you never
pass a highmem buffer into a USB driver.  That's easy; it's the default
behavior.  Just don't override it; e.g. with \code{NETIF\_F\_HIGHDMA}.

This may force your callers to do some bounce buffering, copying from
high memory to ``normal'' DMA memory.  If you can come up with a good way
to fix this issue (for x86\_32 machines with over 1 GByte of memory),
feel free to submit patches.

\end{itemize}


\subsection{Working with existing buffers}
\label{driver-api/usb/dma:working-with-existing-buffers}
Existing buffers aren't usable for DMA without first being mapped into the
DMA address space of the device.  However, most buffers passed to your
driver can safely be used with such DMA mapping.  (See the first section
of Documentation/DMA-API-HOWTO.txt, titled ``What memory is DMA-able?'')
\begin{itemize}
\item {} 
When you're using scatterlists, you can map everything at once.  On some
systems, this kicks in an IOMMU and turns the scatterlists into single
DMA transactions:

\begin{Verbatim}[commandchars=\\\{\}]
int usb\PYGZus{}buffer\PYGZus{}map\PYGZus{}sg (struct usb\PYGZus{}device *dev, unsigned pipe,
        struct scatterlist *sg, int nents);

void usb\PYGZus{}buffer\PYGZus{}dmasync\PYGZus{}sg (struct usb\PYGZus{}device *dev, unsigned pipe,
        struct scatterlist *sg, int n\PYGZus{}hw\PYGZus{}ents);

void usb\PYGZus{}buffer\PYGZus{}unmap\PYGZus{}sg (struct usb\PYGZus{}device *dev, unsigned pipe,
        struct scatterlist *sg, int n\PYGZus{}hw\PYGZus{}ents);
\end{Verbatim}

It's probably easier to use the new \code{usb\_sg\_*()} calls, which do the DMA
mapping and apply other tweaks to make scatterlist i/o be fast.

\item {} 
Some drivers may prefer to work with the model that they're mapping large
buffers, synchronizing their safe re-use.  (If there's no re-use, then let
usbcore do the map/unmap.)  Large periodic transfers make good examples
here, since it's cheaper to just synchronize the buffer than to unmap it
each time an urb completes and then re-map it on during resubmission.

These calls all work with initialized urbs:  \code{urb-\textgreater{}dev}, \code{urb-\textgreater{}pipe},
\code{urb-\textgreater{}transfer\_buffer}, and \code{urb-\textgreater{}transfer\_buffer\_length} must all be
valid when these calls are used (\code{urb-\textgreater{}setup\_packet} must be valid too
if urb is a control request):

\begin{Verbatim}[commandchars=\\\{\}]
struct urb *usb\PYGZus{}buffer\PYGZus{}map (struct urb *urb);

void usb\PYGZus{}buffer\PYGZus{}dmasync (struct urb *urb);

void usb\PYGZus{}buffer\PYGZus{}unmap (struct urb *urb);
\end{Verbatim}

The calls manage \code{urb-\textgreater{}transfer\_dma} for you, and set
\code{URB\_NO\_TRANSFER\_DMA\_MAP} so that usbcore won't map or unmap the buffer.
They cannot be used for setup\_packet buffers in control requests.

\end{itemize}

Note that several of those interfaces are currently commented out, since
they don't have current users.  See the source code.  Other than the dmasync
calls (where the underlying DMA primitives have changed), most of them can
easily be commented back in if you want to use them.


\section{USB Request Block (URB)}
\label{driver-api/usb/URB:usb-request-block-urb}\label{driver-api/usb/URB:usb-urb}\label{driver-api/usb/URB::doc}\begin{quote}\begin{description}
\item[{Revised}] \leavevmode
2000-Dec-05

\item[{Again}] \leavevmode
2002-Jul-06

\item[{Again}] \leavevmode
2005-Sep-19

\item[{Again}] \leavevmode
2017-Mar-29

\end{description}\end{quote}

\begin{notice}{note}{Note:}
The USB subsystem now has a substantial section at {\hyperref[driver\string-api/usb/usb:usb\string-hostside\string-api]{\emph{The Linux-USB Host Side API}}}
section, generated from the current source code.
This particular documentation file isn't complete and may not be
updated to the last version; don't rely on it except for a quick
overview.
\end{notice}


\subsection{Basic concept or `What is an URB?'}
\label{driver-api/usb/URB:basic-concept-or-what-is-an-urb}
The basic idea of the new driver is message passing, the message itself is
called USB Request Block, or URB for short.
\begin{itemize}
\item {} 
An URB consists of all relevant information to execute any USB transaction
and deliver the data and status back.

\item {} 
Execution of an URB is inherently an asynchronous operation, i.e. the
{\hyperref[driver\string-api/usb/usb:c.usb_submit_urb]{\emph{\code{usb\_submit\_urb()}}}} call returns immediately after it has successfully
queued the requested action.

\item {} 
Transfers for one URB can be canceled with {\hyperref[driver\string-api/usb/usb:c.usb_unlink_urb]{\emph{\code{usb\_unlink\_urb()}}}}
at any time.

\item {} 
Each URB has a completion handler, which is called after the action
has been successfully completed or canceled. The URB also contains a
context-pointer for passing information to the completion handler.

\item {} 
Each endpoint for a device logically supports a queue of requests.
You can fill that queue, so that the USB hardware can still transfer
data to an endpoint while your driver handles completion of another.
This maximizes use of USB bandwidth, and supports seamless streaming
of data to (or from) devices when using periodic transfer modes.

\end{itemize}


\subsection{The URB structure}
\label{driver-api/usb/URB:the-urb-structure}
Some of the fields in struct {\hyperref[driver\string-api/usb/usb:c.urb]{\emph{\code{urb}}}} are:

\begin{Verbatim}[commandchars=\\\{\}]
struct urb
\PYGZob{}
// (IN) device and pipe specify the endpoint queue
      struct usb\PYGZus{}device *dev;         // pointer to associated USB device
      unsigned int pipe;              // endpoint information

      unsigned int transfer\PYGZus{}flags;    // URB\PYGZus{}ISO\PYGZus{}ASAP, URB\PYGZus{}SHORT\PYGZus{}NOT\PYGZus{}OK, etc.

// (IN) all urbs need completion routines
      void *context;                  // context for completion routine
      usb\PYGZus{}complete\PYGZus{}t complete;        // pointer to completion routine

// (OUT) status after each completion
      int status;                     // returned status

// (IN) buffer used for data transfers
      void *transfer\PYGZus{}buffer;          // associated data buffer
      u32 transfer\PYGZus{}buffer\PYGZus{}length;     // data buffer length
      int number\PYGZus{}of\PYGZus{}packets;          // size of iso\PYGZus{}frame\PYGZus{}desc

// (OUT) sometimes only part of CTRL/BULK/INTR transfer\PYGZus{}buffer is used
      u32 actual\PYGZus{}length;              // actual data buffer length

// (IN) setup stage for CTRL (pass a struct usb\PYGZus{}ctrlrequest)
      unsigned char *setup\PYGZus{}packet;    // setup packet (control only)

// Only for PERIODIC transfers (ISO, INTERRUPT)
  // (IN/OUT) start\PYGZus{}frame is set unless URB\PYGZus{}ISO\PYGZus{}ASAP isn\PYGZsq{}t set
      int start\PYGZus{}frame;                // start frame
      int interval;                   // polling interval

  // ISO only: packets are only \PYGZdq{}best effort\PYGZdq{}; each can have errors
      int error\PYGZus{}count;                // number of errors
      struct usb\PYGZus{}iso\PYGZus{}packet\PYGZus{}descriptor iso\PYGZus{}frame\PYGZus{}desc[0];
\PYGZcb{};
\end{Verbatim}

Your driver must create the ``pipe'' value using values from the appropriate
endpoint descriptor in an interface that it's claimed.


\subsection{How to get an URB?}
\label{driver-api/usb/URB:how-to-get-an-urb}
URBs are allocated by calling {\hyperref[driver\string-api/usb/usb:c.usb_alloc_urb]{\emph{\code{usb\_alloc\_urb()}}}}:

\begin{Verbatim}[commandchars=\\\{\}]
struct urb *usb\PYGZus{}alloc\PYGZus{}urb(int isoframes, int mem\PYGZus{}flags)
\end{Verbatim}

Return value is a pointer to the allocated URB, 0 if allocation failed.
The parameter isoframes specifies the number of isochronous transfer frames
you want to schedule. For CTRL/BULK/INT, use 0.  The mem\_flags parameter
holds standard memory allocation flags, letting you control (among other
things) whether the underlying code may block or not.

To free an URB, use {\hyperref[driver\string-api/usb/usb:c.usb_free_urb]{\emph{\code{usb\_free\_urb()}}}}:

\begin{Verbatim}[commandchars=\\\{\}]
void usb\PYGZus{}free\PYGZus{}urb(struct urb *urb)
\end{Verbatim}

You may free an urb that you've submitted, but which hasn't yet been
returned to you in a completion callback.  It will automatically be
deallocated when it is no longer in use.


\subsection{What has to be filled in?}
\label{driver-api/usb/URB:what-has-to-be-filled-in}
Depending on the type of transaction, there are some inline functions
defined in \code{linux/usb.h} to simplify the initialization, such as
{\hyperref[driver\string-api/usb/usb:c.usb_fill_control_urb]{\emph{\code{usb\_fill\_control\_urb()}}}}, {\hyperref[driver\string-api/usb/usb:c.usb_fill_bulk_urb]{\emph{\code{usb\_fill\_bulk\_urb()}}}} and
{\hyperref[driver\string-api/usb/usb:c.usb_fill_int_urb]{\emph{\code{usb\_fill\_int\_urb()}}}}.  In general, they need the usb device pointer,
the pipe (usual format from usb.h), the transfer buffer, the desired transfer
length, the completion handler, and its context. Take a look at the some
existing drivers to see how they're used.

Flags:
\begin{itemize}
\item {} 
For ISO there are two startup behaviors: Specified start\_frame or ASAP.

\item {} 
For ASAP set \code{URB\_ISO\_ASAP} in transfer\_flags.

\end{itemize}

If short packets should NOT be tolerated, set \code{URB\_SHORT\_NOT\_OK} in
transfer\_flags.


\subsection{How to submit an URB?}
\label{driver-api/usb/URB:how-to-submit-an-urb}
Just call {\hyperref[driver\string-api/usb/usb:c.usb_submit_urb]{\emph{\code{usb\_submit\_urb()}}}}:

\begin{Verbatim}[commandchars=\\\{\}]
int usb\PYGZus{}submit\PYGZus{}urb(struct urb *urb, int mem\PYGZus{}flags)
\end{Verbatim}

The \code{mem\_flags} parameter, such as \code{GFP\_ATOMIC}, controls memory
allocation, such as whether the lower levels may block when memory is tight.

It immediately returns, either with status 0 (request queued) or some
error code, usually caused by the following:
\begin{itemize}
\item {} 
Out of memory (\code{-ENOMEM})

\item {} 
Unplugged device (\code{-ENODEV})

\item {} 
Stalled endpoint (\code{-EPIPE})

\item {} 
Too many queued ISO transfers (\code{-EAGAIN})

\item {} 
Too many requested ISO frames (\code{-EFBIG})

\item {} 
Invalid INT interval (\code{-EINVAL})

\item {} 
More than one packet for INT (\code{-EINVAL})

\end{itemize}

After submission, \code{urb-\textgreater{}status} is \code{-EINPROGRESS}; however, you should
never look at that value except in your completion callback.

For isochronous endpoints, your completion handlers should (re)submit
URBs to the same endpoint with the \code{URB\_ISO\_ASAP} flag, using
multi-buffering, to get seamless ISO streaming.


\subsection{How to cancel an already running URB?}
\label{driver-api/usb/URB:how-to-cancel-an-already-running-urb}
There are two ways to cancel an URB you've submitted but which hasn't
been returned to your driver yet.  For an asynchronous cancel, call
{\hyperref[driver\string-api/usb/usb:c.usb_unlink_urb]{\emph{\code{usb\_unlink\_urb()}}}}:

\begin{Verbatim}[commandchars=\\\{\}]
int usb\PYGZus{}unlink\PYGZus{}urb(struct urb *urb)
\end{Verbatim}

It removes the urb from the internal list and frees all allocated
HW descriptors. The status is changed to reflect unlinking.  Note
that the URB will not normally have finished when {\hyperref[driver\string-api/usb/usb:c.usb_unlink_urb]{\emph{\code{usb\_unlink\_urb()}}}}
returns; you must still wait for the completion handler to be called.

To cancel an URB synchronously, call {\hyperref[driver\string-api/usb/usb:c.usb_kill_urb]{\emph{\code{usb\_kill\_urb()}}}}:

\begin{Verbatim}[commandchars=\\\{\}]
void usb\PYGZus{}kill\PYGZus{}urb(struct urb *urb)
\end{Verbatim}

It does everything {\hyperref[driver\string-api/usb/usb:c.usb_unlink_urb]{\emph{\code{usb\_unlink\_urb()}}}} does, and in addition it waits
until after the URB has been returned and the completion handler
has finished.  It also marks the URB as temporarily unusable, so
that if the completion handler or anyone else tries to resubmit it
they will get a \code{-EPERM} error.  Thus you can be sure that when
{\hyperref[driver\string-api/usb/usb:c.usb_kill_urb]{\emph{\code{usb\_kill\_urb()}}}} returns, the URB is totally idle.

There is a lifetime issue to consider.  An URB may complete at any
time, and the completion handler may free the URB.  If this happens
while {\hyperref[driver\string-api/usb/usb:c.usb_unlink_urb]{\emph{\code{usb\_unlink\_urb()}}}} or {\hyperref[driver\string-api/usb/usb:c.usb_kill_urb]{\emph{\code{usb\_kill\_urb()}}}} is running, it will
cause a memory-access violation.  The driver is responsible for avoiding this,
which often means some sort of lock will be needed to prevent the URB
from being deallocated while it is still in use.

On the other hand, since usb\_unlink\_urb may end up calling the
completion handler, the handler must not take any lock that is held
when usb\_unlink\_urb is invoked.  The general solution to this problem
is to increment the URB's reference count while holding the lock, then
drop the lock and call usb\_unlink\_urb or usb\_kill\_urb, and then
decrement the URB's reference count.  You increment the reference
count by calling :c:func{}`usb\_get\_urb{}`:

\begin{Verbatim}[commandchars=\\\{\}]
struct urb *usb\PYGZus{}get\PYGZus{}urb(struct urb *urb)
\end{Verbatim}

(ignore the return value; it is the same as the argument) and
decrement the reference count by calling {\hyperref[driver\string-api/usb/usb:c.usb_free_urb]{\emph{\code{usb\_free\_urb()}}}}.  Of course,
none of this is necessary if there's no danger of the URB being freed
by the completion handler.


\subsection{What about the completion handler?}
\label{driver-api/usb/URB:what-about-the-completion-handler}
The handler is of the following type:

\begin{Verbatim}[commandchars=\\\{\}]
typedef void (*usb\PYGZus{}complete\PYGZus{}t)(struct urb *)
\end{Verbatim}

I.e., it gets the URB that caused the completion call. In the completion
handler, you should have a look at \code{urb-\textgreater{}status} to detect any USB errors.
Since the context parameter is included in the URB, you can pass
information to the completion handler.

Note that even when an error (or unlink) is reported, data may have been
transferred.  That's because USB transfers are packetized; it might take
sixteen packets to transfer your 1KByte buffer, and ten of them might
have transferred successfully before the completion was called.

\begin{notice}{warning}{Warning:}
NEVER SLEEP IN A COMPLETION HANDLER.

These are often called in atomic context.
\end{notice}

In the current kernel, completion handlers run with local interrupts
disabled, but in the future this will be changed, so don't assume that
local IRQs are always disabled inside completion handlers.


\subsection{How to do isochronous (ISO) transfers?}
\label{driver-api/usb/URB:how-to-do-isochronous-iso-transfers}
Besides the fields present on a bulk transfer, for ISO, you also
also have to set \code{urb-\textgreater{}interval} to say how often to make transfers; it's
often one per frame (which is once every microframe for highspeed devices).
The actual interval used will be a power of two that's no bigger than what
you specify. You can use the {\hyperref[driver\string-api/usb/usb:c.usb_fill_int_urb]{\emph{\code{usb\_fill\_int\_urb()}}}} macro to fill
most ISO transfer fields.

For ISO transfers you also have to fill a \code{usb\_iso\_packet\_descriptor}
structure, allocated at the end of the URB by {\hyperref[driver\string-api/usb/usb:c.usb_alloc_urb]{\emph{\code{usb\_alloc\_urb()}}}}, for
each packet you want to schedule.

The {\hyperref[driver\string-api/usb/usb:c.usb_submit_urb]{\emph{\code{usb\_submit\_urb()}}}} call modifies \code{urb-\textgreater{}interval} to the implemented
interval value that is less than or equal to the requested interval value.  If
\code{URB\_ISO\_ASAP} scheduling is used, \code{urb-\textgreater{}start\_frame} is also updated.

For each entry you have to specify the data offset for this frame (base is
transfer\_buffer), and the length you want to write/expect to read.
After completion, actual\_length contains the actual transferred length and
status contains the resulting status for the ISO transfer for this frame.
It is allowed to specify a varying length from frame to frame (e.g. for
audio synchronisation/adaptive transfer rates). You can also use the length
0 to omit one or more frames (striping).

For scheduling you can choose your own start frame or \code{URB\_ISO\_ASAP}. As
explained earlier, if you always keep at least one URB queued and your
completion keeps (re)submitting a later URB, you'll get smooth ISO streaming
(if usb bandwidth utilization allows).

If you specify your own start frame, make sure it's several frames in advance
of the current frame.  You might want this model if you're synchronizing
ISO data with some other event stream.


\subsection{How to start interrupt (INT) transfers?}
\label{driver-api/usb/URB:how-to-start-interrupt-int-transfers}
Interrupt transfers, like isochronous transfers, are periodic, and happen
in intervals that are powers of two (1, 2, 4 etc) units.  Units are frames
for full and low speed devices, and microframes for high speed ones.
You can use the {\hyperref[driver\string-api/usb/usb:c.usb_fill_int_urb]{\emph{\code{usb\_fill\_int\_urb()}}}} macro to fill INT transfer fields.

The {\hyperref[driver\string-api/usb/usb:c.usb_submit_urb]{\emph{\code{usb\_submit\_urb()}}}} call modifies \code{urb-\textgreater{}interval} to the implemented
interval value that is less than or equal to the requested interval value.

In Linux 2.6, unlike earlier versions, interrupt URBs are not automagically
restarted when they complete.  They end when the completion handler is
called, just like other URBs.  If you want an interrupt URB to be restarted,
your completion handler must resubmit it.
s


\section{Power Management for USB}
\label{driver-api/usb/power-management:usb-power-management}\label{driver-api/usb/power-management::doc}\label{driver-api/usb/power-management:power-management-for-usb}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Alan Stern \textless{}\href{mailto:stern@rowland.harvard.edu}{stern@rowland.harvard.edu}\textgreater{}

\item[{Date}] \leavevmode
Last-updated: February 2014

\end{description}\end{quote}


\subsection{What is Power Management?}
\label{driver-api/usb/power-management:what-is-power-management}
Power Management (PM) is the practice of saving energy by suspending
parts of a computer system when they aren't being used.  While a
component is \code{suspended} it is in a nonfunctional low-power state; it
might even be turned off completely.  A suspended component can be
\code{resumed} (returned to a functional full-power state) when the kernel
needs to use it.  (There also are forms of PM in which components are
placed in a less functional but still usable state instead of being
suspended; an example would be reducing the CPU's clock rate.  This
document will not discuss those other forms.)

When the parts being suspended include the CPU and most of the rest of
the system, we speak of it as a ``system suspend''.  When a particular
device is turned off while the system as a whole remains running, we
call it a ``dynamic suspend'' (also known as a ``runtime suspend'' or
``selective suspend'').  This document concentrates mostly on how
dynamic PM is implemented in the USB subsystem, although system PM is
covered to some extent (see \code{Documentation/power/*.txt} for more
information about system PM).

System PM support is present only if the kernel was built with
\code{CONFIG\_SUSPEND} or \code{CONFIG\_HIBERNATION} enabled.  Dynamic PM support

for USB is present whenever
the kernel was built with \code{CONFIG\_PM} enabled.

{[}Historically, dynamic PM support for USB was present only if the
kernel had been built with \code{CONFIG\_USB\_SUSPEND} enabled (which depended on
\code{CONFIG\_PM\_RUNTIME}).  Starting with the 3.10 kernel release, dynamic PM
support for USB was present whenever the kernel was built with
\code{CONFIG\_PM\_RUNTIME} enabled.  The \code{CONFIG\_USB\_SUSPEND} option had been
eliminated.{]}


\subsection{What is Remote Wakeup?}
\label{driver-api/usb/power-management:what-is-remote-wakeup}
When a device has been suspended, it generally doesn't resume until
the computer tells it to.  Likewise, if the entire computer has been
suspended, it generally doesn't resume until the user tells it to, say
by pressing a power button or opening the cover.

However some devices have the capability of resuming by themselves, or
asking the kernel to resume them, or even telling the entire computer
to resume.  This capability goes by several names such as ``Wake On
LAN''; we will refer to it generically as ``remote wakeup''.  When a
device is enabled for remote wakeup and it is suspended, it may resume
itself (or send a request to be resumed) in response to some external
event.  Examples include a suspended keyboard resuming when a key is
pressed, or a suspended USB hub resuming when a device is plugged in.


\subsection{When is a USB device idle?}
\label{driver-api/usb/power-management:when-is-a-usb-device-idle}
A device is idle whenever the kernel thinks it's not busy doing
anything important and thus is a candidate for being suspended.  The
exact definition depends on the device's driver; drivers are allowed
to declare that a device isn't idle even when there's no actual
communication taking place.  (For example, a hub isn't considered idle
unless all the devices plugged into that hub are already suspended.)
In addition, a device isn't considered idle so long as a program keeps
its usbfs file open, whether or not any I/O is going on.

If a USB device has no driver, its usbfs file isn't open, and it isn't
being accessed through sysfs, then it definitely is idle.


\subsection{Forms of dynamic PM}
\label{driver-api/usb/power-management:forms-of-dynamic-pm}
Dynamic suspends occur when the kernel decides to suspend an idle
device.  This is called \code{autosuspend} for short.  In general, a device
won't be autosuspended unless it has been idle for some minimum period
of time, the so-called idle-delay time.

Of course, nothing the kernel does on its own initiative should
prevent the computer or its devices from working properly.  If a
device has been autosuspended and a program tries to use it, the
kernel will automatically resume the device (autoresume).  For the
same reason, an autosuspended device will usually have remote wakeup
enabled, if the device supports remote wakeup.

It is worth mentioning that many USB drivers don't support
autosuspend.  In fact, at the time of this writing (Linux 2.6.23) the
only drivers which do support it are the hub driver, kaweth, asix,
usblp, usblcd, and usb-skeleton (which doesn't count).  If a
non-supporting driver is bound to a device, the device won't be
autosuspended.  In effect, the kernel pretends the device is never
idle.

We can categorize power management events in two broad classes:
external and internal.  External events are those triggered by some
agent outside the USB stack: system suspend/resume (triggered by
userspace), manual dynamic resume (also triggered by userspace), and
remote wakeup (triggered by the device).  Internal events are those
triggered within the USB stack: autosuspend and autoresume.  Note that
all dynamic suspend events are internal; external agents are not
allowed to issue dynamic suspends.


\subsection{The user interface for dynamic PM}
\label{driver-api/usb/power-management:the-user-interface-for-dynamic-pm}
The user interface for controlling dynamic PM is located in the \code{power/}
subdirectory of each USB device's sysfs directory, that is, in
\code{/sys/bus/usb/devices/.../power/} where ''...'' is the device's ID.  The
relevant attribute files are: wakeup, control, and
\code{autosuspend\_delay\_ms}.  (There may also be a file named \code{level}; this
file was deprecated as of the 2.6.35 kernel and replaced by the
\code{control} file.  In 2.6.38 the \code{autosuspend} file will be deprecated
and replaced by the \code{autosuspend\_delay\_ms} file.  The only difference
is that the newer file expresses the delay in milliseconds whereas the
older file uses seconds.  Confusingly, both files are present in 2.6.37
but only \code{autosuspend} works.)
\begin{quote}

\code{power/wakeup}
\begin{quote}

This file is empty if the device does not support
remote wakeup.  Otherwise the file contains either the
word \code{enabled} or the word \code{disabled}, and you can
write those words to the file.  The setting determines
whether or not remote wakeup will be enabled when the
device is next suspended.  (If the setting is changed
while the device is suspended, the change won't take
effect until the following suspend.)
\end{quote}

\code{power/control}
\begin{quote}

This file contains one of two words: \code{on} or \code{auto}.
You can write those words to the file to change the
device's setting.
\begin{itemize}
\item {} 
\code{on} means that the device should be resumed and
autosuspend is not allowed.  (Of course, system
suspends are still allowed.)

\item {} 
\code{auto} is the normal state in which the kernel is
allowed to autosuspend and autoresume the device.

\end{itemize}

(In kernels up to 2.6.32, you could also specify
\code{suspend}, meaning that the device should remain
suspended and autoresume was not allowed.  This
setting is no longer supported.)
\end{quote}

\code{power/autosuspend\_delay\_ms}
\begin{quote}

This file contains an integer value, which is the
number of milliseconds the device should remain idle
before the kernel will autosuspend it (the idle-delay
time).  The default is 2000.  0 means to autosuspend
as soon as the device becomes idle, and negative
values mean never to autosuspend.  You can write a
number to the file to change the autosuspend
idle-delay time.
\end{quote}
\end{quote}

Writing \code{-1} to \code{power/autosuspend\_delay\_ms} and writing \code{on} to
\code{power/control} do essentially the same thing -- they both prevent the
device from being autosuspended.  Yes, this is a redundancy in the
API.

(In 2.6.21 writing \code{0} to \code{power/autosuspend} would prevent the device
from being autosuspended; the behavior was changed in 2.6.22.  The
\code{power/autosuspend} attribute did not exist prior to 2.6.21, and the
\code{power/level} attribute did not exist prior to 2.6.22.  \code{power/control}
was added in 2.6.34, and \code{power/autosuspend\_delay\_ms} was added in
2.6.37 but did not become functional until 2.6.38.)


\subsection{Changing the default idle-delay time}
\label{driver-api/usb/power-management:changing-the-default-idle-delay-time}
The default autosuspend idle-delay time (in seconds) is controlled by
a module parameter in usbcore.  You can specify the value when usbcore
is loaded.  For example, to set it to 5 seconds instead of 2 you would
do:

\begin{Verbatim}[commandchars=\\\{\}]
modprobe usbcore autosuspend=5
\end{Verbatim}

Equivalently, you could add to a configuration file in /etc/modprobe.d
a line saying:

\begin{Verbatim}[commandchars=\\\{\}]
options usbcore autosuspend=5
\end{Verbatim}

Some distributions load the usbcore module very early during the boot
process, by means of a program or script running from an initramfs
image.  To alter the parameter value you would have to rebuild that
image.

If usbcore is compiled into the kernel rather than built as a loadable
module, you can add:

\begin{Verbatim}[commandchars=\\\{\}]
usbcore.autosuspend=5
\end{Verbatim}

to the kernel's boot command line.

Finally, the parameter value can be changed while the system is
running.  If you do:

\begin{Verbatim}[commandchars=\\\{\}]
echo 5 \PYGZgt{}/sys/module/usbcore/parameters/autosuspend
\end{Verbatim}

then each new USB device will have its autosuspend idle-delay
initialized to 5.  (The idle-delay values for already existing devices
will not be affected.)

Setting the initial default idle-delay to -1 will prevent any
autosuspend of any USB device.  This has the benefit of allowing you
then to enable autosuspend for selected devices.


\subsection{Warnings}
\label{driver-api/usb/power-management:warnings}
The USB specification states that all USB devices must support power
management.  Nevertheless, the sad fact is that many devices do not
support it very well.  You can suspend them all right, but when you
try to resume them they disconnect themselves from the USB bus or
they stop working entirely.  This seems to be especially prevalent
among printers and scanners, but plenty of other types of device have
the same deficiency.

For this reason, by default the kernel disables autosuspend (the
\code{power/control} attribute is initialized to \code{on}) for all devices other
than hubs.  Hubs, at least, appear to be reasonably well-behaved in
this regard.

(In 2.6.21 and 2.6.22 this wasn't the case.  Autosuspend was enabled
by default for almost all USB devices.  A number of people experienced
problems as a result.)

This means that non-hub devices won't be autosuspended unless the user
or a program explicitly enables it.  As of this writing there aren't
any widespread programs which will do this; we hope that in the near
future device managers such as HAL will take on this added
responsibility.  In the meantime you can always carry out the
necessary operations by hand or add them to a udev script.  You can
also change the idle-delay time; 2 seconds is not the best choice for
every device.

If a driver knows that its device has proper suspend/resume support,
it can enable autosuspend all by itself.  For example, the video
driver for a laptop's webcam might do this (in recent kernels they
do), since these devices are rarely used and so should normally be
autosuspended.

Sometimes it turns out that even when a device does work okay with
autosuspend there are still problems.  For example, the usbhid driver,
which manages keyboards and mice, has autosuspend support.  Tests with
a number of keyboards show that typing on a suspended keyboard, while
causing the keyboard to do a remote wakeup all right, will nonetheless
frequently result in lost keystrokes.  Tests with mice show that some
of them will issue a remote-wakeup request in response to button
presses but not to motion, and some in response to neither.

The kernel will not prevent you from enabling autosuspend on devices
that can't handle it.  It is even possible in theory to damage a
device by suspending it at the wrong time.  (Highly unlikely, but
possible.)  Take care.


\subsection{The driver interface for Power Management}
\label{driver-api/usb/power-management:the-driver-interface-for-power-management}
The requirements for a USB driver to support external power management
are pretty modest; the driver need only define:

\begin{Verbatim}[commandchars=\\\{\}]
.suspend
.resume
.reset\PYGZus{}resume
\end{Verbatim}

methods in its {\hyperref[driver\string-api/usb/usb:c.usb_driver]{\emph{\code{usb\_driver}}}} structure, and the \code{reset\_resume} method
is optional.  The methods' jobs are quite simple:
\begin{itemize}
\item {} 
The \code{suspend} method is called to warn the driver that the
device is going to be suspended.  If the driver returns a
negative error code, the suspend will be aborted.  Normally
the driver will return 0, in which case it must cancel all
outstanding URBs ({\hyperref[driver\string-api/usb/usb:c.usb_kill_urb]{\emph{\code{usb\_kill\_urb()}}}}) and not submit any more.

\item {} 
The \code{resume} method is called to tell the driver that the
device has been resumed and the driver can return to normal
operation.  URBs may once more be submitted.

\item {} 
The \code{reset\_resume} method is called to tell the driver that
the device has been resumed and it also has been reset.
The driver should redo any necessary device initialization,
since the device has probably lost most or all of its state
(although the interfaces will be in the same altsettings as
before the suspend).

\end{itemize}

If the device is disconnected or powered down while it is suspended,
the \code{disconnect} method will be called instead of the \code{resume} or
\code{reset\_resume} method.  This is also quite likely to happen when
waking up from hibernation, as many systems do not maintain suspend
current to the USB host controllers during hibernation.  (It's
possible to work around the hibernation-forces-disconnect problem by
using the USB Persist facility.)

The \code{reset\_resume} method is used by the USB Persist facility (see
{\hyperref[driver\string-api/usb/persist:usb\string-persist]{\emph{USB device persistence during system suspend}}}) and it can also be used under certain
circumstances when \code{CONFIG\_USB\_PERSIST} is not enabled.  Currently, if a
device is reset during a resume and the driver does not have a
\code{reset\_resume} method, the driver won't receive any notification about
the resume.  Later kernels will call the driver's \code{disconnect} method;
2.6.23 doesn't do this.

USB drivers are bound to interfaces, so their \code{suspend} and \code{resume}
methods get called when the interfaces are suspended or resumed.  In
principle one might want to suspend some interfaces on a device (i.e.,
force the drivers for those interface to stop all activity) without
suspending the other interfaces.  The USB core doesn't allow this; all
interfaces are suspended when the device itself is suspended and all
interfaces are resumed when the device is resumed.  It isn't possible
to suspend or resume some but not all of a device's interfaces.  The
closest you can come is to unbind the interfaces' drivers.


\subsection{The driver interface for autosuspend and autoresume}
\label{driver-api/usb/power-management:the-driver-interface-for-autosuspend-and-autoresume}
To support autosuspend and autoresume, a driver should implement all
three of the methods listed above.  In addition, a driver indicates
that it supports autosuspend by setting the \code{.supports\_autosuspend} flag
in its usb\_driver structure.  It is then responsible for informing the
USB core whenever one of its interfaces becomes busy or idle.  The
driver does so by calling these six functions:

\begin{Verbatim}[commandchars=\\\{\}]
int  usb\PYGZus{}autopm\PYGZus{}get\PYGZus{}interface(struct usb\PYGZus{}interface *intf);
void usb\PYGZus{}autopm\PYGZus{}put\PYGZus{}interface(struct usb\PYGZus{}interface *intf);
int  usb\PYGZus{}autopm\PYGZus{}get\PYGZus{}interface\PYGZus{}async(struct usb\PYGZus{}interface *intf);
void usb\PYGZus{}autopm\PYGZus{}put\PYGZus{}interface\PYGZus{}async(struct usb\PYGZus{}interface *intf);
void usb\PYGZus{}autopm\PYGZus{}get\PYGZus{}interface\PYGZus{}no\PYGZus{}resume(struct usb\PYGZus{}interface *intf);
void usb\PYGZus{}autopm\PYGZus{}put\PYGZus{}interface\PYGZus{}no\PYGZus{}suspend(struct usb\PYGZus{}interface *intf);
\end{Verbatim}

The functions work by maintaining a usage counter in the
usb\_interface's embedded device structure.  When the counter is \textgreater{} 0
then the interface is deemed to be busy, and the kernel will not
autosuspend the interface's device.  When the usage counter is = 0
then the interface is considered to be idle, and the kernel may
autosuspend the device.

Drivers need not be concerned about balancing changes to the usage
counter; the USB core will undo any remaining ``get''s when a driver
is unbound from its interface.  As a corollary, drivers must not call
any of the \code{usb\_autopm\_*} functions after their \code{disconnect}
routine has returned.

Drivers using the async routines are responsible for their own
synchronization and mutual exclusion.
\begin{quote}

{\hyperref[driver\string-api/usb/usb:c.usb_autopm_get_interface]{\emph{\code{usb\_autopm\_get\_interface()}}}} increments the usage counter and
does an autoresume if the device is suspended.  If the
autoresume fails, the counter is decremented back.

{\hyperref[driver\string-api/usb/usb:c.usb_autopm_put_interface]{\emph{\code{usb\_autopm\_put\_interface()}}}} decrements the usage counter and
attempts an autosuspend if the new value is = 0.

{\hyperref[driver\string-api/usb/usb:c.usb_autopm_get_interface_async]{\emph{\code{usb\_autopm\_get\_interface\_async()}}}} and
{\hyperref[driver\string-api/usb/usb:c.usb_autopm_put_interface_async]{\emph{\code{usb\_autopm\_put\_interface\_async()}}}} do almost the same things as
their non-async counterparts.  The big difference is that they
use a workqueue to do the resume or suspend part of their
jobs.  As a result they can be called in an atomic context,
such as an URB's completion handler, but when they return the
device will generally not yet be in the desired state.

{\hyperref[driver\string-api/usb/usb:c.usb_autopm_get_interface_no_resume]{\emph{\code{usb\_autopm\_get\_interface\_no\_resume()}}}} and
{\hyperref[driver\string-api/usb/usb:c.usb_autopm_put_interface_no_suspend]{\emph{\code{usb\_autopm\_put\_interface\_no\_suspend()}}}} merely increment or
decrement the usage counter; they do not attempt to carry out
an autoresume or an autosuspend.  Hence they can be called in
an atomic context.
\end{quote}

The simplest usage pattern is that a driver calls
{\hyperref[driver\string-api/usb/usb:c.usb_autopm_get_interface]{\emph{\code{usb\_autopm\_get\_interface()}}}} in its open routine and
{\hyperref[driver\string-api/usb/usb:c.usb_autopm_put_interface]{\emph{\code{usb\_autopm\_put\_interface()}}}} in its close or release routine.  But other
patterns are possible.

The autosuspend attempts mentioned above will often fail for one
reason or another.  For example, the \code{power/control} attribute might be
set to \code{on}, or another interface in the same device might not be
idle.  This is perfectly normal.  If the reason for failure was that
the device hasn't been idle for long enough, a timer is scheduled to
carry out the operation automatically when the autosuspend idle-delay
has expired.

Autoresume attempts also can fail, although failure would mean that
the device is no longer present or operating properly.  Unlike
autosuspend, there's no idle-delay for an autoresume.


\subsection{Other parts of the driver interface}
\label{driver-api/usb/power-management:other-parts-of-the-driver-interface}
Drivers can enable autosuspend for their devices by calling:

\begin{Verbatim}[commandchars=\\\{\}]
usb\PYGZus{}enable\PYGZus{}autosuspend(struct usb\PYGZus{}device *udev);
\end{Verbatim}

in their \code{probe()} routine, if they know that the device is capable of
suspending and resuming correctly.  This is exactly equivalent to
writing \code{auto} to the device's \code{power/control} attribute.  Likewise,
drivers can disable autosuspend by calling:

\begin{Verbatim}[commandchars=\\\{\}]
usb\PYGZus{}disable\PYGZus{}autosuspend(struct usb\PYGZus{}device *udev);
\end{Verbatim}

This is exactly the same as writing \code{on} to the \code{power/control} attribute.

Sometimes a driver needs to make sure that remote wakeup is enabled
during autosuspend.  For example, there's not much point
autosuspending a keyboard if the user can't cause the keyboard to do a
remote wakeup by typing on it.  If the driver sets
\code{intf-\textgreater{}needs\_remote\_wakeup} to 1, the kernel won't autosuspend the
device if remote wakeup isn't available.  (If the device is already
autosuspended, though, setting this flag won't cause the kernel to
autoresume it.  Normally a driver would set this flag in its \code{probe}
method, at which time the device is guaranteed not to be
autosuspended.)

If a driver does its I/O asynchronously in interrupt context, it
should call {\hyperref[driver\string-api/usb/usb:c.usb_autopm_get_interface_async]{\emph{\code{usb\_autopm\_get\_interface\_async()}}}} before starting output and
{\hyperref[driver\string-api/usb/usb:c.usb_autopm_put_interface_async]{\emph{\code{usb\_autopm\_put\_interface\_async()}}}} when the output queue drains.  When
it receives an input event, it should call:

\begin{Verbatim}[commandchars=\\\{\}]
usb\PYGZus{}mark\PYGZus{}last\PYGZus{}busy(struct usb\PYGZus{}device *udev);
\end{Verbatim}

in the event handler.  This tells the PM core that the device was just
busy and therefore the next autosuspend idle-delay expiration should
be pushed back.  Many of the usb\_autopm\_* routines also make this call,
so drivers need to worry only when interrupt-driven input arrives.

Asynchronous operation is always subject to races.  For example, a
driver may call the {\hyperref[driver\string-api/usb/usb:c.usb_autopm_get_interface_async]{\emph{\code{usb\_autopm\_get\_interface\_async()}}}} routine at a time
when the core has just finished deciding the device has been idle for
long enough but not yet gotten around to calling the driver's \code{suspend}
method.  The \code{suspend} method must be responsible for synchronizing with
the I/O request routine and the URB completion handler; it should
cause autosuspends to fail with -EBUSY if the driver needs to use the
device.

External suspend calls should never be allowed to fail in this way,
only autosuspend calls.  The driver can tell them apart by applying
the \code{PMSG\_IS\_AUTO()} macro to the message argument to the \code{suspend}
method; it will return True for internal PM events (autosuspend) and
False for external PM events.


\subsection{Mutual exclusion}
\label{driver-api/usb/power-management:mutual-exclusion}
For external events -- but not necessarily for autosuspend or
autoresume -- the device semaphore (udev-\textgreater{}dev.sem) will be held when a
\code{suspend} or \code{resume} method is called.  This implies that external
suspend/resume events are mutually exclusive with calls to \code{probe},
\code{disconnect}, \code{pre\_reset}, and \code{post\_reset}; the USB core guarantees that
this is true of autosuspend/autoresume events as well.

If a driver wants to block all suspend/resume calls during some
critical section, the best way is to lock the device and call
{\hyperref[driver\string-api/usb/usb:c.usb_autopm_get_interface]{\emph{\code{usb\_autopm\_get\_interface()}}}} (and do the reverse at the end of the
critical section).  Holding the device semaphore will block all
external PM calls, and the {\hyperref[driver\string-api/usb/usb:c.usb_autopm_get_interface]{\emph{\code{usb\_autopm\_get\_interface()}}}} will prevent any
internal PM calls, even if it fails.  (Exercise: Why?)


\subsection{Interaction between dynamic PM and system PM}
\label{driver-api/usb/power-management:interaction-between-dynamic-pm-and-system-pm}
Dynamic power management and system power management can interact in
a couple of ways.

Firstly, a device may already be autosuspended when a system suspend
occurs.  Since system suspends are supposed to be as transparent as
possible, the device should remain suspended following the system
resume.  But this theory may not work out well in practice; over time
the kernel's behavior in this regard has changed.  As of 2.6.37 the
policy is to resume all devices during a system resume and let them
handle their own runtime suspends afterward.

Secondly, a dynamic power-management event may occur as a system
suspend is underway.  The window for this is short, since system
suspends don't take long (a few seconds usually), but it can happen.
For example, a suspended device may send a remote-wakeup signal while
the system is suspending.  The remote wakeup may succeed, which would
cause the system suspend to abort.  If the remote wakeup doesn't
succeed, it may still remain active and thus cause the system to
resume as soon as the system suspend is complete.  Or the remote
wakeup may fail and get lost.  Which outcome occurs depends on timing
and on the hardware and firmware design.


\subsection{xHCI hardware link PM}
\label{driver-api/usb/power-management:xhci-hardware-link-pm}
xHCI host controller provides hardware link power management to usb2.0
(xHCI 1.0 feature) and usb3.0 devices which support link PM. By
enabling hardware LPM, the host can automatically put the device into
lower power state(L1 for usb2.0 devices, or U1/U2 for usb3.0 devices),
which state device can enter and resume very quickly.

The user interface for controlling hardware LPM is located in the
\code{power/} subdirectory of each USB device's sysfs directory, that is, in
\code{/sys/bus/usb/devices/.../power/} where ''...'' is the device's ID. The
relevant attribute files are \code{usb2\_hardware\_lpm} and \code{usb3\_hardware\_lpm}.
\begin{quote}

\code{power/usb2\_hardware\_lpm}
\begin{quote}

When a USB2 device which support LPM is plugged to a
xHCI host root hub which support software LPM, the
host will run a software LPM test for it; if the device
enters L1 state and resume successfully and the host
supports USB2 hardware LPM, this file will show up and
driver will enable hardware LPM for the device. You
can write y/Y/1 or n/N/0 to the file to enable/disable
USB2 hardware LPM manually. This is for test purpose mainly.
\end{quote}

\code{power/usb3\_hardware\_lpm\_u1}
\code{power/usb3\_hardware\_lpm\_u2}
\begin{quote}

When a USB 3.0 lpm-capable device is plugged in to a
xHCI host which supports link PM, it will check if U1
and U2 exit latencies have been set in the BOS
descriptor; if the check is passed and the host
supports USB3 hardware LPM, USB3 hardware LPM will be
enabled for the device and these files will be created.
The files hold a string value (enable or disable)
indicating whether or not USB3 hardware LPM U1 or U2
is enabled for the device.
\end{quote}
\end{quote}


\subsection{USB Port Power Control}
\label{driver-api/usb/power-management:usb-port-power-control}
In addition to suspending endpoint devices and enabling hardware
controlled link power management, the USB subsystem also has the
capability to disable power to ports under some conditions.  Power is
controlled through \code{Set/ClearPortFeature(PORT\_POWER)} requests to a hub.
In the case of a root or platform-internal hub the host controller
driver translates \code{PORT\_POWER} requests into platform firmware (ACPI)
method calls to set the port power state. For more background see the
Linux Plumbers Conference 2012 slides \footnote[1]{
\href{http://dl.dropbox.com/u/96820575/sarah-sharp-lpt-port-power-off2-mini.pdf}{http://dl.dropbox.com/u/96820575/sarah-sharp-lpt-port-power-off2-mini.pdf}
} and video \footnote[2]{
\href{http://linuxplumbers.ubicast.tv/videos/usb-port-power-off-kerneluserspace-api/}{http://linuxplumbers.ubicast.tv/videos/usb-port-power-off-kerneluserspace-api/}
}:

Upon receiving a \code{ClearPortFeature(PORT\_POWER)} request a USB port is
logically off, and may trigger the actual loss of VBUS to the port \footnote[3]{
USB 3.1 Section 10.12

wakeup note: if a device is configured to send wakeup events the port
power control implementation will block poweroff attempts on that
port.
}.
VBUS may be maintained in the case where a hub gangs multiple ports into
a shared power well causing power to remain until all ports in the gang
are turned off.  VBUS may also be maintained by hub ports configured for
a charging application.  In any event a logically off port will lose
connection with its device, not respond to hotplug events, and not
respond to remote wakeup events.

\begin{notice}{warning}{Warning:}
turning off a port may result in the inability to hot add a device.
Please see ``User Interface for Port Power Control'' for details.
\end{notice}

As far as the effect on the device itself it is similar to what a device
goes through during system suspend, i.e. the power session is lost.  Any
USB device or driver that misbehaves with system suspend will be
similarly affected by a port power cycle event.  For this reason the
implementation shares the same device recovery path (and honors the same
quirks) as the system resume path for the hub.


\subsection{User Interface for Port Power Control}
\label{driver-api/usb/power-management:user-interface-for-port-power-control}
The port power control mechanism uses the PM runtime system.  Poweroff is
requested by clearing the \code{power/pm\_qos\_no\_power\_off} flag of the port device
(defaults to 1).  If the port is disconnected it will immediately receive a
\code{ClearPortFeature(PORT\_POWER)} request.  Otherwise, it will honor the pm
runtime rules and require the attached child device and all descendants to be
suspended. This mechanism is dependent on the hub advertising port power
switching in its hub descriptor (wHubCharacteristics logical power switching
mode field).

Note, some interface devices/drivers do not support autosuspend.  Userspace may
need to unbind the interface drivers before the {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{\code{usb\_device}}}} will
suspend.  An unbound interface device is suspended by default.  When unbinding,
be careful to unbind interface drivers, not the driver of the parent usb
device.  Also, leave hub interface drivers bound.  If the driver for the usb
device (not interface) is unbound the kernel is no longer able to resume the
device.  If a hub interface driver is unbound, control of its child ports is
lost and all attached child-devices will disconnect.  A good rule of thumb is
that if the `driver/module' link for a device points to
\code{/sys/module/usbcore} then unbinding it will interfere with port power
control.

Example of the relevant files for port power control.  Note, in this example
these files are relative to a usb hub device (prefix):

\begin{Verbatim}[commandchars=\\\{\}]
prefix=/sys/devices/pci0000:00/0000:00:14.0/usb3/3\PYGZhy{}1

                 attached child device +
             hub port device +         \textbar{}
hub interface device +       \textbar{}         \textbar{}
                     v       v         v
             \PYGZdl{}prefix/3\PYGZhy{}1:1.0/3\PYGZhy{}1\PYGZhy{}port1/device

\PYGZdl{}prefix/3\PYGZhy{}1:1.0/3\PYGZhy{}1\PYGZhy{}port1/power/pm\PYGZus{}qos\PYGZus{}no\PYGZus{}power\PYGZus{}off
\PYGZdl{}prefix/3\PYGZhy{}1:1.0/3\PYGZhy{}1\PYGZhy{}port1/device/power/control
\PYGZdl{}prefix/3\PYGZhy{}1:1.0/3\PYGZhy{}1\PYGZhy{}port1/device/3\PYGZhy{}1.1:\PYGZlt{}intf0\PYGZgt{}/driver/unbind
\PYGZdl{}prefix/3\PYGZhy{}1:1.0/3\PYGZhy{}1\PYGZhy{}port1/device/3\PYGZhy{}1.1:\PYGZlt{}intf1\PYGZgt{}/driver/unbind
...
\PYGZdl{}prefix/3\PYGZhy{}1:1.0/3\PYGZhy{}1\PYGZhy{}port1/device/3\PYGZhy{}1.1:\PYGZlt{}intfN\PYGZgt{}/driver/unbind
\end{Verbatim}

In addition to these files some ports may have a `peer' link to a port on
another hub.  The expectation is that all superspeed ports have a
hi-speed peer:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}prefix/3\PYGZhy{}1:1.0/3\PYGZhy{}1\PYGZhy{}port1/peer \PYGZhy{}\PYGZgt{} ../../../../usb2/2\PYGZhy{}1/2\PYGZhy{}1:1.0/2\PYGZhy{}1\PYGZhy{}port1
../../../../usb2/2\PYGZhy{}1/2\PYGZhy{}1:1.0/2\PYGZhy{}1\PYGZhy{}port1/peer \PYGZhy{}\PYGZgt{} ../../../../usb3/3\PYGZhy{}1/3\PYGZhy{}1:1.0/3\PYGZhy{}1\PYGZhy{}port1
\end{Verbatim}

Distinct from `companion ports', or `ehci/xhci shared switchover ports'
peer ports are simply the hi-speed and superspeed interface pins that
are combined into a single usb3 connector.  Peer ports share the same
ancestor XHCI device.

While a superspeed port is powered off a device may downgrade its
connection and attempt to connect to the hi-speed pins.  The
implementation takes steps to prevent this:
\begin{enumerate}
\item {} 
Port suspend is sequenced to guarantee that hi-speed ports are powered-off
before their superspeed peer is permitted to power-off.  The implication is
that the setting \code{pm\_qos\_no\_power\_off} to zero on a superspeed port may
not cause the port to power-off until its highspeed peer has gone to its
runtime suspend state.  Userspace must take care to order the suspensions
if it wants to guarantee that a superspeed port will power-off.

\item {} 
Port resume is sequenced to force a superspeed port to power-on prior to its
highspeed peer.

\item {} 
Port resume always triggers an attached child device to resume.  After a
power session is lost the device may have been removed, or need reset.
Resuming the child device when the parent port regains power resolves those
states and clamps the maximum port power cycle frequency at the rate the
child device can suspend (autosuspend-delay) and resume (reset-resume
latency).

\end{enumerate}

Sysfs files relevant for port power control:
\begin{quote}
\begin{description}
\item[{\code{\textless{}hubdev-portX\textgreater{}/power/pm\_qos\_no\_power\_off}:}] \leavevmode
This writable flag controls the state of an idle port.
Once all children and descendants have suspended the
port may suspend/poweroff provided that
pm\_qos\_no\_power\_off is `0'.  If pm\_qos\_no\_power\_off is
`1' the port will remain active/powered regardless of
the stats of descendants.  Defaults to 1.

\item[{\code{\textless{}hubdev-portX\textgreater{}/power/runtime\_status}:}] \leavevmode
This file reflects whether the port is `active' (power is on)
or `suspended' (logically off).  There is no indication to
userspace whether VBUS is still supplied.

\item[{\code{\textless{}hubdev-portX\textgreater{}/connect\_type}:}] \leavevmode
An advisory read-only flag to userspace indicating the
location and connection type of the port.  It returns
one of four values `hotplug', `hardwired', `not used',
and `unknown'.  All values, besides unknown, are set by
platform firmware.

\code{hotplug} indicates an externally connectable/visible
port on the platform.  Typically userspace would choose
to keep such a port powered to handle new device
connection events.

\code{hardwired} refers to a port that is not visible but
connectable. Examples are internal ports for USB
bluetooth that can be disconnected via an external
switch or a port with a hardwired USB camera.  It is
expected to be safe to allow these ports to suspend
provided pm\_qos\_no\_power\_off is coordinated with any
switch that gates connections.  Userspace must arrange
for the device to be connected prior to the port
powering off, or to activate the port prior to enabling
connection via a switch.

\code{not used} refers to an internal port that is expected
to never have a device connected to it.  These may be
empty internal ports, or ports that are not physically
exposed on a platform.  Considered safe to be
powered-off at all times.

\code{unknown} means platform firmware does not provide
information for this port.  Most commonly refers to
external hub ports which should be considered `hotplug'
for policy decisions.

\begin{notice}{note}{Note:}\begin{itemize}
\item {} 
since we are relying on the BIOS to get this ACPI
information correct, the USB port descriptions may
be missing or wrong.

\item {} 
Take care in clearing \code{pm\_qos\_no\_power\_off}. Once
power is off this port will
not respond to new connect events.

\end{itemize}
\end{notice}

\end{description}

Once a child device is attached additional constraints are
applied before the port is allowed to poweroff.
\begin{description}
\item[{\code{\textless{}child\textgreater{}/power/control}:}] \leavevmode
Must be \code{auto}, and the port will not
power down until \code{\textless{}child\textgreater{}/power/runtime\_status}
reflects the `suspended' state.  Default
value is controlled by child device driver.

\item[{\code{\textless{}child\textgreater{}/power/persist}:}] \leavevmode
This defaults to \code{1} for most devices and indicates if
kernel can persist the device's configuration across a
power session loss (suspend / port-power event).  When
this value is \code{0} (quirky devices), port poweroff is
disabled.

\item[{\code{\textless{}child\textgreater{}/driver/unbind}:}] \leavevmode
Wakeup capable devices will block port poweroff.  At
this time the only mechanism to clear the usb-internal
wakeup-capability for an interface device is to unbind
its driver.

\end{description}
\end{quote}

Summary of poweroff pre-requisite settings relative to a port device:

\begin{Verbatim}[commandchars=\\\{\}]
echo 0 \PYGZgt{} power/pm\PYGZus{}qos\PYGZus{}no\PYGZus{}power\PYGZus{}off
echo 0 \PYGZgt{} peer/power/pm\PYGZus{}qos\PYGZus{}no\PYGZus{}power\PYGZus{}off \PYGZsh{} if it exists
echo auto \PYGZgt{} power/control \PYGZsh{} this is the default value
echo auto \PYGZgt{} \PYGZlt{}child\PYGZgt{}/power/control
echo 1 \PYGZgt{} \PYGZlt{}child\PYGZgt{}/power/persist \PYGZsh{} this is the default value
\end{Verbatim}


\subsection{Suggested Userspace Port Power Policy}
\label{driver-api/usb/power-management:suggested-userspace-port-power-policy}
As noted above userspace needs to be careful and deliberate about what
ports are enabled for poweroff.

The default configuration is that all ports start with
\code{power/pm\_qos\_no\_power\_off} set to \code{1} causing ports to always remain
active.

Given confidence in the platform firmware's description of the ports
(ACPI \_PLD record for a port populates `connect\_type') userspace can
clear pm\_qos\_no\_power\_off for all `not used' ports.  The same can be
done for `hardwired' ports provided poweroff is coordinated with any
connection switch for the port.

A more aggressive userspace policy is to enable USB port power off for
all ports (set \code{\textless{}hubdev-portX\textgreater{}/power/pm\_qos\_no\_power\_off} to \code{0}) when
some external factor indicates the user has stopped interacting with the
system.  For example, a distro may want to enable power off all USB
ports when the screen blanks, and re-power them when the screen becomes
active.  Smart phones and tablets may want to power off USB ports when
the user pushes the power button.


\section{USB hotplugging}
\label{driver-api/usb/hotplug::doc}\label{driver-api/usb/hotplug:usb-hotplugging}

\subsection{Linux Hotplugging}
\label{driver-api/usb/hotplug:linux-hotplugging}
In hotpluggable busses like USB (and Cardbus PCI), end-users plug devices
into the bus with power on.  In most cases, users expect the devices to become
immediately usable.  That means the system must do many things, including:
\begin{itemize}
\item {} 
Find a driver that can handle the device.  That may involve
loading a kernel module; newer drivers can use module-init-tools
to publish their device (and class) support to user utilities.

\item {} 
Bind a driver to that device.  Bus frameworks do that using a
device driver's probe() routine.

\item {} 
Tell other subsystems to configure the new device.  Print
queues may need to be enabled, networks brought up, disk
partitions mounted, and so on.  In some cases these will
be driver-specific actions.

\end{itemize}

This involves a mix of kernel mode and user mode actions.  Making devices
be immediately usable means that any user mode actions can't wait for an
administrator to do them:  the kernel must trigger them, either passively
(triggering some monitoring daemon to invoke a helper program) or
actively (calling such a user mode helper program directly).

Those triggered actions must support a system's administrative policies;
such programs are called ``policy agents'' here.  Typically they involve
shell scripts that dispatch to more familiar administration tools.

Because some of those actions rely on information about drivers (metadata)
that is currently available only when the drivers are dynamically linked,
you get the best hotplugging when you configure a highly modular system.


\subsection{Kernel Hotplug Helper (\texttt{/sbin/hotplug})}
\label{driver-api/usb/hotplug:kernel-hotplug-helper-sbin-hotplug}
There is a kernel parameter: \code{/proc/sys/kernel/hotplug}, which normally
holds the pathname \code{/sbin/hotplug}.  That parameter names a program
which the kernel may invoke at various times.

The /sbin/hotplug program can be invoked by any subsystem as part of its
reaction to a configuration change, from a thread in that subsystem.
Only one parameter is required: the name of a subsystem being notified of
some kernel event.  That name is used as the first key for further event
dispatch; any other argument and environment parameters are specified by
the subsystem making that invocation.

Hotplug software and other resources is available at:
\begin{quote}

\href{http://linux-hotplug.sourceforge.net}{http://linux-hotplug.sourceforge.net}
\end{quote}

Mailing list information is also available at that site.


\subsection{USB Policy Agent}
\label{driver-api/usb/hotplug:usb-policy-agent}
The USB subsystem currently invokes \code{/sbin/hotplug} when USB devices
are added or removed from system.  The invocation is done by the kernel
hub workqueue {[}hub\_wq{]}, or else as part of root hub initialization
(done by init, modprobe, kapmd, etc).  Its single command line parameter
is the string ``usb'', and it passes these environment variables:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

ACTION
 & 
\code{add}, \code{remove}
\\
\hline
PRODUCT
 & 
USB vendor, product, and version codes (hex)
\\
\hline
TYPE
 & 
device class codes (decimal)
\\
\hline
INTERFACE
 & 
interface 0 class codes (decimal)
\\
\hline\end{tabulary}


If ``usbdevfs'' is configured, DEVICE and DEVFS are also passed.  DEVICE is
the pathname of the device, and is useful for devices with multiple and/or
alternate interfaces that complicate driver selection.  By design, USB
hotplugging is independent of \code{usbdevfs}:  you can do most essential parts
of USB device setup without using that filesystem, and without running a
user mode daemon to detect changes in system configuration.

Currently available policy agent implementations can load drivers for
modules, and can invoke driver-specific setup scripts.  The newest ones
leverage USB module-init-tools support.  Later agents might unload drivers.


\subsection{USB Modutils Support}
\label{driver-api/usb/hotplug:usb-modutils-support}
Current versions of module-init-tools will create a \code{modules.usbmap} file
which contains the entries from each driver's \code{MODULE\_DEVICE\_TABLE}.  Such
files can be used by various user mode policy agents to make sure all the
right driver modules get loaded, either at boot time or later.

See \code{linux/usb.h} for full information about such table entries; or look
at existing drivers.  Each table entry describes one or more criteria to
be used when matching a driver to a device or class of devices.  The
specific criteria are identified by bits set in ``match\_flags'', paired
with field values.  You can construct the criteria directly, or with
macros such as these, and use driver\_info to store more information:

\begin{Verbatim}[commandchars=\\\{\}]
USB\PYGZus{}DEVICE (vendorId, productId)
    ... matching devices with specified vendor and product ids
USB\PYGZus{}DEVICE\PYGZus{}VER (vendorId, productId, lo, hi)
    ... like USB\PYGZus{}DEVICE with lo \PYGZlt{}= productversion \PYGZlt{}= hi
USB\PYGZus{}INTERFACE\PYGZus{}INFO (class, subclass, protocol)
    ... matching specified interface class info
USB\PYGZus{}DEVICE\PYGZus{}INFO (class, subclass, protocol)
    ... matching specified device class info
\end{Verbatim}

A short example, for a driver that supports several specific USB devices
and their quirks, might have a MODULE\_DEVICE\_TABLE like this:

\begin{Verbatim}[commandchars=\\\{\}]
static const struct usb\PYGZus{}device\PYGZus{}id mydriver\PYGZus{}id\PYGZus{}table[] = \PYGZob{}
    \PYGZob{} USB\PYGZus{}DEVICE (0x9999, 0xaaaa), driver\PYGZus{}info: QUIRK\PYGZus{}X \PYGZcb{},
    \PYGZob{} USB\PYGZus{}DEVICE (0xbbbb, 0x8888), driver\PYGZus{}info: QUIRK\PYGZus{}Y\textbar{}QUIRK\PYGZus{}Z \PYGZcb{},
    ...
    \PYGZob{} \PYGZcb{} /* end with an all\PYGZhy{}zeroes entry */
\PYGZcb{};
MODULE\PYGZus{}DEVICE\PYGZus{}TABLE(usb, mydriver\PYGZus{}id\PYGZus{}table);
\end{Verbatim}

Most USB device drivers should pass these tables to the USB subsystem as
well as to the module management subsystem.  Not all, though: some driver
frameworks connect using interfaces layered over USB, and so they won't
need such a struct {\hyperref[driver\string-api/usb/usb:c.usb_driver]{\emph{\code{usb\_driver}}}}.

Drivers that connect directly to the USB subsystem should be declared
something like this:

\begin{Verbatim}[commandchars=\\\{\}]
static struct usb\PYGZus{}driver mydriver = \PYGZob{}
    .name           = \PYGZdq{}mydriver\PYGZdq{},
    .id\PYGZus{}table       = mydriver\PYGZus{}id\PYGZus{}table,
    .probe          = my\PYGZus{}probe,
    .disconnect     = my\PYGZus{}disconnect,

    /*
    if using the usb chardev framework:
        .minor              = MY\PYGZus{}USB\PYGZus{}MINOR\PYGZus{}START,
        .fops               = my\PYGZus{}file\PYGZus{}ops,
    if exposing any operations through usbdevfs:
        .ioctl              = my\PYGZus{}ioctl,
    */
\PYGZcb{};
\end{Verbatim}

When the USB subsystem knows about a driver's device ID table, it's used when
choosing drivers to probe().  The thread doing new device processing checks
drivers' device ID entries from the \code{MODULE\_DEVICE\_TABLE} against interface
and device descriptors for the device.  It will only call \code{probe()} if there
is a match, and the third argument to \code{probe()} will be the entry that
matched.

If you don't provide an \code{id\_table} for your driver, then your driver may get
probed for each new device; the third parameter to \code{probe()} will be
\code{NULL}.


\section{USB device persistence during system suspend}
\label{driver-api/usb/persist:usb-device-persistence-during-system-suspend}\label{driver-api/usb/persist:usb-persist}\label{driver-api/usb/persist::doc}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Alan Stern \textless{}\href{mailto:stern@rowland.harvard.edu}{stern@rowland.harvard.edu}\textgreater{}

\item[{Date}] \leavevmode
September 2, 2006 (Updated February 25, 2008)

\end{description}\end{quote}


\subsection{What is the problem?}
\label{driver-api/usb/persist:what-is-the-problem}
According to the USB specification, when a USB bus is suspended the
bus must continue to supply suspend current (around 1-5 mA).  This
is so that devices can maintain their internal state and hubs can
detect connect-change events (devices being plugged in or unplugged).
The technical term is ``power session''.

If a USB device's power session is interrupted then the system is
required to behave as though the device has been unplugged.  It's a
conservative approach; in the absence of suspend current the computer
has no way to know what has actually happened.  Perhaps the same
device is still attached or perhaps it was removed and a different
device plugged into the port.  The system must assume the worst.

By default, Linux behaves according to the spec.  If a USB host
controller loses power during a system suspend, then when the system
wakes up all the devices attached to that controller are treated as
though they had disconnected.  This is always safe and it is the
``officially correct'' thing to do.

For many sorts of devices this behavior doesn't matter in the least.
If the kernel wants to believe that your USB keyboard was unplugged
while the system was asleep and a new keyboard was plugged in when the
system woke up, who cares?  It'll still work the same when you type on
it.

Unfortunately problems \_can\_ arise, particularly with mass-storage
devices.  The effect is exactly the same as if the device really had
been unplugged while the system was suspended.  If you had a mounted
filesystem on the device, you're out of luck -- everything in that
filesystem is now inaccessible.  This is especially annoying if your
root filesystem was located on the device, since your system will
instantly crash.

Loss of power isn't the only mechanism to worry about.  Anything that
interrupts a power session will have the same effect.  For example,
even though suspend current may have been maintained while the system
was asleep, on many systems during the initial stages of wakeup the
firmware (i.e., the BIOS) resets the motherboard's USB host
controllers.  Result: all the power sessions are destroyed and again
it's as though you had unplugged all the USB devices.  Yes, it's
entirely the BIOS's fault, but that doesn't do \_you\_ any good unless
you can convince the BIOS supplier to fix the problem (lots of luck!).

On many systems the USB host controllers will get reset after a
suspend-to-RAM.  On almost all systems, no suspend current is
available during hibernation (also known as swsusp or suspend-to-disk).
You can check the kernel log after resuming to see if either of these
has happened; look for lines saying ``root hub lost power or was reset''.

In practice, people are forced to unmount any filesystems on a USB
device before suspending.  If the root filesystem is on a USB device,
the system can't be suspended at all.  (All right, it \_can\_ be
suspended -- but it will crash as soon as it wakes up, which isn't
much better.)


\subsection{What is the solution?}
\label{driver-api/usb/persist:what-is-the-solution}
The kernel includes a feature called USB-persist.  It tries to work
around these issues by allowing the core USB device data structures to
persist across a power-session disruption.

It works like this.  If the kernel sees that a USB host controller is
not in the expected state during resume (i.e., if the controller was
reset or otherwise had lost power) then it applies a persistence check
to each of the USB devices below that controller for which the
``persist'' attribute is set.  It doesn't try to resume the device; that
can't work once the power session is gone.  Instead it issues a USB
port reset and then re-enumerates the device.  (This is exactly the
same thing that happens whenever a USB device is reset.)  If the
re-enumeration shows that the device now attached to that port has the
same descriptors as before, including the Vendor and Product IDs, then
the kernel continues to use the same device structure.  In effect, the
kernel treats the device as though it had merely been reset instead of
unplugged.

The same thing happens if the host controller is in the expected state
but a USB device was unplugged and then replugged, or if a USB device
fails to carry out a normal resume.

If no device is now attached to the port, or if the descriptors are
different from what the kernel remembers, then the treatment is what
you would expect.  The kernel destroys the old device structure and
behaves as though the old device had been unplugged and a new device
plugged in.

The end result is that the USB device remains available and usable.
Filesystem mounts and memory mappings are unaffected, and the world is
now a good and happy place.

Note that the ``USB-persist'' feature will be applied only to those
devices for which it is enabled.  You can enable the feature by doing
(as root):

\begin{Verbatim}[commandchars=\\\{\}]
echo 1 \PYGZgt{}/sys/bus/usb/devices/.../power/persist
\end{Verbatim}

where the ''...'' should be filled in the with the device's ID.  Disable
the feature by writing 0 instead of 1.  For hubs the feature is
automatically and permanently enabled and the power/persist file
doesn't even exist, so you only have to worry about setting it for
devices where it really matters.


\subsection{Is this the best solution?}
\label{driver-api/usb/persist:is-this-the-best-solution}
Perhaps not.  Arguably, keeping track of mounted filesystems and
memory mappings across device disconnects should be handled by a
centralized Logical Volume Manager.  Such a solution would allow you
to plug in a USB flash device, create a persistent volume associated
with it, unplug the flash device, plug it back in later, and still
have the same persistent volume associated with the device.  As such
it would be more far-reaching than USB-persist.

On the other hand, writing a persistent volume manager would be a big
job and using it would require significant input from the user.  This
solution is much quicker and easier -- and it exists now, a giant
point in its favor!

Furthermore, the USB-persist feature applies to \_all\_ USB devices, not
just mass-storage devices.  It might turn out to be equally useful for
other device types, such as network interfaces.


\subsection{WARNING: USB-persist can be dangerous!!}
\label{driver-api/usb/persist:warning-usb-persist-can-be-dangerous}
When recovering an interrupted power session the kernel does its best
to make sure the USB device hasn't been changed; that is, the same
device is still plugged into the port as before.  But the checks
aren't guaranteed to be 100\% accurate.

If you replace one USB device with another of the same type (same
manufacturer, same IDs, and so on) there's an excellent chance the
kernel won't detect the change.  The serial number string and other
descriptors are compared with the kernel's stored values, but this
might not help since manufacturers frequently omit serial numbers
entirely in their devices.

Furthermore it's quite possible to leave a USB device exactly the same
while changing its media.  If you replace the flash memory card in a
USB card reader while the system is asleep, the kernel will have no
way to know you did it.  The kernel will assume that nothing has
happened and will continue to use the partition tables, inodes, and
memory mappings for the old card.

If the kernel gets fooled in this way, it's almost certain to cause
data corruption and to crash your system.  You'll have no one to blame
but yourself.

For those devices with avoid\_reset\_quirk attribute being set, persist
maybe fail because they may morph after reset.

YOU HAVE BEEN WARNED!  USE AT YOUR OWN RISK!

That having been said, most of the time there shouldn't be any trouble
at all.  The USB-persist feature can be extremely useful.  Make the
most of it.


\section{USB Error codes}
\label{driver-api/usb/error-codes::doc}\label{driver-api/usb/error-codes:usb-error-codes}\label{driver-api/usb/error-codes:id1}\begin{quote}\begin{description}
\item[{Revised}] \leavevmode
2004-Oct-21

\end{description}\end{quote}

This is the documentation of (hopefully) all possible error codes (and
their interpretation) that can be returned from usbcore.

Some of them are returned by the Host Controller Drivers (HCDs), which
device drivers only see through usbcore.  As a rule, all the HCDs should
behave the same except for transfer speed dependent behaviors and the
way certain faults are reported.


\subsection{Error codes returned by \texttt{usb\_submit\_urb()}}
\label{driver-api/usb/error-codes:error-codes-returned-by-usb-submit-urb}
Non-USB-specific:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

0
 & 
URB submission went fine
\\
\hline
\code{-ENOMEM}
 & 
no memory for allocation of internal structures
\\
\hline\end{tabulary}


USB-specific:

\begin{tabular}{|p{0.475\linewidth}|p{0.475\linewidth}|}
\hline

\code{-EBUSY}
 & 
The URB is already active.
\\
\hline
\code{-ENODEV}
 & 
specified USB-device or bus doesn't exist
\\
\hline
\code{-ENOENT}
 & 
specified interface or endpoint does not exist or
is not enabled
\\
\hline
\code{-ENXIO}
 & 
host controller driver does not support queuing of
this type of urb.  (treat as a host controller bug.)
\\
\hline
\code{-EINVAL}
 & \begin{enumerate}
\item {} 
Invalid transfer type specified (or not supported)

\item {} 
Invalid or unsupported periodic transfer interval

\item {} 
ISO: attempted to change transfer interval

\item {} 
ISO: \code{number\_of\_packets} is \textless{} 0

\item {} 
various other cases

\end{enumerate}
\\
\hline
\code{-EXDEV}
 & 
ISO: \code{URB\_ISO\_ASAP} wasn't specified and all the
frames the URB would be scheduled in have already
expired.
\\
\hline
\code{-EFBIG}
 & 
Host controller driver can't schedule that many ISO
frames.
\\
\hline
\code{-EPIPE}
 & 
The pipe type specified in the URB doesn't match the
endpoint's actual type.
\\
\hline
\code{-EMSGSIZE}
 & \begin{enumerate}
\item {} 
endpoint maxpacket size is zero; it is not usable
in the current interface altsetting.

\item {} 
ISO packet is larger than the endpoint maxpacket.

\item {} 
requested data transfer length is invalid: negative
or too large for the host controller.

\end{enumerate}
\\
\hline
\code{-ENOSPC}
 & 
This request would overcommit the usb bandwidth reserved
for periodic transfers (interrupt, isochronous).
\\
\hline
\code{-ESHUTDOWN}
 & 
The device or host controller has been disabled due to
some problem that could not be worked around.
\\
\hline
\code{-EPERM}
 & 
Submission failed because \code{urb-\textgreater{}reject} was set.
\\
\hline
\code{-EHOSTUNREACH}
 & 
URB was rejected because the device is suspended.
\\
\hline
\code{-ENOEXEC}
 & 
A control URB doesn't contain a Setup packet.
\\
\hline\end{tabular}



\subsection{Error codes returned by \texttt{in urb-\textgreater{}status} or in \texttt{iso\_frame\_desc{[}n{]}.status} (for ISO)}
\label{driver-api/usb/error-codes:error-codes-returned-by-in-urb-status-or-in-iso-frame-desc-n-status-for-iso}
USB device drivers may only test urb status values in completion handlers.
This is because otherwise there would be a race between HCDs updating
these values on one CPU, and device drivers testing them on another CPU.

A transfer's actual\_length may be positive even when an error has been
reported.  That's because transfers often involve several packets, so that
one or more packets could finish before an error stops further endpoint I/O.

For isochronous URBs, the urb status value is non-zero only if the URB is
unlinked, the device is removed, the host controller is disabled, or the total
transferred length is less than the requested length and the
\code{URB\_SHORT\_NOT\_OK} flag is set.  Completion handlers for isochronous URBs
should only see \code{urb-\textgreater{}status} set to zero, \code{-ENOENT}, \code{-ECONNRESET},
\code{-ESHUTDOWN}, or \code{-EREMOTEIO}. Individual frame descriptor status fields
may report more status codes.

\begin{tabular}{|p{0.475\linewidth}|p{0.475\linewidth}|}
\hline

0
 & 
Transfer completed successfully
\\
\hline
\code{-ENOENT}
 & 
URB was synchronously unlinked by
{\hyperref[driver\string-api/usb/usb:c.usb_unlink_urb]{\emph{\code{usb\_unlink\_urb()}}}}
\\
\hline
\code{-EINPROGRESS}
 & 
URB still pending, no results yet
(That is, if drivers see this it's a bug.)
\\
\hline
\code{-EPROTO} \protect\footnotemark[1], \protect\footnotemark[2]
 & \begin{enumerate}
\item {} 
bitstuff error

\item {} 
no response packet received within the
prescribed bus turn-around time

\item {} 
unknown USB error

\end{enumerate}
\\
\hline
\code{-EILSEQ} \protect\footnotemark[1], \protect\footnotemark[2]
 & \begin{enumerate}
\item {} 
CRC mismatch

\item {} 
no response packet received within the
prescribed bus turn-around time

\item {} 
unknown USB error

\end{enumerate}

Note that often the controller hardware does
not distinguish among cases a), b), and c), so
a driver cannot tell whether there was a
protocol error, a failure to respond (often
caused by device disconnect), or some other
fault.
\\
\hline
\code{-ETIME} \protect\footnotemark[2]
 & 
No response packet received within the
prescribed bus turn-around time.  This error
may instead be reported as
\code{-EPROTO} or \code{-EILSEQ}.
\\
\hline
\code{-ETIMEDOUT}
 & 
Synchronous USB message functions use this code
to indicate timeout expired before the transfer
completed, and no other error was reported
by HC.
\\
\hline
\code{-EPIPE} \protect\footnotemark[2]
 & 
Endpoint stalled.  For non-control endpoints,
reset this status with
{\hyperref[driver\string-api/usb/usb:c.usb_clear_halt]{\emph{\code{usb\_clear\_halt()}}}}.
\\
\hline
\code{-ECOMM}
 & 
During an IN transfer, the host controller
received data from an endpoint faster than it
could be written to system memory
\\
\hline
\code{-ENOSR}
 & 
During an OUT transfer, the host controller
could not retrieve data from system memory fast
enough to keep up with the USB data rate
\\
\hline
\code{-EOVERFLOW} \protect\footnotemark[1]
 & 
The amount of data returned by the endpoint was
greater than either the max packet size of the
endpoint or the remaining buffer size.
``Babble''.
\\
\hline
\code{-EREMOTEIO}
 & 
The data read from the endpoint did not fill
the specified buffer, and \code{URB\_SHORT\_NOT\_OK}
was set in \code{urb-\textgreater{}transfer\_flags}.
\\
\hline
\code{-ENODEV}
 & 
Device was removed.  Often preceded by a burst
of other errors, since the hub driver doesn't
detect device removal events immediately.
\\
\hline
\code{-EXDEV}
 & 
ISO transfer only partially completed
(only set in \code{iso\_frame\_desc{[}n{]}.status},
not \code{urb-\textgreater{}status})
\\
\hline
\code{-EINVAL}
 & 
ISO madness, if this happens: Log off and
go home
\\
\hline
\code{-ECONNRESET}
 & 
URB was asynchronously unlinked by
{\hyperref[driver\string-api/usb/usb:c.usb_unlink_urb]{\emph{\code{usb\_unlink\_urb()}}}}
\\
\hline
\code{-ESHUTDOWN}
 & 
The device or host controller has been
disabled due to some problem that could not
be worked around, such as a physical
disconnect.
\\
\hline\end{tabular}

\footnotetext[1]{
Error codes like \code{-EPROTO}, \code{-EILSEQ} and \code{-EOVERFLOW} normally
indicate hardware problems such as bad devices (including firmware)
or cables.
}\footnotetext[2]{
This is also one of several codes that different kinds of host
controller use to indicate a transfer has failed because of device
disconnect.  In the interval before the hub driver starts disconnect
processing, devices may receive such fault reports for every request.
}

\subsection{Error codes returned by usbcore-functions}
\label{driver-api/usb/error-codes:error-codes-returned-by-usbcore-functions}
\begin{notice}{note}{Note:}
expect also other submit and transfer status codes
\end{notice}

\code{usb\_register()}:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

\code{-EINVAL}
 & 
error during registering new driver
\\
\hline\end{tabulary}


\code{usb\_get\_*/usb\_set\_*()},
{\hyperref[driver\string-api/usb/usb:c.usb_control_msg]{\emph{\code{usb\_control\_msg()}}}},
{\hyperref[driver\string-api/usb/usb:c.usb_bulk_msg]{\emph{\code{usb\_bulk\_msg()}}}}:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

\code{-ETIMEDOUT}
 & 
Timeout expired before the transfer completed.
\\
\hline\end{tabulary}



\section{Writing USB Device Drivers}
\label{driver-api/usb/writing_usb_driver:writing-usb-device-drivers}\label{driver-api/usb/writing_usb_driver:writing-usb-driver}\label{driver-api/usb/writing_usb_driver::doc}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Greg Kroah-Hartman

\end{description}\end{quote}


\subsection{Introduction}
\label{driver-api/usb/writing_usb_driver:introduction}
The Linux USB subsystem has grown from supporting only two different
types of devices in the 2.2.7 kernel (mice and keyboards), to over 20
different types of devices in the 2.4 kernel. Linux currently supports
almost all USB class devices (standard types of devices like keyboards,
mice, modems, printers and speakers) and an ever-growing number of
vendor-specific devices (such as USB to serial converters, digital
cameras, Ethernet devices and MP3 players). For a full list of the
different USB devices currently supported, see Resources.

The remaining kinds of USB devices that do not have support on Linux are
almost all vendor-specific devices. Each vendor decides to implement a
custom protocol to talk to their device, so a custom driver usually
needs to be created. Some vendors are open with their USB protocols and
help with the creation of Linux drivers, while others do not publish
them, and developers are forced to reverse-engineer. See Resources for
some links to handy reverse-engineering tools.

Because each different protocol causes a new driver to be created, I
have written a generic USB driver skeleton, modelled after the
pci-skeleton.c file in the kernel source tree upon which many PCI
network drivers have been based. This USB skeleton can be found at
drivers/usb/usb-skeleton.c in the kernel source tree. In this article I
will walk through the basics of the skeleton driver, explaining the
different pieces and what needs to be done to customize it to your
specific device.


\subsection{Linux USB Basics}
\label{driver-api/usb/writing_usb_driver:linux-usb-basics}
If you are going to write a Linux USB driver, please become familiar
with the USB protocol specification. It can be found, along with many
other useful documents, at the USB home page (see Resources). An
excellent introduction to the Linux USB subsystem can be found at the
USB Working Devices List (see Resources). It explains how the Linux USB
subsystem is structured and introduces the reader to the concept of USB
urbs (USB Request Blocks), which are essential to USB drivers.

The first thing a Linux USB driver needs to do is register itself with
the Linux USB subsystem, giving it some information about which devices
the driver supports and which functions to call when a device supported
by the driver is inserted or removed from the system. All of this
information is passed to the USB subsystem in the {\hyperref[driver\string-api/usb/usb:c.usb_driver]{\emph{\code{usb\_driver}}}}
structure. The skeleton driver declares a {\hyperref[driver\string-api/usb/usb:c.usb_driver]{\emph{\code{usb\_driver}}}} as:

\begin{Verbatim}[commandchars=\\\{\}]
static struct usb\PYGZus{}driver skel\PYGZus{}driver = \PYGZob{}
        .name        = \PYGZdq{}skeleton\PYGZdq{},
        .probe       = skel\PYGZus{}probe,
        .disconnect  = skel\PYGZus{}disconnect,
        .fops        = \PYGZam{}skel\PYGZus{}fops,
        .minor       = USB\PYGZus{}SKEL\PYGZus{}MINOR\PYGZus{}BASE,
        .id\PYGZus{}table    = skel\PYGZus{}table,
\PYGZcb{};
\end{Verbatim}

The variable name is a string that describes the driver. It is used in
informational messages printed to the system log. The probe and
disconnect function pointers are called when a device that matches the
information provided in the \code{id\_table} variable is either seen or
removed.

The fops and minor variables are optional. Most USB drivers hook into
another kernel subsystem, such as the SCSI, network or TTY subsystem.
These types of drivers register themselves with the other kernel
subsystem, and any user-space interactions are provided through that
interface. But for drivers that do not have a matching kernel subsystem,
such as MP3 players or scanners, a method of interacting with user space
is needed. The USB subsystem provides a way to register a minor device
number and a set of \code{file\_operations} function pointers that enable
this user-space interaction. The skeleton driver needs this kind of
interface, so it provides a minor starting number and a pointer to its
\code{file\_operations} functions.

The USB driver is then registered with a call to \code{usb\_register()},
usually in the driver's init function, as shown here:

\begin{Verbatim}[commandchars=\\\{\}]
static int \PYGZus{}\PYGZus{}init usb\PYGZus{}skel\PYGZus{}init(void)
\PYGZob{}
        int result;

        /* register this driver with the USB subsystem */
        result = usb\PYGZus{}register(\PYGZam{}skel\PYGZus{}driver);
        if (result \PYGZlt{} 0) \PYGZob{}
                err(\PYGZdq{}usb\PYGZus{}register failed for the \PYGZdq{}\PYGZus{}\PYGZus{}FILE\PYGZus{}\PYGZus{} \PYGZdq{}driver.\PYGZdq{}
                    \PYGZdq{}Error number \PYGZpc{}d\PYGZdq{}, result);
                return \PYGZhy{}1;
        \PYGZcb{}

        return 0;
\PYGZcb{}
module\PYGZus{}init(usb\PYGZus{}skel\PYGZus{}init);
\end{Verbatim}

When the driver is unloaded from the system, it needs to deregister
itself with the USB subsystem. This is done with the {\hyperref[driver\string-api/usb/usb:c.usb_deregister]{\emph{\code{usb\_deregister()}}}}
function:

\begin{Verbatim}[commandchars=\\\{\}]
static void \PYGZus{}\PYGZus{}exit usb\PYGZus{}skel\PYGZus{}exit(void)
\PYGZob{}
        /* deregister this driver with the USB subsystem */
        usb\PYGZus{}deregister(\PYGZam{}skel\PYGZus{}driver);
\PYGZcb{}
module\PYGZus{}exit(usb\PYGZus{}skel\PYGZus{}exit);
\end{Verbatim}

To enable the linux-hotplug system to load the driver automatically when
the device is plugged in, you need to create a \code{MODULE\_DEVICE\_TABLE}.
The following code tells the hotplug scripts that this module supports a
single device with a specific vendor and product ID:

\begin{Verbatim}[commandchars=\\\{\}]
/* table of devices that work with this driver */
static struct usb\PYGZus{}device\PYGZus{}id skel\PYGZus{}table [] = \PYGZob{}
        \PYGZob{} USB\PYGZus{}DEVICE(USB\PYGZus{}SKEL\PYGZus{}VENDOR\PYGZus{}ID, USB\PYGZus{}SKEL\PYGZus{}PRODUCT\PYGZus{}ID) \PYGZcb{},
        \PYGZob{} \PYGZcb{}                      /* Terminating entry */
\PYGZcb{};
MODULE\PYGZus{}DEVICE\PYGZus{}TABLE (usb, skel\PYGZus{}table);
\end{Verbatim}

There are other macros that can be used in describing a struct
{\hyperref[driver\string-api/basics:c.usb_device_id]{\emph{\code{usb\_device\_id}}}} for drivers that support a whole class of USB
drivers. See {\hyperref[driver\string-api/usb/usb:usb\string-header]{\emph{usb.h}}} for more information on this.


\subsection{Device operation}
\label{driver-api/usb/writing_usb_driver:device-operation}
When a device is plugged into the USB bus that matches the device ID
pattern that your driver registered with the USB core, the probe
function is called. The {\hyperref[driver\string-api/usb/usb:c.usb_device]{\emph{\code{usb\_device}}}} structure, interface number and
the interface ID are passed to the function:

\begin{Verbatim}[commandchars=\\\{\}]
static int skel\PYGZus{}probe(struct usb\PYGZus{}interface *interface,
    const struct usb\PYGZus{}device\PYGZus{}id *id)
\end{Verbatim}

The driver now needs to verify that this device is actually one that it
can accept. If so, it returns 0. If not, or if any error occurs during
initialization, an errorcode (such as \code{-ENOMEM} or \code{-ENODEV}) is
returned from the probe function.

In the skeleton driver, we determine what end points are marked as
bulk-in and bulk-out. We create buffers to hold the data that will be
sent and received from the device, and a USB urb to write data to the
device is initialized.

Conversely, when the device is removed from the USB bus, the disconnect
function is called with the device pointer. The driver needs to clean
any private data that has been allocated at this time and to shut down
any pending urbs that are in the USB system.

Now that the device is plugged into the system and the driver is bound
to the device, any of the functions in the \code{file\_operations} structure
that were passed to the USB subsystem will be called from a user program
trying to talk to the device. The first function called will be open, as
the program tries to open the device for I/O. We increment our private
usage count and save a pointer to our internal structure in the file
structure. This is done so that future calls to file operations will
enable the driver to determine which device the user is addressing. All
of this is done with the following code:

\begin{Verbatim}[commandchars=\\\{\}]
/* increment our usage count for the module */
++skel\PYGZhy{}\PYGZgt{}open\PYGZus{}count;

/* save our object in the file\PYGZsq{}s private structure */
file\PYGZhy{}\PYGZgt{}private\PYGZus{}data = dev;
\end{Verbatim}

After the open function is called, the read and write functions are
called to receive and send data to the device. In the \code{skel\_write}
function, we receive a pointer to some data that the user wants to send
to the device and the size of the data. The function determines how much
data it can send to the device based on the size of the write urb it has
created (this size depends on the size of the bulk out end point that
the device has). Then it copies the data from user space to kernel
space, points the urb to the data and submits the urb to the USB
subsystem. This can be seen in the following code:

\begin{Verbatim}[commandchars=\\\{\}]
/* we can only write as much as 1 urb will hold */
bytes\PYGZus{}written = (count \PYGZgt{} skel\PYGZhy{}\PYGZgt{}bulk\PYGZus{}out\PYGZus{}size) ? skel\PYGZhy{}\PYGZgt{}bulk\PYGZus{}out\PYGZus{}size : count;

/* copy the data from user space into our urb */
copy\PYGZus{}from\PYGZus{}user(skel\PYGZhy{}\PYGZgt{}write\PYGZus{}urb\PYGZhy{}\PYGZgt{}transfer\PYGZus{}buffer, buffer, bytes\PYGZus{}written);

/* set up our urb */
usb\PYGZus{}fill\PYGZus{}bulk\PYGZus{}urb(skel\PYGZhy{}\PYGZgt{}write\PYGZus{}urb,
                  skel\PYGZhy{}\PYGZgt{}dev,
                  usb\PYGZus{}sndbulkpipe(skel\PYGZhy{}\PYGZgt{}dev, skel\PYGZhy{}\PYGZgt{}bulk\PYGZus{}out\PYGZus{}endpointAddr),
                  skel\PYGZhy{}\PYGZgt{}write\PYGZus{}urb\PYGZhy{}\PYGZgt{}transfer\PYGZus{}buffer,
                  bytes\PYGZus{}written,
                  skel\PYGZus{}write\PYGZus{}bulk\PYGZus{}callback,
                  skel);

/* send the data out the bulk port */
result = usb\PYGZus{}submit\PYGZus{}urb(skel\PYGZhy{}\PYGZgt{}write\PYGZus{}urb);
if (result) \PYGZob{}
        err(\PYGZdq{}Failed submitting write urb, error \PYGZpc{}d\PYGZdq{}, result);
\PYGZcb{}
\end{Verbatim}

When the write urb is filled up with the proper information using the
{\hyperref[driver\string-api/usb/usb:c.usb_fill_bulk_urb]{\emph{\code{usb\_fill\_bulk\_urb()}}}} function, we point the urb's completion callback
to call our own \code{skel\_write\_bulk\_callback} function. This function is
called when the urb is finished by the USB subsystem. The callback
function is called in interrupt context, so caution must be taken not to
do very much processing at that time. Our implementation of
\code{skel\_write\_bulk\_callback} merely reports if the urb was completed
successfully or not and then returns.

The read function works a bit differently from the write function in
that we do not use an urb to transfer data from the device to the
driver. Instead we call the {\hyperref[driver\string-api/usb/usb:c.usb_bulk_msg]{\emph{\code{usb\_bulk\_msg()}}}} function, which can be used
to send or receive data from a device without having to create urbs and
handle urb completion callback functions. We call the {\hyperref[driver\string-api/usb/usb:c.usb_bulk_msg]{\emph{\code{usb\_bulk\_msg()}}}}
function, giving it a buffer into which to place any data received from
the device and a timeout value. If the timeout period expires without
receiving any data from the device, the function will fail and return an
error message. This can be shown with the following code:

\begin{Verbatim}[commandchars=\\\{\}]
/* do an immediate bulk read to get data from the device */
retval = usb\PYGZus{}bulk\PYGZus{}msg (skel\PYGZhy{}\PYGZgt{}dev,
                       usb\PYGZus{}rcvbulkpipe (skel\PYGZhy{}\PYGZgt{}dev,
                       skel\PYGZhy{}\PYGZgt{}bulk\PYGZus{}in\PYGZus{}endpointAddr),
                       skel\PYGZhy{}\PYGZgt{}bulk\PYGZus{}in\PYGZus{}buffer,
                       skel\PYGZhy{}\PYGZgt{}bulk\PYGZus{}in\PYGZus{}size,
                       \PYGZam{}count, HZ*10);
/* if the read was successful, copy the data to user space */
if (!retval) \PYGZob{}
        if (copy\PYGZus{}to\PYGZus{}user (buffer, skel\PYGZhy{}\PYGZgt{}bulk\PYGZus{}in\PYGZus{}buffer, count))
                retval = \PYGZhy{}EFAULT;
        else
                retval = count;
\PYGZcb{}
\end{Verbatim}

The {\hyperref[driver\string-api/usb/usb:c.usb_bulk_msg]{\emph{\code{usb\_bulk\_msg()}}}} function can be very useful for doing single reads
or writes to a device; however, if you need to read or write constantly to
a device, it is recommended to set up your own urbs and submit them to
the USB subsystem.

When the user program releases the file handle that it has been using to
talk to the device, the release function in the driver is called. In
this function we decrement our private usage count and wait for possible
pending writes:

\begin{Verbatim}[commandchars=\\\{\}]
/* decrement our usage count for the device */
\PYGZhy{}\PYGZhy{}skel\PYGZhy{}\PYGZgt{}open\PYGZus{}count;
\end{Verbatim}

One of the more difficult problems that USB drivers must be able to
handle smoothly is the fact that the USB device may be removed from the
system at any point in time, even if a program is currently talking to
it. It needs to be able to shut down any current reads and writes and
notify the user-space programs that the device is no longer there. The
following code (function \code{skel\_delete}) is an example of how to do
this:

\begin{Verbatim}[commandchars=\\\{\}]
static inline void skel\PYGZus{}delete (struct usb\PYGZus{}skel *dev)
\PYGZob{}
    kfree (dev\PYGZhy{}\PYGZgt{}bulk\PYGZus{}in\PYGZus{}buffer);
    if (dev\PYGZhy{}\PYGZgt{}bulk\PYGZus{}out\PYGZus{}buffer != NULL)
        usb\PYGZus{}free\PYGZus{}coherent (dev\PYGZhy{}\PYGZgt{}udev, dev\PYGZhy{}\PYGZgt{}bulk\PYGZus{}out\PYGZus{}size,
            dev\PYGZhy{}\PYGZgt{}bulk\PYGZus{}out\PYGZus{}buffer,
            dev\PYGZhy{}\PYGZgt{}write\PYGZus{}urb\PYGZhy{}\PYGZgt{}transfer\PYGZus{}dma);
    usb\PYGZus{}free\PYGZus{}urb (dev\PYGZhy{}\PYGZgt{}write\PYGZus{}urb);
    kfree (dev);
\PYGZcb{}
\end{Verbatim}

If a program currently has an open handle to the device, we reset the
flag \code{device\_present}. For every read, write, release and other
functions that expect a device to be present, the driver first checks
this flag to see if the device is still present. If not, it releases
that the device has disappeared, and a \code{-ENODEV} error is returned to the
user-space program. When the release function is eventually called, it
determines if there is no device and if not, it does the cleanup that
the \code{skel\_disconnect} function normally does if there are no open files
on the device (see Listing 5).


\subsection{Isochronous Data}
\label{driver-api/usb/writing_usb_driver:isochronous-data}
This usb-skeleton driver does not have any examples of interrupt or
isochronous data being sent to or from the device. Interrupt data is
sent almost exactly as bulk data is, with a few minor exceptions.
Isochronous data works differently with continuous streams of data being
sent to or from the device. The audio and video camera drivers are very
good examples of drivers that handle isochronous data and will be useful
if you also need to do this.


\subsection{Conclusion}
\label{driver-api/usb/writing_usb_driver:conclusion}
Writing Linux USB device drivers is not a difficult task as the
usb-skeleton driver shows. This driver, combined with the other current
USB drivers, should provide enough examples to help a beginning author
create a working driver in a minimal amount of time. The linux-usb-devel
mailing list archives also contain a lot of helpful information.


\subsection{Resources}
\label{driver-api/usb/writing_usb_driver:resources}
The Linux USB Project:
\href{http://www.linux-usb.org/}{http://www.linux-usb.org/}

Linux Hotplug Project:
\href{http://linux-hotplug.sourceforge.net/}{http://linux-hotplug.sourceforge.net/}

Linux USB Working Devices List:
\href{http://www.qbik.ch/usb/devices/}{http://www.qbik.ch/usb/devices/}

linux-usb-devel Mailing List Archives:
\href{http://marc.theaimsgroup.com/?l=linux-usb-devel}{http://marc.theaimsgroup.com/?l=linux-usb-devel}

Programming Guide for Linux USB Device Drivers:
\href{http://lmu.web.psi.ch/docu/manuals/software\_manuals/linux\_sl/usb\_linux\_programming\_guide.pdf}{http://lmu.web.psi.ch/docu/manuals/software\_manuals/linux\_sl/usb\_linux\_programming\_guide.pdf}

USB Home Page: \href{http://www.usb.org}{http://www.usb.org}


\section{Synopsys DesignWare Core SuperSpeed USB 3.0 Controller}
\label{driver-api/usb/dwc3::doc}\label{driver-api/usb/dwc3:synopsys-designware-core-superspeed-usb-3-0-controller}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Felipe Balbi \textless{}\href{mailto:felipe.balbi@linux.intel.com}{felipe.balbi@linux.intel.com}\textgreater{}

\item[{Date}] \leavevmode
April 2017

\end{description}\end{quote}


\subsection{Introduction}
\label{driver-api/usb/dwc3:introduction}
The \emph{Synopsys DesignWare Core SuperSpeed USB 3.0 Controller}
(hereinafter referred to as \emph{DWC3}) is a USB SuperSpeed compliant
controller which can be configured in one of 4 ways:
\begin{enumerate}
\item {} 
Peripheral-only configuration

\item {} 
Host-only configuration

\item {} 
Dual-Role configuration

\item {} 
Hub configuration

\end{enumerate}

Linux currently supports several versions of this controller. In all
likelyhood, the version in your SoC is already supported. At the time
of this writing, known tested versions range from 2.02a to 3.10a. As a
rule of thumb, anything above 2.02a should work reliably well.

Currently, we have many known users for this driver. In alphabetical
order:
\begin{enumerate}
\item {} 
Cavium

\item {} 
Intel Corporation

\item {} 
Qualcomm

\item {} 
Rockchip

\item {} 
ST

\item {} 
Samsung

\item {} 
Texas Instruments

\item {} 
Xilinx

\end{enumerate}


\subsection{Summary of Features}
\label{driver-api/usb/dwc3:summary-of-features}
For details about features supported by your version of DWC3, consult
your IP team and/or \emph{Synopsys DesignWare Core SuperSpeed USB 3.0
Controller Databook}. Following is a list of features supported by the
driver at the time of this writing:
\begin{enumerate}
\item {} 
Up to 16 bidirectional endpoints (including the control
pipe - ep0)

\item {} 
Flexible endpoint configuration

\item {} 
Simultaneous IN and OUT transfer support

\item {} 
Scatter-list support

\item {} 
Up to 256 TRBs \footnote[1]{
Transfer Request Block
} per endpoint

\item {} 
Support for all transfer types (\emph{Control}, \emph{Bulk},
\emph{Interrupt}, and \emph{Isochronous})

\item {} 
SuperSpeed Bulk Streams

\item {} 
Link Power Management

\item {} 
Trace Events for debugging

\item {} 
DebugFS \footnote[3]{
The Debug File System
} interface

\end{enumerate}

These features have all been exercised with many of the \textbf{in-tree}
gadget drivers. We have verified both \emph{ConfigFS} \footnote[4]{
The Config File System
} and
legacy gadget drivers.


\subsection{Driver Design}
\label{driver-api/usb/dwc3:driver-design}
The DWC3 driver sits on the \emph{drivers/usb/dwc3/} directory. All files
related to this driver are in this one directory. This makes it easy
for new-comers to read the code and understand how it behaves.

Because of DWC3's configuration flexibility, the driver is a little
complex in some places but it should be rather straightforward to
understand.

The biggest part of the driver refers to the Gadget API.


\subsection{Known Limitations}
\label{driver-api/usb/dwc3:known-limitations}
Like any other HW, DWC3 has its own set of limitations. To avoid
constant questions about such problems, we decided to document them
here and have a single location to where we could point users.


\subsubsection{OUT Transfer Size Requirements}
\label{driver-api/usb/dwc3:out-transfer-size-requirements}
According to Synopsys Databook, all OUT transfer TRBs \footnotemark[1] must
have their \emph{size} field set to a value which is integer divisible by
the endpoint's \emph{wMaxPacketSize}. This means that \emph{e.g.} in order to
receive a Mass Storage \emph{CBW} \footnote[5]{
Command Block Wrapper
}, req-\textgreater{}length must either be set
to a value that's divisible by \emph{wMaxPacketSize} (1024 on SuperSpeed,
512 on HighSpeed, etc), or DWC3 driver must add a Chained TRB pointing
to a throw-away buffer for the remaining length. Without this, OUT
transfers will \textbf{NOT} start.

Note that as of this writing, this won't be a problem because DWC3 is
fully capable of appending a chained TRB for the remaining length and
completely hide this detail from the gadget driver. It's still worth
mentioning because this seems to be the largest source of queries
about DWC3 and \emph{non-working transfers}.


\subsubsection{TRB Ring Size Limitation}
\label{driver-api/usb/dwc3:trb-ring-size-limitation}
We, currently, have a hard limit of 256 TRBs \footnotemark[1] per endpoint,
with the last TRB being a Link TRB \footnote[2]{
Transfer Request Block pointing to another Transfer
Request Block.
} pointing back to the
first. This limit is arbitrary but it has the benefit of adding up to
exactly 4096 bytes, or 1 Page.

DWC3 driver will try its best to cope with more than 255 requests and,
for the most part, it should work normally. However this is not
something that has been exercised very frequently. If you experience
any problems, see section \textbf{Reporting Bugs} below.


\subsection{Reporting Bugs}
\label{driver-api/usb/dwc3:reporting-bugs}
Whenever you encounter a problem with DWC3, first and foremost you
should make sure that:
\begin{enumerate}
\item {} 
You're running latest tag from \href{https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/}{Linus' tree}

\item {} 
You can reproduce the error without any out-of-tree changes
to DWC3

\item {} 
You have checked that it's not a fault on the host machine

\end{enumerate}

After all these are verified, then here's how to capture enough
information so we can be of any help to you.


\subsubsection{Required Information}
\label{driver-api/usb/dwc3:required-information}
DWC3 relies exclusively on Trace Events for debugging. Everything is
exposed there, with some extra bits being exposed to DebugFS
\footnotemark[3].

In order to capture DWC3's Trace Events you should run the following
commands \textbf{before} plugging the USB cable to a host machine:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} mkdir \PYGZhy{}p /d}
\PYG{c+c1}{\PYGZsh{} mkdir \PYGZhy{}p /t}
\PYG{c+c1}{\PYGZsh{} mount \PYGZhy{}t debugfs none /d}
\PYG{c+c1}{\PYGZsh{} mount \PYGZhy{}t tracefs none /t}
\PYG{c+c1}{\PYGZsh{} echo 81920 \PYGZgt{} /t/buffer\PYGZus{}size\PYGZus{}kb}
\PYG{c+c1}{\PYGZsh{} echo 1 \PYGZgt{} /t/events/dwc3/enable}
\end{Verbatim}

After this is done, you can connect your USB cable and reproduce the
problem. As soon as the fault is reproduced, make a copy of files
\code{trace} and \code{regdump}, like so:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} cp /t/trace /root/trace.txt}
\PYG{c+c1}{\PYGZsh{} cat /d/*dwc3*/regdump \PYGZgt{} /root/regdump.txt}
\end{Verbatim}

Make sure to compress \code{trace.txt} and \code{regdump.txt} in a tarball
and email it to \href{mailto:felipe.balbi@linux.intel.com}{me} with \href{mailto:linux-usb@vger.kernel.org}{linux-usb} in Cc. If you want to be extra
sure that I'll help you, write your subject line in the following
format:
\begin{quote}

\textbf{{[}BUG REPORT{]} usb: dwc3: Bug while doing XYZ}
\end{quote}

On the email body, make sure to detail what you doing, which gadget
driver you were using, how to reproduce the problem, what SoC you're
using, which OS (and its version) was running on the Host machine.

With all this information, we should be able to understand what's
going on and be helpful to you.


\subsection{Debugging}
\label{driver-api/usb/dwc3:debugging}
First and foremost a disclaimer:

\begin{Verbatim}[commandchars=\\\{\}]
DISCLAIMER: The information available on DebugFS and/or TraceFS can
change at any time at any Major Linux Kernel Release. If writing
scripts, do **NOT** assume information to be available in the
current format.
\end{Verbatim}

With that out of the way, let's carry on.

If you're willing to debug your own problem, you deserve a round of
applause :-)

Anyway, there isn't much to say here other than Trace Events will be
really helpful in figuring out issues with DWC3. Also, access to
Synopsys Databook will be \textbf{really} valuable in this case.

A USB Sniffer can be helpful at times but it's not entirely required,
there's a lot that can be understood without looking at the wire.

Feel free to email \href{mailto:felipe.balbi@linux.intel.com}{me} and Cc \href{mailto:linux-usb@vger.kernel.org}{linux-usb} if you need any help.


\subsubsection{\texttt{DebugFS}}
\label{driver-api/usb/dwc3:debugfs}
\code{DebugFS} is very good for gathering snapshots of what's going on
with DWC3 and/or any endpoint.

On DWC3's \code{DebugFS} directory, you will find the following files and
directories:

\code{ep{[}0..15{]}\{in,out\}/}
\code{link\_state}
\code{regdump}
\code{testmode}


\paragraph{\texttt{link\_state}}
\label{driver-api/usb/dwc3:link-state}
When read, \code{link\_state} will print out one of \code{U0}, \code{U1},
\code{U2}, \code{U3}, \code{SS.Disabled}, \code{RX.Detect}, \code{SS.Inactive},
\code{Polling}, \code{Recovery}, \code{Hot Reset}, \code{Compliance},
\code{Loopback}, \code{Reset}, \code{Resume} or \code{UNKNOWN link state}.

This file can also be written to in order to force link to one of the
states above.


\paragraph{\texttt{regdump}}
\label{driver-api/usb/dwc3:regdump}
File name is self-explanatory. When read, \code{regdump} will print out a
register dump of DWC3. Note that this file can be grepped to find the
information you want.


\paragraph{\texttt{testmode}}
\label{driver-api/usb/dwc3:testmode}
When read, \code{testmode} will print out a name of one of the specified
USB 2.0 Testmodes (\code{test\_j}, \code{test\_k}, \code{test\_se0\_nak},
\code{test\_packet}, \code{test\_force\_enable}) or the string \code{no test} in
case no tests are currently being executed.

In order to start any of these test modes, the same strings can be
written to the file and DWC3 will enter the requested test mode.


\paragraph{\texttt{ep{[}0..15{]}\{in,out\}}}
\label{driver-api/usb/dwc3:ep-0-15-in-out}
For each endpoint we expose one directory following the naming
convention \code{ep\$num\$dir} \emph{(ep0in, ep0out, ep1in, ...)}. Inside each
of these directories you will find the following files:

\code{descriptor\_fetch\_queue}
\code{event\_queue}
\code{rx\_fifo\_queue}
\code{rx\_info\_queue}
\code{rx\_request\_queue}
\code{transfer\_type}
\code{trb\_ring}
\code{tx\_fifo\_queue}
\code{tx\_request\_queue}

With access to Synopsys Databook, you can decode the information on
them.


\subparagraph{\texttt{transfer\_type}}
\label{driver-api/usb/dwc3:transfer-type}
When read, \code{transfer\_type} will print out one of \code{control},
\code{bulk}, \code{interrupt} or \code{isochronous} depending on what the
endpoint descriptor says. If the endpoint hasn't been enabled yet, it
will print \code{-{-}}.


\subparagraph{\texttt{trb\_ring}}
\label{driver-api/usb/dwc3:trb-ring}
When read, \code{trb\_ring} will print out details about all TRBs on the
ring. It will also tell you where our enqueue and dequeue pointers are
located in the ring:

\begin{Verbatim}[commandchars=\\\{\}]
buffer\PYGZus{}addr,size,type,ioc,isp\PYGZus{}imi,csp,chn,lst,hwo
000000002c754000,481,normal,1,0,1,0,0,0
000000002c75c000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c788000,481,normal,1,0,1,0,0,0
000000002c78c000,481,normal,1,0,1,0,0,0
000000002c754000,481,normal,1,0,1,0,0,0
000000002c75c000,481,normal,1,0,1,0,0,0
000000002c784000,481,normal,1,0,1,0,0,0
000000002c788000,481,normal,1,0,1,0,0,0
000000002c78c000,481,normal,1,0,1,0,0,0
000000002c790000,481,normal,1,0,1,0,0,0
000000002c758000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c788000,481,normal,1,0,1,0,0,0
000000002c790000,481,normal,1,0,1,0,0,0
000000002c758000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c784000,481,normal,1,0,1,0,0,0
000000002c788000,481,normal,1,0,1,0,0,0
000000002c78c000,481,normal,1,0,1,0,0,0
000000002c754000,481,normal,1,0,1,0,0,0
000000002c758000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c784000,481,normal,1,0,1,0,0,0
000000002c78c000,481,normal,1,0,1,0,0,0
000000002c790000,481,normal,1,0,1,0,0,0
000000002c758000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c788000,481,normal,1,0,1,0,0,0
000000002c790000,481,normal,1,0,1,0,0,0
000000002c758000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c788000,481,normal,1,0,1,0,0,0
000000002c790000,481,normal,1,0,1,0,0,0
000000002c758000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c788000,481,normal,1,0,1,0,0,0
000000002c790000,481,normal,1,0,1,0,0,0
000000002c758000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c788000,481,normal,1,0,1,0,0,0
000000002c790000,481,normal,1,0,1,0,0,0
000000002c758000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c788000,481,normal,1,0,1,0,0,0
000000002c790000,481,normal,1,0,1,0,0,0
000000002c758000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c788000,481,normal,1,0,1,0,0,0
000000002c790000,481,normal,1,0,1,0,0,0
000000002c758000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c788000,481,normal,1,0,1,0,0,0
000000002c790000,481,normal,1,0,1,0,0,0
000000002c758000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c78c000,481,normal,1,0,1,0,0,0
000000002c784000,481,normal,1,0,1,0,0,0
000000002c788000,481,normal,1,0,1,0,0,0
000000002c78c000,481,normal,1,0,1,0,0,0
000000002c754000,481,normal,1,0,1,0,0,0
000000002c758000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c788000,481,normal,1,0,1,0,0,0
000000002c790000,481,normal,1,0,1,0,0,0
000000002c758000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c758000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c78c000,481,normal,1,0,1,0,0,0
000000002c75c000,481,normal,1,0,1,0,0,0
000000002c78c000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c754000,481,normal,1,0,1,0,0,0
000000002c788000,481,normal,1,0,1,0,0,0
000000002c754000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c788000,481,normal,1,0,1,0,0,0
000000002c78c000,481,normal,1,0,1,0,0,0
000000002c790000,481,normal,1,0,1,0,0,0
000000002c754000,481,normal,1,0,1,0,0,0
000000002c758000,481,normal,1,0,1,0,0,0
000000002c75c000,481,normal,1,0,1,0,0,0
000000002c780000,481,normal,1,0,1,0,0,0
000000002c784000,481,normal,1,0,1,0,0,0
000000002c788000,481,normal,1,0,1,0,0,0
000000002c78c000,481,normal,1,0,1,0,0,0
000000002c790000,481,normal,1,0,1,0,0,0
000000002c754000,481,normal,1,0,1,0,0,0
000000002c758000,481,normal,1,0,1,0,0,0
000000002c75c000,512,normal,1,0,1,0,0,1        D
0000000000000000,0,UNKNOWN,0,0,0,0,0,0       E
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
0000000000000000,0,UNKNOWN,0,0,0,0,0,0
00000000381ab000,0,link,0,0,0,0,0,1
\end{Verbatim}


\subsubsection{Trace Events}
\label{driver-api/usb/dwc3:trace-events}
DWC3 also provides several trace events which help us gathering
information about the behavior of the driver during runtime.

In order to use these events, you must enable \code{CONFIG\_FTRACE} in
your kernel config.

For details about how enable DWC3 events, see section \textbf{Reporting
Bugs}.

The following subsections will give details about each Event Class and
each Event defined by DWC3.


\paragraph{MMIO}
\label{driver-api/usb/dwc3:mmio}
It is sometimes useful to look at every MMIO access when looking for
bugs. Because of that, DWC3 offers two Trace Events (one for
dwc3\_readl() and one for dwc3\_writel()). \code{TP\_printk} follows:

\begin{Verbatim}[commandchars=\\\{\}]
TP\PYGZus{}printk(\PYGZdq{}addr \PYGZpc{}p value \PYGZpc{}08x\PYGZdq{}, \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}base + \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}offset,
              \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}value)
\end{Verbatim}


\paragraph{Interrupt Events}
\label{driver-api/usb/dwc3:interrupt-events}
Every IRQ event can be logged and decoded into a human readable
string. Because every event will be different, we don't give an
example other than the \code{TP\_printk} format used:

\begin{Verbatim}[commandchars=\\\{\}]
TP\PYGZus{}printk(\PYGZdq{}event (\PYGZpc{}08x): \PYGZpc{}s\PYGZdq{}, \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}event,
              dwc3\PYGZus{}decode\PYGZus{}event(\PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}event, \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}ep0state))
\end{Verbatim}


\paragraph{Control Request}
\label{driver-api/usb/dwc3:control-request}
Every USB Control Request can be logged to the trace buffer. The
output format is:

\begin{Verbatim}[commandchars=\\\{\}]
TP\PYGZus{}printk(\PYGZdq{}\PYGZpc{}s\PYGZdq{}, dwc3\PYGZus{}decode\PYGZus{}ctrl(\PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}bRequestType,
                              \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}bRequest, \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}wValue,
                              \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}wIndex, \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}wLength)
)
\end{Verbatim}

Note that Standard Control Requests will be decoded into
human-readable strings with their respective arguments. Class and
Vendor requests will be printed out a sequence of 8 bytes in hex
format.


\paragraph{Lifetime of a \texttt{struct usb\_request}}
\label{driver-api/usb/dwc3:lifetime-of-a-struct-usb-request}
The entire lifetime of a \code{struct usb\_request} can be tracked on the
trace buffer. We have one event for each of allocation, free,
queueing, dequeueing, and giveback. Output format is:

\begin{Verbatim}[commandchars=\\\{\}]
TP\PYGZus{}printk(\PYGZdq{}\PYGZpc{}s: req \PYGZpc{}p length \PYGZpc{}u/\PYGZpc{}u \PYGZpc{}s\PYGZpc{}s\PYGZpc{}s ==\PYGZgt{} \PYGZpc{}d\PYGZdq{},
      \PYGZus{}\PYGZus{}get\PYGZus{}str(name), \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}req, \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}actual, \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}length,
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}zero ? \PYGZdq{}Z\PYGZdq{} : \PYGZdq{}z\PYGZdq{},
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}short\PYGZus{}not\PYGZus{}ok ? \PYGZdq{}S\PYGZdq{} : \PYGZdq{}s\PYGZdq{},
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}no\PYGZus{}interrupt ? \PYGZdq{}i\PYGZdq{} : \PYGZdq{}I\PYGZdq{},
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}status
)
\end{Verbatim}


\paragraph{Generic Commands}
\label{driver-api/usb/dwc3:generic-commands}
We can log and decode every Generic Command with its completion
code. Format is:

\begin{Verbatim}[commandchars=\\\{\}]
TP\PYGZus{}printk(\PYGZdq{}cmd \PYGZsq{}\PYGZpc{}s\PYGZsq{} [\PYGZpc{}x] param \PYGZpc{}08x \PYGZhy{}\PYGZhy{}\PYGZgt{} status: \PYGZpc{}s\PYGZdq{},
      dwc3\PYGZus{}gadget\PYGZus{}generic\PYGZus{}cmd\PYGZus{}string(\PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}cmd),
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}cmd, \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}param,
      dwc3\PYGZus{}gadget\PYGZus{}generic\PYGZus{}cmd\PYGZus{}status\PYGZus{}string(\PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}status)
)
\end{Verbatim}


\paragraph{Endpoint Commands}
\label{driver-api/usb/dwc3:endpoint-commands}
Endpoints commands can also be logged together with completion
code. Format is:

\begin{Verbatim}[commandchars=\\\{\}]
TP\PYGZus{}printk(\PYGZdq{}\PYGZpc{}s: cmd \PYGZsq{}\PYGZpc{}s\PYGZsq{} [\PYGZpc{}d] params \PYGZpc{}08x \PYGZpc{}08x \PYGZpc{}08x \PYGZhy{}\PYGZhy{}\PYGZgt{} status: \PYGZpc{}s\PYGZdq{},
      \PYGZus{}\PYGZus{}get\PYGZus{}str(name), dwc3\PYGZus{}gadget\PYGZus{}ep\PYGZus{}cmd\PYGZus{}string(\PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}cmd),
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}cmd, \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}param0,
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}param1, \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}param2,
      dwc3\PYGZus{}ep\PYGZus{}cmd\PYGZus{}status\PYGZus{}string(\PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}cmd\PYGZus{}status)
)
\end{Verbatim}


\paragraph{Lifetime of a \texttt{TRB}}
\label{driver-api/usb/dwc3:lifetime-of-a-trb}
A \code{TRB} Lifetime is simple. We are either preparing a \code{TRB} or
completing it. With these two events, we can see how a \code{TRB} changes
over time. Format is:

\begin{Verbatim}[commandchars=\\\{\}]
TP\PYGZus{}printk(\PYGZdq{}\PYGZpc{}s: \PYGZpc{}d/\PYGZpc{}d trb \PYGZpc{}p buf \PYGZpc{}08x\PYGZpc{}08x size \PYGZpc{}s\PYGZpc{}d ctrl \PYGZpc{}08x (\PYGZpc{}c\PYGZpc{}c\PYGZpc{}c\PYGZpc{}c:\PYGZpc{}c\PYGZpc{}c:\PYGZpc{}s)\PYGZdq{},
      \PYGZus{}\PYGZus{}get\PYGZus{}str(name), \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}queued, \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}allocated,
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}trb, \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}bph, \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}bpl,
      (\PYGZob{}char *s;
      int pcm = ((\PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}size \PYGZgt{}\PYGZgt{} 24) \PYGZam{} 3) + 1;
      switch (\PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}type) \PYGZob{}
      case USB\PYGZus{}ENDPOINT\PYGZus{}XFER\PYGZus{}INT:
      case USB\PYGZus{}ENDPOINT\PYGZus{}XFER\PYGZus{}ISOC:
              switch (pcm) \PYGZob{}
              case 1:
                      s = \PYGZdq{}1x \PYGZdq{};
                      break;
              case 2:
                      s = \PYGZdq{}2x \PYGZdq{};
                      break;
              case 3:
                      s = \PYGZdq{}3x \PYGZdq{};
                      break;
              \PYGZcb{}
      default:
              s = \PYGZdq{}\PYGZdq{};
      \PYGZcb{} s; \PYGZcb{}),
      DWC3\PYGZus{}TRB\PYGZus{}SIZE\PYGZus{}LENGTH(\PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}size), \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}ctrl,
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}ctrl \PYGZam{} DWC3\PYGZus{}TRB\PYGZus{}CTRL\PYGZus{}HWO ? \PYGZsq{}H\PYGZsq{} : \PYGZsq{}h\PYGZsq{},
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}ctrl \PYGZam{} DWC3\PYGZus{}TRB\PYGZus{}CTRL\PYGZus{}LST ? \PYGZsq{}L\PYGZsq{} : \PYGZsq{}l\PYGZsq{},
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}ctrl \PYGZam{} DWC3\PYGZus{}TRB\PYGZus{}CTRL\PYGZus{}CHN ? \PYGZsq{}C\PYGZsq{} : \PYGZsq{}c\PYGZsq{},
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}ctrl \PYGZam{} DWC3\PYGZus{}TRB\PYGZus{}CTRL\PYGZus{}CSP ? \PYGZsq{}S\PYGZsq{} : \PYGZsq{}s\PYGZsq{},
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}ctrl \PYGZam{} DWC3\PYGZus{}TRB\PYGZus{}CTRL\PYGZus{}ISP\PYGZus{}IMI ? \PYGZsq{}S\PYGZsq{} : \PYGZsq{}s\PYGZsq{},
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}ctrl \PYGZam{} DWC3\PYGZus{}TRB\PYGZus{}CTRL\PYGZus{}IOC ? \PYGZsq{}C\PYGZsq{} : \PYGZsq{}c\PYGZsq{},
    dwc3\PYGZus{}trb\PYGZus{}type\PYGZus{}string(DWC3\PYGZus{}TRBCTL\PYGZus{}TYPE(\PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}ctrl))
)
\end{Verbatim}


\paragraph{Lifetime of an Endpoint}
\label{driver-api/usb/dwc3:lifetime-of-an-endpoint}
And endpoint's lifetime is summarized with enable and disable
operations, both of which can be traced. Format is:

\begin{Verbatim}[commandchars=\\\{\}]
TP\PYGZus{}printk(\PYGZdq{}\PYGZpc{}s: mps \PYGZpc{}d/\PYGZpc{}d streams \PYGZpc{}d burst \PYGZpc{}d ring \PYGZpc{}d/\PYGZpc{}d flags \PYGZpc{}c:\PYGZpc{}c\PYGZpc{}c\PYGZpc{}c\PYGZpc{}c\PYGZpc{}c:\PYGZpc{}c:\PYGZpc{}c\PYGZdq{},
      \PYGZus{}\PYGZus{}get\PYGZus{}str(name), \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}maxpacket,
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}maxpacket\PYGZus{}limit, \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}max\PYGZus{}streams,
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}maxburst, \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}trb\PYGZus{}enqueue,
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}trb\PYGZus{}dequeue,
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}flags \PYGZam{} DWC3\PYGZus{}EP\PYGZus{}ENABLED ? \PYGZsq{}E\PYGZsq{} : \PYGZsq{}e\PYGZsq{},
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}flags \PYGZam{} DWC3\PYGZus{}EP\PYGZus{}STALL ? \PYGZsq{}S\PYGZsq{} : \PYGZsq{}s\PYGZsq{},
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}flags \PYGZam{} DWC3\PYGZus{}EP\PYGZus{}WEDGE ? \PYGZsq{}W\PYGZsq{} : \PYGZsq{}w\PYGZsq{},
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}flags \PYGZam{} DWC3\PYGZus{}EP\PYGZus{}BUSY ? \PYGZsq{}B\PYGZsq{} : \PYGZsq{}b\PYGZsq{},
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}flags \PYGZam{} DWC3\PYGZus{}EP\PYGZus{}PENDING\PYGZus{}REQUEST ? \PYGZsq{}P\PYGZsq{} : \PYGZsq{}p\PYGZsq{},
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}flags \PYGZam{} DWC3\PYGZus{}EP\PYGZus{}MISSED\PYGZus{}ISOC ? \PYGZsq{}M\PYGZsq{} : \PYGZsq{}m\PYGZsq{},
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}flags \PYGZam{} DWC3\PYGZus{}EP\PYGZus{}END\PYGZus{}TRANSFER\PYGZus{}PENDING ? \PYGZsq{}E\PYGZsq{} : \PYGZsq{}e\PYGZsq{},
      \PYGZus{}\PYGZus{}entry\PYGZhy{}\PYGZgt{}direction ? \PYGZsq{}\PYGZlt{}\PYGZsq{} : \PYGZsq{}\PYGZgt{}\PYGZsq{}
)
\end{Verbatim}


\subsection{Structures, Methods and Definitions}
\label{driver-api/usb/dwc3:structures-methods-and-definitions}\index{dwc3\_event\_buffer (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_event_buffer}\pysigline{struct \bfcode{dwc3\_event\_buffer}}
Software event buffer representation

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dwc3\PYGZus{}event\PYGZus{}buffer \PYGZob{}
  void *buf;
  void *cache;
  unsigned length;
  unsigned int            lpos;
  unsigned int            count;
  unsigned int            flags;
\PYGZsh{}define DWC3\PYGZus{}EVENT\PYGZus{}PENDING      BIT(0);
  dma\PYGZus{}addr\PYGZus{}t dma;
  struct dwc3             *dwc;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{buf}}] \leavevmode
\_THE\_ buffer

\item[{\code{cache}}] \leavevmode
The buffer cache used in the threaded interrupt

\item[{\code{length}}] \leavevmode
size of this buffer

\item[{\code{lpos}}] \leavevmode
event offset

\item[{\code{count}}] \leavevmode
cache of last read event count register

\item[{\code{flags}}] \leavevmode
flags related to this event buffer

\item[{\code{dma}}] \leavevmode
dma\_addr\_t

\item[{\code{dwc}}] \leavevmode
pointer to DWC controller

\end{description}
\index{dwc3\_ep (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_ep}\pysigline{struct \bfcode{dwc3\_ep}}
device side endpoint representation

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dwc3\PYGZus{}ep \PYGZob{}
  struct usb\PYGZus{}ep           endpoint;
  struct list\PYGZus{}head        pending\PYGZus{}list;
  struct list\PYGZus{}head        started\PYGZus{}list;
  wait\PYGZus{}queue\PYGZus{}head\PYGZus{}t wait\PYGZus{}end\PYGZus{}transfer;
  spinlock\PYGZus{}t lock;
  void \PYGZus{}\PYGZus{}iomem            *regs;
  struct dwc3\PYGZus{}trb         *trb\PYGZus{}pool;
  dma\PYGZus{}addr\PYGZus{}t trb\PYGZus{}pool\PYGZus{}dma;
  struct dwc3             *dwc;
  u32 saved\PYGZus{}state;
  unsigned flags;
\PYGZsh{}define DWC3\PYGZus{}EP\PYGZus{}ENABLED         BIT(0);
\PYGZsh{}define DWC3\PYGZus{}EP\PYGZus{}STALL           BIT(1);
\PYGZsh{}define DWC3\PYGZus{}EP\PYGZus{}WEDGE           BIT(2);
\PYGZsh{}define DWC3\PYGZus{}EP\PYGZus{}BUSY            BIT(4);
\PYGZsh{}define DWC3\PYGZus{}EP\PYGZus{}PENDING\PYGZus{}REQUEST BIT(5);
\PYGZsh{}define DWC3\PYGZus{}EP\PYGZus{}MISSED\PYGZus{}ISOC     BIT(6);
\PYGZsh{}define DWC3\PYGZus{}EP\PYGZus{}END\PYGZus{}TRANSFER\PYGZus{}PENDING    BIT(7);
\PYGZsh{}define DWC3\PYGZus{}EP\PYGZus{}TRANSFER\PYGZus{}STARTED BIT(8);
\PYGZsh{}define DWC3\PYGZus{}EP0\PYGZus{}DIR\PYGZus{}IN         BIT(31);
  u8 trb\PYGZus{}enqueue;
  u8 trb\PYGZus{}dequeue;
  u8 number;
  u8 type;
  u8 resource\PYGZus{}index;
  u32 allocated\PYGZus{}requests;
  u32 queued\PYGZus{}requests;
  u32 frame\PYGZus{}number;
  u32 interval;
  char name[20];
  unsigned direction:1;
  unsigned stream\PYGZus{}capable:1;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{endpoint}}] \leavevmode
usb endpoint

\item[{\code{pending\_list}}] \leavevmode
list of pending requests for this endpoint

\item[{\code{started\_list}}] \leavevmode
list of started requests on this endpoint

\item[{\code{wait\_end\_transfer}}] \leavevmode
wait\_queue\_head\_t for waiting on End Transfer complete

\item[{\code{lock}}] \leavevmode
spinlock for endpoint request queue traversal

\item[{\code{regs}}] \leavevmode
pointer to first endpoint register

\item[{\code{trb\_pool}}] \leavevmode
array of transaction buffers

\item[{\code{trb\_pool\_dma}}] \leavevmode
dma address of \textbf{trb\_pool}

\item[{\code{dwc}}] \leavevmode
pointer to DWC controller

\item[{\code{saved\_state}}] \leavevmode
ep state saved during hibernation

\item[{\code{flags}}] \leavevmode
endpoint flags (wedged, stalled, ...)

\item[{\code{trb\_enqueue}}] \leavevmode
enqueue `pointer' into TRB array

\item[{\code{trb\_dequeue}}] \leavevmode
dequeue `pointer' into TRB array

\item[{\code{number}}] \leavevmode
endpoint number (1 - 15)

\item[{\code{type}}] \leavevmode
set to bmAttributes \& USB\_ENDPOINT\_XFERTYPE\_MASK

\item[{\code{resource\_index}}] \leavevmode
Resource transfer index

\item[{\code{allocated\_requests}}] \leavevmode
number of requests allocated

\item[{\code{queued\_requests}}] \leavevmode
number of requests queued for transfer

\item[{\code{frame\_number}}] \leavevmode
set to the frame number we want this transfer to start (ISOC)

\item[{\code{interval}}] \leavevmode
the interval on which the ISOC transfer is started

\item[{\code{name}}] \leavevmode
a human readable name e.g. ep1out-bulk

\item[{\code{direction}}] \leavevmode
true for TX, false for RX

\item[{\code{stream\_capable}}] \leavevmode
true when streams are enabled

\end{description}
\index{dwc3\_trb (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_trb}\pysigline{struct \bfcode{dwc3\_trb}}
transfer request block (hw format)

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dwc3\PYGZus{}trb \PYGZob{}
  u32 bpl;
  u32 bph;
  u32 size;
  u32 ctrl;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{bpl}}] \leavevmode
DW0-3

\item[{\code{bph}}] \leavevmode
DW4-7

\item[{\code{size}}] \leavevmode
DW8-B

\item[{\code{ctrl}}] \leavevmode
DWC-F

\end{description}
\index{dwc3\_hwparams (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_hwparams}\pysigline{struct \bfcode{dwc3\_hwparams}}
copy of HWPARAMS registers

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dwc3\PYGZus{}hwparams \PYGZob{}
  u32 hwparams0;
  u32 hwparams1;
  u32 hwparams2;
  u32 hwparams3;
  u32 hwparams4;
  u32 hwparams5;
  u32 hwparams6;
  u32 hwparams7;
  u32 hwparams8;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{hwparams0}}] \leavevmode
GHWPARAMS0

\item[{\code{hwparams1}}] \leavevmode
GHWPARAMS1

\item[{\code{hwparams2}}] \leavevmode
GHWPARAMS2

\item[{\code{hwparams3}}] \leavevmode
GHWPARAMS3

\item[{\code{hwparams4}}] \leavevmode
GHWPARAMS4

\item[{\code{hwparams5}}] \leavevmode
GHWPARAMS5

\item[{\code{hwparams6}}] \leavevmode
GHWPARAMS6

\item[{\code{hwparams7}}] \leavevmode
GHWPARAMS7

\item[{\code{hwparams8}}] \leavevmode
GHWPARAMS8

\end{description}
\index{dwc3\_request (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_request}\pysigline{struct \bfcode{dwc3\_request}}
representation of a transfer request

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dwc3\PYGZus{}request \PYGZob{}
  struct usb\PYGZus{}request      request;
  struct list\PYGZus{}head        list;
  struct dwc3\PYGZus{}ep          *dep;
  struct scatterlist      *sg;
  unsigned num\PYGZus{}pending\PYGZus{}sgs;
  unsigned remaining;
  u8 epnum;
  struct dwc3\PYGZus{}trb         *trb;
  dma\PYGZus{}addr\PYGZus{}t trb\PYGZus{}dma;
  unsigned unaligned:1;
  unsigned direction:1;
  unsigned mapped:1;
  unsigned started:1;
  unsigned zero:1;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{request}}] \leavevmode
struct usb\_request to be transferred

\item[{\code{list}}] \leavevmode
a list\_head used for request queueing

\item[{\code{dep}}] \leavevmode
struct dwc3\_ep owning this request

\item[{\code{sg}}] \leavevmode
pointer to first incomplete sg

\item[{\code{num\_pending\_sgs}}] \leavevmode
counter to pending sgs

\item[{\code{remaining}}] \leavevmode
amount of data remaining

\item[{\code{epnum}}] \leavevmode
endpoint number to which this request refers

\item[{\code{trb}}] \leavevmode
pointer to struct dwc3\_trb

\item[{\code{trb\_dma}}] \leavevmode
DMA address of \textbf{trb}

\item[{\code{unaligned}}] \leavevmode
true for OUT endpoints with length not divisible by maxp

\item[{\code{direction}}] \leavevmode
IN or OUT direction flag

\item[{\code{mapped}}] \leavevmode
true when request has been dma-mapped

\item[{\code{started}}] \leavevmode
request is started

\item[{\code{zero}}] \leavevmode
wants a ZLP

\end{description}
\index{dwc3 (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3}\pysigline{struct \bfcode{dwc3}}
representation of our controller

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dwc3 \PYGZob{}
  struct work\PYGZus{}struct      drd\PYGZus{}work;
  struct dwc3\PYGZus{}trb         *ep0\PYGZus{}trb;
  void *bounce;
  void *scratchbuf;
  u8 *setup\PYGZus{}buf;
  dma\PYGZus{}addr\PYGZus{}t ep0\PYGZus{}trb\PYGZus{}addr;
  dma\PYGZus{}addr\PYGZus{}t bounce\PYGZus{}addr;
  dma\PYGZus{}addr\PYGZus{}t scratch\PYGZus{}addr;
  struct dwc3\PYGZus{}request     ep0\PYGZus{}usb\PYGZus{}req;
  struct completion       ep0\PYGZus{}in\PYGZus{}setup;
  spinlock\PYGZus{}t lock;
  struct device           *dev;
  struct device           *sysdev;
  struct platform\PYGZus{}device  *xhci;
  struct resource         xhci\PYGZus{}resources[DWC3\PYGZus{}XHCI\PYGZus{}RESOURCES\PYGZus{}NUM];
  struct dwc3\PYGZus{}event\PYGZus{}buffer *ev\PYGZus{}buf;
  struct dwc3\PYGZus{}ep          *eps[DWC3\PYGZus{}ENDPOINTS\PYGZus{}NUM];
  struct usb\PYGZus{}gadget       gadget;
  struct usb\PYGZus{}gadget\PYGZus{}driver *gadget\PYGZus{}driver;
  struct usb\PYGZus{}phy          *usb2\PYGZus{}phy;
  struct usb\PYGZus{}phy          *usb3\PYGZus{}phy;
  struct phy              *usb2\PYGZus{}generic\PYGZus{}phy;
  struct phy              *usb3\PYGZus{}generic\PYGZus{}phy;
  bool phys\PYGZus{}ready;
  struct ulpi             *ulpi;
  bool ulpi\PYGZus{}ready;
  void \PYGZus{}\PYGZus{}iomem            *regs;
  size\PYGZus{}t regs\PYGZus{}size;
  enum usb\PYGZus{}dr\PYGZus{}mode        dr\PYGZus{}mode;
  u32 current\PYGZus{}dr\PYGZus{}role;
  u32 desired\PYGZus{}dr\PYGZus{}role;
  struct extcon\PYGZus{}dev       *edev;
  struct notifier\PYGZus{}block   edev\PYGZus{}nb;
  enum usb\PYGZus{}phy\PYGZus{}interface  hsphy\PYGZus{}mode;
  u32 fladj;
  u32 irq\PYGZus{}gadget;
  u32 nr\PYGZus{}scratch;
  u32 u1u2;
  u32 maximum\PYGZus{}speed;
  u32 revision;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}173A      0x5533173a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}175A      0x5533175a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}180A      0x5533180a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}183A      0x5533183a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}185A      0x5533185a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}187A      0x5533187a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}188A      0x5533188a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}190A      0x5533190a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}194A      0x5533194a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}200A      0x5533200a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}202A      0x5533202a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}210A      0x5533210a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}220A      0x5533220a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}230A      0x5533230a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}240A      0x5533240a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}250A      0x5533250a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}260A      0x5533260a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}270A      0x5533270a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}280A      0x5533280a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}290A      0x5533290a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}300A      0x5533300a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}310A      0x5533310a;
\PYGZsh{}define DWC3\PYGZus{}REVISION\PYGZus{}IS\PYGZus{}DWC31          0x80000000;
\PYGZsh{}define DWC3\PYGZus{}USB31\PYGZus{}REVISION\PYGZus{}110A        (0x3131302a \textbar{} DWC3\PYGZus{}REVISION\PYGZus{}IS\PYGZus{}DWC31);
\PYGZsh{}define DWC3\PYGZus{}USB31\PYGZus{}REVISION\PYGZus{}120A        (0x3132302a \textbar{} DWC3\PYGZus{}REVISION\PYGZus{}IS\PYGZus{}DWC31);
  enum dwc3\PYGZus{}ep0\PYGZus{}next      ep0\PYGZus{}next\PYGZus{}event;
  enum dwc3\PYGZus{}ep0\PYGZus{}state     ep0state;
  enum dwc3\PYGZus{}link\PYGZus{}state    link\PYGZus{}state;
  u16 u2sel;
  u16 u2pel;
  u8 u1sel;
  u8 u1pel;
  u8 speed;
  u8 num\PYGZus{}eps;
  struct dwc3\PYGZus{}hwparams    hwparams;
  struct dentry           *root;
  struct debugfs\PYGZus{}regset32 *regset;
  u8 test\PYGZus{}mode;
  u8 test\PYGZus{}mode\PYGZus{}nr;
  u8 lpm\PYGZus{}nyet\PYGZus{}threshold;
  u8 hird\PYGZus{}threshold;
  const char              *hsphy\PYGZus{}interface;
  unsigned connected:1;
  unsigned delayed\PYGZus{}status:1;
  unsigned ep0\PYGZus{}bounced:1;
  unsigned ep0\PYGZus{}expect\PYGZus{}in:1;
  unsigned has\PYGZus{}hibernation:1;
  unsigned sysdev\PYGZus{}is\PYGZus{}parent:1;
  unsigned has\PYGZus{}lpm\PYGZus{}erratum:1;
  unsigned is\PYGZus{}utmi\PYGZus{}l1\PYGZus{}suspend:1;
  unsigned is\PYGZus{}fpga:1;
  unsigned pending\PYGZus{}events:1;
  unsigned pullups\PYGZus{}connected:1;
  unsigned setup\PYGZus{}packet\PYGZus{}pending:1;
  unsigned three\PYGZus{}stage\PYGZus{}setup:1;
  unsigned usb3\PYGZus{}lpm\PYGZus{}capable:1;
  unsigned disable\PYGZus{}scramble\PYGZus{}quirk:1;
  unsigned u2exit\PYGZus{}lfps\PYGZus{}quirk:1;
  unsigned u2ss\PYGZus{}inp3\PYGZus{}quirk:1;
  unsigned req\PYGZus{}p1p2p3\PYGZus{}quirk:1;
  unsigned del\PYGZus{}p1p2p3\PYGZus{}quirk:1;
  unsigned del\PYGZus{}phy\PYGZus{}power\PYGZus{}chg\PYGZus{}quirk:1;
  unsigned lfps\PYGZus{}filter\PYGZus{}quirk:1;
  unsigned rx\PYGZus{}detect\PYGZus{}poll\PYGZus{}quirk:1;
  unsigned dis\PYGZus{}u3\PYGZus{}susphy\PYGZus{}quirk:1;
  unsigned dis\PYGZus{}u2\PYGZus{}susphy\PYGZus{}quirk:1;
  unsigned dis\PYGZus{}enblslpm\PYGZus{}quirk:1;
  unsigned dis\PYGZus{}rxdet\PYGZus{}inp3\PYGZus{}quirk:1;
  unsigned dis\PYGZus{}u2\PYGZus{}freeclk\PYGZus{}exists\PYGZus{}quirk:1;
  unsigned dis\PYGZus{}del\PYGZus{}phy\PYGZus{}power\PYGZus{}chg\PYGZus{}quirk:1;
  unsigned dis\PYGZus{}tx\PYGZus{}ipgap\PYGZus{}linecheck\PYGZus{}quirk:1;
  unsigned tx\PYGZus{}de\PYGZus{}emphasis\PYGZus{}quirk:1;
  unsigned tx\PYGZus{}de\PYGZus{}emphasis:2;
  unsigned dis\PYGZus{}metastability\PYGZus{}quirk:1;
  u16 imod\PYGZus{}interval;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{drd\_work}}] \leavevmode
workqueue used for role swapping

\item[{\code{ep0\_trb}}] \leavevmode
trb which is used for the ctrl\_req

\item[{\code{bounce}}] \leavevmode
address of bounce buffer

\item[{\code{scratchbuf}}] \leavevmode
address of scratch buffer

\item[{\code{setup\_buf}}] \leavevmode
used while precessing STD USB requests

\item[{\code{ep0\_trb\_addr}}] \leavevmode
dma address of \textbf{ep0\_trb}

\item[{\code{bounce\_addr}}] \leavevmode
dma address of \textbf{bounce}

\item[{\code{scratch\_addr}}] \leavevmode
dma address of scratchbuf

\item[{\code{ep0\_usb\_req}}] \leavevmode
dummy req used while handling STD USB requests

\item[{\code{ep0\_in\_setup}}] \leavevmode
one control transfer is completed and enter setup phase

\item[{\code{lock}}] \leavevmode
for synchronizing

\item[{\code{dev}}] \leavevmode
pointer to our struct device

\item[{\code{sysdev}}] \leavevmode
pointer to the DMA-capable device

\item[{\code{xhci}}] \leavevmode
pointer to our xHCI child

\item[{\code{xhci\_resources}}] \leavevmode
struct resources for our \textbf{xhci} child

\item[{\code{ev\_buf}}] \leavevmode
struct dwc3\_event\_buffer pointer

\item[{\code{eps}}] \leavevmode
endpoint array

\item[{\code{gadget}}] \leavevmode
device side representation of the peripheral controller

\item[{\code{gadget\_driver}}] \leavevmode
pointer to the gadget driver

\item[{\code{usb2\_phy}}] \leavevmode
pointer to USB2 PHY

\item[{\code{usb3\_phy}}] \leavevmode
pointer to USB3 PHY

\item[{\code{usb2\_generic\_phy}}] \leavevmode
pointer to USB2 PHY

\item[{\code{usb3\_generic\_phy}}] \leavevmode
pointer to USB3 PHY

\item[{\code{phys\_ready}}] \leavevmode
flag to indicate that PHYs are ready

\item[{\code{ulpi}}] \leavevmode
pointer to ulpi interface

\item[{\code{ulpi\_ready}}] \leavevmode
flag to indicate that ULPI is initialized

\item[{\code{regs}}] \leavevmode
base address for our registers

\item[{\code{regs\_size}}] \leavevmode
address space size

\item[{\code{dr\_mode}}] \leavevmode
requested mode of operation

\item[{\code{current\_dr\_role}}] \leavevmode
current role of operation when in dual-role mode

\item[{\code{desired\_dr\_role}}] \leavevmode
desired role of operation when in dual-role mode

\item[{\code{edev}}] \leavevmode
extcon handle

\item[{\code{edev\_nb}}] \leavevmode
extcon notifier

\item[{\code{hsphy\_mode}}] \leavevmode
UTMI phy mode, one of following:
- USBPHY\_INTERFACE\_MODE\_UTMI
- USBPHY\_INTERFACE\_MODE\_UTMIW

\item[{\code{fladj}}] \leavevmode
frame length adjustment

\item[{\code{irq\_gadget}}] \leavevmode
peripheral controller's IRQ number

\item[{\code{nr\_scratch}}] \leavevmode
number of scratch buffers

\item[{\code{u1u2}}] \leavevmode
only used on revisions \textless{}1.83a for workaround

\item[{\code{maximum\_speed}}] \leavevmode
maximum speed requested (mainly for testing purposes)

\item[{\code{revision}}] \leavevmode
revision register contents

\item[{\code{ep0\_next\_event}}] \leavevmode
hold the next expected event

\item[{\code{ep0state}}] \leavevmode
state of endpoint zero

\item[{\code{link\_state}}] \leavevmode
link state

\item[{\code{u2sel}}] \leavevmode
parameter from Set SEL request.

\item[{\code{u2pel}}] \leavevmode
parameter from Set SEL request.

\item[{\code{u1sel}}] \leavevmode
parameter from Set SEL request.

\item[{\code{u1pel}}] \leavevmode
parameter from Set SEL request.

\item[{\code{speed}}] \leavevmode
device speed (super, high, full, low)

\item[{\code{num\_eps}}] \leavevmode
number of endpoints

\item[{\code{hwparams}}] \leavevmode
copy of hwparams registers

\item[{\code{root}}] \leavevmode
debugfs root folder pointer

\item[{\code{regset}}] \leavevmode
debugfs pointer to regdump file

\item[{\code{test\_mode}}] \leavevmode
true when we're entering a USB test mode

\item[{\code{test\_mode\_nr}}] \leavevmode
test feature selector

\item[{\code{lpm\_nyet\_threshold}}] \leavevmode
LPM NYET response threshold

\item[{\code{hird\_threshold}}] \leavevmode
HIRD threshold

\item[{\code{hsphy\_interface}}] \leavevmode
``utmi'' or ``ulpi''

\item[{\code{connected}}] \leavevmode
true when we're connected to a host, false otherwise

\item[{\code{delayed\_status}}] \leavevmode
true when gadget driver asks for delayed status

\item[{\code{ep0\_bounced}}] \leavevmode
true when we used bounce buffer

\item[{\code{ep0\_expect\_in}}] \leavevmode
true when we expect a DATA IN transfer

\item[{\code{has\_hibernation}}] \leavevmode
true when dwc3 was configured with Hibernation

\item[{\code{sysdev\_is\_parent}}] \leavevmode
true when dwc3 device has a parent driver

\item[{\code{has\_lpm\_erratum}}] \leavevmode
true when core was configured with LPM Erratum. Note that
there's now way for software to detect this in runtime.

\item[{\code{is\_utmi\_l1\_suspend}}] \leavevmode
the core asserts output signal
0       - utmi\_sleep\_n
1       - utmi\_l1\_suspend\_n

\item[{\code{is\_fpga}}] \leavevmode
true when we are using the FPGA board

\item[{\code{pending\_events}}] \leavevmode
true when we have pending IRQs to be handled

\item[{\code{pullups\_connected}}] \leavevmode
true when Run/Stop bit is set

\item[{\code{setup\_packet\_pending}}] \leavevmode
true when there's a Setup Packet in FIFO. Workaround

\item[{\code{three\_stage\_setup}}] \leavevmode
set if we perform a three phase setup

\item[{\code{usb3\_lpm\_capable}}] \leavevmode
set if hadrware supports Link Power Management

\item[{\code{disable\_scramble\_quirk}}] \leavevmode
set if we enable the disable scramble quirk

\item[{\code{u2exit\_lfps\_quirk}}] \leavevmode
set if we enable u2exit lfps quirk

\item[{\code{u2ss\_inp3\_quirk}}] \leavevmode
set if we enable P3 OK for U2/SS Inactive quirk

\item[{\code{req\_p1p2p3\_quirk}}] \leavevmode
set if we enable request p1p2p3 quirk

\item[{\code{del\_p1p2p3\_quirk}}] \leavevmode
set if we enable delay p1p2p3 quirk

\item[{\code{del\_phy\_power\_chg\_quirk}}] \leavevmode
set if we enable delay phy power change quirk

\item[{\code{lfps\_filter\_quirk}}] \leavevmode
set if we enable LFPS filter quirk

\item[{\code{rx\_detect\_poll\_quirk}}] \leavevmode
set if we enable rx\_detect to polling lfps quirk

\item[{\code{dis\_u3\_susphy\_quirk}}] \leavevmode
set if we disable usb3 suspend phy

\item[{\code{dis\_u2\_susphy\_quirk}}] \leavevmode
set if we disable usb2 suspend phy

\item[{\code{dis\_enblslpm\_quirk}}] \leavevmode
set if we clear enblslpm in GUSB2PHYCFG,
disabling the suspend signal to the PHY.

\item[{\code{dis\_rxdet\_inp3\_quirk}}] \leavevmode
set if we disable Rx.Detect in P3

\item[{\code{dis\_u2\_freeclk\_exists\_quirk}}] \leavevmode
set if we clear u2\_freeclk\_exists
in GUSB2PHYCFG, specify that USB2 PHY doesn't
provide a free-running PHY clock.

\item[{\code{dis\_del\_phy\_power\_chg\_quirk}}] \leavevmode
set if we disable delay phy power
change quirk.

\item[{\code{dis\_tx\_ipgap\_linecheck\_quirk}}] \leavevmode
set if we disable u2mac linestate
check during HS transmit.

\item[{\code{tx\_de\_emphasis\_quirk}}] \leavevmode
set if we enable Tx de-emphasis quirk

\item[{\code{tx\_de\_emphasis}}] \leavevmode
Tx de-emphasis value
0       - -6dB de-emphasis
1       - -3.5dB de-emphasis
2       - No de-emphasis
3       - Reserved

\item[{\code{dis\_metastability\_quirk}}] \leavevmode
set to disable metastability quirk.

\item[{\code{imod\_interval}}] \leavevmode
set the interrupt moderation interval in 250ns
increments or 0 to disable.

\end{description}
\index{dwc3\_event\_depevt (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_event_depevt}\pysigline{struct \bfcode{dwc3\_event\_depevt}}
Device Endpoint Events

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dwc3\PYGZus{}event\PYGZus{}depevt \PYGZob{}
  u32 one\PYGZus{}bit:1;
  u32 endpoint\PYGZus{}number:5;
  u32 endpoint\PYGZus{}event:4;
  u32 reserved11\PYGZus{}10:2;
  u32 status:4;
\PYGZsh{}define DEPEVT\PYGZus{}STATUS\PYGZus{}TRANSFER\PYGZus{}ACTIVE   BIT(3);
\PYGZsh{}define DEPEVT\PYGZus{}STATUS\PYGZus{}BUSERR    BIT(0);
\PYGZsh{}define DEPEVT\PYGZus{}STATUS\PYGZus{}SHORT     BIT(1);
\PYGZsh{}define DEPEVT\PYGZus{}STATUS\PYGZus{}IOC       BIT(2);
\PYGZsh{}define DEPEVT\PYGZus{}STATUS\PYGZus{}LST       BIT(3);
\PYGZsh{}define DEPEVT\PYGZus{}STREAMEVT\PYGZus{}FOUND          1;
\PYGZsh{}define DEPEVT\PYGZus{}STREAMEVT\PYGZus{}NOTFOUND       2;
\PYGZsh{}define DEPEVT\PYGZus{}STATUS\PYGZus{}CONTROL\PYGZus{}DATA      1;
\PYGZsh{}define DEPEVT\PYGZus{}STATUS\PYGZus{}CONTROL\PYGZus{}STATUS    2;
\PYGZsh{}define DEPEVT\PYGZus{}STATUS\PYGZus{}CONTROL\PYGZus{}PHASE(n)  ((n) \PYGZam{} 3);
\PYGZsh{}define DEPEVT\PYGZus{}TRANSFER\PYGZus{}NO\PYGZus{}RESOURCE     1;
\PYGZsh{}define DEPEVT\PYGZus{}TRANSFER\PYGZus{}BUS\PYGZus{}EXPIRY      2;
  u32 parameters:16;
\PYGZsh{}define DEPEVT\PYGZus{}PARAMETER\PYGZus{}CMD(n) (((n) \PYGZam{} (0xf \PYGZlt{}\PYGZlt{} 8)) \PYGZgt{}\PYGZgt{} 8);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{one\_bit}}] \leavevmode
indicates this is an endpoint event (not used)

\item[{\code{endpoint\_number}}] \leavevmode
number of the endpoint

\item[{\code{endpoint\_event}}] \leavevmode
The event we have:
0x00    - Reserved
0x01    - XferComplete
0x02    - XferInProgress
0x03    - XferNotReady
0x04    - RxTxFifoEvt (IN-\textgreater{}Underrun, OUT-\textgreater{}Overrun)
0x05    - Reserved
0x06    - StreamEvt
0x07    - EPCmdCmplt

\item[{\code{reserved11\_10}}] \leavevmode
Reserved, don't use.

\item[{\code{status}}] \leavevmode
Indicates the status of the event. Refer to databook for
more information.

\item[{\code{parameters}}] \leavevmode
Parameters of the current event. Refer to databook for
more information.

\end{description}
\index{dwc3\_event\_devt (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_event_devt}\pysigline{struct \bfcode{dwc3\_event\_devt}}
Device Events

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dwc3\PYGZus{}event\PYGZus{}devt \PYGZob{}
  u32 one\PYGZus{}bit:1;
  u32 device\PYGZus{}event:7;
  u32 type:4;
  u32 reserved15\PYGZus{}12:4;
  u32 event\PYGZus{}info:9;
  u32 reserved31\PYGZus{}25:7;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{one\_bit}}] \leavevmode
indicates this is a non-endpoint event (not used)

\item[{\code{device\_event}}] \leavevmode
indicates it's a device event. Should read as 0x00

\item[{\code{type}}] \leavevmode
indicates the type of device event.
0       - DisconnEvt
1       - USBRst
2       - ConnectDone
3       - ULStChng
4       - WkUpEvt
5       - Reserved
6       - EOPF
7       - SOF
8       - Reserved
9       - ErrticErr
10      - CmdCmplt
11      - EvntOverflow
12      - VndrDevTstRcved

\item[{\code{reserved15\_12}}] \leavevmode
Reserved, not used

\item[{\code{event\_info}}] \leavevmode
Information about this event

\item[{\code{reserved31\_25}}] \leavevmode
Reserved, not used

\end{description}
\index{dwc3\_event\_gevt (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_event_gevt}\pysigline{struct \bfcode{dwc3\_event\_gevt}}
Other Core Events

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dwc3\PYGZus{}event\PYGZus{}gevt \PYGZob{}
  u32 one\PYGZus{}bit:1;
  u32 device\PYGZus{}event:7;
  u32 phy\PYGZus{}port\PYGZus{}number:4;
  u32 reserved31\PYGZus{}12:20;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{one\_bit}}] \leavevmode
indicates this is a non-endpoint event (not used)

\item[{\code{device\_event}}] \leavevmode
indicates it's (0x03) Carkit or (0x04) I2C event.

\item[{\code{phy\_port\_number}}] \leavevmode
self-explanatory

\item[{\code{reserved31\_12}}] \leavevmode
Reserved, not used.

\end{description}
\index{dwc3\_event (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_event}\pysigline{union \bfcode{dwc3\_event}}
representation of Event Buffer contents

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
union dwc3\PYGZus{}event \PYGZob{}
  u32 raw;
  struct dwc3\PYGZus{}event\PYGZus{}type          type;
  struct dwc3\PYGZus{}event\PYGZus{}depevt        depevt;
  struct dwc3\PYGZus{}event\PYGZus{}devt          devt;
  struct dwc3\PYGZus{}event\PYGZus{}gevt          gevt;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{raw}}] \leavevmode
raw 32-bit event

\item[{\code{type}}] \leavevmode
the type of the event

\item[{\code{depevt}}] \leavevmode
Device Endpoint Event

\item[{\code{devt}}] \leavevmode
Device Event

\item[{\code{gevt}}] \leavevmode
Global Event

\end{description}
\index{dwc3\_gadget\_ep\_cmd\_params (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_gadget_ep_cmd_params}\pysigline{struct \bfcode{dwc3\_gadget\_ep\_cmd\_params}}
representation of endpoint command parameters

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dwc3\PYGZus{}gadget\PYGZus{}ep\PYGZus{}cmd\PYGZus{}params \PYGZob{}
  u32 param2;
  u32 param1;
  u32 param0;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{param2}}] \leavevmode
third parameter

\item[{\code{param1}}] \leavevmode
second parameter

\item[{\code{param0}}] \leavevmode
first parameter

\end{description}
\index{next\_request (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.next_request}\pysiglinewithargsret{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_request]{\emph{dwc3\_request}}} * \bfcode{next\_request}}{struct list\_head *\emph{ list}}{}
gets the next request on the given list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct list\_head * list}}] \leavevmode
the request list to operate on

\end{description}

\textbf{Description}

Caller should take care of locking. This function return \code{NULL} or the first
request available on \textbf{list}.
\index{dwc3\_gadget\_move\_started\_request (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_gadget_move_started_request}\pysiglinewithargsret{void \bfcode{dwc3\_gadget\_move\_started\_request}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_request]{\emph{dwc3\_request}}} *\emph{ req}}{}
move \textbf{req} to the started\_list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3\_request * req}}] \leavevmode
the request to be moved

\end{description}

\textbf{Description}

Caller should take care of locking. This function will move \textbf{req} from its
current list to the endpoint's started\_list.
\index{dwc3\_gadget\_ep\_get\_transfer\_index (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_gadget_ep_get_transfer_index}\pysiglinewithargsret{u32 \bfcode{dwc3\_gadget\_ep\_get\_transfer\_index}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_ep]{\emph{dwc3\_ep}}} *\emph{ dep}}{}
Gets transfer index from HW

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3\_ep * dep}}] \leavevmode
dwc3 endpoint

\end{description}

\textbf{Description}

Caller should take care of locking. Returns the transfer resource
index for a given endpoint.
\index{dwc3\_gadget\_set\_test\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_gadget_set_test_mode}\pysiglinewithargsret{int \bfcode{dwc3\_gadget\_set\_test\_mode}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3]{\emph{dwc3}}} *\emph{ dwc}, int\emph{ mode}}{}
enables usb2 test modes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3 * dwc}}] \leavevmode
pointer to our context structure

\item[{\code{int mode}}] \leavevmode
the mode to set (J, K SE0 NAK, Force Enable)

\end{description}

\textbf{Description}

Caller should take care of locking. This function will return 0 on
success or -EINVAL if wrong Test Selector is passed.
\index{dwc3\_gadget\_get\_link\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_gadget_get_link_state}\pysiglinewithargsret{int \bfcode{dwc3\_gadget\_get\_link\_state}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3]{\emph{dwc3}}} *\emph{ dwc}}{}
gets current state of usb link

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3 * dwc}}] \leavevmode
pointer to our context structure

\end{description}

\textbf{Description}

Caller should take care of locking. This function will
return the link state on success (\textgreater{}= 0) or -ETIMEDOUT.
\index{dwc3\_gadget\_set\_link\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_gadget_set_link_state}\pysiglinewithargsret{int \bfcode{dwc3\_gadget\_set\_link\_state}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3]{\emph{dwc3}}} *\emph{ dwc}, enum dwc3\_link\_state\emph{ state}}{}
sets usb link to a particular state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3 * dwc}}] \leavevmode
pointer to our context structure

\item[{\code{enum dwc3\_link\_state state}}] \leavevmode
the state to put link into

\end{description}

\textbf{Description}

Caller should take care of locking. This function will
return 0 on success or -ETIMEDOUT.
\index{dwc3\_ep\_inc\_trb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_ep_inc_trb}\pysiglinewithargsret{void \bfcode{dwc3\_ep\_inc\_trb}}{u8 *\emph{ index}}{}
increment a trb index.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 * index}}] \leavevmode
Pointer to the TRB index to increment.

\end{description}

\textbf{Description}

The index should never point to the link TRB. After incrementing,
if it is point to the link TRB, wrap around to the beginning. The
link TRB is always at the last TRB entry.
\index{dwc3\_ep\_inc\_enq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_ep_inc_enq}\pysiglinewithargsret{void \bfcode{dwc3\_ep\_inc\_enq}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_ep]{\emph{dwc3\_ep}}} *\emph{ dep}}{}
increment endpoint's enqueue pointer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3\_ep * dep}}] \leavevmode
The endpoint whose enqueue pointer we're incrementing

\end{description}
\index{dwc3\_ep\_inc\_deq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_ep_inc_deq}\pysiglinewithargsret{void \bfcode{dwc3\_ep\_inc\_deq}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_ep]{\emph{dwc3\_ep}}} *\emph{ dep}}{}
increment endpoint's dequeue pointer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3\_ep * dep}}] \leavevmode
The endpoint whose enqueue pointer we're incrementing

\end{description}
\index{dwc3\_gadget\_giveback (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_gadget_giveback}\pysiglinewithargsret{void \bfcode{dwc3\_gadget\_giveback}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_ep]{\emph{dwc3\_ep}}} *\emph{ dep}, struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_request]{\emph{dwc3\_request}}} *\emph{ req}, int\emph{ status}}{}
call struct usb\_request's -\textgreater{}complete callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3\_ep * dep}}] \leavevmode
The endpoint to whom the request belongs to

\item[{\code{struct dwc3\_request * req}}] \leavevmode
The request we're giving back

\item[{\code{int status}}] \leavevmode
completion code for the request

\end{description}

\textbf{Description}

Must be called with controller's lock held and interrupts disabled. This
function will unmap \textbf{req} and call its -\textgreater{}:c:func:\emph{complete()} callback to notify upper
layers that it has completed.
\index{dwc3\_send\_gadget\_generic\_command (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_send_gadget_generic_command}\pysiglinewithargsret{int \bfcode{dwc3\_send\_gadget\_generic\_command}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3]{\emph{dwc3}}} *\emph{ dwc}, unsigned\emph{ cmd}, u32\emph{ param}}{}
issue a generic command for the controller

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3 * dwc}}] \leavevmode
pointer to the controller context

\item[{\code{unsigned cmd}}] \leavevmode
the command to be issued

\item[{\code{u32 param}}] \leavevmode
command parameter

\end{description}

\textbf{Description}

Caller should take care of locking. Issue \textbf{cmd} with a given \textbf{param} to \textbf{dwc}
and wait for its completion.
\index{dwc3\_send\_gadget\_ep\_cmd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_send_gadget_ep_cmd}\pysiglinewithargsret{int \bfcode{dwc3\_send\_gadget\_ep\_cmd}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_ep]{\emph{dwc3\_ep}}} *\emph{ dep}, unsigned\emph{ cmd}, struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_gadget_ep_cmd_params]{\emph{dwc3\_gadget\_ep\_cmd\_params}}} *\emph{ params}}{}
issue an endpoint command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3\_ep * dep}}] \leavevmode
the endpoint to which the command is going to be issued

\item[{\code{unsigned cmd}}] \leavevmode
the command to be issued

\item[{\code{struct dwc3\_gadget\_ep\_cmd\_params * params}}] \leavevmode
parameters to the command

\end{description}

\textbf{Description}

Caller should handle locking. This function will issue \textbf{cmd} with given
\textbf{params} to \textbf{dep} and wait for its completion.
\index{dwc3\_gadget\_start\_config (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_gadget_start_config}\pysiglinewithargsret{int \bfcode{dwc3\_gadget\_start\_config}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3]{\emph{dwc3}}} *\emph{ dwc}, struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_ep]{\emph{dwc3\_ep}}} *\emph{ dep}}{}
configure ep resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3 * dwc}}] \leavevmode
pointer to our controller context structure

\item[{\code{struct dwc3\_ep * dep}}] \leavevmode
endpoint that is being enabled

\end{description}

\textbf{Description}

Issue a \code{DWC3\_DEPCMD\_DEPSTARTCFG} command to \textbf{dep}. After the command's
completion, it will set Transfer Resource for all available endpoints.

The assignment of transfer resources cannot perfectly follow the data book
due to the fact that the controller driver does not have all knowledge of the
configuration in advance. It is given this information piecemeal by the
composite gadget framework after every SET\_CONFIGURATION and
SET\_INTERFACE. Trying to follow the databook programming model in this
scenario can cause errors. For two reasons:

1) The databook says to do \code{DWC3\_DEPCMD\_DEPSTARTCFG} for every
\code{USB\_REQ\_SET\_CONFIGURATION} and \code{USB\_REQ\_SET\_INTERFACE} (8.1.5). This is
incorrect in the scenario of multiple interfaces.

2) The databook does not mention doing more \code{DWC3\_DEPCMD\_DEPXFERCFG} for new
endpoint on alt setting (8.1.6).

The following simplified method is used instead:

All hardware endpoints can be assigned a transfer resource and this setting
will stay persistent until either a core reset or hibernation. So whenever we
do a \code{DWC3\_DEPCMD\_DEPSTARTCFG{}`{}`(0) we can go ahead and do
{}`{}`DWC3\_DEPCMD\_DEPXFERCFG} for every hardware endpoint as well. We are
guaranteed that there are as many transfer resources as endpoints.

This function is called for each endpoint when it is being enabled but is
triggered only when called for EP0-out, which always happens first, and which
should only happen in one of the above conditions.
\index{\_\_dwc3\_gadget\_ep\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.__dwc3_gadget_ep_enable}\pysiglinewithargsret{int \bfcode{\_\_dwc3\_gadget\_ep\_enable}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_ep]{\emph{dwc3\_ep}}} *\emph{ dep}, bool\emph{ modify}, bool\emph{ restore}}{}
initializes a hw endpoint

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3\_ep * dep}}] \leavevmode
endpoint to be initialized

\item[{\code{bool modify}}] \leavevmode
if true, modify existing endpoint configuration

\item[{\code{bool restore}}] \leavevmode
if true, restore endpoint configuration from scratch buffer

\end{description}

\textbf{Description}

Caller should take care of locking. Execute all necessary commands to
initialize a HW endpoint so it can be used by a gadget driver.
\index{\_\_dwc3\_gadget\_ep\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.__dwc3_gadget_ep_disable}\pysiglinewithargsret{int \bfcode{\_\_dwc3\_gadget\_ep\_disable}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_ep]{\emph{dwc3\_ep}}} *\emph{ dep}}{}
disables a hw endpoint

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3\_ep * dep}}] \leavevmode
the endpoint to disable

\end{description}

\textbf{Description}

This function undoes what \_\_dwc3\_gadget\_ep\_enable did and also removes
requests which are currently being processed by the hardware and those which
are not yet scheduled.

Caller should take care of locking.
\index{dwc3\_prepare\_one\_trb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_prepare_one_trb}\pysiglinewithargsret{void \bfcode{dwc3\_prepare\_one\_trb}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_ep]{\emph{dwc3\_ep}}} *\emph{ dep}, struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_request]{\emph{dwc3\_request}}} *\emph{ req}, unsigned\emph{ chain}, unsigned\emph{ node}}{}
setup one TRB from one request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3\_ep * dep}}] \leavevmode
endpoint for which this request is prepared

\item[{\code{struct dwc3\_request * req}}] \leavevmode
dwc3\_request pointer

\item[{\code{unsigned chain}}] \leavevmode
should this TRB be chained to the next?

\item[{\code{unsigned node}}] \leavevmode
only for isochronous endpoints. First TRB needs different type.

\end{description}
\index{dwc3\_ep\_prev\_trb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_ep_prev_trb}\pysiglinewithargsret{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_trb]{\emph{dwc3\_trb}}} * \bfcode{dwc3\_ep\_prev\_trb}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_ep]{\emph{dwc3\_ep}}} *\emph{ dep}, u8\emph{ index}}{}
returns the previous TRB in the ring

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3\_ep * dep}}] \leavevmode
The endpoint with the TRB ring

\item[{\code{u8 index}}] \leavevmode
The index of the current TRB in the ring

\end{description}

\textbf{Description}

Returns the TRB prior to the one pointed to by the index. If the
index is 0, we will wrap backwards, skip the link TRB, and return
the one just before that.
\index{dwc3\_gadget\_setup\_nump (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_gadget_setup_nump}\pysiglinewithargsret{void \bfcode{dwc3\_gadget\_setup\_nump}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3]{\emph{dwc3}}} *\emph{ dwc}}{}
calculate and initialize NUMP field of \code{DWC3\_DCFG}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3 * dwc}}] \leavevmode
pointer to our context structure

\end{description}

\textbf{Description}

The following looks like complex but it's actually very simple. In order to
calculate the number of packets we can burst at once on OUT transfers, we're
gonna use RxFIFO size.

To calculate RxFIFO size we need two numbers:
MDWIDTH = size, in bits, of the internal memory bus
RAM2\_DEPTH = depth, in MDWIDTH, of internal RAM2 (where RxFIFO sits)

Given these two numbers, the formula is simple:

RxFIFO Size = (RAM2\_DEPTH * MDWIDTH / 8) - 24 - 16;

24 bytes is for 3x SETUP packets
16 bytes is a clock domain crossing tolerance

Given RxFIFO Size, NUMP = RxFIFOSize / 1024;
\index{dwc3\_gadget\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_gadget_init}\pysiglinewithargsret{int \bfcode{dwc3\_gadget\_init}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3]{\emph{dwc3}}} *\emph{ dwc}}{}
initializes gadget related registers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3 * dwc}}] \leavevmode
pointer to our controller context structure

\end{description}

\textbf{Description}

Returns 0 on success otherwise negative errno.
\index{DWC3\_DEFAULT\_AUTOSUSPEND\_DELAY (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.DWC3_DEFAULT_AUTOSUSPEND_DELAY}\pysiglinewithargsret{\bfcode{DWC3\_DEFAULT\_AUTOSUSPEND\_DELAY}}{}{}
DesignWare USB3 DRD Controller Core file

\end{fulllineitems}


\textbf{Parameters}

\textbf{Description}

Copyright (C) 2010-2011 Texas Instruments Incorporated - \href{http://www.ti.com}{http://www.ti.com}
\begin{description}
\item[{Authors: Felipe Balbi \textless{}balbi**ti.com**\textgreater{},}] \leavevmode
Sebastian Andrzej Siewior \textless{}bigeasy**linutronix.de**\textgreater{}

\end{description}
\index{dwc3\_get\_dr\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_get_dr_mode}\pysiglinewithargsret{int \bfcode{dwc3\_get\_dr\_mode}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3]{\emph{dwc3}}} *\emph{ dwc}}{}
Validates and sets dr\_mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3 * dwc}}] \leavevmode
pointer to our context structure

\end{description}
\index{dwc3\_core\_soft\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_core_soft_reset}\pysiglinewithargsret{int \bfcode{dwc3\_core\_soft\_reset}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3]{\emph{dwc3}}} *\emph{ dwc}}{}
Issues core soft reset and PHY reset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3 * dwc}}] \leavevmode
pointer to our context structure

\end{description}
\index{dwc3\_free\_one\_event\_buffer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_free_one_event_buffer}\pysiglinewithargsret{void \bfcode{dwc3\_free\_one\_event\_buffer}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3]{\emph{dwc3}}} *\emph{ dwc}, struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_event_buffer]{\emph{dwc3\_event\_buffer}}} *\emph{ evt}}{}
Frees one event buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3 * dwc}}] \leavevmode
Pointer to our controller context structure

\item[{\code{struct dwc3\_event\_buffer * evt}}] \leavevmode
Pointer to event buffer to be freed

\end{description}
\index{dwc3\_alloc\_one\_event\_buffer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_alloc_one_event_buffer}\pysiglinewithargsret{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3_event_buffer]{\emph{dwc3\_event\_buffer}}} * \bfcode{dwc3\_alloc\_one\_event\_buffer}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3]{\emph{dwc3}}} *\emph{ dwc}, unsigned\emph{ length}}{}
Allocates one event buffer structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3 * dwc}}] \leavevmode
Pointer to our controller context structure

\item[{\code{unsigned length}}] \leavevmode
size of the event buffer

\end{description}

\textbf{Description}

Returns a pointer to the allocated event buffer structure on success
otherwise ERR\_PTR(errno).
\index{dwc3\_free\_event\_buffers (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_free_event_buffers}\pysiglinewithargsret{void \bfcode{dwc3\_free\_event\_buffers}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3]{\emph{dwc3}}} *\emph{ dwc}}{}
frees all allocated event buffers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3 * dwc}}] \leavevmode
Pointer to our controller context structure

\end{description}
\index{dwc3\_alloc\_event\_buffers (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_alloc_event_buffers}\pysiglinewithargsret{int \bfcode{dwc3\_alloc\_event\_buffers}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3]{\emph{dwc3}}} *\emph{ dwc}, unsigned\emph{ length}}{}
Allocates \textbf{num} event buffers of size \textbf{length}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3 * dwc}}] \leavevmode
pointer to our controller context structure

\item[{\code{unsigned length}}] \leavevmode
size of event buffer

\end{description}

\textbf{Description}

Returns 0 on success otherwise negative errno. In the error case, dwc
may contain some buffers allocated but not all which were requested.
\index{dwc3\_event\_buffers\_setup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_event_buffers_setup}\pysiglinewithargsret{int \bfcode{dwc3\_event\_buffers\_setup}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3]{\emph{dwc3}}} *\emph{ dwc}}{}
setup our allocated event buffers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3 * dwc}}] \leavevmode
pointer to our controller context structure

\end{description}

\textbf{Description}

Returns 0 on success otherwise negative errno.
\index{dwc3\_phy\_setup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_phy_setup}\pysiglinewithargsret{int \bfcode{dwc3\_phy\_setup}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3]{\emph{dwc3}}} *\emph{ dwc}}{}
Configure USB PHY Interface of DWC3 Core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3 * dwc}}] \leavevmode
Pointer to our controller context structure

\end{description}

\textbf{Description}

Returns 0 on success. The USB PHY interfaces are configured but not
initialized. The PHY interfaces and the PHYs get initialized together with
the core in dwc3\_core\_init.
\index{dwc3\_core\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/dwc3:c.dwc3_core_init}\pysiglinewithargsret{int \bfcode{dwc3\_core\_init}}{struct {\hyperref[driver\string-api/usb/dwc3:c.dwc3]{\emph{dwc3}}} *\emph{ dwc}}{}
Low-level initialization of DWC3 Core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dwc3 * dwc}}] \leavevmode
Pointer to our controller context structure

\end{description}

\textbf{Description}

Returns 0 on success otherwise negative errno.


\section{Writing a MUSB Glue Layer}
\label{driver-api/usb/writing_musb_glue_layer::doc}\label{driver-api/usb/writing_musb_glue_layer:writing-a-musb-glue-layer}\label{driver-api/usb/writing_musb_glue_layer:linux-usb}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Apelete Seketeli

\end{description}\end{quote}


\subsection{Introduction}
\label{driver-api/usb/writing_musb_glue_layer:introduction}
The Linux MUSB subsystem is part of the larger Linux USB subsystem. It
provides support for embedded USB Device Controllers (UDC) that do not
use Universal Host Controller Interface (UHCI) or Open Host Controller
Interface (OHCI).

Instead, these embedded UDC rely on the USB On-the-Go (OTG)
specification which they implement at least partially. The silicon
reference design used in most cases is the Multipoint USB Highspeed
Dual-Role Controller (MUSB HDRC) found in the Mentor Graphics Inventra™
design.

As a self-taught exercise I have written an MUSB glue layer for the
Ingenic JZ4740 SoC, modelled after the many MUSB glue layers in the
kernel source tree. This layer can be found at
\code{drivers/usb/musb/jz4740.c}. In this documentation I will walk through the
basics of the \code{jz4740.c} glue layer, explaining the different pieces and
what needs to be done in order to write your own device glue layer.


\subsection{Linux MUSB Basics}
\label{driver-api/usb/writing_musb_glue_layer:linux-musb-basics}\label{driver-api/usb/writing_musb_glue_layer:musb-basics}
To get started on the topic, please read USB On-the-Go Basics (see
Resources) which provides an introduction of USB OTG operation at the
hardware level. A couple of wiki pages by Texas Instruments and Analog
Devices also provide an overview of the Linux kernel MUSB configuration,
albeit focused on some specific devices provided by these companies.
Finally, getting acquainted with the USB specification at USB home page
may come in handy, with practical instance provided through the Writing
USB Device Drivers documentation (again, see Resources).

Linux USB stack is a layered architecture in which the MUSB controller
hardware sits at the lowest. The MUSB controller driver abstract the
MUSB controller hardware to the Linux USB stack:

\begin{Verbatim}[commandchars=\\\{\}]
    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
    \textbar{}                      \textbar{} \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} drivers/usb/gadget
    \textbar{} Linux USB Core Stack \textbar{} \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} drivers/usb/host
    \textbar{}                      \textbar{} \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} drivers/usb/core
    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
               ⬍
   \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
   \textbar{}                        \textbar{} \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} drivers/usb/musb/musb\PYGZus{}gadget.c
   \textbar{} MUSB Controller driver \textbar{} \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} drivers/usb/musb/musb\PYGZus{}host.c
   \textbar{}                        \textbar{} \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} drivers/usb/musb/musb\PYGZus{}core.c
   \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
               ⬍
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\textbar{} MUSB Platform Specific Driver \textbar{}
\textbar{}                               \textbar{} \PYGZlt{}\PYGZhy{}\PYGZhy{} drivers/usb/musb/jz4740.c
\textbar{}       aka \PYGZdq{}Glue Layer\PYGZdq{}        \textbar{}
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
               ⬍
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\textbar{}   MUSB Controller Hardware    \textbar{}
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\end{Verbatim}

As outlined above, the glue layer is actually the platform specific code
sitting in between the controller driver and the controller hardware.

Just like a Linux USB driver needs to register itself with the Linux USB
subsystem, the MUSB glue layer needs first to register itself with the
MUSB controller driver. This will allow the controller driver to know
about which device the glue layer supports and which functions to call
when a supported device is detected or released; remember we are talking
about an embedded controller chip here, so no insertion or removal at
run-time.

All of this information is passed to the MUSB controller driver through
a \code{platform\_driver} structure defined in the glue layer as:

\begin{Verbatim}[commandchars=\\\{\}]
static struct platform\PYGZus{}driver jz4740\PYGZus{}driver = \PYGZob{}
    .probe      = jz4740\PYGZus{}probe,
    .remove     = jz4740\PYGZus{}remove,
    .driver     = \PYGZob{}
        .name   = \PYGZdq{}musb\PYGZhy{}jz4740\PYGZdq{},
    \PYGZcb{},
\PYGZcb{};
\end{Verbatim}

The probe and remove function pointers are called when a matching device
is detected and, respectively, released. The name string describes the
device supported by this glue layer. In the current case it matches a
platform\_device structure declared in \code{arch/mips/jz4740/platform.c}. Note
that we are not using device tree bindings here.

In order to register itself to the controller driver, the glue layer
goes through a few steps, basically allocating the controller hardware
resources and initialising a couple of circuits. To do so, it needs to
keep track of the information used throughout these steps. This is done
by defining a private \code{jz4740\_glue} structure:

\begin{Verbatim}[commandchars=\\\{\}]
struct jz4740\PYGZus{}glue \PYGZob{}
    struct device           *dev;
    struct platform\PYGZus{}device  *musb;
    struct clk      *clk;
\PYGZcb{};
\end{Verbatim}

The dev and musb members are both device structure variables. The first
one holds generic information about the device, since it's the basic
device structure, and the latter holds information more closely related
to the subsystem the device is registered to. The clk variable keeps
information related to the device clock operation.

Let's go through the steps of the probe function that leads the glue
layer to register itself to the controller driver.

\begin{notice}{note}{Note:}
For the sake of readability each function will be split in logical
parts, each part being shown as if it was independent from the others.
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{jz4740\PYGZus{}probe}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{platform\PYGZus{}device} \PYG{o}{*}\PYG{n}{pdev}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{struct} \PYG{n}{platform\PYGZus{}device}      \PYG{o}{*}\PYG{n}{musb}\PYG{p}{;}
    \PYG{k}{struct} \PYG{n}{jz4740\PYGZus{}glue}      \PYG{o}{*}\PYG{n}{glue}\PYG{p}{;}
    \PYG{k}{struct} \PYG{n}{clk}                      \PYG{o}{*}\PYG{n}{clk}\PYG{p}{;}
    \PYG{k+kt}{int}             \PYG{n}{ret}\PYG{p}{;}

    \PYG{n}{glue} \PYG{o}{=} \PYG{n}{devm\PYGZus{}kzalloc}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{pdev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dev}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{o}{*}\PYG{n}{glue}\PYG{p}{)}\PYG{p}{,} \PYG{n}{GFP\PYGZus{}KERNEL}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{glue}\PYG{p}{)}
        \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{n}{ENOMEM}\PYG{p}{;}

    \PYG{n}{musb} \PYG{o}{=} \PYG{n}{platform\PYGZus{}device\PYGZus{}alloc}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{musb\PYGZhy{}hdrc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{PLATFORM\PYGZus{}DEVID\PYGZus{}AUTO}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{musb}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{dev\PYGZus{}err}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{pdev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dev}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{failed to allocate musb device}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{n}{ENOMEM}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{clk} \PYG{o}{=} \PYG{n}{devm\PYGZus{}clk\PYGZus{}get}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{pdev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dev}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{udc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{IS\PYGZus{}ERR}\PYG{p}{(}\PYG{n}{clk}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{dev\PYGZus{}err}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{pdev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dev}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{failed to get clock}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ret} \PYG{o}{=} \PYG{n}{PTR\PYGZus{}ERR}\PYG{p}{(}\PYG{n}{clk}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{goto} \PYG{n}{err\PYGZus{}platform\PYGZus{}device\PYGZus{}put}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{ret} \PYG{o}{=} \PYG{n}{clk\PYGZus{}prepare\PYGZus{}enable}\PYG{p}{(}\PYG{n}{clk}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{ret}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{dev\PYGZus{}err}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{pdev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dev}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{failed to enable clock}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{goto} \PYG{n}{err\PYGZus{}platform\PYGZus{}device\PYGZus{}put}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dev}\PYG{p}{.}\PYG{n}{parent}        \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{pdev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dev}\PYG{p}{;}

    \PYG{n}{glue}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dev}           \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{pdev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dev}\PYG{p}{;}
    \PYG{n}{glue}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{musb}          \PYG{o}{=} \PYG{n}{musb}\PYG{p}{;}
    \PYG{n}{glue}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{clk}           \PYG{o}{=} \PYG{n}{clk}\PYG{p}{;}

    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{n+nl}{err\PYGZus{}platform\PYGZus{}device\PYGZus{}put}\PYG{p}{:}
    \PYG{n}{platform\PYGZus{}device\PYGZus{}put}\PYG{p}{(}\PYG{n}{musb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{ret}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The first few lines of the probe function allocate and assign the glue,
musb and clk variables. The \code{GFP\_KERNEL} flag (line 8) allows the
allocation process to sleep and wait for memory, thus being usable in a
locking situation. The \code{PLATFORM\_DEVID\_AUTO} flag (line 12) allows
automatic allocation and management of device IDs in order to avoid
device namespace collisions with explicit IDs. With \code{devm\_clk\_get()}
(line 18) the glue layer allocates the clock -- the \code{devm\_} prefix
indicates that \code{clk\_get()} is managed: it automatically frees the
allocated clock resource data when the device is released -- and enable
it.

Then comes the registration steps:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{jz4740\PYGZus{}probe}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{platform\PYGZus{}device} \PYG{o}{*}\PYG{n}{pdev}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{struct} \PYG{n}{musb\PYGZus{}hdrc\PYGZus{}platform\PYGZus{}data}  \PYG{o}{*}\PYG{n}{pdata} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{jz4740\PYGZus{}musb\PYGZus{}platform\PYGZus{}data}\PYG{p}{;}

    \PYG{n}{pdata}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{platform\PYGZus{}ops}     \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{jz4740\PYGZus{}musb\PYGZus{}ops}\PYG{p}{;}

    \PYG{n}{platform\PYGZus{}set\PYGZus{}drvdata}\PYG{p}{(}\PYG{n}{pdev}\PYG{p}{,} \PYG{n}{glue}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{ret} \PYG{o}{=} \PYG{n}{platform\PYGZus{}device\PYGZus{}add\PYGZus{}resources}\PYG{p}{(}\PYG{n}{musb}\PYG{p}{,} \PYG{n}{pdev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{resource}\PYG{p}{,}
                        \PYG{n}{pdev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{num\PYGZus{}resources}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{ret}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{dev\PYGZus{}err}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{pdev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dev}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{failed to add resources}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{goto} \PYG{n}{err\PYGZus{}clk\PYGZus{}disable}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{ret} \PYG{o}{=} \PYG{n}{platform\PYGZus{}device\PYGZus{}add\PYGZus{}data}\PYG{p}{(}\PYG{n}{musb}\PYG{p}{,} \PYG{n}{pdata}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{o}{*}\PYG{n}{pdata}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{ret}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{dev\PYGZus{}err}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{pdev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dev}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{failed to add platform\PYGZus{}data}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{goto} \PYG{n}{err\PYGZus{}clk\PYGZus{}disable}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{n+nl}{err\PYGZus{}clk\PYGZus{}disable}\PYG{p}{:}
    \PYG{n}{clk\PYGZus{}disable\PYGZus{}unprepare}\PYG{p}{(}\PYG{n}{clk}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nl}{err\PYGZus{}platform\PYGZus{}device\PYGZus{}put}\PYG{p}{:}
    \PYG{n}{platform\PYGZus{}device\PYGZus{}put}\PYG{p}{(}\PYG{n}{musb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{ret}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The first step is to pass the device data privately held by the glue
layer on to the controller driver through \code{platform\_set\_drvdata()}
(line 7). Next is passing on the device resources information, also privately
held at that point, through {\hyperref[driver\string-api/infrastructure:c.platform_device_add_resources]{\emph{\code{platform\_device\_add\_resources()}}}} (line 9).

Finally comes passing on the platform specific data to the controller
driver (line 16). Platform data will be discussed in
{\hyperref[driver\string-api/usb/writing_musb_glue_layer:musb\string-dev\string-platform\string-data]{\emph{Device Platform Data}}}, but here we are looking at the
\code{platform\_ops} function pointer (line 5) in \code{musb\_hdrc\_platform\_data}
structure (line 3). This function pointer allows the MUSB controller
driver to know which function to call for device operation:

\begin{Verbatim}[commandchars=\\\{\}]
static const struct musb\PYGZus{}platform\PYGZus{}ops jz4740\PYGZus{}musb\PYGZus{}ops = \PYGZob{}
    .init       = jz4740\PYGZus{}musb\PYGZus{}init,
    .exit       = jz4740\PYGZus{}musb\PYGZus{}exit,
\PYGZcb{};
\end{Verbatim}

Here we have the minimal case where only init and exit functions are
called by the controller driver when needed. Fact is the JZ4740 MUSB
controller is a basic controller, lacking some features found in other
controllers, otherwise we may also have pointers to a few other
functions like a power management function or a function to switch
between OTG and non-OTG modes, for instance.

At that point of the registration process, the controller driver
actually calls the init function:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{jz4740\PYGZus{}musb\PYGZus{}init}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{musb} \PYG{o}{*}\PYG{n}{musb}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{xceiv} \PYG{o}{=} \PYG{n}{usb\PYGZus{}get\PYGZus{}phy}\PYG{p}{(}\PYG{n}{USB\PYGZus{}PHY\PYGZus{}TYPE\PYGZus{}USB2}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{xceiv}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{pr\PYGZus{}err}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{HS UDC: no transceiver configured}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{n}{ENODEV}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/* Silicon does not implement ConfigData register.}
\PYG{c+cm}{     * Set dyn\PYGZus{}fifo to avoid reading EP config from hardware.}
\PYG{c+cm}{     */}
    \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dyn\PYGZus{}fifo} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}

    \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{isr} \PYG{o}{=} \PYG{n}{jz4740\PYGZus{}musb\PYGZus{}interrupt}\PYG{p}{;}

    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

The goal of \code{jz4740\_musb\_init()} is to get hold of the transceiver
driver data of the MUSB controller hardware and pass it on to the MUSB
controller driver, as usual. The transceiver is the circuitry inside the
controller hardware responsible for sending/receiving the USB data.
Since it is an implementation of the physical layer of the OSI model,
the transceiver is also referred to as PHY.

Getting hold of the \code{MUSB PHY} driver data is done with \code{usb\_get\_phy()}
which returns a pointer to the structure containing the driver instance
data. The next couple of instructions (line 12 and 14) are used as a
quirk and to setup IRQ handling respectively. Quirks and IRQ handling
will be discussed later in {\hyperref[driver\string-api/usb/writing_musb_glue_layer:musb\string-dev\string-quirks]{\emph{Device Quirks}}} and
{\hyperref[driver\string-api/usb/writing_musb_glue_layer:musb\string-handling\string-irqs]{\emph{Handling IRQs}}}

\begin{Verbatim}[commandchars=\\\{\}]
static int jz4740\PYGZus{}musb\PYGZus{}exit(struct musb *musb)
\PYGZob{}
    usb\PYGZus{}put\PYGZus{}phy(musb\PYGZhy{}\PYGZgt{}xceiv);

    return 0;
\PYGZcb{}
\end{Verbatim}

Acting as the counterpart of init, the exit function releases the MUSB
PHY driver when the controller hardware itself is about to be released.

Again, note that init and exit are fairly simple in this case due to the
basic set of features of the JZ4740 controller hardware. When writing an
musb glue layer for a more complex controller hardware, you might need
to take care of more processing in those two functions.

Returning from the init function, the MUSB controller driver jumps back
into the probe function:

\begin{Verbatim}[commandchars=\\\{\}]
static int jz4740\PYGZus{}probe(struct platform\PYGZus{}device *pdev)
\PYGZob{}
    ret = platform\PYGZus{}device\PYGZus{}add(musb);
    if (ret) \PYGZob{}
        dev\PYGZus{}err(\PYGZam{}pdev\PYGZhy{}\PYGZgt{}dev, \PYGZdq{}failed to register musb device\PYGZbs{}n\PYGZdq{});
        goto err\PYGZus{}clk\PYGZus{}disable;
    \PYGZcb{}

    return 0;

err\PYGZus{}clk\PYGZus{}disable:
    clk\PYGZus{}disable\PYGZus{}unprepare(clk);
err\PYGZus{}platform\PYGZus{}device\PYGZus{}put:
    platform\PYGZus{}device\PYGZus{}put(musb);
    return ret;
\PYGZcb{}
\end{Verbatim}

This is the last part of the device registration process where the glue
layer adds the controller hardware device to Linux kernel device
hierarchy: at this stage, all known information about the device is
passed on to the Linux USB core stack:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{jz4740\PYGZus{}remove}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{platform\PYGZus{}device} \PYG{o}{*}\PYG{n}{pdev}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{struct} \PYG{n}{jz4740\PYGZus{}glue}  \PYG{o}{*}\PYG{n}{glue} \PYG{o}{=} \PYG{n}{platform\PYGZus{}get\PYGZus{}drvdata}\PYG{p}{(}\PYG{n}{pdev}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{platform\PYGZus{}device\PYGZus{}unregister}\PYG{p}{(}\PYG{n}{glue}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{musb}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{clk\PYGZus{}disable\PYGZus{}unprepare}\PYG{p}{(}\PYG{n}{glue}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{clk}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

Acting as the counterpart of probe, the remove function unregister the
MUSB controller hardware (line 5) and disable the clock (line 6),
allowing it to be gated.


\subsection{Handling IRQs}
\label{driver-api/usb/writing_musb_glue_layer:musb-handling-irqs}\label{driver-api/usb/writing_musb_glue_layer:handling-irqs}
Additionally to the MUSB controller hardware basic setup and
registration, the glue layer is also responsible for handling the IRQs:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{n}{irqreturn\PYGZus{}t} \PYG{n+nf}{jz4740\PYGZus{}musb\PYGZus{}interrupt}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{irq}\PYG{p}{,} \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{\PYGZus{}\PYGZus{}hci}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long}   \PYG{n}{flags}\PYG{p}{;}
    \PYG{n}{irqreturn\PYGZus{}t}     \PYG{n}{retval} \PYG{o}{=} \PYG{n}{IRQ\PYGZus{}NONE}\PYG{p}{;}
    \PYG{k}{struct} \PYG{n}{musb}     \PYG{o}{*}\PYG{n}{musb} \PYG{o}{=} \PYG{n}{\PYGZus{}\PYGZus{}hci}\PYG{p}{;}

    \PYG{n}{spin\PYGZus{}lock\PYGZus{}irqsave}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lock}\PYG{p}{,} \PYG{n}{flags}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{int\PYGZus{}usb} \PYG{o}{=} \PYG{n}{musb\PYGZus{}readb}\PYG{p}{(}\PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mregs}\PYG{p}{,} \PYG{n}{MUSB\PYGZus{}INTRUSB}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{int\PYGZus{}tx} \PYG{o}{=} \PYG{n}{musb\PYGZus{}readw}\PYG{p}{(}\PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mregs}\PYG{p}{,} \PYG{n}{MUSB\PYGZus{}INTRTX}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{int\PYGZus{}rx} \PYG{o}{=} \PYG{n}{musb\PYGZus{}readw}\PYG{p}{(}\PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mregs}\PYG{p}{,} \PYG{n}{MUSB\PYGZus{}INTRRX}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cm}{/*}
\PYG{c+cm}{     * The controller is gadget only, the state of the host mode IRQ bits is}
\PYG{c+cm}{     * undefined. Mask them to make sure that the musb driver core will}
\PYG{c+cm}{     * never see them set}
\PYG{c+cm}{     */}
    \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{int\PYGZus{}usb} \PYG{o}{\PYGZam{}}\PYG{o}{=} \PYG{n}{MUSB\PYGZus{}INTR\PYGZus{}SUSPEND} \PYG{o}{\textbar{}} \PYG{n}{MUSB\PYGZus{}INTR\PYGZus{}RESUME} \PYG{o}{\textbar{}}
        \PYG{n}{MUSB\PYGZus{}INTR\PYGZus{}RESET} \PYG{o}{\textbar{}} \PYG{n}{MUSB\PYGZus{}INTR\PYGZus{}SOF}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{int\PYGZus{}usb} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{int\PYGZus{}tx} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{int\PYGZus{}rx}\PYG{p}{)}
        \PYG{n}{retval} \PYG{o}{=} \PYG{n}{musb\PYGZus{}interrupt}\PYG{p}{(}\PYG{n}{musb}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{spin\PYGZus{}unlock\PYGZus{}irqrestore}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lock}\PYG{p}{,} \PYG{n}{flags}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{return} \PYG{n}{retval}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

Here the glue layer mostly has to read the relevant hardware registers
and pass their values on to the controller driver which will handle the
actual event that triggered the IRQ.

The interrupt handler critical section is protected by the
\code{spin\_lock\_irqsave()} and counterpart \code{spin\_unlock\_irqrestore()}
functions (line 7 and 24 respectively), which prevent the interrupt
handler code to be run by two different threads at the same time.

Then the relevant interrupt registers are read (line 9 to 11):
\begin{itemize}
\item {} 
\code{MUSB\_INTRUSB}: indicates which USB interrupts are currently active,

\item {} 
\code{MUSB\_INTRTX}: indicates which of the interrupts for TX endpoints are
currently active,

\item {} 
\code{MUSB\_INTRRX}: indicates which of the interrupts for TX endpoints are
currently active.

\end{itemize}

Note that \code{musb\_readb()} is used to read 8-bit registers at most, while
\code{musb\_readw()} allows us to read at most 16-bit registers. There are
other functions that can be used depending on the size of your device
registers. See \code{musb\_io.h} for more information.

Instruction on line 18 is another quirk specific to the JZ4740 USB
device controller, which will be discussed later in {\hyperref[driver\string-api/usb/writing_musb_glue_layer:musb\string-dev\string-quirks]{\emph{Device Quirks}}}.

The glue layer still needs to register the IRQ handler though. Remember
the instruction on line 14 of the init function:

\begin{Verbatim}[commandchars=\\\{\}]
static int jz4740\PYGZus{}musb\PYGZus{}init(struct musb *musb)
\PYGZob{}
    musb\PYGZhy{}\PYGZgt{}isr = jz4740\PYGZus{}musb\PYGZus{}interrupt;

    return 0;
\PYGZcb{}
\end{Verbatim}

This instruction sets a pointer to the glue layer IRQ handler function,
in order for the controller hardware to call the handler back when an
IRQ comes from the controller hardware. The interrupt handler is now
implemented and registered.


\subsection{Device Platform Data}
\label{driver-api/usb/writing_musb_glue_layer:musb-dev-platform-data}\label{driver-api/usb/writing_musb_glue_layer:device-platform-data}
In order to write an MUSB glue layer, you need to have some data
describing the hardware capabilities of your controller hardware, which
is called the platform data.

Platform data is specific to your hardware, though it may cover a broad
range of devices, and is generally found somewhere in the \code{arch/}
directory, depending on your device architecture.

For instance, platform data for the JZ4740 SoC is found in
\code{arch/mips/jz4740/platform.c}. In the \code{platform.c} file each device of the
JZ4740 SoC is described through a set of structures.

Here is the part of \code{arch/mips/jz4740/platform.c} that covers the USB
Device Controller (UDC):
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* USB Device Controller */}
\PYG{k}{struct} \PYG{n}{platform\PYGZus{}device} \PYG{n}{jz4740\PYGZus{}udc\PYGZus{}xceiv\PYGZus{}device} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{usb\PYGZus{}phy\PYGZus{}gen\PYGZus{}xceiv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{p}{.}\PYG{n}{id}   \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{static} \PYG{k}{struct} \PYG{n}{resource} \PYG{n}{jz4740\PYGZus{}udc\PYGZus{}resources}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}
        \PYG{p}{.}\PYG{n}{start} \PYG{o}{=} \PYG{n}{JZ4740\PYGZus{}UDC\PYGZus{}BASE\PYGZus{}ADDR}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{end}   \PYG{o}{=} \PYG{n}{JZ4740\PYGZus{}UDC\PYGZus{}BASE\PYGZus{}ADDR} \PYG{o}{+} \PYG{l+m+mh}{0x10000} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{flags} \PYG{o}{=} \PYG{n}{IORESOURCE\PYGZus{}MEM}\PYG{p}{,}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}
        \PYG{p}{.}\PYG{n}{start} \PYG{o}{=} \PYG{n}{JZ4740\PYGZus{}IRQ\PYGZus{}UDC}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{end}   \PYG{o}{=} \PYG{n}{JZ4740\PYGZus{}IRQ\PYGZus{}UDC}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{flags} \PYG{o}{=} \PYG{n}{IORESOURCE\PYGZus{}IRQ}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{name}  \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{struct} \PYG{n}{platform\PYGZus{}device} \PYG{n}{jz4740\PYGZus{}udc\PYGZus{}device} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{musb\PYGZhy{}jz4740}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{p}{.}\PYG{n}{id}   \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}
    \PYG{p}{.}\PYG{n}{dev}  \PYG{o}{=} \PYG{p}{\PYGZob{}}
        \PYG{p}{.}\PYG{n}{dma\PYGZus{}mask}          \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{jz4740\PYGZus{}udc\PYGZus{}device}\PYG{p}{.}\PYG{n}{dev}\PYG{p}{.}\PYG{n}{coherent\PYGZus{}dma\PYGZus{}mask}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{coherent\PYGZus{}dma\PYGZus{}mask} \PYG{o}{=} \PYG{n}{DMA\PYGZus{}BIT\PYGZus{}MASK}\PYG{p}{(}\PYG{l+m+mi}{32}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{.}\PYG{n}{num\PYGZus{}resources} \PYG{o}{=} \PYG{n}{ARRAY\PYGZus{}SIZE}\PYG{p}{(}\PYG{n}{jz4740\PYGZus{}udc\PYGZus{}resources}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{.}\PYG{n}{resource}      \PYG{o}{=} \PYG{n}{jz4740\PYGZus{}udc\PYGZus{}resources}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}
\end{quote}

The \code{jz4740\_udc\_xceiv\_device} platform device structure (line 2)
describes the UDC transceiver with a name and id number.

At the time of this writing, note that \code{usb\_phy\_gen\_xceiv} is the
specific name to be used for all transceivers that are either built-in
with reference USB IP or autonomous and doesn't require any PHY
programming. You will need to set \code{CONFIG\_NOP\_USB\_XCEIV=y} in the
kernel configuration to make use of the corresponding transceiver
driver. The id field could be set to -1 (equivalent to
\code{PLATFORM\_DEVID\_NONE}), -2 (equivalent to \code{PLATFORM\_DEVID\_AUTO}) or
start with 0 for the first device of this kind if we want a specific id
number.

The \code{jz4740\_udc\_resources} resource structure (line 7) defines the UDC
registers base addresses.

The first array (line 9 to 11) defines the UDC registers base memory
addresses: start points to the first register memory address, end points
to the last register memory address and the flags member defines the
type of resource we are dealing with. So \code{IORESOURCE\_MEM} is used to
define the registers memory addresses. The second array (line 14 to 17)
defines the UDC IRQ registers addresses. Since there is only one IRQ
register available for the JZ4740 UDC, start and end point at the same
address. The \code{IORESOURCE\_IRQ} flag tells that we are dealing with IRQ
resources, and the name \code{mc} is in fact hard-coded in the MUSB core in
order for the controller driver to retrieve this IRQ resource by
querying it by its name.

Finally, the \code{jz4740\_udc\_device} platform device structure (line 21)
describes the UDC itself.

The \code{musb-jz4740} name (line 22) defines the MUSB driver that is used
for this device; remember this is in fact the name that we used in the
\code{jz4740\_driver} platform driver structure in {\hyperref[driver\string-api/usb/writing_musb_glue_layer:musb\string-basics]{\emph{Linux MUSB Basics}}}.
The id field (line 23) is set to -1 (equivalent to \code{PLATFORM\_DEVID\_NONE})
since we do not need an id for the device: the MUSB controller driver was
already set to allocate an automatic id in {\hyperref[driver\string-api/usb/writing_musb_glue_layer:musb\string-basics]{\emph{Linux MUSB Basics}}}. In the dev field
we care for DMA related information here. The \code{dma\_mask} field (line 25)
defines the width of the DMA mask that is going to be used, and
\code{coherent\_dma\_mask} (line 26) has the same purpose but for the
\code{alloc\_coherent} DMA mappings: in both cases we are using a 32 bits mask.
Then the resource field (line 29) is simply a pointer to the resource
structure defined before, while the \code{num\_resources} field (line 28) keeps
track of the number of arrays defined in the resource structure (in this
case there were two resource arrays defined before).

With this quick overview of the UDC platform data at the \code{arch/} level now
done, let's get back to the MUSB glue layer specific platform data in
\code{drivers/usb/musb/jz4740.c}:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k}{struct} \PYG{n}{musb\PYGZus{}hdrc\PYGZus{}config} \PYG{n}{jz4740\PYGZus{}musb\PYGZus{}config} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{c+cm}{/* Silicon does not implement USB OTG. */}
    \PYG{p}{.}\PYG{n}{multipoint} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,}
    \PYG{c+cm}{/* Max EPs scanned, driver will decide which EP can be used. */}
    \PYG{p}{.}\PYG{n}{num\PYGZus{}eps}    \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{,}
    \PYG{c+cm}{/* RAMbits needed to configure EPs from table */}
    \PYG{p}{.}\PYG{n}{ram\PYGZus{}bits}   \PYG{o}{=} \PYG{l+m+mi}{9}\PYG{p}{,}
    \PYG{p}{.}\PYG{n}{fifo\PYGZus{}cfg} \PYG{o}{=} \PYG{n}{jz4740\PYGZus{}musb\PYGZus{}fifo\PYGZus{}cfg}\PYG{p}{,}
    \PYG{p}{.}\PYG{n}{fifo\PYGZus{}cfg\PYGZus{}size} \PYG{o}{=} \PYG{n}{ARRAY\PYGZus{}SIZE}\PYG{p}{(}\PYG{n}{jz4740\PYGZus{}musb\PYGZus{}fifo\PYGZus{}cfg}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{static} \PYG{k}{struct} \PYG{n}{musb\PYGZus{}hdrc\PYGZus{}platform\PYGZus{}data} \PYG{n}{jz4740\PYGZus{}musb\PYGZus{}platform\PYGZus{}data} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{n}{mode}   \PYG{o}{=} \PYG{n}{MUSB\PYGZus{}PERIPHERAL}\PYG{p}{,}
    \PYG{p}{.}\PYG{n}{config} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{jz4740\PYGZus{}musb\PYGZus{}config}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}
\end{quote}

First the glue layer configures some aspects of the controller driver
operation related to the controller hardware specifics. This is done
through the \code{jz4740\_musb\_config} \code{musb\_hdrc\_config} structure.

Defining the OTG capability of the controller hardware, the multipoint
member (line 3) is set to 0 (equivalent to false) since the JZ4740 UDC
is not OTG compatible. Then \code{num\_eps} (line 5) defines the number of USB
endpoints of the controller hardware, including endpoint 0: here we have
3 endpoints + endpoint 0. Next is \code{ram\_bits} (line 7) which is the width
of the RAM address bus for the MUSB controller hardware. This
information is needed when the controller driver cannot automatically
configure endpoints by reading the relevant controller hardware
registers. This issue will be discussed when we get to device quirks in
{\hyperref[driver\string-api/usb/writing_musb_glue_layer:musb\string-dev\string-quirks]{\emph{Device Quirks}}}. Last two fields (line 8 and 9) are also
about device quirks: \code{fifo\_cfg} points to the USB endpoints configuration
table and \code{fifo\_cfg\_size} keeps track of the size of the number of
entries in that configuration table. More on that later in
{\hyperref[driver\string-api/usb/writing_musb_glue_layer:musb\string-dev\string-quirks]{\emph{Device Quirks}}}.

Then this configuration is embedded inside \code{jz4740\_musb\_platform\_data}
\code{musb\_hdrc\_platform\_data} structure (line 11): config is a pointer to
the configuration structure itself, and mode tells the controller driver
if the controller hardware may be used as \code{MUSB\_HOST} only,
\code{MUSB\_PERIPHERAL} only or \code{MUSB\_OTG} which is a dual mode.

Remember that \code{jz4740\_musb\_platform\_data} is then used to convey
platform data information as we have seen in the probe function in
{\hyperref[driver\string-api/usb/writing_musb_glue_layer:musb\string-basics]{\emph{Linux MUSB Basics}}}.


\subsection{Device Quirks}
\label{driver-api/usb/writing_musb_glue_layer:musb-dev-quirks}\label{driver-api/usb/writing_musb_glue_layer:device-quirks}
Completing the platform data specific to your device, you may also need
to write some code in the glue layer to work around some device specific
limitations. These quirks may be due to some hardware bugs, or simply be
the result of an incomplete implementation of the USB On-the-Go
specification.

The JZ4740 UDC exhibits such quirks, some of which we will discuss here
for the sake of insight even though these might not be found in the
controller hardware you are working on.

Let's get back to the init function first:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{jz4740\PYGZus{}musb\PYGZus{}init}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{musb} \PYG{o}{*}\PYG{n}{musb}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{xceiv} \PYG{o}{=} \PYG{n}{usb\PYGZus{}get\PYGZus{}phy}\PYG{p}{(}\PYG{n}{USB\PYGZus{}PHY\PYGZus{}TYPE\PYGZus{}USB2}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{xceiv}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{pr\PYGZus{}err}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{HS UDC: no transceiver configured}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{n}{ENODEV}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/* Silicon does not implement ConfigData register.}
\PYG{c+cm}{     * Set dyn\PYGZus{}fifo to avoid reading EP config from hardware.}
\PYG{c+cm}{     */}
    \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dyn\PYGZus{}fifo} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}

    \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{isr} \PYG{o}{=} \PYG{n}{jz4740\PYGZus{}musb\PYGZus{}interrupt}\PYG{p}{;}

    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

Instruction on line 12 helps the MUSB controller driver to work around
the fact that the controller hardware is missing registers that are used
for USB endpoints configuration.

Without these registers, the controller driver is unable to read the
endpoints configuration from the hardware, so we use line 12 instruction
to bypass reading the configuration from silicon, and rely on a
hard-coded table that describes the endpoints configuration instead:

\begin{Verbatim}[commandchars=\\\{\}]
static struct musb\PYGZus{}fifo\PYGZus{}cfg jz4740\PYGZus{}musb\PYGZus{}fifo\PYGZus{}cfg[] = \PYGZob{}
    \PYGZob{} .hw\PYGZus{}ep\PYGZus{}num = 1, .style = FIFO\PYGZus{}TX, .maxpacket = 512, \PYGZcb{},
    \PYGZob{} .hw\PYGZus{}ep\PYGZus{}num = 1, .style = FIFO\PYGZus{}RX, .maxpacket = 512, \PYGZcb{},
    \PYGZob{} .hw\PYGZus{}ep\PYGZus{}num = 2, .style = FIFO\PYGZus{}TX, .maxpacket = 64, \PYGZcb{},
\PYGZcb{};
\end{Verbatim}

Looking at the configuration table above, we see that each endpoints is
described by three fields: \code{hw\_ep\_num} is the endpoint number, style is
its direction (either \code{FIFO\_TX} for the controller driver to send packets
in the controller hardware, or \code{FIFO\_RX} to receive packets from
hardware), and maxpacket defines the maximum size of each data packet
that can be transmitted over that endpoint. Reading from the table, the
controller driver knows that endpoint 1 can be used to send and receive
USB data packets of 512 bytes at once (this is in fact a bulk in/out
endpoint), and endpoint 2 can be used to send data packets of 64 bytes
at once (this is in fact an interrupt endpoint).

Note that there is no information about endpoint 0 here: that one is
implemented by default in every silicon design, with a predefined
configuration according to the USB specification. For more examples of
endpoint configuration tables, see \code{musb\_core.c}.

Let's now get back to the interrupt handler function:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{n}{irqreturn\PYGZus{}t} \PYG{n+nf}{jz4740\PYGZus{}musb\PYGZus{}interrupt}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{irq}\PYG{p}{,} \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{\PYGZus{}\PYGZus{}hci}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{long}   \PYG{n}{flags}\PYG{p}{;}
    \PYG{n}{irqreturn\PYGZus{}t}     \PYG{n}{retval} \PYG{o}{=} \PYG{n}{IRQ\PYGZus{}NONE}\PYG{p}{;}
    \PYG{k}{struct} \PYG{n}{musb}     \PYG{o}{*}\PYG{n}{musb} \PYG{o}{=} \PYG{n}{\PYGZus{}\PYGZus{}hci}\PYG{p}{;}

    \PYG{n}{spin\PYGZus{}lock\PYGZus{}irqsave}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lock}\PYG{p}{,} \PYG{n}{flags}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{int\PYGZus{}usb} \PYG{o}{=} \PYG{n}{musb\PYGZus{}readb}\PYG{p}{(}\PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mregs}\PYG{p}{,} \PYG{n}{MUSB\PYGZus{}INTRUSB}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{int\PYGZus{}tx} \PYG{o}{=} \PYG{n}{musb\PYGZus{}readw}\PYG{p}{(}\PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mregs}\PYG{p}{,} \PYG{n}{MUSB\PYGZus{}INTRTX}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{int\PYGZus{}rx} \PYG{o}{=} \PYG{n}{musb\PYGZus{}readw}\PYG{p}{(}\PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mregs}\PYG{p}{,} \PYG{n}{MUSB\PYGZus{}INTRRX}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cm}{/*}
\PYG{c+cm}{     * The controller is gadget only, the state of the host mode IRQ bits is}
\PYG{c+cm}{     * undefined. Mask them to make sure that the musb driver core will}
\PYG{c+cm}{     * never see them set}
\PYG{c+cm}{     */}
    \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{int\PYGZus{}usb} \PYG{o}{\PYGZam{}}\PYG{o}{=} \PYG{n}{MUSB\PYGZus{}INTR\PYGZus{}SUSPEND} \PYG{o}{\textbar{}} \PYG{n}{MUSB\PYGZus{}INTR\PYGZus{}RESUME} \PYG{o}{\textbar{}}
        \PYG{n}{MUSB\PYGZus{}INTR\PYGZus{}RESET} \PYG{o}{\textbar{}} \PYG{n}{MUSB\PYGZus{}INTR\PYGZus{}SOF}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{int\PYGZus{}usb} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{int\PYGZus{}tx} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{int\PYGZus{}rx}\PYG{p}{)}
        \PYG{n}{retval} \PYG{o}{=} \PYG{n}{musb\PYGZus{}interrupt}\PYG{p}{(}\PYG{n}{musb}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{spin\PYGZus{}unlock\PYGZus{}irqrestore}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{musb}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lock}\PYG{p}{,} \PYG{n}{flags}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{return} \PYG{n}{retval}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\end{quote}

Instruction on line 18 above is a way for the controller driver to work
around the fact that some interrupt bits used for USB host mode
operation are missing in the \code{MUSB\_INTRUSB} register, thus left in an
undefined hardware state, since this MUSB controller hardware is used in
peripheral mode only. As a consequence, the glue layer masks these
missing bits out to avoid parasite interrupts by doing a logical AND
operation between the value read from \code{MUSB\_INTRUSB} and the bits that
are actually implemented in the register.

These are only a couple of the quirks found in the JZ4740 USB device
controller. Some others were directly addressed in the MUSB core since
the fixes were generic enough to provide a better handling of the issues
for others controller hardware eventually.


\subsection{Conclusion}
\label{driver-api/usb/writing_musb_glue_layer:conclusion}
Writing a Linux MUSB glue layer should be a more accessible task, as
this documentation tries to show the ins and outs of this exercise.

The JZ4740 USB device controller being fairly simple, I hope its glue
layer serves as a good example for the curious mind. Used with the
current MUSB glue layers, this documentation should provide enough
guidance to get started; should anything gets out of hand, the linux-usb
mailing list archive is another helpful resource to browse through.


\subsection{Acknowledgements}
\label{driver-api/usb/writing_musb_glue_layer:acknowledgements}
Many thanks to Lars-Peter Clausen and Maarten ter Huurne for answering
my questions while I was writing the JZ4740 glue layer and for helping
me out getting the code in good shape.

I would also like to thank the Qi-Hardware community at large for its
cheerful guidance and support.


\subsection{Resources}
\label{driver-api/usb/writing_musb_glue_layer:resources}
USB Home Page: \href{http://www.usb.org}{http://www.usb.org}

linux-usb Mailing List Archives: \href{http://marc.info/?l=linux-usb}{http://marc.info/?l=linux-usb}

USB On-the-Go Basics:
\href{http://www.maximintegrated.com/app-notes/index.mvp/id/1822}{http://www.maximintegrated.com/app-notes/index.mvp/id/1822}

{\hyperref[driver\string-api/usb/writing_usb_driver:writing\string-usb\string-driver]{\emph{Writing USB Device Drivers}}}

Texas Instruments USB Configuration Wiki Page:
\href{http://processors.wiki.ti.com/index.php/Usbgeneralpage}{http://processors.wiki.ti.com/index.php/Usbgeneralpage}

Analog Devices Blackfin MUSB Configuration:
\href{http://docs.blackfin.uclinux.org/doku.php?id=linux-kernel:drivers:musb}{http://docs.blackfin.uclinux.org/doku.php?id=linux-kernel:drivers:musb}


\section{USB Type-C connector class}
\label{driver-api/usb/typec:usb-type-c-connector-class}\label{driver-api/usb/typec::doc}

\subsection{Introduction}
\label{driver-api/usb/typec:introduction}
The typec class is meant for describing the USB Type-C ports in a system to the
user space in unified fashion. The class is designed to provide nothing else
except the user space interface implementation in hope that it can be utilized
on as many platforms as possible.

The platforms are expected to register every USB Type-C port they have with the
class. In a normal case the registration will be done by a USB Type-C or PD PHY
driver, but it may be a driver for firmware interface such as UCSI, driver for
USB PD controller or even driver for Thunderbolt3 controller. This document
considers the component registering the USB Type-C ports with the class as ``port
driver''.

On top of showing the capabilities, the class also offer user space control over
the roles and alternate modes of ports, partners and cable plugs when the port
driver is capable of supporting those features.

The class provides an API for the port drivers described in this document. The
attributes are described in Documentation/ABI/testing/sysfs-class-typec.


\subsection{User space interface}
\label{driver-api/usb/typec:user-space-interface}
Every port will be presented as its own device under /sys/class/typec/. The
first port will be named ``port0'', the second ``port1'' and so on.

When connected, the partner will be presented also as its own device under
/sys/class/typec/. The parent of the partner device will always be the port it
is attached to. The partner attached to port ``port0'' will be named
``port0-partner''. Full path to the device would be
/sys/class/typec/port0/port0-partner/.

The cable and the two plugs on it may also be optionally presented as their own
devices under /sys/class/typec/. The cable attached to the port ``port0'' port
will be named port0-cable and the plug on the SOP Prime end (see USB Power
Delivery Specification ch. 2.4) will be named ``port0-plug0'' and on the SOP
Double Prime end ``port0-plug1''. The parent of a cable will always be the port,
and the parent of the cable plugs will always be the cable.

If the port, partner or cable plug supports Alternate Modes, every supported
Alternate Mode SVID will have their own device describing them. Note that the
Alternate Mode devices will not be attached to the typec class. The parent of an
alternate mode will be the device that supports it, so for example an alternate
mode of port0-partner will be presented under /sys/class/typec/port0-partner/.
Every mode that is supported will have its own group under the Alternate Mode
device named ``mode\textless{}index\textgreater{}'', for example /sys/class/typec/port0/\textless{}alternate
mode\textgreater{}/mode1/. The requests for entering/exiting a mode can be done with ``active''
attribute file in that group.


\subsection{Driver API}
\label{driver-api/usb/typec:driver-api}

\subsubsection{Registering the ports}
\label{driver-api/usb/typec:registering-the-ports}
The port drivers will describe every Type-C port they control with struct
typec\_capability data structure, and register them with the following API:
\index{typec\_register\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_register_port}\pysiglinewithargsret{struct typec\_port * \bfcode{typec\_register\_port}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ parent}, const struct typec\_capability *\emph{ cap}}{}
Register a USB Type-C Port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * parent}}] \leavevmode
Parent device

\item[{\code{const struct typec\_capability * cap}}] \leavevmode
Description of the port

\end{description}

\textbf{Description}

Registers a device for USB Type-C Port described in \textbf{cap}.

Returns handle to the port on success or NULL on failure.
\index{typec\_unregister\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_unregister_port}\pysiglinewithargsret{void \bfcode{typec\_unregister\_port}}{struct typec\_port *\emph{ port}}{}
Unregister a USB Type-C Port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_port * port}}] \leavevmode
The port to be unregistered

\end{description}

\textbf{Description}

Unregister device created with {\hyperref[driver\string-api/usb/typec:c.typec_register_port]{\emph{\code{typec\_register\_port()}}}}.

When registering the ports, the prefer\_role member in struct typec\_capability
deserves special notice. If the port that is being registered does not have
initial role preference, which means the port does not execute Try.SNK or
Try.SRC by default, the member must have value TYPEC\_NO\_PREFERRED\_ROLE.
Otherwise if the port executes Try.SNK by default, the member must have value
TYPEC\_DEVICE, and with Try.SRC the value must be TYPEC\_HOST.


\subsubsection{Registering Partners}
\label{driver-api/usb/typec:registering-partners}
After successful connection of a partner, the port driver needs to register the
partner with the class. Details about the partner need to be described in struct
typec\_partner\_desc. The class copies the details of the partner during
registration. The class offers the following API for registering/unregistering
partners.
\index{typec\_register\_partner (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_register_partner}\pysiglinewithargsret{struct typec\_partner * \bfcode{typec\_register\_partner}}{struct typec\_port *\emph{ port}, struct typec\_partner\_desc *\emph{ desc}}{}
Register a USB Type-C Partner

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_port * port}}] \leavevmode
The USB Type-C Port the partner is connected to

\item[{\code{struct typec\_partner\_desc * desc}}] \leavevmode
Description of the partner

\end{description}

\textbf{Description}

Registers a device for USB Type-C Partner described in \textbf{desc}.

Returns handle to the partner on success or NULL on failure.
\index{typec\_unregister\_partner (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_unregister_partner}\pysiglinewithargsret{void \bfcode{typec\_unregister\_partner}}{struct typec\_partner *\emph{ partner}}{}
Unregister a USB Type-C Partner

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_partner * partner}}] \leavevmode
The partner to be unregistered

\end{description}

\textbf{Description}

Unregister device created with {\hyperref[driver\string-api/usb/typec:c.typec_register_partner]{\emph{\code{typec\_register\_partner()}}}}.

The class will provide a handle to struct typec\_partner if the registration was
successful, or NULL.

If the partner is USB Power Delivery capable, and the port driver is able to
show the result of Discover Identity command, the partner descriptor structure
should include handle to struct usb\_pd\_identity instance. The class will then
create a sysfs directory for the identity under the partner device. The result
of Discover Identity command can then be reported with the following API:
\index{typec\_partner\_set\_identity (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_partner_set_identity}\pysiglinewithargsret{int \bfcode{typec\_partner\_set\_identity}}{struct typec\_partner *\emph{ partner}}{}
Report result from Discover Identity command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_partner * partner}}] \leavevmode
The partner updated identity values

\end{description}

\textbf{Description}

This routine is used to report that the result of Discover Identity USB power
delivery command has become available.


\subsubsection{Registering Cables}
\label{driver-api/usb/typec:registering-cables}
After successful connection of a cable that supports USB Power Delivery
Structured VDM ``Discover Identity'', the port driver needs to register the cable
and one or two plugs, depending if there is CC Double Prime controller present
in the cable or not. So a cable capable of SOP Prime communication, but not SOP
Double Prime communication, should only have one plug registered. For more
information about SOP communication, please read chapter about it from the
latest USB Power Delivery specification.

The plugs are represented as their own devices. The cable is registered first,
followed by registration of the cable plugs. The cable will be the parent device
for the plugs. Details about the cable need to be described in struct
typec\_cable\_desc and about a plug in struct typec\_plug\_desc. The class copies
the details during registration. The class offers the following API for
registering/unregistering cables and their plugs:
\index{typec\_register\_plug (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_register_plug}\pysiglinewithargsret{struct typec\_plug * \bfcode{typec\_register\_plug}}{struct typec\_cable *\emph{ cable}, struct typec\_plug\_desc *\emph{ desc}}{}
Register a USB Type-C Cable Plug

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_cable * cable}}] \leavevmode
USB Type-C Cable with the plug

\item[{\code{struct typec\_plug\_desc * desc}}] \leavevmode
Description of the cable plug

\end{description}

\textbf{Description}

Registers a device for USB Type-C Cable Plug described in \textbf{desc}. A USB Type-C
Cable Plug represents a plug with electronics in it that can response to USB
Power Delivery SOP Prime or SOP Double Prime packages.

Returns handle to the cable plug on success or NULL on failure.
\index{typec\_unregister\_plug (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_unregister_plug}\pysiglinewithargsret{void \bfcode{typec\_unregister\_plug}}{struct typec\_plug *\emph{ plug}}{}
Unregister a USB Type-C Cable Plug

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_plug * plug}}] \leavevmode
The cable plug to be unregistered

\end{description}

\textbf{Description}

Unregister device created with {\hyperref[driver\string-api/usb/typec:c.typec_register_plug]{\emph{\code{typec\_register\_plug()}}}}.
\index{typec\_register\_cable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_register_cable}\pysiglinewithargsret{struct typec\_cable * \bfcode{typec\_register\_cable}}{struct typec\_port *\emph{ port}, struct typec\_cable\_desc *\emph{ desc}}{}
Register a USB Type-C Cable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_port * port}}] \leavevmode
The USB Type-C Port the cable is connected to

\item[{\code{struct typec\_cable\_desc * desc}}] \leavevmode
Description of the cable

\end{description}

\textbf{Description}

Registers a device for USB Type-C Cable described in \textbf{desc}. The cable will be
parent for the optional cable plug devises.

Returns handle to the cable on success or NULL on failure.
\index{typec\_unregister\_cable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_unregister_cable}\pysiglinewithargsret{void \bfcode{typec\_unregister\_cable}}{struct typec\_cable *\emph{ cable}}{}
Unregister a USB Type-C Cable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_cable * cable}}] \leavevmode
The cable to be unregistered

\end{description}

\textbf{Description}

Unregister device created with {\hyperref[driver\string-api/usb/typec:c.typec_register_cable]{\emph{\code{typec\_register\_cable()}}}}.

The class will provide a handle to struct typec\_cable and struct typec\_plug if
the registration is successful, or NULL if it isn't.

If the cable is USB Power Delivery capable, and the port driver is able to show
the result of Discover Identity command, the cable descriptor structure should
include handle to struct usb\_pd\_identity instance. The class will then create a
sysfs directory for the identity under the cable device. The result of Discover
Identity command can then be reported with the following API:
\index{typec\_cable\_set\_identity (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_cable_set_identity}\pysiglinewithargsret{int \bfcode{typec\_cable\_set\_identity}}{struct typec\_cable *\emph{ cable}}{}
Report result from Discover Identity command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_cable * cable}}] \leavevmode
The cable updated identity values

\end{description}

\textbf{Description}

This routine is used to report that the result of Discover Identity USB power
delivery command has become available.


\subsubsection{Notifications}
\label{driver-api/usb/typec:notifications}
When the partner has executed a role change, or when the default roles change
during connection of a partner or cable, the port driver must use the following
APIs to report it to the class:
\index{typec\_set\_data\_role (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_set_data_role}\pysiglinewithargsret{void \bfcode{typec\_set\_data\_role}}{struct typec\_port *\emph{ port}, enum typec\_data\_role\emph{ role}}{}
Report data role change

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_port * port}}] \leavevmode
The USB Type-C Port where the role was changed

\item[{\code{enum typec\_data\_role role}}] \leavevmode
The new data role

\end{description}

\textbf{Description}

This routine is used by the port drivers to report data role changes.
\index{typec\_set\_pwr\_role (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_set_pwr_role}\pysiglinewithargsret{void \bfcode{typec\_set\_pwr\_role}}{struct typec\_port *\emph{ port}, enum typec\_role\emph{ role}}{}
Report power role change

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_port * port}}] \leavevmode
The USB Type-C Port where the role was changed

\item[{\code{enum typec\_role role}}] \leavevmode
The new data role

\end{description}

\textbf{Description}

This routine is used by the port drivers to report power role changes.
\index{typec\_set\_vconn\_role (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_set_vconn_role}\pysiglinewithargsret{void \bfcode{typec\_set\_vconn\_role}}{struct typec\_port *\emph{ port}, enum typec\_role\emph{ role}}{}
Report VCONN source change

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_port * port}}] \leavevmode
The USB Type-C Port which VCONN role changed

\item[{\code{enum typec\_role role}}] \leavevmode
Source when \textbf{port} is sourcing VCONN, or Sink when it's not

\end{description}

\textbf{Description}

This routine is used by the port drivers to report if the VCONN source is
changes.
\index{typec\_set\_pwr\_opmode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_set_pwr_opmode}\pysiglinewithargsret{void \bfcode{typec\_set\_pwr\_opmode}}{struct typec\_port *\emph{ port}, enum typec\_pwr\_opmode\emph{ opmode}}{}
Report changed power operation mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_port * port}}] \leavevmode
The USB Type-C Port where the mode was changed

\item[{\code{enum typec\_pwr\_opmode opmode}}] \leavevmode
New power operation mode

\end{description}

\textbf{Description}

This routine is used by the port drivers to report changed power operation
mode in \textbf{port}. The modes are USB (default), 1.5A, 3.0A as defined in USB
Type-C specification, and ``USB Power Delivery'' when the power levels are
negotiated with methods defined in USB Power Delivery specification.


\subsubsection{Alternate Modes}
\label{driver-api/usb/typec:alternate-modes}
USB Type-C ports, partners and cable plugs may support Alternate Modes. Each
Alternate Mode will have identifier called SVID, which is either a Standard ID
given by USB-IF or vendor ID, and each supported SVID can have 1 - 6 modes. The
class provides struct typec\_mode\_desc for describing individual mode of a SVID,
and struct typec\_altmode\_desc which is a container for all the supported modes.

Ports that support Alternate Modes need to register each SVID they support with
the following API:
\index{typec\_port\_register\_altmode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_port_register_altmode}\pysiglinewithargsret{struct typec\_altmode * \bfcode{typec\_port\_register\_altmode}}{struct typec\_port *\emph{ port}, const struct typec\_altmode\_desc *\emph{ desc}}{}
Register USB Type-C Port Alternate Mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_port * port}}] \leavevmode
USB Type-C Port that supports the alternate mode

\item[{\code{const struct typec\_altmode\_desc * desc}}] \leavevmode
Description of the alternate mode

\end{description}

\textbf{Description}

This routine is used to register an alternate mode that \textbf{port} is capable of
supporting.

Returns handle to the alternate mode on success or NULL on failure.

If a partner or cable plug provides a list of SVIDs as response to USB Power
Delivery Structured VDM Discover SVIDs message, each SVID needs to be
registered.

API for the partners:
\index{typec\_partner\_register\_altmode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_partner_register_altmode}\pysiglinewithargsret{struct typec\_altmode * \bfcode{typec\_partner\_register\_altmode}}{struct typec\_partner *\emph{ partner}, const struct typec\_altmode\_desc *\emph{ desc}}{}
Register USB Type-C Partner Alternate Mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_partner * partner}}] \leavevmode
USB Type-C Partner that supports the alternate mode

\item[{\code{const struct typec\_altmode\_desc * desc}}] \leavevmode
Description of the alternate mode

\end{description}

\textbf{Description}

This routine is used to register each alternate mode individually that
\textbf{partner} has listed in response to Discover SVIDs command. The modes for a
SVID listed in response to Discover Modes command need to be listed in an
array in \textbf{desc}.

Returns handle to the alternate mode on success or NULL on failure.

API for the Cable Plugs:
\index{typec\_plug\_register\_altmode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_plug_register_altmode}\pysiglinewithargsret{struct typec\_altmode * \bfcode{typec\_plug\_register\_altmode}}{struct typec\_plug *\emph{ plug}, const struct typec\_altmode\_desc *\emph{ desc}}{}
Register USB Type-C Cable Plug Alternate Mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_plug * plug}}] \leavevmode
USB Type-C Cable Plug that supports the alternate mode

\item[{\code{const struct typec\_altmode\_desc * desc}}] \leavevmode
Description of the alternate mode

\end{description}

\textbf{Description}

This routine is used to register each alternate mode individually that \textbf{plug}
has listed in response to Discover SVIDs command. The modes for a SVID that
the plug lists in response to Discover Modes command need to be listed in an
array in \textbf{desc}.

Returns handle to the alternate mode on success or NULL on failure.

So ports, partners and cable plugs will register the alternate modes with their
own functions, but the registration will always return a handle to struct
typec\_altmode on success, or NULL. The unregistration will happen with the same
function:
\index{typec\_unregister\_altmode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_unregister_altmode}\pysiglinewithargsret{void \bfcode{typec\_unregister\_altmode}}{struct typec\_altmode *\emph{ alt}}{}
Unregister Alternate Mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_altmode * alt}}] \leavevmode
The alternate mode to be unregistered

\end{description}

\textbf{Description}

Unregister device created with {\hyperref[driver\string-api/usb/typec:c.typec_partner_register_altmode]{\emph{\code{typec\_partner\_register\_altmode()}}}},
{\hyperref[driver\string-api/usb/typec:c.typec_plug_register_altmode]{\emph{\code{typec\_plug\_register\_altmode()}}}} or {\hyperref[driver\string-api/usb/typec:c.typec_port_register_altmode]{\emph{\code{typec\_port\_register\_altmode()}}}}.

If a partner or cable plug enters or exits a mode, the port driver needs to
notify the class with the following API:
\index{typec\_altmode\_update\_active (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/usb/typec:c.typec_altmode_update_active}\pysiglinewithargsret{void \bfcode{typec\_altmode\_update\_active}}{struct typec\_altmode *\emph{ alt}, int\emph{ mode}, bool\emph{ active}}{}
Report Enter/Exit mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct typec\_altmode * alt}}] \leavevmode
Handle to the alternate mode

\item[{\code{int mode}}] \leavevmode
Mode index

\item[{\code{bool active}}] \leavevmode
True when the mode has been entered

\end{description}

\textbf{Description}

If a partner or cable plug executes Enter/Exit Mode command successfully, the
drivers use this routine to report the updated state of the mode.


\section{USB3 debug port}
\label{driver-api/usb/usb3-debug-port::doc}\label{driver-api/usb/usb3-debug-port:usb3-debug-port}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Lu Baolu \textless{}\href{mailto:baolu.lu@linux.intel.com}{baolu.lu@linux.intel.com}\textgreater{}

\item[{Date}] \leavevmode
March 2017

\end{description}\end{quote}


\subsection{GENERAL}
\label{driver-api/usb/usb3-debug-port:general}
This is a HOWTO for using the USB3 debug port on x86 systems.

Before using any kernel debugging functionality based on USB3
debug port, you need to:

\begin{Verbatim}[commandchars=\\\{\}]
1) check whether any USB3 debug port is available in
   your system;
2) check which port is used for debugging purposes;
3) have a USB 3.0 super\PYGZhy{}speed A\PYGZhy{}to\PYGZhy{}A debugging cable.
\end{Verbatim}


\subsection{INTRODUCTION}
\label{driver-api/usb/usb3-debug-port:introduction}
The xHCI debug capability (DbC) is an optional but standalone
functionality provided by the xHCI host controller. The xHCI
specification describes DbC in the section 7.6.

When DbC is initialized and enabled, it will present a debug
device through the debug port (normally the first USB3
super-speed port). The debug device is fully compliant with
the USB framework and provides the equivalent of a very high
performance full-duplex serial link between the debug target
(the system under debugging) and a debug host.


\subsection{EARLY PRINTK}
\label{driver-api/usb/usb3-debug-port:early-printk}
DbC has been designed to log early printk messages. One use for
this feature is kernel debugging. For example, when your machine
crashes very early before the regular console code is initialized.
Other uses include simpler, lockless logging instead of a full-
blown printk console driver and klogd.

On the debug target system, you need to customize a debugging
kernel with CONFIG\_EARLY\_PRINTK\_USB\_XDBC enabled. And, add below
kernel boot parameter:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdq{}earlyprintk=xdbc\PYGZdq{}
\end{Verbatim}

If there are multiple xHCI controllers in your system, you can
append a host contoller index to this kernel parameter. This
index starts from 0.

Current design doesn't support DbC runtime suspend/resume. As
the result, you'd better disable runtime power management for
USB subsystem by adding below kernel boot parameter:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdq{}usbcore.autosuspend=\PYGZhy{}1\PYGZdq{}
\end{Verbatim}

Before starting the debug target, you should connect the debug
port to a USB port (root port or port of any external hub) on
the debug host. The cable used to connect these two ports
should be a USB 3.0 super-speed A-to-A debugging cable.

During early boot of the debug target, DbC will be detected and
initialized. After initialization, the debug host should be able
to enumerate the debug device in debug target. The debug host
will then bind the debug device with the usb\_debug driver module
and create the /dev/ttyUSB device.

If the debug device enumeration goes smoothly, you should be able
to see below kernel messages on the debug host:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} tail \PYGZhy{}f /var/log/kern.log
[ 1815.983374] usb 4\PYGZhy{}3: new SuperSpeed USB device number 4 using xhci\PYGZus{}hcd
[ 1815.999595] usb 4\PYGZhy{}3: LPM exit latency is zeroed, disabling LPM.
[ 1815.999899] usb 4\PYGZhy{}3: New USB device found, idVendor=1d6b, idProduct=0004
[ 1815.999902] usb 4\PYGZhy{}3: New USB device strings: Mfr=1, Product=2, SerialNumber=3
[ 1815.999903] usb 4\PYGZhy{}3: Product: Remote GDB
[ 1815.999904] usb 4\PYGZhy{}3: Manufacturer: Linux
[ 1815.999905] usb 4\PYGZhy{}3: SerialNumber: 0001
[ 1816.000240] usb\PYGZus{}debug 4\PYGZhy{}3:1.0: xhci\PYGZus{}dbc converter detected
[ 1816.000360] usb 4\PYGZhy{}3: xhci\PYGZus{}dbc converter now attached to ttyUSB0
\end{Verbatim}

You can use any communication program, for example minicom, to
read and view the messages. Below simple bash scripts can help
you to check the sanity of the setup.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=} start of bash \PYG{n+nv}{scripts} \PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}
\PYG{c+c1}{\PYGZsh{}!/bin/bash}

\PYG{k}{while} \PYG{n+nb}{true} \PYG{p}{;} \PYG{k}{do}
        \PYG{k}{while} \PYG{o}{[} ! \PYGZhy{}d /sys/class/tty/ttyUSB0 \PYG{o}{]} \PYG{p}{;} \PYG{k}{do}
                :
        \PYG{k}{done}
cat /dev/ttyUSB0
\PYG{k}{done}
\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=} end of bash \PYG{n+nv}{scripts} \PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}\PYG{o}{=}
\end{Verbatim}


\subsection{Serial TTY}
\label{driver-api/usb/usb3-debug-port:serial-tty}
The DbC support has been added to the xHCI driver. You can get a
debug device provided by the DbC at runtime.

In order to use this, you need to make sure your kernel has been
configured to support USB\_XHCI\_DBGCAP. A sysfs attribute under
the xHCI device node is used to enable or disable DbC. By default,
DbC is disabled:

\begin{Verbatim}[commandchars=\\\{\}]
root@target:/sys/bus/pci/devices/0000:00:14.0\PYGZsh{} cat dbc
disabled
\end{Verbatim}

Enable DbC with the following command:

\begin{Verbatim}[commandchars=\\\{\}]
root@target:/sys/bus/pci/devices/0000:00:14.0\PYGZsh{} echo enable \PYGZgt{} dbc
\end{Verbatim}

You can check the DbC state at anytime:

\begin{Verbatim}[commandchars=\\\{\}]
root@target:/sys/bus/pci/devices/0000:00:14.0\PYGZsh{} cat dbc
enabled
\end{Verbatim}

Connect the debug target to the debug host with a USB 3.0 super-
speed A-to-A debugging cable. You can see /dev/ttyDBC0 created
on the debug target. You will see below kernel message lines:

\begin{Verbatim}[commandchars=\\\{\}]
root@target: tail \PYGZhy{}f /var/log/kern.log
[  182.730103] xhci\PYGZus{}hcd 0000:00:14.0: DbC connected
[  191.169420] xhci\PYGZus{}hcd 0000:00:14.0: DbC configured
[  191.169597] xhci\PYGZus{}hcd 0000:00:14.0: DbC now attached to /dev/ttyDBC0
\end{Verbatim}

Accordingly, the DbC state has been brought up to:

\begin{Verbatim}[commandchars=\\\{\}]
root@target:/sys/bus/pci/devices/0000:00:14.0\PYGZsh{} cat dbc
configured
\end{Verbatim}

On the debug host, you will see the debug device has been enumerated.
You will see below kernel message lines:

\begin{Verbatim}[commandchars=\\\{\}]
root@host: tail \PYGZhy{}f /var/log/kern.log
[   79.454780] usb 2\PYGZhy{}2.1: new SuperSpeed USB device number 3 using xhci\PYGZus{}hcd
[   79.475003] usb 2\PYGZhy{}2.1: LPM exit latency is zeroed, disabling LPM.
[   79.475389] usb 2\PYGZhy{}2.1: New USB device found, idVendor=1d6b, idProduct=0010
[   79.475390] usb 2\PYGZhy{}2.1: New USB device strings: Mfr=1, Product=2, SerialNumber=3
[   79.475391] usb 2\PYGZhy{}2.1: Product: Linux USB Debug Target
[   79.475392] usb 2\PYGZhy{}2.1: Manufacturer: Linux Foundation
[   79.475393] usb 2\PYGZhy{}2.1: SerialNumber: 0001
\end{Verbatim}

The debug device works now. You can use any communication or debugging
program to talk between the host and the target.


\chapter{PCI Support Library}
\label{driver-api/pci:pci-support-library}\label{driver-api/pci::doc}\index{pci\_bus\_max\_busnr (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_bus_max_busnr}\pysiglinewithargsret{unsigned char \bfcode{pci\_bus\_max\_busnr}}{struct pci\_bus *\emph{ bus}}{}
returns maximum PCI bus number of given bus' children

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_bus * bus}}] \leavevmode
pointer to PCI bus structure to search

\end{description}

\textbf{Description}

Given a PCI bus, returns the highest PCI bus number present in the set
including the given PCI bus and its list of child PCI buses.
\index{pci\_find\_capability (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_find_capability}\pysiglinewithargsret{int \bfcode{pci\_find\_capability}}{struct pci\_dev *\emph{ dev}, int\emph{ cap}}{}
query for devices' capabilities

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to query

\item[{\code{int cap}}] \leavevmode
capability code

\end{description}

\textbf{Description}

Tell if a device supports a given PCI capability.
Returns the address of the requested capability structure within the
device's PCI configuration space or 0 in case the device does not
support it.  Possible values for \textbf{cap}:
\begin{quote}

\code{PCI\_CAP\_ID\_PM}           Power Management
\code{PCI\_CAP\_ID\_AGP}          Accelerated Graphics Port
\code{PCI\_CAP\_ID\_VPD}          Vital Product Data
\code{PCI\_CAP\_ID\_SLOTID}       Slot Identification
\code{PCI\_CAP\_ID\_MSI}          Message Signalled Interrupts
\code{PCI\_CAP\_ID\_CHSWP}        CompactPCI HotSwap
\code{PCI\_CAP\_ID\_PCIX}         PCI-X
\code{PCI\_CAP\_ID\_EXP}          PCI Express
\end{quote}
\index{pci\_bus\_find\_capability (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_bus_find_capability}\pysiglinewithargsret{int \bfcode{pci\_bus\_find\_capability}}{struct pci\_bus *\emph{ bus}, unsigned int\emph{ devfn}, int\emph{ cap}}{}
query for devices' capabilities

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_bus * bus}}] \leavevmode
the PCI bus to query

\item[{\code{unsigned int devfn}}] \leavevmode
PCI device to query

\item[{\code{int cap}}] \leavevmode
capability code

\end{description}

\textbf{Description}

Like {\hyperref[driver\string-api/pci:c.pci_find_capability]{\emph{\code{pci\_find\_capability()}}}} but works for pci devices that do not have a
pci\_dev structure set up yet.

Returns the address of the requested capability structure within the
device's PCI configuration space or 0 in case the device does not
support it.
\index{pci\_find\_next\_ext\_capability (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_find_next_ext_capability}\pysiglinewithargsret{int \bfcode{pci\_find\_next\_ext\_capability}}{struct pci\_dev *\emph{ dev}, int\emph{ start}, int\emph{ cap}}{}
Find an extended capability

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to query

\item[{\code{int start}}] \leavevmode
address at which to start looking (0 to start at beginning of list)

\item[{\code{int cap}}] \leavevmode
capability code

\end{description}

\textbf{Description}

Returns the address of the next matching extended capability structure
within the device's PCI configuration space or 0 if the device does
not support it.  Some capabilities can occur several times, e.g., the
vendor-specific capability, and this provides a way to find them all.
\index{pci\_find\_ext\_capability (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_find_ext_capability}\pysiglinewithargsret{int \bfcode{pci\_find\_ext\_capability}}{struct pci\_dev *\emph{ dev}, int\emph{ cap}}{}
Find an extended capability

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to query

\item[{\code{int cap}}] \leavevmode
capability code

\end{description}

\textbf{Description}

Returns the address of the requested extended capability structure
within the device's PCI configuration space or 0 if the device does
not support it.  Possible values for \textbf{cap}:
\begin{quote}

\code{PCI\_EXT\_CAP\_ID\_ERR}         Advanced Error Reporting
\code{PCI\_EXT\_CAP\_ID\_VC}          Virtual Channel
\code{PCI\_EXT\_CAP\_ID\_DSN}         Device Serial Number
\code{PCI\_EXT\_CAP\_ID\_PWR}         Power Budgeting
\end{quote}
\index{pci\_find\_next\_ht\_capability (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_find_next_ht_capability}\pysiglinewithargsret{int \bfcode{pci\_find\_next\_ht\_capability}}{struct pci\_dev *\emph{ dev}, int\emph{ pos}, int\emph{ ht\_cap}}{}
query a device's Hypertransport capabilities

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to query

\item[{\code{int pos}}] \leavevmode
Position from which to continue searching

\item[{\code{int ht\_cap}}] \leavevmode
Hypertransport capability code

\end{description}

\textbf{Description}

To be used in conjunction with {\hyperref[driver\string-api/pci:c.pci_find_ht_capability]{\emph{\code{pci\_find\_ht\_capability()}}}} to search for
all capabilities matching \textbf{ht\_cap}. \textbf{pos} should always be a value returned
from {\hyperref[driver\string-api/pci:c.pci_find_ht_capability]{\emph{\code{pci\_find\_ht\_capability()}}}}.

NB. To be 100\% safe against broken PCI devices, the caller should take
steps to avoid an infinite loop.
\index{pci\_find\_ht\_capability (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_find_ht_capability}\pysiglinewithargsret{int \bfcode{pci\_find\_ht\_capability}}{struct pci\_dev *\emph{ dev}, int\emph{ ht\_cap}}{}
query a device's Hypertransport capabilities

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to query

\item[{\code{int ht\_cap}}] \leavevmode
Hypertransport capability code

\end{description}

\textbf{Description}

Tell if a device supports a given Hypertransport capability.
Returns an address within the device's PCI configuration space
or 0 in case the device does not support the request capability.
The address points to the PCI capability, of type PCI\_CAP\_ID\_HT,
which has a Hypertransport capability matching \textbf{ht\_cap}.
\index{pci\_find\_parent\_resource (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_find_parent_resource}\pysiglinewithargsret{struct resource * \bfcode{pci\_find\_parent\_resource}}{const struct pci\_dev *\emph{ dev}, struct resource *\emph{ res}}{}
return resource region of parent bus of given region

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct pci\_dev * dev}}] \leavevmode
PCI device structure contains resources to be searched

\item[{\code{struct resource * res}}] \leavevmode
child resource record for which parent is sought

\end{description}

\textbf{Description}
\begin{quote}

For given resource region of given device, return the resource
region of parent bus the given region is contained in.
\end{quote}
\index{pci\_find\_resource (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_find_resource}\pysiglinewithargsret{struct resource * \bfcode{pci\_find\_resource}}{struct pci\_dev *\emph{ dev}, struct resource *\emph{ res}}{}
Return matching PCI device resource

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to query

\item[{\code{struct resource * res}}] \leavevmode
Resource to look for

\end{description}

\textbf{Description}

Goes over standard PCI resources (BARs) and checks if the given resource
is partially or fully contained in any of them. In that case the
matching resource is returned, \code{NULL} otherwise.
\index{pci\_find\_pcie\_root\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_find_pcie_root_port}\pysiglinewithargsret{struct pci\_dev * \bfcode{pci\_find\_pcie\_root\_port}}{struct pci\_dev *\emph{ dev}}{}
return PCIe Root Port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to query

\end{description}

\textbf{Description}

Traverse up the parent chain and return the PCIe Root Port PCI Device
for a given PCI Device.
\index{\_\_pci\_complete\_power\_transition (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.__pci_complete_power_transition}\pysiglinewithargsret{int \bfcode{\_\_pci\_complete\_power\_transition}}{struct pci\_dev *\emph{ dev}, pci\_power\_t\emph{ state}}{}
Complete power transition of a PCI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to handle.

\item[{\code{pci\_power\_t state}}] \leavevmode
State to put the device into.

\end{description}

\textbf{Description}

This function should not be called directly by device drivers.
\index{pci\_set\_power\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_set_power_state}\pysiglinewithargsret{int \bfcode{pci\_set\_power\_state}}{struct pci\_dev *\emph{ dev}, pci\_power\_t\emph{ state}}{}
Set the power state of a PCI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to handle.

\item[{\code{pci\_power\_t state}}] \leavevmode
PCI power state (D0, D1, D2, D3hot) to put the device into.

\end{description}

\textbf{Description}

Transition a device to a new power state, using the platform firmware and/or
the device's PCI PM registers.

RETURN VALUE:
-EINVAL if the requested state is invalid.
-EIO if device does not support PCI PM or its PM capabilities register has a
wrong version, or device doesn't support the requested state.
0 if the transition is to D1 or D2 but D1 and D2 are not supported.
0 if device already is in the requested state.
0 if the transition is to D3 but D3 is not supported.
0 if device's power state has been successfully changed.
\index{pci\_choose\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_choose_state}\pysiglinewithargsret{pci\_power\_t \bfcode{pci\_choose\_state}}{struct pci\_dev *\emph{ dev}, pm\_message\_t\emph{ state}}{}
Choose the power state of a PCI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to be suspended

\item[{\code{pm\_message\_t state}}] \leavevmode
target sleep state for the whole system. This is the value
that is passed to \code{suspend()} function.

\end{description}

\textbf{Description}

Returns PCI power state suitable for given device and given system
message.
\index{pci\_save\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_save_state}\pysiglinewithargsret{int \bfcode{pci\_save\_state}}{struct pci\_dev *\emph{ dev}}{}
save the PCI configuration space of a device before suspending

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode\begin{itemize}
\item {} 
PCI device that we're dealing with

\end{itemize}

\end{description}
\index{pci\_restore\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_restore_state}\pysiglinewithargsret{void \bfcode{pci\_restore\_state}}{struct pci\_dev *\emph{ dev}}{}
Restore the saved state of a PCI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode\begin{itemize}
\item {} 
PCI device that we're dealing with

\end{itemize}

\end{description}
\index{pci\_store\_saved\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_store_saved_state}\pysiglinewithargsret{struct pci\_saved\_state * \bfcode{pci\_store\_saved\_state}}{struct pci\_dev *\emph{ dev}}{}
Allocate and return an opaque struct containing the device saved state.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device that we're dealing with

\end{description}

\textbf{Description}

Return NULL if no state or error.
\index{pci\_load\_saved\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_load_saved_state}\pysiglinewithargsret{int \bfcode{pci\_load\_saved\_state}}{struct pci\_dev *\emph{ dev}, struct pci\_saved\_state *\emph{ state}}{}
Reload the provided save state into struct pci\_dev.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device that we're dealing with

\item[{\code{struct pci\_saved\_state * state}}] \leavevmode
Saved state returned from {\hyperref[driver\string-api/pci:c.pci_store_saved_state]{\emph{\code{pci\_store\_saved\_state()}}}}

\end{description}
\index{pci\_load\_and\_free\_saved\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_load_and_free_saved_state}\pysiglinewithargsret{int \bfcode{pci\_load\_and\_free\_saved\_state}}{struct pci\_dev *\emph{ dev}, struct pci\_saved\_state **\emph{ state}}{}
Reload the save state pointed to by state, and free the memory allocated for it.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device that we're dealing with

\item[{\code{struct pci\_saved\_state ** state}}] \leavevmode
Pointer to saved state returned from {\hyperref[driver\string-api/pci:c.pci_store_saved_state]{\emph{\code{pci\_store\_saved\_state()}}}}

\end{description}
\index{pci\_reenable\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_reenable_device}\pysiglinewithargsret{int \bfcode{pci\_reenable\_device}}{struct pci\_dev *\emph{ dev}}{}
Resume abandoned device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to be resumed

\end{description}

\textbf{Description}
\begin{quote}

Note this function is a backend of pci\_default\_resume and is not supposed
to be called by normal code, write proper resume handler and use it instead.
\end{quote}
\index{pci\_enable\_device\_io (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_enable_device_io}\pysiglinewithargsret{int \bfcode{pci\_enable\_device\_io}}{struct pci\_dev *\emph{ dev}}{}
Initialize a device for use with IO space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to be initialized

\end{description}

\textbf{Description}
\begin{quote}

Initialize device before it's used by a driver. Ask low-level code
to enable I/O resources. Wake up the device if it was suspended.
Beware, this function can fail.
\end{quote}
\index{pci\_enable\_device\_mem (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_enable_device_mem}\pysiglinewithargsret{int \bfcode{pci\_enable\_device\_mem}}{struct pci\_dev *\emph{ dev}}{}
Initialize a device for use with Memory space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to be initialized

\end{description}

\textbf{Description}
\begin{quote}

Initialize device before it's used by a driver. Ask low-level code
to enable Memory resources. Wake up the device if it was suspended.
Beware, this function can fail.
\end{quote}
\index{pci\_enable\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_enable_device}\pysiglinewithargsret{int \bfcode{pci\_enable\_device}}{struct pci\_dev *\emph{ dev}}{}
Initialize device before it's used by a driver.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to be initialized

\end{description}

\textbf{Description}
\begin{quote}

Initialize device before it's used by a driver. Ask low-level code
to enable I/O and memory. Wake up the device if it was suspended.
Beware, this function can fail.

Note we don't actually enable the device many times if we call
this function repeatedly (we just increment the count).
\end{quote}
\index{pcim\_enable\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pcim_enable_device}\pysiglinewithargsret{int \bfcode{pcim\_enable\_device}}{struct pci\_dev *\emph{ pdev}}{}
Managed {\hyperref[driver\string-api/pci:c.pci_enable_device]{\emph{\code{pci\_enable\_device()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
PCI device to be initialized

\end{description}

\textbf{Description}

Managed {\hyperref[driver\string-api/pci:c.pci_enable_device]{\emph{\code{pci\_enable\_device()}}}}.
\index{pcim\_pin\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pcim_pin_device}\pysiglinewithargsret{void \bfcode{pcim\_pin\_device}}{struct pci\_dev *\emph{ pdev}}{}
Pin managed PCI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
PCI device to pin

\end{description}

\textbf{Description}

Pin managed PCI device \textbf{pdev}.  Pinned device won't be disabled on
driver detach.  \textbf{pdev} must have been enabled with
{\hyperref[driver\string-api/pci:c.pcim_enable_device]{\emph{\code{pcim\_enable\_device()}}}}.
\index{pci\_disable\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_disable_device}\pysiglinewithargsret{void \bfcode{pci\_disable\_device}}{struct pci\_dev *\emph{ dev}}{}
Disable PCI device after use

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to be disabled

\end{description}

\textbf{Description}

Signal to the system that the PCI device is not in use by the system
anymore.  This only involves disabling PCI bus-mastering, if active.

Note we don't actually disable the device until all callers of
{\hyperref[driver\string-api/pci:c.pci_enable_device]{\emph{\code{pci\_enable\_device()}}}} have called {\hyperref[driver\string-api/pci:c.pci_disable_device]{\emph{\code{pci\_disable\_device()}}}}.
\index{pci\_set\_pcie\_reset\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_set_pcie_reset_state}\pysiglinewithargsret{int \bfcode{pci\_set\_pcie\_reset\_state}}{struct pci\_dev *\emph{ dev}, enum pcie\_reset\_state\emph{ state}}{}
set reset state for device dev

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCIe device reset

\item[{\code{enum pcie\_reset\_state state}}] \leavevmode
Reset state to enter into

\end{description}

\textbf{Description}

Sets the PCI reset state for the device.
\index{pci\_pme\_capable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_pme_capable}\pysiglinewithargsret{bool \bfcode{pci\_pme\_capable}}{struct pci\_dev *\emph{ dev}, pci\_power\_t\emph{ state}}{}
check the capability of PCI device to generate PME\#

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to handle.

\item[{\code{pci\_power\_t state}}] \leavevmode
PCI state from which device will issue PME\#.

\end{description}
\index{pci\_pme\_active (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_pme_active}\pysiglinewithargsret{void \bfcode{pci\_pme\_active}}{struct pci\_dev *\emph{ dev}, bool\emph{ enable}}{}
enable or disable PCI device's PME\# function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to handle.

\item[{\code{bool enable}}] \leavevmode
`true' to enable PME\# generation; `false' to disable it.

\end{description}

\textbf{Description}

The caller must verify that the device is capable of generating PME\# before
calling this function with \textbf{enable} equal to `true'.
\index{pci\_enable\_wake (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_enable_wake}\pysiglinewithargsret{int \bfcode{pci\_enable\_wake}}{struct pci\_dev *\emph{ dev}, pci\_power\_t\emph{ state}, bool\emph{ enable}}{}
enable PCI device as wakeup event source

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device affected

\item[{\code{pci\_power\_t state}}] \leavevmode
PCI state from which device will issue wakeup events

\item[{\code{bool enable}}] \leavevmode
True to enable event generation; false to disable

\end{description}

\textbf{Description}

This enables the device as a wakeup event source, or disables it.
When such events involves platform-specific hooks, those hooks are
called automatically by this routine.

Devices with legacy power management (no standard PCI PM capabilities)
always require such platform hooks.

RETURN VALUE:
0 is returned on success
-EINVAL is returned if device is not supposed to wake up the system
Error code depending on the platform is returned if both the platform and
the native mechanism fail to enable the generation of wake-up events
\index{pci\_wake\_from\_d3 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_wake_from_d3}\pysiglinewithargsret{int \bfcode{pci\_wake\_from\_d3}}{struct pci\_dev *\emph{ dev}, bool\emph{ enable}}{}
enable/disable device to wake up from D3\_hot or D3\_cold

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to prepare

\item[{\code{bool enable}}] \leavevmode
True to enable wake-up event generation; false to disable

\end{description}

\textbf{Description}

Many drivers want the device to wake up the system from D3\_hot or D3\_cold
and this function allows them to set that up cleanly - {\hyperref[driver\string-api/pci:c.pci_enable_wake]{\emph{\code{pci\_enable\_wake()}}}}
should not be called twice in a row to enable wake-up due to PCI PM vs ACPI
ordering constraints.

This function only returns error code if the device is not capable of
generating PME\# from both D3\_hot and D3\_cold, and the platform is unable to
enable wake-up power for it.
\index{pci\_prepare\_to\_sleep (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_prepare_to_sleep}\pysiglinewithargsret{int \bfcode{pci\_prepare\_to\_sleep}}{struct pci\_dev *\emph{ dev}}{}
prepare PCI device for system-wide transition into a sleep state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
Device to handle.

\end{description}

\textbf{Description}

Choose the power state appropriate for the device depending on whether
it can wake up the system and/or is power manageable by the platform
(PCI\_D3hot is the default) and put the device into that state.
\index{pci\_back\_from\_sleep (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_back_from_sleep}\pysiglinewithargsret{int \bfcode{pci\_back\_from\_sleep}}{struct pci\_dev *\emph{ dev}}{}
turn PCI device on during system-wide transition into working state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
Device to handle.

\end{description}

\textbf{Description}

Disable device's system wake-up capability and put it into D0.
\index{pci\_dev\_run\_wake (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_dev_run_wake}\pysiglinewithargsret{bool \bfcode{pci\_dev\_run\_wake}}{struct pci\_dev *\emph{ dev}}{}
Check if device can generate run-time wake-up events.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
Device to check.

\end{description}

\textbf{Description}

Return true if the device itself is capable of generating wake-up events
(through the platform or using the native PCIe PME) or if the device supports
PME and one of its upstream bridges can generate wake-up events.
\index{pci\_d3cold\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_d3cold_enable}\pysiglinewithargsret{void \bfcode{pci\_d3cold\_enable}}{struct pci\_dev *\emph{ dev}}{}
Enable D3cold for device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to handle

\end{description}

\textbf{Description}

This function can be used in drivers to enable D3cold from the device
they handle.  It also updates upstream PCI bridge PM capabilities
accordingly.
\index{pci\_d3cold\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_d3cold_disable}\pysiglinewithargsret{void \bfcode{pci\_d3cold\_disable}}{struct pci\_dev *\emph{ dev}}{}
Disable D3cold for device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to handle

\end{description}

\textbf{Description}

This function can be used in drivers to disable D3cold from the device
they handle.  It also updates upstream PCI bridge PM capabilities
accordingly.
\index{pci\_enable\_atomic\_ops\_to\_root (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_enable_atomic_ops_to_root}\pysiglinewithargsret{int \bfcode{pci\_enable\_atomic\_ops\_to\_root}}{struct pci\_dev *\emph{ dev}, u32\emph{ cap\_mask}}{}
enable AtomicOp requests to root port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device

\item[{\code{u32 cap\_mask}}] \leavevmode
mask of desired AtomicOp sizes, including one or more of:
PCI\_EXP\_DEVCAP2\_ATOMIC\_COMP32
PCI\_EXP\_DEVCAP2\_ATOMIC\_COMP64
PCI\_EXP\_DEVCAP2\_ATOMIC\_COMP128

\end{description}

\textbf{Description}

Return 0 if all upstream bridges support AtomicOp routing, egress
blocking is disabled on all upstream ports, and the root port supports
the requested completion capabilities (32-bit, 64-bit and/or 128-bit
AtomicOp completion), or negative otherwise.
\index{pci\_common\_swizzle (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_common_swizzle}\pysiglinewithargsret{u8 \bfcode{pci\_common\_swizzle}}{struct pci\_dev *\emph{ dev}, u8 *\emph{ pinp}}{}
swizzle INTx all the way to root bridge

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device

\item[{\code{u8 * pinp}}] \leavevmode
pointer to the INTx pin value (1=INTA, 2=INTB, 3=INTD, 4=INTD)

\end{description}

\textbf{Description}

Perform INTx swizzling for a device.  This traverses through all PCI-to-PCI
bridges all the way up to a PCI root bus.
\index{pci\_release\_region (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_release_region}\pysiglinewithargsret{void \bfcode{pci\_release\_region}}{struct pci\_dev *\emph{ pdev}, int\emph{ bar}}{}
Release a PCI bar

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
PCI device whose resources were previously reserved by pci\_request\_region

\item[{\code{int bar}}] \leavevmode
BAR to release

\end{description}

\textbf{Description}
\begin{quote}

Releases the PCI I/O and memory resources previously reserved by a
successful call to pci\_request\_region.  Call this function only
after all use of the PCI regions has ceased.
\end{quote}
\index{pci\_request\_region (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_request_region}\pysiglinewithargsret{int \bfcode{pci\_request\_region}}{struct pci\_dev *\emph{ pdev}, int\emph{ bar}, const char *\emph{ res\_name}}{}
Reserve PCI I/O and memory resource

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
PCI device whose resources are to be reserved

\item[{\code{int bar}}] \leavevmode
BAR to be reserved

\item[{\code{const char * res\_name}}] \leavevmode
Name to be associated with resource

\end{description}

\textbf{Description}
\begin{quote}

Mark the PCI region associated with PCI device \textbf{pdev} BAR \textbf{bar} as
being reserved by owner \textbf{res\_name}.  Do not access any
address inside the PCI regions unless this call returns
successfully.

Returns 0 on success, or \code{EBUSY} on error.  A warning
message is also printed on failure.
\end{quote}
\index{pci\_request\_region\_exclusive (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_request_region_exclusive}\pysiglinewithargsret{int \bfcode{pci\_request\_region\_exclusive}}{struct pci\_dev *\emph{ pdev}, int\emph{ bar}, const char *\emph{ res\_name}}{}
Reserved PCI I/O and memory resource

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
PCI device whose resources are to be reserved

\item[{\code{int bar}}] \leavevmode
BAR to be reserved

\item[{\code{const char * res\_name}}] \leavevmode
Name to be associated with resource.

\end{description}

\textbf{Description}
\begin{quote}

Mark the PCI region associated with PCI device \textbf{pdev} BR \textbf{bar} as
being reserved by owner \textbf{res\_name}.  Do not access any
address inside the PCI regions unless this call returns
successfully.

Returns 0 on success, or \code{EBUSY} on error.  A warning
message is also printed on failure.

The key difference that \_exclusive makes it that userspace is
explicitly not allowed to map the resource via /dev/mem or
sysfs.
\end{quote}
\index{pci\_release\_selected\_regions (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_release_selected_regions}\pysiglinewithargsret{void \bfcode{pci\_release\_selected\_regions}}{struct pci\_dev *\emph{ pdev}, int\emph{ bars}}{}
Release selected PCI I/O and memory resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
PCI device whose resources were previously reserved

\item[{\code{int bars}}] \leavevmode
Bitmask of BARs to be released

\end{description}

\textbf{Description}

Release selected PCI I/O and memory resources previously reserved.
Call this function only after all use of the PCI regions has ceased.
\index{pci\_request\_selected\_regions (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_request_selected_regions}\pysiglinewithargsret{int \bfcode{pci\_request\_selected\_regions}}{struct pci\_dev *\emph{ pdev}, int\emph{ bars}, const char *\emph{ res\_name}}{}
Reserve selected PCI I/O and memory resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
PCI device whose resources are to be reserved

\item[{\code{int bars}}] \leavevmode
Bitmask of BARs to be requested

\item[{\code{const char * res\_name}}] \leavevmode
Name to be associated with resource

\end{description}
\index{pci\_release\_regions (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_release_regions}\pysiglinewithargsret{void \bfcode{pci\_release\_regions}}{struct pci\_dev *\emph{ pdev}}{}
Release reserved PCI I/O and memory resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
PCI device whose resources were previously reserved by pci\_request\_regions

\end{description}

\textbf{Description}
\begin{quote}

Releases all PCI I/O and memory resources previously reserved by a
successful call to pci\_request\_regions.  Call this function only
after all use of the PCI regions has ceased.
\end{quote}
\index{pci\_request\_regions (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_request_regions}\pysiglinewithargsret{int \bfcode{pci\_request\_regions}}{struct pci\_dev *\emph{ pdev}, const char *\emph{ res\_name}}{}
Reserved PCI I/O and memory resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
PCI device whose resources are to be reserved

\item[{\code{const char * res\_name}}] \leavevmode
Name to be associated with resource.

\end{description}

\textbf{Description}
\begin{quote}

Mark all PCI regions associated with PCI device \textbf{pdev} as
being reserved by owner \textbf{res\_name}.  Do not access any
address inside the PCI regions unless this call returns
successfully.

Returns 0 on success, or \code{EBUSY} on error.  A warning
message is also printed on failure.
\end{quote}
\index{pci\_request\_regions\_exclusive (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_request_regions_exclusive}\pysiglinewithargsret{int \bfcode{pci\_request\_regions\_exclusive}}{struct pci\_dev *\emph{ pdev}, const char *\emph{ res\_name}}{}
Reserved PCI I/O and memory resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
PCI device whose resources are to be reserved

\item[{\code{const char * res\_name}}] \leavevmode
Name to be associated with resource.

\end{description}

\textbf{Description}
\begin{quote}

Mark all PCI regions associated with PCI device \textbf{pdev} as
being reserved by owner \textbf{res\_name}.  Do not access any
address inside the PCI regions unless this call returns
successfully.

{\hyperref[driver\string-api/pci:c.pci_request_regions_exclusive]{\emph{\code{pci\_request\_regions\_exclusive()}}}} will mark the region so that
/dev/mem and the sysfs MMIO access will not be allowed.

Returns 0 on success, or \code{EBUSY} on error.  A warning
message is also printed on failure.
\end{quote}
\index{pci\_remap\_iospace (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_remap_iospace}\pysiglinewithargsret{int \bfcode{pci\_remap\_iospace}}{const struct resource *\emph{ res}, phys\_addr\_t\emph{ phys\_addr}}{}
Remap the memory mapped I/O space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct resource * res}}] \leavevmode
Resource describing the I/O space

\item[{\code{phys\_addr\_t phys\_addr}}] \leavevmode
physical address of range to be mapped

\end{description}

\textbf{Description}
\begin{quote}

Remap the memory mapped I/O space described by the \textbf{res}
and the CPU physical address \textbf{phys\_addr} into virtual address space.
Only architectures that have memory mapped IO functions defined
(and the PCI\_IOBASE value defined) should call this function.
\end{quote}
\index{pci\_unmap\_iospace (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_unmap_iospace}\pysiglinewithargsret{void \bfcode{pci\_unmap\_iospace}}{struct resource *\emph{ res}}{}
Unmap the memory mapped I/O space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct resource * res}}] \leavevmode
resource to be unmapped

\end{description}

\textbf{Description}
\begin{quote}

Unmap the CPU virtual address \textbf{res} from virtual address space.
Only architectures that have memory mapped IO functions defined
(and the PCI\_IOBASE value defined) should call this function.
\end{quote}
\index{devm\_pci\_remap\_cfgspace (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.devm_pci_remap_cfgspace}\pysiglinewithargsret{void \_\_iomem * \bfcode{devm\_pci\_remap\_cfgspace}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, resource\_size\_t\emph{ offset}, resource\_size\_t\emph{ size}}{}
Managed \code{pci\_remap\_cfgspace()}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Generic device to remap IO address for

\item[{\code{resource\_size\_t offset}}] \leavevmode
Resource address to map

\item[{\code{resource\_size\_t size}}] \leavevmode
Size of map

\end{description}

\textbf{Description}

Managed \code{pci\_remap\_cfgspace()}.  Map is automatically unmapped on driver
detach.
\index{devm\_pci\_remap\_cfg\_resource (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.devm_pci_remap_cfg_resource}\pysiglinewithargsret{void \_\_iomem * \bfcode{devm\_pci\_remap\_cfg\_resource}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct resource *\emph{ res}}{}
check, request region and ioremap cfg resource

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
generic device to handle the resource for

\item[{\code{struct resource * res}}] \leavevmode
configuration space resource to be handled

\end{description}

\textbf{Description}

Checks that a resource is a valid memory region, requests the memory
region and ioremaps with \code{pci\_remap\_cfgspace()} API that ensures the
proper PCI configuration space memory attributes are guaranteed.

All operations are managed and will be undone on driver detach.

Returns a pointer to the remapped memory or an \code{ERR\_PTR()} encoded error code
on failure. Usage example:

\begin{Verbatim}[commandchars=\\\{\}]
res = platform\PYGZus{}get\PYGZus{}resource(pdev, IORESOURCE\PYGZus{}MEM, 0);
base = devm\PYGZus{}pci\PYGZus{}remap\PYGZus{}cfg\PYGZus{}resource(:c:type:{}`pdev\PYGZhy{}\PYGZgt{}dev \PYGZlt{}pdev\PYGZgt{}{}`, res);
if (IS\PYGZus{}ERR(base))
        return PTR\PYGZus{}ERR(base);
\end{Verbatim}
\index{pci\_set\_master (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_set_master}\pysiglinewithargsret{void \bfcode{pci\_set\_master}}{struct pci\_dev *\emph{ dev}}{}
enables bus-mastering for device dev

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device to enable

\end{description}

\textbf{Description}

Enables bus-mastering on the device and calls \code{pcibios\_set\_master()}
to do the needed arch specific settings.
\index{pci\_clear\_master (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_clear_master}\pysiglinewithargsret{void \bfcode{pci\_clear\_master}}{struct pci\_dev *\emph{ dev}}{}
disables bus-mastering for device dev

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device to disable

\end{description}
\index{pci\_set\_cacheline\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_set_cacheline_size}\pysiglinewithargsret{int \bfcode{pci\_set\_cacheline\_size}}{struct pci\_dev *\emph{ dev}}{}
ensure the CACHE\_LINE\_SIZE register is programmed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device for which MWI is to be enabled

\end{description}

\textbf{Description}

Helper function for pci\_set\_mwi.
Originally copied from drivers/net/acenic.c.
Copyright 1998-2001 by Jes Sorensen, \textless{}jes**trained**-monkey.org\textgreater{}.

\textbf{Return}

An appropriate -ERRNO error value on error, or zero for success.
\index{pci\_set\_mwi (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_set_mwi}\pysiglinewithargsret{int \bfcode{pci\_set\_mwi}}{struct pci\_dev *\emph{ dev}}{}
enables memory-write-invalidate PCI transaction

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device for which MWI is enabled

\end{description}

\textbf{Description}

Enables the Memory-Write-Invalidate transaction in \code{PCI\_COMMAND}.

\textbf{Return}

An appropriate -ERRNO error value on error, or zero for success.
\index{pcim\_set\_mwi (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pcim_set_mwi}\pysiglinewithargsret{int \bfcode{pcim\_set\_mwi}}{struct pci\_dev *\emph{ dev}}{}
a device-managed {\hyperref[driver\string-api/pci:c.pci_set_mwi]{\emph{\code{pci\_set\_mwi()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device for which MWI is enabled

\end{description}

\textbf{Description}

Managed {\hyperref[driver\string-api/pci:c.pci_set_mwi]{\emph{\code{pci\_set\_mwi()}}}}.

\textbf{Return}

An appropriate -ERRNO error value on error, or zero for success.
\index{pci\_try\_set\_mwi (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_try_set_mwi}\pysiglinewithargsret{int \bfcode{pci\_try\_set\_mwi}}{struct pci\_dev *\emph{ dev}}{}
enables memory-write-invalidate PCI transaction

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device for which MWI is enabled

\end{description}

\textbf{Description}

Enables the Memory-Write-Invalidate transaction in \code{PCI\_COMMAND}.
Callers are not required to check the return value.

\textbf{Return}

An appropriate -ERRNO error value on error, or zero for success.
\index{pci\_clear\_mwi (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_clear_mwi}\pysiglinewithargsret{void \bfcode{pci\_clear\_mwi}}{struct pci\_dev *\emph{ dev}}{}
disables Memory-Write-Invalidate for device dev

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device to disable

\end{description}

\textbf{Description}

Disables PCI Memory-Write-Invalidate transaction on the device
\index{pci\_intx (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_intx}\pysiglinewithargsret{void \bfcode{pci\_intx}}{struct pci\_dev *\emph{ pdev}, int\emph{ enable}}{}
enables/disables PCI INTx for device dev

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
the PCI device to operate on

\item[{\code{int enable}}] \leavevmode
boolean: whether to enable or disable PCI INTx

\end{description}

\textbf{Description}

Enables/disables PCI INTx for device dev
\index{pci\_check\_and\_mask\_intx (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_check_and_mask_intx}\pysiglinewithargsret{bool \bfcode{pci\_check\_and\_mask\_intx}}{struct pci\_dev *\emph{ dev}}{}
mask INTx on pending interrupt

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device to operate on

\end{description}

\textbf{Description}

Check if the device dev has its INTx line asserted, mask it and
return true in that case. False is returned if no interrupt was
pending.
\index{pci\_check\_and\_unmask\_intx (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_check_and_unmask_intx}\pysiglinewithargsret{bool \bfcode{pci\_check\_and\_unmask\_intx}}{struct pci\_dev *\emph{ dev}}{}
unmask INTx if no interrupt is pending

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device to operate on

\end{description}

\textbf{Description}

Check if the device dev has its INTx line asserted, unmask it if not
and return true. False is returned and the mask remains active if
there was still an interrupt pending.
\index{pci\_wait\_for\_pending\_transaction (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_wait_for_pending_transaction}\pysiglinewithargsret{int \bfcode{pci\_wait\_for\_pending\_transaction}}{struct pci\_dev *\emph{ dev}}{}
waits for pending transaction

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device to operate on

\end{description}

\textbf{Description}

Return 0 if transaction is pending 1 otherwise.
\index{pcie\_flr (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pcie_flr}\pysiglinewithargsret{void \bfcode{pcie\_flr}}{struct pci\_dev *\emph{ dev}}{}
initiate a PCIe function level reset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
device to reset

\end{description}

\textbf{Description}

Initiate a function level reset on \textbf{dev}.  The caller should ensure the
device supports FLR before calling this function, e.g. by using the
\code{pcie\_has\_flr()} helper.
\index{pci\_reset\_bridge\_secondary\_bus (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_reset_bridge_secondary_bus}\pysiglinewithargsret{void \bfcode{pci\_reset\_bridge\_secondary\_bus}}{struct pci\_dev *\emph{ dev}}{}
Reset the secondary bus on a PCI bridge.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
Bridge device

\end{description}

\textbf{Description}

Use the bridge control register to assert reset on the secondary bus.
Devices on the secondary bus are left in power-on state.
\index{\_\_pci\_reset\_function\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.__pci_reset_function_locked}\pysiglinewithargsret{int \bfcode{\_\_pci\_reset\_function\_locked}}{struct pci\_dev *\emph{ dev}}{}
reset a PCI device function while holding the \textbf{dev} mutex lock.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to reset

\end{description}

\textbf{Description}

Some devices allow an individual function to be reset without affecting
other functions in the same device.  The PCI device must be responsive
to PCI config space in order to use this function.

The device function is presumed to be unused and the caller is holding
the device mutex lock when this function is called.
Resetting the device will make the contents of PCI configuration space
random, so any caller of this must be prepared to reinitialise the
device including MSI, bus mastering, BARs, decoding IO and memory spaces,
etc.

Returns 0 if the device function was successfully reset or negative if the
device doesn't support resetting a single function.
\index{pci\_reset\_function (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_reset_function}\pysiglinewithargsret{int \bfcode{pci\_reset\_function}}{struct pci\_dev *\emph{ dev}}{}
quiesce and reset a PCI device function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to reset

\end{description}

\textbf{Description}

Some devices allow an individual function to be reset without affecting
other functions in the same device.  The PCI device must be responsive
to PCI config space in order to use this function.

This function does not just reset the PCI portion of a device, but
clears all the state associated with the device.  This function differs
from {\hyperref[driver\string-api/pci:c.__pci_reset_function_locked]{\emph{\code{\_\_pci\_reset\_function\_locked()}}}} in that it saves and restores device state
over the reset and takes the PCI device lock.

Returns 0 if the device function was successfully reset or negative if the
device doesn't support resetting a single function.
\index{pci\_reset\_function\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_reset_function_locked}\pysiglinewithargsret{int \bfcode{pci\_reset\_function\_locked}}{struct pci\_dev *\emph{ dev}}{}
quiesce and reset a PCI device function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to reset

\end{description}

\textbf{Description}

Some devices allow an individual function to be reset without affecting
other functions in the same device.  The PCI device must be responsive
to PCI config space in order to use this function.

This function does not just reset the PCI portion of a device, but
clears all the state associated with the device.  This function differs
from {\hyperref[driver\string-api/pci:c.__pci_reset_function_locked]{\emph{\code{\_\_pci\_reset\_function\_locked()}}}} in that it saves and restores device state
over the reset.  It also differs from {\hyperref[driver\string-api/pci:c.pci_reset_function]{\emph{\code{pci\_reset\_function()}}}} in that it
requires the PCI device lock to be held.

Returns 0 if the device function was successfully reset or negative if the
device doesn't support resetting a single function.
\index{pci\_try\_reset\_function (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_try_reset_function}\pysiglinewithargsret{int \bfcode{pci\_try\_reset\_function}}{struct pci\_dev *\emph{ dev}}{}
quiesce and reset a PCI device function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to reset

\end{description}

\textbf{Description}

Same as above, except return -EAGAIN if unable to lock device.
\index{pci\_probe\_reset\_slot (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_probe_reset_slot}\pysiglinewithargsret{int \bfcode{pci\_probe\_reset\_slot}}{struct pci\_slot *\emph{ slot}}{}
probe whether a PCI slot can be reset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_slot * slot}}] \leavevmode
PCI slot to probe

\end{description}

\textbf{Description}

Return 0 if slot can be reset, negative if a slot reset is not supported.
\index{pci\_reset\_slot (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_reset_slot}\pysiglinewithargsret{int \bfcode{pci\_reset\_slot}}{struct pci\_slot *\emph{ slot}}{}
reset a PCI slot

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_slot * slot}}] \leavevmode
PCI slot to reset

\end{description}

\textbf{Description}

A PCI bus may host multiple slots, each slot may support a reset mechanism
independent of other slots.  For instance, some slots may support slot power
control.  In the case of a 1:1 bus to slot architecture, this function may
wrap the bus reset to avoid spurious slot related events such as hotplug.
Generally a slot reset should be attempted before a bus reset.  All of the
function of the slot and any subordinate buses behind the slot are reset
through this function.  PCI config space of all devices in the slot and
behind the slot is saved before and restored after reset.

Return 0 on success, non-zero on error.
\index{pci\_try\_reset\_slot (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_try_reset_slot}\pysiglinewithargsret{int \bfcode{pci\_try\_reset\_slot}}{struct pci\_slot *\emph{ slot}}{}
Try to reset a PCI slot

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_slot * slot}}] \leavevmode
PCI slot to reset

\end{description}

\textbf{Description}

Same as above except return -EAGAIN if the slot cannot be locked
\index{pci\_probe\_reset\_bus (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_probe_reset_bus}\pysiglinewithargsret{int \bfcode{pci\_probe\_reset\_bus}}{struct pci\_bus *\emph{ bus}}{}
probe whether a PCI bus can be reset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_bus * bus}}] \leavevmode
PCI bus to probe

\end{description}

\textbf{Description}

Return 0 if bus can be reset, negative if a bus reset is not supported.
\index{pci\_reset\_bus (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_reset_bus}\pysiglinewithargsret{int \bfcode{pci\_reset\_bus}}{struct pci\_bus *\emph{ bus}}{}
reset a PCI bus

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_bus * bus}}] \leavevmode
top level PCI bus to reset

\end{description}

\textbf{Description}

Do a bus reset on the given bus and any subordinate buses, saving
and restoring state of all devices.

Return 0 on success, non-zero on error.
\index{pci\_try\_reset\_bus (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_try_reset_bus}\pysiglinewithargsret{int \bfcode{pci\_try\_reset\_bus}}{struct pci\_bus *\emph{ bus}}{}
Try to reset a PCI bus

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_bus * bus}}] \leavevmode
top level PCI bus to reset

\end{description}

\textbf{Description}

Same as above except return -EAGAIN if the bus cannot be locked
\index{pcix\_get\_max\_mmrbc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pcix_get_max_mmrbc}\pysiglinewithargsret{int \bfcode{pcix\_get\_max\_mmrbc}}{struct pci\_dev *\emph{ dev}}{}
get PCI-X maximum designed memory read byte count

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to query

\end{description}

\textbf{Description}
\begin{description}
\item[{Returns mmrbc: maximum designed memory read count in bytes}] \leavevmode
or appropriate error value.

\end{description}
\index{pcix\_get\_mmrbc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pcix_get_mmrbc}\pysiglinewithargsret{int \bfcode{pcix\_get\_mmrbc}}{struct pci\_dev *\emph{ dev}}{}
get PCI-X maximum memory read byte count

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to query

\end{description}

\textbf{Description}
\begin{description}
\item[{Returns mmrbc: maximum memory read count in bytes}] \leavevmode
or appropriate error value.

\end{description}
\index{pcix\_set\_mmrbc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pcix_set_mmrbc}\pysiglinewithargsret{int \bfcode{pcix\_set\_mmrbc}}{struct pci\_dev *\emph{ dev}, int\emph{ mmrbc}}{}
set PCI-X maximum memory read byte count

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to query

\item[{\code{int mmrbc}}] \leavevmode
maximum memory read count in bytes
valid values are 512, 1024, 2048, 4096

\end{description}

\textbf{Description}

If possible sets maximum memory read byte count, some bridges have erratas
that prevent this.
\index{pcie\_get\_readrq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pcie_get_readrq}\pysiglinewithargsret{int \bfcode{pcie\_get\_readrq}}{struct pci\_dev *\emph{ dev}}{}
get PCI Express read request size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to query

\end{description}

\textbf{Description}
\begin{description}
\item[{Returns maximum memory read request in bytes}] \leavevmode
or appropriate error value.

\end{description}
\index{pcie\_set\_readrq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pcie_set_readrq}\pysiglinewithargsret{int \bfcode{pcie\_set\_readrq}}{struct pci\_dev *\emph{ dev}, int\emph{ rq}}{}
set PCI Express maximum memory read request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to query

\item[{\code{int rq}}] \leavevmode
maximum memory read count in bytes
valid values are 128, 256, 512, 1024, 2048, 4096

\end{description}

\textbf{Description}

If possible sets maximum memory read request in bytes
\index{pcie\_get\_mps (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pcie_get_mps}\pysiglinewithargsret{int \bfcode{pcie\_get\_mps}}{struct pci\_dev *\emph{ dev}}{}
get PCI Express maximum payload size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to query

\end{description}

\textbf{Description}

Returns maximum payload size in bytes
\index{pcie\_set\_mps (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pcie_set_mps}\pysiglinewithargsret{int \bfcode{pcie\_set\_mps}}{struct pci\_dev *\emph{ dev}, int\emph{ mps}}{}
set PCI Express maximum payload size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to query

\item[{\code{int mps}}] \leavevmode
maximum payload size in bytes
valid values are 128, 256, 512, 1024, 2048, 4096

\end{description}

\textbf{Description}

If possible sets maximum payload size
\index{pcie\_get\_minimum\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pcie_get_minimum_link}\pysiglinewithargsret{int \bfcode{pcie\_get\_minimum\_link}}{struct pci\_dev *\emph{ dev}, enum pci\_bus\_speed *\emph{ speed}, enum pcie\_link\_width *\emph{ width}}{}
determine minimum link settings of a PCI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to query

\item[{\code{enum pci\_bus\_speed * speed}}] \leavevmode
storage for minimum speed

\item[{\code{enum pcie\_link\_width * width}}] \leavevmode
storage for minimum width

\end{description}

\textbf{Description}

This function will walk up the PCI device chain and determine the minimum
link width and speed of the device.
\index{pci\_select\_bars (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_select_bars}\pysiglinewithargsret{int \bfcode{pci\_select\_bars}}{struct pci\_dev *\emph{ dev}, unsigned long\emph{ flags}}{}
Make BAR mask from the type of resource

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device for which BAR mask is made

\item[{\code{unsigned long flags}}] \leavevmode
resource type mask to be selected

\end{description}

\textbf{Description}

This helper routine makes bar mask from the type of resource.
\index{pci\_add\_dynid (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_add_dynid}\pysiglinewithargsret{int \bfcode{pci\_add\_dynid}}{struct pci\_driver *\emph{ drv}, unsigned int\emph{ vendor}, unsigned int\emph{ device}, unsigned int\emph{ subvendor}, unsigned int\emph{ subdevice}, unsigned int\emph{ class}, unsigned int\emph{ class\_mask}, unsigned long\emph{ driver\_data}}{}
add a new PCI device ID to this driver and re-probe devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_driver * drv}}] \leavevmode
target pci driver

\item[{\code{unsigned int vendor}}] \leavevmode
PCI vendor ID

\item[{\code{unsigned int device}}] \leavevmode
PCI device ID

\item[{\code{unsigned int subvendor}}] \leavevmode
PCI subvendor ID

\item[{\code{unsigned int subdevice}}] \leavevmode
PCI subdevice ID

\item[{\code{unsigned int class}}] \leavevmode
PCI class

\item[{\code{unsigned int class\_mask}}] \leavevmode
PCI class mask

\item[{\code{unsigned long driver\_data}}] \leavevmode
private driver data

\end{description}

\textbf{Description}

Adds a new dynamic pci device ID to this driver and causes the
driver to probe for all devices again.  \textbf{drv} must have been
registered prior to calling this function.

\textbf{Context}

Does GFP\_KERNEL allocation.

\textbf{Return}

0 on success, -errno on failure.
\index{pci\_match\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_match_id}\pysiglinewithargsret{const struct pci\_device\_id * \bfcode{pci\_match\_id}}{const struct pci\_device\_id *\emph{ ids}, struct pci\_dev *\emph{ dev}}{}
See if a pci device matches a given pci\_id table

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct pci\_device\_id * ids}}] \leavevmode
array of PCI device id structures to search in

\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device structure to match against.

\end{description}

\textbf{Description}

Used by a driver to check whether a PCI device present in the
system is in its list of supported devices.  Returns the matching
pci\_device\_id structure or \code{NULL} if there is no match.

Deprecated, don't use this as it will not catch any dynamic ids
that a driver might want to check for.
\index{\_\_pci\_register\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.__pci_register_driver}\pysiglinewithargsret{int \bfcode{\_\_pci\_register\_driver}}{struct pci\_driver *\emph{ drv}, struct module *\emph{ owner}, const char *\emph{ mod\_name}}{}
register a new pci driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_driver * drv}}] \leavevmode
the driver structure to register

\item[{\code{struct module * owner}}] \leavevmode
owner module of drv

\item[{\code{const char * mod\_name}}] \leavevmode
module name string

\end{description}

\textbf{Description}

Adds the driver structure to the list of registered drivers.
Returns a negative value on error, otherwise 0.
If no error occurred, the driver remains registered even if
no device was claimed during registration.
\index{pci\_unregister\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_unregister_driver}\pysiglinewithargsret{void \bfcode{pci\_unregister\_driver}}{struct pci\_driver *\emph{ drv}}{}
unregister a pci driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_driver * drv}}] \leavevmode
the driver structure to unregister

\end{description}

\textbf{Description}

Deletes the driver structure from the list of registered PCI drivers,
gives it a chance to clean up by calling its \code{remove()} function for
each device it was responsible for, and marks those devices as
driverless.
\index{pci\_dev\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_dev_driver}\pysiglinewithargsret{struct pci\_driver * \bfcode{pci\_dev\_driver}}{const struct pci\_dev *\emph{ dev}}{}
get the pci\_driver of a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct pci\_dev * dev}}] \leavevmode
the device to query

\end{description}

\textbf{Description}

Returns the appropriate pci\_driver structure or \code{NULL} if there is no
registered driver for the device.
\index{pci\_dev\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_dev_get}\pysiglinewithargsret{struct pci\_dev * \bfcode{pci\_dev\_get}}{struct pci\_dev *\emph{ dev}}{}
increments the reference count of the pci device structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the device being referenced

\end{description}

\textbf{Description}

Each live reference to a device should be refcounted.

Drivers for PCI devices should normally record such references in
their \code{probe()} methods, when they bind to a device, and release
them by calling {\hyperref[driver\string-api/pci:c.pci_dev_put]{\emph{\code{pci\_dev\_put()}}}}, in their \code{disconnect()} methods.

A pointer to the device with the incremented reference counter is returned.
\index{pci\_dev\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_dev_put}\pysiglinewithargsret{void \bfcode{pci\_dev\_put}}{struct pci\_dev *\emph{ dev}}{}
release a use of the pci device structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
device that's been disconnected

\end{description}

\textbf{Description}

Must be called when a user of a device is finished with it.  When the last
user of the device calls this function, the memory of the device is freed.
\index{pci\_stop\_and\_remove\_bus\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_stop_and_remove_bus_device}\pysiglinewithargsret{void \bfcode{pci\_stop\_and\_remove\_bus\_device}}{struct pci\_dev *\emph{ dev}}{}
remove a PCI device and any children

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the device to remove

\end{description}

\textbf{Description}

Remove a PCI device from the device lists, informing the drivers
that the device has been removed.  We also remove any subordinate
buses and children in a depth-first manner.

For each device we remove, delete the device structure from the
device lists, remove the /proc entry, and notify userspace
(/sbin/hotplug).
\index{pci\_find\_bus (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_find_bus}\pysiglinewithargsret{struct pci\_bus * \bfcode{pci\_find\_bus}}{int\emph{ domain}, int\emph{ busnr}}{}
locate PCI bus from a given domain and bus number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int domain}}] \leavevmode
number of PCI domain to search

\item[{\code{int busnr}}] \leavevmode
number of desired PCI bus

\end{description}

\textbf{Description}

Given a PCI bus number and domain number, the desired PCI bus is located
in the global list of PCI buses.  If the bus is found, a pointer to its
data structure is returned.  If no bus is found, \code{NULL} is returned.
\index{pci\_find\_next\_bus (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_find_next_bus}\pysiglinewithargsret{struct pci\_bus * \bfcode{pci\_find\_next\_bus}}{const struct pci\_bus *\emph{ from}}{}
begin or continue searching for a PCI bus

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct pci\_bus * from}}] \leavevmode
Previous PCI bus found, or \code{NULL} for new search.

\end{description}

\textbf{Description}

Iterates through the list of known PCI buses.  A new search is
initiated by passing \code{NULL} as the \textbf{from} argument.  Otherwise if
\textbf{from} is not \code{NULL}, searches continue from next device on the
global list.
\index{pci\_get\_slot (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_get_slot}\pysiglinewithargsret{struct pci\_dev * \bfcode{pci\_get\_slot}}{struct pci\_bus *\emph{ bus}, unsigned int\emph{ devfn}}{}
locate PCI device for a given PCI slot

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_bus * bus}}] \leavevmode
PCI bus on which desired PCI device resides

\item[{\code{unsigned int devfn}}] \leavevmode
encodes number of PCI slot in which the desired PCI
device resides and the logical device number within that slot
in case of multi-function devices.

\end{description}

\textbf{Description}

Given a PCI bus and slot/function number, the desired PCI device
is located in the list of PCI devices.
If the device is found, its reference count is increased and this
function returns a pointer to its data structure.  The caller must
decrement the reference count by calling {\hyperref[driver\string-api/pci:c.pci_dev_put]{\emph{\code{pci\_dev\_put()}}}}.
If no device is found, \code{NULL} is returned.
\index{pci\_get\_domain\_bus\_and\_slot (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_get_domain_bus_and_slot}\pysiglinewithargsret{struct pci\_dev * \bfcode{pci\_get\_domain\_bus\_and\_slot}}{int\emph{ domain}, unsigned int\emph{ bus}, unsigned int\emph{ devfn}}{}
locate PCI device for a given PCI domain (segment), bus, and slot

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int domain}}] \leavevmode
PCI domain/segment on which the PCI device resides.

\item[{\code{unsigned int bus}}] \leavevmode
PCI bus on which desired PCI device resides

\item[{\code{unsigned int devfn}}] \leavevmode
encodes number of PCI slot in which the desired PCI device
resides and the logical device number within that slot in case of
multi-function devices.

\end{description}

\textbf{Description}

Given a PCI domain, bus, and slot/function number, the desired PCI
device is located in the list of PCI devices. If the device is
found, its reference count is increased and this function returns a
pointer to its data structure.  The caller must decrement the
reference count by calling {\hyperref[driver\string-api/pci:c.pci_dev_put]{\emph{\code{pci\_dev\_put()}}}}.  If no device is found,
\code{NULL} is returned.
\index{pci\_get\_subsys (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_get_subsys}\pysiglinewithargsret{struct pci\_dev * \bfcode{pci\_get\_subsys}}{unsigned int\emph{ vendor}, unsigned int\emph{ device}, unsigned int\emph{ ss\_vendor}, unsigned int\emph{ ss\_device}, struct pci\_dev *\emph{ from}}{}
begin or continue searching for a PCI device by vendor/subvendor/device/subdevice id

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int vendor}}] \leavevmode
PCI vendor id to match, or \code{PCI\_ANY\_ID} to match all vendor ids

\item[{\code{unsigned int device}}] \leavevmode
PCI device id to match, or \code{PCI\_ANY\_ID} to match all device ids

\item[{\code{unsigned int ss\_vendor}}] \leavevmode
PCI subsystem vendor id to match, or \code{PCI\_ANY\_ID} to match all vendor ids

\item[{\code{unsigned int ss\_device}}] \leavevmode
PCI subsystem device id to match, or \code{PCI\_ANY\_ID} to match all device ids

\item[{\code{struct pci\_dev * from}}] \leavevmode
Previous PCI device found in search, or \code{NULL} for new search.

\end{description}

\textbf{Description}

Iterates through the list of known PCI devices.  If a PCI device is found
with a matching \textbf{vendor}, \textbf{device}, \textbf{ss\_vendor} and \textbf{ss\_device}, a pointer to its
device structure is returned, and the reference count to the device is
incremented.  Otherwise, \code{NULL} is returned.  A new search is initiated by
passing \code{NULL} as the \textbf{from} argument.  Otherwise if \textbf{from} is not \code{NULL},
searches continue from next device on the global list.
The reference count for \textbf{from} is always decremented if it is not \code{NULL}.
\index{pci\_get\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_get_device}\pysiglinewithargsret{struct pci\_dev * \bfcode{pci\_get\_device}}{unsigned int\emph{ vendor}, unsigned int\emph{ device}, struct pci\_dev *\emph{ from}}{}
begin or continue searching for a PCI device by vendor/device id

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int vendor}}] \leavevmode
PCI vendor id to match, or \code{PCI\_ANY\_ID} to match all vendor ids

\item[{\code{unsigned int device}}] \leavevmode
PCI device id to match, or \code{PCI\_ANY\_ID} to match all device ids

\item[{\code{struct pci\_dev * from}}] \leavevmode
Previous PCI device found in search, or \code{NULL} for new search.

\end{description}

\textbf{Description}

Iterates through the list of known PCI devices.  If a PCI device is
found with a matching \textbf{vendor} and \textbf{device}, the reference count to the
device is incremented and a pointer to its device structure is returned.
Otherwise, \code{NULL} is returned.  A new search is initiated by passing \code{NULL}
as the \textbf{from} argument.  Otherwise if \textbf{from} is not \code{NULL}, searches continue
from next device on the global list.  The reference count for \textbf{from} is
always decremented if it is not \code{NULL}.
\index{pci\_get\_class (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_get_class}\pysiglinewithargsret{struct pci\_dev * \bfcode{pci\_get\_class}}{unsigned int\emph{ class}, struct pci\_dev *\emph{ from}}{}
begin or continue searching for a PCI device by class

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int class}}] \leavevmode
search for a PCI device with this class designation

\item[{\code{struct pci\_dev * from}}] \leavevmode
Previous PCI device found in search, or \code{NULL} for new search.

\end{description}

\textbf{Description}

Iterates through the list of known PCI devices.  If a PCI device is
found with a matching \textbf{class}, the reference count to the device is
incremented and a pointer to its device structure is returned.
Otherwise, \code{NULL} is returned.
A new search is initiated by passing \code{NULL} as the \textbf{from} argument.
Otherwise if \textbf{from} is not \code{NULL}, searches continue from next device
on the global list.  The reference count for \textbf{from} is always decremented
if it is not \code{NULL}.
\index{pci\_dev\_present (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_dev_present}\pysiglinewithargsret{int \bfcode{pci\_dev\_present}}{const struct pci\_device\_id *\emph{ ids}}{}
Returns 1 if device matching the device list is present, 0 if not.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct pci\_device\_id * ids}}] \leavevmode
A pointer to a null terminated list of struct pci\_device\_id structures
that describe the type of PCI device the caller is trying to find.

\end{description}

\textbf{Description}

Obvious fact: You do not have a reference to any device that might be found
by this function, so if that device is removed from the system right after
this function is finished, the value will be stale.  Use this function to
find devices that are usually built into a system, or for a general hint as
to if another device happens to be present at this specific moment in time.
\index{pci\_msi\_mask\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_msi_mask_irq}\pysiglinewithargsret{void \bfcode{pci\_msi\_mask\_irq}}{struct irq\_data *\emph{ data}}{}
Generic irq chip callback to mask PCI/MSI interrupts

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct irq\_data * data}}] \leavevmode
pointer to irqdata associated to that interrupt

\end{description}
\index{pci\_msi\_unmask\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_msi_unmask_irq}\pysiglinewithargsret{void \bfcode{pci\_msi\_unmask\_irq}}{struct irq\_data *\emph{ data}}{}
Generic irq chip callback to unmask PCI/MSI interrupts

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct irq\_data * data}}] \leavevmode
pointer to irqdata associated to that interrupt

\end{description}
\index{pci\_msi\_vec\_count (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_msi_vec_count}\pysiglinewithargsret{int \bfcode{pci\_msi\_vec\_count}}{struct pci\_dev *\emph{ dev}}{}
Return the number of MSI vectors a device can send

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
device to report about

\end{description}

\textbf{Description}

This function returns the number of MSI vectors a device requested via
Multiple Message Capable register. It returns a negative errno if the
device is not capable sending MSI interrupts. Otherwise, the call succeeds
and returns a power of two, up to a maximum of 2\textasciicircum{}5 (32), according to the
MSI specification.
\index{pci\_msix\_vec\_count (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_msix_vec_count}\pysiglinewithargsret{int \bfcode{pci\_msix\_vec\_count}}{struct pci\_dev *\emph{ dev}}{}
return the number of device's MSI-X table entries

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
pointer to the pci\_dev data structure of MSI-X device function
This function returns the number of device's MSI-X table entries and
therefore the number of MSI-X vectors device is capable of sending.
It returns a negative errno if the device is not capable of sending MSI-X
interrupts.

\end{description}
\index{pci\_msi\_enabled (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_msi_enabled}\pysiglinewithargsret{int \bfcode{pci\_msi\_enabled}}{void}{}
is MSI enabled?

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

Returns true if MSI has not been disabled by the command-line option
pci=nomsi.
\index{pci\_enable\_msix\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_enable_msix_range}\pysiglinewithargsret{int \bfcode{pci\_enable\_msix\_range}}{struct pci\_dev *\emph{ dev}, struct msix\_entry *\emph{ entries}, int\emph{ minvec}, int\emph{ maxvec}}{}
configure device's MSI-X capability structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
pointer to the pci\_dev data structure of MSI-X device function

\item[{\code{struct msix\_entry * entries}}] \leavevmode
pointer to an array of MSI-X entries

\item[{\code{int minvec}}] \leavevmode
minimum number of MSI-X irqs requested

\item[{\code{int maxvec}}] \leavevmode
maximum number of MSI-X irqs requested

\end{description}

\textbf{Description}

Setup the MSI-X capability structure of device function with a maximum
possible number of interrupts in the range between \textbf{minvec} and \textbf{maxvec}
upon its software driver call to request for MSI-X mode enabled on its
hardware device function. It returns a negative errno if an error occurs.
If it succeeds, it returns the actual number of interrupts allocated and
indicates the successful configuration of MSI-X capability structure
with new allocated MSI-X interrupts.
\index{pci\_alloc\_irq\_vectors\_affinity (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_alloc_irq_vectors_affinity}\pysiglinewithargsret{int \bfcode{pci\_alloc\_irq\_vectors\_affinity}}{struct pci\_dev *\emph{ dev}, unsigned int\emph{ min\_vecs}, unsigned int\emph{ max\_vecs}, unsigned int\emph{ flags}, const struct irq\_affinity *\emph{ affd}}{}
allocate multiple IRQs for a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to operate on

\item[{\code{unsigned int min\_vecs}}] \leavevmode
minimum number of vectors required (must be \textgreater{}= 1)

\item[{\code{unsigned int max\_vecs}}] \leavevmode
maximum (desired) number of vectors

\item[{\code{unsigned int flags}}] \leavevmode
flags or quirks for the allocation

\item[{\code{const struct irq\_affinity * affd}}] \leavevmode
optional description of the affinity requirements

\end{description}

\textbf{Description}

Allocate up to \textbf{max\_vecs} interrupt vectors for \textbf{dev}, using MSI-X or MSI
vectors if available, and fall back to a single legacy vector
if neither is available.  Return the number of vectors allocated,
(which might be smaller than \textbf{max\_vecs}) if successful, or a negative
error code on error. If less than \textbf{min\_vecs} interrupt vectors are
available for \textbf{dev} the function will fail with -ENOSPC.

To get the Linux IRQ number used for a vector that can be passed to
\code{request\_irq()} use the {\hyperref[driver\string-api/pci:c.pci_irq_vector]{\emph{\code{pci\_irq\_vector()}}}} helper.
\index{pci\_free\_irq\_vectors (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_free_irq_vectors}\pysiglinewithargsret{void \bfcode{pci\_free\_irq\_vectors}}{struct pci\_dev *\emph{ dev}}{}
free previously allocated IRQs for a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to operate on

\end{description}

\textbf{Description}

Undoes the allocations and enabling in \code{pci\_alloc\_irq\_vectors()}.
\index{pci\_irq\_vector (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_irq_vector}\pysiglinewithargsret{int \bfcode{pci\_irq\_vector}}{struct pci\_dev *\emph{ dev}, unsigned int\emph{ nr}}{}
return Linux IRQ number of a device vector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to operate on

\item[{\code{unsigned int nr}}] \leavevmode
device-relative interrupt vector index (0-based).

\end{description}
\index{pci\_irq\_get\_affinity (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_irq_get_affinity}\pysiglinewithargsret{const struct cpumask * \bfcode{pci\_irq\_get\_affinity}}{struct pci\_dev *\emph{ dev}, int\emph{ nr}}{}
return the affinity of a particular msi vector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to operate on

\item[{\code{int nr}}] \leavevmode
device-relative interrupt vector index (0-based).

\end{description}
\index{pci\_irq\_get\_node (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_irq_get_node}\pysiglinewithargsret{int \bfcode{pci\_irq\_get\_node}}{struct pci\_dev *\emph{ pdev}, int\emph{ vec}}{}
return the numa node of a particular msi vector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
PCI device to operate on

\item[{\code{int vec}}] \leavevmode
device-relative interrupt vector index (0-based).

\end{description}
\index{pci\_msi\_create\_irq\_domain (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_msi_create_irq_domain}\pysiglinewithargsret{struct irq\_domain * \bfcode{pci\_msi\_create\_irq\_domain}}{struct fwnode\_handle *\emph{ fwnode}, struct msi\_domain\_info *\emph{ info}, struct irq\_domain *\emph{ parent}}{}
Create a MSI interrupt domain

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fwnode\_handle * fwnode}}] \leavevmode
Optional fwnode of the interrupt controller

\item[{\code{struct msi\_domain\_info * info}}] \leavevmode
MSI domain info

\item[{\code{struct irq\_domain * parent}}] \leavevmode
Parent irq domain

\end{description}

\textbf{Description}

Updates the domain and chip ops and creates a MSI interrupt domain.

\textbf{Return}

A domain pointer or NULL in case of failure.
\index{pci\_bus\_alloc\_resource (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_bus_alloc_resource}\pysiglinewithargsret{int \bfcode{pci\_bus\_alloc\_resource}}{struct pci\_bus *\emph{ bus}, struct resource *\emph{ res}, resource\_size\_t\emph{ size}, resource\_size\_t\emph{ align}, resource\_size\_t\emph{ min}, unsigned long\emph{ type\_mask}, resource\_size\_t (*alignf) (void\emph{ *}, const struct resource\emph{ *}, resource\_size\_t, resource\_size\_t, void *\emph{ alignf\_data}}{}
allocate a resource from a parent bus

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_bus * bus}}] \leavevmode
PCI bus

\item[{\code{struct resource * res}}] \leavevmode
resource to allocate

\item[{\code{resource\_size\_t size}}] \leavevmode
size of resource to allocate

\item[{\code{resource\_size\_t align}}] \leavevmode
alignment of resource to allocate

\item[{\code{resource\_size\_t min}}] \leavevmode
minimum /proc/iomem address to allocate

\item[{\code{unsigned long type\_mask}}] \leavevmode
IORESOURCE\_* type flags

\item[{\code{resource\_size\_t (*)(void *, const struct resource *, resource\_size\_t, resource\_size\_t) alignf}}] \leavevmode
resource alignment function

\item[{\code{void * alignf\_data}}] \leavevmode
data argument for resource alignment function

\end{description}

\textbf{Description}

Given the PCI bus a device resides on, the size, minimum address,
alignment and type, try to find an acceptable resource allocation
for a specific device resource.
\index{pci\_bus\_add\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_bus_add_device}\pysiglinewithargsret{void \bfcode{pci\_bus\_add\_device}}{struct pci\_dev *\emph{ dev}}{}
start driver for a single device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
device to add

\end{description}

\textbf{Description}

This adds add sysfs entries and start device drivers
\index{pci\_bus\_add\_devices (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_bus_add_devices}\pysiglinewithargsret{void \bfcode{pci\_bus\_add\_devices}}{const struct pci\_bus *\emph{ bus}}{}
start driver for PCI devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct pci\_bus * bus}}] \leavevmode
bus to check for new devices

\end{description}

\textbf{Description}

Start driver for PCI devices and add some sysfs entries.
\index{pci\_bus\_set\_ops (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_bus_set_ops}\pysiglinewithargsret{struct pci\_ops * \bfcode{pci\_bus\_set\_ops}}{struct pci\_bus *\emph{ bus}, struct pci\_ops *\emph{ ops}}{}
Set raw operations of pci bus

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_bus * bus}}] \leavevmode
pci bus struct

\item[{\code{struct pci\_ops * ops}}] \leavevmode
new raw operations

\end{description}

\textbf{Description}

Return previous raw operations
\index{pci\_read\_vpd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_read_vpd}\pysiglinewithargsret{ssize\_t \bfcode{pci\_read\_vpd}}{struct pci\_dev *\emph{ dev}, loff\_t\emph{ pos}, size\_t\emph{ count}, void *\emph{ buf}}{}
Read one entry from Vital Product Data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
pci device struct

\item[{\code{loff\_t pos}}] \leavevmode
offset in vpd space

\item[{\code{size\_t count}}] \leavevmode
number of bytes to read

\item[{\code{void * buf}}] \leavevmode
pointer to where to store result

\end{description}
\index{pci\_write\_vpd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_write_vpd}\pysiglinewithargsret{ssize\_t \bfcode{pci\_write\_vpd}}{struct pci\_dev *\emph{ dev}, loff\_t\emph{ pos}, size\_t\emph{ count}, const void *\emph{ buf}}{}
Write entry to Vital Product Data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
pci device struct

\item[{\code{loff\_t pos}}] \leavevmode
offset in vpd space

\item[{\code{size\_t count}}] \leavevmode
number of bytes to write

\item[{\code{const void * buf}}] \leavevmode
buffer containing write data

\end{description}
\index{pci\_set\_vpd\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_set_vpd_size}\pysiglinewithargsret{int \bfcode{pci\_set\_vpd\_size}}{struct pci\_dev *\emph{ dev}, size\_t\emph{ len}}{}
Set size of Vital Product Data space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
pci device struct

\item[{\code{size\_t len}}] \leavevmode
size of vpd space

\end{description}
\index{pci\_cfg\_access\_lock (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_cfg_access_lock}\pysiglinewithargsret{void \bfcode{pci\_cfg\_access\_lock}}{struct pci\_dev *\emph{ dev}}{}
Lock PCI config reads/writes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
pci device struct

\end{description}

\textbf{Description}

When access is locked, any userspace reads or writes to config
space and concurrent lock requests will sleep until access is
allowed via {\hyperref[driver\string-api/pci:c.pci_cfg_access_unlock]{\emph{\code{pci\_cfg\_access\_unlock()}}}} again.
\index{pci\_cfg\_access\_trylock (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_cfg_access_trylock}\pysiglinewithargsret{bool \bfcode{pci\_cfg\_access\_trylock}}{struct pci\_dev *\emph{ dev}}{}
try to lock PCI config reads/writes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
pci device struct

\end{description}

\textbf{Description}

Same as pci\_cfg\_access\_lock, but will return 0 if access is
already locked, 1 otherwise. This function can be used from
atomic contexts.
\index{pci\_cfg\_access\_unlock (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_cfg_access_unlock}\pysiglinewithargsret{void \bfcode{pci\_cfg\_access\_unlock}}{struct pci\_dev *\emph{ dev}}{}
Unlock PCI config reads/writes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
pci device struct

\end{description}

\textbf{Description}

This function allows PCI config accesses to resume.
\index{pci\_lost\_interrupt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_lost_interrupt}\pysiglinewithargsret{enum pci\_lost\_interrupt\_reason \bfcode{pci\_lost\_interrupt}}{struct pci\_dev *\emph{ pdev}}{}
reports a lost PCI interrupt

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
device whose interrupt is lost

\end{description}

\textbf{Description}

The primary function of this routine is to report a lost interrupt
in a standard way which users can recognise (instead of blaming the
driver).

\textbf{Return}

a suggestion for fixing it (although the driver is not required to
act on this).
\index{pci\_request\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_request_irq}\pysiglinewithargsret{int \bfcode{pci\_request\_irq}}{struct pci\_dev *\emph{ dev}, unsigned int\emph{ nr}, irq\_handler\_t\emph{ handler}, irq\_handler\_t\emph{ thread\_fn}, void *\emph{ dev\_id}, const char *\emph{ fmt}, ...}{}
allocate an interrupt line for a PCI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to operate on

\item[{\code{unsigned int nr}}] \leavevmode
device-relative interrupt vector index (0-based).

\item[{\code{irq\_handler\_t handler}}] \leavevmode
Function to be called when the IRQ occurs.
Primary handler for threaded interrupts.
If NULL and thread\_fn != NULL the default primary handler is
installed.

\item[{\code{irq\_handler\_t thread\_fn}}] \leavevmode
Function called from the IRQ handler thread
If NULL, no IRQ thread is created

\item[{\code{void * dev\_id}}] \leavevmode
Cookie passed back to the handler function

\item[{\code{const char * fmt}}] \leavevmode
Printf-like format string naming the handler

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

This call allocates interrupt resources and enables the interrupt line and
IRQ handling. From the point this call is made \textbf{handler} and \textbf{thread\_fn} may
be invoked.  All interrupts requested using this function might be shared.

\textbf{dev\_id} must not be NULL and must be globally unique.
\index{pci\_free\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_free_irq}\pysiglinewithargsret{void \bfcode{pci\_free\_irq}}{struct pci\_dev *\emph{ dev}, unsigned int\emph{ nr}, void *\emph{ dev\_id}}{}
free an interrupt allocated with pci\_request\_irq

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to operate on

\item[{\code{unsigned int nr}}] \leavevmode
device-relative interrupt vector index (0-based).

\item[{\code{void * dev\_id}}] \leavevmode
Device identity to free

\end{description}

\textbf{Description}

Remove an interrupt handler. The handler is removed and if the interrupt
line is no longer in use by any driver it is disabled.  The caller must
ensure the interrupt is disabled on the device before calling this function.
The function does not return until any executing interrupts for this IRQ
have completed.

This function must not be called from interrupt context.
\index{pcie\_relaxed\_ordering\_enabled (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pcie_relaxed_ordering_enabled}\pysiglinewithargsret{bool \bfcode{pcie\_relaxed\_ordering\_enabled}}{struct pci\_dev *\emph{ dev}}{}
Probe for PCIe relaxed ordering enable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
PCI device to query

\end{description}

\textbf{Description}

Returns true if the device has enabled relaxed ordering attribute.
\index{pci\_scan\_slot (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_scan_slot}\pysiglinewithargsret{int \bfcode{pci\_scan\_slot}}{struct pci\_bus *\emph{ bus}, int\emph{ devfn}}{}
Scan a PCI slot on a bus for devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_bus * bus}}] \leavevmode
PCI bus to scan

\item[{\code{int devfn}}] \leavevmode
slot number to scan (must have zero function)

\end{description}

\textbf{Description}

Scan a PCI slot on the specified PCI bus for devices, adding
discovered devices to the \textbf{bus}-\textgreater{}devices list.  New devices
will not have is\_added set.

Returns the number of new devices found.
\index{pci\_scan\_child\_bus (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_scan_child_bus}\pysiglinewithargsret{unsigned int \bfcode{pci\_scan\_child\_bus}}{struct pci\_bus *\emph{ bus}}{}
Scan devices below a bus

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_bus * bus}}] \leavevmode
Bus to scan for devices

\end{description}

\textbf{Description}

Scans devices below \textbf{bus} including subordinate buses. Returns new
subordinate number including all the found devices.
\index{pci\_rescan\_bus (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_rescan_bus}\pysiglinewithargsret{unsigned int \bfcode{pci\_rescan\_bus}}{struct pci\_bus *\emph{ bus}}{}
Scan a PCI bus for devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_bus * bus}}] \leavevmode
PCI bus to scan

\end{description}

\textbf{Description}

Scan a PCI bus and child buses for new devices, add them,
and enable them.

Returns the max number of subordinate bus discovered.
\index{pci\_create\_slot (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_create_slot}\pysiglinewithargsret{struct pci\_slot * \bfcode{pci\_create\_slot}}{struct pci\_bus *\emph{ parent}, int\emph{ slot\_nr}, const char *\emph{ name}, struct hotplug\_slot *\emph{ hotplug}}{}
create or increment refcount for physical PCI slot

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_bus * parent}}] \leavevmode
struct pci\_bus of parent bridge

\item[{\code{int slot\_nr}}] \leavevmode
PCI\_SLOT(pci\_dev-\textgreater{}devfn) or -1 for placeholder

\item[{\code{const char * name}}] \leavevmode
user visible string presented in /sys/bus/pci/slots/\textless{}name\textgreater{}

\item[{\code{struct hotplug\_slot * hotplug}}] \leavevmode
set if caller is hotplug driver, NULL otherwise

\end{description}

\textbf{Description}

PCI slots have first class attributes such as address, speed, width,
and a \code{struct pci\_slot} is used to manage them. This interface will
either return a new \code{struct pci\_slot} to the caller, or if the pci\_slot
already exists, its refcount will be incremented.

Slots are uniquely identified by a \textbf{pci\_bus}, \textbf{slot\_nr} tuple.

There are known platforms with broken firmware that assign the same
name to multiple slots. Workaround these broken platforms by renaming
the slots on behalf of the caller. If firmware assigns name N to
multiple slots:

The first slot is assigned N
The second slot is assigned N-1
The third slot is assigned N-2
etc.

Placeholder slots:
In most cases, \textbf{pci\_bus}, \textbf{slot\_nr} will be sufficient to uniquely identify
a slot. There is one notable exception - pSeries (rpaphp), where the
\textbf{slot\_nr} cannot be determined until a device is actually inserted into
the slot. In this scenario, the caller may pass -1 for \textbf{slot\_nr}.

The following semantics are imposed when the caller passes \textbf{slot\_nr} ==
-1. First, we no longer check for an existing \code{struct} pci\_slot, as there
may be many slots with \textbf{slot\_nr} of -1.  The other change in semantics is
user-visible, which is the `address' parameter presented in sysfs will
consist solely of a dddd:bb tuple, where dddd is the PCI domain of the
\code{struct} pci\_bus and bb is the bus number. In other words, the devfn of
the `placeholder' slot will not be displayed.
\index{pci\_destroy\_slot (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_destroy_slot}\pysiglinewithargsret{void \bfcode{pci\_destroy\_slot}}{struct pci\_slot *\emph{ slot}}{}
decrement refcount for physical PCI slot

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_slot * slot}}] \leavevmode
struct pci\_slot to decrement

\end{description}

\textbf{Description}

\code{struct} pci\_slot is refcounted, so destroying them is really easy; we
just call kobject\_put on its kobj and let our release methods do the
rest.
\index{pci\_hp\_create\_module\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_hp_create_module_link}\pysiglinewithargsret{void \bfcode{pci\_hp\_create\_module\_link}}{struct pci\_slot *\emph{ pci\_slot}}{}
create symbolic link to the hotplug driver module.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_slot * pci\_slot}}] \leavevmode
struct pci\_slot

\end{description}

\textbf{Description}

Helper function for pci\_hotplug\_core.c to create symbolic link to
the hotplug driver module.
\index{pci\_hp\_remove\_module\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_hp_remove_module_link}\pysiglinewithargsret{void \bfcode{pci\_hp\_remove\_module\_link}}{struct pci\_slot *\emph{ pci\_slot}}{}
remove symbolic link to the hotplug driver module.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_slot * pci\_slot}}] \leavevmode
struct pci\_slot

\end{description}

\textbf{Description}

Helper function for pci\_hotplug\_core.c to remove symbolic link to
the hotplug driver module.
\index{pci\_enable\_rom (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_enable_rom}\pysiglinewithargsret{int \bfcode{pci\_enable\_rom}}{struct pci\_dev *\emph{ pdev}}{}
enable ROM decoding for a PCI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
PCI device to enable

\end{description}

\textbf{Description}

Enable ROM decoding on \textbf{dev}.  This involves simply turning on the last
bit of the PCI ROM BAR.  Note that some cards may share address decoders
between the ROM and other resources, so enabling it may disable access
to MMIO registers or other card memory.
\index{pci\_disable\_rom (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_disable_rom}\pysiglinewithargsret{void \bfcode{pci\_disable\_rom}}{struct pci\_dev *\emph{ pdev}}{}
disable ROM decoding for a PCI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
PCI device to disable

\end{description}

\textbf{Description}

Disable ROM decoding on a PCI device by turning off the last bit in the
ROM BAR.
\index{pci\_map\_rom (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_map_rom}\pysiglinewithargsret{void \_\_iomem * \bfcode{pci\_map\_rom}}{struct pci\_dev *\emph{ pdev}, size\_t *\emph{ size}}{}
map a PCI ROM to kernel space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
pointer to pci device struct

\item[{\code{size\_t * size}}] \leavevmode
pointer to receive size of pci window over ROM

\end{description}

\textbf{Return}

kernel virtual pointer to image of ROM

Map a PCI ROM into kernel space. If ROM is boot video ROM,
the shadow BIOS copy will be returned instead of the
actual ROM.
\index{pci\_unmap\_rom (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_unmap_rom}\pysiglinewithargsret{void \bfcode{pci\_unmap\_rom}}{struct pci\_dev *\emph{ pdev}, void \_\_iomem *\emph{ rom}}{}
unmap the ROM from kernel space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
pointer to pci device struct

\item[{\code{void \_\_iomem * rom}}] \leavevmode
virtual address of the previous mapping

\end{description}

\textbf{Description}

Remove a mapping of a previously mapped ROM
\index{pci\_platform\_rom (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_platform_rom}\pysiglinewithargsret{void \_\_iomem * \bfcode{pci\_platform\_rom}}{struct pci\_dev *\emph{ pdev}, size\_t *\emph{ size}}{}
provides a pointer to any ROM image provided by the platform

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
pointer to pci device struct

\item[{\code{size\_t * size}}] \leavevmode
pointer to receive size of pci window over ROM

\end{description}
\index{pci\_enable\_sriov (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_enable_sriov}\pysiglinewithargsret{int \bfcode{pci\_enable\_sriov}}{struct pci\_dev *\emph{ dev}, int\emph{ nr\_virtfn}}{}
enable the SR-IOV capability

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device

\item[{\code{int nr\_virtfn}}] \leavevmode
number of virtual functions to enable

\end{description}

\textbf{Description}

Returns 0 on success, or negative on failure.
\index{pci\_disable\_sriov (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_disable_sriov}\pysiglinewithargsret{void \bfcode{pci\_disable\_sriov}}{struct pci\_dev *\emph{ dev}}{}
disable the SR-IOV capability

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device

\end{description}
\index{pci\_num\_vf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_num_vf}\pysiglinewithargsret{int \bfcode{pci\_num\_vf}}{struct pci\_dev *\emph{ dev}}{}
return number of VFs associated with a PF device\_release\_driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device

\end{description}

\textbf{Description}

Returns number of VFs, or 0 if SR-IOV is not enabled.
\index{pci\_vfs\_assigned (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_vfs_assigned}\pysiglinewithargsret{int \bfcode{pci\_vfs\_assigned}}{struct pci\_dev *\emph{ dev}}{}
returns number of VFs are assigned to a guest

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI device

\end{description}

\textbf{Description}

Returns number of VFs belonging to this device that are assigned to a guest.
If device is not a physical function returns 0.
\index{pci\_sriov\_set\_totalvfs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_sriov_set_totalvfs}\pysiglinewithargsret{int \bfcode{pci\_sriov\_set\_totalvfs}}{struct pci\_dev *\emph{ dev}, u16\emph{ numvfs}}{}~\begin{itemize}
\item {} 
reduce the TotalVFs available

\end{itemize}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI PF device

\item[{\code{u16 numvfs}}] \leavevmode
number that should be used for TotalVFs supported

\end{description}

\textbf{Description}

Should be called from PF driver's probe routine with
device's mutex held.

Returns 0 if PF is an SRIOV-capable device and
value of numvfs valid. If not a PF return -ENOSYS;
if numvfs is invalid return -EINVAL;
if VFs already enabled, return -EBUSY.
\index{pci\_sriov\_get\_totalvfs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_sriov_get_totalvfs}\pysiglinewithargsret{int \bfcode{pci\_sriov\_get\_totalvfs}}{struct pci\_dev *\emph{ dev}}{}~\begin{itemize}
\item {} 
get total VFs supported on this device

\end{itemize}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * dev}}] \leavevmode
the PCI PF device

\end{description}

\textbf{Description}

For a PCIe device with SRIOV support, return the PCIe
SRIOV capability value of TotalVFs or the value of driver\_max\_VFs
if the driver reduced it.  Otherwise 0.
\index{pci\_read\_legacy\_io (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_read_legacy_io}\pysiglinewithargsret{ssize\_t \bfcode{pci\_read\_legacy\_io}}{struct file *\emph{ filp}, struct kobject *\emph{ kobj}, struct bin\_attribute *\emph{ bin\_attr}, char *\emph{ buf}, loff\_t\emph{ off}, size\_t\emph{ count}}{}
read byte(s) from legacy I/O port space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
open sysfs file

\item[{\code{struct kobject * kobj}}] \leavevmode
kobject corresponding to file to read from

\item[{\code{struct bin\_attribute * bin\_attr}}] \leavevmode
struct bin\_attribute for this file

\item[{\code{char * buf}}] \leavevmode
buffer to store results

\item[{\code{loff\_t off}}] \leavevmode
offset into legacy I/O port space

\item[{\code{size\_t count}}] \leavevmode
number of bytes to read

\end{description}

\textbf{Description}

Reads 1, 2, or 4 bytes from legacy I/O port space using an arch specific
callback routine (pci\_legacy\_read).
\index{pci\_write\_legacy\_io (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_write_legacy_io}\pysiglinewithargsret{ssize\_t \bfcode{pci\_write\_legacy\_io}}{struct file *\emph{ filp}, struct kobject *\emph{ kobj}, struct bin\_attribute *\emph{ bin\_attr}, char *\emph{ buf}, loff\_t\emph{ off}, size\_t\emph{ count}}{}
write byte(s) to legacy I/O port space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
open sysfs file

\item[{\code{struct kobject * kobj}}] \leavevmode
kobject corresponding to file to read from

\item[{\code{struct bin\_attribute * bin\_attr}}] \leavevmode
struct bin\_attribute for this file

\item[{\code{char * buf}}] \leavevmode
buffer containing value to be written

\item[{\code{loff\_t off}}] \leavevmode
offset into legacy I/O port space

\item[{\code{size\_t count}}] \leavevmode
number of bytes to write

\end{description}

\textbf{Description}

Writes 1, 2, or 4 bytes from legacy I/O port space using an arch specific
callback routine (pci\_legacy\_write).
\index{pci\_mmap\_legacy\_mem (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_mmap_legacy_mem}\pysiglinewithargsret{int \bfcode{pci\_mmap\_legacy\_mem}}{struct file *\emph{ filp}, struct kobject *\emph{ kobj}, struct bin\_attribute *\emph{ attr}, struct vm\_area\_struct *\emph{ vma}}{}
map legacy PCI memory into user memory space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
open sysfs file

\item[{\code{struct kobject * kobj}}] \leavevmode
kobject corresponding to device to be mapped

\item[{\code{struct bin\_attribute * attr}}] \leavevmode
struct bin\_attribute for this file

\item[{\code{struct vm\_area\_struct * vma}}] \leavevmode
struct vm\_area\_struct passed to mmap

\end{description}

\textbf{Description}

Uses an arch specific callback, pci\_mmap\_legacy\_mem\_page\_range, to mmap
legacy memory space (first meg of bus space) into application virtual
memory space.
\index{pci\_mmap\_legacy\_io (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_mmap_legacy_io}\pysiglinewithargsret{int \bfcode{pci\_mmap\_legacy\_io}}{struct file *\emph{ filp}, struct kobject *\emph{ kobj}, struct bin\_attribute *\emph{ attr}, struct vm\_area\_struct *\emph{ vma}}{}
map legacy PCI IO into user memory space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
open sysfs file

\item[{\code{struct kobject * kobj}}] \leavevmode
kobject corresponding to device to be mapped

\item[{\code{struct bin\_attribute * attr}}] \leavevmode
struct bin\_attribute for this file

\item[{\code{struct vm\_area\_struct * vma}}] \leavevmode
struct vm\_area\_struct passed to mmap

\end{description}

\textbf{Description}

Uses an arch specific callback, pci\_mmap\_legacy\_io\_page\_range, to mmap
legacy IO space (first meg of bus space) into application virtual
memory space. Returns -ENOSYS if the operation isn't supported
\index{pci\_adjust\_legacy\_attr (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_adjust_legacy_attr}\pysiglinewithargsret{void \bfcode{pci\_adjust\_legacy\_attr}}{struct pci\_bus *\emph{ b}, enum pci\_mmap\_state\emph{ mmap\_type}}{}
adjustment of legacy file attributes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_bus * b}}] \leavevmode
bus to create files under

\item[{\code{enum pci\_mmap\_state mmap\_type}}] \leavevmode
I/O port or memory

\end{description}

\textbf{Description}

Stub implementation. Can be overridden by arch if necessary.
\index{pci\_create\_legacy\_files (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_create_legacy_files}\pysiglinewithargsret{void \bfcode{pci\_create\_legacy\_files}}{struct pci\_bus *\emph{ b}}{}
create legacy I/O port and memory files

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_bus * b}}] \leavevmode
bus to create files under

\end{description}

\textbf{Description}

Some platforms allow access to legacy I/O port and ISA memory space on
a per-bus basis.  This routine creates the files and ties them into
their associated read, write and mmap files from pci-sysfs.c

On error unwind, but don't propagate the error to the caller
as it is ok to set up the PCI bus without these files.
\index{pci\_mmap\_resource (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_mmap_resource}\pysiglinewithargsret{int \bfcode{pci\_mmap\_resource}}{struct kobject *\emph{ kobj}, struct bin\_attribute *\emph{ attr}, struct vm\_area\_struct *\emph{ vma}, int\emph{ write\_combine}}{}
map a PCI resource into user memory space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
kobject for mapping

\item[{\code{struct bin\_attribute * attr}}] \leavevmode
struct bin\_attribute for the file being mapped

\item[{\code{struct vm\_area\_struct * vma}}] \leavevmode
struct vm\_area\_struct passed into the mmap

\item[{\code{int write\_combine}}] \leavevmode
1 for write\_combine mapping

\end{description}

\textbf{Description}

Use the regular PCI mapping routines to map a PCI resource into userspace.
\index{pci\_remove\_resource\_files (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_remove_resource_files}\pysiglinewithargsret{void \bfcode{pci\_remove\_resource\_files}}{struct pci\_dev *\emph{ pdev}}{}
cleanup resource files

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
dev to cleanup

\end{description}

\textbf{Description}

If we created resource files for \textbf{pdev}, remove them from sysfs and
free their resources.
\index{pci\_create\_resource\_files (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_create_resource_files}\pysiglinewithargsret{int \bfcode{pci\_create\_resource\_files}}{struct pci\_dev *\emph{ pdev}}{}
create resource files in sysfs for \textbf{dev}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
dev in question

\end{description}

\textbf{Description}

Walk the resources in \textbf{pdev} creating files for each resource available.
\index{pci\_write\_rom (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_write_rom}\pysiglinewithargsret{ssize\_t \bfcode{pci\_write\_rom}}{struct file *\emph{ filp}, struct kobject *\emph{ kobj}, struct bin\_attribute *\emph{ bin\_attr}, char *\emph{ buf}, loff\_t\emph{ off}, size\_t\emph{ count}}{}
used to enable access to the PCI ROM display

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
sysfs file

\item[{\code{struct kobject * kobj}}] \leavevmode
kernel object handle

\item[{\code{struct bin\_attribute * bin\_attr}}] \leavevmode
struct bin\_attribute for this file

\item[{\code{char * buf}}] \leavevmode
user input

\item[{\code{loff\_t off}}] \leavevmode
file offset

\item[{\code{size\_t count}}] \leavevmode
number of byte in input

\end{description}

\textbf{Description}

writing anything except 0 enables it
\index{pci\_read\_rom (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_read_rom}\pysiglinewithargsret{ssize\_t \bfcode{pci\_read\_rom}}{struct file *\emph{ filp}, struct kobject *\emph{ kobj}, struct bin\_attribute *\emph{ bin\_attr}, char *\emph{ buf}, loff\_t\emph{ off}, size\_t\emph{ count}}{}
read a PCI ROM

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
sysfs file

\item[{\code{struct kobject * kobj}}] \leavevmode
kernel object handle

\item[{\code{struct bin\_attribute * bin\_attr}}] \leavevmode
struct bin\_attribute for this file

\item[{\code{char * buf}}] \leavevmode
where to put the data we read from the ROM

\item[{\code{loff\_t off}}] \leavevmode
file offset

\item[{\code{size\_t count}}] \leavevmode
number of bytes to read

\end{description}

\textbf{Description}

Put \textbf{count} bytes starting at \textbf{off} into \textbf{buf} from the ROM in the PCI
device corresponding to \textbf{kobj}.
\index{pci\_remove\_sysfs\_dev\_files (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_remove_sysfs_dev_files}\pysiglinewithargsret{void \bfcode{pci\_remove\_sysfs\_dev\_files}}{struct pci\_dev *\emph{ pdev}}{}
cleanup PCI specific sysfs files

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
device whose entries we should free

\end{description}

\textbf{Description}

Cleanup when \textbf{pdev} is removed from sysfs.


\chapter{PCI Hotplug Support Library}
\label{driver-api/pci:pci-hotplug-support-library}\index{\_\_pci\_hp\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.__pci_hp_register}\pysiglinewithargsret{int \bfcode{\_\_pci\_hp\_register}}{struct hotplug\_slot *\emph{ slot}, struct pci\_bus *\emph{ bus}, int\emph{ devnr}, const char *\emph{ name}, struct module *\emph{ owner}, const char *\emph{ mod\_name}}{}
register a hotplug\_slot with the PCI hotplug subsystem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hotplug\_slot * slot}}] \leavevmode
pointer to the \code{struct hotplug\_slot} to register

\item[{\code{struct pci\_bus * bus}}] \leavevmode
bus this slot is on

\item[{\code{int devnr}}] \leavevmode
device number

\item[{\code{const char * name}}] \leavevmode
name registered with kobject core

\item[{\code{struct module * owner}}] \leavevmode
caller module owner

\item[{\code{const char * mod\_name}}] \leavevmode
caller module name

\end{description}

\textbf{Description}

Registers a hotplug slot with the pci hotplug subsystem, which will allow
userspace interaction to the slot.

Returns 0 if successful, anything else for an error.
\index{pci\_hp\_deregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_hp_deregister}\pysiglinewithargsret{int \bfcode{pci\_hp\_deregister}}{struct hotplug\_slot *\emph{ slot}}{}
deregister a hotplug\_slot with the PCI hotplug subsystem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hotplug\_slot * slot}}] \leavevmode
pointer to the \code{struct hotplug\_slot} to deregister

\end{description}

\textbf{Description}

The \textbf{slot} must have been registered with the pci hotplug subsystem
previously with a call to \code{pci\_hp\_register()}.

Returns 0 if successful, anything else for an error.
\index{pci\_hp\_change\_slot\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/pci:c.pci_hp_change_slot_info}\pysiglinewithargsret{int \bfcode{pci\_hp\_change\_slot\_info}}{struct hotplug\_slot *\emph{ slot}, struct hotplug\_slot\_info *\emph{ info}}{}
changes the slot's information structure in the core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hotplug\_slot * slot}}] \leavevmode
pointer to the slot whose info has changed

\item[{\code{struct hotplug\_slot\_info * info}}] \leavevmode
pointer to the info copy into the slot's info structure

\end{description}

\textbf{Description}

\textbf{slot} must have been registered with the pci
hotplug subsystem previously with a call to \code{pci\_hp\_register()}.

Returns 0 if successful, anything else for an error.


\chapter{Serial Peripheral Interface (SPI)}
\label{driver-api/spi::doc}\label{driver-api/spi:serial-peripheral-interface-spi}
SPI is the ``Serial Peripheral Interface'', widely used with embedded
systems because it is a simple and efficient interface: basically a
multiplexed shift register. Its three signal wires hold a clock (SCK,
often in the range of 1-20 MHz), a ``Master Out, Slave In'' (MOSI) data
line, and a ``Master In, Slave Out'' (MISO) data line. SPI is a full
duplex protocol; for each bit shifted out the MOSI line (one per clock)
another is shifted in on the MISO line. Those bits are assembled into
words of various sizes on the way to and from system memory. An
additional chipselect line is usually active-low (nCS); four signals are
normally used for each peripheral, plus sometimes an interrupt.

The SPI bus facilities listed here provide a generalized interface to
declare SPI busses and devices, manage them according to the standard
Linux driver model, and perform input/output operations. At this time,
only ``master'' side interfaces are supported, where Linux talks to SPI
peripherals and does not implement such a peripheral itself. (Interfaces
to support implementing SPI slaves would necessarily look different.)

The programming interface is structured around two kinds of driver, and
two kinds of device. A ``Controller Driver'' abstracts the controller
hardware, which may be as simple as a set of GPIO pins or as complex as
a pair of FIFOs connected to dual DMA engines on the other side of the
SPI shift register (maximizing throughput). Such drivers bridge between
whatever bus they sit on (often the platform bus) and SPI, and expose
the SPI side of their device as a \code{struct spi\_master}. SPI devices are children of that master,
represented as a {\hyperref[driver\string-api/spi:c.spi_device]{\emph{\code{struct spi\_device}}}} and
manufactured from {\hyperref[driver\string-api/spi:c.spi_board_info]{\emph{\code{struct spi\_board\_info}}}} descriptors which are usually provided by
board-specific initialization code. A {\hyperref[driver\string-api/spi:c.spi_driver]{\emph{\code{struct spi\_driver}}}} is called a ``Protocol Driver'', and is bound to a
spi\_device using normal driver model calls.

The I/O model is a set of queued messages. Protocol drivers submit one
or more {\hyperref[driver\string-api/spi:c.spi_message]{\emph{\code{struct spi\_message}}}} objects,
which are processed and completed asynchronously. (There are synchronous
wrappers, however.) Messages are built from one or more
{\hyperref[driver\string-api/spi:c.spi_transfer]{\emph{\code{struct spi\_transfer}}}} objects, each of
which wraps a full duplex SPI transfer. A variety of protocol tweaking
options are needed, because different chips adopt very different
policies for how they use the bits transferred with SPI.
\index{spi\_statistics (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_statistics}\pysigline{struct \bfcode{spi\_statistics}}
statistics for spi transfers

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct spi\PYGZus{}statistics \PYGZob{}
  spinlock\PYGZus{}t lock;
  unsigned long           messages;
  unsigned long           transfers;
  unsigned long           errors;
  unsigned long           timedout;
  unsigned long           spi\PYGZus{}sync;
  unsigned long           spi\PYGZus{}sync\PYGZus{}immediate;
  unsigned long           spi\PYGZus{}async;
  unsigned long long      bytes;
  unsigned long long      bytes\PYGZus{}rx;
  unsigned long long      bytes\PYGZus{}tx;
\PYGZsh{}define SPI\PYGZus{}STATISTICS\PYGZus{}HISTO\PYGZus{}SIZE 17;
  unsigned long transfer\PYGZus{}bytes\PYGZus{}histo[SPI\PYGZus{}STATISTICS\PYGZus{}HISTO\PYGZus{}SIZE];
  unsigned long transfers\PYGZus{}split\PYGZus{}maxsize;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{lock}}] \leavevmode
lock protecting this structure

\item[{\code{messages}}] \leavevmode
number of spi-messages handled

\item[{\code{transfers}}] \leavevmode
number of spi\_transfers handled

\item[{\code{errors}}] \leavevmode
number of errors during spi\_transfer

\item[{\code{timedout}}] \leavevmode
number of timeouts during spi\_transfer

\item[{\code{spi\_sync}}] \leavevmode
number of times spi\_sync is used

\item[{\code{spi\_sync\_immediate}}] \leavevmode
number of times spi\_sync is executed immediately
in calling context without queuing and scheduling

\item[{\code{spi\_async}}] \leavevmode
number of times spi\_async is used

\item[{\code{bytes}}] \leavevmode
number of bytes transferred to/from device

\item[{\code{bytes\_rx}}] \leavevmode
number of bytes received from device

\item[{\code{bytes\_tx}}] \leavevmode
number of bytes sent to device

\item[{\code{transfer\_bytes\_histo}}] \leavevmode
transfer bytes histogramm

\item[{\code{transfers\_split\_maxsize}}] \leavevmode
number of transfers that have been split because of
maxsize limit

\end{description}
\index{spi\_device (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_device}\pysigline{struct \bfcode{spi\_device}}
Controller side proxy for an SPI slave device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct spi\PYGZus{}device \PYGZob{}
  struct device           dev;
  struct spi\PYGZus{}controller   *controller;
  struct spi\PYGZus{}controller   *master;
  u32 max\PYGZus{}speed\PYGZus{}hz;
  u8 chip\PYGZus{}select;
  u8 bits\PYGZus{}per\PYGZus{}word;
  u16 mode;
\PYGZsh{}define SPI\PYGZus{}CPHA        0x01                    ;
\PYGZsh{}define SPI\PYGZus{}CPOL        0x02                    ;
\PYGZsh{}define SPI\PYGZus{}MODE\PYGZus{}0      (0\textbar{}0)                   ;
\PYGZsh{}define SPI\PYGZus{}MODE\PYGZus{}1      (0\textbar{}SPI\PYGZus{}CPHA);
\PYGZsh{}define SPI\PYGZus{}MODE\PYGZus{}2      (SPI\PYGZus{}CPOL\textbar{}0);
\PYGZsh{}define SPI\PYGZus{}MODE\PYGZus{}3      (SPI\PYGZus{}CPOL\textbar{}SPI\PYGZus{}CPHA);
\PYGZsh{}define SPI\PYGZus{}CS\PYGZus{}HIGH     0x04                    ;
\PYGZsh{}define SPI\PYGZus{}LSB\PYGZus{}FIRST   0x08                    ;
\PYGZsh{}define SPI\PYGZus{}3WIRE       0x10                    ;
\PYGZsh{}define SPI\PYGZus{}LOOP        0x20                    ;
\PYGZsh{}define SPI\PYGZus{}NO\PYGZus{}CS       0x40                    ;
\PYGZsh{}define SPI\PYGZus{}READY       0x80                    ;
\PYGZsh{}define SPI\PYGZus{}TX\PYGZus{}DUAL     0x100                   ;
\PYGZsh{}define SPI\PYGZus{}TX\PYGZus{}QUAD     0x200                   ;
\PYGZsh{}define SPI\PYGZus{}RX\PYGZus{}DUAL     0x400                   ;
\PYGZsh{}define SPI\PYGZus{}RX\PYGZus{}QUAD     0x800                   ;
  int irq;
  void *controller\PYGZus{}state;
  void *controller\PYGZus{}data;
  char modalias[SPI\PYGZus{}NAME\PYGZus{}SIZE];
  int cs\PYGZus{}gpio;
  struct spi\PYGZus{}statistics   statistics;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev}}] \leavevmode
Driver model representation of the device.

\item[{\code{controller}}] \leavevmode
SPI controller used with the device.

\item[{\code{master}}] \leavevmode
Copy of controller, for backwards compatibility.

\item[{\code{max\_speed\_hz}}] \leavevmode
Maximum clock rate to be used with this chip
(on this board); may be changed by the device's driver.
The spi\_transfer.speed\_hz can override this for each transfer.

\item[{\code{chip\_select}}] \leavevmode
Chipselect, distinguishing chips handled by \textbf{controller}.

\item[{\code{bits\_per\_word}}] \leavevmode
Data transfers involve one or more words; word sizes
like eight or 12 bits are common.  In-memory wordsizes are
powers of two bytes (e.g. 20 bit samples use 32 bits).
This may be changed by the device's driver, or left at the
default (0) indicating protocol words are eight bit bytes.
The spi\_transfer.bits\_per\_word can override this for each transfer.

\item[{\code{mode}}] \leavevmode
The spi mode defines how data is clocked out and in.
This may be changed by the device's driver.
The ``active low'' default for chipselect mode can be overridden
(by specifying SPI\_CS\_HIGH) as can the ``MSB first'' default for
each word in a transfer (by specifying SPI\_LSB\_FIRST).

\item[{\code{irq}}] \leavevmode
Negative, or the number passed to \code{request\_irq()} to receive
interrupts from this device.

\item[{\code{controller\_state}}] \leavevmode
Controller's runtime state

\item[{\code{controller\_data}}] \leavevmode
Board-specific definitions for controller, such as
FIFO initialization parameters; from board\_info.controller\_data

\item[{\code{modalias}}] \leavevmode
Name of the driver to use with this device, or an alias
for that name.  This appears in the sysfs ``modalias'' attribute
for driver coldplugging, and in uevents used for hotplugging

\item[{\code{cs\_gpio}}] \leavevmode
gpio number of the chipselect line (optional, -ENOENT when
not using a GPIO line)

\item[{\code{statistics}}] \leavevmode
statistics for the spi\_device

\end{description}

\textbf{Description}

A \textbf{spi\_device} is used to interchange data between an SPI slave
(usually a discrete chip) and CPU memory.

In \textbf{dev}, the platform\_data is used to hold information about this
device that's meaningful to the device's protocol driver, but not
to its controller.  One example might be an identifier for a chip
variant with slightly different functionality; another might be
information about how this particular board wires the chip's pins.
\index{spi\_driver (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_driver}\pysigline{struct \bfcode{spi\_driver}}
Host side ``protocol'' driver

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct spi\PYGZus{}driver \PYGZob{}
  const struct spi\PYGZus{}device\PYGZus{}id *id\PYGZus{}table;
  int (*probe)(struct spi\PYGZus{}device *spi);
  int (*remove)(struct spi\PYGZus{}device *spi);
  void (*shutdown)(struct spi\PYGZus{}device *spi);
  struct device\PYGZus{}driver    driver;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{id\_table}}] \leavevmode
List of SPI devices supported by this driver

\item[{\code{probe}}] \leavevmode
Binds this driver to the spi device.  Drivers can verify
that the device is actually present, and may need to configure
characteristics (such as bits\_per\_word) which weren't needed for
the initial configuration done during system setup.

\item[{\code{remove}}] \leavevmode
Unbinds this driver from the spi device

\item[{\code{shutdown}}] \leavevmode
Standard shutdown callback used during system state
transitions such as powerdown/halt and kexec

\item[{\code{driver}}] \leavevmode
SPI device drivers should initialize the name and owner
field of this structure.

\end{description}

\textbf{Description}

This represents the kind of device driver that uses SPI messages to
interact with the hardware at the other end of a SPI link.  It's called
a ``protocol'' driver because it works through messages rather than talking
directly to SPI hardware (which is what the underlying SPI controller
driver does to pass those messages).  These protocols are defined in the
specification for the device(s) supported by the driver.

As a rule, those device protocols represent the lowest level interface
supported by a driver, and it will support upper level interfaces too.
Examples of such upper levels include frameworks like MTD, networking,
MMC, RTC, filesystem character device nodes, and hardware monitoring.
\index{spi\_unregister\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_unregister_driver}\pysiglinewithargsret{void \bfcode{spi\_unregister\_driver}}{struct {\hyperref[driver\string-api/spi:c.spi_driver]{\emph{spi\_driver}}} *\emph{ sdrv}}{}
reverse effect of spi\_register\_driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_driver * sdrv}}] \leavevmode
the driver to unregister

\end{description}

\textbf{Context}

can sleep
\index{module\_spi\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.module_spi_driver}\pysiglinewithargsret{\bfcode{module\_spi\_driver}}{\emph{\_\_spi\_driver}}{}
Helper macro for registering a SPI driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_spi\_driver}}] \leavevmode
spi\_driver struct

\end{description}

\textbf{Description}

Helper macro for SPI drivers which do not do anything special in module
init/exit. This eliminates a lot of boilerplate. Each module may only
use this macro once, and calling it replaces {\hyperref[driver\string-api/basics:c.module_init]{\emph{\code{module\_init()}}}} and {\hyperref[driver\string-api/basics:c.module_exit]{\emph{\code{module\_exit()}}}}
\index{spi\_controller (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_controller}\pysigline{struct \bfcode{spi\_controller}}
interface to SPI master or slave controller

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct spi\PYGZus{}controller \PYGZob{}
  struct device   dev;
  struct list\PYGZus{}head list;
  s16 bus\PYGZus{}num;
  u16 num\PYGZus{}chipselect;
  u16 dma\PYGZus{}alignment;
  u16 mode\PYGZus{}bits;
  u32 bits\PYGZus{}per\PYGZus{}word\PYGZus{}mask;
\PYGZsh{}define SPI\PYGZus{}BPW\PYGZus{}MASK(bits) BIT((bits) \PYGZhy{} 1);
\PYGZsh{}define SPI\PYGZus{}BIT\PYGZus{}MASK(bits) (((bits) == 32) ? \PYGZti{}0U : (BIT(bits) \PYGZhy{} 1));
\PYGZsh{}define SPI\PYGZus{}BPW\PYGZus{}RANGE\PYGZus{}MASK(min, max) (SPI\PYGZus{}BIT\PYGZus{}MASK(max) \PYGZhy{} SPI\PYGZus{}BIT\PYGZus{}MASK(min \PYGZhy{} 1));
  u32 min\PYGZus{}speed\PYGZus{}hz;
  u32 max\PYGZus{}speed\PYGZus{}hz;
  u16 flags;
\PYGZsh{}define SPI\PYGZus{}CONTROLLER\PYGZus{}HALF\PYGZus{}DUPLEX      BIT(0)  ;
\PYGZsh{}define SPI\PYGZus{}CONTROLLER\PYGZus{}NO\PYGZus{}RX            BIT(1)  ;
\PYGZsh{}define SPI\PYGZus{}CONTROLLER\PYGZus{}NO\PYGZus{}TX            BIT(2)  ;
\PYGZsh{}define SPI\PYGZus{}CONTROLLER\PYGZus{}MUST\PYGZus{}RX          BIT(3)  ;
\PYGZsh{}define SPI\PYGZus{}CONTROLLER\PYGZus{}MUST\PYGZus{}TX          BIT(4)  ;
\PYGZsh{}define SPI\PYGZus{}MASTER\PYGZus{}GPIO\PYGZus{}SS              BIT(5)  ;
  bool slave;
  size\PYGZus{}t (*max\PYGZus{}transfer\PYGZus{}size)(struct spi\PYGZus{}device *spi);
  size\PYGZus{}t (*max\PYGZus{}message\PYGZus{}size)(struct spi\PYGZus{}device *spi);
  struct mutex            io\PYGZus{}mutex;
  spinlock\PYGZus{}t bus\PYGZus{}lock\PYGZus{}spinlock;
  struct mutex            bus\PYGZus{}lock\PYGZus{}mutex;
  bool bus\PYGZus{}lock\PYGZus{}flag;
  int (*setup)(struct spi\PYGZus{}device *spi);
  int (*transfer)(struct spi\PYGZus{}device *spi, struct spi\PYGZus{}message *mesg);
  void (*cleanup)(struct spi\PYGZus{}device *spi);
  bool (*can\PYGZus{}dma)(struct spi\PYGZus{}controller *ctlr,struct spi\PYGZus{}device *spi, struct spi\PYGZus{}transfer *xfer);
  bool queued;
  struct kthread\PYGZus{}worker           kworker;
  struct task\PYGZus{}struct              *kworker\PYGZus{}task;
  struct kthread\PYGZus{}work             pump\PYGZus{}messages;
  spinlock\PYGZus{}t queue\PYGZus{}lock;
  struct list\PYGZus{}head                queue;
  struct spi\PYGZus{}message              *cur\PYGZus{}msg;
  bool idling;
  bool busy;
  bool running;
  bool rt;
  bool auto\PYGZus{}runtime\PYGZus{}pm;
  bool cur\PYGZus{}msg\PYGZus{}prepared;
  bool cur\PYGZus{}msg\PYGZus{}mapped;
  struct completion               xfer\PYGZus{}completion;
  size\PYGZus{}t max\PYGZus{}dma\PYGZus{}len;
  int (*prepare\PYGZus{}transfer\PYGZus{}hardware)(struct spi\PYGZus{}controller *ctlr);
  int (*transfer\PYGZus{}one\PYGZus{}message)(struct spi\PYGZus{}controller *ctlr, struct spi\PYGZus{}message *mesg);
  int (*unprepare\PYGZus{}transfer\PYGZus{}hardware)(struct spi\PYGZus{}controller *ctlr);
  int (*prepare\PYGZus{}message)(struct spi\PYGZus{}controller *ctlr, struct spi\PYGZus{}message *message);
  int (*unprepare\PYGZus{}message)(struct spi\PYGZus{}controller *ctlr, struct spi\PYGZus{}message *message);
  int (*slave\PYGZus{}abort)(struct spi\PYGZus{}controller *ctlr);
  int (*spi\PYGZus{}flash\PYGZus{}read)(struct  spi\PYGZus{}device *spi, struct spi\PYGZus{}flash\PYGZus{}read\PYGZus{}message *msg);
  bool (*spi\PYGZus{}flash\PYGZus{}can\PYGZus{}dma)(struct spi\PYGZus{}device *spi, struct spi\PYGZus{}flash\PYGZus{}read\PYGZus{}message *msg);
  bool (*flash\PYGZus{}read\PYGZus{}supported)(struct spi\PYGZus{}device *spi);
  void (*set\PYGZus{}cs)(struct spi\PYGZus{}device *spi, bool enable);
  int (*transfer\PYGZus{}one)(struct spi\PYGZus{}controller *ctlr, struct spi\PYGZus{}device *spi, struct spi\PYGZus{}transfer *transfer);
  void (*handle\PYGZus{}err)(struct spi\PYGZus{}controller *ctlr, struct spi\PYGZus{}message *message);
  int *cs\PYGZus{}gpios;
  struct spi\PYGZus{}statistics   statistics;
  struct dma\PYGZus{}chan         *dma\PYGZus{}tx;
  struct dma\PYGZus{}chan         *dma\PYGZus{}rx;
  void *dummy\PYGZus{}rx;
  void *dummy\PYGZus{}tx;
  int (*fw\PYGZus{}translate\PYGZus{}cs)(struct spi\PYGZus{}controller *ctlr, unsigned cs);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev}}] \leavevmode
device interface to this driver

\item[{\code{list}}] \leavevmode
link with the global spi\_controller list

\item[{\code{bus\_num}}] \leavevmode
board-specific (and often SOC-specific) identifier for a
given SPI controller.

\item[{\code{num\_chipselect}}] \leavevmode
chipselects are used to distinguish individual
SPI slaves, and are numbered from zero to num\_chipselects.
each slave has a chipselect signal, but it's common that not
every chipselect is connected to a slave.

\item[{\code{dma\_alignment}}] \leavevmode
SPI controller constraint on DMA buffers alignment.

\item[{\code{mode\_bits}}] \leavevmode
flags understood by this controller driver

\item[{\code{bits\_per\_word\_mask}}] \leavevmode
A mask indicating which values of bits\_per\_word are
supported by the driver. Bit n indicates that a bits\_per\_word n+1 is
supported. If set, the SPI core will reject any transfer with an
unsupported bits\_per\_word. If not set, this value is simply ignored,
and it's up to the individual driver to perform any validation.

\item[{\code{min\_speed\_hz}}] \leavevmode
Lowest supported transfer speed

\item[{\code{max\_speed\_hz}}] \leavevmode
Highest supported transfer speed

\item[{\code{flags}}] \leavevmode
other constraints relevant to this driver

\item[{\code{slave}}] \leavevmode
indicates that this is an SPI slave controller

\item[{\code{max\_transfer\_size}}] \leavevmode
function that returns the max transfer size for
a {\hyperref[driver\string-api/spi:c.spi_device]{\emph{\code{spi\_device}}}}; may be \code{NULL}, so the default \code{SIZE\_MAX} will be used.

\item[{\code{max\_message\_size}}] \leavevmode
function that returns the max message size for
a {\hyperref[driver\string-api/spi:c.spi_device]{\emph{\code{spi\_device}}}}; may be \code{NULL}, so the default \code{SIZE\_MAX} will be used.

\item[{\code{io\_mutex}}] \leavevmode
mutex for physical bus access

\item[{\code{bus\_lock\_spinlock}}] \leavevmode
spinlock for SPI bus locking

\item[{\code{bus\_lock\_mutex}}] \leavevmode
mutex for exclusion of multiple callers

\item[{\code{bus\_lock\_flag}}] \leavevmode
indicates that the SPI bus is locked for exclusive use

\item[{\code{setup}}] \leavevmode
updates the device mode and clocking records used by a
device's SPI controller; protocol code may call this.  This
must fail if an unrecognized or unsupported mode is requested.
It's always safe to call this unless transfers are pending on
the device whose settings are being modified.

\item[{\code{transfer}}] \leavevmode
adds a message to the controller's transfer queue.

\item[{\code{cleanup}}] \leavevmode
frees controller-specific state

\item[{\code{can\_dma}}] \leavevmode
determine whether this controller supports DMA

\item[{\code{queued}}] \leavevmode
whether this controller is providing an internal message queue

\item[{\code{kworker}}] \leavevmode
thread struct for message pump

\item[{\code{kworker\_task}}] \leavevmode
pointer to task for message pump kworker thread

\item[{\code{pump\_messages}}] \leavevmode
work struct for scheduling work to the message pump

\item[{\code{queue\_lock}}] \leavevmode
spinlock to syncronise access to message queue

\item[{\code{queue}}] \leavevmode
message queue

\item[{\code{cur\_msg}}] \leavevmode
the currently in-flight message

\item[{\code{idling}}] \leavevmode
the device is entering idle state

\item[{\code{busy}}] \leavevmode
message pump is busy

\item[{\code{running}}] \leavevmode
message pump is running

\item[{\code{rt}}] \leavevmode
whether this queue is set to run as a realtime task

\item[{\code{auto\_runtime\_pm}}] \leavevmode
the core should ensure a runtime PM reference is held
while the hardware is prepared, using the parent
device for the spidev

\item[{\code{cur\_msg\_prepared}}] \leavevmode
spi\_prepare\_message was called for the currently
in-flight message

\item[{\code{cur\_msg\_mapped}}] \leavevmode
message has been mapped for DMA

\item[{\code{xfer\_completion}}] \leavevmode
used by core \code{transfer\_one\_message()}

\item[{\code{max\_dma\_len}}] \leavevmode
Maximum length of a DMA transfer for the device.

\item[{\code{prepare\_transfer\_hardware}}] \leavevmode
a message will soon arrive from the queue
so the subsystem requests the driver to prepare the transfer hardware
by issuing this call

\item[{\code{transfer\_one\_message}}] \leavevmode
the subsystem calls the driver to transfer a single
message while queuing transfers that arrive in the meantime. When the
driver is finished with this message, it must call
{\hyperref[driver\string-api/spi:c.spi_finalize_current_message]{\emph{\code{spi\_finalize\_current\_message()}}}} so the subsystem can issue the next
message

\item[{\code{unprepare\_transfer\_hardware}}] \leavevmode
there are currently no more messages on the
queue so the subsystem notifies the driver that it may relax the
hardware by issuing this call

\item[{\code{prepare\_message}}] \leavevmode
set up the controller to transfer a single message,
for example doing DMA mapping.  Called from threaded
context.

\item[{\code{unprepare\_message}}] \leavevmode
undo any work done by \code{prepare\_message()}.

\item[{\code{slave\_abort}}] \leavevmode
abort the ongoing transfer request on an SPI slave controller

\item[{\code{spi\_flash\_read}}] \leavevmode
to support spi-controller hardwares that provide
accelerated interface to read from flash devices.

\item[{\code{spi\_flash\_can\_dma}}] \leavevmode
analogous to \code{can\_dma()} interface, but for
controllers implementing spi\_flash\_read.

\item[{\code{flash\_read\_supported}}] \leavevmode
spi device supports flash read

\item[{\code{set\_cs}}] \leavevmode
set the logic level of the chip select line.  May be called
from interrupt context.

\item[{\code{transfer\_one}}] \leavevmode
transfer a single spi\_transfer.
- return 0 if the transfer is finished,
- return 1 if the transfer is still in progress. When
\begin{quote}

the driver is finished with this transfer it must
call {\hyperref[driver\string-api/spi:c.spi_finalize_current_transfer]{\emph{\code{spi\_finalize\_current\_transfer()}}}} so the subsystem
can issue the next transfer. Note: transfer\_one and
transfer\_one\_message are mutually exclusive; when both
are set, the generic subsystem does not call your
transfer\_one callback.
\end{quote}

\item[{\code{handle\_err}}] \leavevmode
the subsystem calls the driver to handle an error that occurs
in the generic implementation of \code{transfer\_one\_message()}.

\item[{\code{cs\_gpios}}] \leavevmode
Array of GPIOs to use as chip select lines; one per CS
number. Any individual value may be -ENOENT for CS lines that
are not GPIOs (driven by the SPI controller itself).

\item[{\code{statistics}}] \leavevmode
statistics for the spi\_controller

\item[{\code{dma\_tx}}] \leavevmode
DMA transmit channel

\item[{\code{dma\_rx}}] \leavevmode
DMA receive channel

\item[{\code{dummy\_rx}}] \leavevmode
dummy receive buffer for full-duplex devices

\item[{\code{dummy\_tx}}] \leavevmode
dummy transmit buffer for full-duplex devices

\item[{\code{fw\_translate\_cs}}] \leavevmode
If the boot firmware uses different numbering scheme
what Linux expects, this optional hook can be used to translate
between the two.

\end{description}

\textbf{Description}

Each SPI controller can communicate with one or more \textbf{spi\_device}
children.  These make a small bus, sharing MOSI, MISO and SCK signals
but not chip select signals.  Each device may be configured to use a
different clock rate, since those shared signals are ignored unless
the chip is selected.

The driver for an SPI controller manages access to those devices through
a queue of spi\_message transactions, copying data between CPU memory and
an SPI slave device.  For each such message it queues, it calls the
message's completion function when the transaction completes.
\index{spi\_res (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_res}\pysigline{struct \bfcode{spi\_res}}
spi resource management structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct spi\PYGZus{}res \PYGZob{}
  struct list\PYGZus{}head        entry;
  spi\PYGZus{}res\PYGZus{}release\PYGZus{}t release;
  unsigned long long      data[];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{entry}}] \leavevmode
list entry

\item[{\code{release}}] \leavevmode
release code called prior to freeing this resource

\item[{\code{data}}] \leavevmode
extra data allocated for the specific use-case

\end{description}

\textbf{Description}

this is based on ideas from devres, but focused on life-cycle
management during spi\_message processing
\index{spi\_transfer (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_transfer}\pysigline{struct \bfcode{spi\_transfer}}
a read/write buffer pair

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct spi\PYGZus{}transfer \PYGZob{}
  const void      *tx\PYGZus{}buf;
  void *rx\PYGZus{}buf;
  unsigned len;
  dma\PYGZus{}addr\PYGZus{}t tx\PYGZus{}dma;
  dma\PYGZus{}addr\PYGZus{}t rx\PYGZus{}dma;
  struct sg\PYGZus{}table tx\PYGZus{}sg;
  struct sg\PYGZus{}table rx\PYGZus{}sg;
  unsigned cs\PYGZus{}change:1;
  unsigned tx\PYGZus{}nbits:3;
  unsigned rx\PYGZus{}nbits:3;
\PYGZsh{}define SPI\PYGZus{}NBITS\PYGZus{}SINGLE        0x01 ;
\PYGZsh{}define SPI\PYGZus{}NBITS\PYGZus{}DUAL          0x02 ;
\PYGZsh{}define SPI\PYGZus{}NBITS\PYGZus{}QUAD          0x04 ;
  u8 bits\PYGZus{}per\PYGZus{}word;
  u16 delay\PYGZus{}usecs;
  u32 speed\PYGZus{}hz;
  struct list\PYGZus{}head transfer\PYGZus{}list;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{tx\_buf}}] \leavevmode
data to be written (dma-safe memory), or NULL

\item[{\code{rx\_buf}}] \leavevmode
data to be read (dma-safe memory), or NULL

\item[{\code{len}}] \leavevmode
size of rx and tx buffers (in bytes)

\item[{\code{tx\_dma}}] \leavevmode
DMA address of tx\_buf, if \textbf{spi\_message.is\_dma\_mapped}

\item[{\code{rx\_dma}}] \leavevmode
DMA address of rx\_buf, if \textbf{spi\_message.is\_dma\_mapped}

\item[{\code{tx\_sg}}] \leavevmode
Scatterlist for transmit, currently not for client use

\item[{\code{rx\_sg}}] \leavevmode
Scatterlist for receive, currently not for client use

\item[{\code{cs\_change}}] \leavevmode
affects chipselect after this transfer completes

\item[{\code{tx\_nbits}}] \leavevmode
number of bits used for writing. If 0 the default
(SPI\_NBITS\_SINGLE) is used.

\item[{\code{rx\_nbits}}] \leavevmode
number of bits used for reading. If 0 the default
(SPI\_NBITS\_SINGLE) is used.

\item[{\code{bits\_per\_word}}] \leavevmode
select a bits\_per\_word other than the device default
for this transfer. If 0 the default (from \textbf{spi\_device}) is used.

\item[{\code{delay\_usecs}}] \leavevmode
microseconds to delay after this transfer before
(optionally) changing the chipselect status, then starting
the next transfer or completing this \textbf{spi\_message}.

\item[{\code{speed\_hz}}] \leavevmode
Select a speed other than the device default for this
transfer. If 0 the default (from \textbf{spi\_device}) is used.

\item[{\code{transfer\_list}}] \leavevmode
transfers are sequenced through \textbf{spi\_message.transfers}

\end{description}

\textbf{Description}

SPI transfers always write the same number of bytes as they read.
Protocol drivers should always provide \textbf{rx\_buf} and/or \textbf{tx\_buf}.
In some cases, they may also want to provide DMA addresses for
the data being transferred; that may reduce overhead, when the
underlying driver uses dma.

If the transmit buffer is null, zeroes will be shifted out
while filling \textbf{rx\_buf}.  If the receive buffer is null, the data
shifted in will be discarded.  Only ``len'' bytes shift out (or in).
It's an error to try to shift out a partial word.  (For example, by
shifting out three bytes with word size of sixteen or twenty bits;
the former uses two bytes per word, the latter uses four bytes.)

In-memory data values are always in native CPU byte order, translated
from the wire byte order (big-endian except with SPI\_LSB\_FIRST).  So
for example when bits\_per\_word is sixteen, buffers are 2N bytes long
(\textbf{len} = 2N) and hold N sixteen bit words in CPU byte order.

When the word size of the SPI transfer is not a power-of-two multiple
of eight bits, those in-memory words include extra bits.  In-memory
words are always seen by protocol drivers as right-justified, so the
undefined (rx) or unused (tx) bits are always the most significant bits.

All SPI transfers start with the relevant chipselect active.  Normally
it stays selected until after the last transfer in a message.  Drivers
can affect the chipselect signal using cs\_change.

(i) If the transfer isn't the last one in the message, this flag is
used to make the chipselect briefly go inactive in the middle of the
message.  Toggling chipselect in this way may be needed to terminate
a chip command, letting a single spi\_message perform all of group of
chip transactions together.

(ii) When the transfer is the last one in the message, the chip may
stay selected until the next transfer.  On multi-device SPI busses
with nothing blocking messages going to other devices, this is just
a performance hint; starting a message to another device deselects
this one.  But in other cases, this can be used to ensure correctness.
Some devices need protocol transactions to be built from a series of
spi\_message submissions, where the content of one message is determined
by the results of previous messages and where the whole transaction
ends when the chipselect goes intactive.

When SPI can transfer in 1x,2x or 4x. It can get this transfer information
from device through \textbf{tx\_nbits} and \textbf{rx\_nbits}. In Bi-direction, these
two should both be set. User can set transfer mode with SPI\_NBITS\_SINGLE(1x)
SPI\_NBITS\_DUAL(2x) and SPI\_NBITS\_QUAD(4x) to support these three transfer.

The code that submits an spi\_message (and its spi\_transfers)
to the lower layers is responsible for managing its memory.
Zero-initialize every field you don't set up explicitly, to
insulate against future API updates.  After you submit a message
and its transfers, ignore them until its completion callback.
\index{spi\_message (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_message}\pysigline{struct \bfcode{spi\_message}}
one multi-segment SPI transaction

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct spi\PYGZus{}message \PYGZob{}
  struct list\PYGZus{}head        transfers;
  struct spi\PYGZus{}device       *spi;
  unsigned is\PYGZus{}dma\PYGZus{}mapped:1;
  void (*complete)(void *context);
  void *context;
  unsigned frame\PYGZus{}length;
  unsigned actual\PYGZus{}length;
  int status;
  struct list\PYGZus{}head        queue;
  void *state;
  struct list\PYGZus{}head        resources;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{transfers}}] \leavevmode
list of transfer segments in this transaction

\item[{\code{spi}}] \leavevmode
SPI device to which the transaction is queued

\item[{\code{is\_dma\_mapped}}] \leavevmode
if true, the caller provided both dma and cpu virtual
addresses for each transfer buffer

\item[{\code{complete}}] \leavevmode
called to report transaction completions

\item[{\code{context}}] \leavevmode
the argument to \code{complete()} when it's called

\item[{\code{frame\_length}}] \leavevmode
the total number of bytes in the message

\item[{\code{actual\_length}}] \leavevmode
the total number of bytes that were transferred in all
successful segments

\item[{\code{status}}] \leavevmode
zero for success, else negative errno

\item[{\code{queue}}] \leavevmode
for use by whichever driver currently owns the message

\item[{\code{state}}] \leavevmode
for use by whichever driver currently owns the message

\item[{\code{resources}}] \leavevmode
for resource management when the spi message is processed

\end{description}

\textbf{Description}

A \textbf{spi\_message} is used to execute an atomic sequence of data transfers,
each represented by a struct spi\_transfer.  The sequence is ``atomic''
in the sense that no other spi\_message may use that SPI bus until that
sequence completes.  On some systems, many such sequences can execute as
as single programmed DMA transfer.  On all systems, these messages are
queued, and might complete after transactions to other devices.  Messages
sent to a given spi\_device are always executed in FIFO order.

The code that submits an spi\_message (and its spi\_transfers)
to the lower layers is responsible for managing its memory.
Zero-initialize every field you don't set up explicitly, to
insulate against future API updates.  After you submit a message
and its transfers, ignore them until its completion callback.
\index{spi\_message\_init\_with\_transfers (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_message_init_with_transfers}\pysiglinewithargsret{void \bfcode{spi\_message\_init\_with\_transfers}}{struct {\hyperref[driver\string-api/spi:c.spi_message]{\emph{spi\_message}}} *\emph{ m}, struct {\hyperref[driver\string-api/spi:c.spi_transfer]{\emph{spi\_transfer}}} *\emph{ xfers}, unsigned int\emph{ num\_xfers}}{}
Initialize spi\_message and append transfers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_message * m}}] \leavevmode
spi\_message to be initialized

\item[{\code{struct spi\_transfer * xfers}}] \leavevmode
An array of spi transfers

\item[{\code{unsigned int num\_xfers}}] \leavevmode
Number of items in the xfer array

\end{description}

\textbf{Description}

This function initializes the given spi\_message and adds each spi\_transfer in
the given array to the message.
\index{spi\_replaced\_transfers (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_replaced_transfers}\pysigline{struct \bfcode{spi\_replaced\_transfers}}
structure describing the spi\_transfer replacements that have occurred so that they can get reverted

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct spi\PYGZus{}replaced\PYGZus{}transfers \PYGZob{}
  spi\PYGZus{}replaced\PYGZus{}release\PYGZus{}t release;
  void *extradata;
  struct list\PYGZus{}head replaced\PYGZus{}transfers;
  struct list\PYGZus{}head *replaced\PYGZus{}after;
  size\PYGZus{}t inserted;
  struct spi\PYGZus{}transfer inserted\PYGZus{}transfers[];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{release}}] \leavevmode
some extra release code to get executed prior to
relasing this structure

\item[{\code{extradata}}] \leavevmode
pointer to some extra data if requested or NULL

\item[{\code{replaced\_transfers}}] \leavevmode
transfers that have been replaced and which need
to get restored

\item[{\code{replaced\_after}}] \leavevmode
the transfer after which the \textbf{replaced\_transfers}
are to get re-inserted

\item[{\code{inserted}}] \leavevmode
number of transfers inserted

\item[{\code{inserted\_transfers}}] \leavevmode
array of spi\_transfers of array-size \textbf{inserted},
that have been replacing replaced\_transfers

\end{description}

\textbf{note}

that \textbf{extradata} will point to \textbf{inserted\_transfers**{[}**inserted}{]}
if some extra allocation is requested, so alignment will be the same
as for spi\_transfers
\index{spi\_sync\_transfer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_sync_transfer}\pysiglinewithargsret{int \bfcode{spi\_sync\_transfer}}{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} *\emph{ spi}, struct {\hyperref[driver\string-api/spi:c.spi_transfer]{\emph{spi\_transfer}}} *\emph{ xfers}, unsigned int\emph{ num\_xfers}}{}
synchronous SPI data transfer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
device with which data will be exchanged

\item[{\code{struct spi\_transfer * xfers}}] \leavevmode
An array of spi\_transfers

\item[{\code{unsigned int num\_xfers}}] \leavevmode
Number of items in the xfer array

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

Does a synchronous SPI data transfer of the given spi\_transfer array.

For more specific semantics see {\hyperref[driver\string-api/spi:c.spi_sync]{\emph{\code{spi\_sync()}}}}.

\textbf{Return}

Return: zero on success, else a negative error code.
\index{spi\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_write}\pysiglinewithargsret{int \bfcode{spi\_write}}{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} *\emph{ spi}, const void *\emph{ buf}, size\_t\emph{ len}}{}
SPI synchronous write

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
device to which data will be written

\item[{\code{const void * buf}}] \leavevmode
data buffer

\item[{\code{size\_t len}}] \leavevmode
data buffer size

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

This function writes the buffer \textbf{buf}.
Callable only from contexts that can sleep.

\textbf{Return}

zero on success, else a negative error code.
\index{spi\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_read}\pysiglinewithargsret{int \bfcode{spi\_read}}{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} *\emph{ spi}, void *\emph{ buf}, size\_t\emph{ len}}{}
SPI synchronous read

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
device from which data will be read

\item[{\code{void * buf}}] \leavevmode
data buffer

\item[{\code{size\_t len}}] \leavevmode
data buffer size

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

This function reads the buffer \textbf{buf}.
Callable only from contexts that can sleep.

\textbf{Return}

zero on success, else a negative error code.
\index{spi\_w8r8 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_w8r8}\pysiglinewithargsret{ssize\_t \bfcode{spi\_w8r8}}{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} *\emph{ spi}, u8\emph{ cmd}}{}
SPI synchronous 8 bit write followed by 8 bit read

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
device with which data will be exchanged

\item[{\code{u8 cmd}}] \leavevmode
command to be written before data is read back

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

Callable only from contexts that can sleep.

\textbf{Return}

the (unsigned) eight bit number returned by the
device, or else a negative error code.
\index{spi\_w8r16 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_w8r16}\pysiglinewithargsret{ssize\_t \bfcode{spi\_w8r16}}{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} *\emph{ spi}, u8\emph{ cmd}}{}
SPI synchronous 8 bit write followed by 16 bit read

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
device with which data will be exchanged

\item[{\code{u8 cmd}}] \leavevmode
command to be written before data is read back

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

The number is returned in wire-order, which is at least sometimes
big-endian.

Callable only from contexts that can sleep.

\textbf{Return}

the (unsigned) sixteen bit number returned by the
device, or else a negative error code.
\index{spi\_w8r16be (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_w8r16be}\pysiglinewithargsret{ssize\_t \bfcode{spi\_w8r16be}}{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} *\emph{ spi}, u8\emph{ cmd}}{}
SPI synchronous 8 bit write followed by 16 bit big-endian read

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
device with which data will be exchanged

\item[{\code{u8 cmd}}] \leavevmode
command to be written before data is read back

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

This function is similar to spi\_w8r16, with the exception that it will
convert the read 16 bit data word from big-endian to native endianness.

Callable only from contexts that can sleep.

\textbf{Return}

the (unsigned) sixteen bit number returned by the device in cpu
endianness, or else a negative error code.
\index{spi\_flash\_read\_message (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_flash_read_message}\pysigline{struct \bfcode{spi\_flash\_read\_message}}
flash specific information for spi-masters that provide accelerated flash read interfaces

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct spi\PYGZus{}flash\PYGZus{}read\PYGZus{}message \PYGZob{}
  void *buf;
  loff\PYGZus{}t from;
  size\PYGZus{}t len;
  size\PYGZus{}t retlen;
  u8 read\PYGZus{}opcode;
  u8 addr\PYGZus{}width;
  u8 dummy\PYGZus{}bytes;
  u8 opcode\PYGZus{}nbits;
  u8 addr\PYGZus{}nbits;
  u8 data\PYGZus{}nbits;
  struct sg\PYGZus{}table rx\PYGZus{}sg;
  bool cur\PYGZus{}msg\PYGZus{}mapped;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{buf}}] \leavevmode
buffer to read data

\item[{\code{from}}] \leavevmode
offset within the flash from where data is to be read

\item[{\code{len}}] \leavevmode
length of data to be read

\item[{\code{retlen}}] \leavevmode
actual length of data read

\item[{\code{read\_opcode}}] \leavevmode
read\_opcode to be used to communicate with flash

\item[{\code{addr\_width}}] \leavevmode
number of address bytes

\item[{\code{dummy\_bytes}}] \leavevmode
number of dummy bytes

\item[{\code{opcode\_nbits}}] \leavevmode
number of lines to send opcode

\item[{\code{addr\_nbits}}] \leavevmode
number of lines to send address

\item[{\code{data\_nbits}}] \leavevmode
number of lines for data

\item[{\code{rx\_sg}}] \leavevmode
Scatterlist for receive data read from flash

\item[{\code{cur\_msg\_mapped}}] \leavevmode
message has been mapped for DMA

\end{description}
\index{spi\_board\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_board_info}\pysigline{struct \bfcode{spi\_board\_info}}
board-specific template for a SPI device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct spi\PYGZus{}board\PYGZus{}info \PYGZob{}
  char modalias[SPI\PYGZus{}NAME\PYGZus{}SIZE];
  const void      *platform\PYGZus{}data;
  const struct property\PYGZus{}entry *properties;
  void *controller\PYGZus{}data;
  int irq;
  u32 max\PYGZus{}speed\PYGZus{}hz;
  u16 bus\PYGZus{}num;
  u16 chip\PYGZus{}select;
  u16 mode;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{modalias}}] \leavevmode
Initializes spi\_device.modalias; identifies the driver.

\item[{\code{platform\_data}}] \leavevmode
Initializes spi\_device.platform\_data; the particular
data stored there is driver-specific.

\item[{\code{properties}}] \leavevmode
Additional device properties for the device.

\item[{\code{controller\_data}}] \leavevmode
Initializes spi\_device.controller\_data; some
controllers need hints about hardware setup, e.g. for DMA.

\item[{\code{irq}}] \leavevmode
Initializes spi\_device.irq; depends on how the board is wired.

\item[{\code{max\_speed\_hz}}] \leavevmode
Initializes spi\_device.max\_speed\_hz; based on limits
from the chip datasheet and board-specific signal quality issues.

\item[{\code{bus\_num}}] \leavevmode
Identifies which spi\_controller parents the spi\_device; unused
by {\hyperref[driver\string-api/spi:c.spi_new_device]{\emph{\code{spi\_new\_device()}}}}, and otherwise depends on board wiring.

\item[{\code{chip\_select}}] \leavevmode
Initializes spi\_device.chip\_select; depends on how
the board is wired.

\item[{\code{mode}}] \leavevmode
Initializes spi\_device.mode; based on the chip datasheet, board
wiring (some devices support both 3WIRE and standard modes), and
possibly presence of an inverter in the chipselect path.

\end{description}

\textbf{Description}

When adding new SPI devices to the device tree, these structures serve
as a partial device template.  They hold information which can't always
be determined by drivers.  Information that \code{probe()} can establish (such
as the default transfer wordsize) is not included here.

These structures are used in two places.  Their primary role is to
be stored in tables of board-specific device descriptors, which are
declared early in board initialization and then used (much later) to
populate a controller's device tree after the that controller's driver
initializes.  A secondary (and atypical) role is as a parameter to
{\hyperref[driver\string-api/spi:c.spi_new_device]{\emph{\code{spi\_new\_device()}}}} call, which happens after those controller drivers
are active in some dynamic board configuration models.
\index{spi\_register\_board\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_register_board_info}\pysiglinewithargsret{int \bfcode{spi\_register\_board\_info}}{struct {\hyperref[driver\string-api/spi:c.spi_board_info]{\emph{spi\_board\_info}}} const *\emph{ info}, unsigned\emph{ n}}{}
register SPI devices for a given board

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_board\_info const * info}}] \leavevmode
array of chip descriptors

\item[{\code{unsigned n}}] \leavevmode
how many descriptors are provided

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

Board-specific early init code calls this (probably during arch\_initcall)
with segments of the SPI device table.  Any device nodes are created later,
after the relevant parent SPI controller (bus\_num) is defined.  We keep
this table of devices forever, so that reloading a controller driver will
not make Linux forget about these hard-wired devices.

Other code can also call this, e.g. a particular add-on board might provide
SPI devices through its expansion connector, so code initializing that board
would naturally declare its SPI devices.

The board info passed can safely be \_\_initdata ... but be careful of
any embedded pointers (platform\_data, etc), they're copied as-is.
Device properties are deep-copied though.

\textbf{Return}

zero on success, else a negative error code.
\index{\_\_spi\_register\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.__spi_register_driver}\pysiglinewithargsret{int \bfcode{\_\_spi\_register\_driver}}{struct module *\emph{ owner}, struct {\hyperref[driver\string-api/spi:c.spi_driver]{\emph{spi\_driver}}} *\emph{ sdrv}}{}
register a SPI driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct module * owner}}] \leavevmode
owner module of the driver to register

\item[{\code{struct spi\_driver * sdrv}}] \leavevmode
the driver to register

\end{description}

\textbf{Context}

can sleep

\textbf{Return}

zero on success, else a negative error code.
\index{spi\_alloc\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_alloc_device}\pysiglinewithargsret{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} * \bfcode{spi\_alloc\_device}}{struct {\hyperref[driver\string-api/spi:c.spi_controller]{\emph{spi\_controller}}} *\emph{ ctlr}}{}
Allocate a new SPI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_controller * ctlr}}] \leavevmode
Controller to which device is connected

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

Allows a driver to allocate and initialize a spi\_device without
registering it immediately.  This allows a driver to directly
fill the spi\_device with device parameters before calling
{\hyperref[driver\string-api/spi:c.spi_add_device]{\emph{\code{spi\_add\_device()}}}} on it.

Caller is responsible to call {\hyperref[driver\string-api/spi:c.spi_add_device]{\emph{\code{spi\_add\_device()}}}} on the returned
spi\_device structure to add it to the SPI controller.  If the caller
needs to discard the spi\_device without adding it, then it should
call \code{spi\_dev\_put()} on it.

\textbf{Return}

a pointer to the new device, or NULL.
\index{spi\_add\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_add_device}\pysiglinewithargsret{int \bfcode{spi\_add\_device}}{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} *\emph{ spi}}{}
Add spi\_device allocated with spi\_alloc\_device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
spi\_device to register

\end{description}

\textbf{Description}

Companion function to spi\_alloc\_device.  Devices allocated with
spi\_alloc\_device can be added onto the spi bus with this function.

\textbf{Return}

0 on success; negative errno on failure
\index{spi\_new\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_new_device}\pysiglinewithargsret{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} * \bfcode{spi\_new\_device}}{struct {\hyperref[driver\string-api/spi:c.spi_controller]{\emph{spi\_controller}}} *\emph{ ctlr}, struct {\hyperref[driver\string-api/spi:c.spi_board_info]{\emph{spi\_board\_info}}} *\emph{ chip}}{}
instantiate one new SPI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_controller * ctlr}}] \leavevmode
Controller to which device is connected

\item[{\code{struct spi\_board\_info * chip}}] \leavevmode
Describes the SPI device

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

On typical mainboards, this is purely internal; and it's not needed
after board init creates the hard-wired devices.  Some development
platforms may not be able to use spi\_register\_board\_info though, and
this is exported so that for example a USB or parport based adapter
driver could add devices (which it would learn about out-of-band).

\textbf{Return}

the new device, or NULL.
\index{spi\_unregister\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_unregister_device}\pysiglinewithargsret{void \bfcode{spi\_unregister\_device}}{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} *\emph{ spi}}{}
unregister a single SPI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
spi\_device to unregister

\end{description}

\textbf{Description}

Start making the passed SPI device vanish. Normally this would be handled
by {\hyperref[driver\string-api/spi:c.spi_unregister_controller]{\emph{\code{spi\_unregister\_controller()}}}}.
\index{spi\_finalize\_current\_transfer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_finalize_current_transfer}\pysiglinewithargsret{void \bfcode{spi\_finalize\_current\_transfer}}{struct {\hyperref[driver\string-api/spi:c.spi_controller]{\emph{spi\_controller}}} *\emph{ ctlr}}{}
report completion of a transfer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_controller * ctlr}}] \leavevmode
the controller reporting completion

\end{description}

\textbf{Description}

Called by SPI drivers using the core \code{transfer\_one\_message()}
implementation to notify it that the current interrupt driven
transfer has finished and the next one may be scheduled.
\index{spi\_get\_next\_queued\_message (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_get_next_queued_message}\pysiglinewithargsret{struct {\hyperref[driver\string-api/spi:c.spi_message]{\emph{spi\_message}}} * \bfcode{spi\_get\_next\_queued\_message}}{struct {\hyperref[driver\string-api/spi:c.spi_controller]{\emph{spi\_controller}}} *\emph{ ctlr}}{}
called by driver to check for queued messages

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_controller * ctlr}}] \leavevmode
the controller to check for queued messages

\end{description}

\textbf{Description}

If there are more messages in the queue, the next message is returned from
this call.

\textbf{Return}

the next message in the queue, else NULL if the queue is empty.
\index{spi\_finalize\_current\_message (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_finalize_current_message}\pysiglinewithargsret{void \bfcode{spi\_finalize\_current\_message}}{struct {\hyperref[driver\string-api/spi:c.spi_controller]{\emph{spi\_controller}}} *\emph{ ctlr}}{}
the current message is complete

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_controller * ctlr}}] \leavevmode
the controller to return the message to

\end{description}

\textbf{Description}

Called by the driver to notify the core that the message in the front of the
queue is complete and can be removed from the queue.
\index{spi\_slave\_abort (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_slave_abort}\pysiglinewithargsret{int \bfcode{spi\_slave\_abort}}{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} *\emph{ spi}}{}
abort the ongoing transfer request on an SPI slave controller

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
device used for the current transfer

\end{description}
\index{\_\_spi\_alloc\_controller (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.__spi_alloc_controller}\pysiglinewithargsret{struct {\hyperref[driver\string-api/spi:c.spi_controller]{\emph{spi\_controller}}} * \bfcode{\_\_spi\_alloc\_controller}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, unsigned int\emph{ size}, bool\emph{ slave}}{}
allocate an SPI master or slave controller

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
the controller, possibly using the platform\_bus

\item[{\code{unsigned int size}}] \leavevmode
how much zeroed driver-private data to allocate; the pointer to this
memory is in the driver\_data field of the returned device,
accessible with \code{spi\_controller\_get\_devdata()}.

\item[{\code{bool slave}}] \leavevmode
flag indicating whether to allocate an SPI master (false) or SPI
slave (true) controller

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

This call is used only by SPI controller drivers, which are the
only ones directly touching chip registers.  It's how they allocate
an spi\_controller structure, prior to calling {\hyperref[driver\string-api/spi:c.spi_register_controller]{\emph{\code{spi\_register\_controller()}}}}.

This must be called from context that can sleep.

The caller is responsible for assigning the bus number and initializing the
controller's methods before calling {\hyperref[driver\string-api/spi:c.spi_register_controller]{\emph{\code{spi\_register\_controller()}}}}; and (after
errors adding the device) calling \code{spi\_controller\_put()} to prevent a memory
leak.

\textbf{Return}

the SPI controller structure on success, else NULL.
\index{spi\_register\_controller (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_register_controller}\pysiglinewithargsret{int \bfcode{spi\_register\_controller}}{struct {\hyperref[driver\string-api/spi:c.spi_controller]{\emph{spi\_controller}}} *\emph{ ctlr}}{}
register SPI master or slave controller

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_controller * ctlr}}] \leavevmode
initialized master, originally from \code{spi\_alloc\_master()} or
\code{spi\_alloc\_slave()}

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

SPI controllers connect to their drivers using some non-SPI bus,
such as the platform bus.  The final stage of \code{probe()} in that code
includes calling {\hyperref[driver\string-api/spi:c.spi_register_controller]{\emph{\code{spi\_register\_controller()}}}} to hook up to this SPI bus glue.

SPI controllers use board specific (often SOC specific) bus numbers,
and board-specific addressing for SPI devices combines those numbers
with chip select numbers.  Since SPI does not directly support dynamic
device identification, boards need configuration tables telling which
chip is at which address.

This must be called from context that can sleep.  It returns zero on
success, else a negative error code (dropping the controller's refcount).
After a successful return, the caller is responsible for calling
{\hyperref[driver\string-api/spi:c.spi_unregister_controller]{\emph{\code{spi\_unregister\_controller()}}}}.

\textbf{Return}

zero on success, else a negative error code.
\index{devm\_spi\_register\_controller (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.devm_spi_register_controller}\pysiglinewithargsret{int \bfcode{devm\_spi\_register\_controller}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct {\hyperref[driver\string-api/spi:c.spi_controller]{\emph{spi\_controller}}} *\emph{ ctlr}}{}
register managed SPI master or slave controller

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device managing SPI controller

\item[{\code{struct spi\_controller * ctlr}}] \leavevmode
initialized controller, originally from \code{spi\_alloc\_master()} or
\code{spi\_alloc\_slave()}

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

Register a SPI device as with {\hyperref[driver\string-api/spi:c.spi_register_controller]{\emph{\code{spi\_register\_controller()}}}} which will
automatically be unregistered and freed.

\textbf{Return}

zero on success, else a negative error code.
\index{spi\_unregister\_controller (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_unregister_controller}\pysiglinewithargsret{void \bfcode{spi\_unregister\_controller}}{struct {\hyperref[driver\string-api/spi:c.spi_controller]{\emph{spi\_controller}}} *\emph{ ctlr}}{}
unregister SPI master or slave controller

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_controller * ctlr}}] \leavevmode
the controller being unregistered

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

This call is used only by SPI controller drivers, which are the
only ones directly touching chip registers.

This must be called from context that can sleep.

Note that this function also drops a reference to the controller.
\index{spi\_busnum\_to\_master (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_busnum_to_master}\pysiglinewithargsret{struct {\hyperref[driver\string-api/spi:c.spi_controller]{\emph{spi\_controller}}} * \bfcode{spi\_busnum\_to\_master}}{u16\emph{ bus\_num}}{}
look up master associated with bus\_num

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u16 bus\_num}}] \leavevmode
the master's bus number

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

This call may be used with devices that are registered after
arch init time.  It returns a refcounted pointer to the relevant
spi\_controller (which the caller must release), or NULL if there is
no such master registered.

\textbf{Return}

the SPI master structure on success, else NULL.
\index{spi\_res\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_res_alloc}\pysiglinewithargsret{void * \bfcode{spi\_res\_alloc}}{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} *\emph{ spi}, spi\_res\_release\_t\emph{ release}, size\_t\emph{ size}, gfp\_t\emph{ gfp}}{}
allocate a spi resource that is life-cycle managed during the processing of a spi\_message while using spi\_transfer\_one

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
the spi device for which we allocate memory

\item[{\code{spi\_res\_release\_t release}}] \leavevmode
the release code to execute for this resource

\item[{\code{size\_t size}}] \leavevmode
size to alloc and return

\item[{\code{gfp\_t gfp}}] \leavevmode
GFP allocation flags

\end{description}

\textbf{Return}

the pointer to the allocated data

This may get enhanced in the future to allocate from a memory pool
of the \textbf{spi\_device} or \textbf{spi\_controller} to avoid repeated allocations.
\index{spi\_res\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_res_free}\pysiglinewithargsret{void \bfcode{spi\_res\_free}}{void *\emph{ res}}{}
free an spi resource

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * res}}] \leavevmode
pointer to the custom data of a resource

\end{description}
\index{spi\_res\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_res_add}\pysiglinewithargsret{void \bfcode{spi\_res\_add}}{struct {\hyperref[driver\string-api/spi:c.spi_message]{\emph{spi\_message}}} *\emph{ message}, void *\emph{ res}}{}
add a spi\_res to the spi\_message

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_message * message}}] \leavevmode
the spi message

\item[{\code{void * res}}] \leavevmode
the spi\_resource

\end{description}
\index{spi\_res\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_res_release}\pysiglinewithargsret{void \bfcode{spi\_res\_release}}{struct {\hyperref[driver\string-api/spi:c.spi_controller]{\emph{spi\_controller}}} *\emph{ ctlr}, struct {\hyperref[driver\string-api/spi:c.spi_message]{\emph{spi\_message}}} *\emph{ message}}{}
release all spi resources for this message

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_controller * ctlr}}] \leavevmode
the \textbf{spi\_controller}

\item[{\code{struct spi\_message * message}}] \leavevmode
the \textbf{spi\_message}

\end{description}
\index{spi\_replace\_transfers (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_replace_transfers}\pysiglinewithargsret{struct {\hyperref[driver\string-api/spi:c.spi_replaced_transfers]{\emph{spi\_replaced\_transfers}}} * \bfcode{spi\_replace\_transfers}}{struct {\hyperref[driver\string-api/spi:c.spi_message]{\emph{spi\_message}}} *\emph{ msg}, struct {\hyperref[driver\string-api/spi:c.spi_transfer]{\emph{spi\_transfer}}} *\emph{ xfer\_first}, size\_t\emph{ remove}, size\_t\emph{ insert}, spi\_replaced\_release\_t\emph{ release}, size\_t\emph{ extradatasize}, gfp\_t\emph{ gfp}}{}
replace transfers with several transfers and register change with spi\_message.resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_message * msg}}] \leavevmode
the spi\_message we work upon

\item[{\code{struct spi\_transfer * xfer\_first}}] \leavevmode
the first spi\_transfer we want to replace

\item[{\code{size\_t remove}}] \leavevmode
number of transfers to remove

\item[{\code{size\_t insert}}] \leavevmode
the number of transfers we want to insert instead

\item[{\code{spi\_replaced\_release\_t release}}] \leavevmode
extra release code necessary in some circumstances

\item[{\code{size\_t extradatasize}}] \leavevmode
extra data to allocate (with alignment guarantees
of struct \textbf{spi\_transfer})

\item[{\code{gfp\_t gfp}}] \leavevmode
gfp flags

\end{description}

\textbf{Return}
\begin{description}
\item[{pointer to \textbf{spi\_replaced\_transfers},}] \leavevmode
PTR\_ERR(...) in case of errors.

\end{description}
\index{spi\_split\_transfers\_maxsize (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_split_transfers_maxsize}\pysiglinewithargsret{int \bfcode{spi\_split\_transfers\_maxsize}}{struct {\hyperref[driver\string-api/spi:c.spi_controller]{\emph{spi\_controller}}} *\emph{ ctlr}, struct {\hyperref[driver\string-api/spi:c.spi_message]{\emph{spi\_message}}} *\emph{ msg}, size\_t\emph{ maxsize}, gfp\_t\emph{ gfp}}{}
split spi transfers into multiple transfers when an individual transfer exceeds a certain size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_controller * ctlr}}] \leavevmode
the \textbf{spi\_controller} for this transfer

\item[{\code{struct spi\_message * msg}}] \leavevmode
the \textbf{spi\_message} to transform

\item[{\code{size\_t maxsize}}] \leavevmode
the maximum when to apply this

\item[{\code{gfp\_t gfp}}] \leavevmode
GFP allocation flags

\end{description}

\textbf{Return}

status of transformation
\index{spi\_setup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_setup}\pysiglinewithargsret{int \bfcode{spi\_setup}}{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} *\emph{ spi}}{}
setup SPI mode and clock rate

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
the device whose settings are being modified

\end{description}

\textbf{Context}

can sleep, and no requests are queued to the device

\textbf{Description}

SPI protocol drivers may need to update the transfer mode if the
device doesn't work with its default.  They may likewise need
to update clock rates or word sizes from initial values.  This function
changes those settings, and must be called from a context that can sleep.
Except for SPI\_CS\_HIGH, which takes effect immediately, the changes take
effect the next time the device is selected and data is transferred to
or from it.  When this function returns, the spi device is deselected.

Note that this call will fail if the protocol driver specifies an option
that the underlying controller or its driver does not support.  For
example, not all hardware supports wire transfers using nine bit words,
LSB-first wire encoding, or active-high chipselects.

\textbf{Return}

zero on success, else a negative error code.
\index{spi\_async (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_async}\pysiglinewithargsret{int \bfcode{spi\_async}}{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} *\emph{ spi}, struct {\hyperref[driver\string-api/spi:c.spi_message]{\emph{spi\_message}}} *\emph{ message}}{}
asynchronous SPI transfer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
device with which data will be exchanged

\item[{\code{struct spi\_message * message}}] \leavevmode
describes the data transfers, including completion callback

\end{description}

\textbf{Context}

any (irqs may be blocked, etc)

\textbf{Description}

This call may be used in\_irq and other contexts which can't sleep,
as well as from task contexts which can sleep.

The completion callback is invoked in a context which can't sleep.
Before that invocation, the value of message-\textgreater{}status is undefined.
When the callback is issued, message-\textgreater{}status holds either zero (to
indicate complete success) or a negative error code.  After that
callback returns, the driver which issued the transfer request may
deallocate the associated memory; it's no longer in use by any SPI
core or controller driver code.

Note that although all messages to a spi\_device are handled in
FIFO order, messages may go to different devices in other orders.
Some device might be higher priority, or have various ``hard'' access
time requirements, for example.

On detection of any fault during the transfer, processing of
the entire message is aborted, and the device is deselected.
Until returning from the associated message completion callback,
no other spi\_message queued to that device will be processed.
(This rule applies equally to all the synchronous transfer calls,
which are wrappers around this core asynchronous primitive.)

\textbf{Return}

zero on success, else a negative error code.
\index{spi\_async\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_async_locked}\pysiglinewithargsret{int \bfcode{spi\_async\_locked}}{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} *\emph{ spi}, struct {\hyperref[driver\string-api/spi:c.spi_message]{\emph{spi\_message}}} *\emph{ message}}{}
version of spi\_async with exclusive bus usage

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
device with which data will be exchanged

\item[{\code{struct spi\_message * message}}] \leavevmode
describes the data transfers, including completion callback

\end{description}

\textbf{Context}

any (irqs may be blocked, etc)

\textbf{Description}

This call may be used in\_irq and other contexts which can't sleep,
as well as from task contexts which can sleep.

The completion callback is invoked in a context which can't sleep.
Before that invocation, the value of message-\textgreater{}status is undefined.
When the callback is issued, message-\textgreater{}status holds either zero (to
indicate complete success) or a negative error code.  After that
callback returns, the driver which issued the transfer request may
deallocate the associated memory; it's no longer in use by any SPI
core or controller driver code.

Note that although all messages to a spi\_device are handled in
FIFO order, messages may go to different devices in other orders.
Some device might be higher priority, or have various ``hard'' access
time requirements, for example.

On detection of any fault during the transfer, processing of
the entire message is aborted, and the device is deselected.
Until returning from the associated message completion callback,
no other spi\_message queued to that device will be processed.
(This rule applies equally to all the synchronous transfer calls,
which are wrappers around this core asynchronous primitive.)

\textbf{Return}

zero on success, else a negative error code.
\index{spi\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_sync}\pysiglinewithargsret{int \bfcode{spi\_sync}}{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} *\emph{ spi}, struct {\hyperref[driver\string-api/spi:c.spi_message]{\emph{spi\_message}}} *\emph{ message}}{}
blocking/synchronous SPI data transfers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
device with which data will be exchanged

\item[{\code{struct spi\_message * message}}] \leavevmode
describes the data transfers

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

This call may only be used from a context that may sleep.  The sleep
is non-interruptible, and has no timeout.  Low-overhead controller
drivers may DMA directly into and out of the message buffers.

Note that the SPI device's chip select is active during the message,
and then is normally disabled between messages.  Drivers for some
frequently-used devices may want to minimize costs of selecting a chip,
by leaving it selected in anticipation that the next message will go
to the same chip.  (That may increase power usage.)

Also, the caller is guaranteeing that the memory associated with the
message will not be freed before this call returns.

\textbf{Return}

zero on success, else a negative error code.
\index{spi\_sync\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_sync_locked}\pysiglinewithargsret{int \bfcode{spi\_sync\_locked}}{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} *\emph{ spi}, struct {\hyperref[driver\string-api/spi:c.spi_message]{\emph{spi\_message}}} *\emph{ message}}{}
version of spi\_sync with exclusive bus usage

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
device with which data will be exchanged

\item[{\code{struct spi\_message * message}}] \leavevmode
describes the data transfers

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

This call may only be used from a context that may sleep.  The sleep
is non-interruptible, and has no timeout.  Low-overhead controller
drivers may DMA directly into and out of the message buffers.

This call should be used by drivers that require exclusive access to the
SPI bus. It has to be preceded by a spi\_bus\_lock call. The SPI bus must
be released by a spi\_bus\_unlock call when the exclusive access is over.

\textbf{Return}

zero on success, else a negative error code.
\index{spi\_bus\_lock (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_bus_lock}\pysiglinewithargsret{int \bfcode{spi\_bus\_lock}}{struct {\hyperref[driver\string-api/spi:c.spi_controller]{\emph{spi\_controller}}} *\emph{ ctlr}}{}
obtain a lock for exclusive SPI bus usage

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_controller * ctlr}}] \leavevmode
SPI bus master that should be locked for exclusive bus access

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

This call may only be used from a context that may sleep.  The sleep
is non-interruptible, and has no timeout.

This call should be used by drivers that require exclusive access to the
SPI bus. The SPI bus must be released by a spi\_bus\_unlock call when the
exclusive access is over. Data transfer must be done by spi\_sync\_locked
and spi\_async\_locked calls when the SPI bus lock is held.

\textbf{Return}

always zero.
\index{spi\_bus\_unlock (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_bus_unlock}\pysiglinewithargsret{int \bfcode{spi\_bus\_unlock}}{struct {\hyperref[driver\string-api/spi:c.spi_controller]{\emph{spi\_controller}}} *\emph{ ctlr}}{}
release the lock for exclusive SPI bus usage

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_controller * ctlr}}] \leavevmode
SPI bus master that was locked for exclusive bus access

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

This call may only be used from a context that may sleep.  The sleep
is non-interruptible, and has no timeout.

This call releases an SPI bus lock previously obtained by an spi\_bus\_lock
call.

\textbf{Return}

always zero.
\index{spi\_write\_then\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/spi:c.spi_write_then_read}\pysiglinewithargsret{int \bfcode{spi\_write\_then\_read}}{struct {\hyperref[driver\string-api/spi:c.spi_device]{\emph{spi\_device}}} *\emph{ spi}, const void *\emph{ txbuf}, unsigned\emph{ n\_tx}, void *\emph{ rxbuf}, unsigned\emph{ n\_rx}}{}
SPI synchronous write followed by read

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct spi\_device * spi}}] \leavevmode
device with which data will be exchanged

\item[{\code{const void * txbuf}}] \leavevmode
data to be written (need not be dma-safe)

\item[{\code{unsigned n\_tx}}] \leavevmode
size of txbuf, in bytes

\item[{\code{void * rxbuf}}] \leavevmode
buffer into which data will be read (need not be dma-safe)

\item[{\code{unsigned n\_rx}}] \leavevmode
size of rxbuf, in bytes

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

This performs a half duplex MicroWire style transaction with the
device, sending txbuf and then reading rxbuf.  The return value
is zero for success, else a negative errno status code.
This call may only be used from a context that may sleep.

Parameters to this routine are always copied using a small buffer;
portable code should never use this for more than 32 bytes.
Performance-sensitive or bulk transfer code should instead use
spi\_\{async,sync\}() calls with dma-safe buffers.

\textbf{Return}

zero on success, else a negative error code.


\chapter{I$^{\text{2}}$C and SMBus Subsystem}
\label{driver-api/i2c:i2c-and-smbus-subsystem}\label{driver-api/i2c::doc}
I$^{\text{2}}$C (or without fancy typography, ``I2C'') is an acronym for
the ``Inter-IC'' bus, a simple bus protocol which is widely used where low
data rate communications suffice. Since it's also a licensed trademark,
some vendors use another name (such as ``Two-Wire Interface'', TWI) for
the same bus. I2C only needs two signals (SCL for clock, SDA for data),
conserving board real estate and minimizing signal quality issues. Most
I2C devices use seven bit addresses, and bus speeds of up to 400 kHz;
there's a high speed extension (3.4 MHz) that's not yet found wide use.
I2C is a multi-master bus; open drain signaling is used to arbitrate
between masters, as well as to handshake and to synchronize clocks from
slower clients.

The Linux I2C programming interfaces support the master side of bus
interactions and the slave side. The programming interface is
structured around two kinds of driver, and two kinds of device. An I2C
``Adapter Driver'' abstracts the controller hardware; it binds to a
physical device (perhaps a PCI device or platform\_device) and exposes a
\code{struct i2c\_adapter} representing each
I2C bus segment it manages. On each I2C bus segment will be I2C devices
represented by a {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{\code{struct i2c\_client}}}}.
Those devices will be bound to a {\hyperref[driver\string-api/i2c:c.i2c_driver]{\emph{\code{struct i2c\_driver}}}}, which should follow the standard Linux driver model. There
are functions to perform various I2C protocol operations; at this writing
all such functions are usable only from task context.

The System Management Bus (SMBus) is a sibling protocol. Most SMBus
systems are also I2C conformant. The electrical constraints are tighter
for SMBus, and it standardizes particular protocol messages and idioms.
Controllers that support I2C can also support most SMBus operations, but
SMBus controllers don't support all the protocol options that an I2C
controller will. There are functions to perform various SMBus protocol
operations, either using I2C primitives or by issuing SMBus commands to
i2c\_adapter devices which don't support those I2C operations.
\index{i2c\_master\_recv (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_master_recv}\pysiglinewithargsret{int \bfcode{i2c\_master\_recv}}{const struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}, char *\emph{ buf}, int\emph{ count}}{}
issue a single I2C message in master receive mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct i2c\_client * client}}] \leavevmode
Handle to slave device

\item[{\code{char * buf}}] \leavevmode
Where to store data read from slave

\item[{\code{int count}}] \leavevmode
How many bytes to read, must be less than 64k since msg.len is u16

\end{description}

\textbf{Description}

Returns negative errno, or else the number of bytes read.
\index{i2c\_master\_recv\_dmasafe (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_master_recv_dmasafe}\pysiglinewithargsret{int \bfcode{i2c\_master\_recv\_dmasafe}}{const struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}, char *\emph{ buf}, int\emph{ count}}{}
issue a single I2C message in master receive mode using a DMA safe buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct i2c\_client * client}}] \leavevmode
Handle to slave device

\item[{\code{char * buf}}] \leavevmode
Where to store data read from slave, must be safe to use with DMA

\item[{\code{int count}}] \leavevmode
How many bytes to read, must be less than 64k since msg.len is u16

\end{description}

\textbf{Description}

Returns negative errno, or else the number of bytes read.
\index{i2c\_master\_send (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_master_send}\pysiglinewithargsret{int \bfcode{i2c\_master\_send}}{const struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}, const char *\emph{ buf}, int\emph{ count}}{}
issue a single I2C message in master transmit mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct i2c\_client * client}}] \leavevmode
Handle to slave device

\item[{\code{const char * buf}}] \leavevmode
Data that will be written to the slave

\item[{\code{int count}}] \leavevmode
How many bytes to write, must be less than 64k since msg.len is u16

\end{description}

\textbf{Description}

Returns negative errno, or else the number of bytes written.
\index{i2c\_master\_send\_dmasafe (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_master_send_dmasafe}\pysiglinewithargsret{int \bfcode{i2c\_master\_send\_dmasafe}}{const struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}, const char *\emph{ buf}, int\emph{ count}}{}
issue a single I2C message in master transmit mode using a DMA safe buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct i2c\_client * client}}] \leavevmode
Handle to slave device

\item[{\code{const char * buf}}] \leavevmode
Data that will be written to the slave, must be safe to use with DMA

\item[{\code{int count}}] \leavevmode
How many bytes to write, must be less than 64k since msg.len is u16

\end{description}

\textbf{Description}

Returns negative errno, or else the number of bytes written.
\index{i2c\_driver (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_driver}\pysigline{struct \bfcode{i2c\_driver}}
represent an I2C device driver

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct i2c\PYGZus{}driver \PYGZob{}
  unsigned int class;
  int (*attach\PYGZus{}adapter)(struct i2c\PYGZus{}adapter *) \PYGZus{}\PYGZus{}deprecated;
  int (*probe)(struct i2c\PYGZus{}client *, const struct i2c\PYGZus{}device\PYGZus{}id *);
  int (*remove)(struct i2c\PYGZus{}client *);
  int (*probe\PYGZus{}new)(struct i2c\PYGZus{}client *);
  void (*shutdown)(struct i2c\PYGZus{}client *);
  void (*alert)(struct i2c\PYGZus{}client *, enum i2c\PYGZus{}alert\PYGZus{}protocol protocol, unsigned int data);
  int (*command)(struct i2c\PYGZus{}client *client, unsigned int cmd, void *arg);
  struct device\PYGZus{}driver driver;
  const struct i2c\PYGZus{}device\PYGZus{}id *id\PYGZus{}table;
  int (*detect)(struct i2c\PYGZus{}client *, struct i2c\PYGZus{}board\PYGZus{}info *);
  const unsigned short *address\PYGZus{}list;
  struct list\PYGZus{}head clients;
  bool disable\PYGZus{}i2c\PYGZus{}core\PYGZus{}irq\PYGZus{}mapping;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{class}}] \leavevmode
What kind of i2c device we instantiate (for detect)

\item[{\code{attach\_adapter}}] \leavevmode
Callback for bus addition (deprecated)

\item[{\code{probe}}] \leavevmode
Callback for device binding - soon to be deprecated

\item[{\code{remove}}] \leavevmode
Callback for device unbinding

\item[{\code{probe\_new}}] \leavevmode
New callback for device binding

\item[{\code{shutdown}}] \leavevmode
Callback for device shutdown

\item[{\code{alert}}] \leavevmode
Alert callback, for example for the SMBus alert protocol

\item[{\code{command}}] \leavevmode
Callback for bus-wide signaling (optional)

\item[{\code{driver}}] \leavevmode
Device driver model driver

\item[{\code{id\_table}}] \leavevmode
List of I2C devices supported by this driver

\item[{\code{detect}}] \leavevmode
Callback for device detection

\item[{\code{address\_list}}] \leavevmode
The I2C addresses to probe (for detect)

\item[{\code{clients}}] \leavevmode
List of detected clients we created (for i2c-core use only)

\item[{\code{disable\_i2c\_core\_irq\_mapping}}] \leavevmode
Tell the i2c-core to not do irq-mapping

\end{description}

\textbf{Description}

The driver.owner field should be set to the module owner of this driver.
The driver.name field should be set to the name of this driver.

For automatic device detection, both \textbf{detect} and \textbf{address\_list} must
be defined. \textbf{class} should also be set, otherwise only devices forced
with module parameters will be created. The detect function must
fill at least the name field of the i2c\_board\_info structure it is
handed upon successful detection, and possibly also the flags field.

If \textbf{detect} is missing, the driver will still work fine for enumerated
devices. Detected devices simply won't be supported. This is expected
for the many I2C/SMBus devices which can't be detected reliably, and
the ones which can always be enumerated in practice.

The i2c\_client structure which is handed to the \textbf{detect} callback is
not a real i2c\_client. It is initialized just enough so that you can
call i2c\_smbus\_read\_byte\_data and friends on it. Don't do anything
else with it. In particular, calling dev\_dbg and friends on it is
not allowed.
\index{i2c\_client (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_client}\pysigline{struct \bfcode{i2c\_client}}
represent an I2C slave device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct i2c\PYGZus{}client \PYGZob{}
  unsigned short flags;
  unsigned short addr;
  char name[I2C\PYGZus{}NAME\PYGZus{}SIZE];
  struct i2c\PYGZus{}adapter *adapter;
  struct device dev;
  int irq;
  struct list\PYGZus{}head detected;
\PYGZsh{}if IS\PYGZus{}ENABLED(CONFIG\PYGZus{}I2C\PYGZus{}SLAVE);
  i2c\PYGZus{}slave\PYGZus{}cb\PYGZus{}t slave\PYGZus{}cb;
\PYGZsh{}endif;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{flags}}] \leavevmode
I2C\_CLIENT\_TEN indicates the device uses a ten bit chip address;
I2C\_CLIENT\_PEC indicates it uses SMBus Packet Error Checking

\item[{\code{addr}}] \leavevmode
Address used on the I2C bus connected to the parent adapter.

\item[{\code{name}}] \leavevmode
Indicates the type of the device, usually a chip name that's
generic enough to hide second-sourcing and compatible revisions.

\item[{\code{adapter}}] \leavevmode
manages the bus segment hosting this I2C device

\item[{\code{dev}}] \leavevmode
Driver model device node for the slave.

\item[{\code{irq}}] \leavevmode
indicates the IRQ generated by this device (if any)

\item[{\code{detected}}] \leavevmode
member of an i2c\_driver.clients list or i2c-core's
userspace\_devices list

\item[{\code{slave\_cb}}] \leavevmode
Callback when I2C slave mode of an adapter is used. The adapter
calls it to pass on slave events to the slave driver.

\end{description}

\textbf{Description}

An i2c\_client identifies a single device (i.e. chip) connected to an
i2c bus. The behaviour exposed to Linux is defined by the driver
managing the device.
\index{i2c\_board\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_board_info}\pysigline{struct \bfcode{i2c\_board\_info}}
template for device creation

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct i2c\PYGZus{}board\PYGZus{}info \PYGZob{}
  char type[I2C\PYGZus{}NAME\PYGZus{}SIZE];
  unsigned short  flags;
  unsigned short  addr;
  const char      *dev\PYGZus{}name;
  void *platform\PYGZus{}data;
  struct dev\PYGZus{}archdata     *archdata;
  struct device\PYGZus{}node *of\PYGZus{}node;
  struct fwnode\PYGZus{}handle *fwnode;
  const struct property\PYGZus{}entry *properties;
  const struct resource *resources;
  unsigned int    num\PYGZus{}resources;
  int irq;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{type}}] \leavevmode
chip type, to initialize i2c\_client.name

\item[{\code{flags}}] \leavevmode
to initialize i2c\_client.flags

\item[{\code{addr}}] \leavevmode
stored in i2c\_client.addr

\item[{\code{dev\_name}}] \leavevmode
Overrides the default \textless{}busnr\textgreater{}-\textless{}addr\textgreater{} dev\_name if set

\item[{\code{platform\_data}}] \leavevmode
stored in i2c\_client.dev.platform\_data

\item[{\code{archdata}}] \leavevmode
copied into i2c\_client.dev.archdata

\item[{\code{of\_node}}] \leavevmode
pointer to OpenFirmware device node

\item[{\code{fwnode}}] \leavevmode
device node supplied by the platform firmware

\item[{\code{properties}}] \leavevmode
additional device properties for the device

\item[{\code{resources}}] \leavevmode
resources associated with the device

\item[{\code{num\_resources}}] \leavevmode
number of resources in the \textbf{resources} array

\item[{\code{irq}}] \leavevmode
stored in i2c\_client.irq

\end{description}

\textbf{Description}

I2C doesn't actually support hardware probing, although controllers and
devices may be able to use I2C\_SMBUS\_QUICK to tell whether or not there's
a device at a given address.  Drivers commonly need more information than
that, such as chip type, configuration, associated IRQ, and so on.

i2c\_board\_info is used to build tables of information listing I2C devices
that are present.  This information is used to grow the driver model tree.
For mainboards this is done statically using {\hyperref[driver\string-api/i2c:c.i2c_register_board_info]{\emph{\code{i2c\_register\_board\_info()}}}};
bus numbers identify adapters that aren't yet available.  For add-on boards,
{\hyperref[driver\string-api/i2c:c.i2c_new_device]{\emph{\code{i2c\_new\_device()}}}} does this dynamically with the adapter already known.
\index{I2C\_BOARD\_INFO (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.I2C_BOARD_INFO}\pysiglinewithargsret{\bfcode{I2C\_BOARD\_INFO}}{\emph{dev\_type}, \emph{dev\_addr}}{}
macro used to list an i2c device and its address

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{dev\_type}}] \leavevmode
identifies the device type

\item[{\code{dev\_addr}}] \leavevmode
the device's address on the bus.

\end{description}

\textbf{Description}

This macro initializes essential fields of a struct i2c\_board\_info,
declaring what has been provided on a particular board.  Optional
fields (such as associated irq, or device-specific platform\_data)
are provided using conventional syntax.
\index{i2c\_algorithm (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_algorithm}\pysigline{struct \bfcode{i2c\_algorithm}}
represent I2C transfer method

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct i2c\PYGZus{}algorithm \PYGZob{}
  int (*master\PYGZus{}xfer)(struct i2c\PYGZus{}adapter *adap, struct i2c\PYGZus{}msg *msgs, int num);
  int (*smbus\PYGZus{}xfer) (struct i2c\PYGZus{}adapter *adap, u16 addr,unsigned short flags, char read\PYGZus{}write, u8 command, int size, union i2c\PYGZus{}smbus\PYGZus{}data *data);
  u32 (*functionality) (struct i2c\PYGZus{}adapter *);
\PYGZsh{}if IS\PYGZus{}ENABLED(CONFIG\PYGZus{}I2C\PYGZus{}SLAVE);
  int (*reg\PYGZus{}slave)(struct i2c\PYGZus{}client *client);
  int (*unreg\PYGZus{}slave)(struct i2c\PYGZus{}client *client);
\PYGZsh{}endif;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{master\_xfer}}] \leavevmode
Issue a set of i2c transactions to the given I2C adapter
defined by the msgs array, with num messages available to transfer via
the adapter specified by adap.

\item[{\code{smbus\_xfer}}] \leavevmode
Issue smbus transactions to the given I2C adapter. If this
is not present, then the bus layer will try and convert the SMBus calls
into I2C transfers instead.

\item[{\code{functionality}}] \leavevmode
Return the flags that this algorithm/adapter pair supports
from the I2C\_FUNC\_* flags.

\item[{\code{reg\_slave}}] \leavevmode
Register given client to I2C slave mode of this adapter

\item[{\code{unreg\_slave}}] \leavevmode
Unregister given client from I2C slave mode of this adapter

\end{description}

\textbf{Description}

The following structs are for those who like to implement new bus drivers:
i2c\_algorithm is the interface to a class of hardware solutions which can
be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584
to name two of the most common.

The return codes from the \textbf{master\_xfer} field should indicate the type of
error code that occurred during the transfer, as documented in the kernel
Documentation file Documentation/i2c/fault-codes.
\index{i2c\_lock\_operations (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_lock_operations}\pysigline{struct \bfcode{i2c\_lock\_operations}}
represent I2C locking operations

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct i2c\PYGZus{}lock\PYGZus{}operations \PYGZob{}
  void (*lock\PYGZus{}bus)(struct i2c\PYGZus{}adapter *, unsigned int flags);
  int (*trylock\PYGZus{}bus)(struct i2c\PYGZus{}adapter *, unsigned int flags);
  void (*unlock\PYGZus{}bus)(struct i2c\PYGZus{}adapter *, unsigned int flags);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{lock\_bus}}] \leavevmode
Get exclusive access to an I2C bus segment

\item[{\code{trylock\_bus}}] \leavevmode
Try to get exclusive access to an I2C bus segment

\item[{\code{unlock\_bus}}] \leavevmode
Release exclusive access to an I2C bus segment

\end{description}

\textbf{Description}

The main operations are wrapped by i2c\_lock\_bus and i2c\_unlock\_bus.
\index{i2c\_timings (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_timings}\pysigline{struct \bfcode{i2c\_timings}}
I2C timing information

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct i2c\PYGZus{}timings \PYGZob{}
  u32 bus\PYGZus{}freq\PYGZus{}hz;
  u32 scl\PYGZus{}rise\PYGZus{}ns;
  u32 scl\PYGZus{}fall\PYGZus{}ns;
  u32 scl\PYGZus{}int\PYGZus{}delay\PYGZus{}ns;
  u32 sda\PYGZus{}fall\PYGZus{}ns;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{bus\_freq\_hz}}] \leavevmode
the bus frequency in Hz

\item[{\code{scl\_rise\_ns}}] \leavevmode
time SCL signal takes to rise in ns; t(r) in the I2C specification

\item[{\code{scl\_fall\_ns}}] \leavevmode
time SCL signal takes to fall in ns; t(f) in the I2C specification

\item[{\code{scl\_int\_delay\_ns}}] \leavevmode
time IP core additionally needs to setup SCL in ns

\item[{\code{sda\_fall\_ns}}] \leavevmode
time SDA signal takes to fall in ns; t(f) in the I2C specification

\end{description}
\index{i2c\_bus\_recovery\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_bus_recovery_info}\pysigline{struct \bfcode{i2c\_bus\_recovery\_info}}
I2C bus recovery information

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct i2c\PYGZus{}bus\PYGZus{}recovery\PYGZus{}info \PYGZob{}
  int (*recover\PYGZus{}bus)(struct i2c\PYGZus{}adapter *adap);
  int (*get\PYGZus{}scl)(struct i2c\PYGZus{}adapter *adap);
  void (*set\PYGZus{}scl)(struct i2c\PYGZus{}adapter *adap, int val);
  int (*get\PYGZus{}sda)(struct i2c\PYGZus{}adapter *adap);
  void (*set\PYGZus{}sda)(struct i2c\PYGZus{}adapter *adap, int val);
  void (*prepare\PYGZus{}recovery)(struct i2c\PYGZus{}adapter *adap);
  void (*unprepare\PYGZus{}recovery)(struct i2c\PYGZus{}adapter *adap);
  struct gpio\PYGZus{}desc *scl\PYGZus{}gpiod;
  struct gpio\PYGZus{}desc *sda\PYGZus{}gpiod;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{recover\_bus}}] \leavevmode
Recover routine. Either pass driver's \code{recover\_bus()} routine, or
\code{i2c\_generic\_scl\_recovery()}.

\item[{\code{get\_scl}}] \leavevmode
This gets current value of SCL line. Mandatory for generic SCL
recovery. Populated internally for generic GPIO recovery.

\item[{\code{set\_scl}}] \leavevmode
This sets/clears the SCL line. Mandatory for generic SCL recovery.
Populated internally for generic GPIO recovery.

\item[{\code{get\_sda}}] \leavevmode
This gets current value of SDA line. Optional for generic SCL
recovery. Populated internally, if sda\_gpio is a valid GPIO, for generic
GPIO recovery.

\item[{\code{set\_sda}}] \leavevmode
This sets/clears the SDA line. Optional for generic SCL recovery.
Populated internally, if sda\_gpio is a valid GPIO, for generic GPIO
recovery.

\item[{\code{prepare\_recovery}}] \leavevmode
This will be called before starting recovery. Platform may
configure padmux here for SDA/SCL line or something else they want.

\item[{\code{unprepare\_recovery}}] \leavevmode
This will be called after completing recovery. Platform
may configure padmux here for SDA/SCL line or something else they want.

\item[{\code{scl\_gpiod}}] \leavevmode
gpiod of the SCL line. Only required for GPIO recovery.

\item[{\code{sda\_gpiod}}] \leavevmode
gpiod of the SDA line. Only required for GPIO recovery.

\end{description}
\index{i2c\_adapter\_quirks (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_adapter_quirks}\pysigline{struct \bfcode{i2c\_adapter\_quirks}}
describe flaws of an i2c adapter

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct i2c\PYGZus{}adapter\PYGZus{}quirks \PYGZob{}
  u64 flags;
  int max\PYGZus{}num\PYGZus{}msgs;
  u16 max\PYGZus{}write\PYGZus{}len;
  u16 max\PYGZus{}read\PYGZus{}len;
  u16 max\PYGZus{}comb\PYGZus{}1st\PYGZus{}msg\PYGZus{}len;
  u16 max\PYGZus{}comb\PYGZus{}2nd\PYGZus{}msg\PYGZus{}len;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{flags}}] \leavevmode
see I2C\_AQ\_* for possible flags and read below

\item[{\code{max\_num\_msgs}}] \leavevmode
maximum number of messages per transfer

\item[{\code{max\_write\_len}}] \leavevmode
maximum length of a write message

\item[{\code{max\_read\_len}}] \leavevmode
maximum length of a read message

\item[{\code{max\_comb\_1st\_msg\_len}}] \leavevmode
maximum length of the first msg in a combined message

\item[{\code{max\_comb\_2nd\_msg\_len}}] \leavevmode
maximum length of the second msg in a combined message

\end{description}

\textbf{Description}

Note about combined messages: Some I2C controllers can only send one message
per transfer, plus something called combined message or write-then-read.
This is (usually) a small write message followed by a read message and
barely enough to access register based devices like EEPROMs. There is a flag
to support this mode. It implies max\_num\_msg = 2 and does the length checks
with max\_comb\_*\_len because combined message mode usually has its own
limitations. Because of HW implementations, some controllers can actually do
write-then-anything or other variants. To support that, write-then-read has
been broken out into smaller bits like write-first and read-second which can
be combined as needed.
\index{i2c\_lock\_bus (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_lock_bus}\pysiglinewithargsret{void \bfcode{i2c\_lock\_bus}}{struct i2c\_adapter *\emph{ adapter}, unsigned int\emph{ flags}}{}
Get exclusive access to an I2C bus segment

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
Target I2C bus segment

\item[{\code{unsigned int flags}}] \leavevmode
I2C\_LOCK\_ROOT\_ADAPTER locks the root i2c adapter, I2C\_LOCK\_SEGMENT
locks only this branch in the adapter tree

\end{description}
\index{i2c\_trylock\_bus (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_trylock_bus}\pysiglinewithargsret{int \bfcode{i2c\_trylock\_bus}}{struct i2c\_adapter *\emph{ adapter}, unsigned int\emph{ flags}}{}
Try to get exclusive access to an I2C bus segment

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
Target I2C bus segment

\item[{\code{unsigned int flags}}] \leavevmode
I2C\_LOCK\_ROOT\_ADAPTER tries to locks the root i2c adapter,
I2C\_LOCK\_SEGMENT tries to lock only this branch in the adapter tree

\end{description}

\textbf{Return}

true if the I2C bus segment is locked, false otherwise
\index{i2c\_unlock\_bus (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_unlock_bus}\pysiglinewithargsret{void \bfcode{i2c\_unlock\_bus}}{struct i2c\_adapter *\emph{ adapter}, unsigned int\emph{ flags}}{}
Release exclusive access to an I2C bus segment

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
Target I2C bus segment

\item[{\code{unsigned int flags}}] \leavevmode
I2C\_LOCK\_ROOT\_ADAPTER unlocks the root i2c adapter, I2C\_LOCK\_SEGMENT
unlocks only this branch in the adapter tree

\end{description}
\index{i2c\_check\_quirks (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_check_quirks}\pysiglinewithargsret{bool \bfcode{i2c\_check\_quirks}}{struct i2c\_adapter *\emph{ adap}, u64\emph{ quirks}}{}
Function for checking the quirk flags in an i2c adapter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adap}}] \leavevmode
i2c adapter

\item[{\code{u64 quirks}}] \leavevmode
quirk flags

\end{description}

\textbf{Return}

true if the adapter has all the specified quirk flags, false if not
\index{module\_i2c\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.module_i2c_driver}\pysiglinewithargsret{\bfcode{module\_i2c\_driver}}{\emph{\_\_i2c\_driver}}{}
Helper macro for registering a modular I2C driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_i2c\_driver}}] \leavevmode
i2c\_driver struct

\end{description}

\textbf{Description}

Helper macro for I2C drivers which do not do anything special in module
init/exit. This eliminates a lot of boilerplate. Each module may only
use this macro once, and calling it replaces {\hyperref[driver\string-api/basics:c.module_init]{\emph{\code{module\_init()}}}} and {\hyperref[driver\string-api/basics:c.module_exit]{\emph{\code{module\_exit()}}}}
\index{builtin\_i2c\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.builtin_i2c_driver}\pysiglinewithargsret{\bfcode{builtin\_i2c\_driver}}{\emph{\_\_i2c\_driver}}{}
Helper macro for registering a builtin I2C driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_i2c\_driver}}] \leavevmode
i2c\_driver struct

\end{description}

\textbf{Description}

Helper macro for I2C drivers which do not do anything special in their
init. This eliminates a lot of boilerplate. Each driver may only
use this macro once, and calling it replaces \code{device\_initcall()}.
\index{i2c\_register\_board\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_register_board_info}\pysiglinewithargsret{int \bfcode{i2c\_register\_board\_info}}{int\emph{ busnum}, struct {\hyperref[driver\string-api/i2c:c.i2c_board_info]{\emph{i2c\_board\_info}}} const *\emph{ info}, unsigned\emph{ len}}{}
statically declare I2C devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int busnum}}] \leavevmode
identifies the bus to which these devices belong

\item[{\code{struct i2c\_board\_info const * info}}] \leavevmode
vector of i2c device descriptors

\item[{\code{unsigned len}}] \leavevmode
how many descriptors in the vector; may be zero to reserve
the specified bus number.

\end{description}

\textbf{Description}

Systems using the Linux I2C driver stack can declare tables of board info
while they initialize.  This should be done in board-specific init code
near \code{arch\_initcall()} time, or equivalent, before any I2C adapter driver is
registered.  For example, mainboard init code could define several devices,
as could the init code for each daughtercard in a board stack.

The I2C devices will be created later, after the adapter for the relevant
bus has been registered.  After that moment, standard driver model tools
are used to bind ``new style'' I2C drivers to the devices.  The bus number
for any device declared using this routine is not available for dynamic
allocation.

The board info passed can safely be \_\_initdata, but be careful of embedded
pointers (for platform\_data, functions, etc) since that won't be copied.
Device properties are deep-copied though.
\index{i2c\_verify\_client (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_verify_client}\pysiglinewithargsret{struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} * \bfcode{i2c\_verify\_client}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
return parameter as i2c\_client, or NULL

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device, probably from some driver model iterator

\end{description}

\textbf{Description}

When traversing the driver model tree, perhaps using driver model
iterators like \textbf{device\_for\_each\_child()}, you can't assume very much
about the nodes you find.  Use this function to avoid oopses caused
by wrongly treating some non-I2C device as an i2c\_client.
\index{i2c\_new\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_new_device}\pysiglinewithargsret{struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} * \bfcode{i2c\_new\_device}}{struct i2c\_adapter *\emph{ adap}, struct {\hyperref[driver\string-api/i2c:c.i2c_board_info]{\emph{i2c\_board\_info}}} const *\emph{ info}}{}
instantiate an i2c device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adap}}] \leavevmode
the adapter managing the device

\item[{\code{struct i2c\_board\_info const * info}}] \leavevmode
describes one I2C device; bus\_num is ignored

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

Create an i2c device. Binding is handled through driver model
\code{probe()}/\code{remove()} methods.  A driver may be bound to this device when we
return from this function, or any later moment (e.g. maybe hotplugging will
load the driver module).  This call is not appropriate for use by mainboard
initialization logic, which usually runs during an \code{arch\_initcall()} long
before any i2c\_adapter could exist.

This returns the new i2c client, which may be saved for later use with
{\hyperref[driver\string-api/i2c:c.i2c_unregister_device]{\emph{\code{i2c\_unregister\_device()}}}}; or NULL to indicate an error.
\index{i2c\_unregister\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_unregister_device}\pysiglinewithargsret{void \bfcode{i2c\_unregister\_device}}{struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}}{}
reverse effect of {\hyperref[driver\string-api/i2c:c.i2c_new_device]{\emph{\code{i2c\_new\_device()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_client * client}}] \leavevmode
value returned from {\hyperref[driver\string-api/i2c:c.i2c_new_device]{\emph{\code{i2c\_new\_device()}}}}

\end{description}

\textbf{Context}

can sleep
\index{i2c\_new\_dummy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_new_dummy}\pysiglinewithargsret{struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} * \bfcode{i2c\_new\_dummy}}{struct i2c\_adapter *\emph{ adapter}, u16\emph{ address}}{}
return a new i2c device bound to a dummy driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
the adapter managing the device

\item[{\code{u16 address}}] \leavevmode
seven bit address to be used

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

This returns an I2C client bound to the ``dummy'' driver, intended for use
with devices that consume multiple addresses.  Examples of such chips
include various EEPROMS (like 24c04 and 24c08 models).

These dummy devices have two main uses.  First, most I2C and SMBus calls
except {\hyperref[driver\string-api/i2c:c.i2c_transfer]{\emph{\code{i2c\_transfer()}}}} need a client handle; the dummy will be that handle.
And second, this prevents the specified address from being bound to a
different driver.

This returns the new i2c client, which should be saved for later use with
{\hyperref[driver\string-api/i2c:c.i2c_unregister_device]{\emph{\code{i2c\_unregister\_device()}}}}; or NULL to indicate an error.
\index{i2c\_new\_secondary\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_new_secondary_device}\pysiglinewithargsret{struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} * \bfcode{i2c\_new\_secondary\_device}}{struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}, const char *\emph{ name}, u16\emph{ default\_addr}}{}
Helper to get the instantiated secondary address and create the associated device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_client * client}}] \leavevmode
Handle to the primary client

\item[{\code{const char * name}}] \leavevmode
Handle to specify which secondary address to get

\item[{\code{u16 default\_addr}}] \leavevmode
Used as a fallback if no secondary address was specified

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

I2C clients can be composed of multiple I2C slaves bound together in a single
component. The I2C client driver then binds to the master I2C slave and needs
to create I2C dummy clients to communicate with all the other slaves.

This function creates and returns an I2C dummy client whose I2C address is
retrieved from the platform firmware based on the given slave name. If no
address is specified by the firmware default\_addr is used.

On DT-based platforms the address is retrieved from the ``reg'' property entry
cell whose ``reg-names'' value matches the slave name.

This returns the new i2c client, which should be saved for later use with
{\hyperref[driver\string-api/i2c:c.i2c_unregister_device]{\emph{\code{i2c\_unregister\_device()}}}}; or NULL to indicate an error.
\index{i2c\_verify\_adapter (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_verify_adapter}\pysiglinewithargsret{struct i2c\_adapter * \bfcode{i2c\_verify\_adapter}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
return parameter as i2c\_adapter or NULL

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device, probably from some driver model iterator

\end{description}

\textbf{Description}

When traversing the driver model tree, perhaps using driver model
iterators like \textbf{device\_for\_each\_child()}, you can't assume very much
about the nodes you find.  Use this function to avoid oopses caused
by wrongly treating some non-I2C device as an i2c\_adapter.
\index{i2c\_handle\_smbus\_host\_notify (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_handle_smbus_host_notify}\pysiglinewithargsret{int \bfcode{i2c\_handle\_smbus\_host\_notify}}{struct i2c\_adapter *\emph{ adap}, unsigned short\emph{ addr}}{}
Forward a Host Notify event to the correct I2C client.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adap}}] \leavevmode
the adapter

\item[{\code{unsigned short addr}}] \leavevmode
the I2C address of the notifying device

\end{description}

\textbf{Context}

can't sleep

\textbf{Description}

Helper function to be called from an I2C bus driver's interrupt
handler. It will schedule the Host Notify IRQ.
\index{i2c\_add\_adapter (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_add_adapter}\pysiglinewithargsret{int \bfcode{i2c\_add\_adapter}}{struct i2c\_adapter *\emph{ adapter}}{}
declare i2c adapter, use dynamic bus number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
the adapter to add

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

This routine is used to declare an I2C adapter when its bus number
doesn't matter or when its bus number is specified by an dt alias.
Examples of bases when the bus number doesn't matter: I2C adapters
dynamically added by USB links or PCI plugin cards.

When this returns zero, a new bus number was allocated and stored
in adap-\textgreater{}nr, and the specified adapter became available for clients.
Otherwise, a negative errno value is returned.
\index{i2c\_add\_numbered\_adapter (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_add_numbered_adapter}\pysiglinewithargsret{int \bfcode{i2c\_add\_numbered\_adapter}}{struct i2c\_adapter *\emph{ adap}}{}
declare i2c adapter, use static bus number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adap}}] \leavevmode
the adapter to register (with adap-\textgreater{}nr initialized)

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

This routine is used to declare an I2C adapter when its bus number
matters.  For example, use it for I2C adapters from system-on-chip CPUs,
or otherwise built in to the system's mainboard, and where i2c\_board\_info
is used to properly configure I2C devices.

If the requested bus number is set to -1, then this function will behave
identically to i2c\_add\_adapter, and will dynamically assign a bus number.

If no devices have pre-been declared for this bus, then be sure to
register the adapter before any dynamically allocated ones.  Otherwise
the required bus ID may not be available.

When this returns zero, the specified adapter became available for
clients using the bus number provided in adap-\textgreater{}nr.  Also, the table
of I2C devices pre-declared using {\hyperref[driver\string-api/i2c:c.i2c_register_board_info]{\emph{\code{i2c\_register\_board\_info()}}}} is scanned,
and the appropriate driver model device nodes are created.  Otherwise, a
negative errno value is returned.
\index{i2c\_del\_adapter (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_del_adapter}\pysiglinewithargsret{void \bfcode{i2c\_del\_adapter}}{struct i2c\_adapter *\emph{ adap}}{}
unregister I2C adapter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adap}}] \leavevmode
the adapter being unregistered

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

This unregisters an I2C adapter which was previously registered
by \textbf{i2c\_add\_adapter} or \textbf{i2c\_add\_numbered\_adapter}.
\index{i2c\_parse\_fw\_timings (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_parse_fw_timings}\pysiglinewithargsret{void \bfcode{i2c\_parse\_fw\_timings}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct {\hyperref[driver\string-api/i2c:c.i2c_timings]{\emph{i2c\_timings}}} *\emph{ t}, bool\emph{ use\_defaults}}{}
get I2C related timing parameters from firmware

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
The device to scan for I2C timing properties

\item[{\code{struct i2c\_timings * t}}] \leavevmode
the i2c\_timings struct to be filled with values

\item[{\code{bool use\_defaults}}] \leavevmode
bool to use sane defaults derived from the I2C specification
when properties are not found, otherwise use 0

\end{description}

\textbf{Description}

Scan the device for the generic I2C properties describing timing parameters
for the signal and fill the given struct with the results. If a property was
not found and use\_defaults was true, then maximum timings are assumed which
are derived from the I2C specification. If use\_defaults is not used, the
results will be 0, so drivers can apply their own defaults later. The latter
is mainly intended for avoiding regressions of existing drivers which want
to switch to this function. New drivers almost always should use the defaults.
\index{i2c\_del\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_del_driver}\pysiglinewithargsret{void \bfcode{i2c\_del\_driver}}{struct {\hyperref[driver\string-api/i2c:c.i2c_driver]{\emph{i2c\_driver}}} *\emph{ driver}}{}
unregister I2C driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_driver * driver}}] \leavevmode
the driver being unregistered

\end{description}

\textbf{Context}

can sleep
\index{i2c\_use\_client (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_use_client}\pysiglinewithargsret{struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} * \bfcode{i2c\_use\_client}}{struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}}{}
increments the reference count of the i2c client structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_client * client}}] \leavevmode
the client being referenced

\end{description}

\textbf{Description}

Each live reference to a client should be refcounted. The driver model does
that automatically as part of driver binding, so that most drivers don't
need to do this explicitly: they hold a reference until they're unbound
from the device.

A pointer to the client with the incremented reference counter is returned.
\index{i2c\_release\_client (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_release_client}\pysiglinewithargsret{void \bfcode{i2c\_release\_client}}{struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}}{}
release a use of the i2c client structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_client * client}}] \leavevmode
the client being no longer referenced

\end{description}

\textbf{Description}

Must be called when a user of a client is finished with it.
\index{\_\_i2c\_transfer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.__i2c_transfer}\pysiglinewithargsret{int \bfcode{\_\_i2c\_transfer}}{struct i2c\_adapter *\emph{ adap}, struct i2c\_msg *\emph{ msgs}, int\emph{ num}}{}
unlocked flavor of i2c\_transfer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adap}}] \leavevmode
Handle to I2C bus

\item[{\code{struct i2c\_msg * msgs}}] \leavevmode
One or more messages to execute before STOP is issued to
terminate the operation; each message begins with a START.

\item[{\code{int num}}] \leavevmode
Number of messages to be executed.

\end{description}

\textbf{Description}

Returns negative errno, else the number of messages executed.

Adapter lock must be held when calling this function. No debug logging
takes place. adap-\textgreater{}algo-\textgreater{}master\_xfer existence isn't checked.
\index{i2c\_transfer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_transfer}\pysiglinewithargsret{int \bfcode{i2c\_transfer}}{struct i2c\_adapter *\emph{ adap}, struct i2c\_msg *\emph{ msgs}, int\emph{ num}}{}
execute a single or combined I2C message

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adap}}] \leavevmode
Handle to I2C bus

\item[{\code{struct i2c\_msg * msgs}}] \leavevmode
One or more messages to execute before STOP is issued to
terminate the operation; each message begins with a START.

\item[{\code{int num}}] \leavevmode
Number of messages to be executed.

\end{description}

\textbf{Description}

Returns negative errno, else the number of messages executed.

Note that there is no requirement that each message be sent to
the same slave address, although that is the most common model.
\index{i2c\_transfer\_buffer\_flags (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_transfer_buffer_flags}\pysiglinewithargsret{int \bfcode{i2c\_transfer\_buffer\_flags}}{const struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}, char *\emph{ buf}, int\emph{ count}, u16\emph{ flags}}{}
issue a single I2C message transferring data to/from a buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct i2c\_client * client}}] \leavevmode
Handle to slave device

\item[{\code{char * buf}}] \leavevmode
Where the data is stored

\item[{\code{int count}}] \leavevmode
How many bytes to transfer, must be less than 64k since msg.len is u16

\item[{\code{u16 flags}}] \leavevmode
The flags to be used for the message, e.g. I2C\_M\_RD for reads

\end{description}

\textbf{Description}

Returns negative errno, or else the number of bytes transferred.
\index{i2c\_get\_dma\_safe\_msg\_buf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_get_dma_safe_msg_buf}\pysiglinewithargsret{u8 * \bfcode{i2c\_get\_dma\_safe\_msg\_buf}}{struct i2c\_msg *\emph{ msg}, unsigned int\emph{ threshold}}{}
get a DMA safe buffer for the given i2c\_msg

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_msg * msg}}] \leavevmode
the message to be checked

\item[{\code{unsigned int threshold}}] \leavevmode
the minimum number of bytes for which using DMA makes sense

\end{description}

\textbf{Return}
\begin{description}
\item[{NULL if a DMA safe buffer was not obtained. Use msg-\textgreater{}buf with PIO.}] \leavevmode
Or a valid pointer to be used with DMA. After use, release it by
calling {\hyperref[driver\string-api/i2c:c.i2c_release_dma_safe_msg_buf]{\emph{\code{i2c\_release\_dma\_safe\_msg\_buf()}}}}.

\end{description}

This function must only be called from process context!
\index{i2c\_release\_dma\_safe\_msg\_buf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_release_dma_safe_msg_buf}\pysiglinewithargsret{void \bfcode{i2c\_release\_dma\_safe\_msg\_buf}}{struct i2c\_msg *\emph{ msg}, u8 *\emph{ buf}}{}
release DMA safe buffer and sync with i2c\_msg

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_msg * msg}}] \leavevmode
the message to be synced with

\item[{\code{u8 * buf}}] \leavevmode
the buffer obtained from {\hyperref[driver\string-api/i2c:c.i2c_get_dma_safe_msg_buf]{\emph{\code{i2c\_get\_dma\_safe\_msg\_buf()}}}}. May be NULL.

\end{description}
\index{i2c\_smbus\_read\_byte (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_smbus_read_byte}\pysiglinewithargsret{s32 \bfcode{i2c\_smbus\_read\_byte}}{const struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}}{}
SMBus ``receive byte'' protocol

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct i2c\_client * client}}] \leavevmode
Handle to slave device

\end{description}

\textbf{Description}

This executes the SMBus ``receive byte'' protocol, returning negative errno
else the byte received from the device.
\index{i2c\_smbus\_write\_byte (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_smbus_write_byte}\pysiglinewithargsret{s32 \bfcode{i2c\_smbus\_write\_byte}}{const struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}, u8\emph{ value}}{}
SMBus ``send byte'' protocol

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct i2c\_client * client}}] \leavevmode
Handle to slave device

\item[{\code{u8 value}}] \leavevmode
Byte to be sent

\end{description}

\textbf{Description}

This executes the SMBus ``send byte'' protocol, returning negative errno
else zero on success.
\index{i2c\_smbus\_read\_byte\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_smbus_read_byte_data}\pysiglinewithargsret{s32 \bfcode{i2c\_smbus\_read\_byte\_data}}{const struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}, u8\emph{ command}}{}
SMBus ``read byte'' protocol

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct i2c\_client * client}}] \leavevmode
Handle to slave device

\item[{\code{u8 command}}] \leavevmode
Byte interpreted by slave

\end{description}

\textbf{Description}

This executes the SMBus ``read byte'' protocol, returning negative errno
else a data byte received from the device.
\index{i2c\_smbus\_write\_byte\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_smbus_write_byte_data}\pysiglinewithargsret{s32 \bfcode{i2c\_smbus\_write\_byte\_data}}{const struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}, u8\emph{ command}, u8\emph{ value}}{}
SMBus ``write byte'' protocol

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct i2c\_client * client}}] \leavevmode
Handle to slave device

\item[{\code{u8 command}}] \leavevmode
Byte interpreted by slave

\item[{\code{u8 value}}] \leavevmode
Byte being written

\end{description}

\textbf{Description}

This executes the SMBus ``write byte'' protocol, returning negative errno
else zero on success.
\index{i2c\_smbus\_read\_word\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_smbus_read_word_data}\pysiglinewithargsret{s32 \bfcode{i2c\_smbus\_read\_word\_data}}{const struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}, u8\emph{ command}}{}
SMBus ``read word'' protocol

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct i2c\_client * client}}] \leavevmode
Handle to slave device

\item[{\code{u8 command}}] \leavevmode
Byte interpreted by slave

\end{description}

\textbf{Description}

This executes the SMBus ``read word'' protocol, returning negative errno
else a 16-bit unsigned ``word'' received from the device.
\index{i2c\_smbus\_write\_word\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_smbus_write_word_data}\pysiglinewithargsret{s32 \bfcode{i2c\_smbus\_write\_word\_data}}{const struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}, u8\emph{ command}, u16\emph{ value}}{}
SMBus ``write word'' protocol

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct i2c\_client * client}}] \leavevmode
Handle to slave device

\item[{\code{u8 command}}] \leavevmode
Byte interpreted by slave

\item[{\code{u16 value}}] \leavevmode
16-bit ``word'' being written

\end{description}

\textbf{Description}

This executes the SMBus ``write word'' protocol, returning negative errno
else zero on success.
\index{i2c\_smbus\_read\_block\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_smbus_read_block_data}\pysiglinewithargsret{s32 \bfcode{i2c\_smbus\_read\_block\_data}}{const struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}, u8\emph{ command}, u8 *\emph{ values}}{}
SMBus ``block read'' protocol

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct i2c\_client * client}}] \leavevmode
Handle to slave device

\item[{\code{u8 command}}] \leavevmode
Byte interpreted by slave

\item[{\code{u8 * values}}] \leavevmode
Byte array into which data will be read; big enough to hold
the data returned by the slave.  SMBus allows at most 32 bytes.

\end{description}

\textbf{Description}

This executes the SMBus ``block read'' protocol, returning negative errno
else the number of data bytes in the slave's response.

Note that using this function requires that the client's adapter support
the I2C\_FUNC\_SMBUS\_READ\_BLOCK\_DATA functionality.  Not all adapter drivers
support this; its emulation through I2C messaging relies on a specific
mechanism (I2C\_M\_RECV\_LEN) which may not be implemented.
\index{i2c\_smbus\_write\_block\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_smbus_write_block_data}\pysiglinewithargsret{s32 \bfcode{i2c\_smbus\_write\_block\_data}}{const struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}, u8\emph{ command}, u8\emph{ length}, const u8 *\emph{ values}}{}
SMBus ``block write'' protocol

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct i2c\_client * client}}] \leavevmode
Handle to slave device

\item[{\code{u8 command}}] \leavevmode
Byte interpreted by slave

\item[{\code{u8 length}}] \leavevmode
Size of data block; SMBus allows at most 32 bytes

\item[{\code{const u8 * values}}] \leavevmode
Byte array which will be written.

\end{description}

\textbf{Description}

This executes the SMBus ``block write'' protocol, returning negative errno
else zero on success.
\index{i2c\_smbus\_xfer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_smbus_xfer}\pysiglinewithargsret{s32 \bfcode{i2c\_smbus\_xfer}}{struct i2c\_adapter *\emph{ adapter}, u16\emph{ addr}, unsigned short\emph{ flags}, char\emph{ read\_write}, u8\emph{ command}, int\emph{ protocol}, union i2c\_smbus\_data *\emph{ data}}{}
execute SMBus protocol operations

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
Handle to I2C bus

\item[{\code{u16 addr}}] \leavevmode
Address of SMBus slave on that bus

\item[{\code{unsigned short flags}}] \leavevmode
I2C\_CLIENT\_* flags (usually zero or I2C\_CLIENT\_PEC)

\item[{\code{char read\_write}}] \leavevmode
I2C\_SMBUS\_READ or I2C\_SMBUS\_WRITE

\item[{\code{u8 command}}] \leavevmode
Byte interpreted by slave, for protocols which use such bytes

\item[{\code{int protocol}}] \leavevmode
SMBus protocol operation to execute, such as I2C\_SMBUS\_PROC\_CALL

\item[{\code{union i2c\_smbus\_data * data}}] \leavevmode
Data to be read or written

\end{description}

\textbf{Description}

This executes an SMBus protocol operation, and returns a negative
errno code else zero on success.
\index{i2c\_smbus\_read\_i2c\_block\_data\_or\_emulated (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_smbus_read_i2c_block_data_or_emulated}\pysiglinewithargsret{s32 \bfcode{i2c\_smbus\_read\_i2c\_block\_data\_or\_emulated}}{const struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} *\emph{ client}, u8\emph{ command}, u8\emph{ length}, u8 *\emph{ values}}{}
read block or emulate

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct i2c\_client * client}}] \leavevmode
Handle to slave device

\item[{\code{u8 command}}] \leavevmode
Byte interpreted by slave

\item[{\code{u8 length}}] \leavevmode
Size of data block; SMBus allows at most I2C\_SMBUS\_BLOCK\_MAX bytes

\item[{\code{u8 * values}}] \leavevmode
Byte array into which data will be read; big enough to hold
the data returned by the slave.  SMBus allows at most
I2C\_SMBUS\_BLOCK\_MAX bytes.

\end{description}

\textbf{Description}

This executes the SMBus ``block read'' protocol if supported by the adapter.
If block read is not supported, it emulates it using either word or byte
read protocols depending on availability.

The addresses of the I2C slave device that are accessed with this function
must be mapped to a linear region, so that a block read will have the same
effect as a byte read. Before using this function you must double-check
if the I2C slave does support exchanging a block transfer with a byte
transfer.
\index{i2c\_setup\_smbus\_alert (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/i2c:c.i2c_setup_smbus_alert}\pysiglinewithargsret{struct {\hyperref[driver\string-api/i2c:c.i2c_client]{\emph{i2c\_client}}} * \bfcode{i2c\_setup\_smbus\_alert}}{struct i2c\_adapter *\emph{ adapter}, struct i2c\_smbus\_alert\_setup *\emph{ setup}}{}
Setup SMBus alert support

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct i2c\_adapter * adapter}}] \leavevmode
the target adapter

\item[{\code{struct i2c\_smbus\_alert\_setup * setup}}] \leavevmode
setup data for the SMBus alert handler

\end{description}

\textbf{Context}

can sleep

\textbf{Description}

Setup handling of the SMBus alert protocol on a given I2C bus segment.

Handling can be done either through our IRQ handler, or by the
adapter (from its handler, periodic polling, or whatever).

NOTE that if we manage the IRQ, we \emph{MUST} know if it's level or
edge triggered in order to hand it to the workqueue correctly.
If triggering the alert seems to wedge the system, you probably
should have said it's level triggered.

This returns the ara client, which should be saved for later use with
\code{i2c\_handle\_smbus\_alert()} and ultimately {\hyperref[driver\string-api/i2c:c.i2c_unregister_device]{\emph{\code{i2c\_unregister\_device()}}}}; or NULL
to indicate an error.


\chapter{High Speed Synchronous Serial Interface (HSI)}
\label{driver-api/hsi:high-speed-synchronous-serial-interface-hsi}\label{driver-api/hsi::doc}

\section{Introduction}
\label{driver-api/hsi:introduction}
High Speed Syncronous Interface (HSI) is a fullduplex, low latency protocol,
that is optimized for die-level interconnect between an Application Processor
and a Baseband chipset. It has been specified by the MIPI alliance in 2003 and
implemented by multiple vendors since then.

The HSI interface supports full duplex communication over multiple channels
(typically 8) and is capable of reaching speeds up to 200 Mbit/s.

The serial protocol uses two signals, DATA and FLAG as combined data and clock
signals and an additional READY signal for flow control. An additional WAKE
signal can be used to wakeup the chips from standby modes. The signals are
commonly prefixed by AC for signals going from the application die to the
cellular die and CA for signals going the other way around.

\begin{Verbatim}[commandchars=\\\{\}]
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+                                 +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\textbar{}  Cellular  \textbar{}                                 \textbar{}  Application  \textbar{}
\textbar{}    Die     \textbar{}                                 \textbar{}      Die      \textbar{}
\textbar{}            \textbar{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} CAWAKE \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZgt{}\textbar{}               \textbar{}
\textbar{}           T\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} CADATA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}\textbar{}R              \textbar{}
\textbar{}           X\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} CAFLAG \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}\textbar{}X              \textbar{}
\textbar{}            \textbar{}\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ACREADY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}               \textbar{}
\textbar{}            \textbar{}                                 \textbar{}               \textbar{}
\textbar{}            \textbar{}                                 \textbar{}               \textbar{}
\textbar{}            \textbar{}\PYGZlt{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{}  ACWAKE \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{}\textbar{}               \textbar{}
\textbar{}           R\textbar{}\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ACDATA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}T              \textbar{}
\textbar{}           X\textbar{}\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ACFLAG \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}X              \textbar{}
\textbar{}            \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} CAREADY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}\textbar{}               \textbar{}
\textbar{}            \textbar{}                                 \textbar{}               \textbar{}
\textbar{}            \textbar{}                                 \textbar{}               \textbar{}
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+                                 +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{Verbatim}


\section{HSI Subsystem in Linux}
\label{driver-api/hsi:hsi-subsystem-in-linux}
In the Linux kernel the hsi subsystem is supposed to be used for HSI devices.
The hsi subsystem contains drivers for hsi controllers including support for
multi-port controllers and provides a generic API for using the HSI ports.

It also contains HSI client drivers, which make use of the generic API to
implement a protocol used on the HSI interface. These client drivers can
use an arbitrary number of channels.


\section{hsi-char Device}
\label{driver-api/hsi:hsi-char-device}
Each port automatically registers a generic client driver called hsi\_char,
which provides a charecter device for userspace representing the HSI port.
It can be used to communicate via HSI from userspace. Userspace may
configure the hsi\_char device using the following ioctl commands:
\begin{description}
\item[{HSC\_RESET}] \leavevmode
flush the HSI port

\item[{HSC\_SET\_PM}] \leavevmode
enable or disable the client.

\item[{HSC\_SEND\_BREAK}] \leavevmode
send break

\item[{HSC\_SET\_RX}] \leavevmode
set RX configuration

\item[{HSC\_GET\_RX}] \leavevmode
get RX configuration

\item[{HSC\_SET\_TX}] \leavevmode
set TX configuration

\item[{HSC\_GET\_TX}] \leavevmode
get TX configuration

\end{description}


\section{The kernel HSI API}
\label{driver-api/hsi:the-kernel-hsi-api}\index{hsi\_channel (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_channel}\pysigline{struct \bfcode{hsi\_channel}}
channel resource used by the hsi clients

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct hsi\PYGZus{}channel \PYGZob{}
  unsigned int    id;
  const char      *name;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{id}}] \leavevmode
Channel number

\item[{\code{name}}] \leavevmode
Channel name

\end{description}
\index{hsi\_config (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_config}\pysigline{struct \bfcode{hsi\_config}}
Configuration for RX/TX HSI modules

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct hsi\PYGZus{}config \PYGZob{}
  unsigned int            mode;
  struct hsi\PYGZus{}channel      *channels;
  unsigned int            num\PYGZus{}channels;
  unsigned int            num\PYGZus{}hw\PYGZus{}channels;
  unsigned int            speed;
  union \PYGZob{}
    unsigned int    flow;
    unsigned int    arb\PYGZus{}mode;
  \PYGZcb{};
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{mode}}] \leavevmode
Bit transmission mode (STREAM or FRAME)

\item[{\code{channels}}] \leavevmode
Channel resources used by the client

\item[{\code{num\_channels}}] \leavevmode
Number of channel resources

\item[{\code{num\_hw\_channels}}] \leavevmode
Number of channels the transceiver is configured for {[}1..16{]}

\item[{\code{speed}}] \leavevmode
Max bit transmission speed (Kbit/s)

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{flow}}] \leavevmode
RX flow type (SYNCHRONIZED or PIPELINE)

\item[{\code{arb\_mode}}] \leavevmode
Arbitration mode for TX frame (Round robin, priority)

\end{description}
\index{hsi\_board\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_board_info}\pysigline{struct \bfcode{hsi\_board\_info}}
HSI client board info

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct hsi\PYGZus{}board\PYGZus{}info \PYGZob{}
  const char              *name;
  unsigned int            hsi\PYGZus{}id;
  unsigned int            port;
  struct hsi\PYGZus{}config       tx\PYGZus{}cfg;
  struct hsi\PYGZus{}config       rx\PYGZus{}cfg;
  void *platform\PYGZus{}data;
  struct dev\PYGZus{}archdata     *archdata;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
Name for the HSI device

\item[{\code{hsi\_id}}] \leavevmode
HSI controller id where the client sits

\item[{\code{port}}] \leavevmode
Port number in the controller where the client sits

\item[{\code{tx\_cfg}}] \leavevmode
HSI TX configuration

\item[{\code{rx\_cfg}}] \leavevmode
HSI RX configuration

\item[{\code{platform\_data}}] \leavevmode
Platform related data

\item[{\code{archdata}}] \leavevmode
Architecture-dependent device data

\end{description}
\index{hsi\_client (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_client}\pysigline{struct \bfcode{hsi\_client}}
HSI client attached to an HSI port

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct hsi\PYGZus{}client \PYGZob{}
  struct device           device;
  struct hsi\PYGZus{}config       tx\PYGZus{}cfg;
  struct hsi\PYGZus{}config       rx\PYGZus{}cfg;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{device}}] \leavevmode
Driver model representation of the device

\item[{\code{tx\_cfg}}] \leavevmode
HSI TX configuration

\item[{\code{rx\_cfg}}] \leavevmode
HSI RX configuration

\end{description}
\index{hsi\_client\_driver (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_client_driver}\pysigline{struct \bfcode{hsi\_client\_driver}}
Driver associated to an HSI client

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct hsi\PYGZus{}client\PYGZus{}driver \PYGZob{}
  struct device\PYGZus{}driver    driver;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{driver}}] \leavevmode
Driver model representation of the driver

\end{description}
\index{hsi\_msg (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_msg}\pysigline{struct \bfcode{hsi\_msg}}
HSI message descriptor

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct hsi\PYGZus{}msg \PYGZob{}
  struct list\PYGZus{}head        link;
  struct hsi\PYGZus{}client       *cl;
  struct sg\PYGZus{}table         sgt;
  void *context;
  void (*complete)(struct hsi\PYGZus{}msg *msg);
  void (*destructor)(struct hsi\PYGZus{}msg *msg);
  int status;
  unsigned int            actual\PYGZus{}len;
  unsigned int            channel;
  unsigned int            ttype:1;
  unsigned int            break\PYGZus{}frame:1;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{link}}] \leavevmode
Free to use by the current descriptor owner

\item[{\code{cl}}] \leavevmode
HSI device client that issues the transfer

\item[{\code{sgt}}] \leavevmode
Head of the scatterlist array

\item[{\code{context}}] \leavevmode
Client context data associated to the transfer

\item[{\code{complete}}] \leavevmode
Transfer completion callback

\item[{\code{destructor}}] \leavevmode
Destructor to free resources when flushing

\item[{\code{status}}] \leavevmode
Status of the transfer when completed

\item[{\code{actual\_len}}] \leavevmode
Actual length of data transferred on completion

\item[{\code{channel}}] \leavevmode
Channel were to TX/RX the message

\item[{\code{ttype}}] \leavevmode
Transfer type (TX if set, RX otherwise)

\item[{\code{break\_frame}}] \leavevmode
if true HSI will send/receive a break frame. Data buffers are
ignored in the request.

\end{description}
\index{hsi\_port (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_port}\pysigline{struct \bfcode{hsi\_port}}
HSI port device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct hsi\PYGZus{}port \PYGZob{}
  struct device                   device;
  struct hsi\PYGZus{}config               tx\PYGZus{}cfg;
  struct hsi\PYGZus{}config               rx\PYGZus{}cfg;
  unsigned int                    num;
  unsigned int                    shared:1;
  int claimed;
  struct mutex                    lock;
  int (*async)(struct hsi\PYGZus{}msg *msg);
  int (*setup)(struct hsi\PYGZus{}client *cl);
  int (*flush)(struct hsi\PYGZus{}client *cl);
  int (*start\PYGZus{}tx)(struct hsi\PYGZus{}client *cl);
  int (*stop\PYGZus{}tx)(struct hsi\PYGZus{}client *cl);
  int (*release)(struct hsi\PYGZus{}client *cl);
  struct blocking\PYGZus{}notifier\PYGZus{}head   n\PYGZus{}head;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{device}}] \leavevmode
Driver model representation of the device

\item[{\code{tx\_cfg}}] \leavevmode
Current TX path configuration

\item[{\code{rx\_cfg}}] \leavevmode
Current RX path configuration

\item[{\code{num}}] \leavevmode
Port number

\item[{\code{shared}}] \leavevmode
Set when port can be shared by different clients

\item[{\code{claimed}}] \leavevmode
Reference count of clients which claimed the port

\item[{\code{lock}}] \leavevmode
Serialize port claim

\item[{\code{async}}] \leavevmode
Asynchronous transfer callback

\item[{\code{setup}}] \leavevmode
Callback to set the HSI client configuration

\item[{\code{flush}}] \leavevmode
Callback to clean the HW state and destroy all pending transfers

\item[{\code{start\_tx}}] \leavevmode
Callback to inform that a client wants to TX data

\item[{\code{stop\_tx}}] \leavevmode
Callback to inform that a client no longer wishes to TX data

\item[{\code{release}}] \leavevmode
Callback to inform that a client no longer uses the port

\item[{\code{n\_head}}] \leavevmode
Notifier chain for signaling port events to the clients.

\end{description}
\index{hsi\_controller (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_controller}\pysigline{struct \bfcode{hsi\_controller}}
HSI controller device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct hsi\PYGZus{}controller \PYGZob{}
  struct device           device;
  struct module           *owner;
  unsigned int            id;
  unsigned int            num\PYGZus{}ports;
  struct hsi\PYGZus{}port         **port;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{device}}] \leavevmode
Driver model representation of the device

\item[{\code{owner}}] \leavevmode
Pointer to the module owning the controller

\item[{\code{id}}] \leavevmode
HSI controller ID

\item[{\code{num\_ports}}] \leavevmode
Number of ports in the HSI controller

\item[{\code{port}}] \leavevmode
Array of HSI ports

\end{description}
\index{hsi\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_id}\pysiglinewithargsret{unsigned int \bfcode{hsi\_id}}{struct {\hyperref[driver\string-api/hsi:c.hsi_client]{\emph{hsi\_client}}} *\emph{ cl}}{}
Get HSI controller ID associated to a client

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_client * cl}}] \leavevmode
Pointer to a HSI client

\end{description}

\textbf{Description}

Return the controller id where the client is attached to
\index{hsi\_port\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_port_id}\pysiglinewithargsret{unsigned int \bfcode{hsi\_port\_id}}{struct {\hyperref[driver\string-api/hsi:c.hsi_client]{\emph{hsi\_client}}} *\emph{ cl}}{}
Gets the port number a client is attached to

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_client * cl}}] \leavevmode
Pointer to HSI client

\end{description}

\textbf{Description}

Return the port number associated to the client
\index{hsi\_setup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_setup}\pysiglinewithargsret{int \bfcode{hsi\_setup}}{struct {\hyperref[driver\string-api/hsi:c.hsi_client]{\emph{hsi\_client}}} *\emph{ cl}}{}
Configure the client's port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_client * cl}}] \leavevmode
Pointer to the HSI client

\end{description}

\textbf{Description}

When sharing ports, clients should either relay on a single
client setup or have the same setup for all of them.

Return -errno on failure, 0 on success
\index{hsi\_flush (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_flush}\pysiglinewithargsret{int \bfcode{hsi\_flush}}{struct {\hyperref[driver\string-api/hsi:c.hsi_client]{\emph{hsi\_client}}} *\emph{ cl}}{}
Flush all pending transactions on the client's port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_client * cl}}] \leavevmode
Pointer to the HSI client

\end{description}

\textbf{Description}

This function will destroy all pending hsi\_msg in the port and reset
the HW port so it is ready to receive and transmit from a clean state.

Return -errno on failure, 0 on success
\index{hsi\_async\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_async_read}\pysiglinewithargsret{int \bfcode{hsi\_async\_read}}{struct {\hyperref[driver\string-api/hsi:c.hsi_client]{\emph{hsi\_client}}} *\emph{ cl}, struct {\hyperref[driver\string-api/hsi:c.hsi_msg]{\emph{hsi\_msg}}} *\emph{ msg}}{}
Submit a read transfer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_client * cl}}] \leavevmode
Pointer to the HSI client

\item[{\code{struct hsi\_msg * msg}}] \leavevmode
HSI message descriptor of the transfer

\end{description}

\textbf{Description}

Return -errno on failure, 0 on success
\index{hsi\_async\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_async_write}\pysiglinewithargsret{int \bfcode{hsi\_async\_write}}{struct {\hyperref[driver\string-api/hsi:c.hsi_client]{\emph{hsi\_client}}} *\emph{ cl}, struct {\hyperref[driver\string-api/hsi:c.hsi_msg]{\emph{hsi\_msg}}} *\emph{ msg}}{}
Submit a write transfer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_client * cl}}] \leavevmode
Pointer to the HSI client

\item[{\code{struct hsi\_msg * msg}}] \leavevmode
HSI message descriptor of the transfer

\end{description}

\textbf{Description}

Return -errno on failure, 0 on success
\index{hsi\_start\_tx (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_start_tx}\pysiglinewithargsret{int \bfcode{hsi\_start\_tx}}{struct {\hyperref[driver\string-api/hsi:c.hsi_client]{\emph{hsi\_client}}} *\emph{ cl}}{}
Signal the port that the client wants to start a TX

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_client * cl}}] \leavevmode
Pointer to the HSI client

\end{description}

\textbf{Description}

Return -errno on failure, 0 on success
\index{hsi\_stop\_tx (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_stop_tx}\pysiglinewithargsret{int \bfcode{hsi\_stop\_tx}}{struct {\hyperref[driver\string-api/hsi:c.hsi_client]{\emph{hsi\_client}}} *\emph{ cl}}{}
Signal the port that the client no longer wants to transmit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_client * cl}}] \leavevmode
Pointer to the HSI client

\end{description}

\textbf{Description}

Return -errno on failure, 0 on success
\index{hsi\_port\_unregister\_clients (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_port_unregister_clients}\pysiglinewithargsret{void \bfcode{hsi\_port\_unregister\_clients}}{struct {\hyperref[driver\string-api/hsi:c.hsi_port]{\emph{hsi\_port}}} *\emph{ port}}{}
Unregister an HSI port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_port * port}}] \leavevmode
The HSI port to unregister

\end{description}
\index{hsi\_unregister\_controller (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_unregister_controller}\pysiglinewithargsret{void \bfcode{hsi\_unregister\_controller}}{struct {\hyperref[driver\string-api/hsi:c.hsi_controller]{\emph{hsi\_controller}}} *\emph{ hsi}}{}
Unregister an HSI controller

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_controller * hsi}}] \leavevmode
The HSI controller to register

\end{description}
\index{hsi\_register\_controller (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_register_controller}\pysiglinewithargsret{int \bfcode{hsi\_register\_controller}}{struct {\hyperref[driver\string-api/hsi:c.hsi_controller]{\emph{hsi\_controller}}} *\emph{ hsi}}{}
Register an HSI controller and its ports

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_controller * hsi}}] \leavevmode
The HSI controller to register

\end{description}

\textbf{Description}

Returns -errno on failure, 0 on success.
\index{hsi\_register\_client\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_register_client_driver}\pysiglinewithargsret{int \bfcode{hsi\_register\_client\_driver}}{struct {\hyperref[driver\string-api/hsi:c.hsi_client_driver]{\emph{hsi\_client\_driver}}} *\emph{ drv}}{}
Register an HSI client to the HSI bus

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_client\_driver * drv}}] \leavevmode
HSI client driver to register

\end{description}

\textbf{Description}

Returns -errno on failure, 0 on success.
\index{hsi\_put\_controller (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_put_controller}\pysiglinewithargsret{void \bfcode{hsi\_put\_controller}}{struct {\hyperref[driver\string-api/hsi:c.hsi_controller]{\emph{hsi\_controller}}} *\emph{ hsi}}{}
Free an HSI controller

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_controller * hsi}}] \leavevmode
Pointer to the HSI controller to freed

\end{description}

\textbf{Description}

HSI controller drivers should only use this function if they need
to free their allocated hsi\_controller structures before a successful
call to hsi\_register\_controller. Other use is not allowed.
\index{hsi\_alloc\_controller (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_alloc_controller}\pysiglinewithargsret{struct {\hyperref[driver\string-api/hsi:c.hsi_controller]{\emph{hsi\_controller}}} * \bfcode{hsi\_alloc\_controller}}{unsigned int\emph{ n\_ports}, gfp\_t\emph{ flags}}{}
Allocate an HSI controller and its ports

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int n\_ports}}] \leavevmode
Number of ports on the HSI controller

\item[{\code{gfp\_t flags}}] \leavevmode
Kernel allocation flags

\end{description}

\textbf{Description}

Return NULL on failure or a pointer to an hsi\_controller on success.
\index{hsi\_free\_msg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_free_msg}\pysiglinewithargsret{void \bfcode{hsi\_free\_msg}}{struct {\hyperref[driver\string-api/hsi:c.hsi_msg]{\emph{hsi\_msg}}} *\emph{ msg}}{}
Free an HSI message

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_msg * msg}}] \leavevmode
Pointer to the HSI message

\end{description}

\textbf{Description}

Client is responsible to free the buffers pointed by the scatterlists.
\index{hsi\_alloc\_msg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_alloc_msg}\pysiglinewithargsret{struct {\hyperref[driver\string-api/hsi:c.hsi_msg]{\emph{hsi\_msg}}} * \bfcode{hsi\_alloc\_msg}}{unsigned int\emph{ nents}, gfp\_t\emph{ flags}}{}
Allocate an HSI message

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int nents}}] \leavevmode
Number of memory entries

\item[{\code{gfp\_t flags}}] \leavevmode
Kernel allocation flags

\end{description}

\textbf{Description}

nents can be 0. This mainly makes sense for read transfer.
In that case, HSI drivers will call the complete callback when
there is data to be read without consuming it.

Return NULL on failure or a pointer to an hsi\_msg on success.
\index{hsi\_async (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_async}\pysiglinewithargsret{int \bfcode{hsi\_async}}{struct {\hyperref[driver\string-api/hsi:c.hsi_client]{\emph{hsi\_client}}} *\emph{ cl}, struct {\hyperref[driver\string-api/hsi:c.hsi_msg]{\emph{hsi\_msg}}} *\emph{ msg}}{}
Submit an HSI transfer to the controller

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_client * cl}}] \leavevmode
HSI client sending the transfer

\item[{\code{struct hsi\_msg * msg}}] \leavevmode
The HSI transfer passed to controller

\end{description}

\textbf{Description}

The HSI message must have the channel, ttype, complete and destructor
fields set beforehand. If nents \textgreater{} 0 then the client has to initialize
also the scatterlists to point to the buffers to write to or read from.

HSI controllers relay on pre-allocated buffers from their clients and they
do not allocate buffers on their own.

Once the HSI message transfer finishes, the HSI controller calls the
complete callback with the status and actual\_len fields of the HSI message
updated. The complete callback can be called before returning from
hsi\_async.

Returns -errno on failure or 0 on success
\index{hsi\_claim\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_claim_port}\pysiglinewithargsret{int \bfcode{hsi\_claim\_port}}{struct {\hyperref[driver\string-api/hsi:c.hsi_client]{\emph{hsi\_client}}} *\emph{ cl}, unsigned int\emph{ share}}{}
Claim the HSI client's port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_client * cl}}] \leavevmode
HSI client that wants to claim its port

\item[{\code{unsigned int share}}] \leavevmode
Flag to indicate if the client wants to share the port or not.

\end{description}

\textbf{Description}

Returns -errno on failure, 0 on success.
\index{hsi\_release\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_release_port}\pysiglinewithargsret{void \bfcode{hsi\_release\_port}}{struct {\hyperref[driver\string-api/hsi:c.hsi_client]{\emph{hsi\_client}}} *\emph{ cl}}{}
Release the HSI client's port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_client * cl}}] \leavevmode
HSI client which previously claimed its port

\end{description}
\index{hsi\_register\_port\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_register_port_event}\pysiglinewithargsret{int \bfcode{hsi\_register\_port\_event}}{struct {\hyperref[driver\string-api/hsi:c.hsi_client]{\emph{hsi\_client}}} *\emph{ cl}, void (*handler) (struct {\hyperref[driver\string-api/hsi:c.hsi_client]{\emph{hsi\_client}}}\emph{ *}, unsigned\emph{ long}}{}
Register a client to receive port events

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_client * cl}}] \leavevmode
HSI client that wants to receive port events

\item[{\code{void (*)(struct hsi\_client *, unsigned long) handler}}] \leavevmode
Event handler callback

\end{description}

\textbf{Description}

Clients should register a callback to be able to receive
events from the ports. Registration should happen after
claiming the port.
The handler can be called in interrupt context.

Returns -errno on error, or 0 on success.
\index{hsi\_unregister\_port\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_unregister_port_event}\pysiglinewithargsret{int \bfcode{hsi\_unregister\_port\_event}}{struct {\hyperref[driver\string-api/hsi:c.hsi_client]{\emph{hsi\_client}}} *\emph{ cl}}{}
Stop receiving port events for a client

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_client * cl}}] \leavevmode
HSI client that wants to stop receiving port events

\end{description}

\textbf{Description}

Clients should call this function before releasing their associated
port.

Returns -errno on error, or 0 on success.
\index{hsi\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_event}\pysiglinewithargsret{int \bfcode{hsi\_event}}{struct {\hyperref[driver\string-api/hsi:c.hsi_port]{\emph{hsi\_port}}} *\emph{ port}, unsigned long\emph{ event}}{}
Notifies clients about port events

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_port * port}}] \leavevmode
Port where the event occurred

\item[{\code{unsigned long event}}] \leavevmode
The event type

\end{description}

\textbf{Description}

Clients should not be concerned about wake line behavior. However, due
to a race condition in HSI HW protocol, clients need to be notified
about wake line changes, so they can implement a workaround for it.

Events:
HSI\_EVENT\_START\_RX - Incoming wake line high
HSI\_EVENT\_STOP\_RX - Incoming wake line down

Returns -errno on error, or 0 on success.
\index{hsi\_get\_channel\_id\_by\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/hsi:c.hsi_get_channel_id_by_name}\pysiglinewithargsret{int \bfcode{hsi\_get\_channel\_id\_by\_name}}{struct {\hyperref[driver\string-api/hsi:c.hsi_client]{\emph{hsi\_client}}} *\emph{ cl}, char *\emph{ name}}{}
acquire channel id by channel name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hsi\_client * cl}}] \leavevmode
HSI client, which uses the channel

\item[{\code{char * name}}] \leavevmode
name the channel is known under

\end{description}

\textbf{Description}

Clients can call this function to get the hsi channel ids similar to
requesting IRQs or GPIOs by name. This function assumes the same
channel configuration is used for RX and TX.

Returns -errno on error or channel id on success.


\chapter{Error Detection And Correction (EDAC) Devices}
\label{driver-api/edac:error-detection-and-correction-edac-devices}\label{driver-api/edac::doc}

\section{Main Concepts used at the EDAC subsystem}
\label{driver-api/edac:main-concepts-used-at-the-edac-subsystem}
There are several things to be aware of that aren't at all obvious, like
\emph{sockets, *socket sets}, \emph{banks}, \emph{rows}, \emph{chip-select rows}, \emph{channels},
etc...

These are some of the many terms that are thrown about that don't always
mean what people think they mean (Inconceivable!).  In the interest of
creating a common ground for discussion, terms and their definitions
will be established.
\begin{itemize}
\item {} 
Memory devices

\end{itemize}

The individual DRAM chips on a memory stick.  These devices commonly
output 4 and 8 bits each (x4, x8). Grouping several of these in parallel
provides the number of bits that the memory controller expects:
typically 72 bits, in order to provide 64 bits + 8 bits of ECC data.
\begin{itemize}
\item {} 
Memory Stick

\end{itemize}

A printed circuit board that aggregates multiple memory devices in
parallel.  In general, this is the Field Replaceable Unit (FRU) which
gets replaced, in the case of excessive errors. Most often it is also
called DIMM (Dual Inline Memory Module).
\begin{itemize}
\item {} 
Memory Socket

\end{itemize}

A physical connector on the motherboard that accepts a single memory
stick. Also called as ``slot'' on several datasheets.
\begin{itemize}
\item {} 
Channel

\end{itemize}

A memory controller channel, responsible to communicate with a group of
DIMMs. Each channel has its own independent control (command) and data
bus, and can be used independently or grouped with other channels.
\begin{itemize}
\item {} 
Branch

\end{itemize}

It is typically the highest hierarchy on a Fully-Buffered DIMM memory
controller. Typically, it contains two channels. Two channels at the
same branch can be used in single mode or in lockstep mode. When
lockstep is enabled, the cacheline is doubled, but it generally brings
some performance penalty. Also, it is generally not possible to point to
just one memory stick when an error occurs, as the error correction code
is calculated using two DIMMs instead of one. Due to that, it is capable
of correcting more errors than on single mode.
\begin{itemize}
\item {} 
Single-channel

\end{itemize}

The data accessed by the memory controller is contained into one dimm
only. E. g. if the data is 64 bits-wide, the data flows to the CPU using
one 64 bits parallel access. Typically used with SDR, DDR, DDR2 and DDR3
memories. FB-DIMM and RAMBUS use a different concept for channel, so
this concept doesn't apply there.
\begin{itemize}
\item {} 
Double-channel

\end{itemize}

The data size accessed by the memory controller is interlaced into two
dimms, accessed at the same time. E. g. if the DIMM is 64 bits-wide (72
bits with ECC), the data flows to the CPU using a 128 bits parallel
access.
\begin{itemize}
\item {} 
Chip-select row

\end{itemize}

This is the name of the DRAM signal used to select the DRAM ranks to be
accessed. Common chip-select rows for single channel are 64 bits, for
dual channel 128 bits. It may not be visible by the memory controller,
as some DIMM types have a memory buffer that can hide direct access to
it from the Memory Controller.
\begin{itemize}
\item {} 
Single-Ranked stick

\end{itemize}

A Single-ranked stick has 1 chip-select row of memory. Motherboards
commonly drive two chip-select pins to a memory stick. A single-ranked
stick, will occupy only one of those rows. The other will be unused.
\phantomsection\label{driver-api/edac:doubleranked}\begin{itemize}
\item {} 
Double-Ranked stick

\end{itemize}

A double-ranked stick has two chip-select rows which access different
sets of memory devices.  The two rows cannot be accessed concurrently.
\begin{itemize}
\item {} 
Double-sided stick

\end{itemize}

\textbf{DEPRECATED TERM}, see {\hyperref[driver\string-api/edac:doubleranked]{\emph{Double-Ranked stick}}}.

A double-sided stick has two chip-select rows which access different sets
of memory devices. The two rows cannot be accessed concurrently.
``Double-sided'' is irrespective of the memory devices being mounted on
both sides of the memory stick.
\begin{itemize}
\item {} 
Socket set

\end{itemize}

All of the memory sticks that are required for a single memory access or
all of the memory sticks spanned by a chip-select row.  A single socket
set has two chip-select rows and if double-sided sticks are used these
will occupy those chip-select rows.
\begin{itemize}
\item {} 
Bank

\end{itemize}

This term is avoided because it is unclear when needing to distinguish
between chip-select rows and socket sets.


\section{Memory Controllers}
\label{driver-api/edac:memory-controllers}
Most of the EDAC core is focused on doing Memory Controller error detection.
The {\hyperref[driver\string-api/edac:c.edac_mc_alloc]{\emph{\code{edac\_mc\_alloc()}}}}. It uses internally the struct \code{mem\_ctl\_info}
to describe the memory controllers, with is an opaque struct for the EDAC
drivers. Only the EDAC core is allowed to touch it.
\index{dev\_type (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.dev_type}\pysigline{enum \bfcode{dev\_type}}
describe the type of memory DRAM chips used at the stick

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{DEV\_UNKNOWN}}] \leavevmode
Can't be determined, or MC doesn't support detect it

\item[{\code{DEV\_X1}}] \leavevmode
1 bit for data

\item[{\code{DEV\_X2}}] \leavevmode
2 bits for data

\item[{\code{DEV\_X4}}] \leavevmode
4 bits for data

\item[{\code{DEV\_X8}}] \leavevmode
8 bits for data

\item[{\code{DEV\_X16}}] \leavevmode
16 bits for data

\item[{\code{DEV\_X32}}] \leavevmode
32 bits for data

\item[{\code{DEV\_X64}}] \leavevmode
64 bits for data

\end{description}

\textbf{Description}

Typical values are x4 and x8.
\index{hw\_event\_mc\_err\_type (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.hw_event_mc_err_type}\pysigline{enum \bfcode{hw\_event\_mc\_err\_type}}
type of the detected error

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{HW\_EVENT\_ERR\_CORRECTED}}] \leavevmode
Corrected Error - Indicates that an ECC
corrected error was detected

\item[{\code{HW\_EVENT\_ERR\_UNCORRECTED}}] \leavevmode
Uncorrected Error - Indicates an error that
can't be corrected by ECC, but it is not
fatal (maybe it is on an unused memory area,
or the memory controller could recover from
it for example, by re-trying the operation).

\item[{\code{HW\_EVENT\_ERR\_DEFERRED}}] \leavevmode
Deferred Error - Indicates an uncorrectable
error whose handling is not urgent. This could
be due to hardware data poisoning where the
system can continue operation until the poisoned
data is consumed. Preemptive measures may also
be taken, e.g. offlining pages, etc.

\item[{\code{HW\_EVENT\_ERR\_FATAL}}] \leavevmode
Fatal Error - Uncorrected error that could not
be recovered.

\item[{\code{HW\_EVENT\_ERR\_INFO}}] \leavevmode
Informational - The CPER spec defines a forth
type of error: informational logs.

\end{description}
\index{mem\_type (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.mem_type}\pysigline{enum \bfcode{mem\_type}}
memory types. For a more detailed reference, please see \href{http://en.wikipedia.org/wiki/DRAM}{http://en.wikipedia.org/wiki/DRAM}

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{MEM\_EMPTY}}] \leavevmode
Empty csrow

\item[{\code{MEM\_RESERVED}}] \leavevmode
Reserved csrow type

\item[{\code{MEM\_UNKNOWN}}] \leavevmode
Unknown csrow type

\item[{\code{MEM\_FPM}}] \leavevmode
FPM - Fast Page Mode, used on systems up to 1995.

\item[{\code{MEM\_EDO}}] \leavevmode
EDO - Extended data out, used on systems up to 1998.

\item[{\code{MEM\_BEDO}}] \leavevmode
BEDO - Burst Extended data out, an EDO variant.

\item[{\code{MEM\_SDR}}] \leavevmode
SDR - Single data rate SDRAM
\href{http://en.wikipedia.org/wiki/Synchronous\_dynamic\_random-access\_memory}{http://en.wikipedia.org/wiki/Synchronous\_dynamic\_random-access\_memory}
They use 3 pins for chip select: Pins 0 and 2 are
for rank 0; pins 1 and 3 are for rank 1, if the memory
is dual-rank.

\item[{\code{MEM\_RDR}}] \leavevmode
Registered SDR SDRAM

\item[{\code{MEM\_DDR}}] \leavevmode
Double data rate SDRAM
\href{http://en.wikipedia.org/wiki/DDR\_SDRAM}{http://en.wikipedia.org/wiki/DDR\_SDRAM}

\item[{\code{MEM\_RDDR}}] \leavevmode
Registered Double data rate SDRAM
This is a variant of the DDR memories.
A registered memory has a buffer inside it, hiding
part of the memory details to the memory controller.

\item[{\code{MEM\_RMBS}}] \leavevmode
Rambus DRAM, used on a few Pentium III/IV controllers.

\item[{\code{MEM\_DDR2}}] \leavevmode
DDR2 RAM, as described at JEDEC JESD79-2F.
Those memories are labeled as ``PC2-'' instead of ``PC'' to
differentiate from DDR.

\item[{\code{MEM\_FB\_DDR2}}] \leavevmode
Fully-Buffered DDR2, as described at JEDEC Std No. 205
and JESD206.
Those memories are accessed per DIMM slot, and not by
a chip select signal.

\item[{\code{MEM\_RDDR2}}] \leavevmode
Registered DDR2 RAM
This is a variant of the DDR2 memories.

\item[{\code{MEM\_XDR}}] \leavevmode
Rambus XDR
It is an evolution of the original RAMBUS memories,
created to compete with DDR2. Weren't used on any
x86 arch, but cell\_edac PPC memory controller uses it.

\item[{\code{MEM\_DDR3}}] \leavevmode
DDR3 RAM

\item[{\code{MEM\_RDDR3}}] \leavevmode
Registered DDR3 RAM
This is a variant of the DDR3 memories.

\item[{\code{MEM\_LRDDR3}}] \leavevmode
Load-Reduced DDR3 memory.

\item[{\code{MEM\_DDR4}}] \leavevmode
Unbuffered DDR4 RAM

\item[{\code{MEM\_RDDR4}}] \leavevmode
Registered DDR4 RAM
This is a variant of the DDR4 memories.

\item[{\code{MEM\_LRDDR4}}] \leavevmode
Load-Reduced DDR4 memory.

\end{description}
\index{edac\_type (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_type}\pysigline{enum \bfcode{edac\_type}}
type - Error Detection and Correction capabilities and mode

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{EDAC\_UNKNOWN}}] \leavevmode
Unknown if ECC is available

\item[{\code{EDAC\_NONE}}] \leavevmode
Doesn't support ECC

\item[{\code{EDAC\_RESERVED}}] \leavevmode
Reserved ECC type

\item[{\code{EDAC\_PARITY}}] \leavevmode
Detects parity errors

\item[{\code{EDAC\_EC}}] \leavevmode
Error Checking - no correction

\item[{\code{EDAC\_SECDED}}] \leavevmode
Single bit error correction, Double detection

\item[{\code{EDAC\_S2ECD2ED}}] \leavevmode
Chipkill x2 devices - do these exist?

\item[{\code{EDAC\_S4ECD4ED}}] \leavevmode
Chipkill x4 devices

\item[{\code{EDAC\_S8ECD8ED}}] \leavevmode
Chipkill x8 devices

\item[{\code{EDAC\_S16ECD16ED}}] \leavevmode
Chipkill x16 devices

\end{description}
\index{scrub\_type (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.scrub_type}\pysigline{enum \bfcode{scrub\_type}}
scrubbing capabilities

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{SCRUB\_UNKNOWN}}] \leavevmode
Unknown if scrubber is available

\item[{\code{SCRUB\_NONE}}] \leavevmode
No scrubber

\item[{\code{SCRUB\_SW\_PROG}}] \leavevmode
SW progressive (sequential) scrubbing

\item[{\code{SCRUB\_SW\_SRC}}] \leavevmode
Software scrub only errors

\item[{\code{SCRUB\_SW\_PROG\_SRC}}] \leavevmode
Progressive software scrub from an error

\item[{\code{SCRUB\_SW\_TUNABLE}}] \leavevmode
Software scrub frequency is tunable

\item[{\code{SCRUB\_HW\_PROG}}] \leavevmode
HW progressive (sequential) scrubbing

\item[{\code{SCRUB\_HW\_SRC}}] \leavevmode
Hardware scrub only errors

\item[{\code{SCRUB\_HW\_PROG\_SRC}}] \leavevmode
Progressive hardware scrub from an error

\item[{\code{SCRUB\_HW\_TUNABLE}}] \leavevmode
Hardware scrub frequency is tunable

\end{description}
\index{edac\_mc\_layer\_type (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_mc_layer_type}\pysigline{enum \bfcode{edac\_mc\_layer\_type}}
memory controller hierarchy layer

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{EDAC\_MC\_LAYER\_BRANCH}}] \leavevmode
memory layer is named ``branch''

\item[{\code{EDAC\_MC\_LAYER\_CHANNEL}}] \leavevmode
memory layer is named ``channel''

\item[{\code{EDAC\_MC\_LAYER\_SLOT}}] \leavevmode
memory layer is named ``slot''

\item[{\code{EDAC\_MC\_LAYER\_CHIP\_SELECT}}] \leavevmode
memory layer is named ``chip select''

\item[{\code{EDAC\_MC\_LAYER\_ALL\_MEM}}] \leavevmode
memory layout is unknown. All memory is mapped
as a single memory area. This is used when
retrieving errors from a firmware driven driver.

\end{description}

\textbf{Description}

This enum is used by the drivers to tell edac\_mc\_sysfs what name should
be used when describing a memory stick location.
\index{edac\_mc\_layer (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_mc_layer}\pysigline{struct \bfcode{edac\_mc\_layer}}
describes the memory controller hierarchy

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct edac\PYGZus{}mc\PYGZus{}layer \PYGZob{}
  enum edac\PYGZus{}mc\PYGZus{}layer\PYGZus{}type type;
  unsigned size;
  bool is\PYGZus{}virt\PYGZus{}csrow;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{type}}] \leavevmode
layer type

\item[{\code{size}}] \leavevmode
number of components per layer. For example,
if the channel layer has two channels, size = 2

\item[{\code{is\_virt\_csrow}}] \leavevmode
This layer is part of the ``csrow'' when old API
compatibility mode is enabled. Otherwise, it is
a channel

\end{description}
\index{EDAC\_DIMM\_OFF (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.EDAC_DIMM_OFF}\pysiglinewithargsret{\bfcode{EDAC\_DIMM\_OFF}}{\emph{layers}, \emph{nlayers}, \emph{layer0}, \emph{layer1}, \emph{layer2}}{}
Macro responsible to get a pointer offset inside a pointer array for the element given by {[}layer0,layer1,layer2{]} position

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{layers}}] \leavevmode
a struct edac\_mc\_layer array, describing how many elements
were allocated for each layer

\item[{\code{nlayers}}] \leavevmode
Number of layers at the \textbf{layers} array

\item[{\code{layer0}}] \leavevmode
layer0 position

\item[{\code{layer1}}] \leavevmode
layer1 position. Unused if n\_layers \textless{} 2

\item[{\code{layer2}}] \leavevmode
layer2 position. Unused if n\_layers \textless{} 3

\end{description}

\textbf{Description}

For 1 layer, this macro returns ``var{[}layer0{]} - var'';

For 2 layers, this macro is similar to allocate a bi-dimensional array
and to return ``var{[}layer0{]}{[}layer1{]} - var'';

For 3 layers, this macro is similar to allocate a tri-dimensional array
and to return ``var{[}layer0{]}{[}layer1{]}{[}layer2{]} - var''.

A loop could be used here to make it more generic, but, as we only have
3 layers, this is a little faster.

By design, layers can never be 0 or more than 3. If that ever happens,
a NULL is returned, causing an OOPS during the memory allocation routine,
with would point to the developer that he's doing something wrong.
\index{EDAC\_DIMM\_PTR (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.EDAC_DIMM_PTR}\pysiglinewithargsret{\bfcode{EDAC\_DIMM\_PTR}}{\emph{layers}, \emph{var}, \emph{nlayers}, \emph{layer0}, \emph{layer1}, \emph{layer2}}{}
Macro responsible to get a pointer inside a pointer array for the element given by {[}layer0,layer1,layer2{]} position

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{layers}}] \leavevmode
a struct edac\_mc\_layer array, describing how many elements
were allocated for each layer

\item[{\code{var}}] \leavevmode
name of the var where we want to get the pointer
(like mci-\textgreater{}dimms)

\item[{\code{nlayers}}] \leavevmode
Number of layers at the \textbf{layers} array

\item[{\code{layer0}}] \leavevmode
layer0 position

\item[{\code{layer1}}] \leavevmode
layer1 position. Unused if n\_layers \textless{} 2

\item[{\code{layer2}}] \leavevmode
layer2 position. Unused if n\_layers \textless{} 3

\end{description}

\textbf{Description}

For 1 layer, this macro returns ``var{[}layer0{]}'';

For 2 layers, this macro is similar to allocate a bi-dimensional array
and to return ``var{[}layer0{]}{[}layer1{]}'';

For 3 layers, this macro is similar to allocate a tri-dimensional array
and to return ``var{[}layer0{]}{[}layer1{]}{[}layer2{]}'';
\index{rank\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.rank_info}\pysigline{struct \bfcode{rank\_info}}
contains the information for one DIMM rank

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct rank\PYGZus{}info \PYGZob{}
  int chan\PYGZus{}idx;
  struct csrow\PYGZus{}info *csrow;
  struct dimm\PYGZus{}info *dimm;
  u32 ce\PYGZus{}count;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{chan\_idx}}] \leavevmode
channel number where the rank is (typically, 0 or 1)

\item[{\code{csrow}}] \leavevmode
A pointer to the chip select row structure (the parent
structure). The location of the rank is given by
the (csrow-\textgreater{}csrow\_idx, chan\_idx) vector.

\item[{\code{dimm}}] \leavevmode
A pointer to the DIMM structure, where the DIMM label
information is stored.

\item[{\code{ce\_count}}] \leavevmode
number of correctable errors for this rank

\end{description}

\textbf{Description}
\begin{description}
\item[{FIXME: Currently, the EDAC core model will assume one DIMM per rank.}] \leavevmode
This is a bad assumption, but it makes this patch easier. Later
patches in this series will fix this issue.

\end{description}
\index{edac\_raw\_error\_desc (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_raw_error_desc}\pysigline{struct \bfcode{edac\_raw\_error\_desc}}
Raw error report structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct edac\PYGZus{}raw\PYGZus{}error\PYGZus{}desc \PYGZob{}
  char location[LOCATION\PYGZus{}SIZE];
  char label[(EDAC\PYGZus{}MC\PYGZus{}LABEL\PYGZus{}LEN + 1 + sizeof(OTHER\PYGZus{}LABEL)) * EDAC\PYGZus{}MAX\PYGZus{}LABELS];
  long grain;
  u16 error\PYGZus{}count;
  int top\PYGZus{}layer;
  int mid\PYGZus{}layer;
  int low\PYGZus{}layer;
  unsigned long page\PYGZus{}frame\PYGZus{}number;
  unsigned long offset\PYGZus{}in\PYGZus{}page;
  unsigned long syndrome;
  const char *msg;
  const char *other\PYGZus{}detail;
  bool enable\PYGZus{}per\PYGZus{}layer\PYGZus{}report;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{location}}] \leavevmode
location of the error

\item[{\code{label}}] \leavevmode
label of the affected DIMM(s)

\item[{\code{grain}}] \leavevmode
minimum granularity for an error report, in bytes

\item[{\code{error\_count}}] \leavevmode
number of errors of the same type

\item[{\code{top\_layer}}] \leavevmode
top layer of the error (layer{[}0{]})

\item[{\code{mid\_layer}}] \leavevmode
middle layer of the error (layer{[}1{]})

\item[{\code{low\_layer}}] \leavevmode
low layer of the error (layer{[}2{]})

\item[{\code{page\_frame\_number}}] \leavevmode
page where the error happened

\item[{\code{offset\_in\_page}}] \leavevmode
page offset

\item[{\code{syndrome}}] \leavevmode
syndrome of the error (or 0 if unknown or if
the syndrome is not applicable)

\item[{\code{msg}}] \leavevmode
error message

\item[{\code{other\_detail}}] \leavevmode
other driver-specific detail about the error

\item[{\code{enable\_per\_layer\_report}}] \leavevmode
if false, the error affects all layers
(typically, a memory controller error)

\end{description}
\index{edac\_mc\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_mc_alloc}\pysiglinewithargsret{struct mem\_ctl\_info * \bfcode{edac\_mc\_alloc}}{unsigned\emph{ mc\_num}, unsigned\emph{ n\_layers}, struct {\hyperref[driver\string-api/edac:c.edac_mc_layer]{\emph{edac\_mc\_layer}}} *\emph{ layers}, unsigned\emph{ sz\_pvt}}{}
Allocate and partially fill a struct \code{mem\_ctl\_info}.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned mc\_num}}] \leavevmode
Memory controller number

\item[{\code{unsigned n\_layers}}] \leavevmode
Number of MC hierarchy layers

\item[{\code{struct edac\_mc\_layer * layers}}] \leavevmode
Describes each layer as seen by the Memory Controller

\item[{\code{unsigned sz\_pvt}}] \leavevmode
size of private storage needed

\end{description}

\textbf{Description}

Everything is kmalloc'ed as one big chunk - more efficient.
Only can be used if all structures have the same lifetime - otherwise
you have to allocate and initialize your own structures.

Use {\hyperref[driver\string-api/edac:c.edac_mc_free]{\emph{\code{edac\_mc\_free()}}}} to free mc structures allocated by this function.

\begin{notice}{note}{Note:}
drivers handle multi-rank memories in different ways: in some
drivers, one multi-rank memory stick is mapped as one entry, while, in
others, a single multi-rank memory stick would be mapped into several
entries. Currently, this function will allocate multiple struct dimm\_info
on such scenarios, as grouping the multiple ranks require drivers change.
\end{notice}

\textbf{Return}
\begin{quote}

On success, return a pointer to struct mem\_ctl\_info pointer;
\code{NULL} otherwise
\end{quote}
\index{edac\_get\_owner (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_get_owner}\pysiglinewithargsret{const char * \bfcode{edac\_get\_owner}}{void}{}
Return the owner's mod\_name of EDAC MC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Return}
\begin{quote}

Pointer to mod\_name string when EDAC MC is owned. NULL otherwise.
\end{quote}
\index{edac\_mc\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_mc_free}\pysiglinewithargsret{void \bfcode{edac\_mc\_free}}{struct mem\_ctl\_info *\emph{ mci}}{}
Frees a previously allocated \textbf{mci} structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mem\_ctl\_info * mci}}] \leavevmode
pointer to a struct mem\_ctl\_info structure

\end{description}
\index{edac\_has\_mcs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_has_mcs}\pysiglinewithargsret{bool \bfcode{edac\_has\_mcs}}{void}{}
Check if any MCs have been allocated.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Return}
\begin{quote}

True if MC instances have been registered successfully.
False otherwise.
\end{quote}
\index{edac\_mc\_find (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_mc_find}\pysiglinewithargsret{struct mem\_ctl\_info * \bfcode{edac\_mc\_find}}{int\emph{ idx}}{}
Search for a mem\_ctl\_info structure whose index is \textbf{idx}.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int idx}}] \leavevmode
index to be seek

\end{description}

\textbf{Description}

If found, return a pointer to the structure.
Else return NULL.
\index{find\_mci\_by\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.find_mci_by_dev}\pysiglinewithargsret{struct mem\_ctl\_info * \bfcode{find\_mci\_by\_dev}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
Scan list of controllers looking for the one that manages the \textbf{dev} device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
pointer to a struct device related with the MCI

\end{description}

\textbf{Return}

on success, returns a pointer to struct \code{mem\_ctl\_info};
\code{NULL} otherwise.
\index{edac\_mc\_del\_mc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_mc_del_mc}\pysiglinewithargsret{struct mem\_ctl\_info * \bfcode{edac\_mc\_del\_mc}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
Remove sysfs entries for mci structure associated with \textbf{dev} and remove mci structure from global list.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Pointer to struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{\code{device}}}} representing mci structure to remove.

\end{description}

\textbf{Return}

pointer to removed mci structure, or \code{NULL} if device not found.
\index{edac\_mc\_find\_csrow\_by\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_mc_find_csrow_by_page}\pysiglinewithargsret{int \bfcode{edac\_mc\_find\_csrow\_by\_page}}{struct mem\_ctl\_info *\emph{ mci}, unsigned long\emph{ page}}{}
Ancillary routine to identify what csrow contains a memory page.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mem\_ctl\_info * mci}}] \leavevmode
pointer to a struct mem\_ctl\_info structure

\item[{\code{unsigned long page}}] \leavevmode
memory page to find

\end{description}

\textbf{Return}

on success, returns the csrow. -1 if not found.
\index{edac\_raw\_mc\_handle\_error (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_raw_mc_handle_error}\pysiglinewithargsret{void \bfcode{edac\_raw\_mc\_handle\_error}}{const enum {\hyperref[driver\string-api/edac:c.hw_event_mc_err_type]{\emph{hw\_event\_mc\_err\_type}}}\emph{ type}, struct mem\_ctl\_info *\emph{ mci}, struct {\hyperref[driver\string-api/edac:c.edac_raw_error_desc]{\emph{edac\_raw\_error\_desc}}} *\emph{ e}}{}
Reports a memory event to userspace without doing anything to discover the error location.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const enum hw\_event\_mc\_err\_type type}}] \leavevmode
severity of the error (CE/UE/Fatal)

\item[{\code{struct mem\_ctl\_info * mci}}] \leavevmode
a struct mem\_ctl\_info pointer

\item[{\code{struct edac\_raw\_error\_desc * e}}] \leavevmode
error description

\end{description}

\textbf{Description}

This raw function is used internally by {\hyperref[driver\string-api/edac:c.edac_mc_handle_error]{\emph{\code{edac\_mc\_handle\_error()}}}}. It should
only be called directly when the hardware error come directly from BIOS,
like in the case of APEI GHES driver.
\index{edac\_mc\_handle\_error (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_mc_handle_error}\pysiglinewithargsret{void \bfcode{edac\_mc\_handle\_error}}{const enum {\hyperref[driver\string-api/edac:c.hw_event_mc_err_type]{\emph{hw\_event\_mc\_err\_type}}}\emph{ type}, struct mem\_ctl\_info *\emph{ mci}, const u16\emph{ error\_count}, const unsigned long\emph{ page\_frame\_number}, const unsigned long\emph{ offset\_in\_page}, const unsigned long\emph{ syndrome}, const int\emph{ top\_layer}, const int\emph{ mid\_layer}, const int\emph{ low\_layer}, const char *\emph{ msg}, const char *\emph{ other\_detail}}{}
Reports a memory event to userspace.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const enum hw\_event\_mc\_err\_type type}}] \leavevmode
severity of the error (CE/UE/Fatal)

\item[{\code{struct mem\_ctl\_info * mci}}] \leavevmode
a struct mem\_ctl\_info pointer

\item[{\code{const u16 error\_count}}] \leavevmode
Number of errors of the same type

\item[{\code{const unsigned long page\_frame\_number}}] \leavevmode
mem page where the error occurred

\item[{\code{const unsigned long offset\_in\_page}}] \leavevmode
offset of the error inside the page

\item[{\code{const unsigned long syndrome}}] \leavevmode
ECC syndrome

\item[{\code{const int top\_layer}}] \leavevmode
Memory layer{[}0{]} position

\item[{\code{const int mid\_layer}}] \leavevmode
Memory layer{[}1{]} position

\item[{\code{const int low\_layer}}] \leavevmode
Memory layer{[}2{]} position

\item[{\code{const char * msg}}] \leavevmode
Message meaningful to the end users that
explains the event

\item[{\code{const char * other\_detail}}] \leavevmode
Technical details about the event that
may help hardware manufacturers and
EDAC developers to analyse the event

\end{description}


\section{PCI Controllers}
\label{driver-api/edac:pci-controllers}
The EDAC subsystem provides a mechanism to handle PCI controllers by calling
the {\hyperref[driver\string-api/edac:c.edac_pci_alloc_ctl_info]{\emph{\code{edac\_pci\_alloc\_ctl\_info()}}}}. It will use the struct
\code{edac\_pci\_ctl\_info} to describe the PCI controllers.
\index{edac\_pci\_alloc\_ctl\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_pci_alloc_ctl_info}\pysiglinewithargsret{struct edac\_pci\_ctl\_info * \bfcode{edac\_pci\_alloc\_ctl\_info}}{unsigned int\emph{ sz\_pvt}, const char *\emph{ edac\_pci\_name}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int sz\_pvt}}] \leavevmode
size of the private info at struct \code{edac\_pci\_ctl\_info}

\item[{\code{const char * edac\_pci\_name}}] \leavevmode
name of the PCI device

\end{description}

\textbf{Description}
\begin{quote}

The \code{alloc()} function for the `edac\_pci' control info
structure.
\end{quote}

The chip driver will allocate one of these for each
edac\_pci it is going to control/register with the EDAC CORE.

\textbf{Return}

a pointer to struct \code{edac\_pci\_ctl\_info} on success; \code{NULL} otherwise.
\index{edac\_pci\_free\_ctl\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_pci_free_ctl_info}\pysiglinewithargsret{void \bfcode{edac\_pci\_free\_ctl\_info}}{struct edac\_pci\_ctl\_info *\emph{ pci}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edac\_pci\_ctl\_info * pci}}] \leavevmode
pointer to struct \code{edac\_pci\_ctl\_info}

\end{description}

\textbf{Description}
\begin{quote}

Last action on the pci control structure.
\end{quote}

Calls the remove sysfs information, which will unregister
this control struct's kobj. When that kobj's ref count
goes to zero, its release function will be call and then
\code{kfree()} the memory.
\index{edac\_pci\_alloc\_index (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_pci_alloc_index}\pysiglinewithargsret{int \bfcode{edac\_pci\_alloc\_index}}{void}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Return}
\begin{quote}

allocated index number
\end{quote}
\index{edac\_pci\_add\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_pci_add_device}\pysiglinewithargsret{int \bfcode{edac\_pci\_add\_device}}{struct edac\_pci\_ctl\_info *\emph{ pci}, int\emph{ edac\_idx}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edac\_pci\_ctl\_info * pci}}] \leavevmode
pointer to the edac\_device structure to be added to the list

\item[{\code{int edac\_idx}}] \leavevmode
A unique numeric identifier to be assigned to the
`edac\_pci' structure.

\end{description}

\textbf{Description}
\begin{quote}

edac\_pci global list and create sysfs entries associated with
edac\_pci structure.
\end{quote}

\textbf{Return}
\begin{quote}

0 on Success, or an error code on failure
\end{quote}
\index{edac\_pci\_del\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_pci_del_device}\pysiglinewithargsret{struct edac\_pci\_ctl\_info * \bfcode{edac\_pci\_del\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Pointer to `struct device' representing edac\_pci structure
to remove

\end{description}

\textbf{Description}
\begin{quote}

Remove sysfs entries for specified edac\_pci structure and
then remove edac\_pci structure from global list
\end{quote}

\textbf{Return}
\begin{quote}

Pointer to removed edac\_pci structure,
or \code{NULL} if device not found
\end{quote}
\index{edac\_pci\_create\_generic\_ctl (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_pci_create_generic_ctl}\pysiglinewithargsret{struct edac\_pci\_ctl\_info * \bfcode{edac\_pci\_create\_generic\_ctl}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ mod\_name}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
pointer to struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{\code{device}}}};

\item[{\code{const char * mod\_name}}] \leavevmode
name of the PCI device

\end{description}

\textbf{Description}
\begin{quote}

A generic constructor for a PCI parity polling device
Some systems have more than one domain of PCI busses.
For systems with one domain, then this API will
provide for a generic poller.
\end{quote}

This routine calls the {\hyperref[driver\string-api/edac:c.edac_pci_alloc_ctl_info]{\emph{\code{edac\_pci\_alloc\_ctl\_info()}}}} for
the generic device, with default values

\textbf{Return}
\begin{description}
\item[{Pointer to struct \code{edac\_pci\_ctl\_info} on success, \code{NULL} on}] \leavevmode
failure.

\end{description}
\index{edac\_pci\_release\_generic\_ctl (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_pci_release_generic_ctl}\pysiglinewithargsret{void \bfcode{edac\_pci\_release\_generic\_ctl}}{struct edac\_pci\_ctl\_info *\emph{ pci}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edac\_pci\_ctl\_info * pci}}] \leavevmode
pointer to struct \code{edac\_pci\_ctl\_info}

\end{description}

\textbf{Description}
\begin{quote}

The release function of a generic EDAC PCI polling device
\end{quote}
\index{edac\_pci\_create\_sysfs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_pci_create_sysfs}\pysiglinewithargsret{int \bfcode{edac\_pci\_create\_sysfs}}{struct edac\_pci\_ctl\_info *\emph{ pci}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edac\_pci\_ctl\_info * pci}}] \leavevmode
pointer to struct \code{edac\_pci\_ctl\_info}

\end{description}

\textbf{Description}
\begin{quote}

Create the controls/attributes for the specified EDAC PCI device
\end{quote}
\index{edac\_pci\_remove\_sysfs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_pci_remove_sysfs}\pysiglinewithargsret{void \bfcode{edac\_pci\_remove\_sysfs}}{struct edac\_pci\_ctl\_info *\emph{ pci}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edac\_pci\_ctl\_info * pci}}] \leavevmode
pointer to struct \code{edac\_pci\_ctl\_info}

\end{description}

\textbf{Description}
\begin{quote}

remove the controls and attributes for this EDAC PCI device
\end{quote}


\section{EDAC Blocks}
\label{driver-api/edac:edac-blocks}
The EDAC subsystem also provides a generic mechanism to report errors on
other parts of the hardware via \code{edac\_device\_alloc\_ctl\_info()} function.

The structures \code{edac\_dev\_sysfs\_block\_attribute},
\code{edac\_device\_block}, \code{edac\_device\_instance} and
\code{edac\_device\_ctl\_info} provide a generic or abstract `edac\_device'
representation at sysfs.

This set of structures and the code that implements the APIs for the same, provide for registering EDAC type devices which are NOT standard memory or
PCI, like:
\begin{itemize}
\item {} 
CPU caches (L1 and L2)

\item {} 
DMA engines

\item {} 
Core CPU switches

\item {} 
Fabric switch units

\item {} 
PCIe interface controllers

\item {} 
other EDAC/ECC type devices that can be monitored for
errors, etc.

\end{itemize}

It allows for a 2 level set of hierarchy.

For example, a cache could be composed of L1, L2 and L3 levels of cache.
Each CPU core would have its own L1 cache, while sharing L2 and maybe L3
caches. On such case, those can be represented via the following sysfs
nodes:

\begin{Verbatim}[commandchars=\\\{\}]
/sys/devices/system/edac/..

pci/            \PYGZlt{}existing pci directory (if available)\PYGZgt{}
mc/             \PYGZlt{}existing memory device directory\PYGZgt{}
cpu/cpu0/..     \PYGZlt{}L1 and L2 block directory\PYGZgt{}
        /L1\PYGZhy{}cache/ce\PYGZus{}count
                 /ue\PYGZus{}count
        /L2\PYGZhy{}cache/ce\PYGZus{}count
                 /ue\PYGZus{}count
cpu/cpu1/..     \PYGZlt{}L1 and L2 block directory\PYGZgt{}
        /L1\PYGZhy{}cache/ce\PYGZus{}count
                 /ue\PYGZus{}count
        /L2\PYGZhy{}cache/ce\PYGZus{}count
                 /ue\PYGZus{}count
...

the L1 and L2 directories would be \PYGZdq{}edac\PYGZus{}device\PYGZus{}block\PYGZsq{}s\PYGZdq{}
\end{Verbatim}
\index{edac\_device\_add\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_device_add_device}\pysiglinewithargsret{int \bfcode{edac\_device\_add\_device}}{struct edac\_device\_ctl\_info *\emph{ edac\_dev}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edac\_device\_ctl\_info * edac\_dev}}] \leavevmode
pointer to edac\_device structure to be added to the list
`edac\_device' structure.

\end{description}

\textbf{Description}
\begin{quote}

edac\_device global list and create sysfs entries associated with
edac\_device structure.
\end{quote}

\textbf{Return}
\begin{quote}

0 on Success, or an error code on failure
\end{quote}
\index{edac\_device\_del\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_device_del_device}\pysiglinewithargsret{struct edac\_device\_ctl\_info * \bfcode{edac\_device\_del\_device}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Pointer to struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{\code{device}}}} representing the edac device
structure to remove.

\end{description}

\textbf{Description}
\begin{quote}

Remove sysfs entries for specified edac\_device structure and
then remove edac\_device structure from global list
\end{quote}

\textbf{Return}
\begin{quote}

Pointer to removed edac\_device structure,
or \code{NULL} if device not found.
\end{quote}
\index{edac\_device\_handle\_ue (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_device_handle_ue}\pysiglinewithargsret{void \bfcode{edac\_device\_handle\_ue}}{struct edac\_device\_ctl\_info *\emph{ edac\_dev}, int\emph{ inst\_nr}, int\emph{ block\_nr}, const char *\emph{ msg}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edac\_device\_ctl\_info * edac\_dev}}] \leavevmode
pointer to struct \code{edac\_device\_ctl\_info}

\item[{\code{int inst\_nr}}] \leavevmode
number of the instance where the UE error happened

\item[{\code{int block\_nr}}] \leavevmode
number of the block where the UE error happened

\item[{\code{const char * msg}}] \leavevmode
message to be printed

\end{description}

\textbf{Description}
\begin{quote}

perform a common output and handling of an `edac\_dev' UE event
\end{quote}
\index{edac\_device\_handle\_ce (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_device_handle_ce}\pysiglinewithargsret{void \bfcode{edac\_device\_handle\_ce}}{struct edac\_device\_ctl\_info *\emph{ edac\_dev}, int\emph{ inst\_nr}, int\emph{ block\_nr}, const char *\emph{ msg}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edac\_device\_ctl\_info * edac\_dev}}] \leavevmode
pointer to struct \code{edac\_device\_ctl\_info}

\item[{\code{int inst\_nr}}] \leavevmode
number of the instance where the CE error happened

\item[{\code{int block\_nr}}] \leavevmode
number of the block where the CE error happened

\item[{\code{const char * msg}}] \leavevmode
message to be printed

\end{description}

\textbf{Description}
\begin{quote}

perform a common output and handling of an `edac\_dev' CE event
\end{quote}
\index{edac\_device\_alloc\_index (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/edac:c.edac_device_alloc_index}\pysiglinewithargsret{int \bfcode{edac\_device\_alloc\_index}}{void}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Return}
\begin{quote}

allocated index number
\end{quote}


\chapter{SCSI Interfaces Guide}
\label{driver-api/scsi:scsi-interfaces-guide}\label{driver-api/scsi::doc}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
James Bottomley

\item[{Author}] \leavevmode
Rob Landley

\end{description}\end{quote}


\section{Introduction}
\label{driver-api/scsi:introduction}

\subsection{Protocol vs bus}
\label{driver-api/scsi:protocol-vs-bus}
Once upon a time, the Small Computer Systems Interface defined both a
parallel I/O bus and a data protocol to connect a wide variety of
peripherals (disk drives, tape drives, modems, printers, scanners,
optical drives, test equipment, and medical devices) to a host computer.

Although the old parallel (fast/wide/ultra) SCSI bus has largely fallen
out of use, the SCSI command set is more widely used than ever to
communicate with devices over a number of different busses.

The \href{http://www.t10.org/scsi-3.htm}{SCSI protocol} is a big-endian
peer-to-peer packet based protocol. SCSI commands are 6, 10, 12, or 16
bytes long, often followed by an associated data payload.

SCSI commands can be transported over just about any kind of bus, and
are the default protocol for storage devices attached to USB, SATA, SAS,
Fibre Channel, FireWire, and ATAPI devices. SCSI packets are also
commonly exchanged over Infiniband,
\href{http://i2o.shadowconnect.com/faq.php}{I2O}, TCP/IP
(\href{https://en.wikipedia.org/wiki/ISCSI}{iSCSI}), even \href{http://cyberelk.net/tim/parport/parscsi.html}{Parallel
ports}.


\subsection{Design of the Linux SCSI subsystem}
\label{driver-api/scsi:design-of-the-linux-scsi-subsystem}
The SCSI subsystem uses a three layer design, with upper, mid, and low
layers. Every operation involving the SCSI subsystem (such as reading a
sector from a disk) uses one driver at each of the 3 levels: one upper
layer driver, one lower layer driver, and the SCSI midlayer.

The SCSI upper layer provides the interface between userspace and the
kernel, in the form of block and char device nodes for I/O and ioctl().
The SCSI lower layer contains drivers for specific hardware devices.

In between is the SCSI mid-layer, analogous to a network routing layer
such as the IPv4 stack. The SCSI mid-layer routes a packet based data
protocol between the upper layer's /dev nodes and the corresponding
devices in the lower layer. It manages command queues, provides error
handling and power management functions, and responds to ioctl()
requests.


\section{SCSI upper layer}
\label{driver-api/scsi:scsi-upper-layer}
The upper layer supports the user-kernel interface by providing device
nodes.


\subsection{sd (SCSI Disk)}
\label{driver-api/scsi:sd-scsi-disk}
sd (sd\_mod.o)


\subsection{sr (SCSI CD-ROM)}
\label{driver-api/scsi:sr-scsi-cd-rom}
sr (sr\_mod.o)


\subsection{st (SCSI Tape)}
\label{driver-api/scsi:st-scsi-tape}
st (st.o)


\subsection{sg (SCSI Generic)}
\label{driver-api/scsi:sg-scsi-generic}
sg (sg.o)


\subsection{ch (SCSI Media Changer)}
\label{driver-api/scsi:ch-scsi-media-changer}
ch (ch.c)


\section{SCSI mid layer}
\label{driver-api/scsi:scsi-mid-layer}

\subsection{SCSI midlayer implementation}
\label{driver-api/scsi:scsi-midlayer-implementation}

\subsubsection{include/scsi/scsi\_device.h}
\label{driver-api/scsi:include-scsi-scsi-device-h}\index{scsi\_vpd (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_vpd}\pysigline{struct \bfcode{scsi\_vpd}}
SCSI Vital Product Data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct scsi\PYGZus{}vpd \PYGZob{}
  struct rcu\PYGZus{}head rcu;
  int len;
  unsigned char   data[];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{rcu}}] \leavevmode
For \code{kfree\_rcu()}.

\item[{\code{len}}] \leavevmode
Length in bytes of \textbf{data}.

\item[{\code{data}}] \leavevmode
VPD data as defined in various T10 SCSI standard documents.

\end{description}
\index{shost\_for\_each\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.shost_for_each_device}\pysiglinewithargsret{\bfcode{shost\_for\_each\_device}}{\emph{sdev}, \emph{shost}}{}
iterate over all devices of a host

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{sdev}}] \leavevmode
the \code{struct scsi\_device} to use as a cursor

\item[{\code{shost}}] \leavevmode
the \code{struct scsi\_host} to iterate over

\end{description}

\textbf{Description}

Iterator that returns each device attached to \textbf{shost}.  This loop
takes a reference on each device and releases it at the end.  If
you break out of the loop, you must call scsi\_device\_put(sdev).
\index{\_\_shost\_for\_each\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.__shost_for_each_device}\pysiglinewithargsret{\bfcode{\_\_shost\_for\_each\_device}}{\emph{sdev}, \emph{shost}}{}
iterate over all devices of a host (UNLOCKED)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{sdev}}] \leavevmode
the \code{struct scsi\_device} to use as a cursor

\item[{\code{shost}}] \leavevmode
the \code{struct scsi\_host} to iterate over

\end{description}

\textbf{Description}

Iterator that returns each device attached to \textbf{shost}.  It does \_not\_
take a reference on the scsi\_device, so the whole loop must be
protected by shost-\textgreater{}host\_lock.

\textbf{Note}

The only reason to use this is because you need to access the
device list in interrupt context.  Otherwise you really want to use
shost\_for\_each\_device instead.
\index{scsi\_device\_supports\_vpd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_device_supports_vpd}\pysiglinewithargsret{int \bfcode{scsi\_device\_supports\_vpd}}{struct scsi\_device *\emph{ sdev}}{}
test if a device supports VPD pages

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
the \code{struct scsi\_device} to test

\end{description}

\textbf{Description}

If the `try\_vpd\_pages' flag is set it takes precedence.
Otherwise we will assume VPD pages are supported if the
SCSI level is at least SPC-3 and `skip\_vpd\_pages' is not set.


\subsubsection{drivers/scsi/scsi.c}
\label{driver-api/scsi:drivers-scsi-scsi-c}
Main file for the SCSI midlayer.
\index{scsi\_cmd\_get\_serial (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_cmd_get_serial}\pysiglinewithargsret{void \bfcode{scsi\_cmd\_get\_serial}}{struct Scsi\_Host *\emph{ host}, struct scsi\_cmnd *\emph{ cmd}}{}
Assign a serial number to a command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * host}}] \leavevmode
the scsi host

\item[{\code{struct scsi\_cmnd * cmd}}] \leavevmode
command to assign serial number to

\end{description}

\textbf{Description}

a serial number identifies a request for error recovery
and debugging purposes.  Protected by the Host\_Lock of host.
\index{scsi\_change\_queue\_depth (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_change_queue_depth}\pysiglinewithargsret{int \bfcode{scsi\_change\_queue\_depth}}{struct scsi\_device *\emph{ sdev}, int\emph{ depth}}{}
change a device's queue depth

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
SCSI Device in question

\item[{\code{int depth}}] \leavevmode
number of commands allowed to be queued to the driver

\end{description}

\textbf{Description}

Sets the device queue depth and returns the new value.
\index{scsi\_track\_queue\_full (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_track_queue_full}\pysiglinewithargsret{int \bfcode{scsi\_track\_queue\_full}}{struct scsi\_device *\emph{ sdev}, int\emph{ depth}}{}
track QUEUE\_FULL events to adjust queue depth

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
SCSI Device in question

\item[{\code{int depth}}] \leavevmode
Current number of outstanding SCSI commands on this device,
not counting the one returned as QUEUE\_FULL.

\end{description}

\textbf{Description}
\begin{description}
\item[{This function will track successive QUEUE\_FULL events on a}] \leavevmode
specific SCSI device to determine if and when there is a
need to adjust the queue depth on the device.

\end{description}

\textbf{Return}
\begin{description}
\item[{0 - No change needed, \textgreater{}0 - Adjust queue depth to this new depth,}] \leavevmode\begin{description}
\item[{-1 - Drop back to untagged operation using host-\textgreater{}cmd\_per\_lun}] \leavevmode
as the untagged command depth

\end{description}

\end{description}

Lock Status: None held on entry

\textbf{Notes}
\begin{description}
\item[{Low level drivers may call this at any time and we will do}] \leavevmode
``The Right Thing.''  We are interrupt context safe.

\end{description}
\index{scsi\_get\_vpd\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_get_vpd_page}\pysiglinewithargsret{int \bfcode{scsi\_get\_vpd\_page}}{struct scsi\_device *\emph{ sdev}, u8\emph{ page}, unsigned char *\emph{ buf}, int\emph{ buf\_len}}{}
Get Vital Product Data from a SCSI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
The device to ask

\item[{\code{u8 page}}] \leavevmode
Which Vital Product Data to return

\item[{\code{unsigned char * buf}}] \leavevmode
where to store the VPD

\item[{\code{int buf\_len}}] \leavevmode
number of bytes in the VPD buffer area

\end{description}

\textbf{Description}

SCSI devices may optionally supply Vital Product Data.  Each `page'
of VPD is defined in the appropriate SCSI document (eg SPC, SBC).
If the device supports this VPD page, this routine returns a pointer
to a buffer containing the data from that page.  The caller is
responsible for calling \code{kfree()} on this pointer when it is no longer
needed.  If we cannot retrieve the VPD page this routine returns \code{NULL}.
\index{scsi\_report\_opcode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_report_opcode}\pysiglinewithargsret{int \bfcode{scsi\_report\_opcode}}{struct scsi\_device *\emph{ sdev}, unsigned char *\emph{ buffer}, unsigned int\emph{ len}, unsigned char\emph{ opcode}}{}
Find out if a given command opcode is supported

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
scsi device to query

\item[{\code{unsigned char * buffer}}] \leavevmode
scratch buffer (must be at least 20 bytes long)

\item[{\code{unsigned int len}}] \leavevmode
length of buffer

\item[{\code{unsigned char opcode}}] \leavevmode
opcode for command to look up

\end{description}

\textbf{Description}

Uses the REPORT SUPPORTED OPERATION CODES to look up the given
opcode. Returns -EINVAL if RSOC fails, 0 if the command opcode is
unsupported and 1 if the device claims to support the command.
\index{scsi\_device\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_device_get}\pysiglinewithargsret{int \bfcode{scsi\_device\_get}}{struct scsi\_device *\emph{ sdev}}{}
get an additional reference to a scsi\_device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
device to get a reference to

\end{description}

\textbf{Description}

Gets a reference to the scsi\_device and increments the use count
of the underlying LLDD module.  You must hold host\_lock of the
parent Scsi\_Host or already have a reference when calling this.

This will fail if a device is deleted or cancelled, or when the LLD module
is in the process of being unloaded.
\index{scsi\_device\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_device_put}\pysiglinewithargsret{void \bfcode{scsi\_device\_put}}{struct scsi\_device *\emph{ sdev}}{}
release a reference to a scsi\_device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
device to release a reference on.

\end{description}

\textbf{Description}

Release a reference to the scsi\_device and decrements the use
count of the underlying LLDD module.  The device is freed once the last
user vanishes.
\index{starget\_for\_each\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.starget_for_each_device}\pysiglinewithargsret{void \bfcode{starget\_for\_each\_device}}{struct scsi\_target *\emph{ starget}, void *\emph{ data}, void (*fn) (struct scsi\_device\emph{ *}, void\emph{ *}}{}
helper to walk all devices of a target

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_target * starget}}] \leavevmode
target whose devices we want to iterate over.

\item[{\code{void * data}}] \leavevmode
Opaque passed to each function call.

\item[{\code{void (*)(struct scsi\_device *, void *) fn}}] \leavevmode
Function to call on each device

\end{description}

\textbf{Description}

This traverses over each device of \textbf{starget}.  The devices have
a reference that must be released by scsi\_host\_put when breaking
out of the loop.
\index{\_\_starget\_for\_each\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.__starget_for_each_device}\pysiglinewithargsret{void \bfcode{\_\_starget\_for\_each\_device}}{struct scsi\_target *\emph{ starget}, void *\emph{ data}, void (*fn) (struct scsi\_device\emph{ *}, void\emph{ *}}{}
helper to walk all devices of a target (UNLOCKED)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_target * starget}}] \leavevmode
target whose devices we want to iterate over.

\item[{\code{void * data}}] \leavevmode
parameter for callback \textbf{fn()}

\item[{\code{void (*)(struct scsi\_device *, void *) fn}}] \leavevmode
callback function that is invoked for each device

\end{description}

\textbf{Description}

This traverses over each device of \textbf{starget}.  It does \_not\_
take a reference on the scsi\_device, so the whole loop must be
protected by shost-\textgreater{}host\_lock.

\textbf{Note}

The only reason why drivers would want to use this is because
they need to access the device list in irq context.  Otherwise you
really want to use starget\_for\_each\_device instead.
\index{\_\_scsi\_device\_lookup\_by\_target (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.__scsi_device_lookup_by_target}\pysiglinewithargsret{struct scsi\_device * \bfcode{\_\_scsi\_device\_lookup\_by\_target}}{struct scsi\_target *\emph{ starget}, u64\emph{ lun}}{}
find a device given the target (UNLOCKED)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_target * starget}}] \leavevmode
SCSI target pointer

\item[{\code{u64 lun}}] \leavevmode
SCSI Logical Unit Number

\end{description}

\textbf{Description}

Looks up the scsi\_device with the specified \textbf{lun} for a given
\textbf{starget}.  The returned scsi\_device does not have an additional
reference.  You must hold the host's host\_lock over this call and
any access to the returned scsi\_device. A scsi\_device in state
SDEV\_DEL is skipped.

\textbf{Note}

The only reason why drivers should use this is because
they need to access the device list in irq context.  Otherwise you
really want to use scsi\_device\_lookup\_by\_target instead.
\index{scsi\_device\_lookup\_by\_target (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_device_lookup_by_target}\pysiglinewithargsret{struct scsi\_device * \bfcode{scsi\_device\_lookup\_by\_target}}{struct scsi\_target *\emph{ starget}, u64\emph{ lun}}{}
find a device given the target

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_target * starget}}] \leavevmode
SCSI target pointer

\item[{\code{u64 lun}}] \leavevmode
SCSI Logical Unit Number

\end{description}

\textbf{Description}

Looks up the scsi\_device with the specified \textbf{lun} for a given
\textbf{starget}.  The returned scsi\_device has an additional reference that
needs to be released with scsi\_device\_put once you're done with it.
\index{\_\_scsi\_device\_lookup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.__scsi_device_lookup}\pysiglinewithargsret{struct scsi\_device * \bfcode{\_\_scsi\_device\_lookup}}{struct Scsi\_Host *\emph{ shost}, uint\emph{ channel}, uint\emph{ id}, u64\emph{ lun}}{}
find a device given the host (UNLOCKED)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
SCSI host pointer

\item[{\code{uint channel}}] \leavevmode
SCSI channel (zero if only one channel)

\item[{\code{uint id}}] \leavevmode
SCSI target number (physical unit number)

\item[{\code{u64 lun}}] \leavevmode
SCSI Logical Unit Number

\end{description}

\textbf{Description}

Looks up the scsi\_device with the specified \textbf{channel}, \textbf{id}, \textbf{lun}
for a given host. The returned scsi\_device does not have an additional
reference.  You must hold the host's host\_lock over this call and any access
to the returned scsi\_device.

\textbf{Note}

The only reason why drivers would want to use this is because
they need to access the device list in irq context.  Otherwise you
really want to use scsi\_device\_lookup instead.
\index{scsi\_device\_lookup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_device_lookup}\pysiglinewithargsret{struct scsi\_device * \bfcode{scsi\_device\_lookup}}{struct Scsi\_Host *\emph{ shost}, uint\emph{ channel}, uint\emph{ id}, u64\emph{ lun}}{}
find a device given the host

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
SCSI host pointer

\item[{\code{uint channel}}] \leavevmode
SCSI channel (zero if only one channel)

\item[{\code{uint id}}] \leavevmode
SCSI target number (physical unit number)

\item[{\code{u64 lun}}] \leavevmode
SCSI Logical Unit Number

\end{description}

\textbf{Description}

Looks up the scsi\_device with the specified \textbf{channel}, \textbf{id}, \textbf{lun}
for a given host.  The returned scsi\_device has an additional reference that
needs to be released with scsi\_device\_put once you're done with it.


\subsubsection{drivers/scsi/scsicam.c}
\label{driver-api/scsi:drivers-scsi-scsicam-c}
\href{http://www.t10.org/ftp/t10/drafts/cam/cam-r12b.pdf}{SCSI Common Access
Method} support
functions, for use with HDIO\_GETGEO, etc.
\index{scsi\_bios\_ptable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_bios_ptable}\pysiglinewithargsret{unsigned char * \bfcode{scsi\_bios\_ptable}}{struct block\_device *\emph{ dev}}{}
Read PC partition table out of first sector of device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct block\_device * dev}}] \leavevmode
from this device

\end{description}

\textbf{Description}
\begin{description}
\item[{Reads the first sector from the device and returns \code{0x42} bytes}] \leavevmode
starting at offset \code{0x1be}.

\end{description}

\textbf{Return}

partition table in kmalloc(GFP\_KERNEL) memory, or NULL on error.
\index{scsicam\_bios\_param (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsicam_bios_param}\pysiglinewithargsret{int \bfcode{scsicam\_bios\_param}}{struct block\_device *\emph{ bdev}, sector\_t\emph{ capacity}, int *\emph{ ip}}{}
Determine geometry of a disk in cylinders/heads/sectors.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct block\_device * bdev}}] \leavevmode
which device

\item[{\code{sector\_t capacity}}] \leavevmode
size of the disk in sectors

\item[{\code{int * ip}}] \leavevmode
return value: ip{[}0{]}=heads, ip{[}1{]}=sectors, ip{[}2{]}=cylinders

\end{description}

\textbf{Description}
\begin{description}
\item[{determine the BIOS mapping/geometry used for a drive in a}] \leavevmode
SCSI-CAM system, storing the results in ip as required
by the HDIO\_GETGEO \code{ioctl()}.

\end{description}

\textbf{Return}

-1 on failure, 0 on success.
\index{scsi\_partsize (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_partsize}\pysiglinewithargsret{int \bfcode{scsi\_partsize}}{unsigned char *\emph{ buf}, unsigned long\emph{ capacity}, unsigned int *\emph{ cyls}, unsigned int *\emph{ hds}, unsigned int *\emph{ secs}}{}
Parse cylinders/heads/sectors from PC partition table

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned char * buf}}] \leavevmode
partition table, see {\hyperref[driver\string-api/scsi:c.scsi_bios_ptable]{\emph{\code{scsi\_bios\_ptable()}}}}

\item[{\code{unsigned long capacity}}] \leavevmode
size of the disk in sectors

\item[{\code{unsigned int * cyls}}] \leavevmode
put cylinders here

\item[{\code{unsigned int * hds}}] \leavevmode
put heads here

\item[{\code{unsigned int * secs}}] \leavevmode
put sectors here

\end{description}

\textbf{Description}

Determine the BIOS mapping/geometry used to create the partition
table, storing the results in \textbf{cyls}, \textbf{hds}, and \textbf{secs}

\textbf{Return}

-1 on failure, 0 on success.


\subsubsection{drivers/scsi/scsi\_error.c}
\label{driver-api/scsi:drivers-scsi-scsi-error-c}
Common SCSI error/timeout handling routines.
\index{scsi\_schedule\_eh (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_schedule_eh}\pysiglinewithargsret{void \bfcode{scsi\_schedule\_eh}}{struct Scsi\_Host *\emph{ shost}}{}
schedule EH for SCSI host

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
SCSI host to invoke error handling on.

\end{description}

\textbf{Description}

Schedule SCSI EH without scmd.
\index{scsi\_block\_when\_processing\_errors (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_block_when_processing_errors}\pysiglinewithargsret{int \bfcode{scsi\_block\_when\_processing\_errors}}{struct scsi\_device *\emph{ sdev}}{}
Prevent cmds from being queued.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
Device on which we are performing recovery.

\end{description}

\textbf{Description}
\begin{quote}

We block until the host is out of error recovery, and then check to
see whether the host or the device is offline.
\end{quote}
\begin{description}
\item[{Return value:}] \leavevmode
0 when dev was taken offline by error recovery. 1 OK to proceed.

\end{description}
\index{scsi\_check\_sense (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_check_sense}\pysiglinewithargsret{int \bfcode{scsi\_check\_sense}}{struct scsi\_cmnd *\emph{ scmd}}{}
Examine scsi cmd sense

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * scmd}}] \leavevmode
Cmd to have sense checked.

\end{description}

\textbf{Description}
\begin{description}
\item[{Return value:}] \leavevmode
SUCCESS or FAILED or NEEDS\_RETRY or ADD\_TO\_MLQUEUE

\end{description}

\textbf{Notes}
\begin{quote}

When a deferred error is detected the current command has
not been executed and needs retrying.
\end{quote}
\index{scsi\_eh\_prep\_cmnd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_eh_prep_cmnd}\pysiglinewithargsret{void \bfcode{scsi\_eh\_prep\_cmnd}}{struct scsi\_cmnd *\emph{ scmd}, struct scsi\_eh\_save *\emph{ ses}, unsigned char *\emph{ cmnd}, int\emph{ cmnd\_size}, unsigned\emph{ sense\_bytes}}{}
Save a scsi command info as part of error recovery

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * scmd}}] \leavevmode
SCSI command structure to hijack

\item[{\code{struct scsi\_eh\_save * ses}}] \leavevmode
structure to save restore information

\item[{\code{unsigned char * cmnd}}] \leavevmode
CDB to send. Can be NULL if no new cmnd is needed

\item[{\code{int cmnd\_size}}] \leavevmode
size in bytes of \textbf{cmnd} (must be \textless{}= BLK\_MAX\_CDB)

\item[{\code{unsigned sense\_bytes}}] \leavevmode
size of sense data to copy. or 0 (if != 0 \textbf{cmnd} is ignored)

\end{description}

\textbf{Description}

This function is used to save a scsi command information before re-execution
as part of the error recovery process.  If \textbf{sense\_bytes} is 0 the command
sent must be one that does not transfer any data.  If \textbf{sense\_bytes} != 0
\textbf{cmnd} is ignored and this functions sets up a REQUEST\_SENSE command
and cmnd buffers to read \textbf{sense\_bytes} into \textbf{scmd}-\textgreater{}sense\_buffer.
\index{scsi\_eh\_restore\_cmnd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_eh_restore_cmnd}\pysiglinewithargsret{void \bfcode{scsi\_eh\_restore\_cmnd}}{struct scsi\_cmnd *\emph{ scmd}, struct scsi\_eh\_save *\emph{ ses}}{}
Restore a scsi command info as part of error recovery

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * scmd}}] \leavevmode
SCSI command structure to restore

\item[{\code{struct scsi\_eh\_save * ses}}] \leavevmode
saved information from a coresponding call to scsi\_eh\_prep\_cmnd

\end{description}

\textbf{Description}

Undo any damage done by above {\hyperref[driver\string-api/scsi:c.scsi_eh_prep_cmnd]{\emph{\code{scsi\_eh\_prep\_cmnd()}}}}.
\index{scsi\_eh\_finish\_cmd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_eh_finish_cmd}\pysiglinewithargsret{void \bfcode{scsi\_eh\_finish\_cmd}}{struct scsi\_cmnd *\emph{ scmd}, struct list\_head *\emph{ done\_q}}{}
Handle a cmd that eh is finished with.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * scmd}}] \leavevmode
Original SCSI cmd that eh has finished.

\item[{\code{struct list\_head * done\_q}}] \leavevmode
Queue for processed commands.

\end{description}

\textbf{Notes}
\begin{quote}

We don't want to use the normal command completion while we are are
still handling errors - it may cause other commands to be queued,
and that would disturb what we are doing.  Thus we really want to
keep a list of pending commands for final completion, and once we
are ready to leave error handling we handle completion for real.
\end{quote}
\index{scsi\_eh\_get\_sense (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_eh_get_sense}\pysiglinewithargsret{int \bfcode{scsi\_eh\_get\_sense}}{struct list\_head *\emph{ work\_q}, struct list\_head *\emph{ done\_q}}{}
Get device sense data.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct list\_head * work\_q}}] \leavevmode
Queue of commands to process.

\item[{\code{struct list\_head * done\_q}}] \leavevmode
Queue of processed commands.

\end{description}

\textbf{Description}
\begin{quote}

See if we need to request sense information.  if so, then get it
now, so we have a better idea of what to do.
\end{quote}

\textbf{Notes}
\begin{quote}

This has the unfortunate side effect that if a shost adapter does
not automatically request sense information, we end up shutting
it down before we request it.

All drivers should request sense information internally these days,
so for now all I have to say is tough noogies if you end up in here.
\begin{description}
\item[{XXX: Long term this code should go away, but that needs an audit of}] \leavevmode
all LLDDs first.

\end{description}
\end{quote}
\index{scsi\_eh\_ready\_devs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_eh_ready_devs}\pysiglinewithargsret{void \bfcode{scsi\_eh\_ready\_devs}}{struct Scsi\_Host *\emph{ shost}, struct list\_head *\emph{ work\_q}, struct list\_head *\emph{ done\_q}}{}
check device ready state and recover if not.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
host to be recovered.

\item[{\code{struct list\_head * work\_q}}] \leavevmode
\code{list\_head} for pending commands.

\item[{\code{struct list\_head * done\_q}}] \leavevmode
\code{list\_head} for processed commands.

\end{description}
\index{scsi\_eh\_flush\_done\_q (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_eh_flush_done_q}\pysiglinewithargsret{void \bfcode{scsi\_eh\_flush\_done\_q}}{struct list\_head *\emph{ done\_q}}{}
finish processed commands or retry them.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct list\_head * done\_q}}] \leavevmode
list\_head of processed commands.

\end{description}
\index{scsi\_ioctl\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_ioctl_reset}\pysiglinewithargsret{int \bfcode{scsi\_ioctl\_reset}}{struct scsi\_device *\emph{ dev}, int \_\_user *\emph{ arg}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * dev}}] \leavevmode
scsi\_device to operate on

\item[{\code{int \_\_user * arg}}] \leavevmode
reset type (see sg.h)

\end{description}
\index{scsi\_get\_sense\_info\_fld (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_get_sense_info_fld}\pysiglinewithargsret{bool \bfcode{scsi\_get\_sense\_info\_fld}}{const u8 *\emph{ sense\_buffer}, int\emph{ sb\_len}, u64 *\emph{ info\_out}}{}
get information field from sense data (either fixed or descriptor format)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * sense\_buffer}}] \leavevmode
byte array of sense data

\item[{\code{int sb\_len}}] \leavevmode
number of valid bytes in sense\_buffer

\item[{\code{u64 * info\_out}}] \leavevmode
pointer to 64 integer where 8 or 4 byte information
field will be placed if found.

\end{description}

\textbf{Description}
\begin{description}
\item[{Return value:}] \leavevmode
true if information field found, false if not found.

\end{description}


\subsubsection{drivers/scsi/scsi\_devinfo.c}
\label{driver-api/scsi:drivers-scsi-scsi-devinfo-c}
Manage scsi\_dev\_info\_list, which tracks blacklisted and whitelisted
devices.
\index{scsi\_dev\_info\_list\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_dev_info_list_add}\pysiglinewithargsret{int \bfcode{scsi\_dev\_info\_list\_add}}{int\emph{ compatible}, char *\emph{ vendor}, char *\emph{ model}, char *\emph{ strflags}, blist\_flags\_t\emph{ flags}}{}
add one dev\_info list entry.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int compatible}}] \leavevmode
if true, null terminate short strings.  Otherwise space pad.

\item[{\code{char * vendor}}] \leavevmode
vendor string

\item[{\code{char * model}}] \leavevmode
model (product) string

\item[{\code{char * strflags}}] \leavevmode
integer string

\item[{\code{blist\_flags\_t flags}}] \leavevmode
if strflags NULL, use this flag value

\end{description}

\textbf{Description}
\begin{quote}

Create and add one dev\_info entry for \textbf{vendor}, \textbf{model}, \textbf{strflags} or
\textbf{flag}. If \textbf{compatible}, add to the tail of the list, do not space
pad, and set devinfo-\textgreater{}compatible. The scsi\_static\_device\_list entries
are added with \textbf{compatible} 1 and \textbf{clfags} NULL.
\end{quote}

\textbf{Return}

0 OK, -error on failure.
\index{scsi\_dev\_info\_list\_find (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_dev_info_list_find}\pysiglinewithargsret{struct scsi\_dev\_info\_list * \bfcode{scsi\_dev\_info\_list\_find}}{const char *\emph{ vendor}, const char *\emph{ model}, enum scsi\_devinfo\_key\emph{ key}}{}
find a matching dev\_info list entry.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * vendor}}] \leavevmode
full vendor string

\item[{\code{const char * model}}] \leavevmode
full model (product) string

\item[{\code{enum scsi\_devinfo\_key key}}] \leavevmode
specify list to use

\end{description}

\textbf{Description}
\begin{quote}

Finds the first dev\_info entry matching \textbf{vendor}, \textbf{model}
in list specified by \textbf{key}.
\end{quote}

\textbf{Return}

pointer to matching entry, or ERR\_PTR on failure.
\index{scsi\_dev\_info\_list\_add\_str (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_dev_info_list_add_str}\pysiglinewithargsret{int \bfcode{scsi\_dev\_info\_list\_add\_str}}{char *\emph{ dev\_list}}{}
parse dev\_list and add to the scsi\_dev\_info\_list.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{char * dev\_list}}] \leavevmode
string of device flags to add

\end{description}

\textbf{Description}
\begin{quote}

Parse dev\_list, and add entries to the scsi\_dev\_info\_list.
dev\_list is of the form ``vendor:product:flag,vendor:product:flag''.
dev\_list is modified via strsep. Can be called for command line
addition, for proc or mabye a sysfs interface.
\end{quote}

\textbf{Return}

0 if OK, -error on failure.
\index{scsi\_get\_device\_flags (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_get_device_flags}\pysiglinewithargsret{blist\_flags\_t \bfcode{scsi\_get\_device\_flags}}{struct scsi\_device *\emph{ sdev}, const unsigned char *\emph{ vendor}, const unsigned char *\emph{ model}}{}
get device specific flags from the dynamic device list.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
\code{scsi\_device} to get flags for

\item[{\code{const unsigned char * vendor}}] \leavevmode
vendor name

\item[{\code{const unsigned char * model}}] \leavevmode
model name

\end{description}

\textbf{Description}
\begin{quote}

Search the global scsi\_dev\_info\_list (specified by list zero)
for an entry matching \textbf{vendor} and \textbf{model}, if found, return the
matching flags value, else return the host or global default
settings.  Called during scan time.
\end{quote}
\index{scsi\_exit\_devinfo (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_exit_devinfo}\pysiglinewithargsret{void \bfcode{scsi\_exit\_devinfo}}{void}{}
remove /proc/scsi/device\_info \& the scsi\_dev\_info\_list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}
\index{scsi\_init\_devinfo (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_init_devinfo}\pysiglinewithargsret{int \bfcode{scsi\_init\_devinfo}}{void}{}
set up the dynamic device list.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}
\begin{quote}

Add command line entries from scsi\_dev\_flags, then add
scsi\_static\_device\_list entries to the scsi device info list.
\end{quote}


\subsubsection{drivers/scsi/scsi\_ioctl.c}
\label{driver-api/scsi:drivers-scsi-scsi-ioctl-c}
Handle ioctl() calls for SCSI devices.
\index{scsi\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_ioctl}\pysiglinewithargsret{int \bfcode{scsi\_ioctl}}{struct scsi\_device *\emph{ sdev}, int\emph{ cmd}, void \_\_user *\emph{ arg}}{}
Dispatch ioctl to scsi device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
scsi device receiving ioctl

\item[{\code{int cmd}}] \leavevmode
which ioctl is it

\item[{\code{void \_\_user * arg}}] \leavevmode
data associated with ioctl

\end{description}

\textbf{Description}

The {\hyperref[driver\string-api/scsi:c.scsi_ioctl]{\emph{\code{scsi\_ioctl()}}}} function differs from most ioctls in that it
does not take a major/minor number as the dev field.  Rather, it takes
a pointer to a \code{struct scsi\_device}.


\subsubsection{drivers/scsi/scsi\_lib.c}
\label{driver-api/scsi:drivers-scsi-scsi-lib-c}
SCSI queuing library.
\index{scsi\_execute (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_execute}\pysiglinewithargsret{int \bfcode{scsi\_execute}}{struct scsi\_device *\emph{ sdev}, const unsigned char *\emph{ cmd}, int\emph{ data\_direction}, void *\emph{ buffer}, unsigned\emph{ bufflen}, unsigned char *\emph{ sense}, struct scsi\_sense\_hdr *\emph{ sshdr}, int\emph{ timeout}, int\emph{ retries}, u64\emph{ flags}, req\_flags\_t\emph{ rq\_flags}, int *\emph{ resid}}{}
insert request and wait for the result

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
scsi device

\item[{\code{const unsigned char * cmd}}] \leavevmode
scsi command

\item[{\code{int data\_direction}}] \leavevmode
data direction

\item[{\code{void * buffer}}] \leavevmode
data buffer

\item[{\code{unsigned bufflen}}] \leavevmode
len of buffer

\item[{\code{unsigned char * sense}}] \leavevmode
optional sense buffer

\item[{\code{struct scsi\_sense\_hdr * sshdr}}] \leavevmode
optional decoded sense header

\item[{\code{int timeout}}] \leavevmode
request timeout in seconds

\item[{\code{int retries}}] \leavevmode
number of times to retry request

\item[{\code{u64 flags}}] \leavevmode
flags for -\textgreater{}cmd\_flags

\item[{\code{req\_flags\_t rq\_flags}}] \leavevmode
flags for -\textgreater{}rq\_flags

\item[{\code{int * resid}}] \leavevmode
optional residual length

\end{description}

\textbf{Description}

Returns the scsi\_cmnd result field if a command was executed, or a negative
Linux error code if we didn't get that far.
\index{scsi\_device\_from\_queue (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_device_from_queue}\pysiglinewithargsret{struct scsi\_device * \bfcode{scsi\_device\_from\_queue}}{struct request\_queue *\emph{ q}}{}
return sdev associated with a request\_queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct request\_queue * q}}] \leavevmode
The request queue to return the sdev from

\end{description}

\textbf{Description}

Return the sdev associated with a request queue or NULL if the
request\_queue does not reference a SCSI device.
\index{scsi\_mode\_select (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_mode_select}\pysiglinewithargsret{int \bfcode{scsi\_mode\_select}}{struct scsi\_device *\emph{ sdev}, int\emph{ pf}, int\emph{ sp}, int\emph{ modepage}, unsigned char *\emph{ buffer}, int\emph{ len}, int\emph{ timeout}, int\emph{ retries}, struct scsi\_mode\_data *\emph{ data}, struct scsi\_sense\_hdr *\emph{ sshdr}}{}
issue a mode select

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
SCSI device to be queried

\item[{\code{int pf}}] \leavevmode
Page format bit (1 == standard, 0 == vendor specific)

\item[{\code{int sp}}] \leavevmode
Save page bit (0 == don't save, 1 == save)

\item[{\code{int modepage}}] \leavevmode
mode page being requested

\item[{\code{unsigned char * buffer}}] \leavevmode
request buffer (may not be smaller than eight bytes)

\item[{\code{int len}}] \leavevmode
length of request buffer.

\item[{\code{int timeout}}] \leavevmode
command timeout

\item[{\code{int retries}}] \leavevmode
number of retries before failing

\item[{\code{struct scsi\_mode\_data * data}}] \leavevmode
returns a structure abstracting the mode header data

\item[{\code{struct scsi\_sense\_hdr * sshdr}}] \leavevmode
place to put sense data (or NULL if no sense to be collected).
must be SCSI\_SENSE\_BUFFERSIZE big.

\end{description}

\textbf{Description}
\begin{quote}

Returns zero if successful; negative error number or scsi
status on error
\end{quote}
\index{scsi\_mode\_sense (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_mode_sense}\pysiglinewithargsret{int \bfcode{scsi\_mode\_sense}}{struct scsi\_device *\emph{ sdev}, int\emph{ dbd}, int\emph{ modepage}, unsigned char *\emph{ buffer}, int\emph{ len}, int\emph{ timeout}, int\emph{ retries}, struct scsi\_mode\_data *\emph{ data}, struct scsi\_sense\_hdr *\emph{ sshdr}}{}
issue a mode sense, falling back from 10 to six bytes if necessary.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
SCSI device to be queried

\item[{\code{int dbd}}] \leavevmode
set if mode sense will allow block descriptors to be returned

\item[{\code{int modepage}}] \leavevmode
mode page being requested

\item[{\code{unsigned char * buffer}}] \leavevmode
request buffer (may not be smaller than eight bytes)

\item[{\code{int len}}] \leavevmode
length of request buffer.

\item[{\code{int timeout}}] \leavevmode
command timeout

\item[{\code{int retries}}] \leavevmode
number of retries before failing

\item[{\code{struct scsi\_mode\_data * data}}] \leavevmode
returns a structure abstracting the mode header data

\item[{\code{struct scsi\_sense\_hdr * sshdr}}] \leavevmode
place to put sense data (or NULL if no sense to be collected).
must be SCSI\_SENSE\_BUFFERSIZE big.

\end{description}

\textbf{Description}
\begin{quote}

Returns zero if unsuccessful, or the header offset (either 4
or 8 depending on whether a six or ten byte command was
issued) if successful.
\end{quote}
\index{scsi\_test\_unit\_ready (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_test_unit_ready}\pysiglinewithargsret{int \bfcode{scsi\_test\_unit\_ready}}{struct scsi\_device *\emph{ sdev}, int\emph{ timeout}, int\emph{ retries}, struct scsi\_sense\_hdr *\emph{ sshdr}}{}
test if unit is ready

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
scsi device to change the state of.

\item[{\code{int timeout}}] \leavevmode
command timeout

\item[{\code{int retries}}] \leavevmode
number of retries before failing

\item[{\code{struct scsi\_sense\_hdr * sshdr}}] \leavevmode
outpout pointer for decoded sense information.

\end{description}

\textbf{Description}
\begin{quote}

Returns zero if unsuccessful or an error if TUR failed.  For
removable media, UNIT\_ATTENTION sets -\textgreater{}changed flag.
\end{quote}
\index{scsi\_device\_set\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_device_set_state}\pysiglinewithargsret{int \bfcode{scsi\_device\_set\_state}}{struct scsi\_device *\emph{ sdev}, enum scsi\_device\_state\emph{ state}}{}
Take the given device through the device state model.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
scsi device to change the state of.

\item[{\code{enum scsi\_device\_state state}}] \leavevmode
state to change to.

\end{description}

\textbf{Description}
\begin{quote}

Returns zero if successful or an error if the requested
transition is illegal.
\end{quote}
\index{sdev\_evt\_send (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sdev_evt_send}\pysiglinewithargsret{void \bfcode{sdev\_evt\_send}}{struct scsi\_device *\emph{ sdev}, struct scsi\_event *\emph{ evt}}{}
send asserted event to uevent thread

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
scsi\_device event occurred on

\item[{\code{struct scsi\_event * evt}}] \leavevmode
event to send

\end{description}

\textbf{Description}
\begin{quote}

Assert scsi device event asynchronously.
\end{quote}
\index{sdev\_evt\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sdev_evt_alloc}\pysiglinewithargsret{struct scsi\_event * \bfcode{sdev\_evt\_alloc}}{enum scsi\_device\_event\emph{ evt\_type}, gfp\_t\emph{ gfpflags}}{}
allocate a new scsi event

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{enum scsi\_device\_event evt\_type}}] \leavevmode
type of event to allocate

\item[{\code{gfp\_t gfpflags}}] \leavevmode
GFP flags for allocation

\end{description}

\textbf{Description}
\begin{quote}

Allocates and returns a new scsi\_event.
\end{quote}
\index{sdev\_evt\_send\_simple (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sdev_evt_send_simple}\pysiglinewithargsret{void \bfcode{sdev\_evt\_send\_simple}}{struct scsi\_device *\emph{ sdev}, enum scsi\_device\_event\emph{ evt\_type}, gfp\_t\emph{ gfpflags}}{}
send asserted event to uevent thread

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
scsi\_device event occurred on

\item[{\code{enum scsi\_device\_event evt\_type}}] \leavevmode
type of event to send

\item[{\code{gfp\_t gfpflags}}] \leavevmode
GFP flags for allocation

\end{description}

\textbf{Description}
\begin{quote}

Assert scsi device event asynchronously, given an event type.
\end{quote}
\index{scsi\_device\_quiesce (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_device_quiesce}\pysiglinewithargsret{int \bfcode{scsi\_device\_quiesce}}{struct scsi\_device *\emph{ sdev}}{}
Block user issued commands.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
scsi device to quiesce.

\end{description}

\textbf{Description}
\begin{quote}

This works by trying to transition to the SDEV\_QUIESCE state
(which must be a legal transition).  When the device is in this
state, only special requests will be accepted, all others will
be deferred.  Since special requests may also be requeued requests,
a successful return doesn't guarantee the device will be
totally quiescent.

Must be called with user context, may sleep.

Returns zero if unsuccessful or an error if not.
\end{quote}
\index{scsi\_device\_resume (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_device_resume}\pysiglinewithargsret{void \bfcode{scsi\_device\_resume}}{struct scsi\_device *\emph{ sdev}}{}
Restart user issued commands to a quiesced device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
scsi device to resume.

\end{description}

\textbf{Description}
\begin{quote}

Moves the device from quiesced back to running and restarts the
queues.

Must be called with user context, may sleep.
\end{quote}
\index{scsi\_internal\_device\_block\_nowait (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_internal_device_block_nowait}\pysiglinewithargsret{int \bfcode{scsi\_internal\_device\_block\_nowait}}{struct scsi\_device *\emph{ sdev}}{}
try to transition to the SDEV\_BLOCK state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
device to block

\end{description}

\textbf{Description}

Pause SCSI command processing on the specified device. Does not sleep.

Returns zero if successful or a negative error code upon failure.

\textbf{Notes}

This routine transitions the device to the SDEV\_BLOCK state (which must be
a legal transition). When the device is in this state, command processing
is paused until the device leaves the SDEV\_BLOCK state. See also
{\hyperref[driver\string-api/scsi:c.scsi_internal_device_unblock_nowait]{\emph{\code{scsi\_internal\_device\_unblock\_nowait()}}}}.
\index{scsi\_internal\_device\_unblock\_nowait (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_internal_device_unblock_nowait}\pysiglinewithargsret{int \bfcode{scsi\_internal\_device\_unblock\_nowait}}{struct scsi\_device *\emph{ sdev}, enum scsi\_device\_state\emph{ new\_state}}{}
resume a device after a block request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
device to resume

\item[{\code{enum scsi\_device\_state new\_state}}] \leavevmode
state to set the device to after unblocking

\end{description}

\textbf{Description}

Restart the device queue for a previously suspended SCSI device. Does not
sleep.

Returns zero if successful or a negative error code upon failure.

\textbf{Notes}

This routine transitions the device to the SDEV\_RUNNING state or to one of
the offline states (which must be a legal transition) allowing the midlayer
to goose the queue for this device.
\index{scsi\_kmap\_atomic\_sg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_kmap_atomic_sg}\pysiglinewithargsret{void * \bfcode{scsi\_kmap\_atomic\_sg}}{struct scatterlist *\emph{ sgl}, int\emph{ sg\_count}, size\_t *\emph{ offset}, size\_t *\emph{ len}}{}
find and atomically map an sg-elemnt

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scatterlist * sgl}}] \leavevmode
scatter-gather list

\item[{\code{int sg\_count}}] \leavevmode
number of segments in sg

\item[{\code{size\_t * offset}}] \leavevmode
offset in bytes into sg, on return offset into the mapped area

\item[{\code{size\_t * len}}] \leavevmode
bytes to map, on return number of bytes mapped

\end{description}

\textbf{Description}

Returns virtual address of the start of the mapped page
\index{scsi\_kunmap\_atomic\_sg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_kunmap_atomic_sg}\pysiglinewithargsret{void \bfcode{scsi\_kunmap\_atomic\_sg}}{void *\emph{ virt}}{}
atomically unmap a virtual address, previously mapped with scsi\_kmap\_atomic\_sg

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * virt}}] \leavevmode
virtual address to be unmapped

\end{description}
\index{scsi\_vpd\_lun\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_vpd_lun_id}\pysiglinewithargsret{int \bfcode{scsi\_vpd\_lun\_id}}{struct scsi\_device *\emph{ sdev}, char *\emph{ id}, size\_t\emph{ id\_len}}{}
return a unique device identification

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
SCSI device

\item[{\code{char * id}}] \leavevmode
buffer for the identification

\item[{\code{size\_t id\_len}}] \leavevmode
length of the buffer

\end{description}

\textbf{Description}

Copies a unique device identification into \textbf{id} based
on the information in the VPD page 0x83 of the device.
The string will be formatted as a SCSI name string.

Returns the length of the identification or error on failure.
If the identifier is longer than the supplied buffer the actual
identifier length is returned and the buffer is not zero-padded.


\subsubsection{drivers/scsi/scsi\_lib\_dma.c}
\label{driver-api/scsi:drivers-scsi-scsi-lib-dma-c}
SCSI library functions depending on DMA (map and unmap scatter-gather
lists).
\index{scsi\_dma\_map (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_dma_map}\pysiglinewithargsret{int \bfcode{scsi\_dma\_map}}{struct scsi\_cmnd *\emph{ cmd}}{}
perform DMA mapping against command's sg lists

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * cmd}}] \leavevmode
scsi command

\end{description}

\textbf{Description}

Returns the number of sg lists actually used, zero if the sg lists
is NULL, or -ENOMEM if the mapping failed.
\index{scsi\_dma\_unmap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_dma_unmap}\pysiglinewithargsret{void \bfcode{scsi\_dma\_unmap}}{struct scsi\_cmnd *\emph{ cmd}}{}
unmap command's sg lists mapped by scsi\_dma\_map

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * cmd}}] \leavevmode
scsi command

\end{description}


\subsubsection{drivers/scsi/scsi\_module.c}
\label{driver-api/scsi:drivers-scsi-scsi-module-c}
The file drivers/scsi/scsi\_module.c contains legacy support for
old-style host templates. It should never be used by any new driver.


\subsubsection{drivers/scsi/scsi\_proc.c}
\label{driver-api/scsi:drivers-scsi-scsi-proc-c}
The functions in this file provide an interface between the PROC file
system and the SCSI device drivers It is mainly used for debugging,
statistics and to pass information directly to the lowlevel driver. I.E.
plumbing to manage /proc/scsi/*
\index{scsi\_proc\_hostdir\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_proc_hostdir_add}\pysiglinewithargsret{void \bfcode{scsi\_proc\_hostdir\_add}}{struct scsi\_host\_template *\emph{ sht}}{}
Create directory in /proc for a scsi host

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_host\_template * sht}}] \leavevmode
owner of this directory

\end{description}

\textbf{Description}

Sets sht-\textgreater{}proc\_dir to the new directory.
\index{scsi\_proc\_hostdir\_rm (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_proc_hostdir_rm}\pysiglinewithargsret{void \bfcode{scsi\_proc\_hostdir\_rm}}{struct scsi\_host\_template *\emph{ sht}}{}
remove directory in /proc for a scsi host

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_host\_template * sht}}] \leavevmode
owner of directory

\end{description}
\index{scsi\_proc\_host\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_proc_host_add}\pysiglinewithargsret{void \bfcode{scsi\_proc\_host\_add}}{struct Scsi\_Host *\emph{ shost}}{}
Add entry for this host to appropriate /proc dir

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
host to add

\end{description}
\index{scsi\_proc\_host\_rm (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_proc_host_rm}\pysiglinewithargsret{void \bfcode{scsi\_proc\_host\_rm}}{struct Scsi\_Host *\emph{ shost}}{}
remove this host's entry from /proc

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
which host

\end{description}
\index{proc\_print\_scsidevice (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.proc_print_scsidevice}\pysiglinewithargsret{int \bfcode{proc\_print\_scsidevice}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, void *\emph{ data}}{}
return data about this host

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
A scsi device

\item[{\code{void * data}}] \leavevmode
\code{struct seq\_file} to output to.

\end{description}

\textbf{Description}

prints Host, Channel, Id, Lun, Vendor, Model, Rev, Type,
and revision.
\index{scsi\_add\_single\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_add_single_device}\pysiglinewithargsret{int \bfcode{scsi\_add\_single\_device}}{uint\emph{ host}, uint\emph{ channel}, uint\emph{ id}, uint\emph{ lun}}{}
Respond to user request to probe for/add device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{uint host}}] \leavevmode
user-supplied decimal integer

\item[{\code{uint channel}}] \leavevmode
user-supplied decimal integer

\item[{\code{uint id}}] \leavevmode
user-supplied decimal integer

\item[{\code{uint lun}}] \leavevmode
user-supplied decimal integer

\end{description}

\textbf{Description}

called by writing ``scsi add-single-device'' to /proc/scsi/scsi.

does {\hyperref[driver\string-api/scsi:c.scsi_host_lookup]{\emph{\code{scsi\_host\_lookup()}}}} and either \code{user\_scan()} if that transport
type supports it, or else \code{scsi\_scan\_host\_selected()}

\textbf{Note}

this seems to be aimed exclusively at SCSI parallel busses.
\index{scsi\_remove\_single\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_remove_single_device}\pysiglinewithargsret{int \bfcode{scsi\_remove\_single\_device}}{uint\emph{ host}, uint\emph{ channel}, uint\emph{ id}, uint\emph{ lun}}{}
Respond to user request to remove a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{uint host}}] \leavevmode
user-supplied decimal integer

\item[{\code{uint channel}}] \leavevmode
user-supplied decimal integer

\item[{\code{uint id}}] \leavevmode
user-supplied decimal integer

\item[{\code{uint lun}}] \leavevmode
user-supplied decimal integer

\end{description}

\textbf{Description}

called by writing ``scsi remove-single-device'' to
/proc/scsi/scsi.  Does a {\hyperref[driver\string-api/scsi:c.scsi_device_lookup]{\emph{\code{scsi\_device\_lookup()}}}} and {\hyperref[driver\string-api/scsi:c.scsi_remove_device]{\emph{\code{scsi\_remove\_device()}}}}
\index{proc\_scsi\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.proc_scsi_write}\pysiglinewithargsret{ssize\_t \bfcode{proc\_scsi\_write}}{struct file *\emph{ file}, const char \_\_user *\emph{ buf}, size\_t\emph{ length}, loff\_t *\emph{ ppos}}{}
handle writes to /proc/scsi/scsi

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * file}}] \leavevmode
not used

\item[{\code{const char \_\_user * buf}}] \leavevmode
buffer to write

\item[{\code{size\_t length}}] \leavevmode
length of buf, at most PAGE\_SIZE

\item[{\code{loff\_t * ppos}}] \leavevmode
not used

\end{description}

\textbf{Description}

this provides a legacy mechanism to add or remove devices by
Host, Channel, ID, and Lun.  To use,
``echo `scsi add-single-device 0 1 2 3' \textgreater{} /proc/scsi/scsi'' or
``echo `scsi remove-single-device 0 1 2 3' \textgreater{} /proc/scsi/scsi'' with
``0 1 2 3'' replaced by the Host, Channel, Id, and Lun.

\textbf{Note}

this seems to be aimed at parallel SCSI. Most modern busses (USB,
SATA, Firewire, Fibre Channel, etc) dynamically assign these values to
provide a unique identifier and nothing more.
\index{proc\_scsi\_open (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.proc_scsi_open}\pysiglinewithargsret{int \bfcode{proc\_scsi\_open}}{struct inode *\emph{ inode}, struct file *\emph{ file}}{}
glue function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct inode * inode}}] \leavevmode
not used

\item[{\code{struct file * file}}] \leavevmode
passed to \code{single\_open()}

\end{description}

\textbf{Description}

Associates proc\_scsi\_show with this file
\index{scsi\_init\_procfs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_init_procfs}\pysiglinewithargsret{int \bfcode{scsi\_init\_procfs}}{void}{}
create scsi and scsi/scsi in procfs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}
\index{scsi\_exit\_procfs (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_exit_procfs}\pysiglinewithargsret{void \bfcode{scsi\_exit\_procfs}}{void}{}
Remove scsi/scsi and scsi from procfs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}


\subsubsection{drivers/scsi/scsi\_netlink.c}
\label{driver-api/scsi:drivers-scsi-scsi-netlink-c}
Infrastructure to provide async events from transports to userspace via
netlink, using a single NETLINK\_SCSITRANSPORT protocol for all
transports. See \href{http://marc.info/?l=linux-scsi\&m=115507374832500\&w=2}{the original patch
submission} for
more details.
\index{scsi\_nl\_rcv\_msg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_nl_rcv_msg}\pysiglinewithargsret{void \bfcode{scsi\_nl\_rcv\_msg}}{struct sk\_buff *\emph{ skb}}{}
Receive message handler.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
socket receive buffer

\end{description}

\textbf{Description}
\begin{description}
\item[{Extracts message from a receive buffer.}] \leavevmode
Validates message header and calls appropriate transport message handler

\end{description}
\index{scsi\_netlink\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_netlink_init}\pysiglinewithargsret{void \bfcode{scsi\_netlink\_init}}{void}{}
Called by SCSI subsystem to initialize the SCSI transport netlink interface

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}
\index{scsi\_netlink\_exit (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_netlink_exit}\pysiglinewithargsret{void \bfcode{scsi\_netlink\_exit}}{void}{}
Called by SCSI subsystem to disable the SCSI transport netlink interface

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}


\subsubsection{drivers/scsi/scsi\_scan.c}
\label{driver-api/scsi:drivers-scsi-scsi-scan-c}
Scan a host to determine which (if any) devices are attached. The
general scanning/probing algorithm is as follows, exceptions are made to
it depending on device specific flags, compilation options, and global
variable (boot or module load time) settings. A specific LUN is scanned
via an INQUIRY command; if the LUN has a device attached, a scsi\_device
is allocated and setup for it. For every id of every channel on the
given host, start by scanning LUN 0. Skip hosts that don't respond at
all to a scan of LUN 0. Otherwise, if LUN 0 has a device attached,
allocate and setup a scsi\_device for it. If target is SCSI-3 or up,
issue a REPORT LUN, and scan all of the LUNs returned by the REPORT LUN;
else, sequentially scan LUNs up until some maximum is reached, or a LUN
is seen that cannot have a device attached to it.
\index{scsi\_complete\_async\_scans (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_complete_async_scans}\pysiglinewithargsret{int \bfcode{scsi\_complete\_async\_scans}}{void}{}
Wait for asynchronous scans to complete

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

When this function returns, any host which started scanning before
this function was called will have finished its scan.  Hosts which
started scanning after this function was called may or may not have
finished.
\index{scsi\_unlock\_floptical (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_unlock_floptical}\pysiglinewithargsret{void \bfcode{scsi\_unlock\_floptical}}{struct scsi\_device *\emph{ sdev}, unsigned char *\emph{ result}}{}
unlock device via a special MODE SENSE command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
scsi device to send command to

\item[{\code{unsigned char * result}}] \leavevmode
area to store the result of the MODE SENSE

\end{description}

\textbf{Description}
\begin{quote}

Send a vendor specific MODE SENSE (not a MODE SELECT) command.
Called for BLIST\_KEY devices.
\end{quote}
\index{scsi\_alloc\_sdev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_alloc_sdev}\pysiglinewithargsret{struct scsi\_device * \bfcode{scsi\_alloc\_sdev}}{struct scsi\_target *\emph{ starget}, u64\emph{ lun}, void *\emph{ hostdata}}{}
allocate and setup a scsi\_Device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_target * starget}}] \leavevmode
which target to allocate a \code{scsi\_device} for

\item[{\code{u64 lun}}] \leavevmode
which lun

\item[{\code{void * hostdata}}] \leavevmode
usually NULL and set by -\textgreater{}slave\_alloc instead

\end{description}

\textbf{Description}
\begin{quote}

Allocate, initialize for io, and return a pointer to a scsi\_Device.
Stores the \textbf{shost}, \textbf{channel}, \textbf{id}, and \textbf{lun} in the scsi\_Device, and
adds scsi\_Device to the appropriate list.
\end{quote}
\begin{description}
\item[{Return value:}] \leavevmode
scsi\_Device pointer, or NULL on failure.

\end{description}
\index{scsi\_target\_reap\_ref\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_target_reap_ref_release}\pysiglinewithargsret{void \bfcode{scsi\_target\_reap\_ref\_release}}{struct kref *\emph{ kref}}{}
remove target from visibility

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kref * kref}}] \leavevmode
the reap\_ref in the target being released

\end{description}

\textbf{Description}

Called on last put of reap\_ref, which is the indication that no device
under this target is visible anymore, so render the target invisible in
sysfs.  Note: we have to be in user context here because the target reaps
should be done in places where the scsi device visibility is being removed.
\index{scsi\_alloc\_target (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_alloc_target}\pysiglinewithargsret{struct scsi\_target * \bfcode{scsi\_alloc\_target}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ parent}, int\emph{ channel}, uint\emph{ id}}{}
allocate a new or find an existing target

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * parent}}] \leavevmode
parent of the target (need not be a scsi host)

\item[{\code{int channel}}] \leavevmode
target channel number (zero if no channels)

\item[{\code{uint id}}] \leavevmode
target id number

\end{description}

\textbf{Description}

Return an existing target if one exists, provided it hasn't already
gone into STARGET\_DEL state, otherwise allocate a new target.

The target is returned with an incremented reference, so the caller
is responsible for both reaping and doing a last put
\index{scsi\_target\_reap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_target_reap}\pysiglinewithargsret{void \bfcode{scsi\_target\_reap}}{struct scsi\_target *\emph{ starget}}{}
check to see if target is in use and destroy if not

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_target * starget}}] \leavevmode
target to be checked

\end{description}

\textbf{Description}

This is used after removing a LUN or doing a last put of the target
it checks atomically that nothing is using the target and removes
it if so.
\index{scsi\_probe\_lun (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_probe_lun}\pysiglinewithargsret{int \bfcode{scsi\_probe\_lun}}{struct scsi\_device *\emph{ sdev}, unsigned char *\emph{ inq\_result}, int\emph{ result\_len}, blist\_flags\_t *\emph{ bflags}}{}
probe a single LUN using a SCSI INQUIRY

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
scsi\_device to probe

\item[{\code{unsigned char * inq\_result}}] \leavevmode
area to store the INQUIRY result

\item[{\code{int result\_len}}] \leavevmode
len of inq\_result

\item[{\code{blist\_flags\_t * bflags}}] \leavevmode
store any bflags found here

\end{description}

\textbf{Description}
\begin{quote}

Probe the lun associated with \textbf{req} using a standard SCSI INQUIRY;

If the INQUIRY is successful, zero is returned and the
INQUIRY data is in \textbf{inq\_result}; the scsi\_level and INQUIRY length
are copied to the scsi\_device any flags value is stored in \textbf{*bflags}.
\end{quote}
\index{scsi\_add\_lun (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_add_lun}\pysiglinewithargsret{int \bfcode{scsi\_add\_lun}}{struct scsi\_device *\emph{ sdev}, unsigned char *\emph{ inq\_result}, blist\_flags\_t *\emph{ bflags}, int\emph{ async}}{}
allocate and fully initialze a scsi\_device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
holds information to be stored in the new scsi\_device

\item[{\code{unsigned char * inq\_result}}] \leavevmode
holds the result of a previous INQUIRY to the LUN

\item[{\code{blist\_flags\_t * bflags}}] \leavevmode
black/white list flag

\item[{\code{int async}}] \leavevmode
1 if this device is being scanned asynchronously

\end{description}

\textbf{Description}
\begin{quote}

Initialize the scsi\_device \textbf{sdev}.  Optionally set fields based
on values in \textbf{*bflags}.
\end{quote}

\textbf{Return}
\begin{quote}

SCSI\_SCAN\_NO\_RESPONSE: could not allocate or setup a scsi\_device
SCSI\_SCAN\_LUN\_PRESENT: a new scsi\_device was allocated and initialized
\end{quote}
\index{scsi\_inq\_str (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_inq_str}\pysiglinewithargsret{unsigned char * \bfcode{scsi\_inq\_str}}{unsigned char *\emph{ buf}, unsigned char *\emph{ inq}, unsigned\emph{ first}, unsigned\emph{ end}}{}
print INQUIRY data from min to max index, strip trailing whitespace

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned char * buf}}] \leavevmode
Output buffer with at least end-first+1 bytes of space

\item[{\code{unsigned char * inq}}] \leavevmode
Inquiry buffer (input)

\item[{\code{unsigned first}}] \leavevmode
Offset of string into inq

\item[{\code{unsigned end}}] \leavevmode
Index after last character in inq

\end{description}
\index{scsi\_probe\_and\_add\_lun (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_probe_and_add_lun}\pysiglinewithargsret{int \bfcode{scsi\_probe\_and\_add\_lun}}{struct scsi\_target *\emph{ starget}, u64\emph{ lun}, blist\_flags\_t *\emph{ bflagsp}, struct scsi\_device **\emph{ sdevp}, enum scsi\_scan\_mode\emph{ rescan}, void *\emph{ hostdata}}{}
probe a LUN, if a LUN is found add it

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_target * starget}}] \leavevmode
pointer to target device structure

\item[{\code{u64 lun}}] \leavevmode
LUN of target device

\item[{\code{blist\_flags\_t * bflagsp}}] \leavevmode
store bflags here if not NULL

\item[{\code{struct scsi\_device ** sdevp}}] \leavevmode
probe the LUN corresponding to this scsi\_device

\item[{\code{enum scsi\_scan\_mode rescan}}] \leavevmode
if not equal to SCSI\_SCAN\_INITIAL skip some code only
needed on first scan

\item[{\code{void * hostdata}}] \leavevmode
passed to {\hyperref[driver\string-api/scsi:c.scsi_alloc_sdev]{\emph{\code{scsi\_alloc\_sdev()}}}}

\end{description}

\textbf{Description}
\begin{quote}

Call scsi\_probe\_lun, if a LUN with an attached device is found,
allocate and set it up by calling scsi\_add\_lun.
\end{quote}

\textbf{Return}
\begin{itemize}
\item {} 
SCSI\_SCAN\_NO\_RESPONSE: could not allocate or setup a scsi\_device

\item {} \begin{description}
\item[{SCSI\_SCAN\_TARGET\_PRESENT: target responded, but no device is}] \leavevmode
attached at the LUN

\end{description}

\item {} 
SCSI\_SCAN\_LUN\_PRESENT: a new scsi\_device was allocated and initialized

\end{itemize}
\index{scsi\_sequential\_lun\_scan (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_sequential_lun_scan}\pysiglinewithargsret{void \bfcode{scsi\_sequential\_lun\_scan}}{struct scsi\_target *\emph{ starget}, blist\_flags\_t\emph{ bflags}, int\emph{ scsi\_level}, enum scsi\_scan\_mode\emph{ rescan}}{}
sequentially scan a SCSI target

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_target * starget}}] \leavevmode
pointer to target structure to scan

\item[{\code{blist\_flags\_t bflags}}] \leavevmode
black/white list flag for LUN 0

\item[{\code{int scsi\_level}}] \leavevmode
Which version of the standard does this device adhere to

\item[{\code{enum scsi\_scan\_mode rescan}}] \leavevmode
passed to \code{scsi\_probe\_add\_lun()}

\end{description}

\textbf{Description}
\begin{quote}

Generally, scan from LUN 1 (LUN 0 is assumed to already have been
scanned) to some maximum lun until a LUN is found with no device
attached. Use the bflags to figure out any oddities.

Modifies sdevscan-\textgreater{}lun.
\end{quote}
\index{scsi\_report\_lun\_scan (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_report_lun_scan}\pysiglinewithargsret{int \bfcode{scsi\_report\_lun\_scan}}{struct scsi\_target *\emph{ starget}, blist\_flags\_t\emph{ bflags}, enum scsi\_scan\_mode\emph{ rescan}}{}
Scan using SCSI REPORT LUN results

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_target * starget}}] \leavevmode
which target

\item[{\code{blist\_flags\_t bflags}}] \leavevmode
Zero or a mix of BLIST\_NOLUN, BLIST\_REPORTLUN2, or BLIST\_NOREPORTLUN

\item[{\code{enum scsi\_scan\_mode rescan}}] \leavevmode
nonzero if we can skip code only needed on first scan

\end{description}

\textbf{Description}
\begin{quote}

Fast scanning for modern (SCSI-3) devices by sending a REPORT LUN command.
Scan the resulting list of LUNs by calling scsi\_probe\_and\_add\_lun.

If BLINK\_REPORTLUN2 is set, scan a target that supports more than 8
LUNs even if it's older than SCSI-3.
If BLIST\_NOREPORTLUN is set, return 1 always.
If BLIST\_NOLUN is set, return 0 always.
If starget-\textgreater{}no\_report\_luns is set, return 1 always.
\end{quote}

\textbf{Return}
\begin{quote}

0: scan completed (or no memory, so further scanning is futile)
1: could not scan with REPORT LUN
\end{quote}
\index{scsi\_prep\_async\_scan (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_prep_async_scan}\pysiglinewithargsret{struct async\_scan\_data * \bfcode{scsi\_prep\_async\_scan}}{struct Scsi\_Host *\emph{ shost}}{}
prepare for an async scan

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
the host which will be scanned

\end{description}

\textbf{Return}

a cookie to be passed to {\hyperref[driver\string-api/scsi:c.scsi_finish_async_scan]{\emph{\code{scsi\_finish\_async\_scan()}}}}

Tells the midlayer this host is going to do an asynchronous scan.
It reserves the host's position in the scanning list and ensures
that other asynchronous scans started after this one won't affect the
ordering of the discovered devices.
\index{scsi\_finish\_async\_scan (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_finish_async_scan}\pysiglinewithargsret{void \bfcode{scsi\_finish\_async\_scan}}{struct async\_scan\_data *\emph{ data}}{}
asynchronous scan has finished

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct async\_scan\_data * data}}] \leavevmode
cookie returned from earlier call to {\hyperref[driver\string-api/scsi:c.scsi_prep_async_scan]{\emph{\code{scsi\_prep\_async\_scan()}}}}

\end{description}

\textbf{Description}

All the devices currently attached to this host have been found.
This function announces all the devices it has found to the rest
of the system.


\subsubsection{drivers/scsi/scsi\_sysctl.c}
\label{driver-api/scsi:drivers-scsi-scsi-sysctl-c}
Set up the sysctl entry: ``/dev/scsi/logging\_level''
(DEV\_SCSI\_LOGGING\_LEVEL) which sets/returns scsi\_logging\_level.


\subsubsection{drivers/scsi/scsi\_sysfs.c}
\label{driver-api/scsi:drivers-scsi-scsi-sysfs-c}
SCSI sysfs interface routines.
\index{scsi\_remove\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_remove_device}\pysiglinewithargsret{void \bfcode{scsi\_remove\_device}}{struct scsi\_device *\emph{ sdev}}{}
unregister a device from the scsi bus

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
scsi\_device to unregister

\end{description}
\index{scsi\_remove\_target (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_remove_target}\pysiglinewithargsret{void \bfcode{scsi\_remove\_target}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
try to remove a target and all its devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
generic starget or parent of generic stargets to be removed

\end{description}

\textbf{Note}

This is slightly racy.  It is possible that if the user
requests the addition of another device then the target won't be
removed.


\subsubsection{drivers/scsi/hosts.c}
\label{driver-api/scsi:drivers-scsi-hosts-c}
mid to lowlevel SCSI driver interface
\index{scsi\_host\_set\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_host_set_state}\pysiglinewithargsret{int \bfcode{scsi\_host\_set\_state}}{struct Scsi\_Host *\emph{ shost}, enum scsi\_host\_state\emph{ state}}{}
Take the given host through the host state model.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
scsi host to change the state of.

\item[{\code{enum scsi\_host\_state state}}] \leavevmode
state to change to.

\end{description}

\textbf{Description}
\begin{quote}

Returns zero if unsuccessful or an error if the requested
transition is illegal.
\end{quote}
\index{scsi\_remove\_host (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_remove_host}\pysiglinewithargsret{void \bfcode{scsi\_remove\_host}}{struct Scsi\_Host *\emph{ shost}}{}
remove a scsi host

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
a pointer to a scsi host to remove

\end{description}
\index{scsi\_add\_host\_with\_dma (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_add_host_with_dma}\pysiglinewithargsret{int \bfcode{scsi\_add\_host\_with\_dma}}{struct Scsi\_Host *\emph{ shost}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dma\_dev}}{}
add a scsi host with dma device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
scsi host pointer to add

\item[{\code{struct device * dev}}] \leavevmode
a struct device of type scsi class

\item[{\code{struct device * dma\_dev}}] \leavevmode
dma device for the host

\end{description}

\textbf{Note}

You rarely need to worry about this unless you're in a
virtualised host environments, so use the simpler \code{scsi\_add\_host()}
function instead.
\begin{description}
\item[{Return value:}] \leavevmode
0 on success / != 0 for error

\end{description}
\index{scsi\_host\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_host_alloc}\pysiglinewithargsret{struct Scsi\_Host * \bfcode{scsi\_host\_alloc}}{struct scsi\_host\_template *\emph{ sht}, int\emph{ privsize}}{}
register a scsi host adapter instance.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_host\_template * sht}}] \leavevmode
pointer to scsi host template

\item[{\code{int privsize}}] \leavevmode
extra bytes to allocate for driver

\end{description}

\textbf{Note}
\begin{quote}

Allocate a new Scsi\_Host and perform basic initialization.
The host is not published to the scsi midlayer until scsi\_add\_host
is called.
\end{quote}
\begin{description}
\item[{Return value:}] \leavevmode
Pointer to a new Scsi\_Host

\end{description}
\index{scsi\_host\_lookup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_host_lookup}\pysiglinewithargsret{struct Scsi\_Host * \bfcode{scsi\_host\_lookup}}{unsigned short\emph{ hostnum}}{}
get a reference to a Scsi\_Host by host no

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned short hostnum}}] \leavevmode
host number to locate

\end{description}

\textbf{Description}
\begin{description}
\item[{Return value:}] \leavevmode
A pointer to located Scsi\_Host or NULL.

The caller must do a {\hyperref[driver\string-api/scsi:c.scsi_host_put]{\emph{\code{scsi\_host\_put()}}}} to drop the reference
that {\hyperref[driver\string-api/scsi:c.scsi_host_get]{\emph{\code{scsi\_host\_get()}}}} took. The {\hyperref[driver\string-api/infrastructure:c.put_device]{\emph{\code{put\_device()}}}} below dropped
the reference from {\hyperref[driver\string-api/infrastructure:c.class_find_device]{\emph{\code{class\_find\_device()}}}}.

\end{description}
\index{scsi\_host\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_host_get}\pysiglinewithargsret{struct Scsi\_Host * \bfcode{scsi\_host\_get}}{struct Scsi\_Host *\emph{ shost}}{}
inc a Scsi\_Host ref count

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
Pointer to Scsi\_Host to inc.

\end{description}
\index{scsi\_host\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_host_put}\pysiglinewithargsret{void \bfcode{scsi\_host\_put}}{struct Scsi\_Host *\emph{ shost}}{}
dec a Scsi\_Host ref count

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
Pointer to Scsi\_Host to dec.

\end{description}
\index{scsi\_queue\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_queue_work}\pysiglinewithargsret{int \bfcode{scsi\_queue\_work}}{struct Scsi\_Host *\emph{ shost}, struct work\_struct *\emph{ work}}{}
Queue work to the Scsi\_Host workqueue.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
Pointer to Scsi\_Host.

\item[{\code{struct work\_struct * work}}] \leavevmode
Work to queue for execution.

\end{description}

\textbf{Description}
\begin{description}
\item[{Return value:}] \leavevmode
1 - work queued for execution
0 - work is already queued
-EINVAL - work queue doesn't exist

\end{description}
\index{scsi\_flush\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_flush_work}\pysiglinewithargsret{void \bfcode{scsi\_flush\_work}}{struct Scsi\_Host *\emph{ shost}}{}
Flush a Scsi\_Host's workqueue.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
Pointer to Scsi\_Host.

\end{description}


\subsubsection{drivers/scsi/scsi\_common.c}
\label{driver-api/scsi:drivers-scsi-scsi-common-c}
general support functions
\index{scsi\_device\_type (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_device_type}\pysiglinewithargsret{const char * \bfcode{scsi\_device\_type}}{unsigned\emph{ type}}{}
Return 17-char string indicating device type.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned type}}] \leavevmode
type number to look up

\end{description}
\index{scsilun\_to\_int (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsilun_to_int}\pysiglinewithargsret{u64 \bfcode{scsilun\_to\_int}}{struct scsi\_lun *\emph{ scsilun}}{}
convert a scsi\_lun to an int

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_lun * scsilun}}] \leavevmode
struct scsi\_lun to be converted.

\end{description}

\textbf{Description}
\begin{quote}

Convert \textbf{scsilun} from a struct scsi\_lun to a four-byte host byte-ordered
integer, and return the result. The caller must check for
truncation before using this function.
\end{quote}

\textbf{Notes}
\begin{quote}

For a description of the LUN format, post SCSI-3 see the SCSI
Architecture Model, for SCSI-3 see the SCSI Controller Commands.

Given a struct scsi\_lun of: d2 04 0b 03 00 00 00 00, this function
returns the integer: 0x0b03d204

This encoding will return a standard integer LUN for LUNs smaller
than 256, which typically use a single level LUN structure with
addressing method 0.
\end{quote}
\index{int\_to\_scsilun (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.int_to_scsilun}\pysiglinewithargsret{void \bfcode{int\_to\_scsilun}}{u64\emph{ lun}, struct scsi\_lun *\emph{ scsilun}}{}
reverts an int into a scsi\_lun

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u64 lun}}] \leavevmode
integer to be reverted

\item[{\code{struct scsi\_lun * scsilun}}] \leavevmode
struct scsi\_lun to be set.

\end{description}

\textbf{Description}
\begin{quote}

Reverts the functionality of the scsilun\_to\_int, which packed
an 8-byte lun value into an int. This routine unpacks the int
back into the lun value.
\end{quote}

\textbf{Notes}
\begin{quote}

Given an integer : 0x0b03d204, this function returns a
struct scsi\_lun of: d2 04 0b 03 00 00 00 00
\end{quote}
\index{scsi\_normalize\_sense (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_normalize_sense}\pysiglinewithargsret{bool \bfcode{scsi\_normalize\_sense}}{const u8 *\emph{ sense\_buffer}, int\emph{ sb\_len}, struct scsi\_sense\_hdr *\emph{ sshdr}}{}
normalize main elements from either fixed or descriptor sense data format into a common format.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * sense\_buffer}}] \leavevmode
byte array containing sense data returned by device

\item[{\code{int sb\_len}}] \leavevmode
number of valid bytes in sense\_buffer

\item[{\code{struct scsi\_sense\_hdr * sshdr}}] \leavevmode
pointer to instance of structure that common
elements are written to.

\end{description}

\textbf{Notes}
\begin{quote}

The ``main elements'' from sense data are: response\_code, sense\_key,
asc, ascq and additional\_length (only for descriptor format).

Typically this function can be called after a device has
responded to a SCSI command with the CHECK\_CONDITION status.
\end{quote}
\begin{description}
\item[{Return value:}] \leavevmode
true if valid sense data information found, else false;

\end{description}
\index{scsi\_sense\_desc\_find (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_sense_desc_find}\pysiglinewithargsret{const u8 * \bfcode{scsi\_sense\_desc\_find}}{const u8 *\emph{ sense\_buffer}, int\emph{ sb\_len}, int\emph{ desc\_type}}{}
search for a given descriptor type in descriptor sense data format.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * sense\_buffer}}] \leavevmode
byte array of descriptor format sense data

\item[{\code{int sb\_len}}] \leavevmode
number of valid bytes in sense\_buffer

\item[{\code{int desc\_type}}] \leavevmode
value of descriptor type to find
(e.g. 0 -\textgreater{} information)

\end{description}

\textbf{Notes}
\begin{quote}

only valid when sense data is in descriptor format
\end{quote}
\begin{description}
\item[{Return value:}] \leavevmode
pointer to start of (first) descriptor if found else NULL

\end{description}
\index{scsi\_build\_sense\_buffer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_build_sense_buffer}\pysiglinewithargsret{void \bfcode{scsi\_build\_sense\_buffer}}{int\emph{ desc}, u8 *\emph{ buf}, u8\emph{ key}, u8\emph{ asc}, u8\emph{ ascq}}{}
build sense data in a buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int desc}}] \leavevmode
Sense format (non-zero == descriptor format,
0 == fixed format)

\item[{\code{u8 * buf}}] \leavevmode
Where to build sense data

\item[{\code{u8 key}}] \leavevmode
Sense key

\item[{\code{u8 asc}}] \leavevmode
Additional sense code

\item[{\code{u8 ascq}}] \leavevmode
Additional sense code qualifier

\end{description}
\index{scsi\_set\_sense\_information (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_set_sense_information}\pysiglinewithargsret{int \bfcode{scsi\_set\_sense\_information}}{u8 *\emph{ buf}, int\emph{ buf\_len}, u64\emph{ info}}{}
set the information field in a formatted sense data buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 * buf}}] \leavevmode
Where to build sense data

\item[{\code{int buf\_len}}] \leavevmode
buffer length

\item[{\code{u64 info}}] \leavevmode
64-bit information value to be set

\end{description}

\textbf{Description}
\begin{description}
\item[{Return value:}] \leavevmode
0 on success or -EINVAL for invalid sense buffer length

\end{description}
\index{scsi\_set\_sense\_field\_pointer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_set_sense_field_pointer}\pysiglinewithargsret{int \bfcode{scsi\_set\_sense\_field\_pointer}}{u8 *\emph{ buf}, int\emph{ buf\_len}, u16\emph{ fp}, u8\emph{ bp}, bool\emph{ cd}}{}
set the field pointer sense key specific information in a formatted sense data buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 * buf}}] \leavevmode
Where to build sense data

\item[{\code{int buf\_len}}] \leavevmode
buffer length

\item[{\code{u16 fp}}] \leavevmode
field pointer to be set

\item[{\code{u8 bp}}] \leavevmode
bit pointer to be set

\item[{\code{bool cd}}] \leavevmode
command/data bit

\end{description}

\textbf{Description}
\begin{description}
\item[{Return value:}] \leavevmode
0 on success or -EINVAL for invalid sense buffer length

\end{description}


\subsection{Transport classes}
\label{driver-api/scsi:transport-classes}
Transport classes are service libraries for drivers in the SCSI lower
layer, which expose transport attributes in sysfs.


\subsubsection{Fibre Channel transport}
\label{driver-api/scsi:fibre-channel-transport}
The file drivers/scsi/scsi\_transport\_fc.c defines transport attributes
for Fibre Channel.
\index{fc\_get\_event\_number (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.fc_get_event_number}\pysiglinewithargsret{u32 \bfcode{fc\_get\_event\_number}}{void}{}
Obtain the next sequential FC event number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Notes}
\begin{quote}

We could have inlined this, but it would have required fc\_event\_seq to
be exposed. For now, live with the subroutine call.
Atomic used to avoid lock/unlock...
\end{quote}
\index{fc\_host\_post\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.fc_host_post_event}\pysiglinewithargsret{void \bfcode{fc\_host\_post\_event}}{struct Scsi\_Host *\emph{ shost}, u32\emph{ event\_number}, enum fc\_host\_event\_code\emph{ event\_code}, u32\emph{ event\_data}}{}
called to post an even on an fc\_host.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
host the event occurred on

\item[{\code{u32 event\_number}}] \leavevmode
fc event number obtained from \code{get\_fc\_event\_number()}

\item[{\code{enum fc\_host\_event\_code event\_code}}] \leavevmode
fc\_host event being posted

\item[{\code{u32 event\_data}}] \leavevmode
32bits of data for the event being posted

\end{description}

\textbf{Notes}
\begin{quote}

This routine assumes no locks are held on entry.
\end{quote}
\index{fc\_host\_post\_vendor\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.fc_host_post_vendor_event}\pysiglinewithargsret{void \bfcode{fc\_host\_post\_vendor\_event}}{struct Scsi\_Host *\emph{ shost}, u32\emph{ event\_number}, u32\emph{ data\_len}, char *\emph{ data\_buf}, u64\emph{ vendor\_id}}{}
called to post a vendor unique event on an fc\_host

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
host the event occurred on

\item[{\code{u32 event\_number}}] \leavevmode
fc event number obtained from \code{get\_fc\_event\_number()}

\item[{\code{u32 data\_len}}] \leavevmode
amount, in bytes, of vendor unique data

\item[{\code{char * data\_buf}}] \leavevmode
pointer to vendor unique data

\item[{\code{u64 vendor\_id}}] \leavevmode
Vendor id

\end{description}

\textbf{Notes}
\begin{quote}

This routine assumes no locks are held on entry.
\end{quote}
\index{fc\_eh\_timed\_out (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.fc_eh_timed_out}\pysiglinewithargsret{enum blk\_eh\_timer\_return \bfcode{fc\_eh\_timed\_out}}{struct scsi\_cmnd *\emph{ scmd}}{}
FC Transport I/O timeout intercept handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * scmd}}] \leavevmode
The SCSI command which timed out

\end{description}

\textbf{Description}

This routine protects against error handlers getting invoked while a
rport is in a blocked state, typically due to a temporarily loss of
connectivity. If the error handlers are allowed to proceed, requests
to abort i/o, reset the target, etc will likely fail as there is no way
to communicate with the device to perform the requested function. These
failures may result in the midlayer taking the device offline, requiring
manual intervention to restore operation.

This routine, called whenever an i/o times out, validates the state of
the underlying rport. If the rport is blocked, it returns
EH\_RESET\_TIMER, which will continue to reschedule the timeout.
Eventually, either the device will return, or devloss\_tmo will fire,
and when the timeout then fires, it will be handled normally.
If the rport is not blocked, normal error handling continues.

\textbf{Notes}
\begin{quote}

This routine assumes no locks are held on entry.
\end{quote}
\index{fc\_remove\_host (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.fc_remove_host}\pysiglinewithargsret{void \bfcode{fc\_remove\_host}}{struct Scsi\_Host *\emph{ shost}}{}
called to terminate any fc\_transport-related elements for a scsi host.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
Which \code{Scsi\_Host}

\end{description}

\textbf{Description}

This routine is expected to be called immediately preceding the
a driver's call to {\hyperref[driver\string-api/scsi:c.scsi_remove_host]{\emph{\code{scsi\_remove\_host()}}}}.
\begin{description}
\item[{WARNING: A driver utilizing the fc\_transport, which fails to call}] \leavevmode
this routine prior to {\hyperref[driver\string-api/scsi:c.scsi_remove_host]{\emph{\code{scsi\_remove\_host()}}}}, will leave dangling
objects in /sys/class/fc\_remote\_ports. Access to any of these
objects can result in a system crash !!!

\end{description}

\textbf{Notes}
\begin{quote}

This routine assumes no locks are held on entry.
\end{quote}
\index{fc\_remote\_port\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.fc_remote_port_add}\pysiglinewithargsret{struct fc\_rport * \bfcode{fc\_remote\_port\_add}}{struct Scsi\_Host *\emph{ shost}, int\emph{ channel}, struct fc\_rport\_identifiers *\emph{ ids}}{}
notify fc transport of the existence of a remote FC port.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
scsi host the remote port is connected to.

\item[{\code{int channel}}] \leavevmode
Channel on shost port connected to.

\item[{\code{struct fc\_rport\_identifiers * ids}}] \leavevmode
The world wide names, fc address, and FC4 port
roles for the remote port.

\end{description}

\textbf{Description}

The LLDD calls this routine to notify the transport of the existence
of a remote port. The LLDD provides the unique identifiers (wwpn,wwn)
of the port, it's FC address (port\_id), and the FC4 roles that are
active for the port.

For ports that are FCP targets (aka scsi targets), the FC transport
maintains consistent target id bindings on behalf of the LLDD.
A consistent target id binding is an assignment of a target id to
a remote port identifier, which persists while the scsi host is
attached. The remote port can disappear, then later reappear, and
it's target id assignment remains the same. This allows for shifts
in FC addressing (if binding by wwpn or wwnn) with no apparent
changes to the scsi subsystem which is based on scsi host number and
target id values.  Bindings are only valid during the attachment of
the scsi host. If the host detaches, then later re-attaches, target
id bindings may change.

This routine is responsible for returning a remote port structure.
The routine will search the list of remote ports it maintains
internally on behalf of consistent target id mappings. If found, the
remote port structure will be reused. Otherwise, a new remote port
structure will be allocated.

Whenever a remote port is allocated, a new fc\_remote\_port class
device is created.

Should not be called from interrupt context.

\textbf{Notes}
\begin{quote}

This routine assumes no locks are held on entry.
\end{quote}
\index{fc\_remote\_port\_delete (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.fc_remote_port_delete}\pysiglinewithargsret{void \bfcode{fc\_remote\_port\_delete}}{struct fc\_rport *\emph{ rport}}{}
notifies the fc transport that a remote port is no longer in existence.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fc\_rport * rport}}] \leavevmode
The remote port that no longer exists

\end{description}

\textbf{Description}

The LLDD calls this routine to notify the transport that a remote
port is no longer part of the topology. Note: Although a port
may no longer be part of the topology, it may persist in the remote
ports displayed by the fc\_host. We do this under 2 conditions:
\begin{enumerate}
\item {} 
If the port was a scsi target, we delay its deletion by ``blocking'' it.
This allows the port to temporarily disappear, then reappear without
disrupting the SCSI device tree attached to it. During the ``blocked''
period the port will still exist.

\item {} 
If the port was a scsi target and disappears for longer than we
expect, we'll delete the port and the tear down the SCSI device tree
attached to it. However, we want to semi-persist the target id assigned
to that port if it eventually does exist. The port structure will
remain (although with minimal information) so that the target id
bindings also remain.

\end{enumerate}

If the remote port is not an FCP Target, it will be fully torn down
and deallocated, including the fc\_remote\_port class device.

If the remote port is an FCP Target, the port will be placed in a
temporary blocked state. From the LLDD's perspective, the rport no
longer exists. From the SCSI midlayer's perspective, the SCSI target
exists, but all sdevs on it are blocked from further I/O. The following
is then expected.
\begin{quote}

If the remote port does not return (signaled by a LLDD call to
{\hyperref[driver\string-api/scsi:c.fc_remote_port_add]{\emph{\code{fc\_remote\_port\_add()}}}}) within the dev\_loss\_tmo timeout, then the
scsi target is removed - killing all outstanding i/o and removing the
scsi devices attached to it. The port structure will be marked Not
Present and be partially cleared, leaving only enough information to
recognize the remote port relative to the scsi target id binding if
it later appears.  The port will remain as long as there is a valid
binding (e.g. until the user changes the binding type or unloads the
scsi host with the binding).

If the remote port returns within the dev\_loss\_tmo value (and matches
according to the target id binding type), the port structure will be
reused. If it is no longer a SCSI target, the target will be torn
down. If it continues to be a SCSI target, then the target will be
unblocked (allowing i/o to be resumed), and a scan will be activated
to ensure that all luns are detected.
\end{quote}

Called from normal process context only - cannot be called from interrupt.

\textbf{Notes}
\begin{quote}

This routine assumes no locks are held on entry.
\end{quote}
\index{fc\_remote\_port\_rolechg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.fc_remote_port_rolechg}\pysiglinewithargsret{void \bfcode{fc\_remote\_port\_rolechg}}{struct fc\_rport *\emph{ rport}, u32\emph{ roles}}{}
notifies the fc transport that the roles on a remote may have changed.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fc\_rport * rport}}] \leavevmode
The remote port that changed.

\item[{\code{u32 roles}}] \leavevmode
New roles for this port.

\end{description}

\textbf{Description}

The LLDD calls this routine to notify the transport that the
roles on a remote port may have changed. The largest effect of this is
if a port now becomes a FCP Target, it must be allocated a
scsi target id.  If the port is no longer a FCP target, any
scsi target id value assigned to it will persist in case the
role changes back to include FCP Target. No changes in the scsi
midlayer will be invoked if the role changes (in the expectation
that the role will be resumed. If it doesn't normal error processing
will take place).

Should not be called from interrupt context.

\textbf{Notes}
\begin{quote}

This routine assumes no locks are held on entry.
\end{quote}
\index{fc\_block\_rport (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.fc_block_rport}\pysiglinewithargsret{int \bfcode{fc\_block\_rport}}{struct fc\_rport *\emph{ rport}}{}
Block SCSI eh thread for blocked fc\_rport.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fc\_rport * rport}}] \leavevmode
Remote port that scsi\_eh is trying to recover.

\end{description}

\textbf{Description}

This routine can be called from a FC LLD scsi\_eh callback. It
blocks the scsi\_eh thread until the fc\_rport leaves the
FC\_PORTSTATE\_BLOCKED, or the fast\_io\_fail\_tmo fires. This is
necessary to avoid the scsi\_eh failing recovery actions for blocked
rports which would lead to offlined SCSI devices.

\textbf{Return}
\begin{description}
\item[{0 if the fc\_rport left the state FC\_PORTSTATE\_BLOCKED.}] \leavevmode
FAST\_IO\_FAIL if the fast\_io\_fail\_tmo fired, this should be
passed back to scsi\_eh.

\end{description}
\index{fc\_block\_scsi\_eh (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.fc_block_scsi_eh}\pysiglinewithargsret{int \bfcode{fc\_block\_scsi\_eh}}{struct scsi\_cmnd *\emph{ cmnd}}{}
Block SCSI eh thread for blocked fc\_rport

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * cmnd}}] \leavevmode
SCSI command that scsi\_eh is trying to recover

\end{description}

\textbf{Description}

This routine can be called from a FC LLD scsi\_eh callback. It
blocks the scsi\_eh thread until the fc\_rport leaves the
FC\_PORTSTATE\_BLOCKED, or the fast\_io\_fail\_tmo fires. This is
necessary to avoid the scsi\_eh failing recovery actions for blocked
rports which would lead to offlined SCSI devices.

\textbf{Return}
\begin{description}
\item[{0 if the fc\_rport left the state FC\_PORTSTATE\_BLOCKED.}] \leavevmode
FAST\_IO\_FAIL if the fast\_io\_fail\_tmo fired, this should be
passed back to scsi\_eh.

\end{description}
\index{fc\_vport\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.fc_vport_create}\pysiglinewithargsret{struct fc\_vport * \bfcode{fc\_vport\_create}}{struct Scsi\_Host *\emph{ shost}, int\emph{ channel}, struct fc\_vport\_identifiers *\emph{ ids}}{}
Admin App or LLDD requests creation of a vport

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
scsi host the virtual port is connected to.

\item[{\code{int channel}}] \leavevmode
channel on shost port connected to.

\item[{\code{struct fc\_vport\_identifiers * ids}}] \leavevmode
The world wide names, FC4 port roles, etc for
the virtual port.

\end{description}

\textbf{Notes}
\begin{quote}

This routine assumes no locks are held on entry.
\end{quote}
\index{fc\_vport\_terminate (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.fc_vport_terminate}\pysiglinewithargsret{int \bfcode{fc\_vport\_terminate}}{struct fc\_vport *\emph{ vport}}{}
Admin App or LLDD requests termination of a vport

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fc\_vport * vport}}] \leavevmode
fc\_vport to be terminated

\end{description}

\textbf{Description}

Calls the LLDD \code{vport\_delete()} function, then deallocates and removes
the vport from the shost and object tree.

\textbf{Notes}
\begin{quote}

This routine assumes no locks are held on entry.
\end{quote}


\subsubsection{iSCSI transport class}
\label{driver-api/scsi:iscsi-transport-class}
The file drivers/scsi/scsi\_transport\_iscsi.c defines transport
attributes for the iSCSI class, which sends SCSI packets over TCP/IP
connections.
\index{iscsi\_create\_flashnode\_sess (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.iscsi_create_flashnode_sess}\pysiglinewithargsret{struct iscsi\_bus\_flash\_session * \bfcode{iscsi\_create\_flashnode\_sess}}{struct Scsi\_Host *\emph{ shost}, int\emph{ index}, struct iscsi\_transport *\emph{ transport}, int\emph{ dd\_size}}{}
Add flashnode session entry in sysfs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
pointer to host data

\item[{\code{int index}}] \leavevmode
index of flashnode to add in sysfs

\item[{\code{struct iscsi\_transport * transport}}] \leavevmode
pointer to transport data

\item[{\code{int dd\_size}}] \leavevmode
total size to allocate

\end{description}

\textbf{Description}

Adds a sysfs entry for the flashnode session attributes

\textbf{Return}
\begin{quote}

pointer to allocated flashnode sess on success
\code{NULL} on failure
\end{quote}
\index{iscsi\_create\_flashnode\_conn (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.iscsi_create_flashnode_conn}\pysiglinewithargsret{struct iscsi\_bus\_flash\_conn * \bfcode{iscsi\_create\_flashnode\_conn}}{struct Scsi\_Host *\emph{ shost}, struct iscsi\_bus\_flash\_session *\emph{ fnode\_sess}, struct iscsi\_transport *\emph{ transport}, int\emph{ dd\_size}}{}
Add flashnode conn entry in sysfs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
pointer to host data

\item[{\code{struct iscsi\_bus\_flash\_session * fnode\_sess}}] \leavevmode
pointer to the parent flashnode session entry

\item[{\code{struct iscsi\_transport * transport}}] \leavevmode
pointer to transport data

\item[{\code{int dd\_size}}] \leavevmode
total size to allocate

\end{description}

\textbf{Description}

Adds a sysfs entry for the flashnode connection attributes

\textbf{Return}
\begin{quote}

pointer to allocated flashnode conn on success
\code{NULL} on failure
\end{quote}
\index{iscsi\_find\_flashnode\_sess (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.iscsi_find_flashnode_sess}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} * \bfcode{iscsi\_find\_flashnode\_sess}}{struct Scsi\_Host *\emph{ shost}, void *\emph{ data}, int (*fn) (struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}}\emph{ *dev}, void\emph{ *data}}{}
finds flashnode session entry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
pointer to host data

\item[{\code{void * data}}] \leavevmode
pointer to data containing value to use for comparison

\item[{\code{int (*)(struct device *dev, void *data) fn}}] \leavevmode
function pointer that does actual comparison

\end{description}

\textbf{Description}

Finds the flashnode session object comparing the data passed using logic
defined in passed function pointer

\textbf{Return}
\begin{quote}

pointer to found flashnode session device object on success
\code{NULL} on failure
\end{quote}
\index{iscsi\_find\_flashnode\_conn (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.iscsi_find_flashnode_conn}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} * \bfcode{iscsi\_find\_flashnode\_conn}}{struct iscsi\_bus\_flash\_session *\emph{ fnode\_sess}}{}
finds flashnode connection entry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iscsi\_bus\_flash\_session * fnode\_sess}}] \leavevmode
pointer to parent flashnode session entry

\end{description}

\textbf{Description}

Finds the flashnode connection object comparing the data passed using logic
defined in passed function pointer

\textbf{Return}
\begin{quote}

pointer to found flashnode connection device object on success
\code{NULL} on failure
\end{quote}
\index{iscsi\_destroy\_flashnode\_sess (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.iscsi_destroy_flashnode_sess}\pysiglinewithargsret{void \bfcode{iscsi\_destroy\_flashnode\_sess}}{struct iscsi\_bus\_flash\_session *\emph{ fnode\_sess}}{}
destroy flashnode session entry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iscsi\_bus\_flash\_session * fnode\_sess}}] \leavevmode
pointer to flashnode session entry to be destroyed

\end{description}

\textbf{Description}

Deletes the flashnode session entry and all children flashnode connection
entries from sysfs
\index{iscsi\_destroy\_all\_flashnode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.iscsi_destroy_all_flashnode}\pysiglinewithargsret{void \bfcode{iscsi\_destroy\_all\_flashnode}}{struct Scsi\_Host *\emph{ shost}}{}
destroy all flashnode session entries

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
pointer to host data

\end{description}

\textbf{Description}

Destroys all the flashnode session entries and all corresponding children
flashnode connection entries from sysfs
\index{iscsi\_scan\_finished (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.iscsi_scan_finished}\pysiglinewithargsret{int \bfcode{iscsi\_scan\_finished}}{struct Scsi\_Host *\emph{ shost}, unsigned long\emph{ time}}{}
helper to report when running scans are done

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
scsi host

\item[{\code{unsigned long time}}] \leavevmode
scan run time

\end{description}

\textbf{Description}

This function can be used by drives like qla4xxx to report to the scsi
layer when the scans it kicked off at module load time are done.
\index{iscsi\_block\_scsi\_eh (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.iscsi_block_scsi_eh}\pysiglinewithargsret{int \bfcode{iscsi\_block\_scsi\_eh}}{struct scsi\_cmnd *\emph{ cmd}}{}
block scsi eh until session state has transistioned

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * cmd}}] \leavevmode
scsi cmd passed to scsi eh handler

\end{description}

\textbf{Description}

If the session is down this function will wait for the recovery
timer to fire or for the session to be logged back in. If the
recovery timer fires then FAST\_IO\_FAIL is returned. The caller
should pass this error value to the scsi eh.
\index{iscsi\_unblock\_session (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.iscsi_unblock_session}\pysiglinewithargsret{void \bfcode{iscsi\_unblock\_session}}{struct iscsi\_cls\_session *\emph{ session}}{}
set a session as logged in and start IO.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iscsi\_cls\_session * session}}] \leavevmode
iscsi session

\end{description}

\textbf{Description}

Mark a session as ready to accept IO.
\index{iscsi\_create\_session (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.iscsi_create_session}\pysiglinewithargsret{struct iscsi\_cls\_session * \bfcode{iscsi\_create\_session}}{struct Scsi\_Host *\emph{ shost}, struct iscsi\_transport *\emph{ transport}, int\emph{ dd\_size}, unsigned int\emph{ target\_id}}{}
create iscsi class session

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
scsi host

\item[{\code{struct iscsi\_transport * transport}}] \leavevmode
iscsi transport

\item[{\code{int dd\_size}}] \leavevmode
private driver data size

\item[{\code{unsigned int target\_id}}] \leavevmode
which target

\end{description}

\textbf{Description}

This can be called from a LLD or iscsi\_transport.
\index{iscsi\_create\_conn (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.iscsi_create_conn}\pysiglinewithargsret{struct iscsi\_cls\_conn * \bfcode{iscsi\_create\_conn}}{struct iscsi\_cls\_session *\emph{ session}, int\emph{ dd\_size}, uint32\_t\emph{ cid}}{}
create iscsi class connection

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iscsi\_cls\_session * session}}] \leavevmode
iscsi cls session

\item[{\code{int dd\_size}}] \leavevmode
private driver data size

\item[{\code{uint32\_t cid}}] \leavevmode
connection id

\end{description}

\textbf{Description}

This can be called from a LLD or iscsi\_transport. The connection
is child of the session so cid must be unique for all connections
on the session.

Since we do not support MCS, cid will normally be zero. In some cases
for software iscsi we could be trying to preallocate a connection struct
in which case there could be two connection structs and cid would be
non-zero.
\index{iscsi\_destroy\_conn (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.iscsi_destroy_conn}\pysiglinewithargsret{int \bfcode{iscsi\_destroy\_conn}}{struct iscsi\_cls\_conn *\emph{ conn}}{}
destroy iscsi class connection

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iscsi\_cls\_conn * conn}}] \leavevmode
iscsi cls session

\end{description}

\textbf{Description}

This can be called from a LLD or iscsi\_transport.
\index{iscsi\_session\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.iscsi_session_event}\pysiglinewithargsret{int \bfcode{iscsi\_session\_event}}{struct iscsi\_cls\_session *\emph{ session}, enum iscsi\_uevent\_e\emph{ event}}{}
send session destr. completion event

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct iscsi\_cls\_session * session}}] \leavevmode
iscsi class session

\item[{\code{enum iscsi\_uevent\_e event}}] \leavevmode
type of event

\end{description}


\subsubsection{Serial Attached SCSI (SAS) transport class}
\label{driver-api/scsi:serial-attached-scsi-sas-transport-class}
The file drivers/scsi/scsi\_transport\_sas.c defines transport
attributes for Serial Attached SCSI, a variant of SATA aimed at large
high-end systems.

The SAS transport class contains common code to deal with SAS HBAs, an
aproximated representation of SAS topologies in the driver model, and
various sysfs attributes to expose these topologies and management
interfaces to userspace.

In addition to the basic SCSI core objects this transport class
introduces two additional intermediate objects: The SAS PHY as
represented by struct sas\_phy defines an ``outgoing'' PHY on a SAS HBA or
Expander, and the SAS remote PHY represented by struct sas\_rphy defines
an ``incoming'' PHY on a SAS Expander or end device. Note that this is
purely a software concept, the underlying hardware for a PHY and a
remote PHY is the exactly the same.

There is no concept of a SAS port in this code, users can see what PHYs
form a wide port based on the port\_identifier attribute, which is the
same for all PHYs in a port.
\index{sas\_remove\_children (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_remove_children}\pysiglinewithargsret{void \bfcode{sas\_remove\_children}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
tear down a devices SAS data structures

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device belonging to the sas object

\end{description}

\textbf{Description}

Removes all SAS PHYs and remote PHYs for a given object
\index{sas\_remove\_host (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_remove_host}\pysiglinewithargsret{void \bfcode{sas\_remove\_host}}{struct Scsi\_Host *\emph{ shost}}{}
tear down a Scsi\_Host's SAS data structures

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
Scsi Host that is torn down

\end{description}

\textbf{Description}

Removes all SAS PHYs and remote PHYs for a given Scsi\_Host and remove the
Scsi\_Host as well.

\textbf{Note}

Do not call {\hyperref[driver\string-api/scsi:c.scsi_remove_host]{\emph{\code{scsi\_remove\_host()}}}} on the Scsi\_Host any more, as it is
already removed.
\index{sas\_get\_address (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_get_address}\pysiglinewithargsret{u64 \bfcode{sas\_get\_address}}{struct scsi\_device *\emph{ sdev}}{}
return the SAS address of the device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
scsi device

\end{description}

\textbf{Description}

Returns the SAS address of the scsi device
\index{sas\_tlr\_supported (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_tlr_supported}\pysiglinewithargsret{unsigned int \bfcode{sas\_tlr\_supported}}{struct scsi\_device *\emph{ sdev}}{}
checking TLR bit in vpd 0x90

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
scsi device struct

\end{description}

\textbf{Description}

Check Transport Layer Retries are supported or not.
If vpd page 0x90 is present, TRL is supported.
\index{sas\_disable\_tlr (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_disable_tlr}\pysiglinewithargsret{void \bfcode{sas\_disable\_tlr}}{struct scsi\_device *\emph{ sdev}}{}
setting TLR flags

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
scsi device struct

\end{description}

\textbf{Description}

Seting tlr\_enabled flag to 0.
\index{sas\_enable\_tlr (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_enable_tlr}\pysiglinewithargsret{void \bfcode{sas\_enable\_tlr}}{struct scsi\_device *\emph{ sdev}}{}
setting TLR flags

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
scsi device struct

\end{description}

\textbf{Description}

Seting tlr\_enabled flag 1.
\index{sas\_phy\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_phy_alloc}\pysiglinewithargsret{struct sas\_phy * \bfcode{sas\_phy\_alloc}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ parent}, int\emph{ number}}{}
allocates and initialize a SAS PHY structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * parent}}] \leavevmode
Parent device

\item[{\code{int number}}] \leavevmode
Phy index

\end{description}

\textbf{Description}

Allocates an SAS PHY structure.  It will be added in the device tree
below the device specified by \textbf{parent}, which has to be either a Scsi\_Host
or sas\_rphy.

\textbf{Return}
\begin{quote}

SAS PHY allocated or \code{NULL} if the allocation failed.
\end{quote}
\index{sas\_phy\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_phy_add}\pysiglinewithargsret{int \bfcode{sas\_phy\_add}}{struct sas\_phy *\emph{ phy}}{}
add a SAS PHY to the device hierarchy

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sas\_phy * phy}}] \leavevmode
The PHY to be added

\end{description}

\textbf{Description}

Publishes a SAS PHY to the rest of the system.
\index{sas\_phy\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_phy_free}\pysiglinewithargsret{void \bfcode{sas\_phy\_free}}{struct sas\_phy *\emph{ phy}}{}
free a SAS PHY

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sas\_phy * phy}}] \leavevmode
SAS PHY to free

\end{description}

\textbf{Description}

Frees the specified SAS PHY.

\textbf{Note}
\begin{quote}

This function must only be called on a PHY that has not
successfully been added using {\hyperref[driver\string-api/scsi:c.sas_phy_add]{\emph{\code{sas\_phy\_add()}}}}.
\end{quote}
\index{sas\_phy\_delete (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_phy_delete}\pysiglinewithargsret{void \bfcode{sas\_phy\_delete}}{struct sas\_phy *\emph{ phy}}{}
remove SAS PHY

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sas\_phy * phy}}] \leavevmode
SAS PHY to remove

\end{description}

\textbf{Description}

Removes the specified SAS PHY.  If the SAS PHY has an
associated remote PHY it is removed before.
\index{scsi\_is\_sas\_phy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_is_sas_phy}\pysiglinewithargsret{int \bfcode{scsi\_is\_sas\_phy}}{const struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
check if a struct device represents a SAS PHY

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct device * dev}}] \leavevmode
device to check

\end{description}

\textbf{Return}
\begin{quote}

\code{1} if the device represents a SAS PHY, \code{0} else
\end{quote}
\index{sas\_port\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_port_add}\pysiglinewithargsret{int \bfcode{sas\_port\_add}}{struct sas\_port *\emph{ port}}{}
add a SAS port to the device hierarchy

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sas\_port * port}}] \leavevmode
port to be added

\end{description}

\textbf{Description}

publishes a port to the rest of the system
\index{sas\_port\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_port_free}\pysiglinewithargsret{void \bfcode{sas\_port\_free}}{struct sas\_port *\emph{ port}}{}
free a SAS PORT

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sas\_port * port}}] \leavevmode
SAS PORT to free

\end{description}

\textbf{Description}

Frees the specified SAS PORT.

\textbf{Note}
\begin{quote}

This function must only be called on a PORT that has not
successfully been added using {\hyperref[driver\string-api/scsi:c.sas_port_add]{\emph{\code{sas\_port\_add()}}}}.
\end{quote}
\index{sas\_port\_delete (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_port_delete}\pysiglinewithargsret{void \bfcode{sas\_port\_delete}}{struct sas\_port *\emph{ port}}{}
remove SAS PORT

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sas\_port * port}}] \leavevmode
SAS PORT to remove

\end{description}

\textbf{Description}

Removes the specified SAS PORT.  If the SAS PORT has an
associated phys, unlink them from the port as well.
\index{scsi\_is\_sas\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_is_sas_port}\pysiglinewithargsret{int \bfcode{scsi\_is\_sas\_port}}{const struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
check if a struct device represents a SAS port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct device * dev}}] \leavevmode
device to check

\end{description}

\textbf{Return}
\begin{quote}

\code{1} if the device represents a SAS Port, \code{0} else
\end{quote}
\index{sas\_port\_get\_phy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_port_get_phy}\pysiglinewithargsret{struct sas\_phy * \bfcode{sas\_port\_get\_phy}}{struct sas\_port *\emph{ port}}{}
try to take a reference on a port member

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sas\_port * port}}] \leavevmode
port to check

\end{description}
\index{sas\_port\_add\_phy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_port_add_phy}\pysiglinewithargsret{void \bfcode{sas\_port\_add\_phy}}{struct sas\_port *\emph{ port}, struct sas\_phy *\emph{ phy}}{}
add another phy to a port to form a wide port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sas\_port * port}}] \leavevmode
port to add the phy to

\item[{\code{struct sas\_phy * phy}}] \leavevmode
phy to add

\end{description}

\textbf{Description}

When a port is initially created, it is empty (has no phys).  All
ports must have at least one phy to operated, and all wide ports
must have at least two.  The current code makes no difference
between ports and wide ports, but the only object that can be
connected to a remote device is a port, so ports must be formed on
all devices with phys if they're connected to anything.
\index{sas\_port\_delete\_phy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_port_delete_phy}\pysiglinewithargsret{void \bfcode{sas\_port\_delete\_phy}}{struct sas\_port *\emph{ port}, struct sas\_phy *\emph{ phy}}{}
remove a phy from a port or wide port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sas\_port * port}}] \leavevmode
port to remove the phy from

\item[{\code{struct sas\_phy * phy}}] \leavevmode
phy to remove

\end{description}

\textbf{Description}

This operation is used for tearing down ports again.  It must be
done to every port or wide port before calling sas\_port\_delete.
\index{sas\_end\_device\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_end_device_alloc}\pysiglinewithargsret{struct sas\_rphy * \bfcode{sas\_end\_device\_alloc}}{struct sas\_port *\emph{ parent}}{}
allocate an rphy for an end device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sas\_port * parent}}] \leavevmode
which port

\end{description}

\textbf{Description}

Allocates an SAS remote PHY structure, connected to \textbf{parent}.

\textbf{Return}
\begin{quote}

SAS PHY allocated or \code{NULL} if the allocation failed.
\end{quote}
\index{sas\_expander\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_expander_alloc}\pysiglinewithargsret{struct sas\_rphy * \bfcode{sas\_expander\_alloc}}{struct sas\_port *\emph{ parent}, enum sas\_device\_type\emph{ type}}{}
allocate an rphy for an end device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sas\_port * parent}}] \leavevmode
which port

\item[{\code{enum sas\_device\_type type}}] \leavevmode
SAS\_EDGE\_EXPANDER\_DEVICE or SAS\_FANOUT\_EXPANDER\_DEVICE

\end{description}

\textbf{Description}

Allocates an SAS remote PHY structure, connected to \textbf{parent}.

\textbf{Return}
\begin{quote}

SAS PHY allocated or \code{NULL} if the allocation failed.
\end{quote}
\index{sas\_rphy\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_rphy_add}\pysiglinewithargsret{int \bfcode{sas\_rphy\_add}}{struct sas\_rphy *\emph{ rphy}}{}
add a SAS remote PHY to the device hierarchy

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sas\_rphy * rphy}}] \leavevmode
The remote PHY to be added

\end{description}

\textbf{Description}

Publishes a SAS remote PHY to the rest of the system.
\index{sas\_rphy\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_rphy_free}\pysiglinewithargsret{void \bfcode{sas\_rphy\_free}}{struct sas\_rphy *\emph{ rphy}}{}
free a SAS remote PHY

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sas\_rphy * rphy}}] \leavevmode
SAS remote PHY to free

\end{description}

\textbf{Description}

Frees the specified SAS remote PHY.

\textbf{Note}
\begin{quote}

This function must only be called on a remote
PHY that has not successfully been added using
{\hyperref[driver\string-api/scsi:c.sas_rphy_add]{\emph{\code{sas\_rphy\_add()}}}} (or has been {\hyperref[driver\string-api/scsi:c.sas_rphy_remove]{\emph{\code{sas\_rphy\_remove()}}}}`d)
\end{quote}
\index{sas\_rphy\_delete (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_rphy_delete}\pysiglinewithargsret{void \bfcode{sas\_rphy\_delete}}{struct sas\_rphy *\emph{ rphy}}{}
remove and free SAS remote PHY

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sas\_rphy * rphy}}] \leavevmode
SAS remote PHY to remove and free

\end{description}

\textbf{Description}

Removes the specified SAS remote PHY and frees it.
\index{sas\_rphy\_unlink (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_rphy_unlink}\pysiglinewithargsret{void \bfcode{sas\_rphy\_unlink}}{struct sas\_rphy *\emph{ rphy}}{}
unlink SAS remote PHY

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sas\_rphy * rphy}}] \leavevmode
SAS remote phy to unlink from its parent port

\end{description}

\textbf{Description}

Removes port reference to an rphy
\index{sas\_rphy\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_rphy_remove}\pysiglinewithargsret{void \bfcode{sas\_rphy\_remove}}{struct sas\_rphy *\emph{ rphy}}{}
remove SAS remote PHY

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sas\_rphy * rphy}}] \leavevmode
SAS remote phy to remove

\end{description}

\textbf{Description}

Removes the specified SAS remote PHY.
\index{scsi\_is\_sas\_rphy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.scsi_is_sas_rphy}\pysiglinewithargsret{int \bfcode{scsi\_is\_sas\_rphy}}{const struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
check if a struct device represents a SAS remote PHY

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct device * dev}}] \leavevmode
device to check

\end{description}

\textbf{Return}
\begin{quote}

\code{1} if the device represents a SAS remote PHY, \code{0} else
\end{quote}
\index{sas\_attach\_transport (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_attach_transport}\pysiglinewithargsret{struct scsi\_transport\_template * \bfcode{sas\_attach\_transport}}{struct sas\_function\_template *\emph{ ft}}{}
instantiate SAS transport template

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sas\_function\_template * ft}}] \leavevmode
SAS transport class function template

\end{description}
\index{sas\_release\_transport (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.sas_release_transport}\pysiglinewithargsret{void \bfcode{sas\_release\_transport}}{struct scsi\_transport\_template *\emph{ t}}{}
release SAS transport template instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_transport\_template * t}}] \leavevmode
transport template instance

\end{description}


\subsubsection{SATA transport class}
\label{driver-api/scsi:sata-transport-class}
The SATA transport is handled by libata, which has its own book of
documentation in this directory.


\subsubsection{Parallel SCSI (SPI) transport class}
\label{driver-api/scsi:parallel-scsi-spi-transport-class}
The file drivers/scsi/scsi\_transport\_spi.c defines transport
attributes for traditional (fast/wide/ultra) SCSI busses.
\index{spi\_schedule\_dv\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.spi_schedule_dv_device}\pysiglinewithargsret{void \bfcode{spi\_schedule\_dv\_device}}{struct scsi\_device *\emph{ sdev}}{}
schedule domain validation to occur on the device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
The device to validate

\end{description}

\textbf{Description}
\begin{quote}

Identical to \code{spi\_dv\_device()} above, except that the DV will be
scheduled to occur in a workqueue later.  All memory allocations
are atomic, so may be called from any context including those holding
SCSI locks.
\end{quote}
\index{spi\_display\_xfer\_agreement (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.spi_display_xfer_agreement}\pysiglinewithargsret{void \bfcode{spi\_display\_xfer\_agreement}}{struct scsi\_target *\emph{ starget}}{}
Print the current target transfer agreement

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_target * starget}}] \leavevmode
The target for which to display the agreement

\end{description}

\textbf{Description}

Each SPI port is required to maintain a transfer agreement for each
other port on the bus.  This function prints a one-line summary of
the current agreement; more detailed information is available in sysfs.
\index{spi\_populate\_tag\_msg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.spi_populate_tag_msg}\pysiglinewithargsret{int \bfcode{spi\_populate\_tag\_msg}}{unsigned char *\emph{ msg}, struct scsi\_cmnd *\emph{ cmd}}{}
place a tag message in a buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned char * msg}}] \leavevmode
pointer to the area to place the tag

\item[{\code{struct scsi\_cmnd * cmd}}] \leavevmode
pointer to the scsi command for the tag

\end{description}

\textbf{Notes}
\begin{quote}

designed to create the correct type of tag message for the
particular request.  Returns the size of the tag message.
May return 0 if TCQ is disabled for this device.
\end{quote}


\subsubsection{SCSI RDMA (SRP) transport class}
\label{driver-api/scsi:scsi-rdma-srp-transport-class}
The file drivers/scsi/scsi\_transport\_srp.c defines transport
attributes for SCSI over Remote Direct Memory Access.
\index{srp\_tmo\_valid (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.srp_tmo_valid}\pysiglinewithargsret{int \bfcode{srp\_tmo\_valid}}{int\emph{ reconnect\_delay}, int\emph{ fast\_io\_fail\_tmo}, long\emph{ dev\_loss\_tmo}}{}
check timeout combination validity

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int reconnect\_delay}}] \leavevmode
Reconnect delay in seconds.

\item[{\code{int fast\_io\_fail\_tmo}}] \leavevmode
Fast I/O fail timeout in seconds.

\item[{\code{long dev\_loss\_tmo}}] \leavevmode
Device loss timeout in seconds.

\end{description}

\textbf{Description}

The combination of the timeout parameters must be such that SCSI commands
are finished in a reasonable time. Hence do not allow the fast I/O fail
timeout to exceed SCSI\_DEVICE\_BLOCK\_MAX\_TIMEOUT nor allow dev\_loss\_tmo to
exceed that limit if failing I/O fast has been disabled. Furthermore, these
parameters must be such that multipath can detect failed paths timely.
Hence do not allow all three parameters to be disabled simultaneously.
\index{srp\_start\_tl\_fail\_timers (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.srp_start_tl_fail_timers}\pysiglinewithargsret{void \bfcode{srp\_start\_tl\_fail\_timers}}{struct srp\_rport *\emph{ rport}}{}
start the transport layer failure timers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct srp\_rport * rport}}] \leavevmode
SRP target port.

\end{description}

\textbf{Description}

Start the transport layer fast I/O failure and device loss timers. Do not
modify a timer that was already started.
\index{srp\_reconnect\_rport (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.srp_reconnect_rport}\pysiglinewithargsret{int \bfcode{srp\_reconnect\_rport}}{struct srp\_rport *\emph{ rport}}{}
reconnect to an SRP target port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct srp\_rport * rport}}] \leavevmode
SRP target port.

\end{description}

\textbf{Description}

Blocks SCSI command queueing before invoking \code{reconnect()} such that
\code{queuecommand()} won't be invoked concurrently with \code{reconnect()} from outside
the SCSI EH. This is important since a \code{reconnect()} implementation may
reallocate resources needed by \code{queuecommand()}.

\textbf{Notes}
\begin{itemize}
\item {} 
This function neither waits until outstanding requests have finished nor
tries to abort these. It is the responsibility of the \code{reconnect()}
function to finish outstanding commands before reconnecting to the target
port.

\item {} 
It is the responsibility of the caller to ensure that the resources
reallocated by the \code{reconnect()} function won't be used while this function
is in progress. One possible strategy is to invoke this function from
the context of the SCSI EH thread only. Another possible strategy is to
lock the rport mutex inside each SCSI LLD callback that can be invoked by
the SCSI EH (the scsi\_host\_template.eh\_*() functions and also the
scsi\_host\_template.:c:func:\emph{queuecommand()} function).

\end{itemize}
\index{srp\_timed\_out (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.srp_timed_out}\pysiglinewithargsret{enum blk\_eh\_timer\_return \bfcode{srp\_timed\_out}}{struct scsi\_cmnd *\emph{ scmd}}{}
SRP transport intercept of the SCSI timeout EH

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * scmd}}] \leavevmode
SCSI command.

\end{description}

\textbf{Description}

If a timeout occurs while an rport is in the blocked state, ask the SCSI
EH to continue waiting (BLK\_EH\_RESET\_TIMER). Otherwise let the SCSI core
handle the timeout (BLK\_EH\_NOT\_HANDLED).

\textbf{Note}

This function is called from soft-IRQ context and with the request
queue lock held.
\index{srp\_rport\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.srp_rport_get}\pysiglinewithargsret{void \bfcode{srp\_rport\_get}}{struct srp\_rport *\emph{ rport}}{}
increment rport reference count

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct srp\_rport * rport}}] \leavevmode
SRP target port.

\end{description}
\index{srp\_rport\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.srp_rport_put}\pysiglinewithargsret{void \bfcode{srp\_rport\_put}}{struct srp\_rport *\emph{ rport}}{}
decrement rport reference count

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct srp\_rport * rport}}] \leavevmode
SRP target port.

\end{description}
\index{srp\_rport\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.srp_rport_add}\pysiglinewithargsret{struct srp\_rport * \bfcode{srp\_rport\_add}}{struct Scsi\_Host *\emph{ shost}, struct srp\_rport\_identifiers *\emph{ ids}}{}
add a SRP remote port to the device hierarchy

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
scsi host the remote port is connected to.

\item[{\code{struct srp\_rport\_identifiers * ids}}] \leavevmode
The port id for the remote port.

\end{description}

\textbf{Description}

Publishes a port to the rest of the system.
\index{srp\_rport\_del (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.srp_rport_del}\pysiglinewithargsret{void \bfcode{srp\_rport\_del}}{struct srp\_rport *\emph{ rport}}{}
remove a SRP remote port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct srp\_rport * rport}}] \leavevmode
SRP remote port to remove

\end{description}

\textbf{Description}

Removes the specified SRP remote port.
\index{srp\_remove\_host (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.srp_remove_host}\pysiglinewithargsret{void \bfcode{srp\_remove\_host}}{struct Scsi\_Host *\emph{ shost}}{}
tear down a Scsi\_Host's SRP data structures

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
Scsi Host that is torn down

\end{description}

\textbf{Description}

Removes all SRP remote ports for a given Scsi\_Host.
Must be called just before scsi\_remove\_host for SRP HBAs.
\index{srp\_stop\_rport\_timers (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.srp_stop_rport_timers}\pysiglinewithargsret{void \bfcode{srp\_stop\_rport\_timers}}{struct srp\_rport *\emph{ rport}}{}
stop the transport layer recovery timers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct srp\_rport * rport}}] \leavevmode
SRP remote port for which to stop the timers.

\end{description}

\textbf{Description}

Must be called after {\hyperref[driver\string-api/scsi:c.srp_remove_host]{\emph{\code{srp\_remove\_host()}}}} and {\hyperref[driver\string-api/scsi:c.scsi_remove_host]{\emph{\code{scsi\_remove\_host()}}}}. The caller
must hold a reference on the rport (rport-\textgreater{}dev) and on the SCSI host
(rport-\textgreater{}dev.parent).
\index{srp\_attach\_transport (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.srp_attach_transport}\pysiglinewithargsret{struct scsi\_transport\_template * \bfcode{srp\_attach\_transport}}{struct srp\_function\_template *\emph{ ft}}{}
instantiate SRP transport template

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct srp\_function\_template * ft}}] \leavevmode
SRP transport class function template

\end{description}
\index{srp\_release\_transport (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/scsi:c.srp_release_transport}\pysiglinewithargsret{void \bfcode{srp\_release\_transport}}{struct scsi\_transport\_template *\emph{ t}}{}
release SRP transport template instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_transport\_template * t}}] \leavevmode
transport template instance

\end{description}


\section{SCSI lower layer}
\label{driver-api/scsi:scsi-lower-layer}

\subsection{Host Bus Adapter transport types}
\label{driver-api/scsi:host-bus-adapter-transport-types}
Many modern device controllers use the SCSI command set as a protocol to
communicate with their devices through many different types of physical
connections.

In SCSI language a bus capable of carrying SCSI commands is called a
``transport'', and a controller connecting to such a bus is called a ``host
bus adapter'' (HBA).


\subsubsection{Debug transport}
\label{driver-api/scsi:debug-transport}
The file drivers/scsi/scsi\_debug.c simulates a host adapter with a
variable number of disks (or disk like devices) attached, sharing a
common amount of RAM. Does a lot of checking to make sure that we are
not getting blocks mixed up, and panics the kernel if anything out of
the ordinary is seen.

To be more realistic, the simulated devices have the transport
attributes of SAS disks.

For documentation see \href{http://sg.danny.cz/sg/sdebug26.html}{http://sg.danny.cz/sg/sdebug26.html}


\subsubsection{todo}
\label{driver-api/scsi:todo}
Parallel (fast/wide/ultra) SCSI, USB, SATA, SAS, Fibre Channel,
FireWire, ATAPI devices, Infiniband, I2O, iSCSI, Parallel ports,
netlink...


\chapter{libATA Developer's Guide}
\label{driver-api/libata::doc}\label{driver-api/libata:libata-developer-s-guide}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Jeff Garzik

\end{description}\end{quote}


\section{Introduction}
\label{driver-api/libata:introduction}
libATA is a library used inside the Linux kernel to support ATA host
controllers and devices. libATA provides an ATA driver API, class
transports for ATA and ATAPI devices, and SCSI\textless{}-\textgreater{}ATA translation for ATA
devices according to the T10 SAT specification.

This Guide documents the libATA driver API, library functions, library
internals, and a couple sample ATA low-level drivers.


\section{libata Driver API}
\label{driver-api/libata:libata-driver-api}
\code{struct ata\_port\_operations}
is defined for every low-level libata
hardware driver, and it controls how the low-level driver interfaces
with the ATA and SCSI layers.

FIS-based drivers will hook into the system with \code{-\textgreater{}qc\_prep()} and
\code{-\textgreater{}qc\_issue()} high-level hooks. Hardware which behaves in a manner
similar to PCI IDE hardware may utilize several generic helpers,
defining at a bare minimum the bus I/O addresses of the ATA shadow
register blocks.


\subsection{\texttt{struct ata\_port\_operations}}
\label{driver-api/libata:struct-ata-port-operations}

\subsubsection{Disable ATA port}
\label{driver-api/libata:disable-ata-port}
\begin{Verbatim}[commandchars=\\\{\}]
void (*port\PYGZus{}disable) (struct ata\PYGZus{}port *);
\end{Verbatim}

Called from {\hyperref[driver\string-api/libata:c.ata_bus_probe]{\emph{\code{ata\_bus\_probe()}}}} error path, as well as when unregistering
from the SCSI module (rmmod, hot unplug). This function should do
whatever needs to be done to take the port out of use. In most cases,
\code{ata\_port\_disable()} can be used as this hook.

Called from {\hyperref[driver\string-api/libata:c.ata_bus_probe]{\emph{\code{ata\_bus\_probe()}}}} on a failed probe. Called from
\code{ata\_scsi\_release()}.


\subsubsection{Post-IDENTIFY device configuration}
\label{driver-api/libata:post-identify-device-configuration}
\begin{Verbatim}[commandchars=\\\{\}]
void (*dev\PYGZus{}config) (struct ata\PYGZus{}port *, struct ata\PYGZus{}device *);
\end{Verbatim}

Called after IDENTIFY {[}PACKET{]} DEVICE is issued to each device found.
Typically used to apply device-specific fixups prior to issue of SET
FEATURES - XFER MODE, and prior to operation.

This entry may be specified as NULL in ata\_port\_operations.


\subsubsection{Set PIO/DMA mode}
\label{driver-api/libata:set-pio-dma-mode}
\begin{Verbatim}[commandchars=\\\{\}]
void (*set\PYGZus{}piomode) (struct ata\PYGZus{}port *, struct ata\PYGZus{}device *);
void (*set\PYGZus{}dmamode) (struct ata\PYGZus{}port *, struct ata\PYGZus{}device *);
void (*post\PYGZus{}set\PYGZus{}mode) (struct ata\PYGZus{}port *);
unsigned int (*mode\PYGZus{}filter) (struct ata\PYGZus{}port *, struct ata\PYGZus{}device *, unsigned int);
\end{Verbatim}

Hooks called prior to the issue of SET FEATURES - XFER MODE command. The
optional \code{-\textgreater{}mode\_filter()} hook is called when libata has built a mask of
the possible modes. This is passed to the \code{-\textgreater{}mode\_filter()} function
which should return a mask of valid modes after filtering those
unsuitable due to hardware limits. It is not valid to use this interface
to add modes.

\code{dev-\textgreater{}pio\_mode} and \code{dev-\textgreater{}dma\_mode} are guaranteed to be valid when
\code{-\textgreater{}set\_piomode()} and when \code{-\textgreater{}set\_dmamode()} is called. The timings for
any other drive sharing the cable will also be valid at this point. That
is the library records the decisions for the modes of each drive on a
channel before it attempts to set any of them.

\code{-\textgreater{}post\_set\_mode()} is called unconditionally, after the SET FEATURES -
XFER MODE command completes successfully.

\code{-\textgreater{}set\_piomode()} is always called (if present), but \code{-\textgreater{}set\_dma\_mode()}
is only called if DMA is possible.


\subsubsection{Taskfile read/write}
\label{driver-api/libata:taskfile-read-write}
\begin{Verbatim}[commandchars=\\\{\}]
void (*sff\PYGZus{}tf\PYGZus{}load) (struct ata\PYGZus{}port *ap, struct ata\PYGZus{}taskfile *tf);
void (*sff\PYGZus{}tf\PYGZus{}read) (struct ata\PYGZus{}port *ap, struct ata\PYGZus{}taskfile *tf);
\end{Verbatim}

\code{-\textgreater{}tf\_load()} is called to load the given taskfile into hardware
registers / DMA buffers. \code{-\textgreater{}tf\_read()} is called to read the hardware
registers / DMA buffers, to obtain the current set of taskfile register
values. Most drivers for taskfile-based hardware (PIO or MMIO) use
\code{ata\_sff\_tf\_load()} and \code{ata\_sff\_tf\_read()} for these hooks.


\subsubsection{PIO data read/write}
\label{driver-api/libata:pio-data-read-write}
\begin{Verbatim}[commandchars=\\\{\}]
void (*sff\PYGZus{}data\PYGZus{}xfer) (struct ata\PYGZus{}device *, unsigned char *, unsigned int, int);
\end{Verbatim}

All bmdma-style drivers must implement this hook. This is the low-level
operation that actually copies the data bytes during a PIO data
transfer. Typically the driver will choose one of
\code{ata\_sff\_data\_xfer\_noirq()}, \code{ata\_sff\_data\_xfer()}, or
\code{ata\_sff\_data\_xfer32()}.


\subsubsection{ATA command execute}
\label{driver-api/libata:ata-command-execute}
\begin{Verbatim}[commandchars=\\\{\}]
void (*sff\PYGZus{}exec\PYGZus{}command)(struct ata\PYGZus{}port *ap, struct ata\PYGZus{}taskfile *tf);
\end{Verbatim}

causes an ATA command, previously loaded with \code{-\textgreater{}tf\_load()}, to be
initiated in hardware. Most drivers for taskfile-based hardware use
\code{ata\_sff\_exec\_command()} for this hook.


\subsubsection{Per-cmd ATAPI DMA capabilities filter}
\label{driver-api/libata:per-cmd-atapi-dma-capabilities-filter}
\begin{Verbatim}[commandchars=\\\{\}]
int (*check\PYGZus{}atapi\PYGZus{}dma) (struct ata\PYGZus{}queued\PYGZus{}cmd *qc);
\end{Verbatim}

Allow low-level driver to filter ATA PACKET commands, returning a status
indicating whether or not it is OK to use DMA for the supplied PACKET
command.

This hook may be specified as NULL, in which case libata will assume
that atapi dma can be supported.


\subsubsection{Read specific ATA shadow registers}
\label{driver-api/libata:read-specific-ata-shadow-registers}
\begin{Verbatim}[commandchars=\\\{\}]
u8   (*sff\PYGZus{}check\PYGZus{}status)(struct ata\PYGZus{}port *ap);
u8   (*sff\PYGZus{}check\PYGZus{}altstatus)(struct ata\PYGZus{}port *ap);
\end{Verbatim}

Reads the Status/AltStatus ATA shadow register from hardware. On some
hardware, reading the Status register has the side effect of clearing
the interrupt condition. Most drivers for taskfile-based hardware use
\code{ata\_sff\_check\_status()} for this hook.


\subsubsection{Write specific ATA shadow register}
\label{driver-api/libata:write-specific-ata-shadow-register}
\begin{Verbatim}[commandchars=\\\{\}]
void (*sff\PYGZus{}set\PYGZus{}devctl)(struct ata\PYGZus{}port *ap, u8 ctl);
\end{Verbatim}

Write the device control ATA shadow register to the hardware. Most
drivers don't need to define this.


\subsubsection{Select ATA device on bus}
\label{driver-api/libata:select-ata-device-on-bus}
\begin{Verbatim}[commandchars=\\\{\}]
void (*sff\PYGZus{}dev\PYGZus{}select)(struct ata\PYGZus{}port *ap, unsigned int device);
\end{Verbatim}

Issues the low-level hardware command(s) that causes one of N hardware
devices to be considered `selected' (active and available for use) on
the ATA bus. This generally has no meaning on FIS-based devices.

Most drivers for taskfile-based hardware use \code{ata\_sff\_dev\_select()} for
this hook.


\subsubsection{Private tuning method}
\label{driver-api/libata:private-tuning-method}
\begin{Verbatim}[commandchars=\\\{\}]
void (*set\PYGZus{}mode) (struct ata\PYGZus{}port *ap);
\end{Verbatim}

By default libata performs drive and controller tuning in accordance
with the ATA timing rules and also applies blacklists and cable limits.
Some controllers need special handling and have custom tuning rules,
typically raid controllers that use ATA commands but do not actually do
drive timing.
\begin{quote}

\textbf{Warning}

This hook should not be used to replace the standard controller
tuning logic when a controller has quirks. Replacing the default
tuning logic in that case would bypass handling for drive and bridge
quirks that may be important to data reliability. If a controller
needs to filter the mode selection it should use the mode\_filter
hook instead.
\end{quote}


\subsubsection{Control PCI IDE BMDMA engine}
\label{driver-api/libata:control-pci-ide-bmdma-engine}
\begin{Verbatim}[commandchars=\\\{\}]
void (*bmdma\PYGZus{}setup) (struct ata\PYGZus{}queued\PYGZus{}cmd *qc);
void (*bmdma\PYGZus{}start) (struct ata\PYGZus{}queued\PYGZus{}cmd *qc);
void (*bmdma\PYGZus{}stop) (struct ata\PYGZus{}port *ap);
u8   (*bmdma\PYGZus{}status) (struct ata\PYGZus{}port *ap);
\end{Verbatim}

When setting up an IDE BMDMA transaction, these hooks arm
(\code{-\textgreater{}bmdma\_setup}), fire (\code{-\textgreater{}bmdma\_start}), and halt (\code{-\textgreater{}bmdma\_stop}) the
hardware's DMA engine. \code{-\textgreater{}bmdma\_status} is used to read the standard PCI
IDE DMA Status register.

These hooks are typically either no-ops, or simply not implemented, in
FIS-based drivers.

Most legacy IDE drivers use \code{ata\_bmdma\_setup()} for the
\code{bmdma\_setup()} hook. \code{ata\_bmdma\_setup()} will write the pointer
to the PRD table to the IDE PRD Table Address register, enable DMA in the DMA
Command register, and call \code{exec\_command()} to begin the transfer.

Most legacy IDE drivers use \code{ata\_bmdma\_start()} for the
\code{bmdma\_start()} hook. \code{ata\_bmdma\_start()} will write the
ATA\_DMA\_START flag to the DMA Command register.

Many legacy IDE drivers use \code{ata\_bmdma\_stop()} for the
\code{bmdma\_stop()} hook. \code{ata\_bmdma\_stop()} clears the ATA\_DMA\_START
flag in the DMA command register.

Many legacy IDE drivers use \code{ata\_bmdma\_status()} as the
\code{bmdma\_status()} hook.


\subsubsection{High-level taskfile hooks}
\label{driver-api/libata:high-level-taskfile-hooks}
\begin{Verbatim}[commandchars=\\\{\}]
void (*qc\PYGZus{}prep) (struct ata\PYGZus{}queued\PYGZus{}cmd *qc);
int (*qc\PYGZus{}issue) (struct ata\PYGZus{}queued\PYGZus{}cmd *qc);
\end{Verbatim}

Higher-level hooks, these two hooks can potentially supercede several of
the above taskfile/DMA engine hooks. \code{-\textgreater{}qc\_prep} is called after the
buffers have been DMA-mapped, and is typically used to populate the
hardware's DMA scatter-gather table. Most drivers use the standard
\code{ata\_qc\_prep()} helper function, but more advanced drivers roll their
own.

\code{-\textgreater{}qc\_issue} is used to make a command active, once the hardware and S/G
tables have been prepared. IDE BMDMA drivers use the helper function
\code{ata\_qc\_issue\_prot()} for taskfile protocol-based dispatch. More
advanced drivers implement their own \code{-\textgreater{}qc\_issue}.

\code{ata\_qc\_issue\_prot()} calls \code{-\textgreater{}tf\_load()}, \code{-\textgreater{}bmdma\_setup()}, and
\code{-\textgreater{}bmdma\_start()} as necessary to initiate a transfer.


\subsubsection{Exception and probe handling (EH)}
\label{driver-api/libata:exception-and-probe-handling-eh}
\begin{Verbatim}[commandchars=\\\{\}]
void (*eng\PYGZus{}timeout) (struct ata\PYGZus{}port *ap);
void (*phy\PYGZus{}reset) (struct ata\PYGZus{}port *ap);
\end{Verbatim}

Deprecated. Use \code{-\textgreater{}error\_handler()} instead.

\begin{Verbatim}[commandchars=\\\{\}]
void (*freeze) (struct ata\PYGZus{}port *ap);
void (*thaw) (struct ata\PYGZus{}port *ap);
\end{Verbatim}

{\hyperref[driver\string-api/libata:c.ata_port_freeze]{\emph{\code{ata\_port\_freeze()}}}} is called when HSM violations or some other
condition disrupts normal operation of the port. A frozen port is not
allowed to perform any operation until the port is thawed, which usually
follows a successful reset.

The optional \code{-\textgreater{}freeze()} callback can be used for freezing the port
hardware-wise (e.g. mask interrupt and stop DMA engine). If a port
cannot be frozen hardware-wise, the interrupt handler must ack and clear
interrupts unconditionally while the port is frozen.

The optional \code{-\textgreater{}thaw()} callback is called to perform the opposite of
\code{-\textgreater{}freeze()}: prepare the port for normal operation once again. Unmask
interrupts, start DMA engine, etc.

\begin{Verbatim}[commandchars=\\\{\}]
void (*error\PYGZus{}handler) (struct ata\PYGZus{}port *ap);
\end{Verbatim}

\code{-\textgreater{}error\_handler()} is a driver's hook into probe, hotplug, and recovery
and other exceptional conditions. The primary responsibility of an
implementation is to call {\hyperref[driver\string-api/libata:c.ata_do_eh]{\emph{\code{ata\_do\_eh()}}}} or \code{ata\_bmdma\_drive\_eh()}
with a set of EH hooks as arguments:

`prereset' hook (may be NULL) is called during an EH reset, before any
other actions are taken.

`postreset' hook (may be NULL) is called after the EH reset is
performed. Based on existing conditions, severity of the problem, and
hardware capabilities,

Either `softreset' (may be NULL) or `hardreset' (may be NULL) will be
called to perform the low-level EH reset.

\begin{Verbatim}[commandchars=\\\{\}]
void (*post\PYGZus{}internal\PYGZus{}cmd) (struct ata\PYGZus{}queued\PYGZus{}cmd *qc);
\end{Verbatim}

Perform any hardware-specific actions necessary to finish processing
after executing a probe-time or EH-time command via
{\hyperref[driver\string-api/libata:c.ata_exec_internal]{\emph{\code{ata\_exec\_internal()}}}}.


\subsubsection{Hardware interrupt handling}
\label{driver-api/libata:hardware-interrupt-handling}
\begin{Verbatim}[commandchars=\\\{\}]
irqreturn\PYGZus{}t (*irq\PYGZus{}handler)(int, void *, struct pt\PYGZus{}regs *);
void (*irq\PYGZus{}clear) (struct ata\PYGZus{}port *);
\end{Verbatim}

\code{-\textgreater{}irq\_handler} is the interrupt handling routine registered with the
system, by libata. \code{-\textgreater{}irq\_clear} is called during probe just before the
interrupt handler is registered, to be sure hardware is quiet.

The second argument, dev\_instance, should be cast to a pointer to
\code{struct ata\_host\_set}.

Most legacy IDE drivers use \code{ata\_sff\_interrupt()} for the irq\_handler
hook, which scans all ports in the host\_set, determines which queued
command was active (if any), and calls ata\_sff\_host\_intr(ap,qc).

Most legacy IDE drivers use \code{ata\_sff\_irq\_clear()} for the
\code{irq\_clear()} hook, which simply clears the interrupt and error flags
in the DMA status register.


\subsubsection{SATA phy read/write}
\label{driver-api/libata:sata-phy-read-write}
\begin{Verbatim}[commandchars=\\\{\}]
int (*scr\PYGZus{}read) (struct ata\PYGZus{}port *ap, unsigned int sc\PYGZus{}reg,
         u32 *val);
int (*scr\PYGZus{}write) (struct ata\PYGZus{}port *ap, unsigned int sc\PYGZus{}reg,
                   u32 val);
\end{Verbatim}

Read and write standard SATA phy registers. Currently only used if
\code{-\textgreater{}phy\_reset} hook called the \code{sata\_phy\_reset()} helper function.
sc\_reg is one of SCR\_STATUS, SCR\_CONTROL, SCR\_ERROR, or SCR\_ACTIVE.


\subsubsection{Init and shutdown}
\label{driver-api/libata:init-and-shutdown}
\begin{Verbatim}[commandchars=\\\{\}]
int (*port\PYGZus{}start) (struct ata\PYGZus{}port *ap);
void (*port\PYGZus{}stop) (struct ata\PYGZus{}port *ap);
void (*host\PYGZus{}stop) (struct ata\PYGZus{}host\PYGZus{}set *host\PYGZus{}set);
\end{Verbatim}

\code{-\textgreater{}port\_start()} is called just after the data structures for each port
are initialized. Typically this is used to alloc per-port DMA buffers /
tables / rings, enable DMA engines, and similar tasks. Some drivers also
use this entry point as a chance to allocate driver-private memory for
\code{ap-\textgreater{}private\_data}.

Many drivers use \code{ata\_port\_start()} as this hook or call it from their
own \code{port\_start()} hooks. \code{ata\_port\_start()} allocates space for
a legacy IDE PRD table and returns.

\code{-\textgreater{}port\_stop()} is called after \code{-\textgreater{}host\_stop()}. Its sole function is to
release DMA/memory resources, now that they are no longer actively being
used. Many drivers also free driver-private data from port at this time.

\code{-\textgreater{}host\_stop()} is called after all \code{-\textgreater{}port\_stop()} calls have completed.
The hook must finalize hardware shutdown, release DMA and other
resources, etc. This hook may be specified as NULL, in which case it is
not called.


\section{Error handling}
\label{driver-api/libata:error-handling}
This chapter describes how errors are handled under libata. Readers are
advised to read SCSI EH (Documentation/scsi/scsi\_eh.txt) and ATA
exceptions doc first.


\subsection{Origins of commands}
\label{driver-api/libata:origins-of-commands}
In libata, a command is represented with
\code{struct ata\_queued\_cmd} or qc.
qc's are preallocated during port initialization and repetitively used
for command executions. Currently only one qc is allocated per port but
yet-to-be-merged NCQ branch allocates one for each tag and maps each qc
to NCQ tag 1-to-1.

libata commands can originate from two sources - libata itself and SCSI
midlayer. libata internal commands are used for initialization and error
handling. All normal blk requests and commands for SCSI emulation are
passed as SCSI commands through queuecommand callback of SCSI host
template.


\subsection{How commands are issued}
\label{driver-api/libata:how-commands-are-issued}\begin{description}
\item[{Internal commands}] \leavevmode
First, qc is allocated and initialized using {\hyperref[driver\string-api/libata:c.ata_qc_new_init]{\emph{\code{ata\_qc\_new\_init()}}}}.
Although {\hyperref[driver\string-api/libata:c.ata_qc_new_init]{\emph{\code{ata\_qc\_new\_init()}}}} doesn't implement any wait or retry
mechanism when qc is not available, internal commands are currently
issued only during initialization and error recovery, so no other
command is active and allocation is guaranteed to succeed.

Once allocated qc's taskfile is initialized for the command to be
executed. qc currently has two mechanisms to notify completion. One
is via \code{qc-\textgreater{}complete\_fn()} callback and the other is completion
\code{qc-\textgreater{}waiting}. \code{qc-\textgreater{}complete\_fn()} callback is the asynchronous path
used by normal SCSI translated commands and \code{qc-\textgreater{}waiting} is the
synchronous (issuer sleeps in process context) path used by internal
commands.

Once initialization is complete, host\_set lock is acquired and the
qc is issued.

\item[{SCSI commands}] \leavevmode
All libata drivers use {\hyperref[driver\string-api/libata:c.ata_scsi_queuecmd]{\emph{\code{ata\_scsi\_queuecmd()}}}} as
\code{hostt-\textgreater{}queuecommand} callback. scmds can either be simulated or
translated. No qc is involved in processing a simulated scmd. The
result is computed right away and the scmd is completed.

For a translated scmd, {\hyperref[driver\string-api/libata:c.ata_qc_new_init]{\emph{\code{ata\_qc\_new\_init()}}}} is invoked to allocate a
qc and the scmd is translated into the qc. SCSI midlayer's
completion notification function pointer is stored into
\code{qc-\textgreater{}scsidone}.

\code{qc-\textgreater{}complete\_fn()} callback is used for completion notification. ATA
commands use \code{ata\_scsi\_qc\_complete()} while ATAPI commands use
\code{atapi\_qc\_complete()}. Both functions end up calling \code{qc-\textgreater{}scsidone}
to notify upper layer when the qc is finished. After translation is
completed, the qc is issued with {\hyperref[driver\string-api/libata:c.ata_qc_issue]{\emph{\code{ata\_qc\_issue()}}}}.

Note that SCSI midlayer invokes hostt-\textgreater{}queuecommand while holding
host\_set lock, so all above occur while holding host\_set lock.

\end{description}


\subsection{How commands are processed}
\label{driver-api/libata:how-commands-are-processed}
Depending on which protocol and which controller are used, commands are
processed differently. For the purpose of discussion, a controller which
uses taskfile interface and all standard callbacks is assumed.

Currently 6 ATA command protocols are used. They can be sorted into the
following four categories according to how they are processed.
\begin{description}
\item[{ATA NO DATA or DMA}] \leavevmode
ATA\_PROT\_NODATA and ATA\_PROT\_DMA fall into this category. These
types of commands don't require any software intervention once
issued. Device will raise interrupt on completion.

\item[{ATA PIO}] \leavevmode
ATA\_PROT\_PIO is in this category. libata currently implements PIO
with polling. ATA\_NIEN bit is set to turn off interrupt and
pio\_task on ata\_wq performs polling and IO.

\item[{ATAPI NODATA or DMA}] \leavevmode
ATA\_PROT\_ATAPI\_NODATA and ATA\_PROT\_ATAPI\_DMA are in this
category. packet\_task is used to poll BSY bit after issuing PACKET
command. Once BSY is turned off by the device, packet\_task
transfers CDB and hands off processing to interrupt handler.

\item[{ATAPI PIO}] \leavevmode
ATA\_PROT\_ATAPI is in this category. ATA\_NIEN bit is set and, as
in ATAPI NODATA or DMA, packet\_task submits cdb. However, after
submitting cdb, further processing (data transfer) is handed off to
pio\_task.

\end{description}


\subsection{How commands are completed}
\label{driver-api/libata:how-commands-are-completed}
Once issued, all qc's are either completed with {\hyperref[driver\string-api/libata:c.ata_qc_complete]{\emph{\code{ata\_qc\_complete()}}}} or
time out. For commands which are handled by interrupts,
\code{ata\_host\_intr()} invokes {\hyperref[driver\string-api/libata:c.ata_qc_complete]{\emph{\code{ata\_qc\_complete()}}}}, and, for PIO tasks,
pio\_task invokes {\hyperref[driver\string-api/libata:c.ata_qc_complete]{\emph{\code{ata\_qc\_complete()}}}}. In error cases, packet\_task may
also complete commands.

{\hyperref[driver\string-api/libata:c.ata_qc_complete]{\emph{\code{ata\_qc\_complete()}}}} does the following.
\begin{enumerate}
\item {} 
DMA memory is unmapped.

\item {} 
ATA\_QCFLAG\_ACTIVE is cleared from qc-\textgreater{}flags.

\item {} 
\code{qc-\textgreater{}complete\_fn()} callback is invoked. If the return value of the
callback is not zero. Completion is short circuited and
{\hyperref[driver\string-api/libata:c.ata_qc_complete]{\emph{\code{ata\_qc\_complete()}}}} returns.

\item {} 
\code{\_\_ata\_qc\_complete()} is called, which does
\begin{enumerate}
\item {} 
\code{qc-\textgreater{}flags} is cleared to zero.

\item {} 
\code{ap-\textgreater{}active\_tag} and \code{qc-\textgreater{}tag} are poisoned.

\item {} 
\code{qc-\textgreater{}waiting} is cleared \& completed (in that order).

\item {} 
qc is deallocated by clearing appropriate bit in \code{ap-\textgreater{}qactive}.

\end{enumerate}

\end{enumerate}

So, it basically notifies upper layer and deallocates qc. One exception
is short-circuit path in \#3 which is used by \code{atapi\_qc\_complete()}.

For all non-ATAPI commands, whether it fails or not, almost the same
code path is taken and very little error handling takes place. A qc is
completed with success status if it succeeded, with failed status
otherwise.

However, failed ATAPI commands require more handling as REQUEST SENSE is
needed to acquire sense data. If an ATAPI command fails,
{\hyperref[driver\string-api/libata:c.ata_qc_complete]{\emph{\code{ata\_qc\_complete()}}}} is invoked with error status, which in turn invokes
\code{atapi\_qc\_complete()} via \code{qc-\textgreater{}complete\_fn()} callback.

This makes \code{atapi\_qc\_complete()} set \code{scmd-\textgreater{}result} to
SAM\_STAT\_CHECK\_CONDITION, complete the scmd and return 1. As the
sense data is empty but \code{scmd-\textgreater{}result} is CHECK CONDITION, SCSI midlayer
will invoke EH for the scmd, and returning 1 makes {\hyperref[driver\string-api/libata:c.ata_qc_complete]{\emph{\code{ata\_qc\_complete()}}}}
to return without deallocating the qc. This leads us to
{\hyperref[driver\string-api/libata:c.ata_scsi_error]{\emph{\code{ata\_scsi\_error()}}}} with partially completed qc.


\subsection{\texttt{ata\_scsi\_error()}}
\label{driver-api/libata:ata-scsi-error}
{\hyperref[driver\string-api/libata:c.ata_scsi_error]{\emph{\code{ata\_scsi\_error()}}}} is the current \code{transportt-\textgreater{}eh\_strategy\_handler()}
for libata. As discussed above, this will be entered in two cases -
timeout and ATAPI error completion. This function calls low level libata
driver's \code{eng\_timeout()} callback, the standard callback for which is
\code{ata\_eng\_timeout()}. It checks if a qc is active and calls
\code{ata\_qc\_timeout()} on the qc if so. Actual error handling occurs in
\code{ata\_qc\_timeout()}.

If EH is invoked for timeout, \code{ata\_qc\_timeout()} stops BMDMA and
completes the qc. Note that as we're currently in EH, we cannot call
scsi\_done. As described in SCSI EH doc, a recovered scmd should be
either retried with \code{scsi\_queue\_insert()} or finished with
\code{scsi\_finish\_command()}. Here, we override \code{qc-\textgreater{}scsidone} with
\code{scsi\_finish\_command()} and calls {\hyperref[driver\string-api/libata:c.ata_qc_complete]{\emph{\code{ata\_qc\_complete()}}}}.

If EH is invoked due to a failed ATAPI qc, the qc here is completed but
not deallocated. The purpose of this half-completion is to use the qc as
place holder to make EH code reach this place. This is a bit hackish,
but it works.

Once control reaches here, the qc is deallocated by invoking
\code{\_\_ata\_qc\_complete()} explicitly. Then, internal qc for REQUEST SENSE
is issued. Once sense data is acquired, scmd is finished by directly
invoking \code{scsi\_finish\_command()} on the scmd. Note that as we already
have completed and deallocated the qc which was associated with the
scmd, we don't need to/cannot call {\hyperref[driver\string-api/libata:c.ata_qc_complete]{\emph{\code{ata\_qc\_complete()}}}} again.


\subsection{Problems with the current EH}
\label{driver-api/libata:problems-with-the-current-eh}\begin{itemize}
\item {} 
Error representation is too crude. Currently any and all error
conditions are represented with ATA STATUS and ERROR registers.
Errors which aren't ATA device errors are treated as ATA device
errors by setting ATA\_ERR bit. Better error descriptor which can
properly represent ATA and other errors/exceptions is needed.

\item {} 
When handling timeouts, no action is taken to make device forget
about the timed out command and ready for new commands.

\item {} 
EH handling via {\hyperref[driver\string-api/libata:c.ata_scsi_error]{\emph{\code{ata\_scsi\_error()}}}} is not properly protected from
usual command processing. On EH entrance, the device is not in
quiescent state. Timed out commands may succeed or fail any time.
pio\_task and atapi\_task may still be running.

\item {} 
Too weak error recovery. Devices / controllers causing HSM mismatch
errors and other errors quite often require reset to return to known
state. Also, advanced error handling is necessary to support features
like NCQ and hotplug.

\item {} 
ATA errors are directly handled in the interrupt handler and PIO
errors in pio\_task. This is problematic for advanced error handling
for the following reasons.

First, advanced error handling often requires context and internal qc
execution.

Second, even a simple failure (say, CRC error) needs information
gathering and could trigger complex error handling (say, resetting \&
reconfiguring). Having multiple code paths to gather information,
enter EH and trigger actions makes life painful.

Third, scattered EH code makes implementing low level drivers
difficult. Low level drivers override libata callbacks. If EH is
scattered over several places, each affected callbacks should perform
its part of error handling. This can be error prone and painful.

\end{itemize}


\section{libata Library}
\label{driver-api/libata:libata-library}\index{ata\_link\_next (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_link_next}\pysiglinewithargsret{struct ata\_link * \bfcode{ata\_link\_next}}{struct ata\_link *\emph{ link}, struct ata\_port *\emph{ ap}, enum ata\_link\_iter\_mode\emph{ mode}}{}
link iteration helper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
the previous link, NULL to start

\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port containing links to iterate

\item[{\code{enum ata\_link\_iter\_mode mode}}] \leavevmode
iteration mode, one of ATA\_LITER\_*

\end{description}

\textbf{Description}
\begin{quote}

LOCKING:
Host lock or EH context.
\end{quote}

\textbf{Return}
\begin{quote}

Pointer to the next link.
\end{quote}
\index{ata\_dev\_next (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_dev_next}\pysiglinewithargsret{struct ata\_device * \bfcode{ata\_dev\_next}}{struct ata\_device *\emph{ dev}, struct ata\_link *\emph{ link}, enum ata\_dev\_iter\_mode\emph{ mode}}{}
device iteration helper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
the previous device, NULL to start

\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link containing devices to iterate

\item[{\code{enum ata\_dev\_iter\_mode mode}}] \leavevmode
iteration mode, one of ATA\_DITER\_*

\end{description}

\textbf{Description}
\begin{quote}

LOCKING:
Host lock or EH context.
\end{quote}

\textbf{Return}
\begin{quote}

Pointer to the next device.
\end{quote}
\index{atapi\_cmd\_type (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.atapi_cmd_type}\pysiglinewithargsret{int \bfcode{atapi\_cmd\_type}}{u8\emph{ opcode}}{}
Determine ATAPI command type from SCSI opcode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 opcode}}] \leavevmode
SCSI opcode

\end{description}

\textbf{Description}
\begin{quote}

Determine ATAPI command type from \textbf{opcode}.

LOCKING:
None.
\end{quote}

\textbf{Return}
\begin{quote}

ATAPI\_\{READ\textbar{}WRITE\textbar{}READ\_CD\textbar{}PASS\_THRU\textbar{}MISC\}
\end{quote}
\index{ata\_tf\_to\_fis (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_tf_to_fis}\pysiglinewithargsret{void \bfcode{ata\_tf\_to\_fis}}{const struct ata\_taskfile *\emph{ tf}, u8\emph{ pmp}, int\emph{ is\_cmd}, u8 *\emph{ fis}}{}
Convert ATA taskfile to SATA FIS structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct ata\_taskfile * tf}}] \leavevmode
Taskfile to convert

\item[{\code{u8 pmp}}] \leavevmode
Port multiplier port

\item[{\code{int is\_cmd}}] \leavevmode
This FIS is for command

\item[{\code{u8 * fis}}] \leavevmode
Buffer into which data will output

\end{description}

\textbf{Description}
\begin{quote}

Converts a standard ATA taskfile to a Serial ATA
FIS structure (Register - Host to Device).

LOCKING:
Inherited from caller.
\end{quote}
\index{ata\_tf\_from\_fis (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_tf_from_fis}\pysiglinewithargsret{void \bfcode{ata\_tf\_from\_fis}}{const u8 *\emph{ fis}, struct ata\_taskfile *\emph{ tf}}{}
Convert SATA FIS to ATA taskfile

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * fis}}] \leavevmode
Buffer from which data will be input

\item[{\code{struct ata\_taskfile * tf}}] \leavevmode
Taskfile to output

\end{description}

\textbf{Description}
\begin{quote}

Converts a serial ATA FIS structure to a standard ATA taskfile.

LOCKING:
Inherited from caller.
\end{quote}
\index{ata\_pack\_xfermask (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_pack_xfermask}\pysiglinewithargsret{unsigned long \bfcode{ata\_pack\_xfermask}}{unsigned long\emph{ pio\_mask}, unsigned long\emph{ mwdma\_mask}, unsigned long\emph{ udma\_mask}}{}
Pack pio, mwdma and udma masks into xfer\_mask

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long pio\_mask}}] \leavevmode
pio\_mask

\item[{\code{unsigned long mwdma\_mask}}] \leavevmode
mwdma\_mask

\item[{\code{unsigned long udma\_mask}}] \leavevmode
udma\_mask

\end{description}

\textbf{Description}
\begin{quote}

Pack \textbf{pio\_mask}, \textbf{mwdma\_mask} and \textbf{udma\_mask} into a single
unsigned int xfer\_mask.

LOCKING:
None.
\end{quote}

\textbf{Return}
\begin{quote}

Packed xfer\_mask.
\end{quote}
\index{ata\_unpack\_xfermask (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_unpack_xfermask}\pysiglinewithargsret{void \bfcode{ata\_unpack\_xfermask}}{unsigned long\emph{ xfer\_mask}, unsigned long *\emph{ pio\_mask}, unsigned long *\emph{ mwdma\_mask}, unsigned long *\emph{ udma\_mask}}{}
Unpack xfer\_mask into pio, mwdma and udma masks

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long xfer\_mask}}] \leavevmode
xfer\_mask to unpack

\item[{\code{unsigned long * pio\_mask}}] \leavevmode
resulting pio\_mask

\item[{\code{unsigned long * mwdma\_mask}}] \leavevmode
resulting mwdma\_mask

\item[{\code{unsigned long * udma\_mask}}] \leavevmode
resulting udma\_mask

\end{description}

\textbf{Description}
\begin{quote}

Unpack \textbf{xfer\_mask} into \textbf{pio\_mask}, \textbf{mwdma\_mask} and \textbf{udma\_mask}.
Any NULL destination masks will be ignored.
\end{quote}
\index{ata\_xfer\_mask2mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_xfer_mask2mode}\pysiglinewithargsret{u8 \bfcode{ata\_xfer\_mask2mode}}{unsigned long\emph{ xfer\_mask}}{}
Find matching XFER\_* for the given xfer\_mask

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long xfer\_mask}}] \leavevmode
xfer\_mask of interest

\end{description}

\textbf{Description}
\begin{quote}

Return matching XFER\_* value for \textbf{xfer\_mask}.  Only the highest
bit of \textbf{xfer\_mask} is considered.

LOCKING:
None.
\end{quote}

\textbf{Return}
\begin{quote}

Matching XFER\_* value, 0xff if no match found.
\end{quote}
\index{ata\_xfer\_mode2mask (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_xfer_mode2mask}\pysiglinewithargsret{unsigned long \bfcode{ata\_xfer\_mode2mask}}{u8\emph{ xfer\_mode}}{}
Find matching xfer\_mask for XFER\_*

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 xfer\_mode}}] \leavevmode
XFER\_* of interest

\end{description}

\textbf{Description}
\begin{quote}

Return matching xfer\_mask for \textbf{xfer\_mode}.

LOCKING:
None.
\end{quote}

\textbf{Return}
\begin{quote}

Matching xfer\_mask, 0 if no match found.
\end{quote}
\index{ata\_xfer\_mode2shift (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_xfer_mode2shift}\pysiglinewithargsret{int \bfcode{ata\_xfer\_mode2shift}}{unsigned long\emph{ xfer\_mode}}{}
Find matching xfer\_shift for XFER\_*

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long xfer\_mode}}] \leavevmode
XFER\_* of interest

\end{description}

\textbf{Description}
\begin{quote}

Return matching xfer\_shift for \textbf{xfer\_mode}.

LOCKING:
None.
\end{quote}

\textbf{Return}
\begin{quote}

Matching xfer\_shift, -1 if no match found.
\end{quote}
\index{ata\_mode\_string (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_mode_string}\pysiglinewithargsret{const char * \bfcode{ata\_mode\_string}}{unsigned long\emph{ xfer\_mask}}{}
convert xfer\_mask to string

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long xfer\_mask}}] \leavevmode
mask of bits supported; only highest bit counts.

\end{description}

\textbf{Description}
\begin{quote}

Determine string which represents the highest speed
(highest bit in \textbf{modemask}).

LOCKING:
None.
\end{quote}

\textbf{Return}
\begin{quote}

Constant C string representing highest speed listed in
\textbf{mode\_mask}, or the constant C string ``\textless{}n/a\textgreater{}''.
\end{quote}
\index{ata\_dev\_classify (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_dev_classify}\pysiglinewithargsret{unsigned int \bfcode{ata\_dev\_classify}}{const struct ata\_taskfile *\emph{ tf}}{}
determine device type based on ATA-spec signature

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct ata\_taskfile * tf}}] \leavevmode
ATA taskfile register set for device to be identified

\end{description}

\textbf{Description}
\begin{quote}

Determine from taskfile register contents whether a device is
ATA or ATAPI, as per ``Signature and persistence'' section
of ATA/PI spec (volume 1, sect 5.14).

LOCKING:
None.
\end{quote}

\textbf{Return}
\begin{quote}

Device type, \code{ATA\_DEV\_ATA}, \code{ATA\_DEV\_ATAPI}, \code{ATA\_DEV\_PMP},
\code{ATA\_DEV\_ZAC}, or \code{ATA\_DEV\_UNKNOWN} the event of failure.
\end{quote}
\index{ata\_id\_string (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_id_string}\pysiglinewithargsret{void \bfcode{ata\_id\_string}}{const u16 *\emph{ id}, unsigned char *\emph{ s}, unsigned int\emph{ ofs}, unsigned int\emph{ len}}{}
Convert IDENTIFY DEVICE page into string

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u16 * id}}] \leavevmode
IDENTIFY DEVICE results we will examine

\item[{\code{unsigned char * s}}] \leavevmode
string into which data is output

\item[{\code{unsigned int ofs}}] \leavevmode
offset into identify device page

\item[{\code{unsigned int len}}] \leavevmode
length of string to return. must be an even number.

\end{description}

\textbf{Description}
\begin{quote}

The strings in the IDENTIFY DEVICE page are broken up into
16-bit chunks.  Run through the string, and output each
8-bit chunk linearly, regardless of platform.

LOCKING:
caller.
\end{quote}
\index{ata\_id\_c\_string (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_id_c_string}\pysiglinewithargsret{void \bfcode{ata\_id\_c\_string}}{const u16 *\emph{ id}, unsigned char *\emph{ s}, unsigned int\emph{ ofs}, unsigned int\emph{ len}}{}
Convert IDENTIFY DEVICE page into C string

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u16 * id}}] \leavevmode
IDENTIFY DEVICE results we will examine

\item[{\code{unsigned char * s}}] \leavevmode
string into which data is output

\item[{\code{unsigned int ofs}}] \leavevmode
offset into identify device page

\item[{\code{unsigned int len}}] \leavevmode
length of string to return. must be an odd number.

\end{description}

\textbf{Description}
\begin{quote}

This function is identical to ata\_id\_string except that it
trims trailing spaces and terminates the resulting string with
null.  \textbf{len} must be actual maximum length (even number) + 1.

LOCKING:
caller.
\end{quote}
\index{ata\_id\_xfermask (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_id_xfermask}\pysiglinewithargsret{unsigned long \bfcode{ata\_id\_xfermask}}{const u16 *\emph{ id}}{}
Compute xfermask from the given IDENTIFY data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u16 * id}}] \leavevmode
IDENTIFY data to compute xfer mask from

\end{description}

\textbf{Description}
\begin{quote}

Compute the xfermask for this device. This is not as trivial
as it seems if we must consider early devices correctly.

FIXME: pre IDE drive timing (do we care ?).

LOCKING:
None.
\end{quote}

\textbf{Return}
\begin{quote}

Computed xfermask
\end{quote}
\index{ata\_pio\_need\_iordy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_pio_need_iordy}\pysiglinewithargsret{unsigned int \bfcode{ata\_pio\_need\_iordy}}{const struct ata\_device *\emph{ adev}}{}
check if iordy needed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct ata\_device * adev}}] \leavevmode
ATA device

\end{description}

\textbf{Description}
\begin{quote}

Check if the current speed of the device requires IORDY. Used
by various controllers for chip configuration.
\end{quote}
\index{ata\_do\_dev\_read\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_do_dev_read_id}\pysiglinewithargsret{unsigned int \bfcode{ata\_do\_dev\_read\_id}}{struct ata\_device *\emph{ dev}, struct ata\_taskfile *\emph{ tf}, u16 *\emph{ id}}{}
default ID read method

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
device

\item[{\code{struct ata\_taskfile * tf}}] \leavevmode
proposed taskfile

\item[{\code{u16 * id}}] \leavevmode
data buffer

\end{description}

\textbf{Description}
\begin{quote}

Issue the identify taskfile and hand back the buffer containing
identify data. For some RAID controllers and for pre ATA devices
this function is wrapped or replaced by the driver
\end{quote}
\index{ata\_cable\_40wire (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_cable_40wire}\pysiglinewithargsret{int \bfcode{ata\_cable\_40wire}}{struct ata\_port *\emph{ ap}}{}
return 40 wire cable type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
port

\end{description}

\textbf{Description}
\begin{quote}

Helper method for drivers which want to hardwire 40 wire cable
detection.
\end{quote}
\index{ata\_cable\_80wire (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_cable_80wire}\pysiglinewithargsret{int \bfcode{ata\_cable\_80wire}}{struct ata\_port *\emph{ ap}}{}
return 80 wire cable type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
port

\end{description}

\textbf{Description}
\begin{quote}

Helper method for drivers which want to hardwire 80 wire cable
detection.
\end{quote}
\index{ata\_cable\_unknown (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_cable_unknown}\pysiglinewithargsret{int \bfcode{ata\_cable\_unknown}}{struct ata\_port *\emph{ ap}}{}
return unknown PATA cable.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
port

\end{description}

\textbf{Description}
\begin{quote}

Helper method for drivers which have no PATA cable detection.
\end{quote}
\index{ata\_cable\_ignore (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_cable_ignore}\pysiglinewithargsret{int \bfcode{ata\_cable\_ignore}}{struct ata\_port *\emph{ ap}}{}
return ignored PATA cable.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
port

\end{description}

\textbf{Description}
\begin{quote}

Helper method for drivers which don't use cable type to limit
transfer mode.
\end{quote}
\index{ata\_cable\_sata (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_cable_sata}\pysiglinewithargsret{int \bfcode{ata\_cable\_sata}}{struct ata\_port *\emph{ ap}}{}
return SATA cable type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
port

\end{description}

\textbf{Description}
\begin{quote}

Helper method for drivers which have SATA cables
\end{quote}
\index{ata\_dev\_pair (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_dev_pair}\pysiglinewithargsret{struct ata\_device * \bfcode{ata\_dev\_pair}}{struct ata\_device *\emph{ adev}}{}
return other device on cable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * adev}}] \leavevmode
device

\end{description}

\textbf{Description}
\begin{quote}

Obtain the other device on the same cable, or if none is
present NULL is returned
\end{quote}
\index{sata\_set\_spd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sata_set_spd}\pysiglinewithargsret{int \bfcode{sata\_set\_spd}}{struct ata\_link *\emph{ link}}{}
set SATA spd according to spd limit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
Link to set SATA spd for

\end{description}

\textbf{Description}
\begin{quote}

Set SATA spd of \textbf{link} according to sata\_spd\_limit.

LOCKING:
Inherited from caller.
\end{quote}

\textbf{Return}
\begin{quote}

0 if spd doesn't need to be changed, 1 if spd has been
changed.  Negative errno if SCR registers are inaccessible.
\end{quote}
\index{ata\_timing\_cycle2mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_timing_cycle2mode}\pysiglinewithargsret{u8 \bfcode{ata\_timing\_cycle2mode}}{unsigned int\emph{ xfer\_shift}, int\emph{ cycle}}{}
find xfer mode for the specified cycle duration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int xfer\_shift}}] \leavevmode
ATA\_SHIFT\_* value for transfer type to examine.

\item[{\code{int cycle}}] \leavevmode
cycle duration in ns

\end{description}

\textbf{Description}
\begin{quote}

Return matching xfer mode for \textbf{cycle}.  The returned mode is of
the transfer type specified by \textbf{xfer\_shift}.  If \textbf{cycle} is too
slow for \textbf{xfer\_shift}, 0xff is returned.  If \textbf{cycle} is faster
than the fastest known mode, the fasted mode is returned.

LOCKING:
None.
\end{quote}

\textbf{Return}
\begin{quote}

Matching xfer\_mode, 0xff if no match found.
\end{quote}
\index{ata\_do\_set\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_do_set_mode}\pysiglinewithargsret{int \bfcode{ata\_do\_set\_mode}}{struct ata\_link *\emph{ link}, struct ata\_device **\emph{ r\_failed\_dev}}{}
Program timings and issue SET FEATURES - XFER

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
link on which timings will be programmed

\item[{\code{struct ata\_device ** r\_failed\_dev}}] \leavevmode
out parameter for failed device

\end{description}

\textbf{Description}
\begin{quote}

Standard implementation of the function used to tune and set
ATA device disk transfer mode (PIO3, UDMA6, etc.).  If
\code{ata\_dev\_set\_mode()} fails, pointer to the failing device is
returned in \textbf{r\_failed\_dev}.

LOCKING:
PCI/etc. bus probe sem.
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, negative errno otherwise
\end{quote}
\index{ata\_wait\_after\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_wait_after_reset}\pysiglinewithargsret{int \bfcode{ata\_wait\_after\_reset}}{struct ata\_link *\emph{ link}, unsigned long\emph{ deadline}, int (*check\_ready) (struct ata\_link\emph{ *link}}{}
wait for link to become ready after reset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
link to be waited on

\item[{\code{unsigned long deadline}}] \leavevmode
deadline jiffies for the operation

\item[{\code{int (*)(struct ata\_link *link) check\_ready}}] \leavevmode
callback to check link readiness

\end{description}

\textbf{Description}
\begin{quote}

Wait for \textbf{link} to become ready after reset.

LOCKING:
EH context.
\end{quote}

\textbf{Return}
\begin{quote}

0 if \textbf{link} is ready before \textbf{deadline}; otherwise, -errno.
\end{quote}
\index{sata\_link\_debounce (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sata_link_debounce}\pysiglinewithargsret{int \bfcode{sata\_link\_debounce}}{struct ata\_link *\emph{ link}, const unsigned long *\emph{ params}, unsigned long\emph{ deadline}}{}
debounce SATA phy status

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link to debounce SATA phy status for

\item[{\code{const unsigned long * params}}] \leavevmode
timing parameters \{ interval, duration, timeout \} in msec

\item[{\code{unsigned long deadline}}] \leavevmode
deadline jiffies for the operation

\end{description}

\textbf{Description}
\begin{quote}

Make sure SStatus of \textbf{link} reaches stable state, determined by
holding the same value where DET is not 1 for \textbf{duration} polled
every \textbf{interval}, before \textbf{timeout}.  Timeout constraints the
beginning of the stable state.  Because DET gets stuck at 1 on
some controllers after hot unplugging, this functions waits
until timeout then returns 0 if DET is stable at 1.

\textbf{timeout} is further limited by \textbf{deadline}.  The sooner of the
two is used.

LOCKING:
Kernel thread context (may sleep)
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -errno on failure.
\end{quote}
\index{sata\_link\_resume (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sata_link_resume}\pysiglinewithargsret{int \bfcode{sata\_link\_resume}}{struct ata\_link *\emph{ link}, const unsigned long *\emph{ params}, unsigned long\emph{ deadline}}{}
resume SATA link

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link to resume SATA

\item[{\code{const unsigned long * params}}] \leavevmode
timing parameters \{ interval, duration, timeout \} in msec

\item[{\code{unsigned long deadline}}] \leavevmode
deadline jiffies for the operation

\end{description}

\textbf{Description}
\begin{quote}

Resume SATA phy \textbf{link} and debounce it.

LOCKING:
Kernel thread context (may sleep)
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -errno on failure.
\end{quote}
\index{sata\_link\_scr\_lpm (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sata_link_scr_lpm}\pysiglinewithargsret{int \bfcode{sata\_link\_scr\_lpm}}{struct ata\_link *\emph{ link}, enum ata\_lpm\_policy\emph{ policy}, bool\emph{ spm\_wakeup}}{}
manipulate SControl IPM and SPM fields

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link to manipulate SControl for

\item[{\code{enum ata\_lpm\_policy policy}}] \leavevmode
LPM policy to configure

\item[{\code{bool spm\_wakeup}}] \leavevmode
initiate LPM transition to active state

\end{description}

\textbf{Description}
\begin{quote}

Manipulate the IPM field of the SControl register of \textbf{link}
according to \textbf{policy}.  If \textbf{policy} is ATA\_LPM\_MAX\_POWER and
\textbf{spm\_wakeup} is \code{true}, the SPM field is manipulated to wake up
the link.  This function also clears PHYRDY\_CHG before
returning.

LOCKING:
EH context.
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -errno otherwise.
\end{quote}
\index{ata\_std\_prereset (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_std_prereset}\pysiglinewithargsret{int \bfcode{ata\_std\_prereset}}{struct ata\_link *\emph{ link}, unsigned long\emph{ deadline}}{}
prepare for reset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link to be reset

\item[{\code{unsigned long deadline}}] \leavevmode
deadline jiffies for the operation

\end{description}

\textbf{Description}
\begin{quote}

\textbf{link} is about to be reset.  Initialize it.  Failure from
prereset makes libata abort whole reset sequence and give up
that port, so prereset should be best-effort.  It does its
best to prepare for reset sequence but if things go wrong, it
should just whine, not fail.

LOCKING:
Kernel thread context (may sleep)
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -errno otherwise.
\end{quote}
\index{sata\_link\_hardreset (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sata_link_hardreset}\pysiglinewithargsret{int \bfcode{sata\_link\_hardreset}}{struct ata\_link *\emph{ link}, const unsigned long *\emph{ timing}, unsigned long\emph{ deadline}, bool *\emph{ online}, int (*check\_ready) (struct ata\_link\emph{ *}}{}
reset link via SATA phy reset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
link to reset

\item[{\code{const unsigned long * timing}}] \leavevmode
timing parameters \{ interval, duration, timeout \} in msec

\item[{\code{unsigned long deadline}}] \leavevmode
deadline jiffies for the operation

\item[{\code{bool * online}}] \leavevmode
optional out parameter indicating link onlineness

\item[{\code{int (*)(struct ata\_link *) check\_ready}}] \leavevmode
optional callback to check link readiness

\end{description}

\textbf{Description}
\begin{quote}

SATA phy-reset \textbf{link} using DET bits of SControl register.
After hardreset, link readiness is waited upon using
{\hyperref[driver\string-api/libata:c.ata_wait_ready]{\emph{\code{ata\_wait\_ready()}}}} if \textbf{check\_ready} is specified.  LLDs are
allowed to not specify \textbf{check\_ready} and wait itself after this
function returns.  Device classification is LLD's
responsibility.

\textbf{*online} is set to one iff reset succeeded and \textbf{link} is online
after reset.

LOCKING:
Kernel thread context (may sleep)
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -errno otherwise.
\end{quote}
\index{sata\_std\_hardreset (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sata_std_hardreset}\pysiglinewithargsret{int \bfcode{sata\_std\_hardreset}}{struct ata\_link *\emph{ link}, unsigned int *\emph{ class}, unsigned long\emph{ deadline}}{}
COMRESET w/o waiting or classification

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
link to reset

\item[{\code{unsigned int * class}}] \leavevmode
resulting class of attached device

\item[{\code{unsigned long deadline}}] \leavevmode
deadline jiffies for the operation

\end{description}

\textbf{Description}
\begin{quote}

Standard SATA COMRESET w/o waiting or classification.

LOCKING:
Kernel thread context (may sleep)
\end{quote}

\textbf{Return}
\begin{quote}

0 if link offline, -EAGAIN if link online, -errno on errors.
\end{quote}
\index{ata\_std\_postreset (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_std_postreset}\pysiglinewithargsret{void \bfcode{ata\_std\_postreset}}{struct ata\_link *\emph{ link}, unsigned int *\emph{ classes}}{}
standard postreset callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
the target ata\_link

\item[{\code{unsigned int * classes}}] \leavevmode
classes of attached devices

\end{description}

\textbf{Description}
\begin{quote}

This function is invoked after a successful reset.  Note that
the device might have been reset more than once using
different reset methods before postreset is invoked.

LOCKING:
Kernel thread context (may sleep)
\end{quote}
\index{ata\_dev\_set\_feature (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_dev_set_feature}\pysiglinewithargsret{unsigned int \bfcode{ata\_dev\_set\_feature}}{struct ata\_device *\emph{ dev}, u8\emph{ enable}, u8\emph{ feature}}{}
Issue SET FEATURES - SATA FEATURES

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
Device to which command will be sent

\item[{\code{u8 enable}}] \leavevmode
Whether to enable or disable the feature

\item[{\code{u8 feature}}] \leavevmode
The sector count represents the feature to set

\end{description}

\textbf{Description}
\begin{quote}

Issue SET FEATURES - SATA FEATURES command to device \textbf{dev}
on port \textbf{ap} with sector count

LOCKING:
PCI/etc. bus probe sem.
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, AC\_ERR\_* mask otherwise.
\end{quote}
\index{ata\_std\_qc\_defer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_std_qc_defer}\pysiglinewithargsret{int \bfcode{ata\_std\_qc\_defer}}{struct ata\_queued\_cmd *\emph{ qc}}{}
Check whether a qc needs to be deferred

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
ATA command in question

\end{description}

\textbf{Description}
\begin{quote}

Non-NCQ commands cannot run with any other command, NCQ or
not.  As upper layer only knows the queue depth, we are
responsible for maintaining exclusion.  This function checks
whether a new command \textbf{qc} can be issued.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}

\textbf{Return}
\begin{quote}

ATA\_DEFER\_* if deferring is needed, 0 otherwise.
\end{quote}
\index{ata\_sg\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_sg_init}\pysiglinewithargsret{void \bfcode{ata\_sg\_init}}{struct ata\_queued\_cmd *\emph{ qc}, struct scatterlist *\emph{ sg}, unsigned int\emph{ n\_elem}}{}
Associate command with scatter-gather table.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Command to be associated

\item[{\code{struct scatterlist * sg}}] \leavevmode
Scatter-gather table.

\item[{\code{unsigned int n\_elem}}] \leavevmode
Number of elements in s/g table.

\end{description}

\textbf{Description}
\begin{quote}

Initialize the data-related elements of queued\_cmd \textbf{qc}
to point to a scatter-gather table \textbf{sg}, containing \textbf{n\_elem}
elements.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_qc\_complete (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_qc_complete}\pysiglinewithargsret{void \bfcode{ata\_qc\_complete}}{struct ata\_queued\_cmd *\emph{ qc}}{}
Complete an active ATA command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Command to complete

\end{description}

\textbf{Description}
\begin{quote}

Indicate to the mid and upper layers that an ATA command has
completed, with either an ok or not-ok status.

Refrain from calling this function multiple times when
successfully completing multiple NCQ commands.
{\hyperref[driver\string-api/libata:c.ata_qc_complete_multiple]{\emph{\code{ata\_qc\_complete\_multiple()}}}} should be used instead, which will
properly update IRQ expect state.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_qc\_complete\_multiple (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_qc_complete_multiple}\pysiglinewithargsret{int \bfcode{ata\_qc\_complete\_multiple}}{struct ata\_port *\emph{ ap}, u32\emph{ qc\_active}}{}
Complete multiple qcs successfully

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
port in question

\item[{\code{u32 qc\_active}}] \leavevmode
new qc\_active mask

\end{description}

\textbf{Description}
\begin{quote}

Complete in-flight commands.  This functions is meant to be
called from low-level driver's interrupt routine to complete
requests normally.  ap-\textgreater{}qc\_active and \textbf{qc\_active} is compared
and commands are completed accordingly.

Always use this function when completing multiple NCQ commands
from IRQ handlers instead of calling {\hyperref[driver\string-api/libata:c.ata_qc_complete]{\emph{\code{ata\_qc\_complete()}}}}
multiple times to keep IRQ expect status properly in sync.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}

\textbf{Return}
\begin{quote}

Number of completed commands on success, -errno otherwise.
\end{quote}
\index{sata\_scr\_valid (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sata_scr_valid}\pysiglinewithargsret{int \bfcode{sata\_scr\_valid}}{struct ata\_link *\emph{ link}}{}
test whether SCRs are accessible

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link to test SCR accessibility for

\end{description}

\textbf{Description}
\begin{quote}

Test whether SCRs are accessible for \textbf{link}.

LOCKING:
None.
\end{quote}

\textbf{Return}
\begin{quote}

1 if SCRs are accessible, 0 otherwise.
\end{quote}
\index{sata\_scr\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sata_scr_read}\pysiglinewithargsret{int \bfcode{sata\_scr\_read}}{struct ata\_link *\emph{ link}, int\emph{ reg}, u32 *\emph{ val}}{}
read SCR register of the specified port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link to read SCR for

\item[{\code{int reg}}] \leavevmode
SCR to read

\item[{\code{u32 * val}}] \leavevmode
Place to store read value

\end{description}

\textbf{Description}
\begin{quote}

Read SCR register \textbf{reg} of \textbf{link} into \textbf{*val}.  This function is
guaranteed to succeed if \textbf{link} is ap-\textgreater{}link, the cable type of
the port is SATA and the port implements -\textgreater{}scr\_read.

LOCKING:
None if \textbf{link} is ap-\textgreater{}link.  Kernel thread context otherwise.
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, negative errno on failure.
\end{quote}
\index{sata\_scr\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sata_scr_write}\pysiglinewithargsret{int \bfcode{sata\_scr\_write}}{struct ata\_link *\emph{ link}, int\emph{ reg}, u32\emph{ val}}{}
write SCR register of the specified port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link to write SCR for

\item[{\code{int reg}}] \leavevmode
SCR to write

\item[{\code{u32 val}}] \leavevmode
value to write

\end{description}

\textbf{Description}
\begin{quote}

Write \textbf{val} to SCR register \textbf{reg} of \textbf{link}.  This function is
guaranteed to succeed if \textbf{link} is ap-\textgreater{}link, the cable type of
the port is SATA and the port implements -\textgreater{}scr\_read.

LOCKING:
None if \textbf{link} is ap-\textgreater{}link.  Kernel thread context otherwise.
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, negative errno on failure.
\end{quote}
\index{sata\_scr\_write\_flush (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sata_scr_write_flush}\pysiglinewithargsret{int \bfcode{sata\_scr\_write\_flush}}{struct ata\_link *\emph{ link}, int\emph{ reg}, u32\emph{ val}}{}
write SCR register of the specified port and flush

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link to write SCR for

\item[{\code{int reg}}] \leavevmode
SCR to write

\item[{\code{u32 val}}] \leavevmode
value to write

\end{description}

\textbf{Description}
\begin{quote}

This function is identical to {\hyperref[driver\string-api/libata:c.sata_scr_write]{\emph{\code{sata\_scr\_write()}}}} except that this
function performs flush after writing to the register.

LOCKING:
None if \textbf{link} is ap-\textgreater{}link.  Kernel thread context otherwise.
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, negative errno on failure.
\end{quote}
\index{ata\_link\_online (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_link_online}\pysiglinewithargsret{bool \bfcode{ata\_link\_online}}{struct ata\_link *\emph{ link}}{}
test whether the given link is online

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link to test

\end{description}

\textbf{Description}
\begin{quote}

Test whether \textbf{link} is online.  This is identical to
{\hyperref[driver\string-api/libata:c.ata_phys_link_online]{\emph{\code{ata\_phys\_link\_online()}}}} when there's no slave link.  When
there's a slave link, this function should only be called on
the master link and will return true if any of M/S links is
online.

LOCKING:
None.
\end{quote}

\textbf{Return}
\begin{quote}

True if the port online status is available and online.
\end{quote}
\index{ata\_link\_offline (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_link_offline}\pysiglinewithargsret{bool \bfcode{ata\_link\_offline}}{struct ata\_link *\emph{ link}}{}
test whether the given link is offline

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link to test

\end{description}

\textbf{Description}
\begin{quote}

Test whether \textbf{link} is offline.  This is identical to
{\hyperref[driver\string-api/libata:c.ata_phys_link_offline]{\emph{\code{ata\_phys\_link\_offline()}}}} when there's no slave link.  When
there's a slave link, this function should only be called on
the master link and will return true if both M/S links are
offline.

LOCKING:
None.
\end{quote}

\textbf{Return}
\begin{quote}

True if the port offline status is available and offline.
\end{quote}
\index{ata\_host\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_host_suspend}\pysiglinewithargsret{int \bfcode{ata\_host\_suspend}}{struct ata\_host *\emph{ host}, pm\_message\_t\emph{ mesg}}{}
suspend host

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_host * host}}] \leavevmode
host to suspend

\item[{\code{pm\_message\_t mesg}}] \leavevmode
PM message

\end{description}

\textbf{Description}
\begin{quote}

Suspend \textbf{host}.  Actual operation is performed by port suspend.
\end{quote}
\index{ata\_host\_resume (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_host_resume}\pysiglinewithargsret{void \bfcode{ata\_host\_resume}}{struct ata\_host *\emph{ host}}{}
resume host

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_host * host}}] \leavevmode
host to resume

\end{description}

\textbf{Description}
\begin{quote}

Resume \textbf{host}.  Actual operation is performed by port resume.
\end{quote}
\index{ata\_host\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_host_alloc}\pysiglinewithargsret{struct ata\_host * \bfcode{ata\_host\_alloc}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, int\emph{ max\_ports}}{}
allocate and init basic ATA host resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
generic device this host is associated with

\item[{\code{int max\_ports}}] \leavevmode
maximum number of ATA ports associated with this host

\end{description}

\textbf{Description}
\begin{quote}

Allocate and initialize basic ATA host resources.  LLD calls
this function to allocate a host, initializes it fully and
attaches it using {\hyperref[driver\string-api/libata:c.ata_host_register]{\emph{\code{ata\_host\_register()}}}}.

\textbf{max\_ports} ports are allocated and host-\textgreater{}n\_ports is
initialized to \textbf{max\_ports}.  The caller is allowed to decrease
host-\textgreater{}n\_ports before calling {\hyperref[driver\string-api/libata:c.ata_host_register]{\emph{\code{ata\_host\_register()}}}}.  The unused
ports will be automatically freed on registration.
\end{quote}

\textbf{Return}
\begin{quote}

Allocate ATA host on success, NULL on failure.

LOCKING:
Inherited from calling layer (may sleep).
\end{quote}
\index{ata\_host\_alloc\_pinfo (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_host_alloc_pinfo}\pysiglinewithargsret{struct ata\_host * \bfcode{ata\_host\_alloc\_pinfo}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const struct ata\_port\_info *const *\emph{ ppi}, int\emph{ n\_ports}}{}
alloc host and init with port\_info array

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
generic device this host is associated with

\item[{\code{const struct ata\_port\_info *const * ppi}}] \leavevmode
array of ATA port\_info to initialize host with

\item[{\code{int n\_ports}}] \leavevmode
number of ATA ports attached to this host

\end{description}

\textbf{Description}
\begin{quote}

Allocate ATA host and initialize with info from \textbf{ppi}.  If NULL
terminated, \textbf{ppi} may contain fewer entries than \textbf{n\_ports}.  The
last entry will be used for the remaining ports.
\end{quote}

\textbf{Return}
\begin{quote}

Allocate ATA host on success, NULL on failure.

LOCKING:
Inherited from calling layer (may sleep).
\end{quote}
\index{ata\_slave\_link\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_slave_link_init}\pysiglinewithargsret{int \bfcode{ata\_slave\_link\_init}}{struct ata\_port *\emph{ ap}}{}
initialize slave link

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
port to initialize slave link for

\end{description}

\textbf{Description}
\begin{quote}

Create and initialize slave link for \textbf{ap}.  This enables slave
link handling on the port.

In libata, a port contains links and a link contains devices.
There is single host link but if a PMP is attached to it,
there can be multiple fan-out links.  On SATA, there's usually
a single device connected to a link but PATA and SATA
controllers emulating TF based interface can have two - master
and slave.

However, there are a few controllers which don't fit into this
abstraction too well - SATA controllers which emulate TF
interface with both master and slave devices but also have
separate SCR register sets for each device.  These controllers
need separate links for physical link handling
(e.g. onlineness, link speed) but should be treated like a
traditional M/S controller for everything else (e.g. command
issue, softreset).

slave\_link is libata's way of handling this class of
controllers without impacting core layer too much.  For
anything other than physical link handling, the default host
link is used for both master and slave.  For physical link
handling, separate \textbf{ap}-\textgreater{}slave\_link is used.  All dirty details
are implemented inside libata core layer.  From LLD's POV, the
only difference is that prereset, hardreset and postreset are
called once more for the slave link, so the reset sequence
looks like the following.

prereset(M) -\textgreater{} prereset(S) -\textgreater{} hardreset(M) -\textgreater{} hardreset(S) -\textgreater{}
softreset(M) -\textgreater{} postreset(M) -\textgreater{} postreset(S)

Note that softreset is called only for the master.  Softreset
resets both M/S by definition, so SRST on master should handle
both (the standard method will work just fine).

LOCKING:
Should be called before host is registered.
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -errno on failure.
\end{quote}
\index{ata\_host\_start (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_host_start}\pysiglinewithargsret{int \bfcode{ata\_host\_start}}{struct ata\_host *\emph{ host}}{}
start and freeze ports of an ATA host

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_host * host}}] \leavevmode
ATA host to start ports for

\end{description}

\textbf{Description}
\begin{quote}

Start and then freeze ports of \textbf{host}.  Started status is
recorded in host-\textgreater{}flags, so this function can be called
multiple times.  Ports are guaranteed to get started only
once.  If host-\textgreater{}ops isn't initialized yet, its set to the
first non-dummy port ops.

LOCKING:
Inherited from calling layer (may sleep).
\end{quote}

\textbf{Return}
\begin{quote}

0 if all ports are started successfully, -errno otherwise.
\end{quote}
\index{ata\_host\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_host_init}\pysiglinewithargsret{void \bfcode{ata\_host\_init}}{struct ata\_host *\emph{ host}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct ata\_port\_operations *\emph{ ops}}{}
Initialize a host struct for sas (ipr, libsas)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_host * host}}] \leavevmode
host to initialize

\item[{\code{struct device * dev}}] \leavevmode
device host is attached to

\item[{\code{struct ata\_port\_operations * ops}}] \leavevmode
port\_ops

\end{description}
\index{ata\_host\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_host_register}\pysiglinewithargsret{int \bfcode{ata\_host\_register}}{struct ata\_host *\emph{ host}, struct scsi\_host\_template *\emph{ sht}}{}
register initialized ATA host

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_host * host}}] \leavevmode
ATA host to register

\item[{\code{struct scsi\_host\_template * sht}}] \leavevmode
template for SCSI host

\end{description}

\textbf{Description}
\begin{quote}

Register initialized ATA host.  \textbf{host} is allocated using
{\hyperref[driver\string-api/libata:c.ata_host_alloc]{\emph{\code{ata\_host\_alloc()}}}} and fully initialized by LLD.  This function
starts ports, registers \textbf{host} with ATA and SCSI layers and
probe registered devices.

LOCKING:
Inherited from calling layer (may sleep).
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -errno otherwise.
\end{quote}
\index{ata\_host\_activate (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_host_activate}\pysiglinewithargsret{int \bfcode{ata\_host\_activate}}{struct ata\_host *\emph{ host}, int\emph{ irq}, irq\_handler\_t\emph{ irq\_handler}, unsigned long\emph{ irq\_flags}, struct scsi\_host\_template *\emph{ sht}}{}
start host, request IRQ and register it

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_host * host}}] \leavevmode
target ATA host

\item[{\code{int irq}}] \leavevmode
IRQ to request

\item[{\code{irq\_handler\_t irq\_handler}}] \leavevmode
irq\_handler used when requesting IRQ

\item[{\code{unsigned long irq\_flags}}] \leavevmode
irq\_flags used when requesting IRQ

\item[{\code{struct scsi\_host\_template * sht}}] \leavevmode
scsi\_host\_template to use when registering the host

\end{description}

\textbf{Description}
\begin{quote}

After allocating an ATA host and initializing it, most libata
LLDs perform three steps to activate the host - start host,
request IRQ and register it.  This helper takes necessary
arguments and performs the three steps in one go.

An invalid IRQ skips the IRQ registration and expects the host to
have set polling mode on the port. In this case, \textbf{irq\_handler}
should be NULL.

LOCKING:
Inherited from calling layer (may sleep).
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -errno otherwise.
\end{quote}
\index{ata\_host\_detach (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_host_detach}\pysiglinewithargsret{void \bfcode{ata\_host\_detach}}{struct ata\_host *\emph{ host}}{}
Detach all ports of an ATA host

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_host * host}}] \leavevmode
Host to detach

\end{description}

\textbf{Description}
\begin{quote}

Detach all ports of \textbf{host}.

LOCKING:
Kernel thread context (may sleep).
\end{quote}
\index{ata\_pci\_remove\_one (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_pci_remove_one}\pysiglinewithargsret{void \bfcode{ata\_pci\_remove\_one}}{struct pci\_dev *\emph{ pdev}}{}
PCI layer callback for device removal

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
PCI device that was removed

\end{description}

\textbf{Description}
\begin{quote}

PCI layer indicates to libata via this hook that hot-unplug or
module unload event has occurred.  Detach all ports.  Resource
release is handled via devres.

LOCKING:
Inherited from PCI layer (may sleep).
\end{quote}
\index{ata\_platform\_remove\_one (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_platform_remove_one}\pysiglinewithargsret{int \bfcode{ata\_platform\_remove\_one}}{struct platform\_device *\emph{ pdev}}{}
Platform layer callback for device removal

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_device * pdev}}] \leavevmode
Platform device that was removed

\end{description}

\textbf{Description}
\begin{quote}

Platform layer indicates to libata via this hook that hot-unplug or
module unload event has occurred.  Detach all ports.  Resource
release is handled via devres.

LOCKING:
Inherited from platform layer (may sleep).
\end{quote}
\index{ata\_msleep (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_msleep}\pysiglinewithargsret{void \bfcode{ata\_msleep}}{struct ata\_port *\emph{ ap}, unsigned int\emph{ msecs}}{}
ATA EH owner aware msleep

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to attribute the sleep to

\item[{\code{unsigned int msecs}}] \leavevmode
duration to sleep in milliseconds

\end{description}

\textbf{Description}
\begin{quote}

Sleeps \textbf{msecs}.  If the current task is owner of \textbf{ap}`s EH, the
ownership is released before going to sleep and reacquired
after the sleep is complete.  IOW, other ports sharing the
\textbf{ap}-\textgreater{}host will be allowed to own the EH while this task is
sleeping.

LOCKING:
Might sleep.
\end{quote}
\index{ata\_wait\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_wait_register}\pysiglinewithargsret{u32 \bfcode{ata\_wait\_register}}{struct ata\_port *\emph{ ap}, void \_\_iomem *\emph{ reg}, u32\emph{ mask}, u32\emph{ val}, unsigned long\emph{ interval}, unsigned long\emph{ timeout}}{}
wait until register value changes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to wait register for, can be NULL

\item[{\code{void \_\_iomem * reg}}] \leavevmode
IO-mapped register

\item[{\code{u32 mask}}] \leavevmode
Mask to apply to read register value

\item[{\code{u32 val}}] \leavevmode
Wait condition

\item[{\code{unsigned long interval}}] \leavevmode
polling interval in milliseconds

\item[{\code{unsigned long timeout}}] \leavevmode
timeout in milliseconds

\end{description}

\textbf{Description}
\begin{quote}

Waiting for some bits of register to change is a common
operation for ATA controllers.  This function reads 32bit LE
IO-mapped register \textbf{reg} and tests for the following condition.

(\textbf{*reg} \& mask) != val

If the condition is met, it returns; otherwise, the process is
repeated after \textbf{interval\_msec} until timeout.

LOCKING:
Kernel thread context (may sleep)
\end{quote}

\textbf{Return}
\begin{quote}

The final register value.
\end{quote}
\index{sata\_lpm\_ignore\_phy\_events (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sata_lpm_ignore_phy_events}\pysiglinewithargsret{bool \bfcode{sata\_lpm\_ignore\_phy\_events}}{struct ata\_link *\emph{ link}}{}
test if PHY event should be ignored

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
Link receiving the event

\end{description}

\textbf{Description}
\begin{quote}

Test whether the received PHY event has to be ignored or not.

LOCKING:
None:
\end{quote}

\textbf{Return}
\begin{quote}

True if the event has to be ignored.
\end{quote}


\section{libata Core Internals}
\label{driver-api/libata:libata-core-internals}\index{ata\_dev\_phys\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_dev_phys_link}\pysiglinewithargsret{struct ata\_link * \bfcode{ata\_dev\_phys\_link}}{struct ata\_device *\emph{ dev}}{}
find physical link for a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
ATA device to look up physical link for

\end{description}

\textbf{Description}
\begin{quote}

Look up physical link which \textbf{dev} is attached to.  Note that
this is different from \textbf{dev}-\textgreater{}link only when \textbf{dev} is on slave
link.  For all other cases, it's the same as \textbf{dev}-\textgreater{}link.

LOCKING:
Don't care.
\end{quote}

\textbf{Return}
\begin{quote}

Pointer to the found physical link.
\end{quote}
\index{ata\_force\_cbl (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_force_cbl}\pysiglinewithargsret{void \bfcode{ata\_force\_cbl}}{struct ata\_port *\emph{ ap}}{}
force cable type according to libata.force

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port of interest

\end{description}

\textbf{Description}
\begin{quote}

Force cable type according to libata.force and whine about it.
The last entry which has matching port number is used, so it
can be specified as part of device force parameters.  For
example, both ``a:40c,1.00:udma4'' and ``1.00:40c,udma4'' have the
same effect.

LOCKING:
EH context.
\end{quote}
\index{ata\_force\_link\_limits (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_force_link_limits}\pysiglinewithargsret{void \bfcode{ata\_force\_link\_limits}}{struct ata\_link *\emph{ link}}{}
force link limits according to libata.force

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link of interest

\end{description}

\textbf{Description}
\begin{quote}

Force link flags and SATA spd limit according to libata.force
and whine about it.  When only the port part is specified
(e.g. 1:), the limit applies to all links connected to both
the host link and all fan-out ports connected via PMP.  If the
device part is specified as 0 (e.g. 1.00:), it specifies the
first fan-out link not the host link.  Device number 15 always
points to the host link whether PMP is attached or not.  If the
controller has slave link, device number 16 points to it.

LOCKING:
EH context.
\end{quote}
\index{ata\_force\_xfermask (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_force_xfermask}\pysiglinewithargsret{void \bfcode{ata\_force\_xfermask}}{struct ata\_device *\emph{ dev}}{}
force xfermask according to libata.force

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
ATA device of interest

\end{description}

\textbf{Description}
\begin{quote}

Force xfer\_mask according to libata.force and whine about it.
For consistency with link selection, device number 15 selects
the first device connected to the host link.

LOCKING:
EH context.
\end{quote}
\index{ata\_force\_horkage (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_force_horkage}\pysiglinewithargsret{void \bfcode{ata\_force\_horkage}}{struct ata\_device *\emph{ dev}}{}
force horkage according to libata.force

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
ATA device of interest

\end{description}

\textbf{Description}
\begin{quote}

Force horkage according to libata.force and whine about it.
For consistency with link selection, device number 15 selects
the first device connected to the host link.

LOCKING:
EH context.
\end{quote}
\index{ata\_rwcmd\_protocol (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_rwcmd_protocol}\pysiglinewithargsret{int \bfcode{ata\_rwcmd\_protocol}}{struct ata\_taskfile *\emph{ tf}, struct ata\_device *\emph{ dev}}{}
set taskfile r/w commands and protocol

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_taskfile * tf}}] \leavevmode
command to examine and configure

\item[{\code{struct ata\_device * dev}}] \leavevmode
device tf belongs to

\end{description}

\textbf{Description}
\begin{quote}

Examine the device configuration and tf-\textgreater{}flags to calculate
the proper read/write commands and protocol to use.

LOCKING:
caller.
\end{quote}
\index{ata\_tf\_read\_block (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_tf_read_block}\pysiglinewithargsret{u64 \bfcode{ata\_tf\_read\_block}}{const struct ata\_taskfile *\emph{ tf}, struct ata\_device *\emph{ dev}}{}
Read block address from ATA taskfile

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct ata\_taskfile * tf}}] \leavevmode
ATA taskfile of interest

\item[{\code{struct ata\_device * dev}}] \leavevmode
ATA device \textbf{tf} belongs to

\end{description}

\textbf{Description}
\begin{quote}

LOCKING:
None.

Read block address from \textbf{tf}.  This function can handle all
three address formats - LBA, LBA48 and CHS.  tf-\textgreater{}protocol and
flags select the address format to use.
\end{quote}

\textbf{Return}
\begin{quote}

Block address read from \textbf{tf}.
\end{quote}
\index{ata\_build\_rw\_tf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_build_rw_tf}\pysiglinewithargsret{int \bfcode{ata\_build\_rw\_tf}}{struct ata\_taskfile *\emph{ tf}, struct ata\_device *\emph{ dev}, u64\emph{ block}, u32\emph{ n\_block}, unsigned int\emph{ tf\_flags}, unsigned int\emph{ tag}, int\emph{ class}}{}
Build ATA taskfile for given read/write request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_taskfile * tf}}] \leavevmode
Target ATA taskfile

\item[{\code{struct ata\_device * dev}}] \leavevmode
ATA device \textbf{tf} belongs to

\item[{\code{u64 block}}] \leavevmode
Block address

\item[{\code{u32 n\_block}}] \leavevmode
Number of blocks

\item[{\code{unsigned int tf\_flags}}] \leavevmode
RW/FUA etc...

\item[{\code{unsigned int tag}}] \leavevmode
tag

\item[{\code{int class}}] \leavevmode
IO priority class

\end{description}

\textbf{Description}
\begin{quote}

LOCKING:
None.

Build ATA taskfile \textbf{tf} for read/write request described by
\textbf{block}, \textbf{n\_block}, \textbf{tf\_flags} and \textbf{tag} on \textbf{dev}.
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -ERANGE if the request is too large for \textbf{dev},
-EINVAL if the request is invalid.
\end{quote}
\index{ata\_read\_native\_max\_address (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_read_native_max_address}\pysiglinewithargsret{int \bfcode{ata\_read\_native\_max\_address}}{struct ata\_device *\emph{ dev}, u64 *\emph{ max\_sectors}}{}
Read native max address

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
target device

\item[{\code{u64 * max\_sectors}}] \leavevmode
out parameter for the result native max address

\end{description}

\textbf{Description}
\begin{quote}

Perform an LBA48 or LBA28 native size query upon the device in
question.
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -EACCES if command is aborted by the drive.
-EIO on other errors.
\end{quote}
\index{ata\_set\_max\_sectors (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_set_max_sectors}\pysiglinewithargsret{int \bfcode{ata\_set\_max\_sectors}}{struct ata\_device *\emph{ dev}, u64\emph{ new\_sectors}}{}
Set max sectors

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
target device

\item[{\code{u64 new\_sectors}}] \leavevmode
new max sectors value to set for the device

\end{description}

\textbf{Description}
\begin{quote}

Set max sectors of \textbf{dev} to \textbf{new\_sectors}.
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -EACCES if command is aborted or denied (due to
previous non-volatile SET\_MAX) by the drive.  -EIO on other
errors.
\end{quote}
\index{ata\_hpa\_resize (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_hpa_resize}\pysiglinewithargsret{int \bfcode{ata\_hpa\_resize}}{struct ata\_device *\emph{ dev}}{}
Resize a device with an HPA set

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
Device to resize

\end{description}

\textbf{Description}
\begin{quote}

Read the size of an LBA28 or LBA48 disk with HPA features and resize
it if required to the full size of the media. The caller must check
the drive has the HPA feature set enabled.
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -errno on failure.
\end{quote}
\index{ata\_dump\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_dump_id}\pysiglinewithargsret{void \bfcode{ata\_dump\_id}}{const u16 *\emph{ id}}{}
IDENTIFY DEVICE info debugging output

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u16 * id}}] \leavevmode
IDENTIFY DEVICE page to dump

\end{description}

\textbf{Description}
\begin{quote}

Dump selected 16-bit words from the given IDENTIFY DEVICE
page.

LOCKING:
caller.
\end{quote}
\index{ata\_exec\_internal\_sg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_exec_internal_sg}\pysiglinewithargsret{unsigned \bfcode{ata\_exec\_internal\_sg}}{struct ata\_device *\emph{ dev}, struct ata\_taskfile *\emph{ tf}, const u8 *\emph{ cdb}, int\emph{ dma\_dir}, struct scatterlist *\emph{ sgl}, unsigned int\emph{ n\_elem}, unsigned long\emph{ timeout}}{}
execute libata internal command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
Device to which the command is sent

\item[{\code{struct ata\_taskfile * tf}}] \leavevmode
Taskfile registers for the command and the result

\item[{\code{const u8 * cdb}}] \leavevmode
CDB for packet command

\item[{\code{int dma\_dir}}] \leavevmode
Data transfer direction of the command

\item[{\code{struct scatterlist * sgl}}] \leavevmode
sg list for the data buffer of the command

\item[{\code{unsigned int n\_elem}}] \leavevmode
Number of sg entries

\item[{\code{unsigned long timeout}}] \leavevmode
Timeout in msecs (0 for default)

\end{description}

\textbf{Description}
\begin{quote}

Executes libata internal command with timeout.  \textbf{tf} contains
command on entry and result on return.  Timeout and error
conditions are reported via return value.  No recovery action
is taken after a command times out.  It's caller's duty to
clean up after timeout.

LOCKING:
None.  Should be called with kernel context, might sleep.
\end{quote}

\textbf{Return}
\begin{quote}

Zero on success, AC\_ERR\_* mask on failure
\end{quote}
\index{ata\_exec\_internal (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_exec_internal}\pysiglinewithargsret{unsigned \bfcode{ata\_exec\_internal}}{struct ata\_device *\emph{ dev}, struct ata\_taskfile *\emph{ tf}, const u8 *\emph{ cdb}, int\emph{ dma\_dir}, void *\emph{ buf}, unsigned int\emph{ buflen}, unsigned long\emph{ timeout}}{}
execute libata internal command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
Device to which the command is sent

\item[{\code{struct ata\_taskfile * tf}}] \leavevmode
Taskfile registers for the command and the result

\item[{\code{const u8 * cdb}}] \leavevmode
CDB for packet command

\item[{\code{int dma\_dir}}] \leavevmode
Data transfer direction of the command

\item[{\code{void * buf}}] \leavevmode
Data buffer of the command

\item[{\code{unsigned int buflen}}] \leavevmode
Length of data buffer

\item[{\code{unsigned long timeout}}] \leavevmode
Timeout in msecs (0 for default)

\end{description}

\textbf{Description}
\begin{quote}

Wrapper around {\hyperref[driver\string-api/libata:c.ata_exec_internal_sg]{\emph{\code{ata\_exec\_internal\_sg()}}}} which takes simple
buffer instead of sg list.

LOCKING:
None.  Should be called with kernel context, might sleep.
\end{quote}

\textbf{Return}
\begin{quote}

Zero on success, AC\_ERR\_* mask on failure
\end{quote}
\index{ata\_pio\_mask\_no\_iordy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_pio_mask_no_iordy}\pysiglinewithargsret{u32 \bfcode{ata\_pio\_mask\_no\_iordy}}{const struct ata\_device *\emph{ adev}}{}
Return the non IORDY mask

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct ata\_device * adev}}] \leavevmode
ATA device

\end{description}

\textbf{Description}
\begin{quote}

Compute the highest mode possible if we are not using iordy. Return
-1 if no iordy mode is available.
\end{quote}
\index{ata\_dev\_read\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_dev_read_id}\pysiglinewithargsret{int \bfcode{ata\_dev\_read\_id}}{struct ata\_device *\emph{ dev}, unsigned int *\emph{ p\_class}, unsigned int\emph{ flags}, u16 *\emph{ id}}{}
Read ID data from the specified device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
target device

\item[{\code{unsigned int * p\_class}}] \leavevmode
pointer to class of the target device (may be changed)

\item[{\code{unsigned int flags}}] \leavevmode
ATA\_READID\_* flags

\item[{\code{u16 * id}}] \leavevmode
buffer to read IDENTIFY data into

\end{description}

\textbf{Description}
\begin{quote}

Read ID data from the specified device.  ATA\_CMD\_ID\_ATA is
performed on ATA devices and ATA\_CMD\_ID\_ATAPI on ATAPI
devices.  This function also issues ATA\_CMD\_INIT\_DEV\_PARAMS
for pre-ATA4 drives.

FIXME: ATA\_CMD\_ID\_ATA is optional for early drives and right
now we abort if we hit that case.

LOCKING:
Kernel thread context (may sleep)
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -errno otherwise.
\end{quote}
\index{ata\_read\_log\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_read_log_page}\pysiglinewithargsret{unsigned int \bfcode{ata\_read\_log\_page}}{struct ata\_device *\emph{ dev}, u8\emph{ log}, u8\emph{ page}, void *\emph{ buf}, unsigned int\emph{ sectors}}{}
read a specific log page

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
target device

\item[{\code{u8 log}}] \leavevmode
log to read

\item[{\code{u8 page}}] \leavevmode
page to read

\item[{\code{void * buf}}] \leavevmode
buffer to store read page

\item[{\code{unsigned int sectors}}] \leavevmode
number of sectors to read

\end{description}

\textbf{Description}
\begin{quote}

Read log page using READ\_LOG\_EXT command.

LOCKING:
Kernel thread context (may sleep).
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, AC\_ERR\_* mask otherwise.
\end{quote}
\index{ata\_dev\_configure (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_dev_configure}\pysiglinewithargsret{int \bfcode{ata\_dev\_configure}}{struct ata\_device *\emph{ dev}}{}
Configure the specified ATA/ATAPI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
Target device to configure

\end{description}

\textbf{Description}
\begin{quote}

Configure \textbf{dev} according to \textbf{dev}-\textgreater{}id.  Generic and low-level
driver specific fixups are also applied.

LOCKING:
Kernel thread context (may sleep)
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -errno otherwise
\end{quote}
\index{ata\_bus\_probe (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_bus_probe}\pysiglinewithargsret{int \bfcode{ata\_bus\_probe}}{struct ata\_port *\emph{ ap}}{}
Reset and probe ATA bus

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
Bus to probe

\end{description}

\textbf{Description}
\begin{quote}

Master ATA bus probing function.  Initiates a hardware-dependent
bus reset, then attempts to identify any devices found on
the bus.

LOCKING:
PCI/etc. bus probe sem.
\end{quote}

\textbf{Return}
\begin{quote}

Zero on success, negative errno otherwise.
\end{quote}
\index{sata\_print\_link\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sata_print_link_status}\pysiglinewithargsret{void \bfcode{sata\_print\_link\_status}}{struct ata\_link *\emph{ link}}{}
Print SATA link status

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
SATA link to printk link status about

\end{description}

\textbf{Description}
\begin{quote}

This function prints link speed and status of a SATA link.

LOCKING:
None.
\end{quote}
\index{sata\_down\_spd\_limit (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sata_down_spd_limit}\pysiglinewithargsret{int \bfcode{sata\_down\_spd\_limit}}{struct ata\_link *\emph{ link}, u32\emph{ spd\_limit}}{}
adjust SATA spd limit downward

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
Link to adjust SATA spd limit for

\item[{\code{u32 spd\_limit}}] \leavevmode
Additional limit

\end{description}

\textbf{Description}
\begin{quote}

Adjust SATA spd limit of \textbf{link} downward.  Note that this
function only adjusts the limit.  The change must be applied
using {\hyperref[driver\string-api/libata:c.sata_set_spd]{\emph{\code{sata\_set\_spd()}}}}.

If \textbf{spd\_limit} is non-zero, the speed is limited to equal to or
lower than \textbf{spd\_limit} if such speed is supported.  If
\textbf{spd\_limit} is slower than any supported speed, only the lowest
supported speed is allowed.

LOCKING:
Inherited from caller.
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, negative errno on failure
\end{quote}
\index{sata\_set\_spd\_needed (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sata_set_spd_needed}\pysiglinewithargsret{int \bfcode{sata\_set\_spd\_needed}}{struct ata\_link *\emph{ link}}{}
is SATA spd configuration needed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
Link in question

\end{description}

\textbf{Description}
\begin{quote}

Test whether the spd limit in SControl matches
\textbf{link}-\textgreater{}sata\_spd\_limit.  This function is used to determine
whether hardreset is necessary to apply SATA spd
configuration.

LOCKING:
Inherited from caller.
\end{quote}

\textbf{Return}
\begin{quote}

1 if SATA spd configuration is needed, 0 otherwise.
\end{quote}
\index{ata\_down\_xfermask\_limit (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_down_xfermask_limit}\pysiglinewithargsret{int \bfcode{ata\_down\_xfermask\_limit}}{struct ata\_device *\emph{ dev}, unsigned int\emph{ sel}}{}
adjust dev xfer masks downward

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
Device to adjust xfer masks

\item[{\code{unsigned int sel}}] \leavevmode
ATA\_DNXFER\_* selector

\end{description}

\textbf{Description}
\begin{quote}

Adjust xfer masks of \textbf{dev} downward.  Note that this function
does not apply the change.  Invoking {\hyperref[driver\string-api/libata:c.ata_set_mode]{\emph{\code{ata\_set\_mode()}}}} afterwards
will apply the limit.

LOCKING:
Inherited from caller.
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, negative errno on failure
\end{quote}
\index{ata\_wait\_ready (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_wait_ready}\pysiglinewithargsret{int \bfcode{ata\_wait\_ready}}{struct ata\_link *\emph{ link}, unsigned long\emph{ deadline}, int (*check\_ready) (struct ata\_link\emph{ *link}}{}
wait for link to become ready

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
link to be waited on

\item[{\code{unsigned long deadline}}] \leavevmode
deadline jiffies for the operation

\item[{\code{int (*)(struct ata\_link *link) check\_ready}}] \leavevmode
callback to check link readiness

\end{description}

\textbf{Description}
\begin{quote}

Wait for \textbf{link} to become ready.  \textbf{check\_ready} should return
positive number if \textbf{link} is ready, 0 if it isn't, -ENODEV if
link doesn't seem to be occupied, other errno for other error
conditions.

Transient -ENODEV conditions are allowed for
ATA\_TMOUT\_FF\_WAIT.

LOCKING:
EH context.
\end{quote}

\textbf{Return}
\begin{quote}

0 if \textbf{link} is ready before \textbf{deadline}; otherwise, -errno.
\end{quote}
\index{ata\_dev\_same\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_dev_same_device}\pysiglinewithargsret{int \bfcode{ata\_dev\_same\_device}}{struct ata\_device *\emph{ dev}, unsigned int\emph{ new\_class}, const u16 *\emph{ new\_id}}{}
Determine whether new ID matches configured device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
device to compare against

\item[{\code{unsigned int new\_class}}] \leavevmode
class of the new device

\item[{\code{const u16 * new\_id}}] \leavevmode
IDENTIFY page of the new device

\end{description}

\textbf{Description}
\begin{quote}

Compare \textbf{new\_class} and \textbf{new\_id} against \textbf{dev} and determine
whether \textbf{dev} is the device indicated by \textbf{new\_class} and
\textbf{new\_id}.

LOCKING:
None.
\end{quote}

\textbf{Return}
\begin{quote}

1 if \textbf{dev} matches \textbf{new\_class} and \textbf{new\_id}, 0 otherwise.
\end{quote}
\index{ata\_dev\_reread\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_dev_reread_id}\pysiglinewithargsret{int \bfcode{ata\_dev\_reread\_id}}{struct ata\_device *\emph{ dev}, unsigned int\emph{ readid\_flags}}{}
Re-read IDENTIFY data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
target ATA device

\item[{\code{unsigned int readid\_flags}}] \leavevmode
read ID flags

\end{description}

\textbf{Description}
\begin{quote}

Re-read IDENTIFY page and make sure \textbf{dev} is still attached to
the port.

LOCKING:
Kernel thread context (may sleep)
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, negative errno otherwise
\end{quote}
\index{ata\_dev\_revalidate (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_dev_revalidate}\pysiglinewithargsret{int \bfcode{ata\_dev\_revalidate}}{struct ata\_device *\emph{ dev}, unsigned int\emph{ new\_class}, unsigned int\emph{ readid\_flags}}{}
Revalidate ATA device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
device to revalidate

\item[{\code{unsigned int new\_class}}] \leavevmode
new class code

\item[{\code{unsigned int readid\_flags}}] \leavevmode
read ID flags

\end{description}

\textbf{Description}
\begin{quote}

Re-read IDENTIFY page, make sure \textbf{dev} is still attached to the
port and reconfigure it according to the new IDENTIFY page.

LOCKING:
Kernel thread context (may sleep)
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, negative errno otherwise
\end{quote}
\index{ata\_is\_40wire (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_is_40wire}\pysiglinewithargsret{int \bfcode{ata\_is\_40wire}}{struct ata\_device *\emph{ dev}}{}
check drive side detection

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
device

\end{description}

\textbf{Description}
\begin{quote}

Perform drive side detection decoding, allowing for device vendors
who can't follow the documentation.
\end{quote}
\index{cable\_is\_40wire (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.cable_is_40wire}\pysiglinewithargsret{int \bfcode{cable\_is\_40wire}}{struct ata\_port *\emph{ ap}}{}
40/80/SATA decider

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
port to consider

\end{description}

\textbf{Description}
\begin{quote}

This function encapsulates the policy for speed management
in one place. At the moment we don't cache the result but
there is a good case for setting ap-\textgreater{}cbl to the result when
we are called with unknown cables (and figuring out if it
impacts hotplug at all).

Return 1 if the cable appears to be 40 wire.
\end{quote}
\index{ata\_dev\_xfermask (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_dev_xfermask}\pysiglinewithargsret{void \bfcode{ata\_dev\_xfermask}}{struct ata\_device *\emph{ dev}}{}
Compute supported xfermask of the given device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
Device to compute xfermask for

\end{description}

\textbf{Description}
\begin{quote}

Compute supported xfermask of \textbf{dev} and store it in
dev-\textgreater{}*\_mask.  This function is responsible for applying all
known limits including host controller limits, device
blacklist, etc...

LOCKING:
None.
\end{quote}
\index{ata\_dev\_set\_xfermode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_dev_set_xfermode}\pysiglinewithargsret{unsigned int \bfcode{ata\_dev\_set\_xfermode}}{struct ata\_device *\emph{ dev}}{}
Issue SET FEATURES - XFER MODE command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
Device to which command will be sent

\end{description}

\textbf{Description}
\begin{quote}

Issue SET FEATURES - XFER MODE command to device \textbf{dev}
on port \textbf{ap}.

LOCKING:
PCI/etc. bus probe sem.
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, AC\_ERR\_* mask otherwise.
\end{quote}
\index{ata\_dev\_init\_params (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_dev_init_params}\pysiglinewithargsret{unsigned int \bfcode{ata\_dev\_init\_params}}{struct ata\_device *\emph{ dev}, u16\emph{ heads}, u16\emph{ sectors}}{}
Issue INIT DEV PARAMS command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
Device to which command will be sent

\item[{\code{u16 heads}}] \leavevmode
Number of heads (taskfile parameter)

\item[{\code{u16 sectors}}] \leavevmode
Number of sectors (taskfile parameter)

\end{description}

\textbf{Description}
\begin{quote}

LOCKING:
Kernel thread context (may sleep)
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, AC\_ERR\_* mask otherwise.
\end{quote}
\index{atapi\_check\_dma (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.atapi_check_dma}\pysiglinewithargsret{int \bfcode{atapi\_check\_dma}}{struct ata\_queued\_cmd *\emph{ qc}}{}
Check whether ATAPI DMA can be supported

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Metadata associated with taskfile to check

\end{description}

\textbf{Description}
\begin{quote}

Allow low-level driver to filter ATA PACKET commands, returning
a status indicating whether or not it is OK to use DMA for the
supplied PACKET command.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}

\textbf{Return}
\begin{description}
\item[{0 when ATAPI DMA can be used}] \leavevmode
nonzero otherwise

\end{description}
\index{ata\_sg\_clean (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_sg_clean}\pysiglinewithargsret{void \bfcode{ata\_sg\_clean}}{struct ata\_queued\_cmd *\emph{ qc}}{}
Unmap DMA memory associated with command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Command containing DMA memory to be released

\end{description}

\textbf{Description}
\begin{quote}

Unmap all mapped DMA memory associated with this command.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_sg\_setup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_sg_setup}\pysiglinewithargsret{int \bfcode{ata\_sg\_setup}}{struct ata\_queued\_cmd *\emph{ qc}}{}
DMA-map the scatter-gather table associated with a command.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Command with scatter-gather table to be mapped.

\end{description}

\textbf{Description}
\begin{quote}

DMA-map the scatter-gather table associated with queued\_cmd \textbf{qc}.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}

\textbf{Return}
\begin{quote}

Zero on success, negative on error.
\end{quote}
\index{swap\_buf\_le16 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.swap_buf_le16}\pysiglinewithargsret{void \bfcode{swap\_buf\_le16}}{u16 *\emph{ buf}, unsigned int\emph{ buf\_words}}{}
swap halves of 16-bit words in place

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u16 * buf}}] \leavevmode
Buffer to swap

\item[{\code{unsigned int buf\_words}}] \leavevmode
Number of 16-bit words in buffer.

\end{description}

\textbf{Description}
\begin{quote}

Swap halves of 16-bit words if needed to convert from
little-endian byte order to native cpu byte order, or
vice-versa.

LOCKING:
Inherited from caller.
\end{quote}
\index{ata\_qc\_new\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_qc_new_init}\pysiglinewithargsret{struct ata\_queued\_cmd * \bfcode{ata\_qc\_new\_init}}{struct ata\_device *\emph{ dev}, int\emph{ tag}}{}
Request an available ATA command, and initialize it

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
Device from whom we request an available command structure

\item[{\code{int tag}}] \leavevmode
tag

\end{description}

\textbf{Description}
\begin{quote}

LOCKING:
None.
\end{quote}
\index{ata\_qc\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_qc_free}\pysiglinewithargsret{void \bfcode{ata\_qc\_free}}{struct ata\_queued\_cmd *\emph{ qc}}{}
free unused ata\_queued\_cmd

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Command to complete

\end{description}

\textbf{Description}
\begin{quote}

Designed to free unused ata\_queued\_cmd object
in case something prevents using it.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_qc\_issue (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_qc_issue}\pysiglinewithargsret{void \bfcode{ata\_qc\_issue}}{struct ata\_queued\_cmd *\emph{ qc}}{}
issue taskfile to device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
command to issue to device

\end{description}

\textbf{Description}
\begin{quote}

Prepare an ATA command to submission to device.
This includes mapping the data into a DMA-able
area, filling in the S/G table, and finally
writing the taskfile to hardware, starting the command.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_phys\_link\_online (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_phys_link_online}\pysiglinewithargsret{bool \bfcode{ata\_phys\_link\_online}}{struct ata\_link *\emph{ link}}{}
test whether the given link is online

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link to test

\end{description}

\textbf{Description}
\begin{quote}

Test whether \textbf{link} is online.  Note that this function returns
0 if online status of \textbf{link} cannot be obtained, so
ata\_link\_online(link) != !ata\_link\_offline(link).

LOCKING:
None.
\end{quote}

\textbf{Return}
\begin{quote}

True if the port online status is available and online.
\end{quote}
\index{ata\_phys\_link\_offline (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_phys_link_offline}\pysiglinewithargsret{bool \bfcode{ata\_phys\_link\_offline}}{struct ata\_link *\emph{ link}}{}
test whether the given link is offline

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link to test

\end{description}

\textbf{Description}
\begin{quote}

Test whether \textbf{link} is offline.  Note that this function
returns 0 if offline status of \textbf{link} cannot be obtained, so
ata\_link\_online(link) != !ata\_link\_offline(link).

LOCKING:
None.
\end{quote}

\textbf{Return}
\begin{quote}

True if the port offline status is available and offline.
\end{quote}
\index{ata\_dev\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_dev_init}\pysiglinewithargsret{void \bfcode{ata\_dev\_init}}{struct ata\_device *\emph{ dev}}{}
Initialize an ata\_device structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
Device structure to initialize

\end{description}

\textbf{Description}
\begin{quote}

Initialize \textbf{dev} in preparation for probing.

LOCKING:
Inherited from caller.
\end{quote}
\index{ata\_link\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_link_init}\pysiglinewithargsret{void \bfcode{ata\_link\_init}}{struct ata\_port *\emph{ ap}, struct ata\_link *\emph{ link}, int\emph{ pmp}}{}
Initialize an ata\_link structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port link is attached to

\item[{\code{struct ata\_link * link}}] \leavevmode
Link structure to initialize

\item[{\code{int pmp}}] \leavevmode
Port multiplier port number

\end{description}

\textbf{Description}
\begin{quote}

Initialize \textbf{link}.

LOCKING:
Kernel thread context (may sleep)
\end{quote}
\index{sata\_link\_init\_spd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sata_link_init_spd}\pysiglinewithargsret{int \bfcode{sata\_link\_init\_spd}}{struct ata\_link *\emph{ link}}{}
Initialize link-\textgreater{}sata\_spd\_limit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
Link to configure sata\_spd\_limit for

\end{description}

\textbf{Description}
\begin{quote}

Initialize \textbf{link}-\textgreater{}{[}{\color{red}\bfseries{}hw\_}{]}sata\_spd\_limit to the currently
configured value.

LOCKING:
Kernel thread context (may sleep).
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -errno on failure.
\end{quote}
\index{ata\_port\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_port_alloc}\pysiglinewithargsret{struct ata\_port * \bfcode{ata\_port\_alloc}}{struct ata\_host *\emph{ host}}{}
allocate and initialize basic ATA port resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_host * host}}] \leavevmode
ATA host this allocated port belongs to

\end{description}

\textbf{Description}
\begin{quote}

Allocate and initialize basic ATA port resources.
\end{quote}

\textbf{Return}
\begin{quote}

Allocate ATA port on success, NULL on failure.

LOCKING:
Inherited from calling layer (may sleep).
\end{quote}
\index{ata\_finalize\_port\_ops (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_finalize_port_ops}\pysiglinewithargsret{void \bfcode{ata\_finalize\_port\_ops}}{struct ata\_port\_operations *\emph{ ops}}{}
finalize ata\_port\_operations

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port\_operations * ops}}] \leavevmode
ata\_port\_operations to finalize

\end{description}

\textbf{Description}
\begin{quote}

An ata\_port\_operations can inherit from another ops and that
ops can again inherit from another.  This can go on as many
times as necessary as long as there is no loop in the
inheritance chain.

Ops tables are finalized when the host is started.  NULL or
unspecified entries are inherited from the closet ancestor
which has the method and the entry is populated with it.
After finalization, the ops table directly points to all the
methods and -\textgreater{}inherits is no longer necessary and cleared.

Using ATA\_OP\_NULL, inheriting ops can force a method to NULL.

LOCKING:
None.
\end{quote}
\index{ata\_port\_detach (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_port_detach}\pysiglinewithargsret{void \bfcode{ata\_port\_detach}}{struct ata\_port *\emph{ ap}}{}
Detach ATA port in preparation of device removal

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to be detached

\end{description}

\textbf{Description}
\begin{quote}

Detach all ATA devices and the associated SCSI devices of \textbf{ap};
then, remove the associated SCSI host.  \textbf{ap} is guaranteed to
be quiescent on return from this function.

LOCKING:
Kernel thread context (may sleep).
\end{quote}
\index{\_\_ata\_ehi\_push\_desc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.__ata_ehi_push_desc}\pysiglinewithargsret{void \bfcode{\_\_ata\_ehi\_push\_desc}}{struct ata\_eh\_info *\emph{ ehi}, const char *\emph{ fmt}, ...}{}
push error description without adding separator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_eh\_info * ehi}}] \leavevmode
target EHI

\item[{\code{const char * fmt}}] \leavevmode
printf format string

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}
\begin{quote}

Format string according to \textbf{fmt} and append it to \textbf{ehi}-\textgreater{}desc.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_ehi\_push\_desc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_ehi_push_desc}\pysiglinewithargsret{void \bfcode{ata\_ehi\_push\_desc}}{struct ata\_eh\_info *\emph{ ehi}, const char *\emph{ fmt}, ...}{}
push error description with separator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_eh\_info * ehi}}] \leavevmode
target EHI

\item[{\code{const char * fmt}}] \leavevmode
printf format string

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}
\begin{quote}

Format string according to \textbf{fmt} and append it to \textbf{ehi}-\textgreater{}desc.
If \textbf{ehi}-\textgreater{}desc is not empty, '', '' is added in-between.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_ehi\_clear\_desc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_ehi_clear_desc}\pysiglinewithargsret{void \bfcode{ata\_ehi\_clear\_desc}}{struct ata\_eh\_info *\emph{ ehi}}{}
clean error description

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_eh\_info * ehi}}] \leavevmode
target EHI

\end{description}

\textbf{Description}
\begin{quote}

Clear \textbf{ehi}-\textgreater{}desc.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_port\_desc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_port_desc}\pysiglinewithargsret{void \bfcode{ata\_port\_desc}}{struct ata\_port *\emph{ ap}, const char *\emph{ fmt}, ...}{}
append port description

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
target ATA port

\item[{\code{const char * fmt}}] \leavevmode
printf format string

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}
\begin{quote}

Format string according to \textbf{fmt} and append it to port
description.  If port description is not empty, '' '' is added
in-between.  This function is to be used while initializing
ata\_host.  The description is printed on host registration.

LOCKING:
None.
\end{quote}
\index{ata\_port\_pbar\_desc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_port_pbar_desc}\pysiglinewithargsret{void \bfcode{ata\_port\_pbar\_desc}}{struct ata\_port *\emph{ ap}, int\emph{ bar}, ssize\_t\emph{ offset}, const char *\emph{ name}}{}
append PCI BAR description

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
target ATA port

\item[{\code{int bar}}] \leavevmode
target PCI BAR

\item[{\code{ssize\_t offset}}] \leavevmode
offset into PCI BAR

\item[{\code{const char * name}}] \leavevmode
name of the area

\end{description}

\textbf{Description}
\begin{quote}

If \textbf{offset} is negative, this function formats a string which
contains the name, address, size and type of the BAR and
appends it to the port description.  If \textbf{offset} is zero or
positive, only name and offsetted address is appended.

LOCKING:
None.
\end{quote}
\index{ata\_internal\_cmd\_timeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_internal_cmd_timeout}\pysiglinewithargsret{unsigned long \bfcode{ata\_internal\_cmd\_timeout}}{struct ata\_device *\emph{ dev}, u8\emph{ cmd}}{}
determine timeout for an internal command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
target device

\item[{\code{u8 cmd}}] \leavevmode
internal command to be issued

\end{description}

\textbf{Description}
\begin{quote}

Determine timeout for internal command \textbf{cmd} for \textbf{dev}.

LOCKING:
EH context.
\end{quote}

\textbf{Return}
\begin{quote}

Determined timeout.
\end{quote}
\index{ata\_internal\_cmd\_timed\_out (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_internal_cmd_timed_out}\pysiglinewithargsret{void \bfcode{ata\_internal\_cmd\_timed\_out}}{struct ata\_device *\emph{ dev}, u8\emph{ cmd}}{}
notification for internal command timeout

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
target device

\item[{\code{u8 cmd}}] \leavevmode
internal command which timed out

\end{description}

\textbf{Description}
\begin{quote}

Notify EH that internal command \textbf{cmd} for \textbf{dev} timed out.  This
function should be called only for commands whose timeouts are
determined using {\hyperref[driver\string-api/libata:c.ata_internal_cmd_timeout]{\emph{\code{ata\_internal\_cmd\_timeout()}}}}.

LOCKING:
EH context.
\end{quote}
\index{ata\_eh\_acquire (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_acquire}\pysiglinewithargsret{void \bfcode{ata\_eh\_acquire}}{struct ata\_port *\emph{ ap}}{}
acquire EH ownership

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to acquire EH ownership for

\end{description}

\textbf{Description}
\begin{quote}

Acquire EH ownership for \textbf{ap}.  This is the basic exclusion
mechanism for ports sharing a host.  Only one port hanging off
the same host can claim the ownership of EH.

LOCKING:
EH context.
\end{quote}
\index{ata\_eh\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_release}\pysiglinewithargsret{void \bfcode{ata\_eh\_release}}{struct ata\_port *\emph{ ap}}{}
release EH ownership

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to release EH ownership for

\end{description}

\textbf{Description}
\begin{quote}

Release EH ownership for \textbf{ap} if the caller.  The caller must
have acquired EH ownership using {\hyperref[driver\string-api/libata:c.ata_eh_acquire]{\emph{\code{ata\_eh\_acquire()}}}} previously.

LOCKING:
EH context.
\end{quote}
\index{ata\_scsi\_timed\_out (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_timed_out}\pysiglinewithargsret{enum blk\_eh\_timer\_return \bfcode{ata\_scsi\_timed\_out}}{struct scsi\_cmnd *\emph{ cmd}}{}
SCSI layer time out callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * cmd}}] \leavevmode
timed out SCSI command

\end{description}

\textbf{Description}
\begin{quote}

Handles SCSI layer timeout.  We race with normal completion of
the qc for \textbf{cmd}.  If the qc is already gone, we lose and let
the scsi command finish (EH\_HANDLED).  Otherwise, the qc has
timed out and EH should be invoked.  Prevent {\hyperref[driver\string-api/libata:c.ata_qc_complete]{\emph{\code{ata\_qc\_complete()}}}}
from finishing it by setting EH\_SCHEDULED and return
EH\_NOT\_HANDLED.

TODO: kill this function once old EH is gone.

LOCKING:
Called from timer context
\end{quote}

\textbf{Return}
\begin{quote}

EH\_HANDLED or EH\_NOT\_HANDLED
\end{quote}
\index{ata\_scsi\_error (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_error}\pysiglinewithargsret{void \bfcode{ata\_scsi\_error}}{struct Scsi\_Host *\emph{ host}}{}
SCSI layer error handler callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * host}}] \leavevmode
SCSI host on which error occurred

\end{description}

\textbf{Description}
\begin{quote}

Handles SCSI-layer-thrown error events.

LOCKING:
Inherited from SCSI layer (none, can sleep)
\end{quote}

\textbf{Return}
\begin{quote}

Zero.
\end{quote}
\index{ata\_scsi\_cmd\_error\_handler (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_cmd_error_handler}\pysiglinewithargsret{void \bfcode{ata\_scsi\_cmd\_error\_handler}}{struct Scsi\_Host *\emph{ host}, struct ata\_port *\emph{ ap}, struct list\_head *\emph{ eh\_work\_q}}{}
error callback for a list of commands

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * host}}] \leavevmode
scsi host containing the port

\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port within the host

\item[{\code{struct list\_head * eh\_work\_q}}] \leavevmode
list of commands to process

\end{description}

\textbf{Description}

process the given list of commands and return those finished to the
ap-\textgreater{}eh\_done\_q.  This function is the first part of the libata error
handler which processes a given list of failed commands.
\index{ata\_scsi\_port\_error\_handler (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_port_error_handler}\pysiglinewithargsret{void \bfcode{ata\_scsi\_port\_error\_handler}}{struct Scsi\_Host *\emph{ host}, struct ata\_port *\emph{ ap}}{}
recover the port after the commands

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * host}}] \leavevmode
SCSI host containing the port

\item[{\code{struct ata\_port * ap}}] \leavevmode
the ATA port

\end{description}

\textbf{Description}

Handle the recovery of the port \textbf{ap} after all the commands
have been recovered.
\index{ata\_port\_wait\_eh (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_port_wait_eh}\pysiglinewithargsret{void \bfcode{ata\_port\_wait\_eh}}{struct ata\_port *\emph{ ap}}{}
Wait for the currently pending EH to complete

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
Port to wait EH for

\end{description}

\textbf{Description}
\begin{quote}

Wait until the currently pending EH is complete.

LOCKING:
Kernel thread context (may sleep).
\end{quote}
\index{ata\_eh\_set\_pending (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_set_pending}\pysiglinewithargsret{void \bfcode{ata\_eh\_set\_pending}}{struct ata\_port *\emph{ ap}, int\emph{ fastdrain}}{}
set ATA\_PFLAG\_EH\_PENDING and activate fast drain

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
target ATA port

\item[{\code{int fastdrain}}] \leavevmode
activate fast drain

\end{description}

\textbf{Description}
\begin{quote}

Set ATA\_PFLAG\_EH\_PENDING and activate fast drain if \textbf{fastdrain}
is non-zero and EH wasn't pending before.  Fast drain ensures
that EH kicks in in timely manner.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_qc\_schedule\_eh (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_qc_schedule_eh}\pysiglinewithargsret{void \bfcode{ata\_qc\_schedule\_eh}}{struct ata\_queued\_cmd *\emph{ qc}}{}
schedule qc for error handling

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
command to schedule error handling for

\end{description}

\textbf{Description}
\begin{quote}

Schedule error handling for \textbf{qc}.  EH will kick in as soon as
other commands are drained.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_std\_sched\_eh (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_std_sched_eh}\pysiglinewithargsret{void \bfcode{ata\_std\_sched\_eh}}{struct ata\_port *\emph{ ap}}{}
non-libsas ata\_ports issue eh with this common routine

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to schedule EH for

\end{description}

\textbf{Description}
\begin{quote}

LOCKING: inherited from ata\_port\_schedule\_eh
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_std\_end\_eh (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_std_end_eh}\pysiglinewithargsret{void \bfcode{ata\_std\_end\_eh}}{struct ata\_port *\emph{ ap}}{}
non-libsas ata\_ports complete eh with this common routine

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to end EH for

\end{description}

\textbf{Description}

In the libata object model there is a 1:1 mapping of ata\_port to
shost, so host fields can be directly manipulated under ap-\textgreater{}lock, in
the libsas case we need to hold a lock at the ha-\textgreater{}level to coordinate
these events.
\begin{quote}

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_port\_schedule\_eh (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_port_schedule_eh}\pysiglinewithargsret{void \bfcode{ata\_port\_schedule\_eh}}{struct ata\_port *\emph{ ap}}{}
schedule error handling without a qc

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to schedule EH for

\end{description}

\textbf{Description}
\begin{quote}

Schedule error handling for \textbf{ap}.  EH will kick in as soon as
all commands are drained.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_link\_abort (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_link_abort}\pysiglinewithargsret{int \bfcode{ata\_link\_abort}}{struct ata\_link *\emph{ link}}{}
abort all qc's on the link

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link to abort qc's for

\end{description}

\textbf{Description}
\begin{quote}

Abort all active qc's active on \textbf{link} and schedule EH.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}

\textbf{Return}
\begin{quote}

Number of aborted qc's.
\end{quote}
\index{ata\_port\_abort (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_port_abort}\pysiglinewithargsret{int \bfcode{ata\_port\_abort}}{struct ata\_port *\emph{ ap}}{}
abort all qc's on the port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to abort qc's for

\end{description}

\textbf{Description}
\begin{quote}

Abort all active qc's of \textbf{ap} and schedule EH.

LOCKING:
spin\_lock\_irqsave(host\_set lock)
\end{quote}

\textbf{Return}
\begin{quote}

Number of aborted qc's.
\end{quote}
\index{\_\_ata\_port\_freeze (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.__ata_port_freeze}\pysiglinewithargsret{void \bfcode{\_\_ata\_port\_freeze}}{struct ata\_port *\emph{ ap}}{}
freeze port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to freeze

\end{description}

\textbf{Description}
\begin{quote}

This function is called when HSM violation or some other
condition disrupts normal operation of the port.  Frozen port
is not allowed to perform any operation until the port is
thawed, which usually follows a successful reset.

ap-\textgreater{}ops-\textgreater{}:c:func:\emph{freeze()} callback can be used for freezing the port
hardware-wise (e.g. mask interrupt and stop DMA engine).  If a
port cannot be frozen hardware-wise, the interrupt handler
must ack and clear interrupts unconditionally while the port
is frozen.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_port\_freeze (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_port_freeze}\pysiglinewithargsret{int \bfcode{ata\_port\_freeze}}{struct ata\_port *\emph{ ap}}{}
abort \& freeze port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to freeze

\end{description}

\textbf{Description}
\begin{quote}

Abort and freeze \textbf{ap}.  The freeze operation must be called
first, because some hardware requires special operations
before the taskfile registers are accessible.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}

\textbf{Return}
\begin{quote}

Number of aborted commands.
\end{quote}
\index{sata\_async\_notification (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sata_async_notification}\pysiglinewithargsret{int \bfcode{sata\_async\_notification}}{struct ata\_port *\emph{ ap}}{}
SATA async notification handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port where async notification is received

\end{description}

\textbf{Description}
\begin{quote}

Handler to be called when async notification via SDB FIS is
received.  This function schedules EH if necessary.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}

\textbf{Return}
\begin{quote}

1 if EH is scheduled, 0 otherwise.
\end{quote}
\index{ata\_eh\_freeze\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_freeze_port}\pysiglinewithargsret{void \bfcode{ata\_eh\_freeze\_port}}{struct ata\_port *\emph{ ap}}{}
EH helper to freeze port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to freeze

\end{description}

\textbf{Description}
\begin{quote}

Freeze \textbf{ap}.

LOCKING:
None.
\end{quote}
\index{ata\_eh\_thaw\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_thaw_port}\pysiglinewithargsret{void \bfcode{ata\_eh\_thaw\_port}}{struct ata\_port *\emph{ ap}}{}
EH helper to thaw port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to thaw

\end{description}

\textbf{Description}
\begin{quote}

Thaw frozen port \textbf{ap}.

LOCKING:
None.
\end{quote}
\index{ata\_eh\_qc\_complete (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_qc_complete}\pysiglinewithargsret{void \bfcode{ata\_eh\_qc\_complete}}{struct ata\_queued\_cmd *\emph{ qc}}{}
Complete an active ATA command from EH

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Command to complete

\end{description}

\textbf{Description}
\begin{quote}

Indicate to the mid and upper layers that an ATA command has
completed.  To be used from EH.
\end{quote}
\index{ata\_eh\_qc\_retry (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_qc_retry}\pysiglinewithargsret{void \bfcode{ata\_eh\_qc\_retry}}{struct ata\_queued\_cmd *\emph{ qc}}{}
Tell midlayer to retry an ATA command after EH

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Command to retry

\end{description}

\textbf{Description}
\begin{quote}

Indicate to the mid and upper layers that an ATA command
should be retried.  To be used from EH.

SCSI midlayer limits the number of retries to scmd-\textgreater{}allowed.
scmd-\textgreater{}allowed is incremented for commands which get retried
due to unrelated failures (qc-\textgreater{}err\_mask is zero).
\end{quote}
\index{ata\_dev\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_dev_disable}\pysiglinewithargsret{void \bfcode{ata\_dev\_disable}}{struct ata\_device *\emph{ dev}}{}
disable ATA device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
ATA device to disable

\end{description}

\textbf{Description}
\begin{quote}

Disable \textbf{dev}.

Locking:
EH context.
\end{quote}
\index{ata\_eh\_detach\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_detach_dev}\pysiglinewithargsret{void \bfcode{ata\_eh\_detach\_dev}}{struct ata\_device *\emph{ dev}}{}
detach ATA device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
ATA device to detach

\end{description}

\textbf{Description}
\begin{quote}

Detach \textbf{dev}.

LOCKING:
None.
\end{quote}
\index{ata\_eh\_about\_to\_do (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_about_to_do}\pysiglinewithargsret{void \bfcode{ata\_eh\_about\_to\_do}}{struct ata\_link *\emph{ link}, struct ata\_device *\emph{ dev}, unsigned int\emph{ action}}{}
about to perform eh\_action

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
target ATA link

\item[{\code{struct ata\_device * dev}}] \leavevmode
target ATA dev for per-dev action (can be NULL)

\item[{\code{unsigned int action}}] \leavevmode
action about to be performed

\end{description}

\textbf{Description}
\begin{quote}

Called just before performing EH actions to clear related bits
in \textbf{link}-\textgreater{}eh\_info such that eh actions are not unnecessarily
repeated.

LOCKING:
None.
\end{quote}
\index{ata\_eh\_done (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_done}\pysiglinewithargsret{void \bfcode{ata\_eh\_done}}{struct ata\_link *\emph{ link}, struct ata\_device *\emph{ dev}, unsigned int\emph{ action}}{}
EH action complete

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link for which EH actions are complete

\item[{\code{struct ata\_device * dev}}] \leavevmode
target ATA dev for per-dev action (can be NULL)

\item[{\code{unsigned int action}}] \leavevmode
action just completed

\end{description}

\textbf{Description}
\begin{quote}

Called right after performing EH actions to clear related bits
in \textbf{link}-\textgreater{}eh\_context.

LOCKING:
None.
\end{quote}
\index{ata\_err\_string (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_err_string}\pysiglinewithargsret{const char * \bfcode{ata\_err\_string}}{unsigned int\emph{ err\_mask}}{}
convert err\_mask to descriptive string

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int err\_mask}}] \leavevmode
error mask to convert to string

\end{description}

\textbf{Description}
\begin{quote}

Convert \textbf{err\_mask} to descriptive string.  Errors are
prioritized according to severity and only the most severe
error is reported.

LOCKING:
None.
\end{quote}

\textbf{Return}
\begin{quote}

Descriptive string for \textbf{err\_mask}
\end{quote}
\index{ata\_eh\_read\_log\_10h (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_read_log_10h}\pysiglinewithargsret{int \bfcode{ata\_eh\_read\_log\_10h}}{struct ata\_device *\emph{ dev}, int *\emph{ tag}, struct ata\_taskfile *\emph{ tf}}{}
Read log page 10h for NCQ error details

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
Device to read log page 10h from

\item[{\code{int * tag}}] \leavevmode
Resulting tag of the failed command

\item[{\code{struct ata\_taskfile * tf}}] \leavevmode
Resulting taskfile registers of the failed command

\end{description}

\textbf{Description}
\begin{quote}

Read log page 10h to obtain NCQ error details and clear error
condition.

LOCKING:
Kernel thread context (may sleep).
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -errno otherwise.
\end{quote}
\index{atapi\_eh\_tur (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.atapi_eh_tur}\pysiglinewithargsret{unsigned int \bfcode{atapi\_eh\_tur}}{struct ata\_device *\emph{ dev}, u8 *\emph{ r\_sense\_key}}{}
perform ATAPI TEST\_UNIT\_READY

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
target ATAPI device

\item[{\code{u8 * r\_sense\_key}}] \leavevmode
out parameter for sense\_key

\end{description}

\textbf{Description}
\begin{quote}

Perform ATAPI TEST\_UNIT\_READY.

LOCKING:
EH context (may sleep).
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, AC\_ERR\_* mask on failure.
\end{quote}
\index{ata\_eh\_request\_sense (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_request_sense}\pysiglinewithargsret{void \bfcode{ata\_eh\_request\_sense}}{struct ata\_queued\_cmd *\emph{ qc}, struct scsi\_cmnd *\emph{ cmd}}{}
perform REQUEST\_SENSE\_DATA\_EXT

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
qc to perform REQUEST\_SENSE\_SENSE\_DATA\_EXT to

\item[{\code{struct scsi\_cmnd * cmd}}] \leavevmode
scsi command for which the sense code should be set

\end{description}

\textbf{Description}
\begin{quote}

Perform REQUEST\_SENSE\_DATA\_EXT after the device reported CHECK
SENSE.  This function is an EH helper.

LOCKING:
Kernel thread context (may sleep).
\end{quote}
\index{atapi\_eh\_request\_sense (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.atapi_eh_request_sense}\pysiglinewithargsret{unsigned int \bfcode{atapi\_eh\_request\_sense}}{struct ata\_device *\emph{ dev}, u8 *\emph{ sense\_buf}, u8\emph{ dfl\_sense\_key}}{}
perform ATAPI REQUEST\_SENSE

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
device to perform REQUEST\_SENSE to

\item[{\code{u8 * sense\_buf}}] \leavevmode
result sense data buffer (SCSI\_SENSE\_BUFFERSIZE bytes long)

\item[{\code{u8 dfl\_sense\_key}}] \leavevmode
default sense key to use

\end{description}

\textbf{Description}
\begin{quote}

Perform ATAPI REQUEST\_SENSE after the device reported CHECK
SENSE.  This function is EH helper.

LOCKING:
Kernel thread context (may sleep).
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, AC\_ERR\_* mask on failure
\end{quote}
\index{ata\_eh\_analyze\_serror (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_analyze_serror}\pysiglinewithargsret{void \bfcode{ata\_eh\_analyze\_serror}}{struct ata\_link *\emph{ link}}{}
analyze SError for a failed port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link to analyze SError for

\end{description}

\textbf{Description}
\begin{quote}

Analyze SError if available and further determine cause of
failure.

LOCKING:
None.
\end{quote}
\index{ata\_eh\_analyze\_ncq\_error (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_analyze_ncq_error}\pysiglinewithargsret{void \bfcode{ata\_eh\_analyze\_ncq\_error}}{struct ata\_link *\emph{ link}}{}
analyze NCQ error

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link to analyze NCQ error for

\end{description}

\textbf{Description}
\begin{quote}

Read log page 10h, determine the offending qc and acquire
error status TF.  For NCQ device errors, all LLDDs have to do
is setting AC\_ERR\_DEV in ehi-\textgreater{}err\_mask.  This function takes
care of the rest.

LOCKING:
Kernel thread context (may sleep).
\end{quote}
\index{ata\_eh\_analyze\_tf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_analyze_tf}\pysiglinewithargsret{unsigned int \bfcode{ata\_eh\_analyze\_tf}}{struct ata\_queued\_cmd *\emph{ qc}, const struct ata\_taskfile *\emph{ tf}}{}
analyze taskfile of a failed qc

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
qc to analyze

\item[{\code{const struct ata\_taskfile * tf}}] \leavevmode
Taskfile registers to analyze

\end{description}

\textbf{Description}
\begin{quote}

Analyze taskfile of \textbf{qc} and further determine cause of
failure.  This function also requests ATAPI sense data if
available.

LOCKING:
Kernel thread context (may sleep).
\end{quote}

\textbf{Return}
\begin{quote}

Determined recovery action
\end{quote}
\index{ata\_eh\_speed\_down\_verdict (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_speed_down_verdict}\pysiglinewithargsret{unsigned int \bfcode{ata\_eh\_speed\_down\_verdict}}{struct ata\_device *\emph{ dev}}{}
Determine speed down verdict

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
Device of interest

\end{description}

\textbf{Description}
\begin{quote}

This function examines error ring of \textbf{dev} and determines
whether NCQ needs to be turned off, transfer speed should be
stepped down, or falling back to PIO is necessary.

ECAT\_ATA\_BUS    : ATA\_BUS error for any command
\begin{description}
\item[{ECAT\_TOUT\_HSM}] \leavevmode{[}TIMEOUT for any command or HSM violation for{]}
IO commands

\end{description}

ECAT\_UNK\_DEV    : Unknown DEV error for IO commands
\begin{description}
\item[{ECAT\_DUBIOUS\_*}] \leavevmode{[}Identical to above three but occurred while{]}
data transfer hasn't been verified.

\end{description}

Verdicts are

NCQ\_OFF         : Turn off NCQ.
\begin{description}
\item[{SPEED\_DOWN}] \leavevmode{[}Speed down transfer speed but don't fall back{]}
to PIO.

\end{description}

FALLBACK\_TO\_PIO : Fall back to PIO.

Even if multiple verdicts are returned, only one action is
taken per error.  An action triggered by non-DUBIOUS errors
clears ering, while one triggered by DUBIOUS\_* errors doesn't.
This is to expedite speed down decisions right after device is
initially configured.

The following are speed down rules.  \#1 and \#2 deal with
DUBIOUS errors.
\begin{enumerate}
\item {} 
If more than one DUBIOUS\_ATA\_BUS or DUBIOUS\_TOUT\_HSM errors
occurred during last 5 mins, SPEED\_DOWN and FALLBACK\_TO\_PIO.

\item {} 
If more than one DUBIOUS\_TOUT\_HSM or DUBIOUS\_UNK\_DEV errors
occurred during last 5 mins, NCQ\_OFF.

\item {} 
If more than 8 ATA\_BUS, TOUT\_HSM or UNK\_DEV errors
occurred during last 5 mins, FALLBACK\_TO\_PIO

\item {} 
If more than 3 TOUT\_HSM or UNK\_DEV errors occurred
during last 10 mins, NCQ\_OFF.

\item {} 
If more than 3 ATA\_BUS or TOUT\_HSM errors, or more than 6
UNK\_DEV errors occurred during last 10 mins, SPEED\_DOWN.

\end{enumerate}

LOCKING:
Inherited from caller.
\end{quote}

\textbf{Return}
\begin{quote}

OR of ATA\_EH\_SPDN\_* flags.
\end{quote}
\index{ata\_eh\_speed\_down (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_speed_down}\pysiglinewithargsret{unsigned int \bfcode{ata\_eh\_speed\_down}}{struct ata\_device *\emph{ dev}, unsigned int\emph{ eflags}, unsigned int\emph{ err\_mask}}{}
record error and speed down if necessary

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
Failed device

\item[{\code{unsigned int eflags}}] \leavevmode
mask of ATA\_EFLAG\_* flags

\item[{\code{unsigned int err\_mask}}] \leavevmode
err\_mask of the error

\end{description}

\textbf{Description}
\begin{quote}

Record error and examine error history to determine whether
adjusting transmission speed is necessary.  It also sets
transmission limits appropriately if such adjustment is
necessary.

LOCKING:
Kernel thread context (may sleep).
\end{quote}

\textbf{Return}
\begin{quote}

Determined recovery action.
\end{quote}
\index{ata\_eh\_worth\_retry (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_worth_retry}\pysiglinewithargsret{int \bfcode{ata\_eh\_worth\_retry}}{struct ata\_queued\_cmd *\emph{ qc}}{}
analyze error and decide whether to retry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
qc to possibly retry

\end{description}

\textbf{Description}
\begin{quote}

Look at the cause of the error and decide if a retry
might be useful or not.  We don't want to retry media errors
because the drive itself has probably already taken 10-30 seconds
doing its own internal retries before reporting the failure.
\end{quote}
\index{ata\_eh\_link\_autopsy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_link_autopsy}\pysiglinewithargsret{void \bfcode{ata\_eh\_link\_autopsy}}{struct ata\_link *\emph{ link}}{}
analyze error and determine recovery action

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
host link to perform autopsy on

\end{description}

\textbf{Description}
\begin{quote}

Analyze why \textbf{link} failed and determine which recovery actions
are needed.  This function also sets more detailed AC\_ERR\_*
values and fills sense data for ATAPI CHECK SENSE.

LOCKING:
Kernel thread context (may sleep).
\end{quote}
\index{ata\_eh\_autopsy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_autopsy}\pysiglinewithargsret{void \bfcode{ata\_eh\_autopsy}}{struct ata\_port *\emph{ ap}}{}
analyze error and determine recovery action

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
host port to perform autopsy on

\end{description}

\textbf{Description}
\begin{quote}

Analyze all links of \textbf{ap} and determine why they failed and
which recovery actions are needed.

LOCKING:
Kernel thread context (may sleep).
\end{quote}
\index{ata\_get\_cmd\_descript (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_get_cmd_descript}\pysiglinewithargsret{const char * \bfcode{ata\_get\_cmd\_descript}}{u8\emph{ command}}{}
get description for ATA command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 command}}] \leavevmode
ATA command code to get description for

\end{description}

\textbf{Description}
\begin{quote}

Return a textual description of the given command, or NULL if the
command is not known.

LOCKING:
None
\end{quote}
\index{ata\_eh\_link\_report (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_link_report}\pysiglinewithargsret{void \bfcode{ata\_eh\_link\_report}}{struct ata\_link *\emph{ link}}{}
report error handling to user

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
ATA link EH is going on

\end{description}

\textbf{Description}
\begin{quote}

Report EH to user.

LOCKING:
None.
\end{quote}
\index{ata\_eh\_report (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_report}\pysiglinewithargsret{void \bfcode{ata\_eh\_report}}{struct ata\_port *\emph{ ap}}{}
report error handling to user

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to report EH about

\end{description}

\textbf{Description}
\begin{quote}

Report EH to user.

LOCKING:
None.
\end{quote}
\index{ata\_set\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_set_mode}\pysiglinewithargsret{int \bfcode{ata\_set\_mode}}{struct ata\_link *\emph{ link}, struct ata\_device **\emph{ r\_failed\_dev}}{}
Program timings and issue SET FEATURES - XFER

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
link on which timings will be programmed

\item[{\code{struct ata\_device ** r\_failed\_dev}}] \leavevmode
out parameter for failed device

\end{description}

\textbf{Description}
\begin{quote}

Set ATA device disk transfer mode (PIO3, UDMA6, etc.).  If
{\hyperref[driver\string-api/libata:c.ata_set_mode]{\emph{\code{ata\_set\_mode()}}}} fails, pointer to the failing device is
returned in \textbf{r\_failed\_dev}.

LOCKING:
PCI/etc. bus probe sem.
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, negative errno otherwise
\end{quote}
\index{atapi\_eh\_clear\_ua (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.atapi_eh_clear_ua}\pysiglinewithargsret{int \bfcode{atapi\_eh\_clear\_ua}}{struct ata\_device *\emph{ dev}}{}
Clear ATAPI UNIT ATTENTION after reset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
ATAPI device to clear UA for

\end{description}

\textbf{Description}
\begin{quote}

Resets and other operations can make an ATAPI device raise
UNIT ATTENTION which causes the next operation to fail.  This
function clears UA.

LOCKING:
EH context (may sleep).
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -errno on failure.
\end{quote}
\index{ata\_eh\_maybe\_retry\_flush (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_maybe_retry_flush}\pysiglinewithargsret{int \bfcode{ata\_eh\_maybe\_retry\_flush}}{struct ata\_device *\emph{ dev}}{}
Retry FLUSH if necessary

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
ATA device which may need FLUSH retry

\end{description}

\textbf{Description}
\begin{quote}

If \textbf{dev} failed FLUSH, it needs to be reported upper layer
immediately as it means that \textbf{dev} failed to remap and already
lost at least a sector and further FLUSH retrials won't make
any difference to the lost sector.  However, if FLUSH failed
for other reasons, for example transmission error, FLUSH needs
to be retried.

This function determines whether FLUSH failure retry is
necessary and performs it if so.
\end{quote}

\textbf{Return}
\begin{quote}

0 if EH can continue, -errno if EH needs to be repeated.
\end{quote}
\index{ata\_eh\_set\_lpm (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_set_lpm}\pysiglinewithargsret{int \bfcode{ata\_eh\_set\_lpm}}{struct ata\_link *\emph{ link}, enum ata\_lpm\_policy\emph{ policy}, struct ata\_device **\emph{ r\_failed\_dev}}{}
configure SATA interface power management

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
link to configure power management

\item[{\code{enum ata\_lpm\_policy policy}}] \leavevmode
the link power management policy

\item[{\code{struct ata\_device ** r\_failed\_dev}}] \leavevmode
out parameter for failed device

\end{description}

\textbf{Description}
\begin{quote}

Enable SATA Interface power management.  This will enable
Device Interface Power Management (DIPM) for min\_power and
medium\_power\_with\_dipm policies, and then call driver specific
callbacks for enabling Host Initiated Power management.

LOCKING:
EH context.
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -errno on failure.
\end{quote}
\index{ata\_eh\_recover (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_recover}\pysiglinewithargsret{int \bfcode{ata\_eh\_recover}}{struct ata\_port *\emph{ ap}, ata\_prereset\_fn\_t\emph{ prereset}, ata\_reset\_fn\_t\emph{ softreset}, ata\_reset\_fn\_t\emph{ hardreset}, ata\_postreset\_fn\_t\emph{ postreset}, struct ata\_link **\emph{ r\_failed\_link}}{}
recover host port after error

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
host port to recover

\item[{\code{ata\_prereset\_fn\_t prereset}}] \leavevmode
prereset method (can be NULL)

\item[{\code{ata\_reset\_fn\_t softreset}}] \leavevmode
softreset method (can be NULL)

\item[{\code{ata\_reset\_fn\_t hardreset}}] \leavevmode
hardreset method (can be NULL)

\item[{\code{ata\_postreset\_fn\_t postreset}}] \leavevmode
postreset method (can be NULL)

\item[{\code{struct ata\_link ** r\_failed\_link}}] \leavevmode
out parameter for failed link

\end{description}

\textbf{Description}
\begin{quote}

This is the alpha and omega, eum and yang, heart and soul of
libata exception handling.  On entry, actions required to
recover each link and hotplug requests are recorded in the
link's eh\_context.  This function executes all the operations
with appropriate retrials and fallbacks to resurrect failed
devices, detach goners and greet newcomers.

LOCKING:
Kernel thread context (may sleep).
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, -errno on failure.
\end{quote}
\index{ata\_eh\_finish (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_finish}\pysiglinewithargsret{void \bfcode{ata\_eh\_finish}}{struct ata\_port *\emph{ ap}}{}
finish up EH

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
host port to finish EH for

\end{description}

\textbf{Description}
\begin{quote}

Recovery is complete.  Clean up EH states and retry or finish
failed qcs.

LOCKING:
None.
\end{quote}
\index{ata\_do\_eh (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_do_eh}\pysiglinewithargsret{void \bfcode{ata\_do\_eh}}{struct ata\_port *\emph{ ap}, ata\_prereset\_fn\_t\emph{ prereset}, ata\_reset\_fn\_t\emph{ softreset}, ata\_reset\_fn\_t\emph{ hardreset}, ata\_postreset\_fn\_t\emph{ postreset}}{}
do standard error handling

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
host port to handle error for

\item[{\code{ata\_prereset\_fn\_t prereset}}] \leavevmode
prereset method (can be NULL)

\item[{\code{ata\_reset\_fn\_t softreset}}] \leavevmode
softreset method (can be NULL)

\item[{\code{ata\_reset\_fn\_t hardreset}}] \leavevmode
hardreset method (can be NULL)

\item[{\code{ata\_postreset\_fn\_t postreset}}] \leavevmode
postreset method (can be NULL)

\end{description}

\textbf{Description}
\begin{quote}

Perform standard error handling sequence.

LOCKING:
Kernel thread context (may sleep).
\end{quote}
\index{ata\_std\_error\_handler (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_std_error_handler}\pysiglinewithargsret{void \bfcode{ata\_std\_error\_handler}}{struct ata\_port *\emph{ ap}}{}
standard error handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
host port to handle error for

\end{description}

\textbf{Description}
\begin{quote}

Standard error handler

LOCKING:
Kernel thread context (may sleep).
\end{quote}
\index{ata\_eh\_handle\_port\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_handle_port_suspend}\pysiglinewithargsret{void \bfcode{ata\_eh\_handle\_port\_suspend}}{struct ata\_port *\emph{ ap}}{}
perform port suspend operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
port to suspend

\end{description}

\textbf{Description}
\begin{quote}

Suspend \textbf{ap}.

LOCKING:
Kernel thread context (may sleep).
\end{quote}
\index{ata\_eh\_handle\_port\_resume (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_eh_handle_port_resume}\pysiglinewithargsret{void \bfcode{ata\_eh\_handle\_port\_resume}}{struct ata\_port *\emph{ ap}}{}
perform port resume operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
port to resume

\end{description}

\textbf{Description}
\begin{quote}

Resume \textbf{ap}.

LOCKING:
Kernel thread context (may sleep).
\end{quote}


\section{libata SCSI translation/emulation}
\label{driver-api/libata:libata-scsi-translation-emulation}\index{ata\_sas\_port\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_sas_port_alloc}\pysiglinewithargsret{struct ata\_port * \bfcode{ata\_sas\_port\_alloc}}{struct ata\_host *\emph{ host}, struct ata\_port\_info *\emph{ port\_info}, struct Scsi\_Host *\emph{ shost}}{}
Allocate port for a SAS attached SATA device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_host * host}}] \leavevmode
ATA host container for all SAS ports

\item[{\code{struct ata\_port\_info * port\_info}}] \leavevmode
Information from low-level host driver

\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
SCSI host that the scsi device is attached to

\end{description}

\textbf{Description}
\begin{quote}

LOCKING:
PCI/etc. bus probe sem.
\end{quote}

\textbf{Return}
\begin{quote}

ata\_port pointer on success / NULL on failure.
\end{quote}
\index{ata\_sas\_port\_start (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_sas_port_start}\pysiglinewithargsret{int \bfcode{ata\_sas\_port\_start}}{struct ata\_port *\emph{ ap}}{}
Set port up for dma.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
Port to initialize

\end{description}

\textbf{Description}
\begin{quote}

Called just after data structures for each port are
initialized.

May be used as the \code{port\_start()} entry in ata\_port\_operations.

LOCKING:
Inherited from caller.
\end{quote}
\index{ata\_sas\_port\_stop (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_sas_port_stop}\pysiglinewithargsret{void \bfcode{ata\_sas\_port\_stop}}{struct ata\_port *\emph{ ap}}{}
Undo {\hyperref[driver\string-api/libata:c.ata_sas_port_start]{\emph{\code{ata\_sas\_port\_start()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
Port to shut down

\end{description}

\textbf{Description}
\begin{quote}

May be used as the \code{port\_stop()} entry in ata\_port\_operations.

LOCKING:
Inherited from caller.
\end{quote}
\index{ata\_sas\_async\_probe (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_sas_async_probe}\pysiglinewithargsret{void \bfcode{ata\_sas\_async\_probe}}{struct ata\_port *\emph{ ap}}{}
simply schedule probing and return

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
Port to probe

\end{description}

\textbf{Description}

For batch scheduling of probe for sas attached ata devices, assumes
the port has already been through {\hyperref[driver\string-api/libata:c.ata_sas_port_init]{\emph{\code{ata\_sas\_port\_init()}}}}
\index{ata\_sas\_port\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_sas_port_init}\pysiglinewithargsret{int \bfcode{ata\_sas\_port\_init}}{struct ata\_port *\emph{ ap}}{}
Initialize a SATA device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
SATA port to initialize

\end{description}

\textbf{Description}
\begin{quote}

LOCKING:
PCI/etc. bus probe sem.
\end{quote}

\textbf{Return}
\begin{quote}

Zero on success, non-zero on error.
\end{quote}
\index{ata\_sas\_port\_destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_sas_port_destroy}\pysiglinewithargsret{void \bfcode{ata\_sas\_port\_destroy}}{struct ata\_port *\emph{ ap}}{}
Destroy a SATA port allocated by ata\_sas\_port\_alloc

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
SATA port to destroy

\end{description}
\index{ata\_sas\_slave\_configure (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_sas_slave_configure}\pysiglinewithargsret{int \bfcode{ata\_sas\_slave\_configure}}{struct scsi\_device *\emph{ sdev}, struct ata\_port *\emph{ ap}}{}
Default slave\_config routine for libata devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
SCSI device to configure

\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to which SCSI device is attached

\end{description}

\textbf{Return}
\begin{quote}

Zero.
\end{quote}
\index{ata\_sas\_queuecmd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_sas_queuecmd}\pysiglinewithargsret{int \bfcode{ata\_sas\_queuecmd}}{struct scsi\_cmnd *\emph{ cmd}, struct ata\_port *\emph{ ap}}{}
Issue SCSI cdb to libata-managed device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * cmd}}] \leavevmode
SCSI command to be sent

\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to which the command is being sent

\end{description}

\textbf{Return}
\begin{quote}

Return value from \code{\_\_ata\_scsi\_queuecmd()} if \textbf{cmd} can be queued,
0 otherwise.
\end{quote}
\index{ata\_std\_bios\_param (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_std_bios_param}\pysiglinewithargsret{int \bfcode{ata\_std\_bios\_param}}{struct scsi\_device *\emph{ sdev}, struct block\_device *\emph{ bdev}, sector\_t\emph{ capacity}, int\emph{ geom}}{}
generic bios head/sector/cylinder calculator used by sd.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
SCSI device for which BIOS geometry is to be determined

\item[{\code{struct block\_device * bdev}}] \leavevmode
block device associated with \textbf{sdev}

\item[{\code{sector\_t capacity}}] \leavevmode
capacity of SCSI device

\item[{\code{int geom}}] \leavevmode
location to which geometry will be output

\end{description}

\textbf{Description}
\begin{quote}

Generic bios head/sector/cylinder calculator
used by sd. Most BIOSes nowadays expect a XXX/255/16  (CHS)
mapping. Some situations may arise where the disk is not
bootable if this is not used.

LOCKING:
Defined by the SCSI layer.  We don't really care.
\end{quote}

\textbf{Return}
\begin{quote}

Zero.
\end{quote}
\index{ata\_scsi\_unlock\_native\_capacity (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_unlock_native_capacity}\pysiglinewithargsret{void \bfcode{ata\_scsi\_unlock\_native\_capacity}}{struct scsi\_device *\emph{ sdev}}{}
unlock native capacity

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
SCSI device to adjust device capacity for

\end{description}

\textbf{Description}
\begin{quote}

This function is called if a partition on \textbf{sdev} extends beyond
the end of the device.  It requests EH to unlock HPA.

LOCKING:
Defined by the SCSI layer.  Might sleep.
\end{quote}
\index{ata\_get\_identity (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_get_identity}\pysiglinewithargsret{int \bfcode{ata\_get\_identity}}{struct ata\_port *\emph{ ap}, struct scsi\_device *\emph{ sdev}, void \_\_user *\emph{ arg}}{}
Handler for HDIO\_GET\_IDENTITY ioctl

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
target port

\item[{\code{struct scsi\_device * sdev}}] \leavevmode
SCSI device to get identify data for

\item[{\code{void \_\_user * arg}}] \leavevmode
User buffer area for identify data

\end{description}

\textbf{Description}
\begin{quote}

LOCKING:
Defined by the SCSI layer.  We don't really care.
\end{quote}

\textbf{Return}
\begin{quote}

Zero on success, negative errno on error.
\end{quote}
\index{ata\_cmd\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_cmd_ioctl}\pysiglinewithargsret{int \bfcode{ata\_cmd\_ioctl}}{struct scsi\_device *\emph{ scsidev}, void \_\_user *\emph{ arg}}{}
Handler for HDIO\_DRIVE\_CMD ioctl

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * scsidev}}] \leavevmode
Device to which we are issuing command

\item[{\code{void \_\_user * arg}}] \leavevmode
User provided data for issuing command

\end{description}

\textbf{Description}
\begin{quote}

LOCKING:
Defined by the SCSI layer.  We don't really care.
\end{quote}

\textbf{Return}
\begin{quote}

Zero on success, negative errno on error.
\end{quote}
\index{ata\_task\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_task_ioctl}\pysiglinewithargsret{int \bfcode{ata\_task\_ioctl}}{struct scsi\_device *\emph{ scsidev}, void \_\_user *\emph{ arg}}{}
Handler for HDIO\_DRIVE\_TASK ioctl

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * scsidev}}] \leavevmode
Device to which we are issuing command

\item[{\code{void \_\_user * arg}}] \leavevmode
User provided data for issuing command

\end{description}

\textbf{Description}
\begin{quote}

LOCKING:
Defined by the SCSI layer.  We don't really care.
\end{quote}

\textbf{Return}
\begin{quote}

Zero on success, negative errno on error.
\end{quote}
\index{ata\_scsi\_qc\_new (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_qc_new}\pysiglinewithargsret{struct ata\_queued\_cmd * \bfcode{ata\_scsi\_qc\_new}}{struct ata\_device *\emph{ dev}, struct scsi\_cmnd *\emph{ cmd}}{}
acquire new ata\_queued\_cmd reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
ATA device to which the new command is attached

\item[{\code{struct scsi\_cmnd * cmd}}] \leavevmode
SCSI command that originated this ATA command

\end{description}

\textbf{Description}
\begin{quote}

Obtain a reference to an unused ata\_queued\_cmd structure,
which is the basic libata structure representing a single
ATA command sent to the hardware.

If a command was available, fill in the SCSI-specific
portions of the structure with information on the
current command.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}

\textbf{Return}
\begin{quote}

Command allocated, or \code{NULL} if none available.
\end{quote}
\index{ata\_dump\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_dump_status}\pysiglinewithargsret{void \bfcode{ata\_dump\_status}}{unsigned\emph{ id}, struct ata\_taskfile *\emph{ tf}}{}
user friendly display of error info

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned id}}] \leavevmode
id of the port in question

\item[{\code{struct ata\_taskfile * tf}}] \leavevmode
ptr to filled out taskfile

\end{description}

\textbf{Description}
\begin{quote}

Decode and dump the ATA error/status registers for the user so
that they have some idea what really happened at the non
make-believe layer.

LOCKING:
inherited from caller
\end{quote}
\index{ata\_to\_sense\_error (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_to_sense_error}\pysiglinewithargsret{void \bfcode{ata\_to\_sense\_error}}{unsigned\emph{ id}, u8\emph{ drv\_stat}, u8\emph{ drv\_err}, u8 *\emph{ sk}, u8 *\emph{ asc}, u8 *\emph{ ascq}, int\emph{ verbose}}{}
convert ATA error to SCSI error

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned id}}] \leavevmode
ATA device number

\item[{\code{u8 drv\_stat}}] \leavevmode
value contained in ATA status register

\item[{\code{u8 drv\_err}}] \leavevmode
value contained in ATA error register

\item[{\code{u8 * sk}}] \leavevmode
the sense key we'll fill out

\item[{\code{u8 * asc}}] \leavevmode
the additional sense code we'll fill out

\item[{\code{u8 * ascq}}] \leavevmode
the additional sense code qualifier we'll fill out

\item[{\code{int verbose}}] \leavevmode
be verbose

\end{description}

\textbf{Description}
\begin{quote}

Converts an ATA error into a SCSI error.  Fill out pointers to
SK, ASC, and ASCQ bytes for later use in fixed or descriptor
format sense blocks.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_gen\_ata\_sense (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_gen_ata_sense}\pysiglinewithargsret{void \bfcode{ata\_gen\_ata\_sense}}{struct ata\_queued\_cmd *\emph{ qc}}{}
generate a SCSI fixed sense block

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Command that we are erroring out

\end{description}

\textbf{Description}
\begin{quote}

Generate sense block for a failed ATA command \textbf{qc}.  Descriptor
format is used to accommodate LBA48 block address.

LOCKING:
None.
\end{quote}
\index{atapi\_drain\_needed (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.atapi_drain_needed}\pysiglinewithargsret{int \bfcode{atapi\_drain\_needed}}{struct request *\emph{ rq}}{}
Check whether data transfer may overflow

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct request * rq}}] \leavevmode
request to be checked

\end{description}

\textbf{Description}
\begin{quote}

ATAPI commands which transfer variable length data to host
might overflow due to application error or hardware bug.  This
function checks whether overflow should be drained and ignored
for \textbf{request}.

LOCKING:
None.
\end{quote}

\textbf{Return}
\begin{quote}

1 if ; otherwise, 0.
\end{quote}
\index{ata\_scsi\_slave\_config (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_slave_config}\pysiglinewithargsret{int \bfcode{ata\_scsi\_slave\_config}}{struct scsi\_device *\emph{ sdev}}{}
Set SCSI device attributes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
SCSI device to examine

\end{description}

\textbf{Description}
\begin{quote}

This is called before we actually start reading
and writing to the device, to configure certain
SCSI mid-layer behaviors.

LOCKING:
Defined by SCSI layer.  We don't really care.
\end{quote}
\index{ata\_scsi\_slave\_destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_slave_destroy}\pysiglinewithargsret{void \bfcode{ata\_scsi\_slave\_destroy}}{struct scsi\_device *\emph{ sdev}}{}
SCSI device is about to be destroyed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
SCSI device to be destroyed

\end{description}

\textbf{Description}
\begin{quote}

\textbf{sdev} is about to be destroyed for hot/warm unplugging.  If
this unplugging was initiated by libata as indicated by NULL
dev-\textgreater{}sdev, this function doesn't have to do anything.
Otherwise, SCSI layer initiated warm-unplug is in progress.
Clear dev-\textgreater{}sdev, schedule the device for ATA detach and invoke
EH.

LOCKING:
Defined by SCSI layer.  We don't really care.
\end{quote}
\index{\_\_ata\_change\_queue\_depth (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.__ata_change_queue_depth}\pysiglinewithargsret{int \bfcode{\_\_ata\_change\_queue\_depth}}{struct ata\_port *\emph{ ap}, struct scsi\_device *\emph{ sdev}, int\emph{ queue\_depth}}{}
helper for ata\_scsi\_change\_queue\_depth

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to which the device change the queue depth

\item[{\code{struct scsi\_device * sdev}}] \leavevmode
SCSI device to configure queue depth for

\item[{\code{int queue\_depth}}] \leavevmode
new queue depth

\end{description}

\textbf{Description}
\begin{quote}

libsas and libata have different approaches for associating a sdev to
its ata\_port.
\end{quote}
\index{ata\_scsi\_change\_queue\_depth (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_change_queue_depth}\pysiglinewithargsret{int \bfcode{ata\_scsi\_change\_queue\_depth}}{struct scsi\_device *\emph{ sdev}, int\emph{ queue\_depth}}{}
SCSI callback for queue depth config

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_device * sdev}}] \leavevmode
SCSI device to configure queue depth for

\item[{\code{int queue\_depth}}] \leavevmode
new queue depth

\end{description}

\textbf{Description}
\begin{quote}

This is libata standard hostt-\textgreater{}change\_queue\_depth callback.
SCSI will call into this callback when user tries to set queue
depth via sysfs.

LOCKING:
SCSI layer (we don't care)
\end{quote}

\textbf{Return}
\begin{quote}

Newly configured queue depth.
\end{quote}
\index{ata\_scsi\_start\_stop\_xlat (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_start_stop_xlat}\pysiglinewithargsret{unsigned int \bfcode{ata\_scsi\_start\_stop\_xlat}}{struct ata\_queued\_cmd *\emph{ qc}}{}
Translate SCSI START STOP UNIT command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Storage for translated ATA taskfile

\end{description}

\textbf{Description}
\begin{quote}

Sets up an ATA taskfile to issue STANDBY (to stop) or READ VERIFY
(to start). Perhaps these commands should be preceded by
CHECK POWER MODE to see what power mode the device is already in.
{[}See SAT revision 5 at www.t10.org{]}

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}

\textbf{Return}
\begin{quote}

Zero on success, non-zero on error.
\end{quote}
\index{ata\_scsi\_flush\_xlat (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_flush_xlat}\pysiglinewithargsret{unsigned int \bfcode{ata\_scsi\_flush\_xlat}}{struct ata\_queued\_cmd *\emph{ qc}}{}
Translate SCSI SYNCHRONIZE CACHE command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Storage for translated ATA taskfile

\end{description}

\textbf{Description}
\begin{quote}

Sets up an ATA taskfile to issue FLUSH CACHE or
FLUSH CACHE EXT.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}

\textbf{Return}
\begin{quote}

Zero on success, non-zero on error.
\end{quote}
\index{scsi\_6\_lba\_len (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.scsi_6_lba_len}\pysiglinewithargsret{void \bfcode{scsi\_6\_lba\_len}}{const u8 *\emph{ cdb}, u64 *\emph{ plba}, u32 *\emph{ plen}}{}
Get LBA and transfer length

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * cdb}}] \leavevmode
SCSI command to translate

\item[{\code{u64 * plba}}] \leavevmode
the LBA

\item[{\code{u32 * plen}}] \leavevmode
the transfer length

\end{description}

\textbf{Description}
\begin{quote}

Calculate LBA and transfer length for 6-byte commands.
\end{quote}
\index{scsi\_10\_lba\_len (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.scsi_10_lba_len}\pysiglinewithargsret{void \bfcode{scsi\_10\_lba\_len}}{const u8 *\emph{ cdb}, u64 *\emph{ plba}, u32 *\emph{ plen}}{}
Get LBA and transfer length

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * cdb}}] \leavevmode
SCSI command to translate

\item[{\code{u64 * plba}}] \leavevmode
the LBA

\item[{\code{u32 * plen}}] \leavevmode
the transfer length

\end{description}

\textbf{Description}
\begin{quote}

Calculate LBA and transfer length for 10-byte commands.
\end{quote}
\index{scsi\_16\_lba\_len (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.scsi_16_lba_len}\pysiglinewithargsret{void \bfcode{scsi\_16\_lba\_len}}{const u8 *\emph{ cdb}, u64 *\emph{ plba}, u32 *\emph{ plen}}{}
Get LBA and transfer length

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * cdb}}] \leavevmode
SCSI command to translate

\item[{\code{u64 * plba}}] \leavevmode
the LBA

\item[{\code{u32 * plen}}] \leavevmode
the transfer length

\end{description}

\textbf{Description}
\begin{quote}

Calculate LBA and transfer length for 16-byte commands.
\end{quote}
\index{ata\_scsi\_verify\_xlat (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_verify_xlat}\pysiglinewithargsret{unsigned int \bfcode{ata\_scsi\_verify\_xlat}}{struct ata\_queued\_cmd *\emph{ qc}}{}
Translate SCSI VERIFY command into an ATA one

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Storage for translated ATA taskfile

\end{description}

\textbf{Description}
\begin{quote}

Converts SCSI VERIFY command to an ATA READ VERIFY command.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}

\textbf{Return}
\begin{quote}

Zero on success, non-zero on error.
\end{quote}
\index{ata\_scsi\_rw\_xlat (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_rw_xlat}\pysiglinewithargsret{unsigned int \bfcode{ata\_scsi\_rw\_xlat}}{struct ata\_queued\_cmd *\emph{ qc}}{}
Translate SCSI r/w command into an ATA one

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Storage for translated ATA taskfile

\end{description}

\textbf{Description}
\begin{quote}

Converts any of six SCSI read/write commands into the
ATA counterpart, including starting sector (LBA),
sector count, and taking into account the device's LBA48
support.

Commands \code{READ\_6}, \code{READ\_10}, \code{READ\_16}, \code{WRITE\_6}, \code{WRITE\_10}, and
\code{WRITE\_16} are currently supported.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}

\textbf{Return}
\begin{quote}

Zero on success, non-zero on error.
\end{quote}
\index{ata\_scsi\_translate (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_translate}\pysiglinewithargsret{int \bfcode{ata\_scsi\_translate}}{struct ata\_device *\emph{ dev}, struct scsi\_cmnd *\emph{ cmd}, ata\_xlat\_func\_t\emph{ xlat\_func}}{}
Translate then issue SCSI command to ATA device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
ATA device to which the command is addressed

\item[{\code{struct scsi\_cmnd * cmd}}] \leavevmode
SCSI command to execute

\item[{\code{ata\_xlat\_func\_t xlat\_func}}] \leavevmode
Actor which translates \textbf{cmd} to an ATA taskfile

\end{description}

\textbf{Description}
\begin{quote}

Our -\textgreater{}:c:func:\emph{queuecommand()} function has decided that the SCSI
command issued can be directly translated into an ATA
command, rather than handled internally.

This function sets up an ata\_queued\_cmd structure for the
SCSI command, and sends that ata\_queued\_cmd to the hardware.

The xlat\_func argument (actor) returns 0 if ready to execute
ATA command, else 1 to finish translation. If 1 is returned
then cmd-\textgreater{}result (and possibly cmd-\textgreater{}sense\_buffer) are assumed
to be set reflecting an error condition or clean (early)
termination.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}

\textbf{Return}
\begin{quote}

0 on success, SCSI\_ML\_QUEUE\_DEVICE\_BUSY if the command
needs to be deferred.
\end{quote}
\index{ata\_scsi\_rbuf\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_rbuf_get}\pysiglinewithargsret{void * \bfcode{ata\_scsi\_rbuf\_get}}{struct scsi\_cmnd *\emph{ cmd}, bool\emph{ copy\_in}, unsigned long *\emph{ flags}}{}
Map response buffer.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * cmd}}] \leavevmode
SCSI command containing buffer to be mapped.

\item[{\code{bool copy\_in}}] \leavevmode
copy in from user buffer

\item[{\code{unsigned long * flags}}] \leavevmode
unsigned long variable to store irq enable status

\end{description}

\textbf{Description}
\begin{quote}

Prepare buffer for simulated SCSI commands.

LOCKING:
spin\_lock\_irqsave(ata\_scsi\_rbuf\_lock) on success
\end{quote}

\textbf{Return}
\begin{quote}

Pointer to response buffer.
\end{quote}
\index{ata\_scsi\_rbuf\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_rbuf_put}\pysiglinewithargsret{void \bfcode{ata\_scsi\_rbuf\_put}}{struct scsi\_cmnd *\emph{ cmd}, bool\emph{ copy\_out}, unsigned long *\emph{ flags}}{}
Unmap response buffer.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * cmd}}] \leavevmode
SCSI command containing buffer to be unmapped.

\item[{\code{bool copy\_out}}] \leavevmode
copy out result

\item[{\code{unsigned long * flags}}] \leavevmode
\textbf{flags} passed to {\hyperref[driver\string-api/libata:c.ata_scsi_rbuf_get]{\emph{\code{ata\_scsi\_rbuf\_get()}}}}

\end{description}

\textbf{Description}
\begin{quote}

Returns rbuf buffer.  The result is copied to \textbf{cmd}`s buffer if
\textbf{copy\_back} is true.

LOCKING:
Unlocks ata\_scsi\_rbuf\_lock.
\end{quote}
\index{ata\_scsi\_rbuf\_fill (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_rbuf_fill}\pysiglinewithargsret{void \bfcode{ata\_scsi\_rbuf\_fill}}{struct ata\_scsi\_args *\emph{ args}, unsigned int (*actor) (struct ata\_scsi\_args\emph{ *args}, u8\emph{ *rbuf}}{}
wrapper for SCSI command simulators

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_scsi\_args * args}}] \leavevmode
device IDENTIFY data / SCSI command of interest.

\item[{\code{unsigned int (*)(struct ata\_scsi\_args *args, u8 *rbuf) actor}}] \leavevmode
Callback hook for desired SCSI command simulator

\end{description}

\textbf{Description}
\begin{quote}

Takes care of the hard work of simulating a SCSI command...
Mapping the response buffer, calling the command's handler,
and handling the handler's return value.  This return value
indicates whether the handler wishes the SCSI command to be
completed successfully (0), or not (in which case cmd-\textgreater{}result
and sense buffer are assumed to be set).

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_scsiop\_inq\_std (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsiop_inq_std}\pysiglinewithargsret{unsigned int \bfcode{ata\_scsiop\_inq\_std}}{struct ata\_scsi\_args *\emph{ args}, u8 *\emph{ rbuf}}{}
Simulate INQUIRY command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_scsi\_args * args}}] \leavevmode
device IDENTIFY data / SCSI command of interest.

\item[{\code{u8 * rbuf}}] \leavevmode
Response buffer, to which simulated SCSI cmd output is sent.

\end{description}

\textbf{Description}
\begin{quote}

Returns standard device identification data associated
with non-VPD INQUIRY command output.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_scsiop\_inq\_00 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsiop_inq_00}\pysiglinewithargsret{unsigned int \bfcode{ata\_scsiop\_inq\_00}}{struct ata\_scsi\_args *\emph{ args}, u8 *\emph{ rbuf}}{}
Simulate INQUIRY VPD page 0, list of pages

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_scsi\_args * args}}] \leavevmode
device IDENTIFY data / SCSI command of interest.

\item[{\code{u8 * rbuf}}] \leavevmode
Response buffer, to which simulated SCSI cmd output is sent.

\end{description}

\textbf{Description}
\begin{quote}

Returns list of inquiry VPD pages available.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_scsiop\_inq\_80 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsiop_inq_80}\pysiglinewithargsret{unsigned int \bfcode{ata\_scsiop\_inq\_80}}{struct ata\_scsi\_args *\emph{ args}, u8 *\emph{ rbuf}}{}
Simulate INQUIRY VPD page 80, device serial number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_scsi\_args * args}}] \leavevmode
device IDENTIFY data / SCSI command of interest.

\item[{\code{u8 * rbuf}}] \leavevmode
Response buffer, to which simulated SCSI cmd output is sent.

\end{description}

\textbf{Description}
\begin{quote}

Returns ATA device serial number.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_scsiop\_inq\_83 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsiop_inq_83}\pysiglinewithargsret{unsigned int \bfcode{ata\_scsiop\_inq\_83}}{struct ata\_scsi\_args *\emph{ args}, u8 *\emph{ rbuf}}{}
Simulate INQUIRY VPD page 83, device identity

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_scsi\_args * args}}] \leavevmode
device IDENTIFY data / SCSI command of interest.

\item[{\code{u8 * rbuf}}] \leavevmode
Response buffer, to which simulated SCSI cmd output is sent.

\end{description}

\textbf{Description}
\begin{quote}
\begin{description}
\item[{Yields two logical unit device identification designators:}] \leavevmode\begin{itemize}
\item {} 
vendor specific ASCII containing the ATA serial number

\item {} 
SAT defined ``t10 vendor id based'' containing ASCII vendor
name (``ATA     ''), model and serial numbers.

\end{itemize}

\end{description}

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_scsiop\_inq\_89 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsiop_inq_89}\pysiglinewithargsret{unsigned int \bfcode{ata\_scsiop\_inq\_89}}{struct ata\_scsi\_args *\emph{ args}, u8 *\emph{ rbuf}}{}
Simulate INQUIRY VPD page 89, ATA info

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_scsi\_args * args}}] \leavevmode
device IDENTIFY data / SCSI command of interest.

\item[{\code{u8 * rbuf}}] \leavevmode
Response buffer, to which simulated SCSI cmd output is sent.

\end{description}

\textbf{Description}
\begin{quote}

Yields SAT-specified ATA VPD page.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{modecpy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.modecpy}\pysiglinewithargsret{void \bfcode{modecpy}}{u8 *\emph{ dest}, const u8 *\emph{ src}, int\emph{ n}, bool\emph{ changeable}}{}
Prepare response for MODE SENSE

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 * dest}}] \leavevmode
output buffer

\item[{\code{const u8 * src}}] \leavevmode
data being copied

\item[{\code{int n}}] \leavevmode
length of mode page

\item[{\code{bool changeable}}] \leavevmode
whether changeable parameters are requested

\end{description}

\textbf{Description}
\begin{quote}

Generate a generic MODE SENSE page for either current or changeable
parameters.

LOCKING:
None.
\end{quote}
\index{ata\_msense\_caching (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_msense_caching}\pysiglinewithargsret{unsigned int \bfcode{ata\_msense\_caching}}{u16 *\emph{ id}, u8 *\emph{ buf}, bool\emph{ changeable}}{}
Simulate MODE SENSE caching info page

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u16 * id}}] \leavevmode
device IDENTIFY data

\item[{\code{u8 * buf}}] \leavevmode
output buffer

\item[{\code{bool changeable}}] \leavevmode
whether changeable parameters are requested

\end{description}

\textbf{Description}
\begin{quote}

Generate a caching info page, which conditionally indicates
write caching to the SCSI layer, depending on device
capabilities.

LOCKING:
None.
\end{quote}
\index{ata\_msense\_control (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_msense_control}\pysiglinewithargsret{unsigned int \bfcode{ata\_msense\_control}}{struct ata\_device *\emph{ dev}, u8 *\emph{ buf}, bool\emph{ changeable}}{}
Simulate MODE SENSE control mode page

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
ATA device of interest

\item[{\code{u8 * buf}}] \leavevmode
output buffer

\item[{\code{bool changeable}}] \leavevmode
whether changeable parameters are requested

\end{description}

\textbf{Description}
\begin{quote}

Generate a generic MODE SENSE control mode page.

LOCKING:
None.
\end{quote}
\index{ata\_msense\_rw\_recovery (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_msense_rw_recovery}\pysiglinewithargsret{unsigned int \bfcode{ata\_msense\_rw\_recovery}}{u8 *\emph{ buf}, bool\emph{ changeable}}{}
Simulate MODE SENSE r/w error recovery page

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 * buf}}] \leavevmode
output buffer

\item[{\code{bool changeable}}] \leavevmode
whether changeable parameters are requested

\end{description}

\textbf{Description}
\begin{quote}

Generate a generic MODE SENSE r/w error recovery page.

LOCKING:
None.
\end{quote}
\index{ata\_scsiop\_mode\_sense (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsiop_mode_sense}\pysiglinewithargsret{unsigned int \bfcode{ata\_scsiop\_mode\_sense}}{struct ata\_scsi\_args *\emph{ args}, u8 *\emph{ rbuf}}{}
Simulate MODE SENSE 6, 10 commands

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_scsi\_args * args}}] \leavevmode
device IDENTIFY data / SCSI command of interest.

\item[{\code{u8 * rbuf}}] \leavevmode
Response buffer, to which simulated SCSI cmd output is sent.

\end{description}

\textbf{Description}
\begin{quote}

Simulate MODE SENSE commands. Assume this is invoked for direct
access devices (e.g. disks) only. There should be no block
descriptor for other device types.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_scsiop\_read\_cap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsiop_read_cap}\pysiglinewithargsret{unsigned int \bfcode{ata\_scsiop\_read\_cap}}{struct ata\_scsi\_args *\emph{ args}, u8 *\emph{ rbuf}}{}
Simulate READ CAPACITY{[} 16{]} commands

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_scsi\_args * args}}] \leavevmode
device IDENTIFY data / SCSI command of interest.

\item[{\code{u8 * rbuf}}] \leavevmode
Response buffer, to which simulated SCSI cmd output is sent.

\end{description}

\textbf{Description}
\begin{quote}

Simulate READ CAPACITY commands.

LOCKING:
None.
\end{quote}
\index{ata\_scsiop\_report\_luns (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsiop_report_luns}\pysiglinewithargsret{unsigned int \bfcode{ata\_scsiop\_report\_luns}}{struct ata\_scsi\_args *\emph{ args}, u8 *\emph{ rbuf}}{}
Simulate REPORT LUNS command

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_scsi\_args * args}}] \leavevmode
device IDENTIFY data / SCSI command of interest.

\item[{\code{u8 * rbuf}}] \leavevmode
Response buffer, to which simulated SCSI cmd output is sent.

\end{description}

\textbf{Description}
\begin{quote}

Simulate REPORT LUNS command.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{atapi\_xlat (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.atapi_xlat}\pysiglinewithargsret{unsigned int \bfcode{atapi\_xlat}}{struct ata\_queued\_cmd *\emph{ qc}}{}
Initialize PACKET taskfile

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
command structure to be initialized

\end{description}

\textbf{Description}
\begin{quote}

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}

\textbf{Return}
\begin{quote}

Zero on success, non-zero on failure.
\end{quote}
\index{ata\_scsi\_find\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_find_dev}\pysiglinewithargsret{struct ata\_device * \bfcode{ata\_scsi\_find\_dev}}{struct ata\_port *\emph{ ap}, const struct scsi\_device *\emph{ scsidev}}{}
lookup ata\_device from scsi\_cmnd

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to which the device is attached

\item[{\code{const struct scsi\_device * scsidev}}] \leavevmode
SCSI device from which we derive the ATA device

\end{description}

\textbf{Description}
\begin{quote}

Given various information provided in struct scsi\_cmnd,
map that onto an ATA bus, and using that mapping
determine which ata\_device is associated with the
SCSI command to be sent.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}

\textbf{Return}
\begin{quote}

Associated ATA device, or \code{NULL} if not found.
\end{quote}
\index{ata\_scsi\_pass\_thru (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_pass_thru}\pysiglinewithargsret{unsigned int \bfcode{ata\_scsi\_pass\_thru}}{struct ata\_queued\_cmd *\emph{ qc}}{}
convert ATA pass-thru CDB to taskfile

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
command structure to be initialized

\end{description}

\textbf{Description}
\begin{quote}

Handles either 12, 16, or 32-byte versions of the CDB.
\end{quote}

\textbf{Return}
\begin{quote}

Zero on success, non-zero on failure.
\end{quote}
\index{ata\_format\_dsm\_trim\_descr (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_format_dsm_trim_descr}\pysiglinewithargsret{size\_t \bfcode{ata\_format\_dsm\_trim\_descr}}{struct scsi\_cmnd *\emph{ cmd}, u32\emph{ trmax}, u64\emph{ sector}, u32\emph{ count}}{}
SATL Write Same to DSM Trim

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct scsi\_cmnd * cmd}}] \leavevmode
SCSI command being translated

\item[{\code{u32 trmax}}] \leavevmode
Maximum number of entries that will fit in sector\_size bytes.

\item[{\code{u64 sector}}] \leavevmode
Starting sector

\item[{\code{u32 count}}] \leavevmode
Total Range of request in logical sectors

\end{description}

\textbf{Description}

Rewrite the WRITE SAME descriptor to be a DSM TRIM little-endian formatted
descriptor.
\begin{description}
\item[{Upto 64 entries of the format:}] \leavevmode\begin{quote}

63:48 Range Length
47:0  LBA
\end{quote}

Range Length of 0 is ignored.
LBA's should be sorted order and not overlap.

\end{description}

\textbf{NOTE}

this is the same format as ADD LBA(S) TO NV CACHE PINNED SET

\textbf{Return}

Number of bytes copied into sglist.
\index{ata\_scsi\_write\_same\_xlat (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_write_same_xlat}\pysiglinewithargsret{unsigned int \bfcode{ata\_scsi\_write\_same\_xlat}}{struct ata\_queued\_cmd *\emph{ qc}}{}
SATL Write Same to ATA SCT Write Same

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Command to be translated

\end{description}

\textbf{Description}

Translate a SCSI WRITE SAME command to be either a DSM TRIM command or
an SCT Write Same command.
Based on WRITE SAME has the UNMAP flag:
\begin{itemize}
\item {} 
When set translate to DSM TRIM

\item {} 
When clear translate to SCT Write Same

\end{itemize}
\index{ata\_scsiop\_maint\_in (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsiop_maint_in}\pysiglinewithargsret{unsigned int \bfcode{ata\_scsiop\_maint\_in}}{struct ata\_scsi\_args *\emph{ args}, u8 *\emph{ rbuf}}{}
Simulate a subset of MAINTENANCE\_IN

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_scsi\_args * args}}] \leavevmode
device MAINTENANCE\_IN data / SCSI command of interest.

\item[{\code{u8 * rbuf}}] \leavevmode
Response buffer, to which simulated SCSI cmd output is sent.

\end{description}

\textbf{Description}
\begin{quote}

Yields a subset to satisfy {\hyperref[driver\string-api/scsi:c.scsi_report_opcode]{\emph{\code{scsi\_report\_opcode()}}}}

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_scsi\_report\_zones\_complete (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_report_zones_complete}\pysiglinewithargsret{void \bfcode{ata\_scsi\_report\_zones\_complete}}{struct ata\_queued\_cmd *\emph{ qc}}{}
convert ATA output

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
command structure returning the data

\end{description}

\textbf{Description}
\begin{quote}

Convert T-13 little-endian field representation into
T-10 big-endian field representation.
What a mess.
\end{quote}
\index{ata\_mselect\_caching (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_mselect_caching}\pysiglinewithargsret{int \bfcode{ata\_mselect\_caching}}{struct ata\_queued\_cmd *\emph{ qc}, const u8 *\emph{ buf}, int\emph{ len}, u16 *\emph{ fp}}{}
Simulate MODE SELECT for caching info page

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Storage for translated ATA taskfile

\item[{\code{const u8 * buf}}] \leavevmode
input buffer

\item[{\code{int len}}] \leavevmode
number of valid bytes in the input buffer

\item[{\code{u16 * fp}}] \leavevmode
out parameter for the failed field on error

\end{description}

\textbf{Description}
\begin{quote}

Prepare a taskfile to modify caching information for the device.

LOCKING:
None.
\end{quote}
\index{ata\_mselect\_control (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_mselect_control}\pysiglinewithargsret{int \bfcode{ata\_mselect\_control}}{struct ata\_queued\_cmd *\emph{ qc}, const u8 *\emph{ buf}, int\emph{ len}, u16 *\emph{ fp}}{}
Simulate MODE SELECT for control page

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Storage for translated ATA taskfile

\item[{\code{const u8 * buf}}] \leavevmode
input buffer

\item[{\code{int len}}] \leavevmode
number of valid bytes in the input buffer

\item[{\code{u16 * fp}}] \leavevmode
out parameter for the failed field on error

\end{description}

\textbf{Description}
\begin{quote}

Prepare a taskfile to modify caching information for the device.

LOCKING:
None.
\end{quote}
\index{ata\_scsi\_mode\_select\_xlat (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_mode_select_xlat}\pysiglinewithargsret{unsigned int \bfcode{ata\_scsi\_mode\_select\_xlat}}{struct ata\_queued\_cmd *\emph{ qc}}{}
Simulate MODE SELECT 6, 10 commands

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Storage for translated ATA taskfile

\end{description}

\textbf{Description}
\begin{quote}

Converts a MODE SELECT command to an ATA SET FEATURES taskfile.
Assume this is invoked for direct access devices (e.g. disks) only.
There should be no block descriptor for other device types.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_scsi\_var\_len\_cdb\_xlat (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_var_len_cdb_xlat}\pysiglinewithargsret{unsigned int \bfcode{ata\_scsi\_var\_len\_cdb\_xlat}}{struct ata\_queued\_cmd *\emph{ qc}}{}
SATL variable length CDB to Handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_queued\_cmd * qc}}] \leavevmode
Command to be translated

\end{description}

\textbf{Description}
\begin{quote}

Translate a SCSI variable length CDB to specified commands.
It checks a service action value in CDB to call corresponding handler.
\end{quote}

\textbf{Return}
\begin{quote}

Zero on success, non-zero on failure
\end{quote}
\index{ata\_get\_xlat\_func (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_get_xlat_func}\pysiglinewithargsret{ata\_xlat\_func\_t \bfcode{ata\_get\_xlat\_func}}{struct ata\_device *\emph{ dev}, u8\emph{ cmd}}{}
check if SCSI to ATA translation is possible

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
ATA device

\item[{\code{u8 cmd}}] \leavevmode
SCSI command opcode to consider

\end{description}

\textbf{Description}
\begin{quote}

Look up the SCSI command given, and determine whether the
SCSI command is to be translated or simulated.
\end{quote}

\textbf{Return}
\begin{quote}

Pointer to translation function if possible, \code{NULL} if not.
\end{quote}
\index{ata\_scsi\_dump\_cdb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_dump_cdb}\pysiglinewithargsret{void \bfcode{ata\_scsi\_dump\_cdb}}{struct ata\_port *\emph{ ap}, struct scsi\_cmnd *\emph{ cmd}}{}
dump SCSI command contents to dmesg

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
ATA port to which the command was being sent

\item[{\code{struct scsi\_cmnd * cmd}}] \leavevmode
SCSI command to dump

\end{description}

\textbf{Description}
\begin{quote}

Prints the contents of a SCSI command via {\hyperref[driver\string-api/basics:c.printk]{\emph{\code{printk()}}}}.
\end{quote}
\index{ata\_scsi\_queuecmd (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_queuecmd}\pysiglinewithargsret{int \bfcode{ata\_scsi\_queuecmd}}{struct Scsi\_Host *\emph{ shost}, struct scsi\_cmnd *\emph{ cmd}}{}
Issue SCSI cdb to libata-managed device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
SCSI host of command to be sent

\item[{\code{struct scsi\_cmnd * cmd}}] \leavevmode
SCSI command to be sent

\end{description}

\textbf{Description}
\begin{quote}

In some cases, this function translates SCSI commands into
ATA taskfiles, and queues the taskfiles to be sent to
hardware.  In other cases, this function simulates a
SCSI device by evaluating and responding to certain
SCSI commands.  This creates the overall effect of
ATA and ATAPI devices appearing as SCSI devices.

LOCKING:
ATA host lock
\end{quote}

\textbf{Return}
\begin{quote}

Return value from \code{\_\_ata\_scsi\_queuecmd()} if \textbf{cmd} can be queued,
0 otherwise.
\end{quote}
\index{ata\_scsi\_simulate (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_simulate}\pysiglinewithargsret{void \bfcode{ata\_scsi\_simulate}}{struct ata\_device *\emph{ dev}, struct scsi\_cmnd *\emph{ cmd}}{}
simulate SCSI command on ATA device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
the target device

\item[{\code{struct scsi\_cmnd * cmd}}] \leavevmode
SCSI command being sent to device.

\end{description}

\textbf{Description}
\begin{quote}

Interprets and directly executes a select list of SCSI commands
that can be handled internally.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_scsi\_offline\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_offline_dev}\pysiglinewithargsret{int \bfcode{ata\_scsi\_offline\_dev}}{struct ata\_device *\emph{ dev}}{}
offline attached SCSI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
ATA device to offline attached SCSI device for

\end{description}

\textbf{Description}
\begin{quote}

This function is called from \code{ata\_eh\_hotplug()} and responsible
for taking the SCSI device attached to \textbf{dev} offline.  This
function is called with host lock which protects dev-\textgreater{}sdev
against clearing.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}

\textbf{Return}
\begin{quote}

1 if attached SCSI device exists, 0 otherwise.
\end{quote}
\index{ata\_scsi\_remove\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_remove_dev}\pysiglinewithargsret{void \bfcode{ata\_scsi\_remove\_dev}}{struct ata\_device *\emph{ dev}}{}
remove attached SCSI device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
ATA device to remove attached SCSI device for

\end{description}

\textbf{Description}
\begin{quote}

This function is called from \code{ata\_eh\_scsi\_hotplug()} and
responsible for removing the SCSI device attached to \textbf{dev}.

LOCKING:
Kernel thread context (may sleep).
\end{quote}
\index{ata\_scsi\_media\_change\_notify (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_media_change_notify}\pysiglinewithargsret{void \bfcode{ata\_scsi\_media\_change\_notify}}{struct ata\_device *\emph{ dev}}{}
send media change event

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
Pointer to the disk device with media change event

\end{description}

\textbf{Description}
\begin{quote}

Tell the block layer to send a media change notification
event.

LOCKING:
spin\_lock\_irqsave(host lock)
\end{quote}
\index{ata\_scsi\_hotplug (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_hotplug}\pysiglinewithargsret{void \bfcode{ata\_scsi\_hotplug}}{struct work\_struct *\emph{ work}}{}
SCSI part of hotplug

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct work\_struct * work}}] \leavevmode
Pointer to ATA port to perform SCSI hotplug on

\end{description}

\textbf{Description}
\begin{quote}

Perform SCSI part of hotplug.  It's executed from a separate
workqueue after EH completes.  This is necessary because SCSI
hot plugging requires working EH and hot unplugging is
synchronized with hot plugging with a mutex.

LOCKING:
Kernel thread context (may sleep).
\end{quote}
\index{ata\_scsi\_user\_scan (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_user_scan}\pysiglinewithargsret{int \bfcode{ata\_scsi\_user\_scan}}{struct Scsi\_Host *\emph{ shost}, unsigned int\emph{ channel}, unsigned int\emph{ id}, u64\emph{ lun}}{}
indication for user-initiated bus scan

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct Scsi\_Host * shost}}] \leavevmode
SCSI host to scan

\item[{\code{unsigned int channel}}] \leavevmode
Channel to scan

\item[{\code{unsigned int id}}] \leavevmode
ID to scan

\item[{\code{u64 lun}}] \leavevmode
LUN to scan

\end{description}

\textbf{Description}
\begin{quote}

This function is called when user explicitly requests bus
scan.  Set probe pending flag and invoke EH.

LOCKING:
SCSI layer (we don't care)
\end{quote}

\textbf{Return}
\begin{quote}

Zero.
\end{quote}
\index{ata\_scsi\_dev\_rescan (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ata_scsi_dev_rescan}\pysiglinewithargsret{void \bfcode{ata\_scsi\_dev\_rescan}}{struct work\_struct *\emph{ work}}{}
initiate \code{scsi\_rescan\_device()}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct work\_struct * work}}] \leavevmode
Pointer to ATA port to perform \code{scsi\_rescan\_device()}

\end{description}

\textbf{Description}
\begin{quote}

After ATA pass thru (SAT) commands are executed successfully,
libata need to propagate the changes to SCSI layer.

LOCKING:
Kernel thread context (may sleep).
\end{quote}


\section{ATA errors and exceptions}
\label{driver-api/libata:ata-errors-and-exceptions}
This chapter tries to identify what error/exception conditions exist for
ATA/ATAPI devices and describe how they should be handled in
implementation-neutral way.

The term `error' is used to describe conditions where either an explicit
error condition is reported from device or a command has timed out.

The term `exception' is either used to describe exceptional conditions
which are not errors (say, power or hotplug events), or to describe both
errors and non-error exceptional conditions. Where explicit distinction
between error and exception is necessary, the term `non-error exception'
is used.


\subsection{Exception categories}
\label{driver-api/libata:exception-categories}
Exceptions are described primarily with respect to legacy taskfile + bus
master IDE interface. If a controller provides other better mechanism
for error reporting, mapping those into categories described below
shouldn't be difficult.

In the following sections, two recovery actions - reset and
reconfiguring transport - are mentioned. These are described further in
{\hyperref[driver\string-api/libata:exrec]{\emph{EH recovery actions}}}.


\subsubsection{HSM violation}
\label{driver-api/libata:hsm-violation}
This error is indicated when STATUS value doesn't match HSM requirement
during issuing or execution any ATA/ATAPI command.
\begin{itemize}
\item {} 
ATA\_STATUS doesn't contain !BSY \&\& DRDY \&\& !DRQ while trying to
issue a command.

\item {} 
!BSY \&\& !DRQ during PIO data transfer.

\item {} 
DRQ on command completion.

\item {} 
!BSY \&\& ERR after CDB transfer starts but before the last byte of CDB
is transferred. ATA/ATAPI standard states that ``The device shall not
terminate the PACKET command with an error before the last byte of
the command packet has been written'' in the error outputs description
of PACKET command and the state diagram doesn't include such
transitions.

\end{itemize}

In these cases, HSM is violated and not much information regarding the
error can be acquired from STATUS or ERROR register. IOW, this error can
be anything - driver bug, faulty device, controller and/or cable.

As HSM is violated, reset is necessary to restore known state.
Reconfiguring transport for lower speed might be helpful too as
transmission errors sometimes cause this kind of errors.


\subsubsection{ATA/ATAPI device error (non-NCQ / non-CHECK CONDITION)}
\label{driver-api/libata:ata-atapi-device-error-non-ncq-non-check-condition}
These are errors detected and reported by ATA/ATAPI devices indicating
device problems. For this type of errors, STATUS and ERROR register
values are valid and describe error condition. Note that some of ATA bus
errors are detected by ATA/ATAPI devices and reported using the same
mechanism as device errors. Those cases are described later in this
section.

For ATA commands, this type of errors are indicated by !BSY \&\& ERR
during command execution and on completion.

For ATAPI commands,
\begin{itemize}
\item {} 
!BSY \&\& ERR \&\& ABRT right after issuing PACKET indicates that PACKET
command is not supported and falls in this category.

\item {} 
!BSY \&\& ERR(==CHK) \&\& !ABRT after the last byte of CDB is transferred
indicates CHECK CONDITION and doesn't fall in this category.

\item {} 
!BSY \&\& ERR(==CHK) \&\& ABRT after the last byte of CDB is transferred
*probably* indicates CHECK CONDITION and doesn't fall in this
category.

\end{itemize}

Of errors detected as above, the following are not ATA/ATAPI device
errors but ATA bus errors and should be handled according to
{\hyperref[driver\string-api/libata:excatATAbusErr]{\emph{ATA bus error}}}.
\begin{description}
\item[{CRC error during data transfer}] \leavevmode
This is indicated by ICRC bit in the ERROR register and means that
corruption occurred during data transfer. Up to ATA/ATAPI-7, the
standard specifies that this bit is only applicable to UDMA
transfers but ATA/ATAPI-8 draft revision 1f says that the bit may be
applicable to multiword DMA and PIO.

\item[{ABRT error during data transfer or on completion}] \leavevmode
Up to ATA/ATAPI-7, the standard specifies that ABRT could be set on
ICRC errors and on cases where a device is not able to complete a
command. Combined with the fact that MWDMA and PIO transfer errors
aren't allowed to use ICRC bit up to ATA/ATAPI-7, it seems to imply
that ABRT bit alone could indicate transfer errors.

However, ATA/ATAPI-8 draft revision 1f removes the part that ICRC
errors can turn on ABRT. So, this is kind of gray area. Some
heuristics are needed here.

\end{description}

ATA/ATAPI device errors can be further categorized as follows.
\begin{description}
\item[{Media errors}] \leavevmode
This is indicated by UNC bit in the ERROR register. ATA devices
reports UNC error only after certain number of retries cannot
recover the data, so there's nothing much else to do other than
notifying upper layer.

READ and WRITE commands report CHS or LBA of the first failed sector
but ATA/ATAPI standard specifies that the amount of transferred data
on error completion is indeterminate, so we cannot assume that
sectors preceding the failed sector have been transferred and thus
cannot complete those sectors successfully as SCSI does.

\item[{Media changed / media change requested error}] \leavevmode
\textless{}\textless{}TODO: fill here\textgreater{}\textgreater{}

\item[{Address error}] \leavevmode
This is indicated by IDNF bit in the ERROR register. Report to upper
layer.

\item[{Other errors}] \leavevmode
This can be invalid command or parameter indicated by ABRT ERROR bit
or some other error condition. Note that ABRT bit can indicate a lot
of things including ICRC and Address errors. Heuristics needed.

\end{description}

Depending on commands, not all STATUS/ERROR bits are applicable. These
non-applicable bits are marked with ``na'' in the output descriptions but
up to ATA/ATAPI-7 no definition of ``na'' can be found. However,
ATA/ATAPI-8 draft revision 1f describes ``N/A'' as follows.
\begin{quote}
\begin{description}
\item[{3.2.3.3a N/A}] \leavevmode
A keyword the indicates a field has no defined value in this
standard and should not be checked by the host or device. N/A
fields should be cleared to zero.

\end{description}
\end{quote}

So, it seems reasonable to assume that ``na'' bits are cleared to zero by
devices and thus need no explicit masking.


\subsubsection{ATAPI device CHECK CONDITION}
\label{driver-api/libata:atapi-device-check-condition}
ATAPI device CHECK CONDITION error is indicated by set CHK bit (ERR bit)
in the STATUS register after the last byte of CDB is transferred for a
PACKET command. For this kind of errors, sense data should be acquired
to gather information regarding the errors. REQUEST SENSE packet command
should be used to acquire sense data.

Once sense data is acquired, this type of errors can be handled
similarly to other SCSI errors. Note that sense data may indicate ATA
bus error (e.g. Sense Key 04h HARDWARE ERROR \&\& ASC/ASCQ 47h/00h SCSI
PARITY ERROR). In such cases, the error should be considered as an ATA
bus error and handled according to {\hyperref[driver\string-api/libata:excatATAbusErr]{\emph{ATA bus error}}}.


\subsubsection{ATA device error (NCQ)}
\label{driver-api/libata:ata-device-error-ncq}
NCQ command error is indicated by cleared BSY and set ERR bit during NCQ
command phase (one or more NCQ commands outstanding). Although STATUS
and ERROR registers will contain valid values describing the error, READ
LOG EXT is required to clear the error condition, determine which
command has failed and acquire more information.

READ LOG EXT Log Page 10h reports which tag has failed and taskfile
register values describing the error. With this information the failed
command can be handled as a normal ATA command error as in
{\hyperref[driver\string-api/libata:excatDevErr]{\emph{ATA/ATAPI device error (non-NCQ / non-CHECK CONDITION)}}}
and all other in-flight commands must be retried. Note that this retry
should not be counted - it's likely that commands retried this way would
have completed normally if it were not for the failed command.

Note that ATA bus errors can be reported as ATA device NCQ errors. This
should be handled as described in {\hyperref[driver\string-api/libata:excatATAbusErr]{\emph{ATA bus error}}}.

If READ LOG EXT Log Page 10h fails or reports NQ, we're thoroughly
screwed. This condition should be treated according to
{\hyperref[driver\string-api/libata:excatHSMviolation]{\emph{HSM violation}}}.


\subsubsection{ATA bus error}
\label{driver-api/libata:ata-bus-error}
ATA bus error means that data corruption occurred during transmission
over ATA bus (SATA or PATA). This type of errors can be indicated by
\begin{itemize}
\item {} 
ICRC or ABRT error as described in
{\hyperref[driver\string-api/libata:excatDevErr]{\emph{ATA/ATAPI device error (non-NCQ / non-CHECK CONDITION)}}}.

\item {} 
Controller-specific error completion with error information
indicating transmission error.

\item {} 
On some controllers, command timeout. In this case, there may be a
mechanism to determine that the timeout is due to transmission error.

\item {} 
Unknown/random errors, timeouts and all sorts of weirdities.

\end{itemize}

As described above, transmission errors can cause wide variety of
symptoms ranging from device ICRC error to random device lockup, and,
for many cases, there is no way to tell if an error condition is due to
transmission error or not; therefore, it's necessary to employ some kind
of heuristic when dealing with errors and timeouts. For example,
encountering repetitive ABRT errors for known supported command is
likely to indicate ATA bus error.

Once it's determined that ATA bus errors have possibly occurred,
lowering ATA bus transmission speed is one of actions which may
alleviate the problem. See {\hyperref[driver\string-api/libata:exrecReconf]{\emph{Reconfigure transport}}} for
more information.


\subsubsection{PCI bus error}
\label{driver-api/libata:pci-bus-error}
Data corruption or other failures during transmission over PCI (or other
system bus). For standard BMDMA, this is indicated by Error bit in the
BMDMA Status register. This type of errors must be logged as it
indicates something is very wrong with the system. Resetting host
controller is recommended.


\subsubsection{Late completion}
\label{driver-api/libata:late-completion}
This occurs when timeout occurs and the timeout handler finds out that
the timed out command has completed successfully or with error. This is
usually caused by lost interrupts. This type of errors must be logged.
Resetting host controller is recommended.


\subsubsection{Unknown error (timeout)}
\label{driver-api/libata:unknown-error-timeout}
This is when timeout occurs and the command is still processing or the
host and device are in unknown state. When this occurs, HSM could be in
any valid or invalid state. To bring the device to known state and make
it forget about the timed out command, resetting is necessary. The timed
out command may be retried.

Timeouts can also be caused by transmission errors. Refer to
{\hyperref[driver\string-api/libata:excatATAbusErr]{\emph{ATA bus error}}} for more details.


\subsubsection{Hotplug and power management exceptions}
\label{driver-api/libata:hotplug-and-power-management-exceptions}
\textless{}\textless{}TODO: fill here\textgreater{}\textgreater{}


\subsection{EH recovery actions}
\label{driver-api/libata:eh-recovery-actions}
This section discusses several important recovery actions.


\subsubsection{Clearing error condition}
\label{driver-api/libata:clearing-error-condition}
Many controllers require its error registers to be cleared by error
handler. Different controllers may have different requirements.

For SATA, it's strongly recommended to clear at least SError register
during error handling.


\subsubsection{Reset}
\label{driver-api/libata:reset}
During EH, resetting is necessary in the following cases.
\begin{itemize}
\item {} 
HSM is in unknown or invalid state

\item {} 
HBA is in unknown or invalid state

\item {} 
EH needs to make HBA/device forget about in-flight commands

\item {} 
HBA/device behaves weirdly

\end{itemize}

Resetting during EH might be a good idea regardless of error condition
to improve EH robustness. Whether to reset both or either one of HBA and
device depends on situation but the following scheme is recommended.
\begin{itemize}
\item {} 
When it's known that HBA is in ready state but ATA/ATAPI device is in
unknown state, reset only device.

\item {} 
If HBA is in unknown state, reset both HBA and device.

\end{itemize}

HBA resetting is implementation specific. For a controller complying to
taskfile/BMDMA PCI IDE, stopping active DMA transaction may be
sufficient iff BMDMA state is the only HBA context. But even mostly
taskfile/BMDMA PCI IDE complying controllers may have implementation
specific requirements and mechanism to reset themselves. This must be
addressed by specific drivers.

OTOH, ATA/ATAPI standard describes in detail ways to reset ATA/ATAPI
devices.
\begin{description}
\item[{PATA hardware reset}] \leavevmode
This is hardware initiated device reset signalled with asserted PATA
RESET- signal. There is no standard way to initiate hardware reset
from software although some hardware provides registers that allow
driver to directly tweak the RESET- signal.

\item[{Software reset}] \leavevmode
This is achieved by turning CONTROL SRST bit on for at least 5us.
Both PATA and SATA support it but, in case of SATA, this may require
controller-specific support as the second Register FIS to clear SRST
should be transmitted while BSY bit is still set. Note that on PATA,
this resets both master and slave devices on a channel.

\item[{EXECUTE DEVICE DIAGNOSTIC command}] \leavevmode
Although ATA/ATAPI standard doesn't describe exactly, EDD implies
some level of resetting, possibly similar level with software reset.
Host-side EDD protocol can be handled with normal command processing
and most SATA controllers should be able to handle EDD's just like
other commands. As in software reset, EDD affects both devices on a
PATA bus.

Although EDD does reset devices, this doesn't suit error handling as
EDD cannot be issued while BSY is set and it's unclear how it will
act when device is in unknown/weird state.

\item[{ATAPI DEVICE RESET command}] \leavevmode
This is very similar to software reset except that reset can be
restricted to the selected device without affecting the other device
sharing the cable.

\item[{SATA phy reset}] \leavevmode
This is the preferred way of resetting a SATA device. In effect,
it's identical to PATA hardware reset. Note that this can be done
with the standard SCR Control register. As such, it's usually easier
to implement than software reset.

\end{description}

One more thing to consider when resetting devices is that resetting
clears certain configuration parameters and they need to be set to their
previous or newly adjusted values after reset.

Parameters affected are.
\begin{itemize}
\item {} 
CHS set up with INITIALIZE DEVICE PARAMETERS (seldom used)

\item {} 
Parameters set with SET FEATURES including transfer mode setting

\item {} 
Block count set with SET MULTIPLE MODE

\item {} 
Other parameters (SET MAX, MEDIA LOCK...)

\end{itemize}

ATA/ATAPI standard specifies that some parameters must be maintained
across hardware or software reset, but doesn't strictly specify all of
them. Always reconfiguring needed parameters after reset is required for
robustness. Note that this also applies when resuming from deep sleep
(power-off).

Also, ATA/ATAPI standard requires that IDENTIFY DEVICE / IDENTIFY PACKET
DEVICE is issued after any configuration parameter is updated or a
hardware reset and the result used for further operation. OS driver is
required to implement revalidation mechanism to support this.


\subsubsection{Reconfigure transport}
\label{driver-api/libata:reconfigure-transport}
For both PATA and SATA, a lot of corners are cut for cheap connectors,
cables or controllers and it's quite common to see high transmission
error rate. This can be mitigated by lowering transmission speed.

The following is a possible scheme Jeff Garzik suggested.
\begin{quote}

If more than \$N (3?) transmission errors happen in 15 minutes,
\begin{itemize}
\item {} 
if SATA, decrease SATA PHY speed. if speed cannot be decreased,

\item {} 
decrease UDMA xfer speed. if at UDMA0, switch to PIO4,

\item {} 
decrease PIO xfer speed. if at PIO3, complain, but continue

\end{itemize}
\end{quote}


\section{ata\_piix Internals}
\label{driver-api/libata:ata-piix-internals}\index{ich\_pata\_cable\_detect (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ich_pata_cable_detect}\pysiglinewithargsret{int \bfcode{ich\_pata\_cable\_detect}}{struct ata\_port *\emph{ ap}}{}
Probe host controller cable detect info

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
Port for which cable detect info is desired

\end{description}

\textbf{Description}
\begin{quote}

Read 80c cable indicator from ATA PCI device's PCI config
register.  This register is normally set by firmware (BIOS).

LOCKING:
None (inherited from caller).
\end{quote}
\index{piix\_pata\_prereset (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.piix_pata_prereset}\pysiglinewithargsret{int \bfcode{piix\_pata\_prereset}}{struct ata\_link *\emph{ link}, unsigned long\emph{ deadline}}{}
prereset for PATA host controller

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
Target link

\item[{\code{unsigned long deadline}}] \leavevmode
deadline jiffies for the operation

\end{description}

\textbf{Description}
\begin{quote}

LOCKING:
None (inherited from caller).
\end{quote}
\index{piix\_set\_piomode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.piix_set_piomode}\pysiglinewithargsret{void \bfcode{piix\_set\_piomode}}{struct ata\_port *\emph{ ap}, struct ata\_device *\emph{ adev}}{}
Initialize host controller PATA PIO timings

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
Port whose timings we are configuring

\item[{\code{struct ata\_device * adev}}] \leavevmode
Drive in question

\end{description}

\textbf{Description}
\begin{quote}

Set PIO mode for device, in host controller PCI config space.

LOCKING:
None (inherited from caller).
\end{quote}
\index{do\_pata\_set\_dmamode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.do_pata_set_dmamode}\pysiglinewithargsret{void \bfcode{do\_pata\_set\_dmamode}}{struct ata\_port *\emph{ ap}, struct ata\_device *\emph{ adev}, int\emph{ isich}}{}
Initialize host controller PATA PIO timings

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
Port whose timings we are configuring

\item[{\code{struct ata\_device * adev}}] \leavevmode
Drive in question

\item[{\code{int isich}}] \leavevmode
set if the chip is an ICH device

\end{description}

\textbf{Description}
\begin{quote}

Set UDMA mode for device, in host controller PCI config space.

LOCKING:
None (inherited from caller).
\end{quote}
\index{piix\_set\_dmamode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.piix_set_dmamode}\pysiglinewithargsret{void \bfcode{piix\_set\_dmamode}}{struct ata\_port *\emph{ ap}, struct ata\_device *\emph{ adev}}{}
Initialize host controller PATA DMA timings

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
Port whose timings we are configuring

\item[{\code{struct ata\_device * adev}}] \leavevmode
um

\end{description}

\textbf{Description}
\begin{quote}

Set MW/UDMA mode for device, in host controller PCI config space.

LOCKING:
None (inherited from caller).
\end{quote}
\index{ich\_set\_dmamode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.ich_set_dmamode}\pysiglinewithargsret{void \bfcode{ich\_set\_dmamode}}{struct ata\_port *\emph{ ap}, struct ata\_device *\emph{ adev}}{}
Initialize host controller PATA DMA timings

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_port * ap}}] \leavevmode
Port whose timings we are configuring

\item[{\code{struct ata\_device * adev}}] \leavevmode
um

\end{description}

\textbf{Description}
\begin{quote}

Set MW/UDMA mode for device, in host controller PCI config space.

LOCKING:
None (inherited from caller).
\end{quote}
\index{piix\_check\_450nx\_errata (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.piix_check_450nx_errata}\pysiglinewithargsret{int \bfcode{piix\_check\_450nx\_errata}}{struct pci\_dev *\emph{ ata\_dev}}{}
Check for problem 450NX setup

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * ata\_dev}}] \leavevmode
the PCI device to check

\end{description}

\textbf{Description}
\begin{quote}

Check for the present of 450NX errata \#19 and errata \#25. If
they are found return an error code so we can turn off DMA
\end{quote}
\index{piix\_init\_one (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.piix_init_one}\pysiglinewithargsret{int \bfcode{piix\_init\_one}}{struct pci\_dev *\emph{ pdev}, const struct pci\_device\_id *\emph{ ent}}{}
Register PIIX ATA PCI device with kernel services

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pci\_dev * pdev}}] \leavevmode
PCI device to register

\item[{\code{const struct pci\_device\_id * ent}}] \leavevmode
Entry in piix\_pci\_tbl matching with \textbf{pdev}

\end{description}

\textbf{Description}
\begin{quote}

Called from kernel PCI layer.  We probe for combined mode (sigh),
and then hand over control to libata, for it to do the rest.

LOCKING:
Inherited from PCI layer (may sleep).
\end{quote}

\textbf{Return}
\begin{quote}

Zero on success, or -ERRNO value.
\end{quote}


\section{sata\_sil Internals}
\label{driver-api/libata:sata-sil-internals}\index{sil\_set\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sil_set_mode}\pysiglinewithargsret{int \bfcode{sil\_set\_mode}}{struct ata\_link *\emph{ link}, struct ata\_device **\emph{ r\_failed}}{}
wrap set\_mode functions

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_link * link}}] \leavevmode
link to set up

\item[{\code{struct ata\_device ** r\_failed}}] \leavevmode
returned device when we fail

\end{description}

\textbf{Description}
\begin{quote}

Wrap the libata method for device setup as after the setup we need
to inspect the results and do some configuration work
\end{quote}
\index{sil\_dev\_config (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/libata:c.sil_dev_config}\pysiglinewithargsret{void \bfcode{sil\_dev\_config}}{struct ata\_device *\emph{ dev}}{}
Apply device/host-specific errata fixups

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ata\_device * dev}}] \leavevmode
Device to be examined

\end{description}

\textbf{Description}
\begin{quote}

After the IDENTIFY {[}PACKET{]} DEVICE step is complete, and a
device is known to be present, this function is called.
We apply two errata fixups which are specific to Silicon Image,
a Seagate and a Maxtor fixup.

For certain Seagate devices, we must limit the maximum sectors
to under 8K.

For certain Maxtor devices, we must not program the drive
beyond udma5.

Both fixups are unfairly pessimistic.  As soon as I get more
information on these errata, I will create a more exhaustive
list, and apply the fixups to only the specific
devices/hosts/firmwares that need it.

20040111 - Seagate drives affected by the Mod15Write bug are blacklisted
The Maxtor quirk is in the blacklist, but I'm keeping the original
pessimistic fix for the following reasons...
- There seems to be less info on it, only one device gleaned off the
Windows driver, maybe only one is affected.  More info would be greatly
appreciated.
- But then again UDMA5 is hardly anything to complain about
\end{quote}


\section{Thanks}
\label{driver-api/libata:thanks}
The bulk of the ATA knowledge comes thanks to long conversations with
Andre Hedrick (www.linux-ide.org), and long hours pondering the ATA and
SCSI specifications.

Thanks to Alan Cox for pointing out similarities between SATA and SCSI,
and in general for motivation to hack on libata.

libata's device detection method, ata\_pio\_devchk, and in general all
the early probing was based on extensive study of Hale Landis's
probe/reset code in his ATADRVR driver (www.ata-atapi.com).


\chapter{MTD NAND Driver Programming Interface}
\label{driver-api/mtdnand:mtd-nand-driver-programming-interface}\label{driver-api/mtdnand::doc}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Thomas Gleixner

\end{description}\end{quote}


\section{Introduction}
\label{driver-api/mtdnand:introduction}
The generic NAND driver supports almost all NAND and AG-AND based chips
and connects them to the Memory Technology Devices (MTD) subsystem of
the Linux Kernel.

This documentation is provided for developers who want to implement
board drivers or filesystem drivers suitable for NAND devices.


\section{Known Bugs And Assumptions}
\label{driver-api/mtdnand:known-bugs-and-assumptions}
None.


\section{Documentation hints}
\label{driver-api/mtdnand:documentation-hints}
The function and structure docs are autogenerated. Each function and
struct member has a short description which is marked with an {[}XXX{]}
identifier. The following chapters explain the meaning of those
identifiers.


\subsection{Function identifiers {[}XXX{]}}
\label{driver-api/mtdnand:function-identifiers-xxx}
The functions are marked with {[}XXX{]} identifiers in the short comment.
The identifiers explain the usage and scope of the functions. Following
identifiers are used:
\begin{itemize}
\item {} 
{[}MTD Interface{]}

These functions provide the interface to the MTD kernel API. They are
not replaceable and provide functionality which is complete hardware
independent.

\item {} 
{[}NAND Interface{]}

These functions are exported and provide the interface to the NAND
kernel API.

\item {} 
{[}GENERIC{]}

Generic functions are not replaceable and provide functionality which
is complete hardware independent.

\item {} 
{[}DEFAULT{]}

Default functions provide hardware related functionality which is
suitable for most of the implementations. These functions can be
replaced by the board driver if necessary. Those functions are called
via pointers in the NAND chip description structure. The board driver
can set the functions which should be replaced by board dependent
functions before calling nand\_scan(). If the function pointer is
NULL on entry to nand\_scan() then the pointer is set to the default
function which is suitable for the detected chip type.

\end{itemize}


\subsection{Struct member identifiers {[}XXX{]}}
\label{driver-api/mtdnand:struct-member-identifiers-xxx}
The struct members are marked with {[}XXX{]} identifiers in the comment. The
identifiers explain the usage and scope of the members. Following
identifiers are used:
\begin{itemize}
\item {} 
{[}INTERN{]}

These members are for NAND driver internal use only and must not be
modified. Most of these values are calculated from the chip geometry
information which is evaluated during nand\_scan().

\item {} 
{[}REPLACEABLE{]}

Replaceable members hold hardware related functions which can be
provided by the board driver. The board driver can set the functions
which should be replaced by board dependent functions before calling
nand\_scan(). If the function pointer is NULL on entry to
nand\_scan() then the pointer is set to the default function which is
suitable for the detected chip type.

\item {} 
{[}BOARDSPECIFIC{]}

Board specific members hold hardware related information which must
be provided by the board driver. The board driver must set the
function pointers and datafields before calling nand\_scan().

\item {} 
{[}OPTIONAL{]}

Optional members can hold information relevant for the board driver.
The generic NAND driver code does not use this information.

\end{itemize}


\section{Basic board driver}
\label{driver-api/mtdnand:basic-board-driver}
For most boards it will be sufficient to provide just the basic
functions and fill out some really board dependent members in the nand
chip description structure.


\subsection{Basic defines}
\label{driver-api/mtdnand:basic-defines}
At least you have to provide a nand\_chip structure and a storage for
the ioremap'ed chip address. You can allocate the nand\_chip structure
using kmalloc or you can allocate it statically. The NAND chip structure
embeds an mtd structure which will be registered to the MTD subsystem.
You can extract a pointer to the mtd structure from a nand\_chip pointer
using the nand\_to\_mtd() helper.

Kmalloc based example

\begin{Verbatim}[commandchars=\\\{\}]
static struct mtd\PYGZus{}info *board\PYGZus{}mtd;
static void \PYGZus{}\PYGZus{}iomem *baseaddr;
\end{Verbatim}

Static example

\begin{Verbatim}[commandchars=\\\{\}]
static struct nand\PYGZus{}chip board\PYGZus{}chip;
static void \PYGZus{}\PYGZus{}iomem *baseaddr;
\end{Verbatim}


\subsection{Partition defines}
\label{driver-api/mtdnand:partition-defines}
If you want to divide your device into partitions, then define a
partitioning scheme suitable to your board.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}define NUM\PYGZus{}PARTITIONS 2
static struct mtd\PYGZus{}partition partition\PYGZus{}info[] = \PYGZob{}
    \PYGZob{} .name = \PYGZdq{}Flash partition 1\PYGZdq{},
      .offset =  0,
      .size =    8 * 1024 * 1024 \PYGZcb{},
    \PYGZob{} .name = \PYGZdq{}Flash partition 2\PYGZdq{},
      .offset =  MTDPART\PYGZus{}OFS\PYGZus{}NEXT,
      .size =    MTDPART\PYGZus{}SIZ\PYGZus{}FULL \PYGZcb{},
\PYGZcb{};
\end{Verbatim}


\subsection{Hardware control function}
\label{driver-api/mtdnand:hardware-control-function}
The hardware control function provides access to the control pins of the
NAND chip(s). The access can be done by GPIO pins or by address lines.
If you use address lines, make sure that the timing requirements are
met.

\emph{GPIO based example}

\begin{Verbatim}[commandchars=\\\{\}]
static void board\PYGZus{}hwcontrol(struct mtd\PYGZus{}info *mtd, int cmd)
\PYGZob{}
    switch(cmd)\PYGZob{}
        case NAND\PYGZus{}CTL\PYGZus{}SETCLE: /* Set CLE pin high */ break;
        case NAND\PYGZus{}CTL\PYGZus{}CLRCLE: /* Set CLE pin low */ break;
        case NAND\PYGZus{}CTL\PYGZus{}SETALE: /* Set ALE pin high */ break;
        case NAND\PYGZus{}CTL\PYGZus{}CLRALE: /* Set ALE pin low */ break;
        case NAND\PYGZus{}CTL\PYGZus{}SETNCE: /* Set nCE pin low */ break;
        case NAND\PYGZus{}CTL\PYGZus{}CLRNCE: /* Set nCE pin high */ break;
    \PYGZcb{}
\PYGZcb{}
\end{Verbatim}

\emph{Address lines based example.} It's assumed that the nCE pin is driven
by a chip select decoder.

\begin{Verbatim}[commandchars=\\\{\}]
static void board\PYGZus{}hwcontrol(struct mtd\PYGZus{}info *mtd, int cmd)
\PYGZob{}
    struct nand\PYGZus{}chip *this = mtd\PYGZus{}to\PYGZus{}nand(mtd);
    switch(cmd)\PYGZob{}
        case NAND\PYGZus{}CTL\PYGZus{}SETCLE: this\PYGZhy{}\PYGZgt{}IO\PYGZus{}ADDR\PYGZus{}W \textbar{}= CLE\PYGZus{}ADRR\PYGZus{}BIT;  break;
        case NAND\PYGZus{}CTL\PYGZus{}CLRCLE: this\PYGZhy{}\PYGZgt{}IO\PYGZus{}ADDR\PYGZus{}W \PYGZam{}= \PYGZti{}CLE\PYGZus{}ADRR\PYGZus{}BIT; break;
        case NAND\PYGZus{}CTL\PYGZus{}SETALE: this\PYGZhy{}\PYGZgt{}IO\PYGZus{}ADDR\PYGZus{}W \textbar{}= ALE\PYGZus{}ADRR\PYGZus{}BIT;  break;
        case NAND\PYGZus{}CTL\PYGZus{}CLRALE: this\PYGZhy{}\PYGZgt{}IO\PYGZus{}ADDR\PYGZus{}W \PYGZam{}= \PYGZti{}ALE\PYGZus{}ADRR\PYGZus{}BIT; break;
    \PYGZcb{}
\PYGZcb{}
\end{Verbatim}


\subsection{Device ready function}
\label{driver-api/mtdnand:device-ready-function}
If the hardware interface has the ready busy pin of the NAND chip
connected to a GPIO or other accessible I/O pin, this function is used
to read back the state of the pin. The function has no arguments and
should return 0, if the device is busy (R/B pin is low) and 1, if the
device is ready (R/B pin is high). If the hardware interface does not
give access to the ready busy pin, then the function must not be defined
and the function pointer this-\textgreater{}dev\_ready is set to NULL.


\subsection{Init function}
\label{driver-api/mtdnand:init-function}
The init function allocates memory and sets up all the board specific
parameters and function pointers. When everything is set up nand\_scan()
is called. This function tries to detect and identify then chip. If a
chip is found all the internal data fields are initialized accordingly.
The structure(s) have to be zeroed out first and then filled with the
necessary information about the device.

\begin{Verbatim}[commandchars=\\\{\}]
static int \PYGZus{}\PYGZus{}init board\PYGZus{}init (void)
\PYGZob{}
    struct nand\PYGZus{}chip *this;
    int err = 0;

    /* Allocate memory for MTD device structure and private data */
    this = kzalloc(sizeof(struct nand\PYGZus{}chip), GFP\PYGZus{}KERNEL);
    if (!this) \PYGZob{}
        printk (\PYGZdq{}Unable to allocate NAND MTD device structure.\PYGZbs{}n\PYGZdq{});
        err = \PYGZhy{}ENOMEM;
        goto out;
    \PYGZcb{}

    board\PYGZus{}mtd = nand\PYGZus{}to\PYGZus{}mtd(this);

    /* map physical address */
    baseaddr = ioremap(CHIP\PYGZus{}PHYSICAL\PYGZus{}ADDRESS, 1024);
    if (!baseaddr) \PYGZob{}
        printk(\PYGZdq{}Ioremap to access NAND chip failed\PYGZbs{}n\PYGZdq{});
        err = \PYGZhy{}EIO;
        goto out\PYGZus{}mtd;
    \PYGZcb{}

    /* Set address of NAND IO lines */
    this\PYGZhy{}\PYGZgt{}IO\PYGZus{}ADDR\PYGZus{}R = baseaddr;
    this\PYGZhy{}\PYGZgt{}IO\PYGZus{}ADDR\PYGZus{}W = baseaddr;
    /* Reference hardware control function */
    this\PYGZhy{}\PYGZgt{}hwcontrol = board\PYGZus{}hwcontrol;
    /* Set command delay time, see datasheet for correct value */
    this\PYGZhy{}\PYGZgt{}chip\PYGZus{}delay = CHIP\PYGZus{}DEPENDEND\PYGZus{}COMMAND\PYGZus{}DELAY;
    /* Assign the device ready function, if available */
    this\PYGZhy{}\PYGZgt{}dev\PYGZus{}ready = board\PYGZus{}dev\PYGZus{}ready;
    this\PYGZhy{}\PYGZgt{}eccmode = NAND\PYGZus{}ECC\PYGZus{}SOFT;

    /* Scan to find existence of the device */
    if (nand\PYGZus{}scan (board\PYGZus{}mtd, 1)) \PYGZob{}
        err = \PYGZhy{}ENXIO;
        goto out\PYGZus{}ior;
    \PYGZcb{}

    add\PYGZus{}mtd\PYGZus{}partitions(board\PYGZus{}mtd, partition\PYGZus{}info, NUM\PYGZus{}PARTITIONS);
    goto out;

out\PYGZus{}ior:
    iounmap(baseaddr);
out\PYGZus{}mtd:
    kfree (this);
out:
    return err;
\PYGZcb{}
module\PYGZus{}init(board\PYGZus{}init);
\end{Verbatim}


\subsection{Exit function}
\label{driver-api/mtdnand:exit-function}
The exit function is only necessary if the driver is compiled as a
module. It releases all resources which are held by the chip driver and
unregisters the partitions in the MTD layer.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}ifdef MODULE
static void \PYGZus{}\PYGZus{}exit board\PYGZus{}cleanup (void)
\PYGZob{}
    /* Release resources, unregister device */
    nand\PYGZus{}release (board\PYGZus{}mtd);

    /* unmap physical address */
    iounmap(baseaddr);

    /* Free the MTD device structure */
    kfree (mtd\PYGZus{}to\PYGZus{}nand(board\PYGZus{}mtd));
\PYGZcb{}
module\PYGZus{}exit(board\PYGZus{}cleanup);
\PYGZsh{}endif
\end{Verbatim}


\section{Advanced board driver functions}
\label{driver-api/mtdnand:advanced-board-driver-functions}
This chapter describes the advanced functionality of the NAND driver.
For a list of functions which can be overridden by the board driver see
the documentation of the nand\_chip structure.


\subsection{Multiple chip control}
\label{driver-api/mtdnand:multiple-chip-control}
The nand driver can control chip arrays. Therefore the board driver must
provide an own select\_chip function. This function must (de)select the
requested chip. The function pointer in the nand\_chip structure must be
set before calling nand\_scan(). The maxchip parameter of nand\_scan()
defines the maximum number of chips to scan for. Make sure that the
select\_chip function can handle the requested number of chips.

The nand driver concatenates the chips to one virtual chip and provides
this virtual chip to the MTD layer.

\emph{Note: The driver can only handle linear chip arrays of equally sized
chips. There is no support for parallel arrays which extend the
buswidth.}

\emph{GPIO based example}

\begin{Verbatim}[commandchars=\\\{\}]
static void board\PYGZus{}select\PYGZus{}chip (struct mtd\PYGZus{}info *mtd, int chip)
\PYGZob{}
    /* Deselect all chips, set all nCE pins high */
    GPIO(BOARD\PYGZus{}NAND\PYGZus{}NCE) \textbar{}= 0xff;
    if (chip \PYGZgt{}= 0)
        GPIO(BOARD\PYGZus{}NAND\PYGZus{}NCE) \PYGZam{}= \PYGZti{} (1 \PYGZlt{}\PYGZlt{} chip);
\PYGZcb{}
\end{Verbatim}

\emph{Address lines based example.} Its assumed that the nCE pins are
connected to an address decoder.

\begin{Verbatim}[commandchars=\\\{\}]
static void board\PYGZus{}select\PYGZus{}chip (struct mtd\PYGZus{}info *mtd, int chip)
\PYGZob{}
    struct nand\PYGZus{}chip *this = mtd\PYGZus{}to\PYGZus{}nand(mtd);

    /* Deselect all chips */
    this\PYGZhy{}\PYGZgt{}IO\PYGZus{}ADDR\PYGZus{}R \PYGZam{}= \PYGZti{}BOARD\PYGZus{}NAND\PYGZus{}ADDR\PYGZus{}MASK;
    this\PYGZhy{}\PYGZgt{}IO\PYGZus{}ADDR\PYGZus{}W \PYGZam{}= \PYGZti{}BOARD\PYGZus{}NAND\PYGZus{}ADDR\PYGZus{}MASK;
    switch (chip) \PYGZob{}
    case 0:
        this\PYGZhy{}\PYGZgt{}IO\PYGZus{}ADDR\PYGZus{}R \textbar{}= BOARD\PYGZus{}NAND\PYGZus{}ADDR\PYGZus{}CHIP0;
        this\PYGZhy{}\PYGZgt{}IO\PYGZus{}ADDR\PYGZus{}W \textbar{}= BOARD\PYGZus{}NAND\PYGZus{}ADDR\PYGZus{}CHIP0;
        break;
    ....
    case n:
        this\PYGZhy{}\PYGZgt{}IO\PYGZus{}ADDR\PYGZus{}R \textbar{}= BOARD\PYGZus{}NAND\PYGZus{}ADDR\PYGZus{}CHIPn;
        this\PYGZhy{}\PYGZgt{}IO\PYGZus{}ADDR\PYGZus{}W \textbar{}= BOARD\PYGZus{}NAND\PYGZus{}ADDR\PYGZus{}CHIPn;
        break;
    \PYGZcb{}
\PYGZcb{}
\end{Verbatim}


\subsection{Hardware ECC support}
\label{driver-api/mtdnand:hardware-ecc-support}

\subsubsection{Functions and constants}
\label{driver-api/mtdnand:functions-and-constants}
The nand driver supports three different types of hardware ECC.
\begin{itemize}
\item {} 
NAND\_ECC\_HW3\_256

Hardware ECC generator providing 3 bytes ECC per 256 byte.

\item {} 
NAND\_ECC\_HW3\_512

Hardware ECC generator providing 3 bytes ECC per 512 byte.

\item {} 
NAND\_ECC\_HW6\_512

Hardware ECC generator providing 6 bytes ECC per 512 byte.

\item {} 
NAND\_ECC\_HW8\_512

Hardware ECC generator providing 6 bytes ECC per 512 byte.

\end{itemize}

If your hardware generator has a different functionality add it at the
appropriate place in nand\_base.c

The board driver must provide following functions:
\begin{itemize}
\item {} 
enable\_hwecc

This function is called before reading / writing to the chip. Reset
or initialize the hardware generator in this function. The function
is called with an argument which let you distinguish between read and
write operations.

\item {} 
calculate\_ecc

This function is called after read / write from / to the chip.
Transfer the ECC from the hardware to the buffer. If the option
NAND\_HWECC\_SYNDROME is set then the function is only called on
write. See below.

\item {} 
correct\_data

In case of an ECC error this function is called for error detection
and correction. Return 1 respectively 2 in case the error can be
corrected. If the error is not correctable return -1. If your
hardware generator matches the default algorithm of the nand\_ecc
software generator then use the correction function provided by
nand\_ecc instead of implementing duplicated code.

\end{itemize}


\subsubsection{Hardware ECC with syndrome calculation}
\label{driver-api/mtdnand:hardware-ecc-with-syndrome-calculation}
Many hardware ECC implementations provide Reed-Solomon codes and
calculate an error syndrome on read. The syndrome must be converted to a
standard Reed-Solomon syndrome before calling the error correction code
in the generic Reed-Solomon library.

The ECC bytes must be placed immediately after the data bytes in order
to make the syndrome generator work. This is contrary to the usual
layout used by software ECC. The separation of data and out of band area
is not longer possible. The nand driver code handles this layout and the
remaining free bytes in the oob area are managed by the autoplacement
code. Provide a matching oob-layout in this case. See rts\_from4.c and
diskonchip.c for implementation reference. In those cases we must also
use bad block tables on FLASH, because the ECC layout is interfering
with the bad block marker positions. See bad block table support for
details.


\subsection{Bad block table support}
\label{driver-api/mtdnand:bad-block-table-support}
Most NAND chips mark the bad blocks at a defined position in the spare
area. Those blocks must not be erased under any circumstances as the bad
block information would be lost. It is possible to check the bad block
mark each time when the blocks are accessed by reading the spare area of
the first page in the block. This is time consuming so a bad block table
is used.

The nand driver supports various types of bad block tables.
\begin{itemize}
\item {} 
Per device

The bad block table contains all bad block information of the device
which can consist of multiple chips.

\item {} 
Per chip

A bad block table is used per chip and contains the bad block
information for this particular chip.

\item {} 
Fixed offset

The bad block table is located at a fixed offset in the chip
(device). This applies to various DiskOnChip devices.

\item {} 
Automatic placed

The bad block table is automatically placed and detected either at
the end or at the beginning of a chip (device)

\item {} 
Mirrored tables

The bad block table is mirrored on the chip (device) to allow updates
of the bad block table without data loss.

\end{itemize}

nand\_scan() calls the function nand\_default\_bbt().
nand\_default\_bbt() selects appropriate default bad block table
descriptors depending on the chip information which was retrieved by
nand\_scan().

The standard policy is scanning the device for bad blocks and build a
ram based bad block table which allows faster access than always
checking the bad block information on the flash chip itself.


\subsubsection{Flash based tables}
\label{driver-api/mtdnand:flash-based-tables}
It may be desired or necessary to keep a bad block table in FLASH. For
AG-AND chips this is mandatory, as they have no factory marked bad
blocks. They have factory marked good blocks. The marker pattern is
erased when the block is erased to be reused. So in case of powerloss
before writing the pattern back to the chip this block would be lost and
added to the bad blocks. Therefore we scan the chip(s) when we detect
them the first time for good blocks and store this information in a bad
block table before erasing any of the blocks.

The blocks in which the tables are stored are protected against
accidental access by marking them bad in the memory bad block table. The
bad block table management functions are allowed to circumvent this
protection.

The simplest way to activate the FLASH based bad block table support is
to set the option NAND\_BBT\_USE\_FLASH in the bbt\_option field of the
nand chip structure before calling nand\_scan(). For AG-AND chips is
this done by default. This activates the default FLASH based bad block
table functionality of the NAND driver. The default bad block table
options are
\begin{itemize}
\item {} 
Store bad block table per chip

\item {} 
Use 2 bits per block

\item {} 
Automatic placement at the end of the chip

\item {} 
Use mirrored tables with version numbers

\item {} 
Reserve 4 blocks at the end of the chip

\end{itemize}


\subsubsection{User defined tables}
\label{driver-api/mtdnand:user-defined-tables}
User defined tables are created by filling out a nand\_bbt\_descr
structure and storing the pointer in the nand\_chip structure member
bbt\_td before calling nand\_scan(). If a mirror table is necessary a
second structure must be created and a pointer to this structure must be
stored in bbt\_md inside the nand\_chip structure. If the bbt\_md member
is set to NULL then only the main table is used and no scan for the
mirrored table is performed.

The most important field in the nand\_bbt\_descr structure is the
options field. The options define most of the table properties. Use the
predefined constants from rawnand.h to define the options.
\begin{itemize}
\item {} 
Number of bits per block

The supported number of bits is 1, 2, 4, 8.

\item {} 
Table per chip

Setting the constant NAND\_BBT\_PERCHIP selects that a bad block
table is managed for each chip in a chip array. If this option is not
set then a per device bad block table is used.

\item {} 
Table location is absolute

Use the option constant NAND\_BBT\_ABSPAGE and define the absolute
page number where the bad block table starts in the field pages. If
you have selected bad block tables per chip and you have a multi chip
array then the start page must be given for each chip in the chip
array. Note: there is no scan for a table ident pattern performed, so
the fields pattern, veroffs, offs, len can be left uninitialized

\item {} 
Table location is automatically detected

The table can either be located in the first or the last good blocks
of the chip (device). Set NAND\_BBT\_LASTBLOCK to place the bad block
table at the end of the chip (device). The bad block tables are
marked and identified by a pattern which is stored in the spare area
of the first page in the block which holds the bad block table. Store
a pointer to the pattern in the pattern field. Further the length of
the pattern has to be stored in len and the offset in the spare area
must be given in the offs member of the nand\_bbt\_descr structure.
For mirrored bad block tables different patterns are mandatory.

\item {} 
Table creation

Set the option NAND\_BBT\_CREATE to enable the table creation if no
table can be found during the scan. Usually this is done only once if
a new chip is found.

\item {} 
Table write support

Set the option NAND\_BBT\_WRITE to enable the table write support.
This allows the update of the bad block table(s) in case a block has
to be marked bad due to wear. The MTD interface function
block\_markbad is calling the update function of the bad block table.
If the write support is enabled then the table is updated on FLASH.

Note: Write support should only be enabled for mirrored tables with
version control.

\item {} 
Table version control

Set the option NAND\_BBT\_VERSION to enable the table version
control. It's highly recommended to enable this for mirrored tables
with write support. It makes sure that the risk of losing the bad
block table information is reduced to the loss of the information
about the one worn out block which should be marked bad. The version
is stored in 4 consecutive bytes in the spare area of the device. The
position of the version number is defined by the member veroffs in
the bad block table descriptor.

\item {} 
Save block contents on write

In case that the block which holds the bad block table does contain
other useful information, set the option NAND\_BBT\_SAVECONTENT. When
the bad block table is written then the whole block is read the bad
block table is updated and the block is erased and everything is
written back. If this option is not set only the bad block table is
written and everything else in the block is ignored and erased.

\item {} 
Number of reserved blocks

For automatic placement some blocks must be reserved for bad block
table storage. The number of reserved blocks is defined in the
maxblocks member of the bad block table description structure.
Reserving 4 blocks for mirrored tables should be a reasonable number.
This also limits the number of blocks which are scanned for the bad
block table ident pattern.

\end{itemize}


\subsection{Spare area (auto)placement}
\label{driver-api/mtdnand:spare-area-auto-placement}
The nand driver implements different possibilities for placement of
filesystem data in the spare area,
\begin{itemize}
\item {} 
Placement defined by fs driver

\item {} 
Automatic placement

\end{itemize}

The default placement function is automatic placement. The nand driver
has built in default placement schemes for the various chiptypes. If due
to hardware ECC functionality the default placement does not fit then
the board driver can provide a own placement scheme.

File system drivers can provide a own placement scheme which is used
instead of the default placement scheme.

Placement schemes are defined by a nand\_oobinfo structure

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}oobinfo \PYGZob{}
    int useecc;
    int eccbytes;
    int eccpos[24];
    int oobfree[8][2];
\PYGZcb{};
\end{Verbatim}
\begin{itemize}
\item {} 
useecc

The useecc member controls the ecc and placement function. The header
file include/mtd/mtd-abi.h contains constants to select ecc and
placement. MTD\_NANDECC\_OFF switches off the ecc complete. This is
not recommended and available for testing and diagnosis only.
MTD\_NANDECC\_PLACE selects caller defined placement,
MTD\_NANDECC\_AUTOPLACE selects automatic placement.

\item {} 
eccbytes

The eccbytes member defines the number of ecc bytes per page.

\item {} 
eccpos

The eccpos array holds the byte offsets in the spare area where the
ecc codes are placed.

\item {} 
oobfree

The oobfree array defines the areas in the spare area which can be
used for automatic placement. The information is given in the format
\{offset, size\}. offset defines the start of the usable area, size the
length in bytes. More than one area can be defined. The list is
terminated by an \{0, 0\} entry.

\end{itemize}


\subsubsection{Placement defined by fs driver}
\label{driver-api/mtdnand:placement-defined-by-fs-driver}
The calling function provides a pointer to a nand\_oobinfo structure
which defines the ecc placement. For writes the caller must provide a
spare area buffer along with the data buffer. The spare area buffer size
is (number of pages) * (size of spare area). For reads the buffer size
is (number of pages) * ((size of spare area) + (number of ecc steps per
page) * sizeof (int)). The driver stores the result of the ecc check
for each tuple in the spare buffer. The storage sequence is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}spare data page 0\PYGZgt{}\PYGZlt{}ecc result 0\PYGZgt{}...\PYGZlt{}ecc result n\PYGZgt{}

...

\PYGZlt{}spare data page n\PYGZgt{}\PYGZlt{}ecc result 0\PYGZgt{}...\PYGZlt{}ecc result n\PYGZgt{}
\end{Verbatim}

This is a legacy mode used by YAFFS1.

If the spare area buffer is NULL then only the ECC placement is done
according to the given scheme in the nand\_oobinfo structure.


\subsubsection{Automatic placement}
\label{driver-api/mtdnand:automatic-placement}
Automatic placement uses the built in defaults to place the ecc bytes in
the spare area. If filesystem data have to be stored / read into the
spare area then the calling function must provide a buffer. The buffer
size per page is determined by the oobfree array in the nand\_oobinfo
structure.

If the spare area buffer is NULL then only the ECC placement is done
according to the default builtin scheme.


\subsection{Spare area autoplacement default schemes}
\label{driver-api/mtdnand:spare-area-autoplacement-default-schemes}

\subsubsection{256 byte pagesize}
\label{driver-api/mtdnand:byte-pagesize}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Offset
} & \textsf{\relax 
Content
} & \textsf{\relax 
Comment
}\\
\hline
0x00
 & 
ECC byte 0
 & 
Error correction code byte 0
\\
\hline
0x01
 & 
ECC byte 1
 & 
Error correction code byte 1
\\
\hline
0x02
 & 
ECC byte 2
 & 
Error correction code byte 2
\\
\hline
0x03
 & 
Autoplace 0
 & \\
\hline
0x04
 & 
Autoplace 1
 & \\
\hline
0x05
 & 
Bad block marker
 & 
If any bit in this byte is zero, then this
block is bad. This applies only to the first
page in a block. In the remaining pages this
byte is reserved
\\
\hline
0x06
 & 
Autoplace 2
 & \\
\hline
0x07
 & 
Autoplace 3
 & \\
\hline\end{tabulary}



\subsubsection{512 byte pagesize}
\label{driver-api/mtdnand:id1}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Offset
} & \textsf{\relax 
Content
} & \textsf{\relax 
Comment
}\\
\hline
0x00
 & 
ECC byte 0
 & 
Error correction code byte 0 of the lower
256 Byte data in this page
\\
\hline
0x01
 & 
ECC byte 1
 & 
Error correction code byte 1 of the lower
256 Bytes of data in this page
\\
\hline
0x02
 & 
ECC byte 2
 & 
Error correction code byte 2 of the lower
256 Bytes of data in this page
\\
\hline
0x03
 & 
ECC byte 3
 & 
Error correction code byte 0 of the upper
256 Bytes of data in this page
\\
\hline
0x04
 & 
reserved
 & 
reserved
\\
\hline
0x05
 & 
Bad block marker
 & 
If any bit in this byte is zero, then this
block is bad. This applies only to the first
page in a block. In the remaining pages this
byte is reserved
\\
\hline
0x06
 & 
ECC byte 4
 & 
Error correction code byte 1 of the upper
256 Bytes of data in this page
\\
\hline
0x07
 & 
ECC byte 5
 & 
Error correction code byte 2 of the upper
256 Bytes of data in this page
\\
\hline
0x08 - 0x0F
 & 
Autoplace 0 - 7
 & \\
\hline\end{tabulary}



\subsubsection{2048 byte pagesize}
\label{driver-api/mtdnand:id2}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Offset
} & \textsf{\relax 
Content
} & \textsf{\relax 
Comment
}\\
\hline
0x00
 & 
Bad block marker
 & 
If any bit in this byte is zero, then this block
is bad. This applies only to the first page in a
block. In the remaining pages this byte is
reserved
\\
\hline
0x01
 & 
Reserved
 & 
Reserved
\\
\hline
0x02-0x27
 & 
Autoplace 0 - 37
 & \\
\hline
0x28
 & 
ECC byte 0
 & 
Error correction code byte 0 of the first
256 Byte data in this page
\\
\hline
0x29
 & 
ECC byte 1
 & 
Error correction code byte 1 of the first
256 Bytes of data in this page
\\
\hline
0x2A
 & 
ECC byte 2
 & 
Error correction code byte 2 of the first
256 Bytes data in this page
\\
\hline
0x2B
 & 
ECC byte 3
 & 
Error correction code byte 0 of the second
256 Bytes of data in this page
\\
\hline
0x2C
 & 
ECC byte 4
 & 
Error correction code byte 1 of the second
256 Bytes of data in this page
\\
\hline
0x2D
 & 
ECC byte 5
 & 
Error correction code byte 2 of the second
256 Bytes of data in this page
\\
\hline
0x2E
 & 
ECC byte 6
 & 
Error correction code byte 0 of the third
256 Bytes of data in this page
\\
\hline
0x2F
 & 
ECC byte 7
 & 
Error correction code byte 1 of the third
256 Bytes of data in this page
\\
\hline
0x30
 & 
ECC byte 8
 & 
Error correction code byte 2 of the third
256 Bytes of data in this page
\\
\hline
0x31
 & 
ECC byte 9
 & 
Error correction code byte 0 of the fourth
256 Bytes of data in this page
\\
\hline
0x32
 & 
ECC byte 10
 & 
Error correction code byte 1 of the fourth
256 Bytes of data in this page
\\
\hline
0x33
 & 
ECC byte 11
 & 
Error correction code byte 2 of the fourth
256 Bytes of data in this page
\\
\hline
0x34
 & 
ECC byte 12
 & 
Error correction code byte 0 of the fifth
256 Bytes of data in this page
\\
\hline
0x35
 & 
ECC byte 13
 & 
Error correction code byte 1 of the fifth
256 Bytes of data in this page
\\
\hline
0x36
 & 
ECC byte 14
 & 
Error correction code byte 2 of the fifth
256 Bytes of data in this page
\\
\hline
0x37
 & 
ECC byte 15
 & 
Error correction code byte 0 of the sixth
256 Bytes of data in this page
\\
\hline
0x38
 & 
ECC byte 16
 & 
Error correction code byte 1 of the sixth
256 Bytes of data in this page
\\
\hline
0x39
 & 
ECC byte 17
 & 
Error correction code byte 2 of the sixth
256 Bytes of data in this page
\\
\hline
0x3A
 & 
ECC byte 18
 & 
Error correction code byte 0 of the seventh
256 Bytes of data in this page
\\
\hline
0x3B
 & 
ECC byte 19
 & 
Error correction code byte 1 of the seventh
256 Bytes of data in this page
\\
\hline
0x3C
 & 
ECC byte 20
 & 
Error correction code byte 2 of the seventh
256 Bytes of data in this page
\\
\hline
0x3D
 & 
ECC byte 21
 & 
Error correction code byte 0 of the eighth
256 Bytes of data in this page
\\
\hline
0x3E
 & 
ECC byte 22
 & 
Error correction code byte 1 of the eighth
256 Bytes of data in this page
\\
\hline
0x3F
 & 
ECC byte 23
 & 
Error correction code byte 2 of the eighth
256 Bytes of data in this page
\\
\hline\end{tabulary}



\section{Filesystem support}
\label{driver-api/mtdnand:filesystem-support}
The NAND driver provides all necessary functions for a filesystem via
the MTD interface.

Filesystems must be aware of the NAND peculiarities and restrictions.
One major restrictions of NAND Flash is, that you cannot write as often
as you want to a page. The consecutive writes to a page, before erasing
it again, are restricted to 1-3 writes, depending on the manufacturers
specifications. This applies similar to the spare area.

Therefore NAND aware filesystems must either write in page size chunks
or hold a writebuffer to collect smaller writes until they sum up to
pagesize. Available NAND aware filesystems: JFFS2, YAFFS.

The spare area usage to store filesystem data is controlled by the spare
area placement functionality which is described in one of the earlier
chapters.


\section{Tools}
\label{driver-api/mtdnand:tools}
The MTD project provides a couple of helpful tools to handle NAND Flash.
\begin{itemize}
\item {} 
flasherase, flasheraseall: Erase and format FLASH partitions

\item {} 
nandwrite: write filesystem images to NAND FLASH

\item {} 
nanddump: dump the contents of a NAND FLASH partitions

\end{itemize}

These tools are aware of the NAND restrictions. Please use those tools
instead of complaining about errors which are caused by non NAND aware
access methods.


\section{Constants}
\label{driver-api/mtdnand:constants}
This chapter describes the constants which might be relevant for a
driver developer.


\subsection{Chip option constants}
\label{driver-api/mtdnand:chip-option-constants}

\subsubsection{Constants for chip id table}
\label{driver-api/mtdnand:constants-for-chip-id-table}
These constants are defined in rawnand.h. They are OR-ed together to
describe the chip functionality:

\begin{Verbatim}[commandchars=\\\{\}]
/* Buswitdh is 16 bit */
\PYGZsh{}define NAND\PYGZus{}BUSWIDTH\PYGZus{}16    0x00000002
/* Device supports partial programming without padding */
\PYGZsh{}define NAND\PYGZus{}NO\PYGZus{}PADDING     0x00000004
/* Chip has cache program function */
\PYGZsh{}define NAND\PYGZus{}CACHEPRG       0x00000008
/* Chip has copy back function */
\PYGZsh{}define NAND\PYGZus{}COPYBACK       0x00000010
/* AND Chip which has 4 banks and a confusing page / block
 * assignment. See Renesas datasheet for further information */
\PYGZsh{}define NAND\PYGZus{}IS\PYGZus{}AND     0x00000020
/* Chip has a array of 4 pages which can be read without
 * additional ready /busy waits */
\PYGZsh{}define NAND\PYGZus{}4PAGE\PYGZus{}ARRAY    0x00000040
\end{Verbatim}


\subsubsection{Constants for runtime options}
\label{driver-api/mtdnand:constants-for-runtime-options}
These constants are defined in rawnand.h. They are OR-ed together to
describe the functionality:

\begin{Verbatim}[commandchars=\\\{\}]
/* The hw ecc generator provides a syndrome instead a ecc value on read
 * This can only work if we have the ecc bytes directly behind the
 * data bytes. Applies for DOC and AG\PYGZhy{}AND Renesas HW Reed Solomon generators */
\PYGZsh{}define NAND\PYGZus{}HWECC\PYGZus{}SYNDROME 0x00020000
\end{Verbatim}


\subsection{ECC selection constants}
\label{driver-api/mtdnand:ecc-selection-constants}
Use these constants to select the ECC algorithm:

\begin{Verbatim}[commandchars=\\\{\}]
/* No ECC. Usage is not recommended ! */
\PYGZsh{}define NAND\PYGZus{}ECC\PYGZus{}NONE       0
/* Software ECC 3 byte ECC per 256 Byte data */
\PYGZsh{}define NAND\PYGZus{}ECC\PYGZus{}SOFT       1
/* Hardware ECC 3 byte ECC per 256 Byte data */
\PYGZsh{}define NAND\PYGZus{}ECC\PYGZus{}HW3\PYGZus{}256    2
/* Hardware ECC 3 byte ECC per 512 Byte data */
\PYGZsh{}define NAND\PYGZus{}ECC\PYGZus{}HW3\PYGZus{}512    3
/* Hardware ECC 6 byte ECC per 512 Byte data */
\PYGZsh{}define NAND\PYGZus{}ECC\PYGZus{}HW6\PYGZus{}512    4
/* Hardware ECC 6 byte ECC per 512 Byte data */
\PYGZsh{}define NAND\PYGZus{}ECC\PYGZus{}HW8\PYGZus{}512    6
\end{Verbatim}


\subsection{Hardware control related constants}
\label{driver-api/mtdnand:hardware-control-related-constants}
These constants describe the requested hardware access function when the
boardspecific hardware control function is called:

\begin{Verbatim}[commandchars=\\\{\}]
/* Select the chip by setting nCE to low */
\PYGZsh{}define NAND\PYGZus{}CTL\PYGZus{}SETNCE     1
/* Deselect the chip by setting nCE to high */
\PYGZsh{}define NAND\PYGZus{}CTL\PYGZus{}CLRNCE     2
/* Select the command latch by setting CLE to high */
\PYGZsh{}define NAND\PYGZus{}CTL\PYGZus{}SETCLE     3
/* Deselect the command latch by setting CLE to low */
\PYGZsh{}define NAND\PYGZus{}CTL\PYGZus{}CLRCLE     4
/* Select the address latch by setting ALE to high */
\PYGZsh{}define NAND\PYGZus{}CTL\PYGZus{}SETALE     5
/* Deselect the address latch by setting ALE to low */
\PYGZsh{}define NAND\PYGZus{}CTL\PYGZus{}CLRALE     6
/* Set write protection by setting WP to high. Not used! */
\PYGZsh{}define NAND\PYGZus{}CTL\PYGZus{}SETWP      7
/* Clear write protection by setting WP to low. Not used! */
\PYGZsh{}define NAND\PYGZus{}CTL\PYGZus{}CLRWP      8
\end{Verbatim}


\subsection{Bad block table related constants}
\label{driver-api/mtdnand:bad-block-table-related-constants}
These constants describe the options used for bad block table
descriptors:

\begin{Verbatim}[commandchars=\\\{\}]
/* Options for the bad block table descriptors */

/* The number of bits used per block in the bbt on the device */
\PYGZsh{}define NAND\PYGZus{}BBT\PYGZus{}NRBITS\PYGZus{}MSK 0x0000000F
\PYGZsh{}define NAND\PYGZus{}BBT\PYGZus{}1BIT       0x00000001
\PYGZsh{}define NAND\PYGZus{}BBT\PYGZus{}2BIT       0x00000002
\PYGZsh{}define NAND\PYGZus{}BBT\PYGZus{}4BIT       0x00000004
\PYGZsh{}define NAND\PYGZus{}BBT\PYGZus{}8BIT       0x00000008
/* The bad block table is in the last good block of the device */
\PYGZsh{}define NAND\PYGZus{}BBT\PYGZus{}LASTBLOCK  0x00000010
/* The bbt is at the given page, else we must scan for the bbt */
\PYGZsh{}define NAND\PYGZus{}BBT\PYGZus{}ABSPAGE    0x00000020
/* bbt is stored per chip on multichip devices */
\PYGZsh{}define NAND\PYGZus{}BBT\PYGZus{}PERCHIP    0x00000080
/* bbt has a version counter at offset veroffs */
\PYGZsh{}define NAND\PYGZus{}BBT\PYGZus{}VERSION    0x00000100
/* Create a bbt if none axists */
\PYGZsh{}define NAND\PYGZus{}BBT\PYGZus{}CREATE     0x00000200
/* Write bbt if necessary */
\PYGZsh{}define NAND\PYGZus{}BBT\PYGZus{}WRITE      0x00001000
/* Read and write back block contents when writing bbt */
\PYGZsh{}define NAND\PYGZus{}BBT\PYGZus{}SAVECONTENT    0x00002000
\end{Verbatim}


\section{Structures}
\label{driver-api/mtdnand:structures}
This chapter contains the autogenerated documentation of the structures
which are used in the NAND driver and might be relevant for a driver
developer. Each struct member has a short description which is marked
with an {[}XXX{]} identifier. See the chapter ``Documentation hints'' for an
explanation.
\index{nand\_id (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_id}\pysigline{struct \bfcode{nand\_id}}
NAND id structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}id \PYGZob{}
  u8 data[NAND\PYGZus{}MAX\PYGZus{}ID\PYGZus{}LEN];
  int len;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{data}}] \leavevmode
buffer containing the id bytes.

\item[{\code{len}}] \leavevmode
ID length.

\end{description}
\index{nand\_hw\_control (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_hw_control}\pysigline{struct \bfcode{nand\_hw\_control}}
Control structure for hardware controller (e.g ECC generator) shared among independent devices

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}hw\PYGZus{}control \PYGZob{}
  spinlock\PYGZus{}t lock;
  struct nand\PYGZus{}chip *active;
  wait\PYGZus{}queue\PYGZus{}head\PYGZus{}t wq;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{lock}}] \leavevmode
protection lock

\item[{\code{active}}] \leavevmode
the mtd device which holds the controller currently

\item[{\code{wq}}] \leavevmode
wait queue to sleep on if a NAND operation is in
progress used instead of the per chip wait queue
when a hw controller is available.

\end{description}
\index{nand\_ecc\_step\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_ecc_step_info}\pysigline{struct \bfcode{nand\_ecc\_step\_info}}
ECC step information of ECC engine

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}ecc\PYGZus{}step\PYGZus{}info \PYGZob{}
  int stepsize;
  const int *strengths;
  int nstrengths;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{stepsize}}] \leavevmode
data bytes per ECC step

\item[{\code{strengths}}] \leavevmode
array of supported strengths

\item[{\code{nstrengths}}] \leavevmode
number of supported strengths

\end{description}
\index{nand\_ecc\_caps (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_ecc_caps}\pysigline{struct \bfcode{nand\_ecc\_caps}}
capability of ECC engine

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}ecc\PYGZus{}caps \PYGZob{}
  const struct nand\PYGZus{}ecc\PYGZus{}step\PYGZus{}info *stepinfos;
  int nstepinfos;
  int (*calc\PYGZus{}ecc\PYGZus{}bytes)(int step\PYGZus{}size, int strength);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{stepinfos}}] \leavevmode
array of ECC step information

\item[{\code{nstepinfos}}] \leavevmode
number of ECC step information

\item[{\code{calc\_ecc\_bytes}}] \leavevmode
driver's hook to calculate ECC bytes per step

\end{description}
\index{nand\_ecc\_ctrl (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_ecc_ctrl}\pysigline{struct \bfcode{nand\_ecc\_ctrl}}
Control structure for ECC

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}ecc\PYGZus{}ctrl \PYGZob{}
  nand\PYGZus{}ecc\PYGZus{}modes\PYGZus{}t mode;
  enum nand\PYGZus{}ecc\PYGZus{}algo algo;
  int steps;
  int size;
  int bytes;
  int total;
  int strength;
  int prepad;
  int postpad;
  unsigned int options;
  void *priv;
  u8 *calc\PYGZus{}buf;
  u8 *code\PYGZus{}buf;
  void (*hwctl)(struct mtd\PYGZus{}info *mtd, int mode);
  int (*calculate)(struct mtd\PYGZus{}info *mtd, const uint8\PYGZus{}t *dat, uint8\PYGZus{}t *ecc\PYGZus{}code);
  int (*correct)(struct mtd\PYGZus{}info *mtd, uint8\PYGZus{}t *dat, uint8\PYGZus{}t *read\PYGZus{}ecc, uint8\PYGZus{}t *calc\PYGZus{}ecc);
  int (*read\PYGZus{}page\PYGZus{}raw)(struct mtd\PYGZus{}info *mtd, struct nand\PYGZus{}chip *chip, uint8\PYGZus{}t *buf, int oob\PYGZus{}required, int page);
  int (*write\PYGZus{}page\PYGZus{}raw)(struct mtd\PYGZus{}info *mtd, struct nand\PYGZus{}chip *chip, const uint8\PYGZus{}t *buf, int oob\PYGZus{}required, int page);
  int (*read\PYGZus{}page)(struct mtd\PYGZus{}info *mtd, struct nand\PYGZus{}chip *chip, uint8\PYGZus{}t *buf, int oob\PYGZus{}required, int page);
  int (*read\PYGZus{}subpage)(struct mtd\PYGZus{}info *mtd, struct nand\PYGZus{}chip *chip, uint32\PYGZus{}t offs, uint32\PYGZus{}t len, uint8\PYGZus{}t *buf, int page);
  int (*write\PYGZus{}subpage)(struct mtd\PYGZus{}info *mtd, struct nand\PYGZus{}chip *chip,uint32\PYGZus{}t offset, uint32\PYGZus{}t data\PYGZus{}len, const uint8\PYGZus{}t *data\PYGZus{}buf, int oob\PYGZus{}required, int page);
  int (*write\PYGZus{}page)(struct mtd\PYGZus{}info *mtd, struct nand\PYGZus{}chip *chip, const uint8\PYGZus{}t *buf, int oob\PYGZus{}required, int page);
  int (*write\PYGZus{}oob\PYGZus{}raw)(struct mtd\PYGZus{}info *mtd, struct nand\PYGZus{}chip *chip, int page);
  int (*read\PYGZus{}oob\PYGZus{}raw)(struct mtd\PYGZus{}info *mtd, struct nand\PYGZus{}chip *chip, int page);
  int (*read\PYGZus{}oob)(struct mtd\PYGZus{}info *mtd, struct nand\PYGZus{}chip *chip, int page);
  int (*write\PYGZus{}oob)(struct mtd\PYGZus{}info *mtd, struct nand\PYGZus{}chip *chip, int page);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{mode}}] \leavevmode
ECC mode

\item[{\code{algo}}] \leavevmode
ECC algorithm

\item[{\code{steps}}] \leavevmode
number of ECC steps per page

\item[{\code{size}}] \leavevmode
data bytes per ECC step

\item[{\code{bytes}}] \leavevmode
ECC bytes per step

\item[{\code{total}}] \leavevmode
total number of ECC bytes per page

\item[{\code{strength}}] \leavevmode
max number of correctible bits per ECC step

\item[{\code{prepad}}] \leavevmode
padding information for syndrome based ECC generators

\item[{\code{postpad}}] \leavevmode
padding information for syndrome based ECC generators

\item[{\code{options}}] \leavevmode
ECC specific options (see NAND\_ECC\_XXX flags defined above)

\item[{\code{priv}}] \leavevmode
pointer to private ECC control data

\item[{\code{calc\_buf}}] \leavevmode
buffer for calculated ECC, size is oobsize.

\item[{\code{code\_buf}}] \leavevmode
buffer for ECC read from flash, size is oobsize.

\item[{\code{hwctl}}] \leavevmode
function to control hardware ECC generator. Must only
be provided if an hardware ECC is available

\item[{\code{calculate}}] \leavevmode
function for ECC calculation or readback from ECC hardware

\item[{\code{correct}}] \leavevmode
function for ECC correction, matching to ECC generator (sw/hw).
Should return a positive number representing the number of
corrected bitflips, -EBADMSG if the number of bitflips exceed
ECC strength, or any other error code if the error is not
directly related to correction.
If -EBADMSG is returned the input buffers should be left
untouched.

\item[{\code{read\_page\_raw}}] \leavevmode
function to read a raw page without ECC. This function
should hide the specific layout used by the ECC
controller and always return contiguous in-band and
out-of-band data even if they're not stored
contiguously on the NAND chip (e.g.
NAND\_ECC\_HW\_SYNDROME interleaves in-band and
out-of-band data).

\item[{\code{write\_page\_raw}}] \leavevmode
function to write a raw page without ECC. This function
should hide the specific layout used by the ECC
controller and consider the passed data as contiguous
in-band and out-of-band data. ECC controller is
responsible for doing the appropriate transformations
to adapt to its specific layout (e.g.
NAND\_ECC\_HW\_SYNDROME interleaves in-band and
out-of-band data).

\item[{\code{read\_page}}] \leavevmode
function to read a page according to the ECC generator
requirements; returns maximum number of bitflips corrected in
any single ECC step, -EIO hw error

\item[{\code{read\_subpage}}] \leavevmode
function to read parts of the page covered by ECC;
returns same as \code{read\_page()}

\item[{\code{write\_subpage}}] \leavevmode
function to write parts of the page covered by ECC.

\item[{\code{write\_page}}] \leavevmode
function to write a page according to the ECC generator
requirements.

\item[{\code{write\_oob\_raw}}] \leavevmode
function to write chip OOB data without ECC

\item[{\code{read\_oob\_raw}}] \leavevmode
function to read chip OOB data without ECC

\item[{\code{read\_oob}}] \leavevmode
function to read chip OOB data

\item[{\code{write\_oob}}] \leavevmode
function to write chip OOB data

\end{description}
\index{nand\_sdr\_timings (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_sdr_timings}\pysigline{struct \bfcode{nand\_sdr\_timings}}
SDR NAND chip timings

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}sdr\PYGZus{}timings \PYGZob{}
  u64 tBERS\PYGZus{}max;
  u32 tCCS\PYGZus{}min;
  u64 tPROG\PYGZus{}max;
  u64 tR\PYGZus{}max;
  u32 tALH\PYGZus{}min;
  u32 tADL\PYGZus{}min;
  u32 tALS\PYGZus{}min;
  u32 tAR\PYGZus{}min;
  u32 tCEA\PYGZus{}max;
  u32 tCEH\PYGZus{}min;
  u32 tCH\PYGZus{}min;
  u32 tCHZ\PYGZus{}max;
  u32 tCLH\PYGZus{}min;
  u32 tCLR\PYGZus{}min;
  u32 tCLS\PYGZus{}min;
  u32 tCOH\PYGZus{}min;
  u32 tCS\PYGZus{}min;
  u32 tDH\PYGZus{}min;
  u32 tDS\PYGZus{}min;
  u32 tFEAT\PYGZus{}max;
  u32 tIR\PYGZus{}min;
  u32 tITC\PYGZus{}max;
  u32 tRC\PYGZus{}min;
  u32 tREA\PYGZus{}max;
  u32 tREH\PYGZus{}min;
  u32 tRHOH\PYGZus{}min;
  u32 tRHW\PYGZus{}min;
  u32 tRHZ\PYGZus{}max;
  u32 tRLOH\PYGZus{}min;
  u32 tRP\PYGZus{}min;
  u32 tRR\PYGZus{}min;
  u64 tRST\PYGZus{}max;
  u32 tWB\PYGZus{}max;
  u32 tWC\PYGZus{}min;
  u32 tWH\PYGZus{}min;
  u32 tWHR\PYGZus{}min;
  u32 tWP\PYGZus{}min;
  u32 tWW\PYGZus{}min;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{tBERS\_max}}] \leavevmode
Block erase time

\item[{\code{tCCS\_min}}] \leavevmode
Change column setup time

\item[{\code{tPROG\_max}}] \leavevmode
Page program time

\item[{\code{tR\_max}}] \leavevmode
Page read time

\item[{\code{tALH\_min}}] \leavevmode
ALE hold time

\item[{\code{tADL\_min}}] \leavevmode
ALE to data loading time

\item[{\code{tALS\_min}}] \leavevmode
ALE setup time

\item[{\code{tAR\_min}}] \leavevmode
ALE to RE\# delay

\item[{\code{tCEA\_max}}] \leavevmode
CE\# access time

\item[{\code{tCEH\_min}}] \leavevmode
CE\# high hold time

\item[{\code{tCH\_min}}] \leavevmode
CE\# hold time

\item[{\code{tCHZ\_max}}] \leavevmode
CE\# high to output hi-Z

\item[{\code{tCLH\_min}}] \leavevmode
CLE hold time

\item[{\code{tCLR\_min}}] \leavevmode
CLE to RE\# delay

\item[{\code{tCLS\_min}}] \leavevmode
CLE setup time

\item[{\code{tCOH\_min}}] \leavevmode
CE\# high to output hold

\item[{\code{tCS\_min}}] \leavevmode
CE\# setup time

\item[{\code{tDH\_min}}] \leavevmode
Data hold time

\item[{\code{tDS\_min}}] \leavevmode
Data setup time

\item[{\code{tFEAT\_max}}] \leavevmode
Busy time for Set Features and Get Features

\item[{\code{tIR\_min}}] \leavevmode
Output hi-Z to RE\# low

\item[{\code{tITC\_max}}] \leavevmode
Interface and Timing Mode Change time

\item[{\code{tRC\_min}}] \leavevmode
RE\# cycle time

\item[{\code{tREA\_max}}] \leavevmode
RE\# access time

\item[{\code{tREH\_min}}] \leavevmode
RE\# high hold time

\item[{\code{tRHOH\_min}}] \leavevmode
RE\# high to output hold

\item[{\code{tRHW\_min}}] \leavevmode
RE\# high to WE\# low

\item[{\code{tRHZ\_max}}] \leavevmode
RE\# high to output hi-Z

\item[{\code{tRLOH\_min}}] \leavevmode
RE\# low to output hold

\item[{\code{tRP\_min}}] \leavevmode
RE\# pulse width

\item[{\code{tRR\_min}}] \leavevmode
Ready to RE\# low (data only)

\item[{\code{tRST\_max}}] \leavevmode
Device reset time, measured from the falling edge of R/B\# to the
rising edge of R/B\#.

\item[{\code{tWB\_max}}] \leavevmode
WE\# high to SR{[}6{]} low

\item[{\code{tWC\_min}}] \leavevmode
WE\# cycle time

\item[{\code{tWH\_min}}] \leavevmode
WE\# high hold time

\item[{\code{tWHR\_min}}] \leavevmode
WE\# high to RE\# low

\item[{\code{tWP\_min}}] \leavevmode
WE\# pulse width

\item[{\code{tWW\_min}}] \leavevmode
WP\# transition to WE\# low

\end{description}

\textbf{Description}

This struct defines the timing requirements of a SDR NAND chip.
These information can be found in every NAND datasheets and the timings
meaning are described in the ONFI specifications:
www.onfi.org/\textasciitilde{}/media/ONFI/specs/onfi\_3\_1\_spec.pdf (chapter 4.15 Timing
Parameters)

All these timings are expressed in picoseconds.
\index{nand\_data\_interface\_type (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_data_interface_type}\pysigline{enum \bfcode{nand\_data\_interface\_type}}
NAND interface timing type

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{NAND\_SDR\_IFACE}}] \leavevmode
Single Data Rate interface

\end{description}
\index{nand\_data\_interface (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_data_interface}\pysigline{struct \bfcode{nand\_data\_interface}}
NAND interface timing

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}data\PYGZus{}interface \PYGZob{}
  enum nand\PYGZus{}data\PYGZus{}interface\PYGZus{}type type;
  union \PYGZob{}
    struct nand\PYGZus{}sdr\PYGZus{}timings sdr;
  \PYGZcb{} timings;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{type}}] \leavevmode
type of the timing

\item[{\code{timings}}] \leavevmode
The timing, type according to \textbf{type}

\end{description}
\index{nand\_get\_sdr\_timings (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_get_sdr_timings}\pysiglinewithargsret{const struct {\hyperref[driver\string-api/mtdnand:c.nand_sdr_timings]{\emph{nand\_sdr\_timings}}} * \bfcode{nand\_get\_sdr\_timings}}{const struct {\hyperref[driver\string-api/mtdnand:c.nand_data_interface]{\emph{nand\_data\_interface}}} *\emph{ conf}}{}
get SDR timing from data interface

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct nand\_data\_interface * conf}}] \leavevmode
The data interface

\end{description}
\index{nand\_manufacturer\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_manufacturer_ops}\pysigline{struct \bfcode{nand\_manufacturer\_ops}}
NAND Manufacturer operations

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}manufacturer\PYGZus{}ops \PYGZob{}
  void (*detect)(struct nand\PYGZus{}chip *chip);
  int (*init)(struct nand\PYGZus{}chip *chip);
  void (*cleanup)(struct nand\PYGZus{}chip *chip);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{detect}}] \leavevmode
detect the NAND memory organization and capabilities

\item[{\code{init}}] \leavevmode
initialize all vendor specific fields (like the -\textgreater{}:c:func:\emph{read\_retry()}
implementation) if any.

\item[{\code{cleanup}}] \leavevmode
the -\textgreater{}:c:func:\emph{init()} function may have allocated resources, -\textgreater{}:c:func:\emph{cleanup()}
is here to let vendor specific code release those resources.

\end{description}
\index{nand\_op\_cmd\_instr (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_op_cmd_instr}\pysigline{struct \bfcode{nand\_op\_cmd\_instr}}
Definition of a command instruction

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}op\PYGZus{}cmd\PYGZus{}instr \PYGZob{}
  u8 opcode;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{opcode}}] \leavevmode
the command to issue in one cycle

\end{description}
\index{nand\_op\_addr\_instr (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_op_addr_instr}\pysigline{struct \bfcode{nand\_op\_addr\_instr}}
Definition of an address instruction

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}op\PYGZus{}addr\PYGZus{}instr \PYGZob{}
  unsigned int naddrs;
  const u8 *addrs;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{naddrs}}] \leavevmode
length of the \textbf{addrs} array

\item[{\code{addrs}}] \leavevmode
array containing the address cycles to issue

\end{description}
\index{nand\_op\_data\_instr (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_op_data_instr}\pysigline{struct \bfcode{nand\_op\_data\_instr}}
Definition of a data instruction

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}op\PYGZus{}data\PYGZus{}instr \PYGZob{}
  unsigned int len;
  union \PYGZob{}
    void *in;
    const void *out;
  \PYGZcb{} buf;
  bool force\PYGZus{}8bit;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{len}}] \leavevmode
number of data bytes to move

\item[{\code{force\_8bit}}] \leavevmode
force 8-bit access

\end{description}

\textbf{Description}

Please note that ``in'' and ``out'' are inverted from the ONFI specification
and are from the controller perspective, so a ``in'' is a read from the NAND
chip while a ``out'' is a write to the NAND chip.
\index{nand\_op\_waitrdy\_instr (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_op_waitrdy_instr}\pysigline{struct \bfcode{nand\_op\_waitrdy\_instr}}
Definition of a wait ready instruction

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}op\PYGZus{}waitrdy\PYGZus{}instr \PYGZob{}
  unsigned int timeout\PYGZus{}ms;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{timeout\_ms}}] \leavevmode
maximum delay while waiting for the ready/busy pin in ms

\end{description}
\index{nand\_op\_instr\_type (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_op_instr_type}\pysigline{enum \bfcode{nand\_op\_instr\_type}}
Definition of all instruction types

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{NAND\_OP\_CMD\_INSTR}}] \leavevmode
command instruction

\item[{\code{NAND\_OP\_ADDR\_INSTR}}] \leavevmode
address instruction

\item[{\code{NAND\_OP\_DATA\_IN\_INSTR}}] \leavevmode
data in instruction

\item[{\code{NAND\_OP\_DATA\_OUT\_INSTR}}] \leavevmode
data out instruction

\item[{\code{NAND\_OP\_WAITRDY\_INSTR}}] \leavevmode
wait ready instruction

\end{description}
\index{nand\_op\_instr (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_op_instr}\pysigline{struct \bfcode{nand\_op\_instr}}
Instruction object

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}op\PYGZus{}instr \PYGZob{}
  enum nand\PYGZus{}op\PYGZus{}instr\PYGZus{}type type;
  union \PYGZob{}
    struct nand\PYGZus{}op\PYGZus{}cmd\PYGZus{}instr cmd;
    struct nand\PYGZus{}op\PYGZus{}addr\PYGZus{}instr addr;
    struct nand\PYGZus{}op\PYGZus{}data\PYGZus{}instr data;
    struct nand\PYGZus{}op\PYGZus{}waitrdy\PYGZus{}instr waitrdy;
  \PYGZcb{} ctx;
  unsigned int delay\PYGZus{}ns;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{type}}] \leavevmode
the instruction type
\textbf{cmd}/\textbf{addr}/\textbf{data}/\textbf{waitrdy}: extra data associated to the instruction.
\begin{quote}

You'll have to use the appropriate element
depending on \textbf{type}
\end{quote}

\item[{\code{delay\_ns}}] \leavevmode
delay the controller should apply after the instruction has been
issued on the bus. Most modern controllers have internal timings
control logic, and in this case, the controller driver can ignore
this field.

\end{description}
\index{nand\_subop (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_subop}\pysigline{struct \bfcode{nand\_subop}}
a sub operation

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}subop \PYGZob{}
  const struct nand\PYGZus{}op\PYGZus{}instr *instrs;
  unsigned int ninstrs;
  unsigned int first\PYGZus{}instr\PYGZus{}start\PYGZus{}off;
  unsigned int last\PYGZus{}instr\PYGZus{}end\PYGZus{}off;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{instrs}}] \leavevmode
array of instructions

\item[{\code{ninstrs}}] \leavevmode
length of the \textbf{instrs} array

\item[{\code{first\_instr\_start\_off}}] \leavevmode
offset to start from for the first instruction
of the sub-operation

\item[{\code{last\_instr\_end\_off}}] \leavevmode
offset to end at (excluded) for the last instruction
of the sub-operation

\end{description}

\textbf{Description}

Both \textbf{first\_instr\_start\_off} and \textbf{last\_instr\_end\_off} only apply to data or
address instructions.

When an operation cannot be handled as is by the NAND controller, it will
be split by the parser into sub-operations which will be passed to the
controller driver.
\index{nand\_op\_parser\_addr\_constraints (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_op_parser_addr_constraints}\pysigline{struct \bfcode{nand\_op\_parser\_addr\_constraints}}
Constraints for address instructions

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}op\PYGZus{}parser\PYGZus{}addr\PYGZus{}constraints \PYGZob{}
  unsigned int maxcycles;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{maxcycles}}] \leavevmode
maximum number of address cycles the controller can issue in a
single step

\end{description}
\index{nand\_op\_parser\_data\_constraints (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_op_parser_data_constraints}\pysigline{struct \bfcode{nand\_op\_parser\_data\_constraints}}
Constraints for data instructions

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}op\PYGZus{}parser\PYGZus{}data\PYGZus{}constraints \PYGZob{}
  unsigned int maxlen;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{maxlen}}] \leavevmode
maximum data length that the controller can handle in a single step

\end{description}
\index{nand\_op\_parser\_pattern\_elem (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_op_parser_pattern_elem}\pysigline{struct \bfcode{nand\_op\_parser\_pattern\_elem}}
One element of a pattern

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}op\PYGZus{}parser\PYGZus{}pattern\PYGZus{}elem \PYGZob{}
  enum nand\PYGZus{}op\PYGZus{}instr\PYGZus{}type type;
  bool optional;
  union \PYGZob{}
    struct nand\PYGZus{}op\PYGZus{}parser\PYGZus{}addr\PYGZus{}constraints addr;
    struct nand\PYGZus{}op\PYGZus{}parser\PYGZus{}data\PYGZus{}constraints data;
  \PYGZcb{} ctx;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{type}}] \leavevmode
the instructuction type

\item[{\code{optional}}] \leavevmode
whether this element of the pattern is optional or mandatory
\textbf{addr}/\textbf{data}: address or data constraint (number of cycles or data length)

\end{description}
\index{nand\_op\_parser\_pattern (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_op_parser_pattern}\pysigline{struct \bfcode{nand\_op\_parser\_pattern}}
NAND sub-operation pattern descriptor

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}op\PYGZus{}parser\PYGZus{}pattern \PYGZob{}
  const struct nand\PYGZus{}op\PYGZus{}parser\PYGZus{}pattern\PYGZus{}elem *elems;
  unsigned int nelems;
  int (*exec)(struct nand\PYGZus{}chip *chip, const struct nand\PYGZus{}subop *subop);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{elems}}] \leavevmode
array of pattern elements

\item[{\code{nelems}}] \leavevmode
number of pattern elements in \textbf{elems} array

\item[{\code{exec}}] \leavevmode
the function that will issue a sub-operation

\end{description}

\textbf{Description}

A pattern is a list of elements, each element reprensenting one instruction
with its constraints. The pattern itself is used by the core to match NAND
chip operation with NAND controller operations.
Once a match between a NAND controller operation pattern and a NAND chip
operation (or a sub-set of a NAND operation) is found, the pattern -\textgreater{}:c:func:\emph{exec()}
hook is called so that the controller driver can issue the operation on the
bus.

Controller drivers should declare as many patterns as they support and pass
this list of patterns (created with the help of the following macro) to
the {\hyperref[driver\string-api/mtdnand:c.nand_op_parser_exec_op]{\emph{\code{nand\_op\_parser\_exec\_op()}}}} helper.
\index{nand\_op\_parser (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_op_parser}\pysigline{struct \bfcode{nand\_op\_parser}}
NAND controller operation parser descriptor

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}op\PYGZus{}parser \PYGZob{}
  const struct nand\PYGZus{}op\PYGZus{}parser\PYGZus{}pattern *patterns;
  unsigned int npatterns;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{patterns}}] \leavevmode
array of supported patterns

\item[{\code{npatterns}}] \leavevmode
length of the \textbf{patterns} array

\end{description}

\textbf{Description}

The parser descriptor is just an array of supported patterns which will be
iterated by {\hyperref[driver\string-api/mtdnand:c.nand_op_parser_exec_op]{\emph{\code{nand\_op\_parser\_exec\_op()}}}} everytime it tries to execute an
NAND operation (or tries to determine if a specific operation is supported).

It is worth mentioning that patterns will be tested in their declaration
order, and the first match will be taken, so it's important to order patterns
appropriately so that simple/inefficient patterns are placed at the end of
the list. Usually, this is where you put single instruction patterns.
\index{nand\_operation (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_operation}\pysigline{struct \bfcode{nand\_operation}}
NAND operation descriptor

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}operation \PYGZob{}
  const struct nand\PYGZus{}op\PYGZus{}instr *instrs;
  unsigned int ninstrs;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{instrs}}] \leavevmode
array of instructions to execute

\item[{\code{ninstrs}}] \leavevmode
length of the \textbf{instrs} array

\end{description}

\textbf{Description}

The actual operation structure that will be passed to chip-\textgreater{}:c:func:\emph{exec\_op()}.
\index{nand\_chip (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_chip}\pysigline{struct \bfcode{nand\_chip}}
NAND Private Flash Chip Data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}chip \PYGZob{}
  struct mtd\PYGZus{}info mtd;
  void \PYGZus{}\PYGZus{}iomem *IO\PYGZus{}ADDR\PYGZus{}R;
  void \PYGZus{}\PYGZus{}iomem *IO\PYGZus{}ADDR\PYGZus{}W;
  uint8\PYGZus{}t (*read\PYGZus{}byte)(struct mtd\PYGZus{}info *mtd);
  u16 (*read\PYGZus{}word)(struct mtd\PYGZus{}info *mtd);
  void (*write\PYGZus{}byte)(struct mtd\PYGZus{}info *mtd, uint8\PYGZus{}t byte);
  void (*write\PYGZus{}buf)(struct mtd\PYGZus{}info *mtd, const uint8\PYGZus{}t *buf, int len);
  void (*read\PYGZus{}buf)(struct mtd\PYGZus{}info *mtd, uint8\PYGZus{}t *buf, int len);
  void (*select\PYGZus{}chip)(struct mtd\PYGZus{}info *mtd, int chip);
  int (*block\PYGZus{}bad)(struct mtd\PYGZus{}info *mtd, loff\PYGZus{}t ofs);
  int (*block\PYGZus{}markbad)(struct mtd\PYGZus{}info *mtd, loff\PYGZus{}t ofs);
  void (*cmd\PYGZus{}ctrl)(struct mtd\PYGZus{}info *mtd, int dat, unsigned int ctrl);
  int (*dev\PYGZus{}ready)(struct mtd\PYGZus{}info *mtd);
  void (*cmdfunc)(struct mtd\PYGZus{}info *mtd, unsigned command, int column, int page\PYGZus{}addr);
  int(*waitfunc)(struct mtd\PYGZus{}info *mtd, struct nand\PYGZus{}chip *this);
  int (*exec\PYGZus{}op)(struct nand\PYGZus{}chip *chip,const struct nand\PYGZus{}operation *op, bool check\PYGZus{}only);
  int (*erase)(struct mtd\PYGZus{}info *mtd, int page);
  int (*scan\PYGZus{}bbt)(struct mtd\PYGZus{}info *mtd);
  int (*onfi\PYGZus{}set\PYGZus{}features)(struct mtd\PYGZus{}info *mtd, struct nand\PYGZus{}chip *chip, int feature\PYGZus{}addr, uint8\PYGZus{}t *subfeature\PYGZus{}para);
  int (*onfi\PYGZus{}get\PYGZus{}features)(struct mtd\PYGZus{}info *mtd, struct nand\PYGZus{}chip *chip, int feature\PYGZus{}addr, uint8\PYGZus{}t *subfeature\PYGZus{}para);
  int (*setup\PYGZus{}read\PYGZus{}retry)(struct mtd\PYGZus{}info *mtd, int retry\PYGZus{}mode);
  int (*setup\PYGZus{}data\PYGZus{}interface)(struct mtd\PYGZus{}info *mtd, int chipnr, const struct nand\PYGZus{}data\PYGZus{}interface *conf);
  int chip\PYGZus{}delay;
  unsigned int options;
  unsigned int bbt\PYGZus{}options;
  int page\PYGZus{}shift;
  int phys\PYGZus{}erase\PYGZus{}shift;
  int bbt\PYGZus{}erase\PYGZus{}shift;
  int chip\PYGZus{}shift;
  int numchips;
  uint64\PYGZus{}t chipsize;
  int pagemask;
  u8 *data\PYGZus{}buf;
  int pagebuf;
  unsigned int pagebuf\PYGZus{}bitflips;
  int subpagesize;
  uint8\PYGZus{}t bits\PYGZus{}per\PYGZus{}cell;
  uint16\PYGZus{}t ecc\PYGZus{}strength\PYGZus{}ds;
  uint16\PYGZus{}t ecc\PYGZus{}step\PYGZus{}ds;
  int onfi\PYGZus{}timing\PYGZus{}mode\PYGZus{}default;
  int badblockpos;
  int badblockbits;
  struct nand\PYGZus{}id id;
  int onfi\PYGZus{}version;
  int jedec\PYGZus{}version;
  union \PYGZob{}
    struct nand\PYGZus{}onfi\PYGZus{}params onfi\PYGZus{}params;
    struct nand\PYGZus{}jedec\PYGZus{}params jedec\PYGZus{}params;
  \PYGZcb{};
  u16 max\PYGZus{}bb\PYGZus{}per\PYGZus{}die;
  u32 blocks\PYGZus{}per\PYGZus{}die;
  struct nand\PYGZus{}data\PYGZus{}interface data\PYGZus{}interface;
  int read\PYGZus{}retries;
  flstate\PYGZus{}t state;
  uint8\PYGZus{}t *oob\PYGZus{}poi;
  struct nand\PYGZus{}hw\PYGZus{}control *controller;
  struct nand\PYGZus{}ecc\PYGZus{}ctrl ecc;
  unsigned long buf\PYGZus{}align;
  struct nand\PYGZus{}hw\PYGZus{}control hwcontrol;
  uint8\PYGZus{}t *bbt;
  struct nand\PYGZus{}bbt\PYGZus{}descr *bbt\PYGZus{}td;
  struct nand\PYGZus{}bbt\PYGZus{}descr *bbt\PYGZus{}md;
  struct nand\PYGZus{}bbt\PYGZus{}descr *badblock\PYGZus{}pattern;
  void *priv;
  struct \PYGZob{}
    const struct nand\PYGZus{}manufacturer *desc;
    void *priv;
  \PYGZcb{} manufacturer;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{mtd}}] \leavevmode
MTD device registered to the MTD framework

\item[{\code{IO\_ADDR\_R}}] \leavevmode
{[}BOARDSPECIFIC{]} address to read the 8 I/O lines of the
flash device

\item[{\code{IO\_ADDR\_W}}] \leavevmode
{[}BOARDSPECIFIC{]} address to write the 8 I/O lines of the
flash device.

\item[{\code{read\_byte}}] \leavevmode
{[}REPLACEABLE{]} read one byte from the chip

\item[{\code{read\_word}}] \leavevmode
{[}REPLACEABLE{]} read one word from the chip

\item[{\code{write\_byte}}] \leavevmode
{[}REPLACEABLE{]} write a single byte to the chip on the
low 8 I/O lines

\item[{\code{write\_buf}}] \leavevmode
{[}REPLACEABLE{]} write data from the buffer to the chip

\item[{\code{read\_buf}}] \leavevmode
{[}REPLACEABLE{]} read data from the chip into the buffer

\item[{\code{select\_chip}}] \leavevmode
{[}REPLACEABLE{]} select chip nr

\item[{\code{block\_bad}}] \leavevmode
{[}REPLACEABLE{]} check if a block is bad, using OOB markers

\item[{\code{block\_markbad}}] \leavevmode
{[}REPLACEABLE{]} mark a block bad

\item[{\code{cmd\_ctrl}}] \leavevmode
{[}BOARDSPECIFIC{]} hardwarespecific function for controlling
ALE/CLE/nCE. Also used to write command and address

\item[{\code{dev\_ready}}] \leavevmode
{[}BOARDSPECIFIC{]} hardwarespecific function for accessing
device ready/busy line. If set to NULL no access to
ready/busy is available and the ready/busy information
is read from the chip status register.

\item[{\code{cmdfunc}}] \leavevmode
{[}REPLACEABLE{]} hardwarespecific function for writing
commands to the chip.

\item[{\code{waitfunc}}] \leavevmode
{[}REPLACEABLE{]} hardwarespecific function for wait on
ready.

\item[{\code{exec\_op}}] \leavevmode
controller specific method to execute NAND operations.
This method replaces -\textgreater{}:c:func:\emph{cmdfunc()},
-\textgreater{}\{read,write\}\_\{buf,byte,word\}(), -\textgreater{}:c:func:\emph{dev\_ready()} and
-\textgreater{}:c:func:\emph{waifunc()}.

\item[{\code{erase}}] \leavevmode
{[}REPLACEABLE{]} erase function

\item[{\code{scan\_bbt}}] \leavevmode
{[}REPLACEABLE{]} function to scan bad block table

\item[{\code{onfi\_set\_features}}] \leavevmode
{[}REPLACEABLE{]} set the features for ONFI nand

\item[{\code{onfi\_get\_features}}] \leavevmode
{[}REPLACEABLE{]} get the features for ONFI nand

\item[{\code{setup\_read\_retry}}] \leavevmode
{[}FLASHSPECIFIC{]} flash (vendor) specific function for
setting the read-retry mode. Mostly needed for MLC NAND.

\item[{\code{setup\_data\_interface}}] \leavevmode
{[}OPTIONAL{]} setup the data interface and timing. If
chipnr is set to \code{NAND\_DATA\_IFACE\_CHECK\_ONLY} this
means the configuration should not be applied but
only checked.

\item[{\code{chip\_delay}}] \leavevmode
{[}BOARDSPECIFIC{]} chip dependent delay for transferring
data from array to read regs (tR).

\item[{\code{options}}] \leavevmode
{[}BOARDSPECIFIC{]} various chip options. They can partly
be set to inform nand\_scan about special functionality.
See the defines for further explanation.

\item[{\code{bbt\_options}}] \leavevmode
{[}INTERN{]} bad block specific options. All options used
here must come from bbm.h. By default, these options
will be copied to the appropriate nand\_bbt\_descr's.

\item[{\code{page\_shift}}] \leavevmode
{[}INTERN{]} number of address bits in a page (column
address bits).

\item[{\code{phys\_erase\_shift}}] \leavevmode
{[}INTERN{]} number of address bits in a physical eraseblock

\item[{\code{bbt\_erase\_shift}}] \leavevmode
{[}INTERN{]} number of address bits in a bbt entry

\item[{\code{chip\_shift}}] \leavevmode
{[}INTERN{]} number of address bits in one chip

\item[{\code{numchips}}] \leavevmode
{[}INTERN{]} number of physical chips

\item[{\code{chipsize}}] \leavevmode
{[}INTERN{]} the size of one chip for multichip arrays

\item[{\code{pagemask}}] \leavevmode
{[}INTERN{]} page number mask = number of (pages / chip) - 1

\item[{\code{data\_buf}}] \leavevmode
{[}INTERN{]} buffer for data, size is (page size + oobsize).

\item[{\code{pagebuf}}] \leavevmode
{[}INTERN{]} holds the pagenumber which is currently in
data\_buf.

\item[{\code{pagebuf\_bitflips}}] \leavevmode
{[}INTERN{]} holds the bitflip count for the page which is
currently in data\_buf.

\item[{\code{subpagesize}}] \leavevmode
{[}INTERN{]} holds the subpagesize

\item[{\code{bits\_per\_cell}}] \leavevmode
{[}INTERN{]} number of bits per cell. i.e., 1 means SLC.

\item[{\code{ecc\_strength\_ds}}] \leavevmode
{[}INTERN{]} ECC correctability from the datasheet.
Minimum amount of bit errors per \textbf{ecc\_step\_ds} guaranteed
to be correctable. If unknown, set to zero.

\item[{\code{ecc\_step\_ds}}] \leavevmode
{[}INTERN{]} ECC step required by the \textbf{ecc\_strength\_ds},
also from the datasheet. It is the recommended ECC step
size, if known; if unknown, set to zero.

\item[{\code{onfi\_timing\_mode\_default}}] \leavevmode
{[}INTERN{]} default ONFI timing mode. This field is
set to the actually used ONFI mode if the chip is
ONFI compliant or deduced from the datasheet if
the NAND chip is not ONFI compliant.

\item[{\code{badblockpos}}] \leavevmode
{[}INTERN{]} position of the bad block marker in the oob
area.

\item[{\code{badblockbits}}] \leavevmode
{[}INTERN{]} minimum number of set bits in a good block's
bad block marker position; i.e., BBM == 11110111b is
not bad when badblockbits == 7

\item[{\code{id}}] \leavevmode
{[}INTERN{]} holds NAND ID

\item[{\code{onfi\_version}}] \leavevmode
{[}INTERN{]} holds the chip ONFI version (BCD encoded),
non 0 if ONFI supported.

\item[{\code{jedec\_version}}] \leavevmode
{[}INTERN{]} holds the chip JEDEC version (BCD encoded),
non 0 if JEDEC supported.

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{onfi\_params}}] \leavevmode
{[}INTERN{]} holds the ONFI page parameter when ONFI is
supported, 0 otherwise.

\item[{\code{jedec\_params}}] \leavevmode
{[}INTERN{]} holds the JEDEC parameter page when JEDEC is
supported, 0 otherwise.

\item[{\code{max\_bb\_per\_die}}] \leavevmode
{[}INTERN{]} the max number of bad blocks each die of a
this nand device will encounter their life times.

\item[{\code{blocks\_per\_die}}] \leavevmode
{[}INTERN{]} The number of PEBs in a die

\item[{\code{data\_interface}}] \leavevmode
{[}INTERN{]} NAND interface timing information

\item[{\code{read\_retries}}] \leavevmode
{[}INTERN{]} the number of read retry modes supported

\item[{\code{state}}] \leavevmode
{[}INTERN{]} the current state of the NAND device

\item[{\code{oob\_poi}}] \leavevmode
``poison value buffer,'' used for laying out OOB data
before writing

\item[{\code{controller}}] \leavevmode
{[}REPLACEABLE{]} a pointer to a hardware controller
structure which is shared among multiple independent
devices.

\item[{\code{ecc}}] \leavevmode
{[}BOARDSPECIFIC{]} ECC control structure

\item[{\code{buf\_align}}] \leavevmode
minimum buffer alignment required by a platform

\item[{\code{hwcontrol}}] \leavevmode
platform-specific hardware control structure

\item[{\code{bbt}}] \leavevmode
{[}INTERN{]} bad block table pointer

\item[{\code{bbt\_td}}] \leavevmode
{[}REPLACEABLE{]} bad block table descriptor for flash
lookup.

\item[{\code{bbt\_md}}] \leavevmode
{[}REPLACEABLE{]} bad block table mirror descriptor

\item[{\code{badblock\_pattern}}] \leavevmode
{[}REPLACEABLE{]} bad block scan pattern used for initial
bad block scan.

\item[{\code{priv}}] \leavevmode
{[}OPTIONAL{]} pointer to private chip data

\item[{\code{manufacturer}}] \leavevmode
{[}INTERN{]} Contains manufacturer information

\end{description}
\index{nand\_flash\_dev (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_flash_dev}\pysigline{struct \bfcode{nand\_flash\_dev}}
NAND Flash Device ID Structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}flash\PYGZus{}dev \PYGZob{}
  char *name;
  union \PYGZob{}
    struct \PYGZob{}
      uint8\PYGZus{}t mfr\PYGZus{}id;
      uint8\PYGZus{}t dev\PYGZus{}id;
    \PYGZcb{};
    uint8\PYGZus{}t id[NAND\PYGZus{}MAX\PYGZus{}ID\PYGZus{}LEN];
  \PYGZcb{};
  unsigned int pagesize;
  unsigned int chipsize;
  unsigned int erasesize;
  unsigned int options;
  uint16\PYGZus{}t id\PYGZus{}len;
  uint16\PYGZus{}t oobsize;
  struct \PYGZob{}
    uint16\PYGZus{}t strength\PYGZus{}ds;
    uint16\PYGZus{}t step\PYGZus{}ds;
  \PYGZcb{} ecc;
  int onfi\PYGZus{}timing\PYGZus{}mode\PYGZus{}default;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
a human-readable name of the NAND chip

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{\{unnamed\_struct\}}}] \leavevmode
anonymous

\item[{\code{mfr\_id}}] \leavevmode
manufecturer ID part of the full chip ID array (refers the same
memory address as {\color{red}\bfseries{}**}id**{[}0{]})

\item[{\code{dev\_id}}] \leavevmode
device ID part of the full chip ID array (refers the same memory
address as {\color{red}\bfseries{}**}id**{[}1{]})

\item[{\code{id}}] \leavevmode
full device ID array

\item[{\code{pagesize}}] \leavevmode
size of the NAND page in bytes; if 0, then the real page size (as
well as the eraseblock size) is determined from the extended NAND
chip ID array)

\item[{\code{chipsize}}] \leavevmode
total chip size in MiB

\item[{\code{erasesize}}] \leavevmode
eraseblock size in bytes (determined from the extended ID if 0)

\item[{\code{options}}] \leavevmode
stores various chip bit options

\item[{\code{id\_len}}] \leavevmode
The valid length of the \textbf{id}.

\item[{\code{oobsize}}] \leavevmode
OOB size

\item[{\code{ecc}}] \leavevmode
ECC correctability and step information from the datasheet.

\item[{\code{ecc.strength\_ds}}] \leavevmode
The ECC correctability from the datasheet, same as the
\textbf{ecc\_strength\_ds} in nand\_chip\{\}.

\item[{\code{ecc.step\_ds}}] \leavevmode
The ECC step required by the \textbf{ecc.strength\_ds}, same as the
\textbf{ecc\_step\_ds} in nand\_chip\{\}, also from the datasheet.
For example, the ``4bit ECC for each 512Byte'' can be set with
NAND\_ECC\_INFO(4, 512).

\item[{\code{onfi\_timing\_mode\_default}}] \leavevmode
the default ONFI timing mode entered after a NAND
reset. Should be deduced from timings described
in the datasheet.

\end{description}
\index{nand\_manufacturer (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_manufacturer}\pysigline{struct \bfcode{nand\_manufacturer}}
NAND Flash Manufacturer structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}manufacturer \PYGZob{}
  int id;
  char *name;
  const struct nand\PYGZus{}manufacturer\PYGZus{}ops *ops;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{id}}] \leavevmode
manufacturer ID code of device.

\item[{\code{name}}] \leavevmode
Manufacturer name

\item[{\code{ops}}] \leavevmode
manufacturer operations

\end{description}
\index{platform\_nand\_chip (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.platform_nand_chip}\pysigline{struct \bfcode{platform\_nand\_chip}}
chip level device structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct platform\PYGZus{}nand\PYGZus{}chip \PYGZob{}
  int nr\PYGZus{}chips;
  int chip\PYGZus{}offset;
  int nr\PYGZus{}partitions;
  struct mtd\PYGZus{}partition *partitions;
  int chip\PYGZus{}delay;
  unsigned int options;
  unsigned int bbt\PYGZus{}options;
  const char **part\PYGZus{}probe\PYGZus{}types;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{nr\_chips}}] \leavevmode
max. number of chips to scan for

\item[{\code{chip\_offset}}] \leavevmode
chip number offset

\item[{\code{nr\_partitions}}] \leavevmode
number of partitions pointed to by partitions (or zero)

\item[{\code{partitions}}] \leavevmode
mtd partition list

\item[{\code{chip\_delay}}] \leavevmode
R/B delay value in us

\item[{\code{options}}] \leavevmode
Option flags, e.g. 16bit buswidth

\item[{\code{bbt\_options}}] \leavevmode
BBT option flags, e.g. NAND\_BBT\_USE\_FLASH

\item[{\code{part\_probe\_types}}] \leavevmode
NULL-terminated array of probe types

\end{description}
\index{platform\_nand\_ctrl (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.platform_nand_ctrl}\pysigline{struct \bfcode{platform\_nand\_ctrl}}
controller level device structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct platform\PYGZus{}nand\PYGZus{}ctrl \PYGZob{}
  int (*probe)(struct platform\PYGZus{}device *pdev);
  void (*remove)(struct platform\PYGZus{}device *pdev);
  void (*hwcontrol)(struct mtd\PYGZus{}info *mtd, int cmd);
  int (*dev\PYGZus{}ready)(struct mtd\PYGZus{}info *mtd);
  void (*select\PYGZus{}chip)(struct mtd\PYGZus{}info *mtd, int chip);
  void (*cmd\PYGZus{}ctrl)(struct mtd\PYGZus{}info *mtd, int dat, unsigned int ctrl);
  void (*write\PYGZus{}buf)(struct mtd\PYGZus{}info *mtd, const uint8\PYGZus{}t *buf, int len);
  void (*read\PYGZus{}buf)(struct mtd\PYGZus{}info *mtd, uint8\PYGZus{}t *buf, int len);
  unsigned char (*read\PYGZus{}byte)(struct mtd\PYGZus{}info *mtd);
  void *priv;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{probe}}] \leavevmode
platform specific function to probe/setup hardware

\item[{\code{remove}}] \leavevmode
platform specific function to remove/teardown hardware

\item[{\code{hwcontrol}}] \leavevmode
platform specific hardware control structure

\item[{\code{dev\_ready}}] \leavevmode
platform specific function to read ready/busy pin

\item[{\code{select\_chip}}] \leavevmode
platform specific chip select function

\item[{\code{cmd\_ctrl}}] \leavevmode
platform specific function for controlling
ALE/CLE/nCE. Also used to write command and address

\item[{\code{write\_buf}}] \leavevmode
platform specific function for write buffer

\item[{\code{read\_buf}}] \leavevmode
platform specific function for read buffer

\item[{\code{read\_byte}}] \leavevmode
platform specific function to read one byte from chip

\item[{\code{priv}}] \leavevmode
private data to transport driver specific settings

\end{description}

\textbf{Description}

All fields are optional and depend on the hardware driver requirements
\index{platform\_nand\_data (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.platform_nand_data}\pysigline{struct \bfcode{platform\_nand\_data}}
container structure for platform-specific data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct platform\PYGZus{}nand\PYGZus{}data \PYGZob{}
  struct platform\PYGZus{}nand\PYGZus{}chip chip;
  struct platform\PYGZus{}nand\PYGZus{}ctrl ctrl;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{chip}}] \leavevmode
chip level chip structure

\item[{\code{ctrl}}] \leavevmode
controller level device structure

\end{description}
\index{nand\_opcode\_8bits (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_opcode_8bits}\pysiglinewithargsret{int \bfcode{nand\_opcode\_8bits}}{unsigned int\emph{ command}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int command}}] \leavevmode
opcode to check

\end{description}


\section{Public Functions Provided}
\label{driver-api/mtdnand:public-functions-provided}
This chapter contains the autogenerated documentation of the NAND kernel
API functions which are exported. Each function has a short description
which is marked with an {[}XXX{]} identifier. See the chapter ``Documentation
hints'' for an explanation.
\index{nand\_wait\_ready (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_wait_ready}\pysiglinewithargsret{void \bfcode{nand\_wait\_ready}}{struct mtd\_info *\emph{ mtd}}{}
{[}GENERIC{]} Wait for the ready pin after commands.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\end{description}

\textbf{Description}

Wait for the ready pin after a command, and warn if a timeout occurs.
\index{nand\_soft\_waitrdy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_soft_waitrdy}\pysiglinewithargsret{int \bfcode{nand\_soft\_waitrdy}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, unsigned long\emph{ timeout\_ms}}{}
Poll STATUS reg until RDY bit is set to 1

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
NAND chip structure

\item[{\code{unsigned long timeout\_ms}}] \leavevmode
Timeout in ms

\end{description}

\textbf{Description}

Poll the STATUS register using -\textgreater{}:c:func:\emph{exec\_op()} until the RDY bit becomes 1.
If that does not happen whitin the specified timeout, -ETIMEDOUT is
returned.

This helper is intended to be used when the controller does not have access
to the NAND R/B pin.

Be aware that calling this helper from an -\textgreater{}:c:func:\emph{exec\_op()} implementation means
-\textgreater{}:c:func:\emph{exec\_op()} must be re-entrant.

Return 0 if the NAND chip is ready, a negative error otherwise.
\index{nand\_read\_page\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_page_op}\pysiglinewithargsret{int \bfcode{nand\_read\_page\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, unsigned int\emph{ page}, unsigned int\emph{ offset\_in\_page}, void *\emph{ buf}, unsigned int\emph{ len}}{}
Do a READ PAGE operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{unsigned int page}}] \leavevmode
page to read

\item[{\code{unsigned int offset\_in\_page}}] \leavevmode
offset within the page

\item[{\code{void * buf}}] \leavevmode
buffer used to store the data

\item[{\code{unsigned int len}}] \leavevmode
length of the buffer

\end{description}

\textbf{Description}

This function issues a READ PAGE operation.
This function does not select/unselect the CS line.

Returns 0 on success, a negative error code otherwise.
\index{nand\_change\_read\_column\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_change_read_column_op}\pysiglinewithargsret{int \bfcode{nand\_change\_read\_column\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, unsigned int\emph{ offset\_in\_page}, void *\emph{ buf}, unsigned int\emph{ len}, bool\emph{ force\_8bit}}{}
Do a CHANGE READ COLUMN operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{unsigned int offset\_in\_page}}] \leavevmode
offset within the page

\item[{\code{void * buf}}] \leavevmode
buffer used to store the data

\item[{\code{unsigned int len}}] \leavevmode
length of the buffer

\item[{\code{bool force\_8bit}}] \leavevmode
force 8-bit bus access

\end{description}

\textbf{Description}

This function issues a CHANGE READ COLUMN operation.
This function does not select/unselect the CS line.

Returns 0 on success, a negative error code otherwise.
\index{nand\_read\_oob\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_oob_op}\pysiglinewithargsret{int \bfcode{nand\_read\_oob\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, unsigned int\emph{ page}, unsigned int\emph{ offset\_in\_oob}, void *\emph{ buf}, unsigned int\emph{ len}}{}
Do a READ OOB operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{unsigned int page}}] \leavevmode
page to read

\item[{\code{unsigned int offset\_in\_oob}}] \leavevmode
offset within the OOB area

\item[{\code{void * buf}}] \leavevmode
buffer used to store the data

\item[{\code{unsigned int len}}] \leavevmode
length of the buffer

\end{description}

\textbf{Description}

This function issues a READ OOB operation.
This function does not select/unselect the CS line.

Returns 0 on success, a negative error code otherwise.
\index{nand\_prog\_page\_begin\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_prog_page_begin_op}\pysiglinewithargsret{int \bfcode{nand\_prog\_page\_begin\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, unsigned int\emph{ page}, unsigned int\emph{ offset\_in\_page}, const void *\emph{ buf}, unsigned int\emph{ len}}{}
starts a PROG PAGE operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{unsigned int page}}] \leavevmode
page to write

\item[{\code{unsigned int offset\_in\_page}}] \leavevmode
offset within the page

\item[{\code{const void * buf}}] \leavevmode
buffer containing the data to write to the page

\item[{\code{unsigned int len}}] \leavevmode
length of the buffer

\end{description}

\textbf{Description}

This function issues the first half of a PROG PAGE operation.
This function does not select/unselect the CS line.

Returns 0 on success, a negative error code otherwise.
\index{nand\_prog\_page\_end\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_prog_page_end_op}\pysiglinewithargsret{int \bfcode{nand\_prog\_page\_end\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}}{}
ends a PROG PAGE operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\end{description}

\textbf{Description}

This function issues the second half of a PROG PAGE operation.
This function does not select/unselect the CS line.

Returns 0 on success, a negative error code otherwise.
\index{nand\_prog\_page\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_prog_page_op}\pysiglinewithargsret{int \bfcode{nand\_prog\_page\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, unsigned int\emph{ page}, unsigned int\emph{ offset\_in\_page}, const void *\emph{ buf}, unsigned int\emph{ len}}{}
Do a full PROG PAGE operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{unsigned int page}}] \leavevmode
page to write

\item[{\code{unsigned int offset\_in\_page}}] \leavevmode
offset within the page

\item[{\code{const void * buf}}] \leavevmode
buffer containing the data to write to the page

\item[{\code{unsigned int len}}] \leavevmode
length of the buffer

\end{description}

\textbf{Description}

This function issues a full PROG PAGE operation.
This function does not select/unselect the CS line.

Returns 0 on success, a negative error code otherwise.
\index{nand\_change\_write\_column\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_change_write_column_op}\pysiglinewithargsret{int \bfcode{nand\_change\_write\_column\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, unsigned int\emph{ offset\_in\_page}, const void *\emph{ buf}, unsigned int\emph{ len}, bool\emph{ force\_8bit}}{}
Do a CHANGE WRITE COLUMN operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{unsigned int offset\_in\_page}}] \leavevmode
offset within the page

\item[{\code{const void * buf}}] \leavevmode
buffer containing the data to send to the NAND

\item[{\code{unsigned int len}}] \leavevmode
length of the buffer

\item[{\code{bool force\_8bit}}] \leavevmode
force 8-bit bus access

\end{description}

\textbf{Description}

This function issues a CHANGE WRITE COLUMN operation.
This function does not select/unselect the CS line.

Returns 0 on success, a negative error code otherwise.
\index{nand\_readid\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_readid_op}\pysiglinewithargsret{int \bfcode{nand\_readid\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, u8\emph{ addr}, void *\emph{ buf}, unsigned int\emph{ len}}{}
Do a READID operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{u8 addr}}] \leavevmode
address cycle to pass after the READID command

\item[{\code{void * buf}}] \leavevmode
buffer used to store the ID

\item[{\code{unsigned int len}}] \leavevmode
length of the buffer

\end{description}

\textbf{Description}

This function sends a READID command and reads back the ID returned by the
NAND.
This function does not select/unselect the CS line.

Returns 0 on success, a negative error code otherwise.
\index{nand\_status\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_status_op}\pysiglinewithargsret{int \bfcode{nand\_status\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, u8 *\emph{ status}}{}
Do a STATUS operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{u8 * status}}] \leavevmode
out variable to store the NAND status

\end{description}

\textbf{Description}

This function sends a STATUS command and reads back the status returned by
the NAND.
This function does not select/unselect the CS line.

Returns 0 on success, a negative error code otherwise.
\index{nand\_exit\_status\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_exit_status_op}\pysiglinewithargsret{int \bfcode{nand\_exit\_status\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}}{}
Exit a STATUS operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\end{description}

\textbf{Description}

This function sends a READ0 command to cancel the effect of the STATUS
command to avoid reading only the status until a new read command is sent.

This function does not select/unselect the CS line.

Returns 0 on success, a negative error code otherwise.
\index{nand\_erase\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_erase_op}\pysiglinewithargsret{int \bfcode{nand\_erase\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, unsigned int\emph{ eraseblock}}{}
Do an erase operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{unsigned int eraseblock}}] \leavevmode
block to erase

\end{description}

\textbf{Description}

This function sends an ERASE command and waits for the NAND to be ready
before returning.
This function does not select/unselect the CS line.

Returns 0 on success, a negative error code otherwise.
\index{nand\_reset\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_reset_op}\pysiglinewithargsret{int \bfcode{nand\_reset\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}}{}
Do a reset operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\end{description}

\textbf{Description}

This function sends a RESET command and waits for the NAND to be ready
before returning.
This function does not select/unselect the CS line.

Returns 0 on success, a negative error code otherwise.
\index{nand\_read\_data\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_data_op}\pysiglinewithargsret{int \bfcode{nand\_read\_data\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, void *\emph{ buf}, unsigned int\emph{ len}, bool\emph{ force\_8bit}}{}
Read data from the NAND

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{void * buf}}] \leavevmode
buffer used to store the data

\item[{\code{unsigned int len}}] \leavevmode
length of the buffer

\item[{\code{bool force\_8bit}}] \leavevmode
force 8-bit bus access

\end{description}

\textbf{Description}

This function does a raw data read on the bus. Usually used after launching
another NAND operation like {\hyperref[driver\string-api/mtdnand:c.nand_read_page_op]{\emph{\code{nand\_read\_page\_op()}}}}.
This function does not select/unselect the CS line.

Returns 0 on success, a negative error code otherwise.
\index{nand\_write\_data\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_write_data_op}\pysiglinewithargsret{int \bfcode{nand\_write\_data\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, const void *\emph{ buf}, unsigned int\emph{ len}, bool\emph{ force\_8bit}}{}
Write data from the NAND

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{const void * buf}}] \leavevmode
buffer containing the data to send on the bus

\item[{\code{unsigned int len}}] \leavevmode
length of the buffer

\item[{\code{bool force\_8bit}}] \leavevmode
force 8-bit bus access

\end{description}

\textbf{Description}

This function does a raw data write on the bus. Usually used after launching
another NAND operation like \code{nand\_write\_page\_begin\_op()}.
This function does not select/unselect the CS line.

Returns 0 on success, a negative error code otherwise.
\index{nand\_op\_parser\_exec\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_op_parser_exec_op}\pysiglinewithargsret{int \bfcode{nand\_op\_parser\_exec\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, const struct {\hyperref[driver\string-api/mtdnand:c.nand_op_parser]{\emph{nand\_op\_parser}}} *\emph{ parser}, const struct {\hyperref[driver\string-api/mtdnand:c.nand_operation]{\emph{nand\_operation}}} *\emph{ op}, bool\emph{ check\_only}}{}
exec\_op parser

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
the NAND chip

\item[{\code{const struct nand\_op\_parser * parser}}] \leavevmode
patterns description provided by the controller driver

\item[{\code{const struct nand\_operation * op}}] \leavevmode
the NAND operation to address

\item[{\code{bool check\_only}}] \leavevmode
when true, the function only checks if \textbf{op} can be handled but
does not execute the operation

\end{description}

\textbf{Description}

Helper function designed to ease integration of NAND controller drivers that
only support a limited set of instruction sequences. The supported sequences
are described in \textbf{parser}, and the framework takes care of splitting \textbf{op} into
multiple sub-operations (if required) and pass them back to the -\textgreater{}:c:func:\emph{exec()}
callback of the matching pattern if \textbf{check\_only} is set to false.

NAND controller drivers should call this function from their own -\textgreater{}:c:func:\emph{exec\_op()}
implementation.

Returns 0 on success, a negative error code otherwise. A failure can be
caused by an unsupported operation (none of the supported patterns is able
to handle the requested operation), or an error returned by one of the
matching pattern-\textgreater{}:c:func:\emph{exec()} hook.
\index{nand\_subop\_get\_addr\_start\_off (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_subop_get_addr_start_off}\pysiglinewithargsret{int \bfcode{nand\_subop\_get\_addr\_start\_off}}{const struct {\hyperref[driver\string-api/mtdnand:c.nand_subop]{\emph{nand\_subop}}} *\emph{ subop}, unsigned int\emph{ instr\_idx}}{}
Get the start offset in an address array

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct nand\_subop * subop}}] \leavevmode
The entire sub-operation

\item[{\code{unsigned int instr\_idx}}] \leavevmode
Index of the instruction inside the sub-operation

\end{description}

\textbf{Description}

During driver development, one could be tempted to directly use the
-\textgreater{}addr.addrs field of address instructions. This is wrong as address
instructions might be split.

Given an address instruction, returns the offset of the first cycle to issue.
\index{nand\_subop\_get\_num\_addr\_cyc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_subop_get_num_addr_cyc}\pysiglinewithargsret{int \bfcode{nand\_subop\_get\_num\_addr\_cyc}}{const struct {\hyperref[driver\string-api/mtdnand:c.nand_subop]{\emph{nand\_subop}}} *\emph{ subop}, unsigned int\emph{ instr\_idx}}{}
Get the remaining address cycles to assert

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct nand\_subop * subop}}] \leavevmode
The entire sub-operation

\item[{\code{unsigned int instr\_idx}}] \leavevmode
Index of the instruction inside the sub-operation

\end{description}

\textbf{Description}

During driver development, one could be tempted to directly use the
-\textgreater{}addr-\textgreater{}naddrs field of a data instruction. This is wrong as instructions
might be split.

Given an address instruction, returns the number of address cycle to issue.
\index{nand\_subop\_get\_data\_start\_off (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_subop_get_data_start_off}\pysiglinewithargsret{int \bfcode{nand\_subop\_get\_data\_start\_off}}{const struct {\hyperref[driver\string-api/mtdnand:c.nand_subop]{\emph{nand\_subop}}} *\emph{ subop}, unsigned int\emph{ instr\_idx}}{}
Get the start offset in a data array

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct nand\_subop * subop}}] \leavevmode
The entire sub-operation

\item[{\code{unsigned int instr\_idx}}] \leavevmode
Index of the instruction inside the sub-operation

\end{description}

\textbf{Description}

During driver development, one could be tempted to directly use the
-\textgreater{}data-\textgreater{}buf.\{in,out\} field of data instructions. This is wrong as data
instructions might be split.

Given a data instruction, returns the offset to start from.
\index{nand\_subop\_get\_data\_len (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_subop_get_data_len}\pysiglinewithargsret{int \bfcode{nand\_subop\_get\_data\_len}}{const struct {\hyperref[driver\string-api/mtdnand:c.nand_subop]{\emph{nand\_subop}}} *\emph{ subop}, unsigned int\emph{ instr\_idx}}{}
Get the number of bytes to retrieve

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct nand\_subop * subop}}] \leavevmode
The entire sub-operation

\item[{\code{unsigned int instr\_idx}}] \leavevmode
Index of the instruction inside the sub-operation

\end{description}

\textbf{Description}

During driver development, one could be tempted to directly use the
-\textgreater{}data-\textgreater{}len field of a data instruction. This is wrong as data instructions
might be split.

Returns the length of the chunk of data to send/receive.
\index{nand\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_reset}\pysiglinewithargsret{int \bfcode{nand\_reset}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, int\emph{ chipnr}}{}
Reset and initialize a NAND device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{int chipnr}}] \leavevmode
Internal die id

\end{description}

\textbf{Description}

Save the timings data structure, then apply SDR timings mode 0 (see
nand\_reset\_data\_interface for details), do the reset operation, and
apply back the previous timings.

Returns 0 on success, a negative error code otherwise.
\index{nand\_check\_erased\_ecc\_chunk (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_check_erased_ecc_chunk}\pysiglinewithargsret{int \bfcode{nand\_check\_erased\_ecc\_chunk}}{void *\emph{ data}, int\emph{ datalen}, void *\emph{ ecc}, int\emph{ ecclen}, void *\emph{ extraoob}, int\emph{ extraooblen}, int\emph{ bitflips\_threshold}}{}
check if an ECC chunk contains (almost) only 0xff data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * data}}] \leavevmode
data buffer to test

\item[{\code{int datalen}}] \leavevmode
data length

\item[{\code{void * ecc}}] \leavevmode
ECC buffer

\item[{\code{int ecclen}}] \leavevmode
ECC length

\item[{\code{void * extraoob}}] \leavevmode
extra OOB buffer

\item[{\code{int extraooblen}}] \leavevmode
extra OOB length

\item[{\code{int bitflips\_threshold}}] \leavevmode
maximum number of bitflips

\end{description}

\textbf{Description}

Check if a data buffer and its associated ECC and OOB data contains only
0xff pattern, which means the underlying region has been erased and is
ready to be programmed.
The bitflips\_threshold specify the maximum number of bitflips before
considering the region as not erased.

\textbf{Note}
\begin{description}
\item[{1/ ECC algorithms are working on pre-defined block sizes which are usually}] \leavevmode
different from the NAND page size. When fixing bitflips, ECC engines will
report the number of errors per chunk, and the NAND core infrastructure
expect you to return the maximum number of bitflips for the whole page.
This is why you should always use this function on a single chunk and
not on the whole page. After checking each chunk you should update your
max\_bitflips value accordingly.

\item[{2/ When checking for bitflips in erased pages you should not only check}] \leavevmode
the payload data but also their associated ECC data, because a user might
have programmed almost all bits to 1 but a few. In this case, we
shouldn't consider the chunk as erased, and checking ECC bytes prevent
this case.

\item[{3/ The extraoob argument is optional, and should be used if some of your OOB}] \leavevmode
data are protected by the ECC engine.
It could also be used if you support subpages and want to attach some
extra OOB data to an ECC chunk.

\end{description}

Returns a positive number of bitflips less than or equal to
bitflips\_threshold, or -ERROR\_CODE for bitflips in excess of the
threshold. In case of success, the passed buffers are filled with 0xff.
\index{nand\_read\_page\_raw (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_page_raw}\pysiglinewithargsret{int \bfcode{nand\_read\_page\_raw}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, uint8\_t *\emph{ buf}, int\emph{ oob\_required}, int\emph{ page}}{}
{[}INTERN{]} read raw page data without ecc

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{uint8\_t * buf}}] \leavevmode
buffer to store read data

\item[{\code{int oob\_required}}] \leavevmode
caller requires OOB data read to chip-\textgreater{}oob\_poi

\item[{\code{int page}}] \leavevmode
page number to read

\end{description}

\textbf{Description}

Not for syndrome calculating ECC controllers, which use a special oob layout.
\index{nand\_read\_oob\_std (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_oob_std}\pysiglinewithargsret{int \bfcode{nand\_read\_oob\_std}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, int\emph{ page}}{}
{[}REPLACEABLE{]} the most common OOB data read function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{int page}}] \leavevmode
page number to read

\end{description}
\index{nand\_read\_oob\_syndrome (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_oob_syndrome}\pysiglinewithargsret{int \bfcode{nand\_read\_oob\_syndrome}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, int\emph{ page}}{}
{[}REPLACEABLE{]} OOB data read function for HW ECC with syndromes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{int page}}] \leavevmode
page number to read

\end{description}
\index{nand\_write\_oob\_std (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_write_oob_std}\pysiglinewithargsret{int \bfcode{nand\_write\_oob\_std}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, int\emph{ page}}{}
{[}REPLACEABLE{]} the most common OOB data write function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{int page}}] \leavevmode
page number to write

\end{description}
\index{nand\_write\_oob\_syndrome (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_write_oob_syndrome}\pysiglinewithargsret{int \bfcode{nand\_write\_oob\_syndrome}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, int\emph{ page}}{}
{[}REPLACEABLE{]} OOB data write function for HW ECC with syndrome - only for large page flash

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{int page}}] \leavevmode
page number to write

\end{description}
\index{nand\_write\_page\_raw (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_write_page_raw}\pysiglinewithargsret{int \bfcode{nand\_write\_page\_raw}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, const uint8\_t *\emph{ buf}, int\emph{ oob\_required}, int\emph{ page}}{}
{[}INTERN{]} raw page write function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{const uint8\_t * buf}}] \leavevmode
data buffer

\item[{\code{int oob\_required}}] \leavevmode
must write chip-\textgreater{}oob\_poi to OOB

\item[{\code{int page}}] \leavevmode
page number to write

\end{description}

\textbf{Description}

Not for syndrome calculating ECC controllers, which use a special oob layout.
\index{nand\_onfi\_get\_set\_features\_notsupp (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_onfi_get_set_features_notsupp}\pysiglinewithargsret{int \bfcode{nand\_onfi\_get\_set\_features\_notsupp}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, int\emph{ addr}, u8 *\emph{ subfeature\_param}}{}
set/get features stub returning -ENOTSUPP

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{int addr}}] \leavevmode
feature address.

\item[{\code{u8 * subfeature\_param}}] \leavevmode
the subfeature parameters, a four bytes array.

\end{description}

\textbf{Description}

Should be used by NAND controller drivers that do not support the SET/GET
FEATURES operations.
\index{nand\_scan\_ident (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_scan_ident}\pysiglinewithargsret{int \bfcode{nand\_scan\_ident}}{struct mtd\_info *\emph{ mtd}, int\emph{ maxchips}, struct {\hyperref[driver\string-api/mtdnand:c.nand_flash_dev]{\emph{nand\_flash\_dev}}} *\emph{ table}}{}
{[}NAND Interface{]} Scan for the NAND device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{int maxchips}}] \leavevmode
number of chips to scan for

\item[{\code{struct nand\_flash\_dev * table}}] \leavevmode
alternative NAND ID table

\end{description}

\textbf{Description}

This is the first phase of the normal {\hyperref[driver\string-api/mtdnand:c.nand_scan]{\emph{\code{nand\_scan()}}}} function. It reads the
flash ID and sets up MTD fields accordingly.
\index{nand\_check\_ecc\_caps (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_check_ecc_caps}\pysiglinewithargsret{int \bfcode{nand\_check\_ecc\_caps}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, const struct {\hyperref[driver\string-api/mtdnand:c.nand_ecc_caps]{\emph{nand\_ecc\_caps}}} *\emph{ caps}, int\emph{ oobavail}}{}
check the sanity of preset ECC settings

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{const struct nand\_ecc\_caps * caps}}] \leavevmode
ECC caps info structure

\item[{\code{int oobavail}}] \leavevmode
OOB size that the ECC engine can use

\end{description}

\textbf{Description}

When ECC step size and strength are already set, check if they are supported
by the controller and the calculated ECC bytes fit within the chip's OOB.
On success, the calculated ECC bytes is set.
\index{nand\_match\_ecc\_req (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_match_ecc_req}\pysiglinewithargsret{int \bfcode{nand\_match\_ecc\_req}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, const struct {\hyperref[driver\string-api/mtdnand:c.nand_ecc_caps]{\emph{nand\_ecc\_caps}}} *\emph{ caps}, int\emph{ oobavail}}{}
meet the chip's requirement with least ECC bytes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{const struct nand\_ecc\_caps * caps}}] \leavevmode
ECC engine caps info structure

\item[{\code{int oobavail}}] \leavevmode
OOB size that the ECC engine can use

\end{description}

\textbf{Description}

If a chip's ECC requirement is provided, try to meet it with the least
number of ECC bytes (i.e. with the largest number of OOB-free bytes).
On success, the chosen ECC settings are set.
\index{nand\_maximize\_ecc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_maximize_ecc}\pysiglinewithargsret{int \bfcode{nand\_maximize\_ecc}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, const struct {\hyperref[driver\string-api/mtdnand:c.nand_ecc_caps]{\emph{nand\_ecc\_caps}}} *\emph{ caps}, int\emph{ oobavail}}{}
choose the max ECC strength available

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{const struct nand\_ecc\_caps * caps}}] \leavevmode
ECC engine caps info structure

\item[{\code{int oobavail}}] \leavevmode
OOB size that the ECC engine can use

\end{description}

\textbf{Description}

Choose the max ECC strength that is supported on the controller, and can fit
within the chip's OOB.  On success, the chosen ECC settings are set.
\index{nand\_scan\_tail (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_scan_tail}\pysiglinewithargsret{int \bfcode{nand\_scan\_tail}}{struct mtd\_info *\emph{ mtd}}{}
{[}NAND Interface{]} Scan for the NAND device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\end{description}

\textbf{Description}

This is the second phase of the normal {\hyperref[driver\string-api/mtdnand:c.nand_scan]{\emph{\code{nand\_scan()}}}} function. It fills out
all the uninitialized function pointers with the defaults and scans for a
bad block table if appropriate.
\index{nand\_scan (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_scan}\pysiglinewithargsret{int \bfcode{nand\_scan}}{struct mtd\_info *\emph{ mtd}, int\emph{ maxchips}}{}
{[}NAND Interface{]} Scan for the NAND device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{int maxchips}}] \leavevmode
number of chips to scan for

\end{description}

\textbf{Description}

This fills out all the uninitialized function pointers with the defaults.
The flash ID is read and the mtd/chip structures are filled with the
appropriate values.
\index{nand\_cleanup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_cleanup}\pysiglinewithargsret{void \bfcode{nand\_cleanup}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}}{}
{[}NAND Interface{]} Free resources held by the NAND device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
NAND chip object

\end{description}
\index{nand\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_release}\pysiglinewithargsret{void \bfcode{nand\_release}}{struct mtd\_info *\emph{ mtd}}{}
{[}NAND Interface{]} Unregister the MTD device and free resources held by the NAND device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\end{description}
\index{\_\_nand\_calculate\_ecc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.__nand_calculate_ecc}\pysiglinewithargsret{void \bfcode{\_\_nand\_calculate\_ecc}}{const unsigned char *\emph{ buf}, unsigned int\emph{ eccsize}, unsigned char *\emph{ code}}{}
{[}NAND Interface{]} Calculate 3-byte ECC for 256/512-byte block

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const unsigned char * buf}}] \leavevmode
input buffer with raw data

\item[{\code{unsigned int eccsize}}] \leavevmode
data bytes per ECC step (256 or 512)

\item[{\code{unsigned char * code}}] \leavevmode
output buffer with ECC

\end{description}
\index{nand\_calculate\_ecc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_calculate_ecc}\pysiglinewithargsret{int \bfcode{nand\_calculate\_ecc}}{struct mtd\_info *\emph{ mtd}, const unsigned char *\emph{ buf}, unsigned char *\emph{ code}}{}
{[}NAND Interface{]} Calculate 3-byte ECC for 256/512-byte block

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD block structure

\item[{\code{const unsigned char * buf}}] \leavevmode
input buffer with raw data

\item[{\code{unsigned char * code}}] \leavevmode
output buffer with ECC

\end{description}
\index{\_\_nand\_correct\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.__nand_correct_data}\pysiglinewithargsret{int \bfcode{\_\_nand\_correct\_data}}{unsigned char *\emph{ buf}, unsigned char *\emph{ read\_ecc}, unsigned char *\emph{ calc\_ecc}, unsigned int\emph{ eccsize}}{}
{[}NAND Interface{]} Detect and correct bit error(s)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned char * buf}}] \leavevmode
raw data read from the chip

\item[{\code{unsigned char * read\_ecc}}] \leavevmode
ECC from the chip

\item[{\code{unsigned char * calc\_ecc}}] \leavevmode
the ECC calculated from raw data

\item[{\code{unsigned int eccsize}}] \leavevmode
data bytes per ECC step (256 or 512)

\end{description}

\textbf{Description}

Detect and correct a 1 bit error for eccsize byte block
\index{nand\_correct\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_correct_data}\pysiglinewithargsret{int \bfcode{nand\_correct\_data}}{struct mtd\_info *\emph{ mtd}, unsigned char *\emph{ buf}, unsigned char *\emph{ read\_ecc}, unsigned char *\emph{ calc\_ecc}}{}
{[}NAND Interface{]} Detect and correct bit error(s)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD block structure

\item[{\code{unsigned char * buf}}] \leavevmode
raw data read from the chip

\item[{\code{unsigned char * read\_ecc}}] \leavevmode
ECC from the chip

\item[{\code{unsigned char * calc\_ecc}}] \leavevmode
the ECC calculated from raw data

\end{description}

\textbf{Description}

Detect and correct a 1 bit error for 256/512 byte block


\section{Internal Functions Provided}
\label{driver-api/mtdnand:internal-functions-provided}
This chapter contains the autogenerated documentation of the NAND driver
internal functions. Each function has a short description which is
marked with an {[}XXX{]} identifier. See the chapter ``Documentation hints''
for an explanation. The functions marked with {[}DEFAULT{]} might be
relevant for a board driver developer.
\index{nand\_release\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_release_device}\pysiglinewithargsret{void \bfcode{nand\_release\_device}}{struct mtd\_info *\emph{ mtd}}{}
{[}GENERIC{]} release chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\end{description}

\textbf{Description}

Release chip lock and wake up anyone waiting on the device.
\index{nand\_read\_byte (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_byte}\pysiglinewithargsret{uint8\_t \bfcode{nand\_read\_byte}}{struct mtd\_info *\emph{ mtd}}{}
{[}DEFAULT{]} read one byte from the chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\end{description}

\textbf{Description}

Default read function for 8bit buswidth
\index{nand\_read\_byte16 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_byte16}\pysiglinewithargsret{uint8\_t \bfcode{nand\_read\_byte16}}{struct mtd\_info *\emph{ mtd}}{}
{[}DEFAULT{]} read one byte endianness aware from the chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\end{description}

\textbf{Description}

Default read function for 16bit buswidth with endianness conversion.
\index{nand\_read\_word (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_word}\pysiglinewithargsret{u16 \bfcode{nand\_read\_word}}{struct mtd\_info *\emph{ mtd}}{}
{[}DEFAULT{]} read one word from the chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\end{description}

\textbf{Description}

Default read function for 16bit buswidth without endianness conversion.
\index{nand\_select\_chip (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_select_chip}\pysiglinewithargsret{void \bfcode{nand\_select\_chip}}{struct mtd\_info *\emph{ mtd}, int\emph{ chipnr}}{}
{[}DEFAULT{]} control CE line

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{int chipnr}}] \leavevmode
chipnumber to select, -1 for deselect

\end{description}

\textbf{Description}

Default select function for 1 chip devices.
\index{nand\_write\_byte (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_write_byte}\pysiglinewithargsret{void \bfcode{nand\_write\_byte}}{struct mtd\_info *\emph{ mtd}, uint8\_t\emph{ byte}}{}
{[}DEFAULT{]} write single byte to chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{uint8\_t byte}}] \leavevmode
value to write

\end{description}

\textbf{Description}

Default function to write a byte to I/O{[}7:0{]}
\index{nand\_write\_byte16 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_write_byte16}\pysiglinewithargsret{void \bfcode{nand\_write\_byte16}}{struct mtd\_info *\emph{ mtd}, uint8\_t\emph{ byte}}{}
{[}DEFAULT{]} write single byte to a chip with width 16

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{uint8\_t byte}}] \leavevmode
value to write

\end{description}

\textbf{Description}

Default function to write a byte to I/O{[}7:0{]} on a 16-bit wide chip.
\index{nand\_write\_buf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_write_buf}\pysiglinewithargsret{void \bfcode{nand\_write\_buf}}{struct mtd\_info *\emph{ mtd}, const uint8\_t *\emph{ buf}, int\emph{ len}}{}
{[}DEFAULT{]} write buffer to chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{const uint8\_t * buf}}] \leavevmode
data buffer

\item[{\code{int len}}] \leavevmode
number of bytes to write

\end{description}

\textbf{Description}

Default write function for 8bit buswidth.
\index{nand\_read\_buf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_buf}\pysiglinewithargsret{void \bfcode{nand\_read\_buf}}{struct mtd\_info *\emph{ mtd}, uint8\_t *\emph{ buf}, int\emph{ len}}{}
{[}DEFAULT{]} read chip data into buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{uint8\_t * buf}}] \leavevmode
buffer to store date

\item[{\code{int len}}] \leavevmode
number of bytes to read

\end{description}

\textbf{Description}

Default read function for 8bit buswidth.
\index{nand\_write\_buf16 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_write_buf16}\pysiglinewithargsret{void \bfcode{nand\_write\_buf16}}{struct mtd\_info *\emph{ mtd}, const uint8\_t *\emph{ buf}, int\emph{ len}}{}
{[}DEFAULT{]} write buffer to chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{const uint8\_t * buf}}] \leavevmode
data buffer

\item[{\code{int len}}] \leavevmode
number of bytes to write

\end{description}

\textbf{Description}

Default write function for 16bit buswidth.
\index{nand\_read\_buf16 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_buf16}\pysiglinewithargsret{void \bfcode{nand\_read\_buf16}}{struct mtd\_info *\emph{ mtd}, uint8\_t *\emph{ buf}, int\emph{ len}}{}
{[}DEFAULT{]} read chip data into buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{uint8\_t * buf}}] \leavevmode
buffer to store date

\item[{\code{int len}}] \leavevmode
number of bytes to read

\end{description}

\textbf{Description}

Default read function for 16bit buswidth.
\index{nand\_block\_bad (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_block_bad}\pysiglinewithargsret{int \bfcode{nand\_block\_bad}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ ofs}}{}
{[}DEFAULT{]} Read bad block marker from the chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t ofs}}] \leavevmode
offset from device start

\end{description}

\textbf{Description}

Check, if the block is bad.
\index{nand\_default\_block\_markbad (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_default_block_markbad}\pysiglinewithargsret{int \bfcode{nand\_default\_block\_markbad}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ ofs}}{}
{[}DEFAULT{]} mark a block bad via bad block marker

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t ofs}}] \leavevmode
offset from device start

\end{description}

\textbf{Description}

This is the default implementation, which can be overridden by a hardware
specific driver. It provides the details for writing a bad block marker to a
block.
\index{nand\_block\_markbad\_lowlevel (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_block_markbad_lowlevel}\pysiglinewithargsret{int \bfcode{nand\_block\_markbad\_lowlevel}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ ofs}}{}
mark a block bad

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t ofs}}] \leavevmode
offset from device start

\end{description}

\textbf{Description}

This function performs the generic NAND bad block marking steps (i.e., bad
block table(s) and/or marker(s)). We only allow the hardware driver to
specify how to write bad block markers to OOB (chip-\textgreater{}block\_markbad).

We try operations in the following order:
\begin{enumerate}
\item {} 
erase the affected block, to allow OOB marker to be written cleanly

\item {} 
write bad block marker to OOB area of affected block (unless flag
NAND\_BBT\_NO\_OOB\_BBM is present)

\item {} 
update the BBT

\end{enumerate}

Note that we retain the first error encountered in (2) or (3), finish the
procedures, and dump the error in the end.
\index{nand\_check\_wp (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_check_wp}\pysiglinewithargsret{int \bfcode{nand\_check\_wp}}{struct mtd\_info *\emph{ mtd}}{}
{[}GENERIC{]} check if the chip is write protected

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\end{description}

\textbf{Description}

Check, if the device is write protected. The function expects, that the
device is already selected.
\index{nand\_block\_isreserved (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_block_isreserved}\pysiglinewithargsret{int \bfcode{nand\_block\_isreserved}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ ofs}}{}
{[}GENERIC{]} Check if a block is marked reserved.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t ofs}}] \leavevmode
offset from device start

\end{description}

\textbf{Description}

Check if the block is marked as reserved.
\index{nand\_block\_checkbad (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_block_checkbad}\pysiglinewithargsret{int \bfcode{nand\_block\_checkbad}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ ofs}, int\emph{ allowbbt}}{}
{[}GENERIC{]} Check if a block is marked bad

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t ofs}}] \leavevmode
offset from device start

\item[{\code{int allowbbt}}] \leavevmode
1, if its allowed to access the bbt area

\end{description}

\textbf{Description}

Check, if the block is bad. Either by reading the bad block table or
calling of the scan function.
\index{panic\_nand\_wait\_ready (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.panic_nand_wait_ready}\pysiglinewithargsret{void \bfcode{panic\_nand\_wait\_ready}}{struct mtd\_info *\emph{ mtd}, unsigned long\emph{ timeo}}{}
{[}GENERIC{]} Wait for the ready pin after commands.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{unsigned long timeo}}] \leavevmode
Timeout

\end{description}

\textbf{Description}

Helper function for nand\_wait\_ready used when needing to wait in interrupt
context.
\index{nand\_wait\_status\_ready (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_wait_status_ready}\pysiglinewithargsret{void \bfcode{nand\_wait\_status\_ready}}{struct mtd\_info *\emph{ mtd}, unsigned long\emph{ timeo}}{}
{[}GENERIC{]} Wait for the ready status after commands.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{unsigned long timeo}}] \leavevmode
Timeout in ms

\end{description}

\textbf{Description}

Wait for status ready (i.e. command done) or timeout.
\index{nand\_command (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_command}\pysiglinewithargsret{void \bfcode{nand\_command}}{struct mtd\_info *\emph{ mtd}, unsigned int\emph{ command}, int\emph{ column}, int\emph{ page\_addr}}{}
{[}DEFAULT{]} Send command to NAND device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{unsigned int command}}] \leavevmode
the command to be sent

\item[{\code{int column}}] \leavevmode
the column address for this command, -1 if none

\item[{\code{int page\_addr}}] \leavevmode
the page address for this command, -1 if none

\end{description}

\textbf{Description}

Send command to NAND device. This function is used for small page devices
(512 Bytes per page).
\index{nand\_command\_lp (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_command_lp}\pysiglinewithargsret{void \bfcode{nand\_command\_lp}}{struct mtd\_info *\emph{ mtd}, unsigned int\emph{ command}, int\emph{ column}, int\emph{ page\_addr}}{}
{[}DEFAULT{]} Send command to NAND large page device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{unsigned int command}}] \leavevmode
the command to be sent

\item[{\code{int column}}] \leavevmode
the column address for this command, -1 if none

\item[{\code{int page\_addr}}] \leavevmode
the page address for this command, -1 if none

\end{description}

\textbf{Description}

Send command to NAND device. This is the version for the new large page
devices. We don't have the separate regions as we have in the small page
devices. We must emulate NAND\_CMD\_READOOB to keep the code compatible.
\index{panic\_nand\_get\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.panic_nand_get_device}\pysiglinewithargsret{void \bfcode{panic\_nand\_get\_device}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, struct mtd\_info *\emph{ mtd}, int\emph{ new\_state}}{}
{[}GENERIC{]} Get chip for selected access

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
the nand chip descriptor

\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{int new\_state}}] \leavevmode
the state which is requested

\end{description}

\textbf{Description}

Used when in panic, no locks are taken.
\index{nand\_get\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_get_device}\pysiglinewithargsret{int \bfcode{nand\_get\_device}}{struct mtd\_info *\emph{ mtd}, int\emph{ new\_state}}{}
{[}GENERIC{]} Get chip for selected access

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{int new\_state}}] \leavevmode
the state which is requested

\end{description}

\textbf{Description}

Get the device and lock it for exclusive access
\index{panic\_nand\_wait (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.panic_nand_wait}\pysiglinewithargsret{void \bfcode{panic\_nand\_wait}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, unsigned long\emph{ timeo}}{}
{[}GENERIC{]} wait until the command is done

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
NAND chip structure

\item[{\code{unsigned long timeo}}] \leavevmode
timeout

\end{description}

\textbf{Description}

Wait for command done. This is a helper function for nand\_wait used when
we are in interrupt context. May happen when in panic and trying to write
an oops through mtdoops.
\index{nand\_wait (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_wait}\pysiglinewithargsret{int \bfcode{nand\_wait}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}}{}
{[}DEFAULT{]} wait until the command is done

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
NAND chip structure

\end{description}

\textbf{Description}

Wait for command done. This applies to erase and program only.
\index{nand\_reset\_data\_interface (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_reset_data_interface}\pysiglinewithargsret{int \bfcode{nand\_reset\_data\_interface}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, int\emph{ chipnr}}{}
Reset data interface and timings

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{int chipnr}}] \leavevmode
Internal die id

\end{description}

\textbf{Description}

Reset the Data interface and timings to ONFI mode 0.

Returns 0 for success or negative error code otherwise.
\index{nand\_setup\_data\_interface (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_setup_data_interface}\pysiglinewithargsret{int \bfcode{nand\_setup\_data\_interface}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, int\emph{ chipnr}}{}
Setup the best data interface and timings

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{int chipnr}}] \leavevmode
Internal die id

\end{description}

\textbf{Description}

Find and configure the best data interface and NAND timings supported by
the chip and the driver.
First tries to retrieve supported timing modes from ONFI information,
and if the NAND chip does not support ONFI, relies on the
-\textgreater{}onfi\_timing\_mode\_default specified in the nand\_ids table.

Returns 0 for success or negative error code otherwise.
\index{nand\_init\_data\_interface (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_init_data_interface}\pysiglinewithargsret{int \bfcode{nand\_init\_data\_interface}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}}{}
find the best data interface and timings

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\end{description}

\textbf{Description}

Find the best data interface and NAND timings supported by the chip
and the driver.
First tries to retrieve supported timing modes from ONFI information,
and if the NAND chip does not support ONFI, relies on the
-\textgreater{}onfi\_timing\_mode\_default specified in the nand\_ids table. After this
function nand\_chip-\textgreater{}data\_interface is initialized with the best timing mode
available.

Returns 0 for success or negative error code otherwise.
\index{nand\_fill\_column\_cycles (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_fill_column_cycles}\pysiglinewithargsret{int \bfcode{nand\_fill\_column\_cycles}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, u8 *\emph{ addrs}, unsigned int\emph{ offset\_in\_page}}{}
fill the column cycles of an address

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{u8 * addrs}}] \leavevmode
Array of address cycles to fill

\item[{\code{unsigned int offset\_in\_page}}] \leavevmode
The offset in the page

\end{description}

\textbf{Description}

Fills the first or the first two bytes of the \textbf{addrs} field depending
on the NAND bus width and the page size.

Returns the number of cycles needed to encode the column, or a negative
error code in case one of the arguments is invalid.
\index{nand\_read\_param\_page\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_param_page_op}\pysiglinewithargsret{int \bfcode{nand\_read\_param\_page\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, u8\emph{ page}, void *\emph{ buf}, unsigned int\emph{ len}}{}
Do a READ PARAMETER PAGE operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{u8 page}}] \leavevmode
parameter page to read

\item[{\code{void * buf}}] \leavevmode
buffer used to store the data

\item[{\code{unsigned int len}}] \leavevmode
length of the buffer

\end{description}

\textbf{Description}

This function issues a READ PARAMETER PAGE operation.
This function does not select/unselect the CS line.

Returns 0 on success, a negative error code otherwise.
\index{nand\_set\_features\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_set_features_op}\pysiglinewithargsret{int \bfcode{nand\_set\_features\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, u8\emph{ feature}, const void *\emph{ data}}{}
Do a SET FEATURES operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{u8 feature}}] \leavevmode
feature id

\item[{\code{const void * data}}] \leavevmode
4 bytes of data

\end{description}

\textbf{Description}

This function sends a SET FEATURES command and waits for the NAND to be
ready before returning.
This function does not select/unselect the CS line.

Returns 0 on success, a negative error code otherwise.
\index{nand\_get\_features\_op (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_get_features_op}\pysiglinewithargsret{int \bfcode{nand\_get\_features\_op}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, u8\emph{ feature}, void *\emph{ data}}{}
Do a GET FEATURES operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * chip}}] \leavevmode
The NAND chip

\item[{\code{u8 feature}}] \leavevmode
feature id

\item[{\code{void * data}}] \leavevmode
4 bytes of data

\end{description}

\textbf{Description}

This function sends a GET FEATURES command and waits for the NAND to be
ready before returning.
This function does not select/unselect the CS line.

Returns 0 on success, a negative error code otherwise.
\index{nand\_op\_parser\_ctx (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_op_parser_ctx}\pysigline{struct \bfcode{nand\_op\_parser\_ctx}}
Context used by the parser

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct nand\PYGZus{}op\PYGZus{}parser\PYGZus{}ctx \PYGZob{}
  const struct nand\PYGZus{}op\PYGZus{}instr *instrs;
  unsigned int ninstrs;
  struct nand\PYGZus{}subop subop;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{instrs}}] \leavevmode
array of all the instructions that must be addressed

\item[{\code{ninstrs}}] \leavevmode
length of the \textbf{instrs} array

\item[{\code{subop}}] \leavevmode
Sub-operation to be passed to the NAND controller

\end{description}

\textbf{Description}

This structure is used by the core to split NAND operations into
sub-operations that can be handled by the NAND controller.
\index{nand\_op\_parser\_must\_split\_instr (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_op_parser_must_split_instr}\pysiglinewithargsret{bool \bfcode{nand\_op\_parser\_must\_split\_instr}}{const struct {\hyperref[driver\string-api/mtdnand:c.nand_op_parser_pattern_elem]{\emph{nand\_op\_parser\_pattern\_elem}}} *\emph{ pat}, const struct {\hyperref[driver\string-api/mtdnand:c.nand_op_instr]{\emph{nand\_op\_instr}}} *\emph{ instr}, unsigned int *\emph{ start\_offset}}{}
Checks if an instruction must be split

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct nand\_op\_parser\_pattern\_elem * pat}}] \leavevmode
the parser pattern element that matches \textbf{instr}

\item[{\code{const struct nand\_op\_instr * instr}}] \leavevmode
pointer to the instruction to check

\item[{\code{unsigned int * start\_offset}}] \leavevmode
this is an in/out parameter. If \textbf{instr} has already been
split, then \textbf{start\_offset} is the offset from which to start
(either an address cycle or an offset in the data buffer).
Conversely, if the function returns true (ie. instr must be
split), this parameter is updated to point to the first
data/address cycle that has not been taken care of.

\end{description}

\textbf{Description}

Some NAND controllers are limited and cannot send X address cycles with a
unique operation, or cannot read/write more than Y bytes at the same time.
In this case, split the instruction that does not fit in a single
controller-operation into two or more chunks.

Returns true if the instruction must be split, false otherwise.
The \textbf{start\_offset} parameter is also updated to the offset at which the next
bundle of instruction must start (if an address or a data instruction).
\index{nand\_op\_parser\_match\_pat (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_op_parser_match_pat}\pysiglinewithargsret{bool \bfcode{nand\_op\_parser\_match\_pat}}{const struct {\hyperref[driver\string-api/mtdnand:c.nand_op_parser_pattern]{\emph{nand\_op\_parser\_pattern}}} *\emph{ pat}, struct {\hyperref[driver\string-api/mtdnand:c.nand_op_parser_ctx]{\emph{nand\_op\_parser\_ctx}}} *\emph{ ctx}}{}
Checks if a pattern matches the instructions remaining in the parser context

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct nand\_op\_parser\_pattern * pat}}] \leavevmode
the pattern to test

\item[{\code{struct nand\_op\_parser\_ctx * ctx}}] \leavevmode
the parser context structure to match with the pattern \textbf{pat}

\end{description}

\textbf{Description}

Check if \textbf{pat} matches the set or a sub-set of instructions remaining in \textbf{ctx}.
Returns true if this is the case, false ortherwise. When true is returned,
\textbf{ctx}-\textgreater{}subop is updated with the set of instructions to be passed to the
controller driver.
\index{nand\_check\_erased\_buf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_check_erased_buf}\pysiglinewithargsret{int \bfcode{nand\_check\_erased\_buf}}{void *\emph{ buf}, int\emph{ len}, int\emph{ bitflips\_threshold}}{}
check if a buffer contains (almost) only 0xff data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * buf}}] \leavevmode
buffer to test

\item[{\code{int len}}] \leavevmode
buffer length

\item[{\code{int bitflips\_threshold}}] \leavevmode
maximum number of bitflips

\end{description}

\textbf{Description}

Check if a buffer contains only 0xff, which means the underlying region
has been erased and is ready to be programmed.
The bitflips\_threshold specify the maximum number of bitflips before
considering the region is not erased.

\textbf{Note}

The logic of this function has been extracted from the memweight
implementation, except that nand\_check\_erased\_buf function exit before
testing the whole buffer if the number of bitflips exceed the
bitflips\_threshold value.

Returns a positive number of bitflips less than or equal to
bitflips\_threshold, or -ERROR\_CODE for bitflips in excess of the
threshold.
\index{nand\_read\_page\_raw\_syndrome (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_page_raw_syndrome}\pysiglinewithargsret{int \bfcode{nand\_read\_page\_raw\_syndrome}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, uint8\_t *\emph{ buf}, int\emph{ oob\_required}, int\emph{ page}}{}
{[}INTERN{]} read raw page data without ecc

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{uint8\_t * buf}}] \leavevmode
buffer to store read data

\item[{\code{int oob\_required}}] \leavevmode
caller requires OOB data read to chip-\textgreater{}oob\_poi

\item[{\code{int page}}] \leavevmode
page number to read

\end{description}

\textbf{Description}

We need a special oob layout and handling even when OOB isn't used.
\index{nand\_read\_page\_swecc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_page_swecc}\pysiglinewithargsret{int \bfcode{nand\_read\_page\_swecc}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, uint8\_t *\emph{ buf}, int\emph{ oob\_required}, int\emph{ page}}{}
{[}REPLACEABLE{]} software ECC based page read function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{uint8\_t * buf}}] \leavevmode
buffer to store read data

\item[{\code{int oob\_required}}] \leavevmode
caller requires OOB data read to chip-\textgreater{}oob\_poi

\item[{\code{int page}}] \leavevmode
page number to read

\end{description}
\index{nand\_read\_subpage (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_subpage}\pysiglinewithargsret{int \bfcode{nand\_read\_subpage}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, uint32\_t\emph{ data\_offs}, uint32\_t\emph{ readlen}, uint8\_t *\emph{ bufpoi}, int\emph{ page}}{}
{[}REPLACEABLE{]} ECC based sub-page read function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{uint32\_t data\_offs}}] \leavevmode
offset of requested data within the page

\item[{\code{uint32\_t readlen}}] \leavevmode
data length

\item[{\code{uint8\_t * bufpoi}}] \leavevmode
buffer to store read data

\item[{\code{int page}}] \leavevmode
page number to read

\end{description}
\index{nand\_read\_page\_hwecc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_page_hwecc}\pysiglinewithargsret{int \bfcode{nand\_read\_page\_hwecc}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, uint8\_t *\emph{ buf}, int\emph{ oob\_required}, int\emph{ page}}{}
{[}REPLACEABLE{]} hardware ECC based page read function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{uint8\_t * buf}}] \leavevmode
buffer to store read data

\item[{\code{int oob\_required}}] \leavevmode
caller requires OOB data read to chip-\textgreater{}oob\_poi

\item[{\code{int page}}] \leavevmode
page number to read

\end{description}

\textbf{Description}

Not for syndrome calculating ECC controllers which need a special oob layout.
\index{nand\_read\_page\_hwecc\_oob\_first (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_page_hwecc_oob_first}\pysiglinewithargsret{int \bfcode{nand\_read\_page\_hwecc\_oob\_first}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, uint8\_t *\emph{ buf}, int\emph{ oob\_required}, int\emph{ page}}{}
{[}REPLACEABLE{]} hw ecc, read oob first

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{uint8\_t * buf}}] \leavevmode
buffer to store read data

\item[{\code{int oob\_required}}] \leavevmode
caller requires OOB data read to chip-\textgreater{}oob\_poi

\item[{\code{int page}}] \leavevmode
page number to read

\end{description}

\textbf{Description}

Hardware ECC for large page chips, require OOB to be read first. For this
ECC mode, the write\_page method is re-used from ECC\_HW. These methods
read/write ECC from the OOB area, unlike the ECC\_HW\_SYNDROME support with
multiple ECC steps, follows the ``infix ECC'' scheme and reads/writes ECC from
the data area, by overwriting the NAND manufacturer bad block markings.
\index{nand\_read\_page\_syndrome (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_page_syndrome}\pysiglinewithargsret{int \bfcode{nand\_read\_page\_syndrome}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, uint8\_t *\emph{ buf}, int\emph{ oob\_required}, int\emph{ page}}{}
{[}REPLACEABLE{]} hardware ECC syndrome based page read

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{uint8\_t * buf}}] \leavevmode
buffer to store read data

\item[{\code{int oob\_required}}] \leavevmode
caller requires OOB data read to chip-\textgreater{}oob\_poi

\item[{\code{int page}}] \leavevmode
page number to read

\end{description}

\textbf{Description}

The hw generator calculates the error syndrome automatically. Therefore we
need a special oob layout and handling.
\index{nand\_transfer\_oob (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_transfer_oob}\pysiglinewithargsret{uint8\_t * \bfcode{nand\_transfer\_oob}}{struct mtd\_info *\emph{ mtd}, uint8\_t *\emph{ oob}, struct mtd\_oob\_ops *\emph{ ops}, size\_t\emph{ len}}{}
{[}INTERN{]} Transfer oob to client buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{uint8\_t * oob}}] \leavevmode
oob destination address

\item[{\code{struct mtd\_oob\_ops * ops}}] \leavevmode
oob ops structure

\item[{\code{size\_t len}}] \leavevmode
size of oob to transfer

\end{description}
\index{nand\_setup\_read\_retry (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_setup_read_retry}\pysiglinewithargsret{int \bfcode{nand\_setup\_read\_retry}}{struct mtd\_info *\emph{ mtd}, int\emph{ retry\_mode}}{}
{[}INTERN{]} Set the READ RETRY mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{int retry\_mode}}] \leavevmode
the retry mode to use

\end{description}

\textbf{Description}

Some vendors supply a special command to shift the Vt threshold, to be used
when there are too many bitflips in a page (i.e., ECC error). After setting
a new threshold, the host should retry reading the page.
\index{nand\_do\_read\_ops (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_do_read_ops}\pysiglinewithargsret{int \bfcode{nand\_do\_read\_ops}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ from}, struct mtd\_oob\_ops *\emph{ ops}}{}
{[}INTERN{]} Read data with ECC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t from}}] \leavevmode
offset to read from

\item[{\code{struct mtd\_oob\_ops * ops}}] \leavevmode
oob ops structure

\end{description}

\textbf{Description}

Internal function. Called with chip held.
\index{nand\_do\_read\_oob (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_do_read_oob}\pysiglinewithargsret{int \bfcode{nand\_do\_read\_oob}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ from}, struct mtd\_oob\_ops *\emph{ ops}}{}
{[}INTERN{]} NAND read out-of-band

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t from}}] \leavevmode
offset to read from

\item[{\code{struct mtd\_oob\_ops * ops}}] \leavevmode
oob operations description structure

\end{description}

\textbf{Description}

NAND read out-of-band data from the spare area.
\index{nand\_read\_oob (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_read_oob}\pysiglinewithargsret{int \bfcode{nand\_read\_oob}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ from}, struct mtd\_oob\_ops *\emph{ ops}}{}
{[}MTD Interface{]} NAND read data and/or out-of-band

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t from}}] \leavevmode
offset to read from

\item[{\code{struct mtd\_oob\_ops * ops}}] \leavevmode
oob operation description structure

\end{description}

\textbf{Description}

NAND read data and/or out-of-band data.
\index{nand\_write\_page\_raw\_syndrome (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_write_page_raw_syndrome}\pysiglinewithargsret{int \bfcode{nand\_write\_page\_raw\_syndrome}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, const uint8\_t *\emph{ buf}, int\emph{ oob\_required}, int\emph{ page}}{}
{[}INTERN{]} raw page write function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{const uint8\_t * buf}}] \leavevmode
data buffer

\item[{\code{int oob\_required}}] \leavevmode
must write chip-\textgreater{}oob\_poi to OOB

\item[{\code{int page}}] \leavevmode
page number to write

\end{description}

\textbf{Description}

We need a special oob layout and handling even when ECC isn't checked.
\index{nand\_write\_page\_swecc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_write_page_swecc}\pysiglinewithargsret{int \bfcode{nand\_write\_page\_swecc}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, const uint8\_t *\emph{ buf}, int\emph{ oob\_required}, int\emph{ page}}{}
{[}REPLACEABLE{]} software ECC based page write function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{const uint8\_t * buf}}] \leavevmode
data buffer

\item[{\code{int oob\_required}}] \leavevmode
must write chip-\textgreater{}oob\_poi to OOB

\item[{\code{int page}}] \leavevmode
page number to write

\end{description}
\index{nand\_write\_page\_hwecc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_write_page_hwecc}\pysiglinewithargsret{int \bfcode{nand\_write\_page\_hwecc}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, const uint8\_t *\emph{ buf}, int\emph{ oob\_required}, int\emph{ page}}{}
{[}REPLACEABLE{]} hardware ECC based page write function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{const uint8\_t * buf}}] \leavevmode
data buffer

\item[{\code{int oob\_required}}] \leavevmode
must write chip-\textgreater{}oob\_poi to OOB

\item[{\code{int page}}] \leavevmode
page number to write

\end{description}
\index{nand\_write\_subpage\_hwecc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_write_subpage_hwecc}\pysiglinewithargsret{int \bfcode{nand\_write\_subpage\_hwecc}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, uint32\_t\emph{ offset}, uint32\_t\emph{ data\_len}, const uint8\_t *\emph{ buf}, int\emph{ oob\_required}, int\emph{ page}}{}
{[}REPLACEABLE{]} hardware ECC based subpage write

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{uint32\_t offset}}] \leavevmode
column address of subpage within the page

\item[{\code{uint32\_t data\_len}}] \leavevmode
data length

\item[{\code{const uint8\_t * buf}}] \leavevmode
data buffer

\item[{\code{int oob\_required}}] \leavevmode
must write chip-\textgreater{}oob\_poi to OOB

\item[{\code{int page}}] \leavevmode
page number to write

\end{description}
\index{nand\_write\_page\_syndrome (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_write_page_syndrome}\pysiglinewithargsret{int \bfcode{nand\_write\_page\_syndrome}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, const uint8\_t *\emph{ buf}, int\emph{ oob\_required}, int\emph{ page}}{}
{[}REPLACEABLE{]} hardware ECC syndrome based page write

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
mtd info structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{const uint8\_t * buf}}] \leavevmode
data buffer

\item[{\code{int oob\_required}}] \leavevmode
must write chip-\textgreater{}oob\_poi to OOB

\item[{\code{int page}}] \leavevmode
page number to write

\end{description}

\textbf{Description}

The hw generator calculates the error syndrome automatically. Therefore we
need a special oob layout and handling.
\index{nand\_write\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_write_page}\pysiglinewithargsret{int \bfcode{nand\_write\_page}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, uint32\_t\emph{ offset}, int\emph{ data\_len}, const uint8\_t *\emph{ buf}, int\emph{ oob\_required}, int\emph{ page}, int\emph{ raw}}{}
write one page

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
NAND chip descriptor

\item[{\code{uint32\_t offset}}] \leavevmode
address offset within the page

\item[{\code{int data\_len}}] \leavevmode
length of actual data to be written

\item[{\code{const uint8\_t * buf}}] \leavevmode
the data to write

\item[{\code{int oob\_required}}] \leavevmode
must write chip-\textgreater{}oob\_poi to OOB

\item[{\code{int page}}] \leavevmode
page number to write

\item[{\code{int raw}}] \leavevmode
use \_raw version of write\_page

\end{description}
\index{nand\_fill\_oob (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_fill_oob}\pysiglinewithargsret{uint8\_t * \bfcode{nand\_fill\_oob}}{struct mtd\_info *\emph{ mtd}, uint8\_t *\emph{ oob}, size\_t\emph{ len}, struct mtd\_oob\_ops *\emph{ ops}}{}
{[}INTERN{]} Transfer client buffer to oob

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{uint8\_t * oob}}] \leavevmode
oob data buffer

\item[{\code{size\_t len}}] \leavevmode
oob data write length

\item[{\code{struct mtd\_oob\_ops * ops}}] \leavevmode
oob ops structure

\end{description}
\index{nand\_do\_write\_ops (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_do_write_ops}\pysiglinewithargsret{int \bfcode{nand\_do\_write\_ops}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ to}, struct mtd\_oob\_ops *\emph{ ops}}{}
{[}INTERN{]} NAND write with ECC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t to}}] \leavevmode
offset to write to

\item[{\code{struct mtd\_oob\_ops * ops}}] \leavevmode
oob operations description structure

\end{description}

\textbf{Description}

NAND write with ECC.
\index{panic\_nand\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.panic_nand_write}\pysiglinewithargsret{int \bfcode{panic\_nand\_write}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ to}, size\_t\emph{ len}, size\_t *\emph{ retlen}, const uint8\_t *\emph{ buf}}{}
{[}MTD Interface{]} NAND write with ECC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t to}}] \leavevmode
offset to write to

\item[{\code{size\_t len}}] \leavevmode
number of bytes to write

\item[{\code{size\_t * retlen}}] \leavevmode
pointer to variable to store the number of written bytes

\item[{\code{const uint8\_t * buf}}] \leavevmode
the data to write

\end{description}

\textbf{Description}

NAND write with ECC. Used when performing writes in interrupt context, this
may for example be called by mtdoops when writing an oops while in panic.
\index{nand\_do\_write\_oob (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_do_write_oob}\pysiglinewithargsret{int \bfcode{nand\_do\_write\_oob}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ to}, struct mtd\_oob\_ops *\emph{ ops}}{}
{[}MTD Interface{]} NAND write out-of-band

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t to}}] \leavevmode
offset to write to

\item[{\code{struct mtd\_oob\_ops * ops}}] \leavevmode
oob operation description structure

\end{description}

\textbf{Description}

NAND write out-of-band.
\index{nand\_write\_oob (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_write_oob}\pysiglinewithargsret{int \bfcode{nand\_write\_oob}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ to}, struct mtd\_oob\_ops *\emph{ ops}}{}
{[}MTD Interface{]} NAND write data and/or out-of-band

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t to}}] \leavevmode
offset to write to

\item[{\code{struct mtd\_oob\_ops * ops}}] \leavevmode
oob operation description structure

\end{description}
\index{single\_erase (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.single_erase}\pysiglinewithargsret{int \bfcode{single\_erase}}{struct mtd\_info *\emph{ mtd}, int\emph{ page}}{}
{[}GENERIC{]} NAND standard block erase command function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{int page}}] \leavevmode
the page address of the block which will be erased

\end{description}

\textbf{Description}

Standard erase command for NAND chips. Returns NAND status.
\index{nand\_erase (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_erase}\pysiglinewithargsret{int \bfcode{nand\_erase}}{struct mtd\_info *\emph{ mtd}, struct erase\_info *\emph{ instr}}{}
{[}MTD Interface{]} erase block(s)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{struct erase\_info * instr}}] \leavevmode
erase instruction

\end{description}

\textbf{Description}

Erase one ore more blocks.
\index{nand\_erase\_nand (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_erase_nand}\pysiglinewithargsret{int \bfcode{nand\_erase\_nand}}{struct mtd\_info *\emph{ mtd}, struct erase\_info *\emph{ instr}, int\emph{ allowbbt}}{}
{[}INTERN{]} erase block(s)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{struct erase\_info * instr}}] \leavevmode
erase instruction

\item[{\code{int allowbbt}}] \leavevmode
allow erasing the bbt area

\end{description}

\textbf{Description}

Erase one ore more blocks.
\index{nand\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_sync}\pysiglinewithargsret{void \bfcode{nand\_sync}}{struct mtd\_info *\emph{ mtd}}{}
{[}MTD Interface{]} sync

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\end{description}

\textbf{Description}

Sync is actually a wait for chip ready function.
\index{nand\_block\_isbad (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_block_isbad}\pysiglinewithargsret{int \bfcode{nand\_block\_isbad}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ offs}}{}
{[}MTD Interface{]} Check if block at offset is bad

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t offs}}] \leavevmode
offset relative to mtd start

\end{description}
\index{nand\_block\_markbad (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_block_markbad}\pysiglinewithargsret{int \bfcode{nand\_block\_markbad}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ ofs}}{}
{[}MTD Interface{]} Mark block at the given offset as bad

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t ofs}}] \leavevmode
offset relative to mtd start

\end{description}
\index{nand\_max\_bad\_blocks (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_max_bad_blocks}\pysiglinewithargsret{int \bfcode{nand\_max\_bad\_blocks}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ ofs}, size\_t\emph{ len}}{}
{[}MTD Interface{]} Max number of bad blocks for an mtd

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t ofs}}] \leavevmode
offset relative to mtd start

\item[{\code{size\_t len}}] \leavevmode
length of mtd

\end{description}
\index{nand\_onfi\_set\_features (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_onfi_set_features}\pysiglinewithargsret{int \bfcode{nand\_onfi\_set\_features}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, int\emph{ addr}, uint8\_t *\emph{ subfeature\_param}}{}
{[}REPLACEABLE{]} set features for ONFI nand

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{int addr}}] \leavevmode
feature address.

\item[{\code{uint8\_t * subfeature\_param}}] \leavevmode
the subfeature parameters, a four bytes array.

\end{description}
\index{nand\_onfi\_get\_features (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_onfi_get_features}\pysiglinewithargsret{int \bfcode{nand\_onfi\_get\_features}}{struct mtd\_info *\emph{ mtd}, struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ chip}, int\emph{ addr}, uint8\_t *\emph{ subfeature\_param}}{}
{[}REPLACEABLE{]} get features for ONFI nand

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{struct nand\_chip * chip}}] \leavevmode
nand chip info structure

\item[{\code{int addr}}] \leavevmode
feature address.

\item[{\code{uint8\_t * subfeature\_param}}] \leavevmode
the subfeature parameters, a four bytes array.

\end{description}
\index{nand\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_suspend}\pysiglinewithargsret{int \bfcode{nand\_suspend}}{struct mtd\_info *\emph{ mtd}}{}
{[}MTD Interface{]} Suspend the NAND flash

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\end{description}
\index{nand\_resume (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_resume}\pysiglinewithargsret{void \bfcode{nand\_resume}}{struct mtd\_info *\emph{ mtd}}{}
{[}MTD Interface{]} Resume the NAND flash

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\end{description}
\index{nand\_shutdown (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_shutdown}\pysiglinewithargsret{void \bfcode{nand\_shutdown}}{struct mtd\_info *\emph{ mtd}}{}
{[}MTD Interface{]} Finish the current NAND operation and prevent further operations

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\end{description}
\index{check\_pattern (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.check_pattern}\pysiglinewithargsret{int \bfcode{check\_pattern}}{uint8\_t *\emph{ buf}, int\emph{ len}, int\emph{ paglen}, struct nand\_bbt\_descr *\emph{ td}}{}
{[}GENERIC{]} check if a pattern is in the buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{uint8\_t * buf}}] \leavevmode
the buffer to search

\item[{\code{int len}}] \leavevmode
the length of buffer to search

\item[{\code{int paglen}}] \leavevmode
the pagelength

\item[{\code{struct nand\_bbt\_descr * td}}] \leavevmode
search pattern descriptor

\end{description}

\textbf{Description}

Check for a pattern at the given place. Used to search bad block tables and
good / bad block identifiers.
\index{check\_short\_pattern (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.check_short_pattern}\pysiglinewithargsret{int \bfcode{check\_short\_pattern}}{uint8\_t *\emph{ buf}, struct nand\_bbt\_descr *\emph{ td}}{}
{[}GENERIC{]} check if a pattern is in the buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{uint8\_t * buf}}] \leavevmode
the buffer to search

\item[{\code{struct nand\_bbt\_descr * td}}] \leavevmode
search pattern descriptor

\end{description}

\textbf{Description}

Check for a pattern at the given place. Used to search bad block tables and
good / bad block identifiers. Same as check\_pattern, but no optional empty
check.
\index{add\_marker\_len (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.add_marker_len}\pysiglinewithargsret{u32 \bfcode{add\_marker\_len}}{struct nand\_bbt\_descr *\emph{ td}}{}
compute the length of the marker in data area

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_bbt\_descr * td}}] \leavevmode
BBT descriptor used for computation

\end{description}

\textbf{Description}

The length will be 0 if the marker is located in OOB area.
\index{read\_bbt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.read_bbt}\pysiglinewithargsret{int \bfcode{read\_bbt}}{struct mtd\_info *\emph{ mtd}, uint8\_t *\emph{ buf}, int\emph{ page}, int\emph{ num}, struct nand\_bbt\_descr *\emph{ td}, int\emph{ offs}}{}
{[}GENERIC{]} Read the bad block table starting from page

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{uint8\_t * buf}}] \leavevmode
temporary buffer

\item[{\code{int page}}] \leavevmode
the starting page

\item[{\code{int num}}] \leavevmode
the number of bbt descriptors to read

\item[{\code{struct nand\_bbt\_descr * td}}] \leavevmode
the bbt describtion table

\item[{\code{int offs}}] \leavevmode
block number offset in the table

\end{description}

\textbf{Description}

Read the bad block table starting from page.
\index{read\_abs\_bbt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.read_abs_bbt}\pysiglinewithargsret{int \bfcode{read\_abs\_bbt}}{struct mtd\_info *\emph{ mtd}, uint8\_t *\emph{ buf}, struct nand\_bbt\_descr *\emph{ td}, int\emph{ chip}}{}
{[}GENERIC{]} Read the bad block table starting at a given page

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{uint8\_t * buf}}] \leavevmode
temporary buffer

\item[{\code{struct nand\_bbt\_descr * td}}] \leavevmode
descriptor for the bad block table

\item[{\code{int chip}}] \leavevmode
read the table for a specific chip, -1 read all chips; applies only if
NAND\_BBT\_PERCHIP option is set

\end{description}

\textbf{Description}

Read the bad block table for all chips starting at a given page. We assume
that the bbt bits are in consecutive order.
\index{scan\_read\_oob (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.scan_read_oob}\pysiglinewithargsret{int \bfcode{scan\_read\_oob}}{struct mtd\_info *\emph{ mtd}, uint8\_t *\emph{ buf}, loff\_t\emph{ offs}, size\_t\emph{ len}}{}
{[}GENERIC{]} Scan data+OOB region to buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{uint8\_t * buf}}] \leavevmode
temporary buffer

\item[{\code{loff\_t offs}}] \leavevmode
offset at which to scan

\item[{\code{size\_t len}}] \leavevmode
length of data region to read

\end{description}

\textbf{Description}

Scan read data from data+OOB. May traverse multiple pages, interleaving
page,OOB,page,OOB,... in buf. Completes transfer and returns the ``strongest''
ECC condition (error or bitflip). May quit on the first (non-ECC) error.
\index{read\_abs\_bbts (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.read_abs_bbts}\pysiglinewithargsret{void \bfcode{read\_abs\_bbts}}{struct mtd\_info *\emph{ mtd}, uint8\_t *\emph{ buf}, struct nand\_bbt\_descr *\emph{ td}, struct nand\_bbt\_descr *\emph{ md}}{}
{[}GENERIC{]} Read the bad block table(s) for all chips starting at a given page

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{uint8\_t * buf}}] \leavevmode
temporary buffer

\item[{\code{struct nand\_bbt\_descr * td}}] \leavevmode
descriptor for the bad block table

\item[{\code{struct nand\_bbt\_descr * md}}] \leavevmode
descriptor for the bad block table mirror

\end{description}

\textbf{Description}

Read the bad block table(s) for all chips starting at a given page. We
assume that the bbt bits are in consecutive order.
\index{create\_bbt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.create_bbt}\pysiglinewithargsret{int \bfcode{create\_bbt}}{struct mtd\_info *\emph{ mtd}, uint8\_t *\emph{ buf}, struct nand\_bbt\_descr *\emph{ bd}, int\emph{ chip}}{}
{[}GENERIC{]} Create a bad block table by scanning the device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{uint8\_t * buf}}] \leavevmode
temporary buffer

\item[{\code{struct nand\_bbt\_descr * bd}}] \leavevmode
descriptor for the good/bad block search pattern

\item[{\code{int chip}}] \leavevmode
create the table for a specific chip, -1 read all chips; applies only
if NAND\_BBT\_PERCHIP option is set

\end{description}

\textbf{Description}

Create a bad block table by scanning the device for the given good/bad block
identify pattern.
\index{search\_bbt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.search_bbt}\pysiglinewithargsret{int \bfcode{search\_bbt}}{struct mtd\_info *\emph{ mtd}, uint8\_t *\emph{ buf}, struct nand\_bbt\_descr *\emph{ td}}{}
{[}GENERIC{]} scan the device for a specific bad block table

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{uint8\_t * buf}}] \leavevmode
temporary buffer

\item[{\code{struct nand\_bbt\_descr * td}}] \leavevmode
descriptor for the bad block table

\end{description}

\textbf{Description}

Read the bad block table by searching for a given ident pattern. Search is
preformed either from the beginning up or from the end of the device
downwards. The search starts always at the start of a block. If the option
NAND\_BBT\_PERCHIP is given, each chip is searched for a bbt, which contains
the bad block information of this chip. This is necessary to provide support
for certain DOC devices.

The bbt ident pattern resides in the oob area of the first page in a block.
\index{search\_read\_bbts (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.search_read_bbts}\pysiglinewithargsret{void \bfcode{search\_read\_bbts}}{struct mtd\_info *\emph{ mtd}, uint8\_t *\emph{ buf}, struct nand\_bbt\_descr *\emph{ td}, struct nand\_bbt\_descr *\emph{ md}}{}
{[}GENERIC{]} scan the device for bad block table(s)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{uint8\_t * buf}}] \leavevmode
temporary buffer

\item[{\code{struct nand\_bbt\_descr * td}}] \leavevmode
descriptor for the bad block table

\item[{\code{struct nand\_bbt\_descr * md}}] \leavevmode
descriptor for the bad block table mirror

\end{description}

\textbf{Description}

Search and read the bad block table(s).
\index{get\_bbt\_block (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.get_bbt_block}\pysiglinewithargsret{int \bfcode{get\_bbt\_block}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ this}, struct nand\_bbt\_descr *\emph{ td}, struct nand\_bbt\_descr *\emph{ md}, int\emph{ chip}}{}
Get the first valid eraseblock suitable to store a BBT

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * this}}] \leavevmode
the NAND device

\item[{\code{struct nand\_bbt\_descr * td}}] \leavevmode
the BBT description

\item[{\code{struct nand\_bbt\_descr * md}}] \leavevmode
the mirror BBT descriptor

\item[{\code{int chip}}] \leavevmode
the CHIP selector

\end{description}

\textbf{Description}

This functions returns a positive block number pointing a valid eraseblock
suitable to store a BBT (i.e. in the range reserved for BBT), or -ENOSPC if
all blocks are already used of marked bad. If td-\textgreater{}pages{[}chip{]} was already
pointing to a valid block we re-use it, otherwise we search for the next
valid one.
\index{mark\_bbt\_block\_bad (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.mark_bbt_block_bad}\pysiglinewithargsret{void \bfcode{mark\_bbt\_block\_bad}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ this}, struct nand\_bbt\_descr *\emph{ td}, int\emph{ chip}, int\emph{ block}}{}
Mark one of the block reserved for BBT bad

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * this}}] \leavevmode
the NAND device

\item[{\code{struct nand\_bbt\_descr * td}}] \leavevmode
the BBT description

\item[{\code{int chip}}] \leavevmode
the CHIP selector

\item[{\code{int block}}] \leavevmode
the BBT block to mark

\end{description}

\textbf{Description}

Blocks reserved for BBT can become bad. This functions is an helper to mark
such blocks as bad. It takes care of updating the in-memory BBT, marking the
block as bad using a bad block marker and invalidating the associated
td-\textgreater{}pages{[}{]} entry.
\index{write\_bbt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.write_bbt}\pysiglinewithargsret{int \bfcode{write\_bbt}}{struct mtd\_info *\emph{ mtd}, uint8\_t *\emph{ buf}, struct nand\_bbt\_descr *\emph{ td}, struct nand\_bbt\_descr *\emph{ md}, int\emph{ chipsel}}{}
{[}GENERIC{]} (Re)write the bad block table

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{uint8\_t * buf}}] \leavevmode
temporary buffer

\item[{\code{struct nand\_bbt\_descr * td}}] \leavevmode
descriptor for the bad block table

\item[{\code{struct nand\_bbt\_descr * md}}] \leavevmode
descriptor for the bad block table mirror

\item[{\code{int chipsel}}] \leavevmode
selector for a specific chip, -1 for all

\end{description}

\textbf{Description}

(Re)write the bad block table.
\index{nand\_memory\_bbt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_memory_bbt}\pysiglinewithargsret{int \bfcode{nand\_memory\_bbt}}{struct mtd\_info *\emph{ mtd}, struct nand\_bbt\_descr *\emph{ bd}}{}
{[}GENERIC{]} create a memory based bad block table

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{struct nand\_bbt\_descr * bd}}] \leavevmode
descriptor for the good/bad block search pattern

\end{description}

\textbf{Description}

The function creates a memory based bbt by scanning the device for
manufacturer / software marked good / bad blocks.
\index{check\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.check_create}\pysiglinewithargsret{int \bfcode{check\_create}}{struct mtd\_info *\emph{ mtd}, uint8\_t *\emph{ buf}, struct nand\_bbt\_descr *\emph{ bd}}{}
{[}GENERIC{]} create and write bbt(s) if necessary

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{uint8\_t * buf}}] \leavevmode
temporary buffer

\item[{\code{struct nand\_bbt\_descr * bd}}] \leavevmode
descriptor for the good/bad block search pattern

\end{description}

\textbf{Description}

The function checks the results of the previous call to read\_bbt and creates
/ updates the bbt(s) if necessary. Creation is necessary if no bbt was found
for the chip/device. Update is necessary if one of the tables is missing or
the version nr. of one table is less than the other.
\index{mark\_bbt\_region (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.mark_bbt_region}\pysiglinewithargsret{void \bfcode{mark\_bbt\_region}}{struct mtd\_info *\emph{ mtd}, struct nand\_bbt\_descr *\emph{ td}}{}
{[}GENERIC{]} mark the bad block table regions

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{struct nand\_bbt\_descr * td}}] \leavevmode
bad block table descriptor

\end{description}

\textbf{Description}

The bad block table regions are marked as ``bad'' to prevent accidental
erasures / writes. The regions are identified by the mark 0x02.
\index{verify\_bbt\_descr (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.verify_bbt_descr}\pysiglinewithargsret{void \bfcode{verify\_bbt\_descr}}{struct mtd\_info *\emph{ mtd}, struct nand\_bbt\_descr *\emph{ bd}}{}
verify the bad block description

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{struct nand\_bbt\_descr * bd}}] \leavevmode
the table to verify

\end{description}

\textbf{Description}

This functions performs a few sanity checks on the bad block description
table.
\index{nand\_scan\_bbt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_scan_bbt}\pysiglinewithargsret{int \bfcode{nand\_scan\_bbt}}{struct mtd\_info *\emph{ mtd}, struct nand\_bbt\_descr *\emph{ bd}}{}
{[}NAND Interface{]} scan, find, read and maybe create bad block table(s)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{struct nand\_bbt\_descr * bd}}] \leavevmode
descriptor for the good/bad block search pattern

\end{description}

\textbf{Description}

The function checks, if a bad block table(s) is/are already available. If
not it scans the device for manufacturer marked good / bad blocks and writes
the bad block table(s) to the selected place.

The bad block table memory is allocated here. It must be freed by calling
the nand\_free\_bbt function.
\index{nand\_update\_bbt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_update_bbt}\pysiglinewithargsret{int \bfcode{nand\_update\_bbt}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ offs}}{}
update bad block table(s)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t offs}}] \leavevmode
the offset of the newly marked block

\end{description}

\textbf{Description}

The function updates the bad block table(s).
\index{nand\_create\_badblock\_pattern (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_create_badblock_pattern}\pysiglinewithargsret{int \bfcode{nand\_create\_badblock\_pattern}}{struct {\hyperref[driver\string-api/mtdnand:c.nand_chip]{\emph{nand\_chip}}} *\emph{ this}}{}
{[}INTERN{]} Creates a BBT descriptor structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct nand\_chip * this}}] \leavevmode
NAND chip to create descriptor for

\end{description}

\textbf{Description}

This function allocates and initializes a nand\_bbt\_descr for BBM detection
based on the properties of \textbf{this}. The new descriptor is stored in
this-\textgreater{}badblock\_pattern. Thus, this-\textgreater{}badblock\_pattern should be NULL when
passed to this function.
\index{nand\_default\_bbt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_default_bbt}\pysiglinewithargsret{int \bfcode{nand\_default\_bbt}}{struct mtd\_info *\emph{ mtd}}{}
{[}NAND Interface{]} Select a default bad block table for the device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\end{description}

\textbf{Description}

This function selects the default bad block table support for the device and
calls the nand\_scan\_bbt function.
\index{nand\_isreserved\_bbt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_isreserved_bbt}\pysiglinewithargsret{int \bfcode{nand\_isreserved\_bbt}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ offs}}{}
{[}NAND Interface{]} Check if a block is reserved

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t offs}}] \leavevmode
offset in the device

\end{description}
\index{nand\_isbad\_bbt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_isbad_bbt}\pysiglinewithargsret{int \bfcode{nand\_isbad\_bbt}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ offs}, int\emph{ allowbbt}}{}
{[}NAND Interface{]} Check if a block is bad

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t offs}}] \leavevmode
offset in the device

\item[{\code{int allowbbt}}] \leavevmode
allow access to bad block table region

\end{description}
\index{nand\_markbad\_bbt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/mtdnand:c.nand_markbad_bbt}\pysiglinewithargsret{int \bfcode{nand\_markbad\_bbt}}{struct mtd\_info *\emph{ mtd}, loff\_t\emph{ offs}}{}
{[}NAND Interface{]} Mark a block bad in the BBT

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mtd\_info * mtd}}] \leavevmode
MTD device structure

\item[{\code{loff\_t offs}}] \leavevmode
offset of the bad block

\end{description}


\section{Credits}
\label{driver-api/mtdnand:credits}
The following people have contributed to the NAND driver:
\begin{enumerate}
\item {} 
Steven J. Hill\href{mailto:sjhill@realitydiluted.com}{sjhill@realitydiluted.com}

\item {} 
David Woodhouse\href{mailto:dwmw2@infradead.org}{dwmw2@infradead.org}

\item {} 
Thomas Gleixner\href{mailto:tglx@linutronix.de}{tglx@linutronix.de}

\end{enumerate}

A lot of users have provided bugfixes, improvements and helping hands
for testing. Thanks a lot.

The following people have contributed to this document:
\begin{enumerate}
\item {} 
Thomas Gleixner\href{mailto:tglx@linutronix.de}{tglx@linutronix.de}

\end{enumerate}


\chapter{Parallel Port Devices}
\label{driver-api/miscellaneous:parallel-port-devices}\label{driver-api/miscellaneous::doc}\index{parport\_yield (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_yield}\pysiglinewithargsret{int \bfcode{parport\_yield}}{struct pardevice *\emph{ dev}}{}
relinquish a parallel port temporarily

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pardevice * dev}}] \leavevmode
a device on the parallel port

\end{description}

\textbf{Description}

This function relinquishes the port if it would be helpful to other
drivers to do so.  Afterwards it tries to reclaim the port using
{\hyperref[driver\string-api/miscellaneous:c.parport_claim]{\emph{\code{parport\_claim()}}}}, and the return value is the same as for
{\hyperref[driver\string-api/miscellaneous:c.parport_claim]{\emph{\code{parport\_claim()}}}}.  If it fails, the port is left unclaimed and it is
the driver's responsibility to reclaim the port.

The {\hyperref[driver\string-api/miscellaneous:c.parport_yield]{\emph{\code{parport\_yield()}}}} and {\hyperref[driver\string-api/miscellaneous:c.parport_yield_blocking]{\emph{\code{parport\_yield\_blocking()}}}} functions are for
marking points in the driver at which other drivers may claim the
port and use their devices.  Yielding the port is similar to
releasing it and reclaiming it, but is more efficient because no
action is taken if there are no other devices needing the port.  In
fact, nothing is done even if there are other devices waiting but
the current device is still within its ``timeslice''.  The default
timeslice is half a second, but it can be adjusted via the /proc
interface.
\index{parport\_yield\_blocking (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_yield_blocking}\pysiglinewithargsret{int \bfcode{parport\_yield\_blocking}}{struct pardevice *\emph{ dev}}{}
relinquish a parallel port temporarily

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pardevice * dev}}] \leavevmode
a device on the parallel port

\end{description}

\textbf{Description}

This function relinquishes the port if it would be helpful to other
drivers to do so.  Afterwards it tries to reclaim the port using
{\hyperref[driver\string-api/miscellaneous:c.parport_claim_or_block]{\emph{\code{parport\_claim\_or\_block()}}}}, and the return value is the same as for
{\hyperref[driver\string-api/miscellaneous:c.parport_claim_or_block]{\emph{\code{parport\_claim\_or\_block()}}}}.
\index{parport\_wait\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_wait_event}\pysiglinewithargsret{int \bfcode{parport\_wait\_event}}{struct parport *\emph{ port}, signed long\emph{ timeout}}{}
wait for an event on a parallel port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct parport * port}}] \leavevmode
port to wait on

\item[{\code{signed long timeout}}] \leavevmode
time to wait (in jiffies)

\end{description}

\textbf{Description}
\begin{quote}

This function waits for up to \textbf{timeout} jiffies for an
interrupt to occur on a parallel port.  If the port timeout is
set to zero, it returns immediately.

If an interrupt occurs before the timeout period elapses, this
function returns zero immediately.  If it times out, it returns
one.  An error code less than zero indicates an error (most
likely a pending signal), and the calling code should finish
what it's doing as soon as it can.
\end{quote}
\index{parport\_wait\_peripheral (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_wait_peripheral}\pysiglinewithargsret{int \bfcode{parport\_wait\_peripheral}}{struct parport *\emph{ port}, unsigned char\emph{ mask}, unsigned char\emph{ result}}{}
wait for status lines to change in 35ms

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct parport * port}}] \leavevmode
port to watch

\item[{\code{unsigned char mask}}] \leavevmode
status lines to watch

\item[{\code{unsigned char result}}] \leavevmode
desired values of chosen status lines

\end{description}

\textbf{Description}
\begin{quote}

This function waits until the masked status lines have the
desired values, or until 35ms have elapsed (see IEEE 1284-1994
page 24 to 25 for why this value in particular is hardcoded).
The \textbf{mask} and \textbf{result} parameters are bitmasks, with the bits
defined by the constants in parport.h: \code{PARPORT\_STATUS\_BUSY},
and so on.

The port is polled quickly to start off with, in anticipation
of a fast response from the peripheral.  This fast polling
time is configurable (using /proc), and defaults to 500usec.
If the timeout for this port (see {\hyperref[driver\string-api/miscellaneous:c.parport_set_timeout]{\emph{\code{parport\_set\_timeout()}}}}) is
zero, the fast polling time is 35ms, and this function does
not call \code{schedule()}.

If the timeout for this port is non-zero, after the fast
polling fails it uses {\hyperref[driver\string-api/miscellaneous:c.parport_wait_event]{\emph{\code{parport\_wait\_event()}}}} to wait for up to
10ms, waking up if an interrupt occurs.
\end{quote}
\index{parport\_negotiate (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_negotiate}\pysiglinewithargsret{int \bfcode{parport\_negotiate}}{struct parport *\emph{ port}, int\emph{ mode}}{}
negotiate an IEEE 1284 mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct parport * port}}] \leavevmode
port to use

\item[{\code{int mode}}] \leavevmode
mode to negotiate to

\end{description}

\textbf{Description}
\begin{quote}

Use this to negotiate to a particular IEEE 1284 transfer mode.
The \textbf{mode} parameter should be one of the constants in
parport.h starting \code{IEEE1284\_MODE\_xxx}.

The return value is 0 if the peripheral has accepted the
negotiation to the mode specified, -1 if the peripheral is not
IEEE 1284 compliant (or not present), or 1 if the peripheral
has rejected the negotiation.
\end{quote}
\index{parport\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_write}\pysiglinewithargsret{ssize\_t \bfcode{parport\_write}}{struct parport *\emph{ port}, const void *\emph{ buffer}, size\_t\emph{ len}}{}
write a block of data to a parallel port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct parport * port}}] \leavevmode
port to write to

\item[{\code{const void * buffer}}] \leavevmode
data buffer (in kernel space)

\item[{\code{size\_t len}}] \leavevmode
number of bytes of data to transfer

\end{description}

\textbf{Description}
\begin{quote}

This will write up to \textbf{len} bytes of \textbf{buffer} to the port
specified, using the IEEE 1284 transfer mode most recently
negotiated to (using {\hyperref[driver\string-api/miscellaneous:c.parport_negotiate]{\emph{\code{parport\_negotiate()}}}}), as long as that
mode supports forward transfers (host to peripheral).

It is the caller's responsibility to ensure that the first
\textbf{len} bytes of \textbf{buffer} are valid.

This function returns the number of bytes transferred (if zero
or positive), or else an error code.
\end{quote}
\index{parport\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_read}\pysiglinewithargsret{ssize\_t \bfcode{parport\_read}}{struct parport *\emph{ port}, void *\emph{ buffer}, size\_t\emph{ len}}{}
read a block of data from a parallel port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct parport * port}}] \leavevmode
port to read from

\item[{\code{void * buffer}}] \leavevmode
data buffer (in kernel space)

\item[{\code{size\_t len}}] \leavevmode
number of bytes of data to transfer

\end{description}

\textbf{Description}
\begin{quote}

This will read up to \textbf{len} bytes of \textbf{buffer} to the port
specified, using the IEEE 1284 transfer mode most recently
negotiated to (using {\hyperref[driver\string-api/miscellaneous:c.parport_negotiate]{\emph{\code{parport\_negotiate()}}}}), as long as that
mode supports reverse transfers (peripheral to host).

It is the caller's responsibility to ensure that the first
\textbf{len} bytes of \textbf{buffer} are available to write to.

This function returns the number of bytes transferred (if zero
or positive), or else an error code.
\end{quote}
\index{parport\_set\_timeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_set_timeout}\pysiglinewithargsret{long \bfcode{parport\_set\_timeout}}{struct pardevice *\emph{ dev}, long\emph{ inactivity}}{}
set the inactivity timeout for a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pardevice * dev}}] \leavevmode
device on a port

\item[{\code{long inactivity}}] \leavevmode
inactivity timeout (in jiffies)

\end{description}

\textbf{Description}
\begin{quote}

This sets the inactivity timeout for a particular device on a
port.  This affects functions like {\hyperref[driver\string-api/miscellaneous:c.parport_wait_peripheral]{\emph{\code{parport\_wait\_peripheral()}}}}.
The special value 0 means not to call \code{schedule()} while dealing
with this device.

The return value is the previous inactivity timeout.

Any callers of {\hyperref[driver\string-api/miscellaneous:c.parport_wait_event]{\emph{\code{parport\_wait\_event()}}}} for this device are woken
up.
\end{quote}
\index{\_\_parport\_register\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.__parport_register_driver}\pysiglinewithargsret{int \bfcode{\_\_parport\_register\_driver}}{struct parport\_driver *\emph{ drv}, struct module *\emph{ owner}, const char *\emph{ mod\_name}}{}
register a parallel port device driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct parport\_driver * drv}}] \leavevmode
structure describing the driver

\item[{\code{struct module * owner}}] \leavevmode
owner module of drv

\item[{\code{const char * mod\_name}}] \leavevmode
module name string

\end{description}

\textbf{Description}
\begin{quote}

This can be called by a parallel port device driver in order
to receive notifications about ports being found in the
system, as well as ports no longer available.

If devmodel is true then the new device model is used
for registration.

The \textbf{drv} structure is allocated by the caller and must not be
deallocated until after calling {\hyperref[driver\string-api/miscellaneous:c.parport_unregister_driver]{\emph{\code{parport\_unregister\_driver()}}}}.

If using the non device model:
The driver's \code{attach()} function may block.  The port that
\code{attach()} is given will be valid for the duration of the
callback, but if the driver wants to take a copy of the
pointer it must call {\hyperref[driver\string-api/miscellaneous:c.parport_get_port]{\emph{\code{parport\_get\_port()}}}} to do so.  Calling
{\hyperref[driver\string-api/miscellaneous:c.parport_register_device]{\emph{\code{parport\_register\_device()}}}} on that port will do this for you.

The driver's \code{detach()} function may block.  The port that
\code{detach()} is given will be valid for the duration of the
callback, but if the driver wants to take a copy of the
pointer it must call {\hyperref[driver\string-api/miscellaneous:c.parport_get_port]{\emph{\code{parport\_get\_port()}}}} to do so.

Returns 0 on success. The non device model will always succeeds.
but the new device model can fail and will return the error code.
\end{quote}
\index{parport\_unregister\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_unregister_driver}\pysiglinewithargsret{void \bfcode{parport\_unregister\_driver}}{struct parport\_driver *\emph{ drv}}{}
deregister a parallel port device driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct parport\_driver * drv}}] \leavevmode
structure describing the driver that was given to
\code{parport\_register\_driver()}

\end{description}

\textbf{Description}
\begin{quote}

This should be called by a parallel port device driver that
has registered itself using \code{parport\_register\_driver()} when it
is about to be unloaded.

When it returns, the driver's \code{attach()} routine will no longer
be called, and for each port that \code{attach()} was called for, the
\code{detach()} routine will have been called.

All the driver's \code{attach()} and \code{detach()} calls are guaranteed to have
finished by the time this function returns.
\end{quote}
\index{parport\_get\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_get_port}\pysiglinewithargsret{struct parport * \bfcode{parport\_get\_port}}{struct parport *\emph{ port}}{}
increment a port's reference count

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct parport * port}}] \leavevmode
the port

\end{description}

\textbf{Description}
\begin{quote}

This ensures that a struct parport pointer remains valid
until the matching {\hyperref[driver\string-api/miscellaneous:c.parport_put_port]{\emph{\code{parport\_put\_port()}}}} call.
\end{quote}
\index{parport\_put\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_put_port}\pysiglinewithargsret{void \bfcode{parport\_put\_port}}{struct parport *\emph{ port}}{}
decrement a port's reference count

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct parport * port}}] \leavevmode
the port

\end{description}

\textbf{Description}
\begin{quote}

This should be called once for each call to {\hyperref[driver\string-api/miscellaneous:c.parport_get_port]{\emph{\code{parport\_get\_port()}}}},
once the port is no longer needed. When the reference count reaches
zero (port is no longer used), free\_port is called.
\end{quote}
\index{parport\_register\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_register_port}\pysiglinewithargsret{struct parport * \bfcode{parport\_register\_port}}{unsigned long\emph{ base}, int\emph{ irq}, int\emph{ dma}, struct parport\_operations *\emph{ ops}}{}
register a parallel port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long base}}] \leavevmode
base I/O address

\item[{\code{int irq}}] \leavevmode
IRQ line

\item[{\code{int dma}}] \leavevmode
DMA channel

\item[{\code{struct parport\_operations * ops}}] \leavevmode
pointer to the port driver's port operations structure

\end{description}

\textbf{Description}
\begin{quote}

When a parallel port (lowlevel) driver finds a port that
should be made available to parallel port device drivers, it
should call {\hyperref[driver\string-api/miscellaneous:c.parport_register_port]{\emph{\code{parport\_register\_port()}}}}.  The \textbf{base}, \textbf{irq}, and
\textbf{dma} parameters are for the convenience of port drivers, and
for ports where they aren't meaningful needn't be set to
anything special.  They can be altered afterwards by adjusting
the relevant members of the parport structure that is returned
and represents the port.  They should not be tampered with
after calling parport\_announce\_port, however.

If there are parallel port device drivers in the system that
have registered themselves using \code{parport\_register\_driver()},
they are not told about the port at this time; that is done by
{\hyperref[driver\string-api/miscellaneous:c.parport_announce_port]{\emph{\code{parport\_announce\_port()}}}}.

The \textbf{ops} structure is allocated by the caller, and must not be
deallocated before calling {\hyperref[driver\string-api/miscellaneous:c.parport_remove_port]{\emph{\code{parport\_remove\_port()}}}}.

If there is no memory to allocate a new parport structure,
this function will return \code{NULL}.
\end{quote}
\index{parport\_announce\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_announce_port}\pysiglinewithargsret{void \bfcode{parport\_announce\_port}}{struct parport *\emph{ port}}{}
tell device drivers about a parallel port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct parport * port}}] \leavevmode
parallel port to announce

\end{description}

\textbf{Description}
\begin{quote}

After a port driver has registered a parallel port with
parport\_register\_port, and performed any necessary
initialisation or adjustments, it should call
{\hyperref[driver\string-api/miscellaneous:c.parport_announce_port]{\emph{\code{parport\_announce\_port()}}}} in order to notify all device drivers
that have called \code{parport\_register\_driver()}.  Their \code{attach()}
functions will be called, with \textbf{port} as the parameter.
\end{quote}
\index{parport\_remove\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_remove_port}\pysiglinewithargsret{void \bfcode{parport\_remove\_port}}{struct parport *\emph{ port}}{}
deregister a parallel port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct parport * port}}] \leavevmode
parallel port to deregister

\end{description}

\textbf{Description}
\begin{quote}

When a parallel port driver is forcibly unloaded, or a
parallel port becomes inaccessible, the port driver must call
this function in order to deal with device drivers that still
want to use it.

The parport structure associated with the port has its
operations structure replaced with one containing `null'
operations that return errors or just don't do anything.

Any drivers that have registered themselves using
\code{parport\_register\_driver()} are notified that the port is no
longer accessible by having their \code{detach()} routines called
with \textbf{port} as the parameter.
\end{quote}
\index{parport\_register\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_register_device}\pysiglinewithargsret{struct pardevice * \bfcode{parport\_register\_device}}{struct parport *\emph{ port}, const char *\emph{ name}, int (*pf) (void\emph{ *}, void (*kf) (void\emph{ *}, void (*irq\_func) (void\emph{ *}, int\emph{ flags}, void *\emph{ handle}}{}
register a device on a parallel port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct parport * port}}] \leavevmode
port to which the device is attached

\item[{\code{const char * name}}] \leavevmode
a name to refer to the device

\item[{\code{int (*)(void *) pf}}] \leavevmode
preemption callback

\item[{\code{void (*)(void *) kf}}] \leavevmode
kick callback (wake-up)

\item[{\code{void (*)(void *) irq\_func}}] \leavevmode
interrupt handler

\item[{\code{int flags}}] \leavevmode
registration flags

\item[{\code{void * handle}}] \leavevmode
data for callback functions

\end{description}

\textbf{Description}
\begin{quote}

This function, called by parallel port device drivers,
declares that a device is connected to a port, and tells the
system all it needs to know.

The \textbf{name} is allocated by the caller and must not be
deallocated until the caller calls \textbf{parport\_unregister\_device}
for that device.

The preemption callback function, \textbf{pf}, is called when this
device driver has claimed access to the port but another
device driver wants to use it.  It is given \textbf{handle} as its
parameter, and should return zero if it is willing for the
system to release the port to another driver on its behalf.
If it wants to keep control of the port it should return
non-zero, and no action will be taken.  It is good manners for
the driver to try to release the port at the earliest
opportunity after its preemption callback rejects a preemption
attempt.  Note that if a preemption callback is happy for
preemption to go ahead, there is no need to release the port;
it is done automatically.  This function may not block, as it
may be called from interrupt context.  If the device driver
does not support preemption, \textbf{pf} can be \code{NULL}.

The wake-up (``kick'') callback function, \textbf{kf}, is called when
the port is available to be claimed for exclusive access; that
is, {\hyperref[driver\string-api/miscellaneous:c.parport_claim]{\emph{\code{parport\_claim()}}}} is guaranteed to succeed when called from
inside the wake-up callback function.  If the driver wants to
claim the port it should do so; otherwise, it need not take
any action.  This function may not block, as it may be called
from interrupt context.  If the device driver does not want to
be explicitly invited to claim the port in this way, \textbf{kf} can
be \code{NULL}.

The interrupt handler, \textbf{irq\_func}, is called when an interrupt
arrives from the parallel port.  Note that if a device driver
wants to use interrupts it should use \code{parport\_enable\_irq()},
and can also check the irq member of the parport structure
representing the port.

The parallel port (lowlevel) driver is the one that has called
\code{request\_irq()} and whose interrupt handler is called first.
This handler does whatever needs to be done to the hardware to
acknowledge the interrupt (for PC-style ports there is nothing
special to be done).  It then tells the IEEE 1284 code about
the interrupt, which may involve reacting to an IEEE 1284
event depending on the current IEEE 1284 phase.  After this,
it calls \textbf{irq\_func}.  Needless to say, \textbf{irq\_func} will be called
from interrupt context, and may not block.

The \code{PARPORT\_DEV\_EXCL} flag is for preventing port sharing, and
so should only be used when sharing the port with other device
drivers is impossible and would lead to incorrect behaviour.
Use it sparingly!  Normally, \textbf{flags} will be zero.

This function returns a pointer to a structure that represents
the device on the port, or \code{NULL} if there is not enough memory
to allocate space for that structure.
\end{quote}
\index{parport\_unregister\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_unregister_device}\pysiglinewithargsret{void \bfcode{parport\_unregister\_device}}{struct pardevice *\emph{ dev}}{}
deregister a device on a parallel port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pardevice * dev}}] \leavevmode
pointer to structure representing device

\end{description}

\textbf{Description}
\begin{quote}

This undoes the effect of {\hyperref[driver\string-api/miscellaneous:c.parport_register_device]{\emph{\code{parport\_register\_device()}}}}.
\end{quote}
\index{parport\_find\_number (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_find_number}\pysiglinewithargsret{struct parport * \bfcode{parport\_find\_number}}{int\emph{ number}}{}
find a parallel port by number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int number}}] \leavevmode
parallel port number

\end{description}

\textbf{Description}
\begin{quote}

This returns the parallel port with the specified number, or
\code{NULL} if there is none.

There is an implicit {\hyperref[driver\string-api/miscellaneous:c.parport_get_port]{\emph{\code{parport\_get\_port()}}}} done already; to throw
away the reference to the port that {\hyperref[driver\string-api/miscellaneous:c.parport_find_number]{\emph{\code{parport\_find\_number()}}}}
gives you, use {\hyperref[driver\string-api/miscellaneous:c.parport_put_port]{\emph{\code{parport\_put\_port()}}}}.
\end{quote}
\index{parport\_find\_base (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_find_base}\pysiglinewithargsret{struct parport * \bfcode{parport\_find\_base}}{unsigned long\emph{ base}}{}
find a parallel port by base address

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long base}}] \leavevmode
base I/O address

\end{description}

\textbf{Description}
\begin{quote}

This returns the parallel port with the specified base
address, or \code{NULL} if there is none.

There is an implicit {\hyperref[driver\string-api/miscellaneous:c.parport_get_port]{\emph{\code{parport\_get\_port()}}}} done already; to throw
away the reference to the port that {\hyperref[driver\string-api/miscellaneous:c.parport_find_base]{\emph{\code{parport\_find\_base()}}}}
gives you, use {\hyperref[driver\string-api/miscellaneous:c.parport_put_port]{\emph{\code{parport\_put\_port()}}}}.
\end{quote}
\index{parport\_claim (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_claim}\pysiglinewithargsret{int \bfcode{parport\_claim}}{struct pardevice *\emph{ dev}}{}
claim access to a parallel port device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pardevice * dev}}] \leavevmode
pointer to structure representing a device on the port

\end{description}

\textbf{Description}
\begin{quote}

This function will not block and so can be used from interrupt
context.  If {\hyperref[driver\string-api/miscellaneous:c.parport_claim]{\emph{\code{parport\_claim()}}}} succeeds in claiming access to
the port it returns zero and the port is available to use.  It
may fail (returning non-zero) if the port is in use by another
driver and that driver is not willing to relinquish control of
the port.
\end{quote}
\index{parport\_claim\_or\_block (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_claim_or_block}\pysiglinewithargsret{int \bfcode{parport\_claim\_or\_block}}{struct pardevice *\emph{ dev}}{}
claim access to a parallel port device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pardevice * dev}}] \leavevmode
pointer to structure representing a device on the port

\end{description}

\textbf{Description}
\begin{quote}

This behaves like {\hyperref[driver\string-api/miscellaneous:c.parport_claim]{\emph{\code{parport\_claim()}}}}, but will block if necessary
to wait for the port to be free.  A return value of 1
indicates that it slept; 0 means that it succeeded without
needing to sleep.  A negative error code indicates failure.
\end{quote}
\index{parport\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_release}\pysiglinewithargsret{void \bfcode{parport\_release}}{struct pardevice *\emph{ dev}}{}
give up access to a parallel port device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pardevice * dev}}] \leavevmode
pointer to structure representing parallel port device

\end{description}

\textbf{Description}
\begin{quote}

This function cannot fail, but it should not be called without
the port claimed.  Similarly, if the port is already claimed
you should not try claiming it again.
\end{quote}
\index{parport\_open (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_open}\pysiglinewithargsret{struct pardevice * \bfcode{parport\_open}}{int\emph{ devnum}, const char *\emph{ name}}{}
find a device by canonical device number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int devnum}}] \leavevmode
canonical device number

\item[{\code{const char * name}}] \leavevmode
name to associate with the device

\end{description}

\textbf{Description}
\begin{quote}

This function is similar to {\hyperref[driver\string-api/miscellaneous:c.parport_register_device]{\emph{\code{parport\_register\_device()}}}}, except
that it locates a device by its number rather than by the port
it is attached to.

All parameters except for \textbf{devnum} are the same as for
{\hyperref[driver\string-api/miscellaneous:c.parport_register_device]{\emph{\code{parport\_register\_device()}}}}.  The return value is the same as
for {\hyperref[driver\string-api/miscellaneous:c.parport_register_device]{\emph{\code{parport\_register\_device()}}}}.
\end{quote}
\index{parport\_close (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.parport_close}\pysiglinewithargsret{void \bfcode{parport\_close}}{struct pardevice *\emph{ dev}}{}
close a device opened with {\hyperref[driver\string-api/miscellaneous:c.parport_open]{\emph{\code{parport\_open()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pardevice * dev}}] \leavevmode
device to close

\end{description}

\textbf{Description}
\begin{quote}

This is to {\hyperref[driver\string-api/miscellaneous:c.parport_open]{\emph{\code{parport\_open()}}}} as {\hyperref[driver\string-api/miscellaneous:c.parport_unregister_device]{\emph{\code{parport\_unregister\_device()}}}} is to
{\hyperref[driver\string-api/miscellaneous:c.parport_register_device]{\emph{\code{parport\_register\_device()}}}}.
\end{quote}


\chapter{16x50 UART Driver}
\label{driver-api/miscellaneous:x50-uart-driver}\index{uart\_update\_timeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.uart_update_timeout}\pysiglinewithargsret{void \bfcode{uart\_update\_timeout}}{struct uart\_port *\emph{ port}, unsigned int\emph{ cflag}, unsigned int\emph{ baud}}{}
update per-port FIFO timeout.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct uart\_port * port}}] \leavevmode
uart\_port structure describing the port

\item[{\code{unsigned int cflag}}] \leavevmode
termios cflag value

\item[{\code{unsigned int baud}}] \leavevmode
speed of the port

\end{description}

\textbf{Description}
\begin{quote}

Set the port FIFO timeout value.  The \textbf{cflag} value should
reflect the actual hardware settings.
\end{quote}
\index{uart\_get\_baud\_rate (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.uart_get_baud_rate}\pysiglinewithargsret{unsigned int \bfcode{uart\_get\_baud\_rate}}{struct uart\_port *\emph{ port}, struct ktermios *\emph{ termios}, struct ktermios *\emph{ old}, unsigned int\emph{ min}, unsigned int\emph{ max}}{}
return baud rate for a particular port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct uart\_port * port}}] \leavevmode
uart\_port structure describing the port in question.

\item[{\code{struct ktermios * termios}}] \leavevmode
desired termios settings.

\item[{\code{struct ktermios * old}}] \leavevmode
old termios (or NULL)

\item[{\code{unsigned int min}}] \leavevmode
minimum acceptable baud rate

\item[{\code{unsigned int max}}] \leavevmode
maximum acceptable baud rate

\end{description}

\textbf{Description}
\begin{quote}

Decode the termios structure into a numeric baud rate,
taking account of the magic 38400 baud rate (with spd\_*
flags), and mapping the \code{B0} rate to 9600 baud.

If the new baud rate is invalid, try the old termios setting.
If it's still invalid, we try 9600 baud.

Update the \textbf{termios} structure to reflect the baud rate
we're actually going to be using. Don't do this for the case
where B0 is requested (``hang up'').
\end{quote}
\index{uart\_get\_divisor (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.uart_get_divisor}\pysiglinewithargsret{unsigned int \bfcode{uart\_get\_divisor}}{struct uart\_port *\emph{ port}, unsigned int\emph{ baud}}{}
return uart clock divisor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct uart\_port * port}}] \leavevmode
uart\_port structure describing the port.

\item[{\code{unsigned int baud}}] \leavevmode
desired baud rate

\end{description}

\textbf{Description}
\begin{quote}

Calculate the uart clock divisor for the port.
\end{quote}
\index{uart\_console\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.uart_console_write}\pysiglinewithargsret{void \bfcode{uart\_console\_write}}{struct uart\_port *\emph{ port}, const char *\emph{ s}, unsigned int\emph{ count}, void (*putchar) (struct uart\_port\emph{ *}, int}{}
write a console message to a serial port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct uart\_port * port}}] \leavevmode
the port to write the message

\item[{\code{const char * s}}] \leavevmode
array of characters

\item[{\code{unsigned int count}}] \leavevmode
number of characters in string to write

\item[{\code{void (*)(struct uart\_port *, int) putchar}}] \leavevmode
function to write character to port

\end{description}
\index{uart\_parse\_earlycon (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.uart_parse_earlycon}\pysiglinewithargsret{int \bfcode{uart\_parse\_earlycon}}{char *\emph{ p}, unsigned char *\emph{ iotype}, resource\_size\_t *\emph{ addr}, char **\emph{ options}}{}
Parse earlycon options

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{char * p}}] \leavevmode
ptr to 2nd field (ie., just beyond `\textless{}name\textgreater{},')

\item[{\code{unsigned char * iotype}}] \leavevmode
ptr for decoded iotype (out)

\item[{\code{resource\_size\_t * addr}}] \leavevmode
ptr for decoded mapbase/iobase (out)

\item[{\code{char ** options}}] \leavevmode
ptr for \textless{}options\textgreater{} field; NULL if not present (out)

\end{description}

\textbf{Description}
\begin{quote}
\begin{description}
\item[{Decodes earlycon kernel command line parameters of the form}] \leavevmode
earlycon=\textless{}name\textgreater{},io\textbar{}mmio\textbar{}mmio16\textbar{}mmio32\textbar{}mmio32be\textbar{}mmio32native,\textless{}addr\textgreater{},\textless{}options\textgreater{}
console=\textless{}name\textgreater{},io\textbar{}mmio\textbar{}mmio16\textbar{}mmio32\textbar{}mmio32be\textbar{}mmio32native,\textless{}addr\textgreater{},\textless{}options\textgreater{}

\item[{The optional form}] \leavevmode
earlycon=\textless{}name\textgreater{},0x\textless{}addr\textgreater{},\textless{}options\textgreater{}
console=\textless{}name\textgreater{},0x\textless{}addr\textgreater{},\textless{}options\textgreater{}

\end{description}

is also accepted; the returned \textbf{iotype} will be UPIO\_MEM.

Returns 0 on success or -EINVAL on failure
\end{quote}
\index{uart\_parse\_options (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.uart_parse_options}\pysiglinewithargsret{void \bfcode{uart\_parse\_options}}{const char *\emph{ options}, int *\emph{ baud}, int *\emph{ parity}, int *\emph{ bits}, int *\emph{ flow}}{}
Parse serial port baud/parity/bits/flow control.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * options}}] \leavevmode
pointer to option string

\item[{\code{int * baud}}] \leavevmode
pointer to an `int' variable for the baud rate.

\item[{\code{int * parity}}] \leavevmode
pointer to an `int' variable for the parity.

\item[{\code{int * bits}}] \leavevmode
pointer to an `int' variable for the number of data bits.

\item[{\code{int * flow}}] \leavevmode
pointer to an `int' variable for the flow control character.

\end{description}

\textbf{Description}
\begin{quote}

uart\_parse\_options decodes a string containing the serial console
options.  The format of the string is \textless{}baud\textgreater{}\textless{}parity\textgreater{}\textless{}bits\textgreater{}\textless{}flow\textgreater{},
eg: 115200n8r
\end{quote}
\index{uart\_set\_options (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.uart_set_options}\pysiglinewithargsret{int \bfcode{uart\_set\_options}}{struct uart\_port *\emph{ port}, struct console *\emph{ co}, int\emph{ baud}, int\emph{ parity}, int\emph{ bits}, int\emph{ flow}}{}
setup the serial console parameters

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct uart\_port * port}}] \leavevmode
pointer to the serial ports uart\_port structure

\item[{\code{struct console * co}}] \leavevmode
console pointer

\item[{\code{int baud}}] \leavevmode
baud rate

\item[{\code{int parity}}] \leavevmode
parity character - `n' (none), `o' (odd), `e' (even)

\item[{\code{int bits}}] \leavevmode
number of data bits

\item[{\code{int flow}}] \leavevmode
flow control character - `r' (rts)

\end{description}
\index{uart\_register\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.uart_register_driver}\pysiglinewithargsret{int \bfcode{uart\_register\_driver}}{struct uart\_driver *\emph{ drv}}{}
register a driver with the uart core layer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct uart\_driver * drv}}] \leavevmode
low level driver structure

\end{description}

\textbf{Description}
\begin{quote}

Register a uart driver with the core driver.  We in turn register
with the tty layer, and initialise the core driver per-port state.

We have a proc file in /proc/tty/driver which is named after the
normal driver.

drv-\textgreater{}port should be NULL, and the per-port structures should be
registered using uart\_add\_one\_port after this call has succeeded.
\end{quote}
\index{uart\_unregister\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.uart_unregister_driver}\pysiglinewithargsret{void \bfcode{uart\_unregister\_driver}}{struct uart\_driver *\emph{ drv}}{}
remove a driver from the uart core layer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct uart\_driver * drv}}] \leavevmode
low level driver structure

\end{description}

\textbf{Description}
\begin{quote}

Remove all references to a driver from the core driver.  The low
level driver must have removed all its ports via the
{\hyperref[driver\string-api/miscellaneous:c.uart_remove_one_port]{\emph{\code{uart\_remove\_one\_port()}}}} if it registered them with {\hyperref[driver\string-api/miscellaneous:c.uart_add_one_port]{\emph{\code{uart\_add\_one\_port()}}}}.
(ie, drv-\textgreater{}port == NULL)
\end{quote}
\index{uart\_add\_one\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.uart_add_one_port}\pysiglinewithargsret{int \bfcode{uart\_add\_one\_port}}{struct uart\_driver *\emph{ drv}, struct uart\_port *\emph{ uport}}{}
attach a driver-defined port structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct uart\_driver * drv}}] \leavevmode
pointer to the uart low level driver structure for this port

\item[{\code{struct uart\_port * uport}}] \leavevmode
uart port structure to use for this port.

\end{description}

\textbf{Description}
\begin{quote}

This allows the driver to register its own uart\_port structure
with the core driver.  The main purpose is to allow the low
level uart drivers to expand uart\_port, rather than having yet
more levels of structures.
\end{quote}
\index{uart\_remove\_one\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.uart_remove_one_port}\pysiglinewithargsret{int \bfcode{uart\_remove\_one\_port}}{struct uart\_driver *\emph{ drv}, struct uart\_port *\emph{ uport}}{}
detach a driver defined port structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct uart\_driver * drv}}] \leavevmode
pointer to the uart low level driver structure for this port

\item[{\code{struct uart\_port * uport}}] \leavevmode
uart port structure for this port

\end{description}

\textbf{Description}
\begin{quote}

This unhooks (and hangs up) the specified port structure from the
core driver.  No further calls will be made to the low-level code
for this port.
\end{quote}
\index{uart\_handle\_dcd\_change (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.uart_handle_dcd_change}\pysiglinewithargsret{void \bfcode{uart\_handle\_dcd\_change}}{struct uart\_port *\emph{ uport}, unsigned int\emph{ status}}{}
handle a change of carrier detect state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct uart\_port * uport}}] \leavevmode
uart\_port structure for the open port

\item[{\code{unsigned int status}}] \leavevmode
new carrier detect status, nonzero if active

\end{description}

\textbf{Description}
\begin{quote}

Caller must hold uport-\textgreater{}lock
\end{quote}
\index{uart\_handle\_cts\_change (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.uart_handle_cts_change}\pysiglinewithargsret{void \bfcode{uart\_handle\_cts\_change}}{struct uart\_port *\emph{ uport}, unsigned int\emph{ status}}{}
handle a change of clear-to-send state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct uart\_port * uport}}] \leavevmode
uart\_port structure for the open port

\item[{\code{unsigned int status}}] \leavevmode
new clear to send status, nonzero if active

\end{description}

\textbf{Description}
\begin{quote}

Caller must hold uport-\textgreater{}lock
\end{quote}
\index{uart\_insert\_char (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.uart_insert_char}\pysiglinewithargsret{void \bfcode{uart\_insert\_char}}{struct uart\_port *\emph{ port}, unsigned int\emph{ status}, unsigned int\emph{ overrun}, unsigned int\emph{ ch}, unsigned int\emph{ flag}}{}
push a char to the uart layer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct uart\_port * port}}] \leavevmode
corresponding port

\item[{\code{unsigned int status}}] \leavevmode
state of the serial port RX buffer (LSR for 8250)

\item[{\code{unsigned int overrun}}] \leavevmode
mask of overrun bits in \textbf{status}

\item[{\code{unsigned int ch}}] \leavevmode
character to push

\item[{\code{unsigned int flag}}] \leavevmode
flag for the character (see TTY\_NORMAL and friends)

\end{description}

\textbf{Description}

User is responsible to call tty\_flip\_buffer\_push when they are done with
insertion.
\index{uart\_get\_rs485\_mode (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.uart_get_rs485_mode}\pysiglinewithargsret{void \bfcode{uart\_get\_rs485\_mode}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct serial\_rs485 *\emph{ rs485conf}}{}
retrieve rs485 properties for given uart

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
uart device

\item[{\code{struct serial\_rs485 * rs485conf}}] \leavevmode
output parameter

\end{description}

\textbf{Description}

This function implements the device tree binding described in
Documentation/devicetree/bindings/serial/rs485.txt.
\index{serial8250\_get\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.serial8250_get_port}\pysiglinewithargsret{struct uart\_8250\_port * \bfcode{serial8250\_get\_port}}{int\emph{ line}}{}
retrieve struct uart\_8250\_port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int line}}] \leavevmode
serial line number

\end{description}

\textbf{Description}

This function retrieves struct uart\_8250\_port for the specific line.
This struct \emph{must} \emph{not} be used to perform a 8250 or serial core operation
which is not accessible otherwise. Its only purpose is to make the struct
accessible to the runtime-pm callbacks for context suspend/restore.
The lock assumption made here is none because runtime-pm suspend/resume
callbacks should not be invoked if there is any operation performed on the
port.
\index{serial8250\_suspend\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.serial8250_suspend_port}\pysiglinewithargsret{void \bfcode{serial8250\_suspend\_port}}{int\emph{ line}}{}
suspend one serial port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int line}}] \leavevmode
serial line number

\end{description}

\textbf{Description}
\begin{quote}

Suspend one serial port.
\end{quote}
\index{serial8250\_resume\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.serial8250_resume_port}\pysiglinewithargsret{void \bfcode{serial8250\_resume\_port}}{int\emph{ line}}{}
resume one serial port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int line}}] \leavevmode
serial line number

\end{description}

\textbf{Description}
\begin{quote}

Resume one serial port.
\end{quote}
\index{serial8250\_register\_8250\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.serial8250_register_8250_port}\pysiglinewithargsret{int \bfcode{serial8250\_register\_8250\_port}}{struct uart\_8250\_port *\emph{ up}}{}
register a serial port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct uart\_8250\_port * up}}] \leavevmode
serial port template

\end{description}

\textbf{Description}
\begin{quote}

Configure the serial port specified by the request. If the
port exists and is in use, it is hung up and unregistered
first.

The port is then probed and if necessary the IRQ is autodetected
If this fails an error is returned.

On success the port is ready to use and the line number is returned.
\end{quote}
\index{serial8250\_unregister\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.serial8250_unregister_port}\pysiglinewithargsret{void \bfcode{serial8250\_unregister\_port}}{int\emph{ line}}{}
remove a 16x50 serial port at runtime

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int line}}] \leavevmode
serial line number

\end{description}

\textbf{Description}
\begin{quote}

Remove one serial port.  This may not be called from interrupt
context.  We hand the port back to the our control.
\end{quote}


\chapter{Pulse-Width Modulation (PWM)}
\label{driver-api/miscellaneous:pulse-width-modulation-pwm}
Pulse-width modulation is a modulation technique primarily used to
control power supplied to electrical devices.

The PWM framework provides an abstraction for providers and consumers of
PWM signals. A controller that provides one or more PWM signals is
registered as {\hyperref[driver\string-api/miscellaneous:c.pwm_chip]{\emph{\code{struct pwm\_chip}}}}. Providers
are expected to embed this structure in a driver-specific structure.
This structure contains fields that describe a particular chip.

A chip exposes one or more PWM signal sources, each of which exposed as
a {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{\code{struct pwm\_device}}}}. Operations can be
performed on PWM devices to control the period, duty cycle, polarity and
active state of the signal.

Note that PWM devices are exclusive resources: they can always only be
used by one consumer at a time.
\index{pwm\_polarity (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_polarity}\pysigline{enum \bfcode{pwm\_polarity}}
polarity of a PWM signal

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{PWM\_POLARITY\_NORMAL}}] \leavevmode
a high signal for the duration of the duty-
cycle, followed by a low signal for the remainder of the pulse
period

\item[{\code{PWM\_POLARITY\_INVERSED}}] \leavevmode
a low signal for the duration of the duty-
cycle, followed by a high signal for the remainder of the pulse
period

\end{description}
\index{pwm\_args (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_args}\pysigline{struct \bfcode{pwm\_args}}
board-dependent PWM arguments

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct pwm\PYGZus{}args \PYGZob{}
  unsigned int period;
  enum pwm\PYGZus{}polarity polarity;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{period}}] \leavevmode
reference period

\item[{\code{polarity}}] \leavevmode
reference polarity

\end{description}

\textbf{Description}

This structure describes board-dependent arguments attached to a PWM
device. These arguments are usually retrieved from the PWM lookup table or
device tree.

Do not confuse this with the PWM state: PWM arguments represent the initial
configuration that users want to use on this PWM device rather than the
current PWM hardware state.
\index{pwm\_device (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_device}\pysigline{struct \bfcode{pwm\_device}}
PWM channel object

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct pwm\PYGZus{}device \PYGZob{}
  const char *label;
  unsigned long flags;
  unsigned int hwpwm;
  unsigned int pwm;
  struct pwm\PYGZus{}chip *chip;
  void *chip\PYGZus{}data;
  struct pwm\PYGZus{}args args;
  struct pwm\PYGZus{}state state;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{label}}] \leavevmode
name of the PWM device

\item[{\code{flags}}] \leavevmode
flags associated with the PWM device

\item[{\code{hwpwm}}] \leavevmode
per-chip relative index of the PWM device

\item[{\code{pwm}}] \leavevmode
global index of the PWM device

\item[{\code{chip}}] \leavevmode
PWM chip providing this PWM device

\item[{\code{chip\_data}}] \leavevmode
chip-private data associated with the PWM device

\item[{\code{args}}] \leavevmode
PWM arguments

\item[{\code{state}}] \leavevmode
curent PWM channel state

\end{description}
\index{pwm\_get\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_get_state}\pysiglinewithargsret{void \bfcode{pwm\_get\_state}}{const struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} *\emph{ pwm}, struct pwm\_state *\emph{ state}}{}
retrieve the current PWM state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct pwm\_device * pwm}}] \leavevmode
PWM device

\item[{\code{struct pwm\_state * state}}] \leavevmode
state to fill with the current PWM state

\end{description}
\index{pwm\_init\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_init_state}\pysiglinewithargsret{void \bfcode{pwm\_init\_state}}{const struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} *\emph{ pwm}, struct pwm\_state *\emph{ state}}{}
prepare a new state to be applied with {\hyperref[driver\string-api/miscellaneous:c.pwm_apply_state]{\emph{\code{pwm\_apply\_state()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct pwm\_device * pwm}}] \leavevmode
PWM device

\item[{\code{struct pwm\_state * state}}] \leavevmode
state to fill with the prepared PWM state

\end{description}

\textbf{Description}

This functions prepares a state that can later be tweaked and applied
to the PWM device with {\hyperref[driver\string-api/miscellaneous:c.pwm_apply_state]{\emph{\code{pwm\_apply\_state()}}}}. This is a convenient function
that first retrieves the current PWM state and the replaces the period
and polarity fields with the reference values defined in pwm-\textgreater{}args.
Once the function returns, you can adjust the -\textgreater{}enabled and -\textgreater{}duty\_cycle
fields according to your needs before calling {\hyperref[driver\string-api/miscellaneous:c.pwm_apply_state]{\emph{\code{pwm\_apply\_state()}}}}.

-\textgreater{}duty\_cycle is initially set to zero to avoid cases where the current
-\textgreater{}duty\_cycle value exceed the pwm\_args-\textgreater{}period one, which would trigger
an error if the user calls {\hyperref[driver\string-api/miscellaneous:c.pwm_apply_state]{\emph{\code{pwm\_apply\_state()}}}} without adjusting -\textgreater{}duty\_cycle
first.
\index{pwm\_get\_relative\_duty\_cycle (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_get_relative_duty_cycle}\pysiglinewithargsret{unsigned int \bfcode{pwm\_get\_relative\_duty\_cycle}}{const struct pwm\_state *\emph{ state}, unsigned int\emph{ scale}}{}
Get a relative duty cycle value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct pwm\_state * state}}] \leavevmode
PWM state to extract the duty cycle from

\item[{\code{unsigned int scale}}] \leavevmode
target scale of the relative duty cycle

\end{description}

\textbf{Description}

This functions converts the absolute duty cycle stored in \textbf{state} (expressed
in nanosecond) into a value relative to the period.

For example if you want to get the duty\_cycle expressed in percent, call:

pwm\_get\_state(pwm, \code{state});
duty = pwm\_get\_relative\_duty\_cycle(\code{state}, 100);
\index{pwm\_set\_relative\_duty\_cycle (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_set_relative_duty_cycle}\pysiglinewithargsret{int \bfcode{pwm\_set\_relative\_duty\_cycle}}{struct pwm\_state *\emph{ state}, unsigned int\emph{ duty\_cycle}, unsigned int\emph{ scale}}{}
Set a relative duty cycle value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pwm\_state * state}}] \leavevmode
PWM state to fill

\item[{\code{unsigned int duty\_cycle}}] \leavevmode
relative duty cycle value

\item[{\code{unsigned int scale}}] \leavevmode
scale in which \textbf{duty\_cycle} is expressed

\end{description}

\textbf{Description}

This functions converts a relative into an absolute duty cycle (expressed
in nanoseconds), and puts the result in state-\textgreater{}duty\_cycle.

For example if you want to configure a 50\% duty cycle, call:

pwm\_init\_state(pwm, \code{state});
pwm\_set\_relative\_duty\_cycle(\code{state}, 50, 100);
pwm\_apply\_state(pwm, \code{state});

This functions returns -EINVAL if \textbf{duty\_cycle} and/or \textbf{scale} are
inconsistent (\textbf{scale} == 0 or \textbf{duty\_cycle} \textgreater{} \textbf{scale}).
\index{pwm\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_ops}\pysigline{struct \bfcode{pwm\_ops}}
PWM controller operations

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct pwm\PYGZus{}ops \PYGZob{}
  int (*request)(struct pwm\PYGZus{}chip *chip, struct pwm\PYGZus{}device *pwm);
  void (*free)(struct pwm\PYGZus{}chip *chip, struct pwm\PYGZus{}device *pwm);
  int (*config)(struct pwm\PYGZus{}chip *chip, struct pwm\PYGZus{}device *pwm, int duty\PYGZus{}ns, int period\PYGZus{}ns);
  int (*set\PYGZus{}polarity)(struct pwm\PYGZus{}chip *chip, struct pwm\PYGZus{}device *pwm, enum pwm\PYGZus{}polarity polarity);
  int (*capture)(struct pwm\PYGZus{}chip *chip, struct pwm\PYGZus{}device *pwm, struct pwm\PYGZus{}capture *result, unsigned long timeout);
  int (*enable)(struct pwm\PYGZus{}chip *chip, struct pwm\PYGZus{}device *pwm);
  void (*disable)(struct pwm\PYGZus{}chip *chip, struct pwm\PYGZus{}device *pwm);
  int (*apply)(struct pwm\PYGZus{}chip *chip, struct pwm\PYGZus{}device *pwm, struct pwm\PYGZus{}state *state);
  void (*get\PYGZus{}state)(struct pwm\PYGZus{}chip *chip, struct pwm\PYGZus{}device *pwm, struct pwm\PYGZus{}state *state);
\PYGZsh{}ifdef CONFIG\PYGZus{}DEBUG\PYGZus{}FS;
  void (*dbg\PYGZus{}show)(struct pwm\PYGZus{}chip *chip, struct seq\PYGZus{}file *s);
\PYGZsh{}endif;
  struct module *owner;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{request}}] \leavevmode
optional hook for requesting a PWM

\item[{\code{free}}] \leavevmode
optional hook for freeing a PWM

\item[{\code{config}}] \leavevmode
configure duty cycles and period length for this PWM

\item[{\code{set\_polarity}}] \leavevmode
configure the polarity of this PWM

\item[{\code{capture}}] \leavevmode
capture and report PWM signal

\item[{\code{enable}}] \leavevmode
enable PWM output toggling

\item[{\code{disable}}] \leavevmode
disable PWM output toggling

\item[{\code{apply}}] \leavevmode
atomically apply a new PWM config. The state argument
should be adjusted with the real hardware config (if the
approximate the period or duty\_cycle value, state should
reflect it)

\item[{\code{get\_state}}] \leavevmode
get the current PWM state. This function is only
called once per PWM device when the PWM chip is
registered.

\item[{\code{dbg\_show}}] \leavevmode
optional routine to show contents in debugfs

\item[{\code{owner}}] \leavevmode
helps prevent removal of modules exporting active PWMs

\end{description}
\index{pwm\_chip (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_chip}\pysigline{struct \bfcode{pwm\_chip}}
abstract a PWM controller

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct pwm\PYGZus{}chip \PYGZob{}
  struct device *dev;
  struct list\PYGZus{}head list;
  const struct pwm\PYGZus{}ops *ops;
  int base;
  unsigned int npwm;
  struct pwm\PYGZus{}device *pwms;
  struct pwm\PYGZus{}device * (*of\PYGZus{}xlate)(struct pwm\PYGZus{}chip *pc, const struct of\PYGZus{}phandle\PYGZus{}args *args);
  unsigned int of\PYGZus{}pwm\PYGZus{}n\PYGZus{}cells;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev}}] \leavevmode
device providing the PWMs

\item[{\code{list}}] \leavevmode
list node for internal use

\item[{\code{ops}}] \leavevmode
callbacks for this PWM controller

\item[{\code{base}}] \leavevmode
number of first PWM controlled by this chip

\item[{\code{npwm}}] \leavevmode
number of PWMs controlled by this chip

\item[{\code{pwms}}] \leavevmode
array of PWM devices allocated by the framework

\item[{\code{of\_xlate}}] \leavevmode
request a PWM device given a device tree PWM specifier

\item[{\code{of\_pwm\_n\_cells}}] \leavevmode
number of cells expected in the device tree PWM specifier

\end{description}
\index{pwm\_capture (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_capture}\pysigline{struct \bfcode{pwm\_capture}}
PWM capture data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct pwm\PYGZus{}capture \PYGZob{}
  unsigned int period;
  unsigned int duty\PYGZus{}cycle;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{period}}] \leavevmode
period of the PWM signal (in nanoseconds)

\item[{\code{duty\_cycle}}] \leavevmode
duty cycle of the PWM signal (in nanoseconds)

\end{description}
\index{pwm\_config (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_config}\pysiglinewithargsret{int \bfcode{pwm\_config}}{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} *\emph{ pwm}, int\emph{ duty\_ns}, int\emph{ period\_ns}}{}
change a PWM device configuration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pwm\_device * pwm}}] \leavevmode
PWM device

\item[{\code{int duty\_ns}}] \leavevmode
``on'' time (in nanoseconds)

\item[{\code{int period\_ns}}] \leavevmode
duration (in nanoseconds) of one cycle

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{pwm\_set\_polarity (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_set_polarity}\pysiglinewithargsret{int \bfcode{pwm\_set\_polarity}}{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} *\emph{ pwm}, enum {\hyperref[driver\string-api/miscellaneous:c.pwm_polarity]{\emph{pwm\_polarity}}}\emph{ polarity}}{}
configure the polarity of a PWM signal

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pwm\_device * pwm}}] \leavevmode
PWM device

\item[{\code{enum pwm\_polarity polarity}}] \leavevmode
new polarity of the PWM signal

\end{description}

\textbf{Description}

Note that the polarity cannot be configured while the PWM device is
enabled.

\textbf{Return}

0 on success or a negative error code on failure.
\index{pwm\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_enable}\pysiglinewithargsret{int \bfcode{pwm\_enable}}{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} *\emph{ pwm}}{}
start a PWM output toggling

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pwm\_device * pwm}}] \leavevmode
PWM device

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{pwm\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_disable}\pysiglinewithargsret{void \bfcode{pwm\_disable}}{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} *\emph{ pwm}}{}
stop a PWM output toggling

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pwm\_device * pwm}}] \leavevmode
PWM device

\end{description}
\index{pwm\_set\_chip\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_set_chip_data}\pysiglinewithargsret{int \bfcode{pwm\_set\_chip\_data}}{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} *\emph{ pwm}, void *\emph{ data}}{}
set private chip data for a PWM

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pwm\_device * pwm}}] \leavevmode
PWM device

\item[{\code{void * data}}] \leavevmode
pointer to chip-specific data

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{pwm\_get\_chip\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_get_chip_data}\pysiglinewithargsret{void * \bfcode{pwm\_get\_chip\_data}}{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} *\emph{ pwm}}{}
get private chip data for a PWM

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pwm\_device * pwm}}] \leavevmode
PWM device

\end{description}

\textbf{Return}

A pointer to the chip-private data for the PWM device.
\index{pwmchip\_add\_with\_polarity (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwmchip_add_with_polarity}\pysiglinewithargsret{int \bfcode{pwmchip\_add\_with\_polarity}}{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_chip]{\emph{pwm\_chip}}} *\emph{ chip}, enum {\hyperref[driver\string-api/miscellaneous:c.pwm_polarity]{\emph{pwm\_polarity}}}\emph{ polarity}}{}
register a new PWM chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pwm\_chip * chip}}] \leavevmode
the PWM chip to add

\item[{\code{enum pwm\_polarity polarity}}] \leavevmode
initial polarity of PWM channels

\end{description}

\textbf{Description}

Register a new PWM chip. If chip-\textgreater{}base \textless{} 0 then a dynamically assigned base
will be used. The initial polarity for all channels is specified by the
\textbf{polarity} parameter.

\textbf{Return}

0 on success or a negative error code on failure.
\index{pwmchip\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwmchip_add}\pysiglinewithargsret{int \bfcode{pwmchip\_add}}{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_chip]{\emph{pwm\_chip}}} *\emph{ chip}}{}
register a new PWM chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pwm\_chip * chip}}] \leavevmode
the PWM chip to add

\end{description}

\textbf{Description}

Register a new PWM chip. If chip-\textgreater{}base \textless{} 0 then a dynamically assigned base
will be used. The initial polarity for all channels is normal.

\textbf{Return}

0 on success or a negative error code on failure.
\index{pwmchip\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwmchip_remove}\pysiglinewithargsret{int \bfcode{pwmchip\_remove}}{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_chip]{\emph{pwm\_chip}}} *\emph{ chip}}{}
remove a PWM chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pwm\_chip * chip}}] \leavevmode
the PWM chip to remove

\end{description}

\textbf{Description}

Removes a PWM chip. This function may return busy if the PWM chip provides
a PWM device that is still requested.

\textbf{Return}

0 on success or a negative error code on failure.
\index{pwm\_request (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_request}\pysiglinewithargsret{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} * \bfcode{pwm\_request}}{int\emph{ pwm}, const char *\emph{ label}}{}
request a PWM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int pwm}}] \leavevmode
global PWM device index

\item[{\code{const char * label}}] \leavevmode
PWM device label

\end{description}

\textbf{Description}

This function is deprecated, use {\hyperref[driver\string-api/miscellaneous:c.pwm_get]{\emph{\code{pwm\_get()}}}} instead.

\textbf{Return}

A pointer to a PWM device or an \code{ERR\_PTR()}-encoded error code on
failure.
\index{pwm\_request\_from\_chip (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_request_from_chip}\pysiglinewithargsret{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} * \bfcode{pwm\_request\_from\_chip}}{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_chip]{\emph{pwm\_chip}}} *\emph{ chip}, unsigned int\emph{ index}, const char *\emph{ label}}{}
request a PWM device relative to a PWM chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pwm\_chip * chip}}] \leavevmode
PWM chip

\item[{\code{unsigned int index}}] \leavevmode
per-chip index of the PWM to request

\item[{\code{const char * label}}] \leavevmode
a literal description string of this PWM

\end{description}

\textbf{Return}

A pointer to the PWM device at the given index of the given PWM
chip. A negative error code is returned if the index is not valid for the
specified PWM chip or if the PWM device cannot be requested.
\index{pwm\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_free}\pysiglinewithargsret{void \bfcode{pwm\_free}}{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} *\emph{ pwm}}{}
free a PWM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pwm\_device * pwm}}] \leavevmode
PWM device

\end{description}

\textbf{Description}

This function is deprecated, use {\hyperref[driver\string-api/miscellaneous:c.pwm_put]{\emph{\code{pwm\_put()}}}} instead.
\index{pwm\_apply\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_apply_state}\pysiglinewithargsret{int \bfcode{pwm\_apply\_state}}{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} *\emph{ pwm}, struct pwm\_state *\emph{ state}}{}
atomically apply a new state to a PWM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pwm\_device * pwm}}] \leavevmode
PWM device

\item[{\code{struct pwm\_state * state}}] \leavevmode
new state to apply. This can be adjusted by the PWM driver
if the requested config is not achievable, for example,
-\textgreater{}duty\_cycle and -\textgreater{}period might be approximated.

\end{description}
\index{pwm\_capture (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{int \bfcode{pwm\_capture}}{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} *\emph{ pwm}, struct {\hyperref[driver\string-api/miscellaneous:c.pwm_capture]{\emph{pwm\_capture}}} *\emph{ result}, unsigned long\emph{ timeout}}{}
capture and report a PWM signal

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pwm\_device * pwm}}] \leavevmode
PWM device

\item[{\code{struct pwm\_capture * result}}] \leavevmode
structure to fill with capture result

\item[{\code{unsigned long timeout}}] \leavevmode
time to wait, in milliseconds, before giving up on capture

\end{description}

\textbf{Return}

0 on success or a negative error code on failure.
\index{pwm\_adjust\_config (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_adjust_config}\pysiglinewithargsret{int \bfcode{pwm\_adjust\_config}}{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} *\emph{ pwm}}{}
adjust the current PWM config to the PWM arguments

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pwm\_device * pwm}}] \leavevmode
PWM device

\end{description}

\textbf{Description}

This function will adjust the PWM config to the PWM arguments provided
by the DT or PWM lookup table. This is particularly useful to adapt
the bootloader config to the Linux one.
\index{of\_pwm\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.of_pwm_get}\pysiglinewithargsret{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} * \bfcode{of\_pwm\_get}}{struct device\_node *\emph{ np}, const char *\emph{ con\_id}}{}
request a PWM via the PWM framework

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device\_node * np}}] \leavevmode
device node to get the PWM from

\item[{\code{const char * con\_id}}] \leavevmode
consumer name

\end{description}

\textbf{Description}

Returns the PWM device parsed from the phandle and index specified in the
``pwms'' property of a device tree node or a negative error-code on failure.
Values parsed from the device tree are stored in the returned PWM device
object.

If con\_id is NULL, the first PWM device listed in the ``pwms'' property will
be requested. Otherwise the ``pwm-names'' property is used to do a reverse
lookup of the PWM index. This also means that the ``pwm-names'' property
becomes mandatory for devices that look up the PWM device via the con\_id
parameter.

\textbf{Return}

A pointer to the requested PWM device or an \code{ERR\_PTR()}-encoded
error code on failure.
\index{pwm\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_get}\pysiglinewithargsret{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} * \bfcode{pwm\_get}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ con\_id}}{}
look up and request a PWM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device for PWM consumer

\item[{\code{const char * con\_id}}] \leavevmode
consumer name

\end{description}

\textbf{Description}

Lookup is first attempted using DT. If the device was not instantiated from
a device tree, a PWM chip and a relative index is looked up via a table
supplied by board setup code (see \code{pwm\_add\_table()}).

Once a PWM chip has been found the specified PWM device will be requested
and is ready to be used.

\textbf{Return}

A pointer to the requested PWM device or an \code{ERR\_PTR()}-encoded
error code on failure.
\index{pwm\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.pwm_put}\pysiglinewithargsret{void \bfcode{pwm\_put}}{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} *\emph{ pwm}}{}
release a PWM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct pwm\_device * pwm}}] \leavevmode
PWM device

\end{description}
\index{devm\_pwm\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.devm_pwm_get}\pysiglinewithargsret{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} * \bfcode{devm\_pwm\_get}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ con\_id}}{}
resource managed {\hyperref[driver\string-api/miscellaneous:c.pwm_get]{\emph{\code{pwm\_get()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device for PWM consumer

\item[{\code{const char * con\_id}}] \leavevmode
consumer name

\end{description}

\textbf{Description}

This function performs like {\hyperref[driver\string-api/miscellaneous:c.pwm_get]{\emph{\code{pwm\_get()}}}} but the acquired PWM device will
automatically be released on driver detach.

\textbf{Return}

A pointer to the requested PWM device or an \code{ERR\_PTR()}-encoded
error code on failure.
\index{devm\_of\_pwm\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.devm_of_pwm_get}\pysiglinewithargsret{struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} * \bfcode{devm\_of\_pwm\_get}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct device\_node *\emph{ np}, const char *\emph{ con\_id}}{}
resource managed {\hyperref[driver\string-api/miscellaneous:c.of_pwm_get]{\emph{\code{of\_pwm\_get()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device for PWM consumer

\item[{\code{struct device\_node * np}}] \leavevmode
device node to get the PWM from

\item[{\code{const char * con\_id}}] \leavevmode
consumer name

\end{description}

\textbf{Description}

This function performs like {\hyperref[driver\string-api/miscellaneous:c.of_pwm_get]{\emph{\code{of\_pwm\_get()}}}} but the acquired PWM device will
automatically be released on driver detach.

\textbf{Return}

A pointer to the requested PWM device or an \code{ERR\_PTR()}-encoded
error code on failure.
\index{devm\_pwm\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/miscellaneous:c.devm_pwm_put}\pysiglinewithargsret{void \bfcode{devm\_pwm\_put}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct {\hyperref[driver\string-api/miscellaneous:c.pwm_device]{\emph{pwm\_device}}} *\emph{ pwm}}{}
resource managed {\hyperref[driver\string-api/miscellaneous:c.pwm_put]{\emph{\code{pwm\_put()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device for PWM consumer

\item[{\code{struct pwm\_device * pwm}}] \leavevmode
PWM device

\end{description}

\textbf{Description}

Release a PWM previously allocated using {\hyperref[driver\string-api/miscellaneous:c.devm_pwm_get]{\emph{\code{devm\_pwm\_get()}}}}. Calling this
function is usually not needed because devm-allocated resources are
automatically released on driver detach.


\chapter{W1: Dallas' 1-wire bus}
\label{driver-api/w1::doc}\label{driver-api/w1:w1-dallas-1-wire-bus}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
David Fries

\end{description}\end{quote}


\section{W1 API internal to the kernel}
\label{driver-api/w1:w1-api-internal-to-the-kernel}

\subsection{W1 API internal to the kernel}
\label{driver-api/w1:id1}

\subsubsection{include/linux/w1.h}
\label{driver-api/w1:include-linux-w1-h}
W1 kernel API functions.
\index{w1\_reg\_num (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_reg_num}\pysigline{struct \bfcode{w1\_reg\_num}}
broken out slave device id

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct w1\PYGZus{}reg\PYGZus{}num \PYGZob{}
\PYGZsh{}if defined(\PYGZus{}\PYGZus{}LITTLE\PYGZus{}ENDIAN\PYGZus{}BITFIELD);
  \PYGZus{}\PYGZus{}u64 family:8,id:48, crc:8;
\PYGZsh{}elif defined(\PYGZus{}\PYGZus{}BIG\PYGZus{}ENDIAN\PYGZus{}BITFIELD);
  \PYGZus{}\PYGZus{}u64 crc:8,id:48, family:8;
\PYGZsh{}else;
\PYGZsh{}error \PYGZdq{}Please fix \PYGZlt{}asm/byteorder.h\PYGZgt{}\PYGZdq{};
\PYGZsh{}endif;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{family}}] \leavevmode
identifies the type of device

\item[{\code{id}}] \leavevmode
along with family is the unique device id

\item[{\code{crc}}] \leavevmode
checksum of the other bytes

\item[{\code{crc}}] \leavevmode
checksum of the other bytes

\item[{\code{id}}] \leavevmode
along with family is the unique device id

\item[{\code{family}}] \leavevmode
identifies the type of device

\end{description}
\index{w1\_slave (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_slave}\pysigline{struct \bfcode{w1\_slave}}
holds a single slave device on the bus

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct w1\PYGZus{}slave \PYGZob{}
  struct module           *owner;
  unsigned char           name[W1\PYGZus{}MAXNAMELEN];
  struct list\PYGZus{}head        w1\PYGZus{}slave\PYGZus{}entry;
  struct w1\PYGZus{}reg\PYGZus{}num       reg\PYGZus{}num;
  atomic\PYGZus{}t refcnt;
  int ttl;
  unsigned long           flags;
  struct w1\PYGZus{}master        *master;
  struct w1\PYGZus{}family        *family;
  void *family\PYGZus{}data;
  struct device           dev;
  struct device           *hwmon;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{owner}}] \leavevmode
Points to the one wire ``wire'' kernel module.

\item[{\code{name}}] \leavevmode
Device id is ascii.

\item[{\code{w1\_slave\_entry}}] \leavevmode
data for the linked list

\item[{\code{reg\_num}}] \leavevmode
the slave id in binary

\item[{\code{refcnt}}] \leavevmode
reference count, delete when 0

\item[{\code{ttl}}] \leavevmode
decrement per search this slave isn't found, deatch at 0

\item[{\code{flags}}] \leavevmode
bit flags for W1\_SLAVE\_ACTIVE W1\_SLAVE\_DETACH

\item[{\code{master}}] \leavevmode
bus which this slave is on

\item[{\code{family}}] \leavevmode
module for device family type

\item[{\code{family\_data}}] \leavevmode
pointer for use by the family module

\item[{\code{dev}}] \leavevmode
kernel device identifier

\item[{\code{hwmon}}] \leavevmode
pointer to hwmon device

\end{description}
\index{w1\_bus\_master (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_bus_master}\pysigline{struct \bfcode{w1\_bus\_master}}
operations available on a bus master

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct w1\PYGZus{}bus\PYGZus{}master \PYGZob{}
  void *data;
  u8 (*read\PYGZus{}bit)(void *);
  void (*write\PYGZus{}bit)(void *, u8);
  u8 (*touch\PYGZus{}bit)(void *, u8);
  u8 (*read\PYGZus{}byte)(void *);
  void (*write\PYGZus{}byte)(void *, u8);
  u8 (*read\PYGZus{}block)(void *, u8 *, int);
  void (*write\PYGZus{}block)(void *, const u8 *, int);
  u8 (*triplet)(void *, u8);
  u8 (*reset\PYGZus{}bus)(void *);
  u8 (*set\PYGZus{}pullup)(void *, int);
  void (*search)(void *, struct w1\PYGZus{}master *, u8, w1\PYGZus{}slave\PYGZus{}found\PYGZus{}callback);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{data}}] \leavevmode
the first parameter in all the functions below

\item[{\code{read\_bit}}] \leavevmode
Sample the line level \textbf{return} the level read (0 or 1)

\item[{\code{write\_bit}}] \leavevmode
Sets the line level

\item[{\code{touch\_bit}}] \leavevmode
the lowest-level function for devices that really support the
1-wire protocol.
touch\_bit(0) = write-0 cycle
touch\_bit(1) = write-1 / read cycle
\textbf{return} the bit read (0 or 1)

\item[{\code{read\_byte}}] \leavevmode
Reads a bytes. Same as 8 touch\_bit(1) calls.
\textbf{return} the byte read

\item[{\code{write\_byte}}] \leavevmode
Writes a byte. Same as 8 touch\_bit(x) calls.

\item[{\code{read\_block}}] \leavevmode
Same as a series of \code{read\_byte()} calls
\textbf{return} the number of bytes read

\item[{\code{write\_block}}] \leavevmode
Same as a series of \code{write\_byte()} calls

\item[{\code{triplet}}] \leavevmode
Combines two reads and a smart write for ROM searches
\textbf{return} bit0=Id bit1=comp\_id bit2=dir\_taken

\item[{\code{reset\_bus}}] \leavevmode
long write-0 with a read for the presence pulse detection
\textbf{return} -1=Error, 0=Device present, 1=No device present

\item[{\code{set\_pullup}}] \leavevmode
Put out a strong pull-up pulse of the specified duration.
\textbf{return} -1=Error, 0=completed

\item[{\code{search}}] \leavevmode
Really nice hardware can handles the different types of ROM search
w1\_master* is passed to the slave found callback.
u8 is search\_type, W1\_SEARCH or W1\_ALARM\_SEARCH

\end{description}

\textbf{Note}

read\_bit and write\_bit are very low level functions and should only
be used with hardware that doesn't really support 1-wire operations,
like a parallel/serial port.
Either define read\_bit and write\_bit OR define, at minimum, touch\_bit and
reset\_bus.
\index{w1\_master\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_master_flags}\pysigline{enum \bfcode{w1\_master\_flags}}
bitfields used in w1\_master.flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{W1\_ABORT\_SEARCH}}] \leavevmode
abort searching early on shutdown

\item[{\code{W1\_WARN\_MAX\_COUNT}}] \leavevmode
limit warning when the maximum count is reached

\end{description}
\index{w1\_master (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_master}\pysigline{struct \bfcode{w1\_master}}
one per bus master

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct w1\PYGZus{}master \PYGZob{}
  struct list\PYGZus{}head        w1\PYGZus{}master\PYGZus{}entry;
  struct module           *owner;
  unsigned char           name[W1\PYGZus{}MAXNAMELEN];
  struct mutex            list\PYGZus{}mutex;
  struct list\PYGZus{}head        slist;
  struct list\PYGZus{}head        async\PYGZus{}list;
  int max\PYGZus{}slave\PYGZus{}count, slave\PYGZus{}count;
  unsigned long           attempts;
  int slave\PYGZus{}ttl;
  int initialized;
  u32 id;
  int search\PYGZus{}count;
  u64 search\PYGZus{}id;
  atomic\PYGZus{}t refcnt;
  void *priv;
  int enable\PYGZus{}pullup;
  int pullup\PYGZus{}duration;
  long flags;
  struct task\PYGZus{}struct      *thread;
  struct mutex            mutex;
  struct mutex            bus\PYGZus{}mutex;
  struct device\PYGZus{}driver    *driver;
  struct device           dev;
  struct w1\PYGZus{}bus\PYGZus{}master    *bus\PYGZus{}master;
  u32 seq;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{w1\_master\_entry}}] \leavevmode
master linked list

\item[{\code{owner}}] \leavevmode
module owner

\item[{\code{name}}] \leavevmode
dynamically allocate bus name

\item[{\code{list\_mutex}}] \leavevmode
protect slist and async\_list

\item[{\code{slist}}] \leavevmode
linked list of slaves

\item[{\code{async\_list}}] \leavevmode
linked list of netlink commands to execute

\item[{\code{max\_slave\_count}}] \leavevmode
maximum number of slaves to search for at a time

\item[{\code{slave\_count}}] \leavevmode
current number of slaves known

\item[{\code{attempts}}] \leavevmode
number of searches ran

\item[{\code{slave\_ttl}}] \leavevmode
number of searches before a slave is timed out

\item[{\code{initialized}}] \leavevmode
prevent init/removal race conditions

\item[{\code{id}}] \leavevmode
w1 bus number

\item[{\code{search\_count}}] \leavevmode
number of automatic searches to run, -1 unlimited

\item[{\code{search\_id}}] \leavevmode
allows continuing a search

\item[{\code{refcnt}}] \leavevmode
reference count

\item[{\code{priv}}] \leavevmode
private data storage

\item[{\code{enable\_pullup}}] \leavevmode
allows a strong pullup

\item[{\code{pullup\_duration}}] \leavevmode
time for the next strong pullup

\item[{\code{flags}}] \leavevmode
one of w1\_master\_flags

\item[{\code{thread}}] \leavevmode
thread for bus search and netlink commands

\item[{\code{mutex}}] \leavevmode
protect most of w1\_master

\item[{\code{bus\_mutex}}] \leavevmode
pretect concurrent bus access

\item[{\code{driver}}] \leavevmode
sysfs driver

\item[{\code{dev}}] \leavevmode
sysfs device

\item[{\code{bus\_master}}] \leavevmode
io operations available

\item[{\code{seq}}] \leavevmode
sequence number used for netlink broadcasts

\end{description}
\index{w1\_family\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_family_ops}\pysigline{struct \bfcode{w1\_family\_ops}}
operations for a family type

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct w1\PYGZus{}family\PYGZus{}ops \PYGZob{}
  int (*add\PYGZus{}slave)(struct w1\PYGZus{}slave *sl);
  void (*remove\PYGZus{}slave)(struct w1\PYGZus{}slave *sl);
  const struct attribute\PYGZus{}group **groups;
  const struct hwmon\PYGZus{}chip\PYGZus{}info *chip\PYGZus{}info;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{add\_slave}}] \leavevmode
add\_slave

\item[{\code{remove\_slave}}] \leavevmode
remove\_slave

\item[{\code{groups}}] \leavevmode
sysfs group

\item[{\code{chip\_info}}] \leavevmode
pointer to struct hwmon\_chip\_info

\end{description}
\index{w1\_family (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_family}\pysigline{struct \bfcode{w1\_family}}
reference counted family structure.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct w1\PYGZus{}family \PYGZob{}
  struct list\PYGZus{}head        family\PYGZus{}entry;
  u8 fid;
  struct w1\PYGZus{}family\PYGZus{}ops    *fops;
  atomic\PYGZus{}t refcnt;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{family\_entry}}] \leavevmode
family linked list

\item[{\code{fid}}] \leavevmode
8 bit family identifier

\item[{\code{fops}}] \leavevmode
operations for this family

\item[{\code{refcnt}}] \leavevmode
reference counter

\end{description}
\index{module\_w1\_family (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.module_w1_family}\pysiglinewithargsret{\bfcode{module\_w1\_family}}{\emph{\_\_w1\_family}}{}
Helper macro for registering a 1-Wire families

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_w1\_family}}] \leavevmode
w1\_family struct

\end{description}

\textbf{Description}

Helper macro for 1-Wire families which do not do anything special in module
init/exit. This eliminates a lot of boilerplate. Each module may only
use this macro once, and calling it replaces {\hyperref[driver\string-api/basics:c.module_init]{\emph{\code{module\_init()}}}} and {\hyperref[driver\string-api/basics:c.module_exit]{\emph{\code{module\_exit()}}}}


\subsubsection{drivers/w1/w1.c}
\label{driver-api/w1:drivers-w1-w1-c}
W1 core functions.
\index{w1\_search (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_search}\pysiglinewithargsret{void \bfcode{w1\_search}}{struct {\hyperref[driver\string-api/w1:c.w1_master]{\emph{w1\_master}}} *\emph{ dev}, u8\emph{ search\_type}, w1\_slave\_found\_callback\emph{ cb}}{}
Performs a ROM Search \& registers any devices found.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_master * dev}}] \leavevmode
The master device to search

\item[{\code{u8 search\_type}}] \leavevmode
W1\_SEARCH to search all devices, or W1\_ALARM\_SEARCH
to return only devices in the alarmed state

\item[{\code{w1\_slave\_found\_callback cb}}] \leavevmode
Function to call when a device is found

\end{description}

\textbf{Description}

The 1-wire search is a simple binary tree search.
For each bit of the address, we read two bits and write one bit.
The bit written will put to sleep all devies that don't match that bit.
When the two reads differ, the direction choice is obvious.
When both bits are 0, we must choose a path to take.
When we can scan all 64 bits without having to choose a path, we are done.

See ``Application note 187 1-wire search algorithm'' at www.maxim-ic.com
\index{w1\_process\_callbacks (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_process_callbacks}\pysiglinewithargsret{int \bfcode{w1\_process\_callbacks}}{struct {\hyperref[driver\string-api/w1:c.w1_master]{\emph{w1\_master}}} *\emph{ dev}}{}
execute each dev-\textgreater{}async\_list callback entry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_master * dev}}] \leavevmode
w1\_master device

\end{description}

\textbf{Description}

The w1 master list\_mutex must be held.

\textbf{Return}

1 if there were commands to executed 0 otherwise


\subsubsection{drivers/w1/w1\_family.c}
\label{driver-api/w1:drivers-w1-w1-family-c}
Allows registering device family operations.
\index{w1\_register\_family (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_register_family}\pysiglinewithargsret{int \bfcode{w1\_register\_family}}{struct {\hyperref[driver\string-api/w1:c.w1_family]{\emph{w1\_family}}} *\emph{ newf}}{}
register a device family driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_family * newf}}] \leavevmode
family to register

\end{description}
\index{w1\_unregister\_family (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_unregister_family}\pysiglinewithargsret{void \bfcode{w1\_unregister\_family}}{struct {\hyperref[driver\string-api/w1:c.w1_family]{\emph{w1\_family}}} *\emph{ fent}}{}
unregister a device family driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_family * fent}}] \leavevmode
family to unregister

\end{description}


\subsubsection{drivers/w1/w1\_internal.h}
\label{driver-api/w1:drivers-w1-w1-internal-h}
W1 internal initialization for master devices.
\index{w1\_async\_cmd (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_async_cmd}\pysigline{struct \bfcode{w1\_async\_cmd}}
execute callback from the w1\_process kthread

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct w1\PYGZus{}async\PYGZus{}cmd \PYGZob{}
  struct list\PYGZus{}head        async\PYGZus{}entry;
  void (*cb)(struct w1\PYGZus{}master *dev, struct w1\PYGZus{}async\PYGZus{}cmd *async\PYGZus{}cmd);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{async\_entry}}] \leavevmode
link entry

\item[{\code{cb}}] \leavevmode
callback function, must list\_del and destroy this list before
returning

\end{description}

\textbf{Description}

When inserted into the w1\_master async\_list, w1\_process will execute
the callback.  Embed this into the structure with the command details.


\subsubsection{drivers/w1/w1\_int.c}
\label{driver-api/w1:drivers-w1-w1-int-c}
W1 internal initialization for master devices.
\index{w1\_add\_master\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_add_master_device}\pysiglinewithargsret{int \bfcode{w1\_add\_master\_device}}{struct {\hyperref[driver\string-api/w1:c.w1_bus_master]{\emph{w1\_bus\_master}}} *\emph{ master}}{}
registers a new master device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_bus\_master * master}}] \leavevmode
master bus device to register

\end{description}
\index{w1\_remove\_master\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_remove_master_device}\pysiglinewithargsret{void \bfcode{w1\_remove\_master\_device}}{struct {\hyperref[driver\string-api/w1:c.w1_bus_master]{\emph{w1\_bus\_master}}} *\emph{ bm}}{}
unregister a master device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_bus\_master * bm}}] \leavevmode
master bus device to remove

\end{description}


\subsubsection{drivers/w1/w1\_netlink.h}
\label{driver-api/w1:drivers-w1-w1-netlink-h}
W1 external netlink API structures and commands.
\index{w1\_cn\_msg\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_cn_msg_flags}\pysigline{enum \bfcode{w1\_cn\_msg\_flags}}
bitfield flags for struct cn\_msg.flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{W1\_CN\_BUNDLE}}] \leavevmode
Request bundling replies into fewer messagse.  Be prepared
to handle multiple struct cn\_msg, struct w1\_netlink\_msg, and
struct w1\_netlink\_cmd in one packet.

\end{description}
\index{w1\_netlink\_message\_types (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_netlink_message_types}\pysigline{enum \bfcode{w1\_netlink\_message\_types}}
message type

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{W1\_SLAVE\_ADD}}] \leavevmode
notification that a slave device was added

\item[{\code{W1\_SLAVE\_REMOVE}}] \leavevmode
notification that a slave device was removed

\item[{\code{W1\_MASTER\_ADD}}] \leavevmode
notification that a new bus master was added

\item[{\code{W1\_MASTER\_REMOVE}}] \leavevmode
notification that a bus masterwas removed

\item[{\code{W1\_MASTER\_CMD}}] \leavevmode
initiate operations on a specific master

\item[{\code{W1\_SLAVE\_CMD}}] \leavevmode
sends reset, selects the slave, then does a read/write/touch
operation

\item[{\code{W1\_LIST\_MASTERS}}] \leavevmode
used to determine the bus master identifiers

\end{description}
\index{w1\_netlink\_msg (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_netlink_msg}\pysigline{struct \bfcode{w1\_netlink\_msg}}
holds w1 message type, id, and result

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct w1\PYGZus{}netlink\PYGZus{}msg \PYGZob{}
  \PYGZus{}\PYGZus{}u8 type;
  \PYGZus{}\PYGZus{}u8 status;
  \PYGZus{}\PYGZus{}u16 len;
  union \PYGZob{}
    \PYGZus{}\PYGZus{}u8 id[8];
    struct w1\PYGZus{}mst \PYGZob{}
      \PYGZus{}\PYGZus{}u32 id;
      \PYGZus{}\PYGZus{}u32 res;
    \PYGZcb{} mst;
  \PYGZcb{} id;
  \PYGZus{}\PYGZus{}u8 data[0];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{type}}] \leavevmode
one of enum w1\_netlink\_message\_types

\item[{\code{status}}] \leavevmode
kernel feedback for success 0 or errno failure value

\item[{\code{len}}] \leavevmode
length of data following w1\_netlink\_msg

\item[{\code{id}}] \leavevmode
union holding bus master id (msg.id) and slave device id (id{[}8{]}).

\item[{\code{id.id}}] \leavevmode
Slave ID (8 bytes)

\item[{\code{id.mst}}] \leavevmode
bus master identification

\item[{\code{id.mst.id}}] \leavevmode
bus master ID

\item[{\code{id.mst.res}}] \leavevmode
bus master reserved

\item[{\code{data}}] \leavevmode
start address of any following data

\end{description}

\textbf{Description}

The base message structure for w1 messages over netlink.
The netlink connector data sequence is, struct nlmsghdr, struct cn\_msg,
then one or more struct w1\_netlink\_msg (each with optional data).
\index{w1\_commands (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_commands}\pysigline{enum \bfcode{w1\_commands}}
commands available for master or slave operations

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{W1\_CMD\_READ}}] \leavevmode
read len bytes

\item[{\code{W1\_CMD\_WRITE}}] \leavevmode
write len bytes

\item[{\code{W1\_CMD\_SEARCH}}] \leavevmode
initiate a standard search, returns only the slave
devices found during that search

\item[{\code{W1\_CMD\_ALARM\_SEARCH}}] \leavevmode
search for devices that are currently alarming

\item[{\code{W1\_CMD\_TOUCH}}] \leavevmode
Touches a series of bytes.

\item[{\code{W1\_CMD\_RESET}}] \leavevmode
sends a bus reset on the given master

\item[{\code{W1\_CMD\_SLAVE\_ADD}}] \leavevmode
adds a slave to the given master,
8 byte slave id at data{[}0{]}

\item[{\code{W1\_CMD\_SLAVE\_REMOVE}}] \leavevmode
removes a slave to the given master,
8 byte slave id at data{[}0{]}

\item[{\code{W1\_CMD\_LIST\_SLAVES}}] \leavevmode
list of slaves registered on this master

\item[{\code{W1\_CMD\_MAX}}] \leavevmode
number of available commands

\end{description}
\index{w1\_netlink\_cmd (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_netlink_cmd}\pysigline{struct \bfcode{w1\_netlink\_cmd}}
holds the command and data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct w1\PYGZus{}netlink\PYGZus{}cmd \PYGZob{}
  \PYGZus{}\PYGZus{}u8 cmd;
  \PYGZus{}\PYGZus{}u8 res;
  \PYGZus{}\PYGZus{}u16 len;
  \PYGZus{}\PYGZus{}u8 data[0];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{cmd}}] \leavevmode
one of enum w1\_commands

\item[{\code{res}}] \leavevmode
reserved

\item[{\code{len}}] \leavevmode
length of data following w1\_netlink\_cmd

\item[{\code{data}}] \leavevmode
start address of any following data

\end{description}

\textbf{Description}

One or more struct w1\_netlink\_cmd is placed starting at w1\_netlink\_msg.data
each with optional data.


\subsubsection{drivers/w1/w1\_io.c}
\label{driver-api/w1:drivers-w1-w1-io-c}
W1 input/output.
\index{w1\_touch\_bit (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_touch_bit}\pysiglinewithargsret{u8 \bfcode{w1\_touch\_bit}}{struct {\hyperref[driver\string-api/w1:c.w1_master]{\emph{w1\_master}}} *\emph{ dev}, int\emph{ bit}}{}
Generates a write-0 or write-1 cycle and samples the level.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_master * dev}}] \leavevmode
the master device

\item[{\code{int bit}}] \leavevmode
0 - write a 0, 1 - write a 0 read the level

\end{description}
\index{w1\_write\_8 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_write_8}\pysiglinewithargsret{void \bfcode{w1\_write\_8}}{struct {\hyperref[driver\string-api/w1:c.w1_master]{\emph{w1\_master}}} *\emph{ dev}, u8\emph{ byte}}{}
Writes 8 bits.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_master * dev}}] \leavevmode
the master device

\item[{\code{u8 byte}}] \leavevmode
the byte to write

\end{description}
\index{w1\_triplet (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_triplet}\pysiglinewithargsret{u8 \bfcode{w1\_triplet}}{struct {\hyperref[driver\string-api/w1:c.w1_master]{\emph{w1\_master}}} *\emph{ dev}, int\emph{ bdir}}{}~\begin{itemize}
\item {} 
Does a triplet - used for searching ROM addresses.

\end{itemize}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_master * dev}}] \leavevmode
the master device

\item[{\code{int bdir}}] \leavevmode
the bit to write if both id\_bit and comp\_bit are 0

\end{description}

\textbf{Description}
\begin{description}
\item[{Return bits:}] \leavevmode
bit 0 = id\_bit
bit 1 = comp\_bit
bit 2 = dir\_taken

\end{description}

If both bits 0 \& 1 are set, the search should be restarted.

\textbf{Return}

bit fields - see above
\index{w1\_read\_8 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_read_8}\pysiglinewithargsret{u8 \bfcode{w1\_read\_8}}{struct {\hyperref[driver\string-api/w1:c.w1_master]{\emph{w1\_master}}} *\emph{ dev}}{}
Reads 8 bits.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_master * dev}}] \leavevmode
the master device

\end{description}

\textbf{Return}

the byte read
\index{w1\_write\_block (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_write_block}\pysiglinewithargsret{void \bfcode{w1\_write\_block}}{struct {\hyperref[driver\string-api/w1:c.w1_master]{\emph{w1\_master}}} *\emph{ dev}, const u8 *\emph{ buf}, int\emph{ len}}{}
Writes a series of bytes.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_master * dev}}] \leavevmode
the master device

\item[{\code{const u8 * buf}}] \leavevmode
pointer to the data to write

\item[{\code{int len}}] \leavevmode
the number of bytes to write

\end{description}
\index{w1\_touch\_block (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_touch_block}\pysiglinewithargsret{void \bfcode{w1\_touch\_block}}{struct {\hyperref[driver\string-api/w1:c.w1_master]{\emph{w1\_master}}} *\emph{ dev}, u8 *\emph{ buf}, int\emph{ len}}{}
Touches a series of bytes.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_master * dev}}] \leavevmode
the master device

\item[{\code{u8 * buf}}] \leavevmode
pointer to the data to write

\item[{\code{int len}}] \leavevmode
the number of bytes to write

\end{description}
\index{w1\_read\_block (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_read_block}\pysiglinewithargsret{u8 \bfcode{w1\_read\_block}}{struct {\hyperref[driver\string-api/w1:c.w1_master]{\emph{w1\_master}}} *\emph{ dev}, u8 *\emph{ buf}, int\emph{ len}}{}
Reads a series of bytes.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_master * dev}}] \leavevmode
the master device

\item[{\code{u8 * buf}}] \leavevmode
pointer to the buffer to fill

\item[{\code{int len}}] \leavevmode
the number of bytes to read

\end{description}

\textbf{Return}

the number of bytes read
\index{w1\_reset\_bus (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_reset_bus}\pysiglinewithargsret{int \bfcode{w1\_reset\_bus}}{struct {\hyperref[driver\string-api/w1:c.w1_master]{\emph{w1\_master}}} *\emph{ dev}}{}
Issues a reset bus sequence.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_master * dev}}] \leavevmode
the master device

\end{description}

\textbf{Return}

0=Device present, 1=No device present or error
\index{w1\_reset\_select\_slave (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_reset_select_slave}\pysiglinewithargsret{int \bfcode{w1\_reset\_select\_slave}}{struct {\hyperref[driver\string-api/w1:c.w1_slave]{\emph{w1\_slave}}} *\emph{ sl}}{}
reset and select a slave

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_slave * sl}}] \leavevmode
the slave to select

\end{description}

\textbf{Description}

Resets the bus and then selects the slave by sending either a skip rom
or a rom match.  A skip rom is issued if there is only one device
registered on the bus.
The w1 master lock must be held.

\textbf{Return}

0=success, anything else=error
\index{w1\_reset\_resume\_command (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_reset_resume_command}\pysiglinewithargsret{int \bfcode{w1\_reset\_resume\_command}}{struct {\hyperref[driver\string-api/w1:c.w1_master]{\emph{w1\_master}}} *\emph{ dev}}{}
resume instead of another match ROM

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_master * dev}}] \leavevmode
the master device

\end{description}

\textbf{Description}

When the workflow with a slave amongst many requires several
successive commands a reset between each, this function is similar
to doing a reset then a match ROM for the last matched ROM. The
advantage being that the matched ROM step is skipped in favor of the
resume command. The slave must support the command of course.

If the bus has only one slave, traditionnaly the match ROM is skipped
and a ``SKIP ROM'' is done for efficiency. On multi-slave busses, this
doesn't work of course, but the resume command is the next best thing.

The w1 master lock must be held.
\index{w1\_next\_pullup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_next_pullup}\pysiglinewithargsret{void \bfcode{w1\_next\_pullup}}{struct {\hyperref[driver\string-api/w1:c.w1_master]{\emph{w1\_master}}} *\emph{ dev}, int\emph{ delay}}{}
register for a strong pullup

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_master * dev}}] \leavevmode
the master device

\item[{\code{int delay}}] \leavevmode
time in milliseconds

\end{description}

\textbf{Description}

Put out a strong pull-up of the specified duration after the next write
operation.  Not all hardware supports strong pullups.  Hardware that
doesn't support strong pullups will sleep for the given time after the
write operation without a strong pullup.  This is a one shot request for
the next write, specifying zero will clear a previous request.
The w1 master lock must be held.

\textbf{Return}

0=success, anything else=error
\index{w1\_write\_bit (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_write_bit}\pysiglinewithargsret{void \bfcode{w1\_write\_bit}}{struct {\hyperref[driver\string-api/w1:c.w1_master]{\emph{w1\_master}}} *\emph{ dev}, int\emph{ bit}}{}
Generates a write-0 or write-1 cycle.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_master * dev}}] \leavevmode
the master device

\item[{\code{int bit}}] \leavevmode
bit to write

\end{description}

\textbf{Description}

Only call if dev-\textgreater{}bus\_master-\textgreater{}touch\_bit is NULL
\index{w1\_pre\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_pre_write}\pysiglinewithargsret{void \bfcode{w1\_pre\_write}}{struct {\hyperref[driver\string-api/w1:c.w1_master]{\emph{w1\_master}}} *\emph{ dev}}{}
pre-write operations

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_master * dev}}] \leavevmode
the master device

\end{description}

\textbf{Description}

Pre-write operation, currently only supporting strong pullups.
Program the hardware for a strong pullup, if one has been requested and
the hardware supports it.
\index{w1\_post\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_post_write}\pysiglinewithargsret{void \bfcode{w1\_post\_write}}{struct {\hyperref[driver\string-api/w1:c.w1_master]{\emph{w1\_master}}} *\emph{ dev}}{}
post-write options

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_master * dev}}] \leavevmode
the master device

\end{description}

\textbf{Description}

Post-write operation, currently only supporting strong pullups.
If a strong pullup was requested, clear it if the hardware supports
them, or execute the delay otherwise, in either case clear the request.
\index{w1\_read\_bit (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/w1:c.w1_read_bit}\pysiglinewithargsret{u8 \bfcode{w1\_read\_bit}}{struct {\hyperref[driver\string-api/w1:c.w1_master]{\emph{w1\_master}}} *\emph{ dev}}{}
Generates a write-1 cycle and samples the level.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct w1\_master * dev}}] \leavevmode
the master device

\end{description}

\textbf{Description}

Only call if dev-\textgreater{}bus\_master-\textgreater{}touch\_bit is NULL


\chapter{RapidIO Subsystem Guide}
\label{driver-api/rapidio:rapidio-subsystem-guide}\label{driver-api/rapidio::doc}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Matt Porter

\end{description}\end{quote}


\section{Introduction}
\label{driver-api/rapidio:introduction}
RapidIO is a high speed switched fabric interconnect with features aimed
at the embedded market. RapidIO provides support for memory-mapped I/O
as well as message-based transactions over the switched fabric network.
RapidIO has a standardized discovery mechanism not unlike the PCI bus
standard that allows simple detection of devices in a network.

This documentation is provided for developers intending to support
RapidIO on new architectures, write new drivers, or to understand the
subsystem internals.


\section{Known Bugs and Limitations}
\label{driver-api/rapidio:known-bugs-and-limitations}

\subsection{Bugs}
\label{driver-api/rapidio:bugs}
None. ;)


\subsection{Limitations}
\label{driver-api/rapidio:limitations}\begin{enumerate}
\item {} 
Access/management of RapidIO memory regions is not supported

\item {} 
Multiple host enumeration is not supported

\end{enumerate}


\section{RapidIO driver interface}
\label{driver-api/rapidio:rapidio-driver-interface}
Drivers are provided a set of calls in order to interface with the
subsystem to gather info on devices, request/map memory region
resources, and manage mailboxes/doorbells.


\subsection{Functions}
\label{driver-api/rapidio:functions}\index{rio\_local\_read\_config\_32 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_local_read_config_32}\pysiglinewithargsret{int \bfcode{rio\_local\_read\_config\_32}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, u32\emph{ offset}, u32 *\emph{ data}}{}
Read 32 bits from local configuration space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port

\item[{\code{u32 offset}}] \leavevmode
Offset into local configuration space

\item[{\code{u32 * data}}] \leavevmode
Pointer to read data into

\end{description}

\textbf{Description}

Reads 32 bits of data from the specified offset within the local
device's configuration space.
\index{rio\_local\_write\_config\_32 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_local_write_config_32}\pysiglinewithargsret{int \bfcode{rio\_local\_write\_config\_32}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, u32\emph{ offset}, u32\emph{ data}}{}
Write 32 bits to local configuration space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port

\item[{\code{u32 offset}}] \leavevmode
Offset into local configuration space

\item[{\code{u32 data}}] \leavevmode
Data to be written

\end{description}

\textbf{Description}

Writes 32 bits of data to the specified offset within the local
device's configuration space.
\index{rio\_local\_read\_config\_16 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_local_read_config_16}\pysiglinewithargsret{int \bfcode{rio\_local\_read\_config\_16}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, u32\emph{ offset}, u16 *\emph{ data}}{}
Read 16 bits from local configuration space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port

\item[{\code{u32 offset}}] \leavevmode
Offset into local configuration space

\item[{\code{u16 * data}}] \leavevmode
Pointer to read data into

\end{description}

\textbf{Description}

Reads 16 bits of data from the specified offset within the local
device's configuration space.
\index{rio\_local\_write\_config\_16 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_local_write_config_16}\pysiglinewithargsret{int \bfcode{rio\_local\_write\_config\_16}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, u32\emph{ offset}, u16\emph{ data}}{}
Write 16 bits to local configuration space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port

\item[{\code{u32 offset}}] \leavevmode
Offset into local configuration space

\item[{\code{u16 data}}] \leavevmode
Data to be written

\end{description}

\textbf{Description}

Writes 16 bits of data to the specified offset within the local
device's configuration space.
\index{rio\_local\_read\_config\_8 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_local_read_config_8}\pysiglinewithargsret{int \bfcode{rio\_local\_read\_config\_8}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, u32\emph{ offset}, u8 *\emph{ data}}{}
Read 8 bits from local configuration space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port

\item[{\code{u32 offset}}] \leavevmode
Offset into local configuration space

\item[{\code{u8 * data}}] \leavevmode
Pointer to read data into

\end{description}

\textbf{Description}

Reads 8 bits of data from the specified offset within the local
device's configuration space.
\index{rio\_local\_write\_config\_8 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_local_write_config_8}\pysiglinewithargsret{int \bfcode{rio\_local\_write\_config\_8}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, u32\emph{ offset}, u8\emph{ data}}{}
Write 8 bits to local configuration space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port

\item[{\code{u32 offset}}] \leavevmode
Offset into local configuration space

\item[{\code{u8 data}}] \leavevmode
Data to be written

\end{description}

\textbf{Description}

Writes 8 bits of data to the specified offset within the local
device's configuration space.
\index{rio\_read\_config\_32 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_read_config_32}\pysiglinewithargsret{int \bfcode{rio\_read\_config\_32}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, u32\emph{ offset}, u32 *\emph{ data}}{}
Read 32 bits from configuration space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device

\item[{\code{u32 offset}}] \leavevmode
Offset into device configuration space

\item[{\code{u32 * data}}] \leavevmode
Pointer to read data into

\end{description}

\textbf{Description}

Reads 32 bits of data from the specified offset within the
RIO device's configuration space.
\index{rio\_write\_config\_32 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_write_config_32}\pysiglinewithargsret{int \bfcode{rio\_write\_config\_32}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, u32\emph{ offset}, u32\emph{ data}}{}
Write 32 bits to configuration space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device

\item[{\code{u32 offset}}] \leavevmode
Offset into device configuration space

\item[{\code{u32 data}}] \leavevmode
Data to be written

\end{description}

\textbf{Description}

Writes 32 bits of data to the specified offset within the
RIO device's configuration space.
\index{rio\_read\_config\_16 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_read_config_16}\pysiglinewithargsret{int \bfcode{rio\_read\_config\_16}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, u32\emph{ offset}, u16 *\emph{ data}}{}
Read 16 bits from configuration space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device

\item[{\code{u32 offset}}] \leavevmode
Offset into device configuration space

\item[{\code{u16 * data}}] \leavevmode
Pointer to read data into

\end{description}

\textbf{Description}

Reads 16 bits of data from the specified offset within the
RIO device's configuration space.
\index{rio\_write\_config\_16 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_write_config_16}\pysiglinewithargsret{int \bfcode{rio\_write\_config\_16}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, u32\emph{ offset}, u16\emph{ data}}{}
Write 16 bits to configuration space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device

\item[{\code{u32 offset}}] \leavevmode
Offset into device configuration space

\item[{\code{u16 data}}] \leavevmode
Data to be written

\end{description}

\textbf{Description}

Writes 16 bits of data to the specified offset within the
RIO device's configuration space.
\index{rio\_read\_config\_8 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_read_config_8}\pysiglinewithargsret{int \bfcode{rio\_read\_config\_8}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, u32\emph{ offset}, u8 *\emph{ data}}{}
Read 8 bits from configuration space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device

\item[{\code{u32 offset}}] \leavevmode
Offset into device configuration space

\item[{\code{u8 * data}}] \leavevmode
Pointer to read data into

\end{description}

\textbf{Description}

Reads 8 bits of data from the specified offset within the
RIO device's configuration space.
\index{rio\_write\_config\_8 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_write_config_8}\pysiglinewithargsret{int \bfcode{rio\_write\_config\_8}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, u32\emph{ offset}, u8\emph{ data}}{}
Write 8 bits to configuration space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device

\item[{\code{u32 offset}}] \leavevmode
Offset into device configuration space

\item[{\code{u8 data}}] \leavevmode
Data to be written

\end{description}

\textbf{Description}

Writes 8 bits of data to the specified offset within the
RIO device's configuration space.
\index{rio\_send\_doorbell (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_send_doorbell}\pysiglinewithargsret{int \bfcode{rio\_send\_doorbell}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, u16\emph{ data}}{}
Send a doorbell message to a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device

\item[{\code{u16 data}}] \leavevmode
Doorbell message data

\end{description}

\textbf{Description}

Send a doorbell message to a RIO device. The doorbell message
has a 16-bit info field provided by the \textbf{data} argument.
\index{rio\_init\_mbox\_res (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_init_mbox_res}\pysiglinewithargsret{void \bfcode{rio\_init\_mbox\_res}}{struct resource *\emph{ res}, int\emph{ start}, int\emph{ end}}{}
Initialize a RIO mailbox resource

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct resource * res}}] \leavevmode
resource struct

\item[{\code{int start}}] \leavevmode
start of mailbox range

\item[{\code{int end}}] \leavevmode
end of mailbox range

\end{description}

\textbf{Description}

This function is used to initialize the fields of a resource
for use as a mailbox resource.  It initializes a range of
mailboxes using the start and end arguments.
\index{rio\_init\_dbell\_res (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_init_dbell_res}\pysiglinewithargsret{void \bfcode{rio\_init\_dbell\_res}}{struct resource *\emph{ res}, u16\emph{ start}, u16\emph{ end}}{}
Initialize a RIO doorbell resource

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct resource * res}}] \leavevmode
resource struct

\item[{\code{u16 start}}] \leavevmode
start of doorbell range

\item[{\code{u16 end}}] \leavevmode
end of doorbell range

\end{description}

\textbf{Description}

This function is used to initialize the fields of a resource
for use as a doorbell resource.  It initializes a range of
doorbell messages using the start and end arguments.
\index{RIO\_DEVICE (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.RIO_DEVICE}\pysiglinewithargsret{\bfcode{RIO\_DEVICE}}{\emph{dev}, \emph{ven}}{}
macro used to describe a specific RIO device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{dev}}] \leavevmode
the 16 bit RIO device ID

\item[{\code{ven}}] \leavevmode
the 16 bit RIO vendor ID

\end{description}

\textbf{Description}

This macro is used to create a struct rio\_device\_id that matches a
specific device.  The assembly vendor and assembly device fields
will be set to \code{RIO\_ANY\_ID}.
\index{rio\_add\_outb\_message (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_add_outb_message}\pysiglinewithargsret{int \bfcode{rio\_add\_outb\_message}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, int\emph{ mbox}, void *\emph{ buffer}, size\_t\emph{ len}}{}
Add RIO message to an outbound mailbox queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
RIO master port containing the outbound queue

\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device the message is be sent to

\item[{\code{int mbox}}] \leavevmode
The outbound mailbox queue

\item[{\code{void * buffer}}] \leavevmode
Pointer to the message buffer

\item[{\code{size\_t len}}] \leavevmode
Length of the message buffer

\end{description}

\textbf{Description}

Adds a RIO message buffer to an outbound mailbox queue for
transmission. Returns 0 on success.
\index{rio\_add\_inb\_buffer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_add_inb_buffer}\pysiglinewithargsret{int \bfcode{rio\_add\_inb\_buffer}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, int\emph{ mbox}, void *\emph{ buffer}}{}
Add buffer to an inbound mailbox queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
Master port containing the inbound mailbox

\item[{\code{int mbox}}] \leavevmode
The inbound mailbox number

\item[{\code{void * buffer}}] \leavevmode
Pointer to the message buffer

\end{description}

\textbf{Description}

Adds a buffer to an inbound mailbox queue for reception. Returns
0 on success.
\index{rio\_get\_inb\_message (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_get_inb_message}\pysiglinewithargsret{void * \bfcode{rio\_get\_inb\_message}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, int\emph{ mbox}}{}
Get A RIO message from an inbound mailbox queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
Master port containing the inbound mailbox

\item[{\code{int mbox}}] \leavevmode
The inbound mailbox number

\end{description}

\textbf{Description}

Get a RIO message from an inbound mailbox queue. Returns 0 on success.
\index{rio\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_name}\pysiglinewithargsret{const char * \bfcode{rio\_name}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}}{}
Get the unique RIO device identifier

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device

\end{description}

\textbf{Description}

Get the unique RIO device identifier. Returns the device
identifier string.
\index{rio\_get\_drvdata (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_get_drvdata}\pysiglinewithargsret{void * \bfcode{rio\_get\_drvdata}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}}{}
Get RIO driver specific data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device

\end{description}

\textbf{Description}

Get RIO driver specific data. Returns a pointer to the
driver specific data.
\index{rio\_set\_drvdata (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_set_drvdata}\pysiglinewithargsret{void \bfcode{rio\_set\_drvdata}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, void *\emph{ data}}{}
Set RIO driver specific data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device

\item[{\code{void * data}}] \leavevmode
Pointer to driver specific data

\end{description}

\textbf{Description}

Set RIO driver specific data. device struct driver data pointer
is set to the \textbf{data} argument.
\index{rio\_dev\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_dev_get}\pysiglinewithargsret{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} * \bfcode{rio\_dev\_get}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}}{}
Increments the reference count of the RIO device structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device being referenced

\end{description}

\textbf{Description}

Each live reference to a device should be refcounted.

Drivers for RIO devices should normally record such references in
their \code{probe()} methods, when they bind to a device, and release
them by calling {\hyperref[driver\string-api/rapidio:c.rio_dev_put]{\emph{\code{rio\_dev\_put()}}}}, in their \code{disconnect()} methods.
\index{rio\_dev\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_dev_put}\pysiglinewithargsret{void \bfcode{rio\_dev\_put}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}}{}
Release a use of the RIO device structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device being disconnected

\end{description}

\textbf{Description}

Must be called when a user of a device is finished with it.
When the last user of the device calls this function, the
memory of the device is freed.
\index{rio\_register\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_register_driver}\pysiglinewithargsret{int \bfcode{rio\_register\_driver}}{struct {\hyperref[driver\string-api/rapidio:c.rio_driver]{\emph{rio\_driver}}} *\emph{ rdrv}}{}
register a new RIO driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_driver * rdrv}}] \leavevmode
the RIO driver structure to register

\end{description}

\textbf{Description}
\begin{quote}

Adds a {\hyperref[driver\string-api/rapidio:c.rio_driver]{\emph{\code{struct rio\_driver}}}} to the list of registered drivers.
Returns a negative value on error, otherwise 0. If no error
occurred, the driver remains registered even if no device
was claimed during registration.
\end{quote}
\index{rio\_unregister\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_unregister_driver}\pysiglinewithargsret{void \bfcode{rio\_unregister\_driver}}{struct {\hyperref[driver\string-api/rapidio:c.rio_driver]{\emph{rio\_driver}}} *\emph{ rdrv}}{}
unregister a RIO driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_driver * rdrv}}] \leavevmode
the RIO driver structure to unregister

\end{description}

\textbf{Description}
\begin{quote}

Deletes the {\hyperref[driver\string-api/rapidio:c.rio_driver]{\emph{\code{struct rio\_driver}}}} from the list of registered RIO
drivers, gives it a chance to clean up by calling its \code{remove()}
function for each device it was responsible for, and marks those
devices as driverless.
\end{quote}
\index{rio\_local\_get\_device\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_local_get_device_id}\pysiglinewithargsret{u16 \bfcode{rio\_local\_get\_device\_id}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}}{}
Get the base/extended device id for a port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
RIO master port from which to get the deviceid

\end{description}

\textbf{Description}

Reads the base/extended device id from the local device
implementing the master port. Returns the 8/16-bit device
id.
\index{rio\_query\_mport (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_query_mport}\pysiglinewithargsret{int \bfcode{rio\_query\_mport}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, struct {\hyperref[driver\string-api/rapidio:c.rio_mport_attr]{\emph{rio\_mport\_attr}}} *\emph{ mport\_attr}}{}
Query mport device attributes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
mport device to query

\item[{\code{struct rio\_mport\_attr * mport\_attr}}] \leavevmode
mport attributes data structure

\end{description}

\textbf{Description}

Returns attributes of specified mport through the
pointer to attributes data structure.
\index{rio\_alloc\_net (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_alloc_net}\pysiglinewithargsret{struct {\hyperref[driver\string-api/rapidio:c.rio_net]{\emph{rio\_net}}} * \bfcode{rio\_alloc\_net}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}}{}
Allocate and initialize a new RIO network data structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
Master port associated with the RIO network

\end{description}

\textbf{Description}

Allocates a RIO network structure, initializes per-network
list heads, and adds the associated master port to the
network list of associated master ports. Returns a
RIO network pointer on success or \code{NULL} on failure.
\index{rio\_local\_set\_device\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_local_set_device_id}\pysiglinewithargsret{void \bfcode{rio\_local\_set\_device\_id}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, u16\emph{ did}}{}
Set the base/extended device id for a port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
RIO master port

\item[{\code{u16 did}}] \leavevmode
Device ID value to be written

\end{description}

\textbf{Description}

Writes the base/extended device id from a device.
\index{rio\_add\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_add_device}\pysiglinewithargsret{int \bfcode{rio\_add\_device}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}}{}
Adds a RIO device to the device model

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device

\end{description}

\textbf{Description}

Adds the RIO device to the global device list and adds the RIO
device to the RIO device list.  Creates the generic sysfs nodes
for an RIO device.
\index{rio\_request\_inb\_mbox (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_request_inb_mbox}\pysiglinewithargsret{int \bfcode{rio\_request\_inb\_mbox}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, void *\emph{ dev\_id}, int\emph{ mbox}, int\emph{ entries}, void (*minb) (struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, void\emph{ *dev\_id}, int\emph{ mbox}, int\emph{ slot}}{}
request inbound mailbox service

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
RIO master port from which to allocate the mailbox resource

\item[{\code{void * dev\_id}}] \leavevmode
Device specific pointer to pass on event

\item[{\code{int mbox}}] \leavevmode
Mailbox number to claim

\item[{\code{int entries}}] \leavevmode
Number of entries in inbound mailbox queue

\item[{\code{void (*) (struct rio\_mport * mport, void *dev\_id, int mbox, int slot) minb}}] \leavevmode
Callback to execute when inbound message is received

\end{description}

\textbf{Description}

Requests ownership of an inbound mailbox resource and binds
a callback function to the resource. Returns \code{0} on success.
\index{rio\_release\_inb\_mbox (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_release_inb_mbox}\pysiglinewithargsret{int \bfcode{rio\_release\_inb\_mbox}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, int\emph{ mbox}}{}
release inbound mailbox message service

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
RIO master port from which to release the mailbox resource

\item[{\code{int mbox}}] \leavevmode
Mailbox number to release

\end{description}

\textbf{Description}

Releases ownership of an inbound mailbox resource. Returns 0
if the request has been satisfied.
\index{rio\_request\_outb\_mbox (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_request_outb_mbox}\pysiglinewithargsret{int \bfcode{rio\_request\_outb\_mbox}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, void *\emph{ dev\_id}, int\emph{ mbox}, int\emph{ entries}, void (*moutb) (struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, void\emph{ *dev\_id}, int\emph{ mbox}, int\emph{ slot}}{}
request outbound mailbox service

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
RIO master port from which to allocate the mailbox resource

\item[{\code{void * dev\_id}}] \leavevmode
Device specific pointer to pass on event

\item[{\code{int mbox}}] \leavevmode
Mailbox number to claim

\item[{\code{int entries}}] \leavevmode
Number of entries in outbound mailbox queue

\item[{\code{void (*) (struct rio\_mport * mport, void *dev\_id, int mbox, int slot) moutb}}] \leavevmode
Callback to execute when outbound message is sent

\end{description}

\textbf{Description}

Requests ownership of an outbound mailbox resource and binds
a callback function to the resource. Returns 0 on success.
\index{rio\_release\_outb\_mbox (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_release_outb_mbox}\pysiglinewithargsret{int \bfcode{rio\_release\_outb\_mbox}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, int\emph{ mbox}}{}
release outbound mailbox message service

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
RIO master port from which to release the mailbox resource

\item[{\code{int mbox}}] \leavevmode
Mailbox number to release

\end{description}

\textbf{Description}

Releases ownership of an inbound mailbox resource. Returns 0
if the request has been satisfied.
\index{rio\_request\_inb\_dbell (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_request_inb_dbell}\pysiglinewithargsret{int \bfcode{rio\_request\_inb\_dbell}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, void *\emph{ dev\_id}, u16\emph{ start}, u16\emph{ end}, void (*dinb) (struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, void\emph{ *dev\_id}, u16\emph{ src}, u16\emph{ dst}, u16\emph{ info}}{}
request inbound doorbell message service

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
RIO master port from which to allocate the doorbell resource

\item[{\code{void * dev\_id}}] \leavevmode
Device specific pointer to pass on event

\item[{\code{u16 start}}] \leavevmode
Doorbell info range start

\item[{\code{u16 end}}] \leavevmode
Doorbell info range end

\item[{\code{void (*) (struct rio\_mport * mport, void *dev\_id, u16 src, u16 dst, u16 info) dinb}}] \leavevmode
Callback to execute when doorbell is received

\end{description}

\textbf{Description}

Requests ownership of an inbound doorbell resource and binds
a callback function to the resource. Returns 0 if the request
has been satisfied.
\index{rio\_release\_inb\_dbell (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_release_inb_dbell}\pysiglinewithargsret{int \bfcode{rio\_release\_inb\_dbell}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, u16\emph{ start}, u16\emph{ end}}{}
release inbound doorbell message service

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
RIO master port from which to release the doorbell resource

\item[{\code{u16 start}}] \leavevmode
Doorbell info range start

\item[{\code{u16 end}}] \leavevmode
Doorbell info range end

\end{description}

\textbf{Description}

Releases ownership of an inbound doorbell resource and removes
callback from the doorbell event list. Returns 0 if the request
has been satisfied.
\index{rio\_request\_outb\_dbell (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_request_outb_dbell}\pysiglinewithargsret{struct resource * \bfcode{rio\_request\_outb\_dbell}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, u16\emph{ start}, u16\emph{ end}}{}
request outbound doorbell message range

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device from which to allocate the doorbell resource

\item[{\code{u16 start}}] \leavevmode
Doorbell message range start

\item[{\code{u16 end}}] \leavevmode
Doorbell message range end

\end{description}

\textbf{Description}

Requests ownership of a doorbell message range. Returns a resource
if the request has been satisfied or \code{NULL} on failure.
\index{rio\_release\_outb\_dbell (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_release_outb_dbell}\pysiglinewithargsret{int \bfcode{rio\_release\_outb\_dbell}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, struct resource *\emph{ res}}{}
release outbound doorbell message range

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device from which to release the doorbell resource

\item[{\code{struct resource * res}}] \leavevmode
Doorbell resource to be freed

\end{description}

\textbf{Description}

Releases ownership of a doorbell message range. Returns 0 if the
request has been satisfied.
\index{rio\_add\_mport\_pw\_handler (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_add_mport_pw_handler}\pysiglinewithargsret{int \bfcode{rio\_add\_mport\_pw\_handler}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, void *\emph{ context}, int (*pwcback) (struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}}\emph{ *mport}, void\emph{ *context}, union rio\_pw\_msg\emph{ *msg}, int\emph{ step}}{}
add port-write message handler into the list of mport specific pw handlers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
RIO master port to bind the portwrite callback

\item[{\code{void * context}}] \leavevmode
Handler specific context to pass on event

\item[{\code{int (*)(struct rio\_mport *mport, void *context, union rio\_pw\_msg *msg, int step) pwcback}}] \leavevmode
Callback to execute when portwrite is received

\end{description}

\textbf{Description}

Returns 0 if the request has been satisfied.
\index{rio\_del\_mport\_pw\_handler (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_del_mport_pw_handler}\pysiglinewithargsret{int \bfcode{rio\_del\_mport\_pw\_handler}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, void *\emph{ context}, int (*pwcback) (struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}}\emph{ *mport}, void\emph{ *context}, union rio\_pw\_msg\emph{ *msg}, int\emph{ step}}{}
remove port-write message handler from the list of mport specific pw handlers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
RIO master port to bind the portwrite callback

\item[{\code{void * context}}] \leavevmode
Registered handler specific context to pass on event

\item[{\code{int (*)(struct rio\_mport *mport, void *context, union rio\_pw\_msg *msg, int step) pwcback}}] \leavevmode
Registered callback function

\end{description}

\textbf{Description}

Returns 0 if the request has been satisfied.
\index{rio\_request\_inb\_pwrite (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_request_inb_pwrite}\pysiglinewithargsret{int \bfcode{rio\_request\_inb\_pwrite}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, int (*pwcback) (struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}}\emph{ *rdev}, union rio\_pw\_msg\emph{ *msg}, int\emph{ step}}{}
request inbound port-write message service for specific RapidIO device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device to which register inbound port-write callback routine

\item[{\code{int (*)(struct rio\_dev *rdev, union rio\_pw\_msg *msg, int step) pwcback}}] \leavevmode
Callback routine to execute when port-write is received

\end{description}

\textbf{Description}

Binds a port-write callback function to the RapidIO device.
Returns 0 if the request has been satisfied.
\index{rio\_release\_inb\_pwrite (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_release_inb_pwrite}\pysiglinewithargsret{int \bfcode{rio\_release\_inb\_pwrite}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}}{}
release inbound port-write message service associated with specific RapidIO device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device which registered for inbound port-write callback

\end{description}

\textbf{Description}

Removes callback from the rio\_dev structure. Returns 0 if the request
has been satisfied.
\index{rio\_pw\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_pw_enable}\pysiglinewithargsret{void \bfcode{rio\_pw\_enable}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, int\emph{ enable}}{}
Enables/disables port-write handling by a master port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
Master port associated with port-write handling

\item[{\code{int enable}}] \leavevmode
1=enable,  0=disable

\end{description}
\index{rio\_map\_inb\_region (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_map_inb_region}\pysiglinewithargsret{int \bfcode{rio\_map\_inb\_region}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, dma\_addr\_t\emph{ local}, u64\emph{ rbase}, u32\emph{ size}, u32\emph{ rflags}}{}~\begin{itemize}
\item {} 
Map inbound memory region.

\end{itemize}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
Master port.

\item[{\code{dma\_addr\_t local}}] \leavevmode
physical address of memory region to be mapped

\item[{\code{u64 rbase}}] \leavevmode
RIO base address assigned to this window

\item[{\code{u32 size}}] \leavevmode
Size of the memory region

\item[{\code{u32 rflags}}] \leavevmode
Flags for mapping.

\end{description}

\textbf{Return}

0 -- Success.

This function will create the mapping from RIO space to local memory.
\index{rio\_unmap\_inb\_region (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_unmap_inb_region}\pysiglinewithargsret{void \bfcode{rio\_unmap\_inb\_region}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, dma\_addr\_t\emph{ lstart}}{}~\begin{itemize}
\item {} 
Unmap the inbound memory region

\end{itemize}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
Master port

\item[{\code{dma\_addr\_t lstart}}] \leavevmode
physical address of memory region to be unmapped

\end{description}
\index{rio\_map\_outb\_region (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_map_outb_region}\pysiglinewithargsret{int \bfcode{rio\_map\_outb\_region}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, u16\emph{ destid}, u64\emph{ rbase}, u32\emph{ size}, u32\emph{ rflags}, dma\_addr\_t *\emph{ local}}{}~\begin{itemize}
\item {} 
Map outbound memory region.

\end{itemize}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
Master port.

\item[{\code{u16 destid}}] \leavevmode
destination id window points to

\item[{\code{u64 rbase}}] \leavevmode
RIO base address window translates to

\item[{\code{u32 size}}] \leavevmode
Size of the memory region

\item[{\code{u32 rflags}}] \leavevmode
Flags for mapping.

\item[{\code{dma\_addr\_t * local}}] \leavevmode
physical address of memory region mapped

\end{description}

\textbf{Return}

0 -- Success.

This function will create the mapping from RIO space to local memory.
\index{rio\_unmap\_outb\_region (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_unmap_outb_region}\pysiglinewithargsret{void \bfcode{rio\_unmap\_outb\_region}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, u16\emph{ destid}, u64\emph{ rstart}}{}~\begin{itemize}
\item {} 
Unmap the inbound memory region

\end{itemize}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
Master port

\item[{\code{u16 destid}}] \leavevmode
destination id mapping points to

\item[{\code{u64 rstart}}] \leavevmode
RIO base address window translates to

\end{description}
\index{rio\_mport\_get\_physefb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_mport_get_physefb}\pysiglinewithargsret{u32 \bfcode{rio\_mport\_get\_physefb}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, int\emph{ local}, u16\emph{ destid}, u8\emph{ hopcount}, u32 *\emph{ rmap}}{}
Helper function that returns register offset for Physical Layer Extended Features Block.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port to issue transaction

\item[{\code{int local}}] \leavevmode
Indicate a local master port or remote device access

\item[{\code{u16 destid}}] \leavevmode
Destination ID of the device

\item[{\code{u8 hopcount}}] \leavevmode
Number of switch hops to the device

\item[{\code{u32 * rmap}}] \leavevmode
pointer to location to store register map type info

\end{description}
\index{rio\_get\_comptag (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_get_comptag}\pysiglinewithargsret{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} * \bfcode{rio\_get\_comptag}}{u32\emph{ comp\_tag}, struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ from}}{}
Begin or continue searching for a RIO device by component tag

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u32 comp\_tag}}] \leavevmode
RIO component tag to match

\item[{\code{struct rio\_dev * from}}] \leavevmode
Previous RIO device found in search, or \code{NULL} for new search

\end{description}

\textbf{Description}

Iterates through the list of known RIO devices. If a RIO device is
found with a matching \textbf{comp\_tag}, a pointer to its device
structure is returned. Otherwise, \code{NULL} is returned. A new search
is initiated by passing \code{NULL} to the \textbf{from} argument. Otherwise, if
\textbf{from} is not \code{NULL}, searches continue from next device on the global
list.
\index{rio\_set\_port\_lockout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_set_port_lockout}\pysiglinewithargsret{int \bfcode{rio\_set\_port\_lockout}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, u32\emph{ pnum}, int\emph{ lock}}{}
Sets/clears LOCKOUT bit (RIO EM 1.3) for a switch port.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
Pointer to RIO device control structure

\item[{\code{u32 pnum}}] \leavevmode
Switch port number to set LOCKOUT bit

\item[{\code{int lock}}] \leavevmode
Operation : set (=1) or clear (=0)

\end{description}
\index{rio\_enable\_rx\_tx\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_enable_rx_tx_port}\pysiglinewithargsret{int \bfcode{rio\_enable\_rx\_tx\_port}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, int\emph{ local}, u16\emph{ destid}, u8\emph{ hopcount}, u8\emph{ port\_num}}{}
enable input receiver and output transmitter of given port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port associated with the RIO network

\item[{\code{int local}}] \leavevmode
local=1 select local port otherwise a far device is reached

\item[{\code{u16 destid}}] \leavevmode
Destination ID of the device to check host bit

\item[{\code{u8 hopcount}}] \leavevmode
Number of hops to reach the target

\item[{\code{u8 port\_num}}] \leavevmode
Port (-number on switch) to enable on a far end device

\end{description}

\textbf{Description}

Returns 0 or 1 from on General Control Command and Status Register
(EXT\_PTR+0x3C)
\index{rio\_mport\_chk\_dev\_access (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_mport_chk_dev_access}\pysiglinewithargsret{int \bfcode{rio\_mport\_chk\_dev\_access}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, u16\emph{ destid}, u8\emph{ hopcount}}{}
Validate access to the specified device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
Master port to send transactions

\item[{\code{u16 destid}}] \leavevmode
Device destination ID in network

\item[{\code{u8 hopcount}}] \leavevmode
Number of hops into the network

\end{description}
\index{rio\_inb\_pwrite\_handler (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_inb_pwrite_handler}\pysiglinewithargsret{int \bfcode{rio\_inb\_pwrite\_handler}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, union rio\_pw\_msg *\emph{ pw\_msg}}{}
inbound port-write message handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
mport device associated with port-write

\item[{\code{union rio\_pw\_msg * pw\_msg}}] \leavevmode
pointer to inbound port-write message

\end{description}

\textbf{Description}

Processes an inbound port-write message. Returns 0 if the request
has been satisfied.
\index{rio\_mport\_get\_efb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_mport_get_efb}\pysiglinewithargsret{u32 \bfcode{rio\_mport\_get\_efb}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, int\emph{ local}, u16\emph{ destid}, u8\emph{ hopcount}, u32\emph{ from}}{}
get pointer to next extended features block

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port to issue transaction

\item[{\code{int local}}] \leavevmode
Indicate a local master port or remote device access

\item[{\code{u16 destid}}] \leavevmode
Destination ID of the device

\item[{\code{u8 hopcount}}] \leavevmode
Number of switch hops to the device

\item[{\code{u32 from}}] \leavevmode
Offset of  current Extended Feature block header (if 0 starts
from ExtFeaturePtr)

\end{description}
\index{rio\_mport\_get\_feature (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_mport_get_feature}\pysiglinewithargsret{u32 \bfcode{rio\_mport\_get\_feature}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, int\emph{ local}, u16\emph{ destid}, u8\emph{ hopcount}, int\emph{ ftr}}{}
query for devices' extended features

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port to issue transaction

\item[{\code{int local}}] \leavevmode
Indicate a local master port or remote device access

\item[{\code{u16 destid}}] \leavevmode
Destination ID of the device

\item[{\code{u8 hopcount}}] \leavevmode
Number of switch hops to the device

\item[{\code{int ftr}}] \leavevmode
Extended feature code

\end{description}

\textbf{Description}

Tell if a device supports a given RapidIO capability.
Returns the offset of the requested extended feature
block within the device's RIO configuration space or
0 in case the device does not support it.
\index{rio\_get\_asm (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_get_asm}\pysiglinewithargsret{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} * \bfcode{rio\_get\_asm}}{u16\emph{ vid}, u16\emph{ did}, u16\emph{ asm\_vid}, u16\emph{ asm\_did}, struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ from}}{}
Begin or continue searching for a RIO device by vid/did/asm\_vid/asm\_did

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u16 vid}}] \leavevmode
RIO vid to match or \code{RIO\_ANY\_ID} to match all vids

\item[{\code{u16 did}}] \leavevmode
RIO did to match or \code{RIO\_ANY\_ID} to match all dids

\item[{\code{u16 asm\_vid}}] \leavevmode
RIO asm\_vid to match or \code{RIO\_ANY\_ID} to match all asm\_vids

\item[{\code{u16 asm\_did}}] \leavevmode
RIO asm\_did to match or \code{RIO\_ANY\_ID} to match all asm\_dids

\item[{\code{struct rio\_dev * from}}] \leavevmode
Previous RIO device found in search, or \code{NULL} for new search

\end{description}

\textbf{Description}

Iterates through the list of known RIO devices. If a RIO device is
found with a matching \textbf{vid}, \textbf{did}, \textbf{asm\_vid}, \textbf{asm\_did}, the reference
count to the device is incrememted and a pointer to its device
structure is returned. Otherwise, \code{NULL} is returned. A new search
is initiated by passing \code{NULL} to the \textbf{from} argument. Otherwise, if
\textbf{from} is not \code{NULL}, searches continue from next device on the global
list. The reference count for \textbf{from} is always decremented if it is
not \code{NULL}.
\index{rio\_get\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_get_device}\pysiglinewithargsret{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} * \bfcode{rio\_get\_device}}{u16\emph{ vid}, u16\emph{ did}, struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ from}}{}
Begin or continue searching for a RIO device by vid/did

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u16 vid}}] \leavevmode
RIO vid to match or \code{RIO\_ANY\_ID} to match all vids

\item[{\code{u16 did}}] \leavevmode
RIO did to match or \code{RIO\_ANY\_ID} to match all dids

\item[{\code{struct rio\_dev * from}}] \leavevmode
Previous RIO device found in search, or \code{NULL} for new search

\end{description}

\textbf{Description}

Iterates through the list of known RIO devices. If a RIO device is
found with a matching \textbf{vid} and \textbf{did}, the reference count to the
device is incrememted and a pointer to its device structure is returned.
Otherwise, \code{NULL} is returned. A new search is initiated by passing \code{NULL}
to the \textbf{from} argument. Otherwise, if \textbf{from} is not \code{NULL}, searches
continue from next device on the global list. The reference count for
\textbf{from} is always decremented if it is not \code{NULL}.
\index{rio\_lock\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_lock_device}\pysiglinewithargsret{int \bfcode{rio\_lock\_device}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, u16\emph{ destid}, u8\emph{ hopcount}, int\emph{ wait\_ms}}{}
Acquires host device lock for specified device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port to send transaction

\item[{\code{u16 destid}}] \leavevmode
Destination ID for device/switch

\item[{\code{u8 hopcount}}] \leavevmode
Hopcount to reach switch

\item[{\code{int wait\_ms}}] \leavevmode
Max wait time in msec (0 = no timeout)

\end{description}

\textbf{Description}

Attepts to acquire host device lock for specified device
Returns 0 if device lock acquired or EINVAL if timeout expires.
\index{rio\_unlock\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_unlock_device}\pysiglinewithargsret{int \bfcode{rio\_unlock\_device}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, u16\emph{ destid}, u8\emph{ hopcount}}{}
Releases host device lock for specified device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port to send transaction

\item[{\code{u16 destid}}] \leavevmode
Destination ID for device/switch

\item[{\code{u8 hopcount}}] \leavevmode
Hopcount to reach switch

\end{description}

\textbf{Description}

Returns 0 if device lock released or EINVAL if fails.
\index{rio\_route\_add\_entry (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_route_add_entry}\pysiglinewithargsret{int \bfcode{rio\_route\_add\_entry}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, u16\emph{ table}, u16\emph{ route\_destid}, u8\emph{ route\_port}, int\emph{ lock}}{}
Add a route entry to a switch routing table

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device

\item[{\code{u16 table}}] \leavevmode
Routing table ID

\item[{\code{u16 route\_destid}}] \leavevmode
Destination ID to be routed

\item[{\code{u8 route\_port}}] \leavevmode
Port number to be routed

\item[{\code{int lock}}] \leavevmode
apply a hardware lock on switch device flag (1=lock, 0=no\_lock)

\end{description}

\textbf{Description}

If available calls the switch specific \code{add\_entry()} method to add a route
entry into a switch routing table. Otherwise uses standard RT update method
as defined by RapidIO specification. A specific routing table can be selected
using the \textbf{table} argument if a switch has per port routing tables or
the standard (or global) table may be used by passing
\code{RIO\_GLOBAL\_TABLE} in \textbf{table}.

Returns \code{0} on success or \code{-EINVAL} on failure.
\index{rio\_route\_get\_entry (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_route_get_entry}\pysiglinewithargsret{int \bfcode{rio\_route\_get\_entry}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, u16\emph{ table}, u16\emph{ route\_destid}, u8 *\emph{ route\_port}, int\emph{ lock}}{}
Read an entry from a switch routing table

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device

\item[{\code{u16 table}}] \leavevmode
Routing table ID

\item[{\code{u16 route\_destid}}] \leavevmode
Destination ID to be routed

\item[{\code{u8 * route\_port}}] \leavevmode
Pointer to read port number into

\item[{\code{int lock}}] \leavevmode
apply a hardware lock on switch device flag (1=lock, 0=no\_lock)

\end{description}

\textbf{Description}

If available calls the switch specific \code{get\_entry()} method to fetch a route
entry from a switch routing table. Otherwise uses standard RT read method
as defined by RapidIO specification. A specific routing table can be selected
using the \textbf{table} argument if a switch has per port routing tables or
the standard (or global) table may be used by passing
\code{RIO\_GLOBAL\_TABLE} in \textbf{table}.

Returns \code{0} on success or \code{-EINVAL} on failure.
\index{rio\_route\_clr\_table (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_route_clr_table}\pysiglinewithargsret{int \bfcode{rio\_route\_clr\_table}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, u16\emph{ table}, int\emph{ lock}}{}
Clear a switch routing table

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device

\item[{\code{u16 table}}] \leavevmode
Routing table ID

\item[{\code{int lock}}] \leavevmode
apply a hardware lock on switch device flag (1=lock, 0=no\_lock)

\end{description}

\textbf{Description}

If available calls the switch specific \code{clr\_table()} method to clear a switch
routing table. Otherwise uses standard RT write method as defined by RapidIO
specification. A specific routing table can be selected using the \textbf{table}
argument if a switch has per port routing tables or the standard (or global)
table may be used by passing \code{RIO\_GLOBAL\_TABLE} in \textbf{table}.

Returns \code{0} on success or \code{-EINVAL} on failure.
\index{rio\_request\_mport\_dma (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_request_mport_dma}\pysiglinewithargsret{struct dma\_chan * \bfcode{rio\_request\_mport\_dma}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}}{}
request RapidIO capable DMA channel associated with specified local RapidIO mport device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
RIO mport to perform DMA data transfers

\end{description}

\textbf{Description}

Returns pointer to allocated DMA channel or NULL if failed.
\index{rio\_request\_dma (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_request_dma}\pysiglinewithargsret{struct dma\_chan * \bfcode{rio\_request\_dma}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}}{}
request RapidIO capable DMA channel that supports specified target RapidIO device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device associated with DMA transfer

\end{description}

\textbf{Description}

Returns pointer to allocated DMA channel or NULL if failed.
\index{rio\_release\_dma (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_release_dma}\pysiglinewithargsret{void \bfcode{rio\_release\_dma}}{struct dma\_chan *\emph{ dchan}}{}
release specified DMA channel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_chan * dchan}}] \leavevmode
DMA channel to release

\end{description}
\index{rio\_dma\_prep\_xfer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_dma_prep_xfer}\pysiglinewithargsret{struct dma\_async\_tx\_descriptor * \bfcode{rio\_dma\_prep\_xfer}}{struct dma\_chan *\emph{ dchan}, u16\emph{ destid}, struct rio\_dma\_data *\emph{ data}, enum dma\_transfer\_direction\emph{ direction}, unsigned long\emph{ flags}}{}
RapidIO specific wrapper for device\_prep\_slave\_sg callback defined by DMAENGINE.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dma\_chan * dchan}}] \leavevmode
DMA channel to configure

\item[{\code{u16 destid}}] \leavevmode
target RapidIO device destination ID

\item[{\code{struct rio\_dma\_data * data}}] \leavevmode
RIO specific data descriptor

\item[{\code{enum dma\_transfer\_direction direction}}] \leavevmode
DMA data transfer direction (TO or FROM the device)

\item[{\code{unsigned long flags}}] \leavevmode
dmaengine defined flags

\end{description}

\textbf{Description}

Initializes RapidIO capable DMA channel for the specified data transfer.
Uses DMA channel private extension to pass information related to remote
target RIO device.

\textbf{Return}
\begin{description}
\item[{pointer to DMA transaction descriptor if successful,}] \leavevmode
error-valued pointer or NULL if failed.

\end{description}
\index{rio\_dma\_prep\_slave\_sg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_dma_prep_slave_sg}\pysiglinewithargsret{struct dma\_async\_tx\_descriptor * \bfcode{rio\_dma\_prep\_slave\_sg}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, struct dma\_chan *\emph{ dchan}, struct rio\_dma\_data *\emph{ data}, enum dma\_transfer\_direction\emph{ direction}, unsigned long\emph{ flags}}{}
RapidIO specific wrapper for device\_prep\_slave\_sg callback defined by DMAENGINE.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device control structure

\item[{\code{struct dma\_chan * dchan}}] \leavevmode
DMA channel to configure

\item[{\code{struct rio\_dma\_data * data}}] \leavevmode
RIO specific data descriptor

\item[{\code{enum dma\_transfer\_direction direction}}] \leavevmode
DMA data transfer direction (TO or FROM the device)

\item[{\code{unsigned long flags}}] \leavevmode
dmaengine defined flags

\end{description}

\textbf{Description}

Initializes RapidIO capable DMA channel for the specified data transfer.
Uses DMA channel private extension to pass information related to remote
target RIO device.

\textbf{Return}
\begin{description}
\item[{pointer to DMA transaction descriptor if successful,}] \leavevmode
error-valued pointer or NULL if failed.

\end{description}
\index{rio\_register\_scan (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_register_scan}\pysiglinewithargsret{int \bfcode{rio\_register\_scan}}{int\emph{ mport\_id}, struct {\hyperref[driver\string-api/rapidio:c.rio_scan]{\emph{rio\_scan}}} *\emph{ scan\_ops}}{}
enumeration/discovery method registration interface

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int mport\_id}}] \leavevmode
mport device ID for which fabric scan routine has to be set
(RIO\_MPORT\_ANY = set for all available mports)

\item[{\code{struct rio\_scan * scan\_ops}}] \leavevmode
enumeration/discovery operations structure

\end{description}

\textbf{Description}

Registers enumeration/discovery operations with RapidIO subsystem and
attaches it to the specified mport device (or all available mports
if RIO\_MPORT\_ANY is specified).

Returns error if the mport already has an enumerator attached to it.
In case of RIO\_MPORT\_ANY skips mports with valid scan routines (no error).
\index{rio\_unregister\_scan (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_unregister_scan}\pysiglinewithargsret{int \bfcode{rio\_unregister\_scan}}{int\emph{ mport\_id}, struct {\hyperref[driver\string-api/rapidio:c.rio_scan]{\emph{rio\_scan}}} *\emph{ scan\_ops}}{}
removes enumeration/discovery method from mport

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int mport\_id}}] \leavevmode
mport device ID for which fabric scan routine has to be
unregistered (RIO\_MPORT\_ANY = apply to all mports that use
the specified scan\_ops)

\item[{\code{struct rio\_scan * scan\_ops}}] \leavevmode
enumeration/discovery operations structure

\end{description}

\textbf{Description}

Removes enumeration or discovery method assigned to the specified mport
device. If RIO\_MPORT\_ANY is specified, removes the specified operations from
all mports that have them attached.


\section{Internals}
\label{driver-api/rapidio:internals}
This chapter contains the autogenerated documentation of the RapidIO
subsystem.


\subsection{Structures}
\label{driver-api/rapidio:structures}\index{rio\_switch (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_switch}\pysigline{struct \bfcode{rio\_switch}}
RIO switch info

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct rio\PYGZus{}switch \PYGZob{}
  struct list\PYGZus{}head node;
  u8 *route\PYGZus{}table;
  u32 port\PYGZus{}ok;
  struct rio\PYGZus{}switch\PYGZus{}ops *ops;
  spinlock\PYGZus{}t lock;
  struct rio\PYGZus{}dev *nextdev[0];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{node}}] \leavevmode
Node in global list of switches

\item[{\code{route\_table}}] \leavevmode
Copy of switch routing table

\item[{\code{port\_ok}}] \leavevmode
Status of each port (one bit per port) - OK=1 or UNINIT=0

\item[{\code{ops}}] \leavevmode
pointer to switch-specific operations

\item[{\code{lock}}] \leavevmode
lock to serialize operations updates

\item[{\code{nextdev}}] \leavevmode
Array of per-port pointers to the next attached device

\end{description}
\index{rio\_switch\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_switch_ops}\pysigline{struct \bfcode{rio\_switch\_ops}}
Per-switch operations

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct rio\PYGZus{}switch\PYGZus{}ops \PYGZob{}
  struct module *owner;
  int (*add\PYGZus{}entry) (struct rio\PYGZus{}mport *mport, u16 destid, u8 hopcount, u16 table, u16 route\PYGZus{}destid, u8 route\PYGZus{}port);
  int (*get\PYGZus{}entry) (struct rio\PYGZus{}mport *mport, u16 destid, u8 hopcount, u16 table, u16 route\PYGZus{}destid, u8 *route\PYGZus{}port);
  int (*clr\PYGZus{}table) (struct rio\PYGZus{}mport *mport, u16 destid, u8 hopcount, u16 table);
  int (*set\PYGZus{}domain) (struct rio\PYGZus{}mport *mport, u16 destid, u8 hopcount, u8 sw\PYGZus{}domain);
  int (*get\PYGZus{}domain) (struct rio\PYGZus{}mport *mport, u16 destid, u8 hopcount, u8 *sw\PYGZus{}domain);
  int (*em\PYGZus{}init) (struct rio\PYGZus{}dev *dev);
  int (*em\PYGZus{}handle) (struct rio\PYGZus{}dev *dev, u8 swport);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{owner}}] \leavevmode
The module owner of this structure

\item[{\code{add\_entry}}] \leavevmode
Callback for switch-specific route add function

\item[{\code{get\_entry}}] \leavevmode
Callback for switch-specific route get function

\item[{\code{clr\_table}}] \leavevmode
Callback for switch-specific clear route table function

\item[{\code{set\_domain}}] \leavevmode
Callback for switch-specific domain setting function

\item[{\code{get\_domain}}] \leavevmode
Callback for switch-specific domain get function

\item[{\code{em\_init}}] \leavevmode
Callback for switch-specific error management init function

\item[{\code{em\_handle}}] \leavevmode
Callback for switch-specific error management handler function

\end{description}

\textbf{Description}

Defines the operations that are necessary to initialize/control
a particular RIO switch device.
\index{rio\_dev (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_dev}\pysigline{struct \bfcode{rio\_dev}}
RIO device info

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct rio\PYGZus{}dev \PYGZob{}
  struct list\PYGZus{}head global\PYGZus{}list;
  struct list\PYGZus{}head net\PYGZus{}list;
  struct rio\PYGZus{}net *net;
  bool do\PYGZus{}enum;
  u16 did;
  u16 vid;
  u32 device\PYGZus{}rev;
  u16 asm\PYGZus{}did;
  u16 asm\PYGZus{}vid;
  u16 asm\PYGZus{}rev;
  u16 efptr;
  u32 pef;
  u32 swpinfo;
  u32 src\PYGZus{}ops;
  u32 dst\PYGZus{}ops;
  u32 comp\PYGZus{}tag;
  u32 phys\PYGZus{}efptr;
  u32 phys\PYGZus{}rmap;
  u32 em\PYGZus{}efptr;
  u64 dma\PYGZus{}mask;
  struct rio\PYGZus{}driver *driver;
  struct device dev;
  struct resource riores[RIO\PYGZus{}MAX\PYGZus{}DEV\PYGZus{}RESOURCES];
  int (*pwcback) (struct rio\PYGZus{}dev *rdev, union rio\PYGZus{}pw\PYGZus{}msg *msg, int step);
  u16 destid;
  u8 hopcount;
  struct rio\PYGZus{}dev *prev;
  atomic\PYGZus{}t state;
  struct rio\PYGZus{}switch rswitch[0];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{global\_list}}] \leavevmode
Node in list of all RIO devices

\item[{\code{net\_list}}] \leavevmode
Node in list of RIO devices in a network

\item[{\code{net}}] \leavevmode
Network this device is a part of

\item[{\code{do\_enum}}] \leavevmode
Enumeration flag

\item[{\code{did}}] \leavevmode
Device ID

\item[{\code{vid}}] \leavevmode
Vendor ID

\item[{\code{device\_rev}}] \leavevmode
Device revision

\item[{\code{asm\_did}}] \leavevmode
Assembly device ID

\item[{\code{asm\_vid}}] \leavevmode
Assembly vendor ID

\item[{\code{asm\_rev}}] \leavevmode
Assembly revision

\item[{\code{efptr}}] \leavevmode
Extended feature pointer

\item[{\code{pef}}] \leavevmode
Processing element features

\item[{\code{swpinfo}}] \leavevmode
Switch port info

\item[{\code{src\_ops}}] \leavevmode
Source operation capabilities

\item[{\code{dst\_ops}}] \leavevmode
Destination operation capabilities

\item[{\code{comp\_tag}}] \leavevmode
RIO component tag

\item[{\code{phys\_efptr}}] \leavevmode
RIO device extended features pointer

\item[{\code{phys\_rmap}}] \leavevmode
LP-Serial Register Map Type (1 or 2)

\item[{\code{em\_efptr}}] \leavevmode
RIO Error Management features pointer

\item[{\code{dma\_mask}}] \leavevmode
Mask of bits of RIO address this device implements

\item[{\code{driver}}] \leavevmode
Driver claiming this device

\item[{\code{dev}}] \leavevmode
Device model device

\item[{\code{riores}}] \leavevmode
RIO resources this device owns

\item[{\code{pwcback}}] \leavevmode
port-write callback function for this device

\item[{\code{destid}}] \leavevmode
Network destination ID (or associated destid for switch)

\item[{\code{hopcount}}] \leavevmode
Hopcount to this device

\item[{\code{prev}}] \leavevmode
Previous RIO device connected to the current one

\item[{\code{state}}] \leavevmode
device state

\item[{\code{rswitch}}] \leavevmode
struct rio\_switch (if valid for this device)

\end{description}
\index{rio\_msg (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_msg}\pysigline{struct \bfcode{rio\_msg}}
RIO message event

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct rio\PYGZus{}msg \PYGZob{}
  struct resource *res;
  void (*mcback) (struct rio\PYGZus{}mport * mport, void *dev\PYGZus{}id, int mbox, int slot);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{res}}] \leavevmode
Mailbox resource

\item[{\code{mcback}}] \leavevmode
Message event callback

\end{description}
\index{rio\_dbell (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_dbell}\pysigline{struct \bfcode{rio\_dbell}}
RIO doorbell event

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct rio\PYGZus{}dbell \PYGZob{}
  struct list\PYGZus{}head node;
  struct resource *res;
  void (*dinb) (struct rio\PYGZus{}mport *mport, void *dev\PYGZus{}id, u16 src, u16 dst, u16 info);
  void *dev\PYGZus{}id;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{node}}] \leavevmode
Node in list of doorbell events

\item[{\code{res}}] \leavevmode
Doorbell resource

\item[{\code{dinb}}] \leavevmode
Doorbell event callback

\item[{\code{dev\_id}}] \leavevmode
Device specific pointer to pass on event

\end{description}
\index{rio\_mport (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_mport}\pysigline{struct \bfcode{rio\_mport}}
RIO master port info

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct rio\PYGZus{}mport \PYGZob{}
  struct list\PYGZus{}head dbells;
  struct list\PYGZus{}head pwrites;
  struct list\PYGZus{}head node;
  struct list\PYGZus{}head nnode;
  struct rio\PYGZus{}net *net;
  struct mutex lock;
  struct resource iores;
  struct resource riores[RIO\PYGZus{}MAX\PYGZus{}MPORT\PYGZus{}RESOURCES];
  struct rio\PYGZus{}msg inb\PYGZus{}msg[RIO\PYGZus{}MAX\PYGZus{}MBOX];
  struct rio\PYGZus{}msg outb\PYGZus{}msg[RIO\PYGZus{}MAX\PYGZus{}MBOX];
  int host\PYGZus{}deviceid;
  struct rio\PYGZus{}ops *ops;
  unsigned char id;
  unsigned char index;
  unsigned int sys\PYGZus{}size;
  u32 phys\PYGZus{}efptr;
  u32 phys\PYGZus{}rmap;
  unsigned char name[RIO\PYGZus{}MAX\PYGZus{}MPORT\PYGZus{}NAME];
  struct device dev;
  void *priv;
\PYGZsh{}ifdef CONFIG\PYGZus{}RAPIDIO\PYGZus{}DMA\PYGZus{}ENGINE;
  struct dma\PYGZus{}device       dma;
\PYGZsh{}endif;
  struct rio\PYGZus{}scan *nscan;
  atomic\PYGZus{}t state;
  unsigned int pwe\PYGZus{}refcnt;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dbells}}] \leavevmode
List of doorbell events

\item[{\code{pwrites}}] \leavevmode
List of portwrite events

\item[{\code{node}}] \leavevmode
Node in global list of master ports

\item[{\code{nnode}}] \leavevmode
Node in network list of master ports

\item[{\code{net}}] \leavevmode
RIO net this mport is attached to

\item[{\code{lock}}] \leavevmode
lock to synchronize lists manipulations

\item[{\code{iores}}] \leavevmode
I/O mem resource that this master port interface owns

\item[{\code{riores}}] \leavevmode
RIO resources that this master port interfaces owns

\item[{\code{inb\_msg}}] \leavevmode
RIO inbound message event descriptors

\item[{\code{outb\_msg}}] \leavevmode
RIO outbound message event descriptors

\item[{\code{host\_deviceid}}] \leavevmode
Host device ID associated with this master port

\item[{\code{ops}}] \leavevmode
configuration space functions

\item[{\code{id}}] \leavevmode
Port ID, unique among all ports

\item[{\code{index}}] \leavevmode
Port index, unique among all port interfaces of the same type

\item[{\code{sys\_size}}] \leavevmode
RapidIO common transport system size

\item[{\code{phys\_efptr}}] \leavevmode
RIO port extended features pointer

\item[{\code{phys\_rmap}}] \leavevmode
LP-Serial EFB Register Mapping type (1 or 2).

\item[{\code{name}}] \leavevmode
Port name string

\item[{\code{dev}}] \leavevmode
device structure associated with an mport

\item[{\code{priv}}] \leavevmode
Master port private data

\item[{\code{dma}}] \leavevmode
DMA device associated with mport

\item[{\code{nscan}}] \leavevmode
RapidIO network enumeration/discovery operations

\item[{\code{state}}] \leavevmode
mport device state

\item[{\code{pwe\_refcnt}}] \leavevmode
port-write enable ref counter to track enable/disable requests

\end{description}
\index{rio\_net (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_net}\pysigline{struct \bfcode{rio\_net}}
RIO network info

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct rio\PYGZus{}net \PYGZob{}
  struct list\PYGZus{}head node;
  struct list\PYGZus{}head devices;
  struct list\PYGZus{}head switches;
  struct list\PYGZus{}head mports;
  struct rio\PYGZus{}mport *hport;
  unsigned char id;
  struct device dev;
  void *enum\PYGZus{}data;
  void (*release)(struct rio\PYGZus{}net *net);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{node}}] \leavevmode
Node in global list of RIO networks

\item[{\code{devices}}] \leavevmode
List of devices in this network

\item[{\code{switches}}] \leavevmode
List of switches in this network

\item[{\code{mports}}] \leavevmode
List of master ports accessing this network

\item[{\code{hport}}] \leavevmode
Default port for accessing this network

\item[{\code{id}}] \leavevmode
RIO network ID

\item[{\code{dev}}] \leavevmode
Device object

\item[{\code{enum\_data}}] \leavevmode
private data specific to a network enumerator

\item[{\code{release}}] \leavevmode
enumerator-specific release callback

\end{description}
\index{rio\_mport\_attr (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_mport_attr}\pysigline{struct \bfcode{rio\_mport\_attr}}
RIO mport device attributes

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct rio\PYGZus{}mport\PYGZus{}attr \PYGZob{}
  int flags;
  int link\PYGZus{}speed;
  int link\PYGZus{}width;
  int dma\PYGZus{}max\PYGZus{}sge;
  int dma\PYGZus{}max\PYGZus{}size;
  int dma\PYGZus{}align;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{flags}}] \leavevmode
mport device capability flags

\item[{\code{link\_speed}}] \leavevmode
SRIO link speed value (as defined by RapidIO specification)

\item[{\code{link\_width}}] \leavevmode
SRIO link width value (as defined by RapidIO specification)

\item[{\code{dma\_max\_sge}}] \leavevmode
number of SG list entries that can be handled by DMA channel(s)

\item[{\code{dma\_max\_size}}] \leavevmode
max number of bytes in single DMA transfer (SG entry)

\item[{\code{dma\_align}}] \leavevmode
alignment shift for DMA operations (as for other DMA operations)

\end{description}
\index{rio\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_ops}\pysigline{struct \bfcode{rio\_ops}}
Low-level RIO configuration space operations

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct rio\PYGZus{}ops \PYGZob{}
  int (*lcread) (struct rio\PYGZus{}mport *mport, int index, u32 offset, int len, u32 *data);
  int (*lcwrite) (struct rio\PYGZus{}mport *mport, int index, u32 offset, int len, u32 data);
  int (*cread) (struct rio\PYGZus{}mport *mport, int index, u16 destid, u8 hopcount, u32 offset, int len, u32 *data);
  int (*cwrite) (struct rio\PYGZus{}mport *mport, int index, u16 destid, u8 hopcount, u32 offset, int len, u32 data);
  int (*dsend) (struct rio\PYGZus{}mport *mport, int index, u16 destid, u16 data);
  int (*pwenable) (struct rio\PYGZus{}mport *mport, int enable);
  int (*open\PYGZus{}outb\PYGZus{}mbox)(struct rio\PYGZus{}mport *mport, void *dev\PYGZus{}id, int mbox, int entries);
  void (*close\PYGZus{}outb\PYGZus{}mbox)(struct rio\PYGZus{}mport *mport, int mbox);
  int (*open\PYGZus{}inb\PYGZus{}mbox)(struct rio\PYGZus{}mport *mport, void *dev\PYGZus{}id, int mbox, int entries);
  void (*close\PYGZus{}inb\PYGZus{}mbox)(struct rio\PYGZus{}mport *mport, int mbox);
  int (*add\PYGZus{}outb\PYGZus{}message)(struct rio\PYGZus{}mport *mport, struct rio\PYGZus{}dev *rdev, int mbox, void *buffer, size\PYGZus{}t len);
  int (*add\PYGZus{}inb\PYGZus{}buffer)(struct rio\PYGZus{}mport *mport, int mbox, void *buf);
  void *(*get\PYGZus{}inb\PYGZus{}message)(struct rio\PYGZus{}mport *mport, int mbox);
  int (*map\PYGZus{}inb)(struct rio\PYGZus{}mport *mport, dma\PYGZus{}addr\PYGZus{}t lstart, u64 rstart, u64 size, u32 flags);
  void (*unmap\PYGZus{}inb)(struct rio\PYGZus{}mport *mport, dma\PYGZus{}addr\PYGZus{}t lstart);
  int (*query\PYGZus{}mport)(struct rio\PYGZus{}mport *mport, struct rio\PYGZus{}mport\PYGZus{}attr *attr);
  int (*map\PYGZus{}outb)(struct rio\PYGZus{}mport *mport, u16 destid, u64 rstart, u32 size, u32 flags, dma\PYGZus{}addr\PYGZus{}t *laddr);
  void (*unmap\PYGZus{}outb)(struct rio\PYGZus{}mport *mport, u16 destid, u64 rstart);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{lcread}}] \leavevmode
Callback to perform local (master port) read of config space.

\item[{\code{lcwrite}}] \leavevmode
Callback to perform local (master port) write of config space.

\item[{\code{cread}}] \leavevmode
Callback to perform network read of config space.

\item[{\code{cwrite}}] \leavevmode
Callback to perform network write of config space.

\item[{\code{dsend}}] \leavevmode
Callback to send a doorbell message.

\item[{\code{pwenable}}] \leavevmode
Callback to enable/disable port-write message handling.

\item[{\code{open\_outb\_mbox}}] \leavevmode
Callback to initialize outbound mailbox.

\item[{\code{close\_outb\_mbox}}] \leavevmode
Callback to shut down outbound mailbox.

\item[{\code{open\_inb\_mbox}}] \leavevmode
Callback to initialize inbound mailbox.

\item[{\code{close\_inb\_mbox}}] \leavevmode
Callback to shut down inbound mailbox.

\item[{\code{add\_outb\_message}}] \leavevmode
Callback to add a message to an outbound mailbox queue.

\item[{\code{add\_inb\_buffer}}] \leavevmode
Callback to add a buffer to an inbound mailbox queue.

\item[{\code{get\_inb\_message}}] \leavevmode
Callback to get a message from an inbound mailbox queue.

\item[{\code{map\_inb}}] \leavevmode
Callback to map RapidIO address region into local memory space.

\item[{\code{unmap\_inb}}] \leavevmode
Callback to unmap RapidIO address region mapped with \code{map\_inb()}.

\item[{\code{query\_mport}}] \leavevmode
Callback to query mport device attributes.

\item[{\code{map\_outb}}] \leavevmode
Callback to map outbound address region into local memory space.

\item[{\code{unmap\_outb}}] \leavevmode
Callback to unmap outbound RapidIO address region.

\end{description}
\index{rio\_driver (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_driver}\pysigline{struct \bfcode{rio\_driver}}
RIO driver info

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct rio\PYGZus{}driver \PYGZob{}
  struct list\PYGZus{}head node;
  char *name;
  const struct rio\PYGZus{}device\PYGZus{}id *id\PYGZus{}table;
  int (*probe) (struct rio\PYGZus{}dev * dev, const struct rio\PYGZus{}device\PYGZus{}id * id);
  void (*remove) (struct rio\PYGZus{}dev * dev);
  void (*shutdown)(struct rio\PYGZus{}dev *dev);
  int (*suspend) (struct rio\PYGZus{}dev * dev, u32 state);
  int (*resume) (struct rio\PYGZus{}dev * dev);
  int (*enable\PYGZus{}wake) (struct rio\PYGZus{}dev * dev, u32 state, int enable);
  struct device\PYGZus{}driver driver;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{node}}] \leavevmode
Node in list of drivers

\item[{\code{name}}] \leavevmode
RIO driver name

\item[{\code{id\_table}}] \leavevmode
RIO device ids to be associated with this driver

\item[{\code{probe}}] \leavevmode
RIO device inserted

\item[{\code{remove}}] \leavevmode
RIO device removed

\item[{\code{shutdown}}] \leavevmode
shutdown notification callback

\item[{\code{suspend}}] \leavevmode
RIO device suspended

\item[{\code{resume}}] \leavevmode
RIO device awakened

\item[{\code{enable\_wake}}] \leavevmode
RIO device enable wake event

\item[{\code{driver}}] \leavevmode
LDM driver struct

\end{description}

\textbf{Description}

Provides info on a RIO device driver for insertion/removal and
power management purposes.
\index{rio\_scan (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_scan}\pysigline{struct \bfcode{rio\_scan}}
RIO enumeration and discovery operations

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct rio\PYGZus{}scan \PYGZob{}
  struct module *owner;
  int (*enumerate)(struct rio\PYGZus{}mport *mport, u32 flags);
  int (*discover)(struct rio\PYGZus{}mport *mport, u32 flags);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{owner}}] \leavevmode
The module owner of this structure

\item[{\code{enumerate}}] \leavevmode
Callback to perform RapidIO fabric enumeration.

\item[{\code{discover}}] \leavevmode
Callback to perform RapidIO fabric discovery.

\end{description}
\index{rio\_scan\_node (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_scan_node}\pysigline{struct \bfcode{rio\_scan\_node}}
list node to register RapidIO enumeration and discovery methods with RapidIO core.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct rio\PYGZus{}scan\PYGZus{}node \PYGZob{}
  int mport\PYGZus{}id;
  struct list\PYGZus{}head node;
  struct rio\PYGZus{}scan *ops;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{mport\_id}}] \leavevmode
ID of an mport (net) serviced by this enumerator

\item[{\code{node}}] \leavevmode
node in global list of registered enumerators

\item[{\code{ops}}] \leavevmode
RIO enumeration and discovery operations

\end{description}


\subsection{Enumeration and Discovery}
\label{driver-api/rapidio:enumeration-and-discovery}\index{rio\_destid\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_destid_alloc}\pysiglinewithargsret{u16 \bfcode{rio\_destid\_alloc}}{struct {\hyperref[driver\string-api/rapidio:c.rio_net]{\emph{rio\_net}}} *\emph{ net}}{}
Allocate next available destID for given network

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_net * net}}] \leavevmode
RIO network

\end{description}

\textbf{Description}

Returns next available device destination ID for the specified RIO network.
Marks allocated ID as one in use.
Returns RIO\_INVALID\_DESTID if new destID is not available.
\index{rio\_destid\_reserve (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_destid_reserve}\pysiglinewithargsret{int \bfcode{rio\_destid\_reserve}}{struct {\hyperref[driver\string-api/rapidio:c.rio_net]{\emph{rio\_net}}} *\emph{ net}, u16\emph{ destid}}{}
Reserve the specivied destID

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_net * net}}] \leavevmode
RIO network

\item[{\code{u16 destid}}] \leavevmode
destID to reserve

\end{description}

\textbf{Description}

Tries to reserve the specified destID.
Returns 0 if successful.
\index{rio\_destid\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_destid_free}\pysiglinewithargsret{void \bfcode{rio\_destid\_free}}{struct {\hyperref[driver\string-api/rapidio:c.rio_net]{\emph{rio\_net}}} *\emph{ net}, u16\emph{ destid}}{}
free a previously allocated destID

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_net * net}}] \leavevmode
RIO network

\item[{\code{u16 destid}}] \leavevmode
destID to free

\end{description}

\textbf{Description}

Makes the specified destID available for use.
\index{rio\_destid\_first (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_destid_first}\pysiglinewithargsret{u16 \bfcode{rio\_destid\_first}}{struct {\hyperref[driver\string-api/rapidio:c.rio_net]{\emph{rio\_net}}} *\emph{ net}}{}
return first destID in use

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_net * net}}] \leavevmode
RIO network

\end{description}
\index{rio\_destid\_next (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_destid_next}\pysiglinewithargsret{u16 \bfcode{rio\_destid\_next}}{struct {\hyperref[driver\string-api/rapidio:c.rio_net]{\emph{rio\_net}}} *\emph{ net}, u16\emph{ from}}{}
return next destID in use

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_net * net}}] \leavevmode
RIO network

\item[{\code{u16 from}}] \leavevmode
destination ID from which search shall continue

\end{description}
\index{rio\_get\_device\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_get_device_id}\pysiglinewithargsret{u16 \bfcode{rio\_get\_device\_id}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, u16\emph{ destid}, u8\emph{ hopcount}}{}
Get the base/extended device id for a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
RIO master port

\item[{\code{u16 destid}}] \leavevmode
Destination ID of device

\item[{\code{u8 hopcount}}] \leavevmode
Hopcount to device

\end{description}

\textbf{Description}

Reads the base/extended device id from a device. Returns the
8/16-bit device ID.
\index{rio\_set\_device\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_set_device_id}\pysiglinewithargsret{void \bfcode{rio\_set\_device\_id}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, u16\emph{ destid}, u8\emph{ hopcount}, u16\emph{ did}}{}
Set the base/extended device id for a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
RIO master port

\item[{\code{u16 destid}}] \leavevmode
Destination ID of device

\item[{\code{u8 hopcount}}] \leavevmode
Hopcount to device

\item[{\code{u16 did}}] \leavevmode
Device ID value to be written

\end{description}

\textbf{Description}

Writes the base/extended device id from a device.
\index{rio\_clear\_locks (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_clear_locks}\pysiglinewithargsret{int \bfcode{rio\_clear\_locks}}{struct {\hyperref[driver\string-api/rapidio:c.rio_net]{\emph{rio\_net}}} *\emph{ net}}{}
Release all host locks and signal enumeration complete

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_net * net}}] \leavevmode
RIO network to run on

\end{description}

\textbf{Description}

Marks the component tag CSR on each device with the enumeration
complete flag. When complete, it then release the host locks on
each device. Returns 0 on success or \code{-EINVAL} on failure.
\index{rio\_enum\_host (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_enum_host}\pysiglinewithargsret{int \bfcode{rio\_enum\_host}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}}{}
Set host lock and initialize host destination ID

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port to issue transaction

\end{description}

\textbf{Description}

Sets the local host master port lock and destination ID register
with the host device ID value. The host device ID value is provided
by the platform. Returns \code{0} on success or \code{-1} on failure.
\index{rio\_device\_has\_destid (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_device_has_destid}\pysiglinewithargsret{int \bfcode{rio\_device\_has\_destid}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, int\emph{ src\_ops}, int\emph{ dst\_ops}}{}
Test if a device contains a destination ID register

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port to issue transaction

\item[{\code{int src\_ops}}] \leavevmode
RIO device source operations

\item[{\code{int dst\_ops}}] \leavevmode
RIO device destination operations

\end{description}

\textbf{Description}

Checks the provided \textbf{src\_ops} and \textbf{dst\_ops} for the necessary transaction
capabilities that indicate whether or not a device will implement a
destination ID register. Returns 1 if true or 0 if false.
\index{rio\_release\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_release_dev}\pysiglinewithargsret{void \bfcode{rio\_release\_dev}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
Frees a RIO device struct

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
LDM device associated with a RIO device struct

\end{description}

\textbf{Description}

Gets the RIO device struct associated a RIO device struct.
The RIO device struct is freed.
\index{rio\_is\_switch (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_is_switch}\pysiglinewithargsret{int \bfcode{rio\_is\_switch}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}}{}
Tests if a RIO device has switch capabilities

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device

\end{description}

\textbf{Description}

Gets the RIO device Processing Element Features register
contents and tests for switch capabilities. Returns 1 if
the device is a switch or 0 if it is not a switch.
The RIO device struct is freed.
\index{rio\_setup\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_setup_device}\pysiglinewithargsret{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} * \bfcode{rio\_setup\_device}}{struct {\hyperref[driver\string-api/rapidio:c.rio_net]{\emph{rio\_net}}} *\emph{ net}, struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, u16\emph{ destid}, u8\emph{ hopcount}, int\emph{ do\_enum}}{}
Allocates and sets up a RIO device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_net * net}}] \leavevmode
RIO network

\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port to send transactions

\item[{\code{u16 destid}}] \leavevmode
Current destination ID

\item[{\code{u8 hopcount}}] \leavevmode
Current hopcount

\item[{\code{int do\_enum}}] \leavevmode
Enumeration/Discovery mode flag

\end{description}

\textbf{Description}

Allocates a RIO device and configures fields based on configuration
space contents. If device has a destination ID register, a destination
ID is either assigned in enumeration mode or read from configuration
space in discovery mode.  If the device has switch capabilities, then
a switch is allocated and configured appropriately. Returns a pointer
to a RIO device on success or NULL on failure.
\index{rio\_sport\_is\_active (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_sport_is_active}\pysiglinewithargsret{int \bfcode{rio\_sport\_is\_active}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, int\emph{ sp}}{}
Tests if a switch port has an active connection.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RapidIO device object

\item[{\code{int sp}}] \leavevmode
Switch port number

\end{description}

\textbf{Description}

Reads the port error status CSR for a particular switch port to
determine if the port has an active link.  Returns
\code{RIO\_PORT\_N\_ERR\_STS\_PORT\_OK} if the port is active or \code{0} if it is
inactive.
\index{rio\_get\_host\_deviceid\_lock (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_get_host_deviceid_lock}\pysiglinewithargsret{u16 \bfcode{rio\_get\_host\_deviceid\_lock}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, u8\emph{ hopcount}}{}
Reads the Host Device ID Lock CSR on a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port to send transaction

\item[{\code{u8 hopcount}}] \leavevmode
Number of hops to the device

\end{description}

\textbf{Description}

Used during enumeration to read the Host Device ID Lock CSR on a
RIO device. Returns the value of the lock register.
\index{rio\_enum\_peer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_enum_peer}\pysiglinewithargsret{int \bfcode{rio\_enum\_peer}}{struct {\hyperref[driver\string-api/rapidio:c.rio_net]{\emph{rio\_net}}} *\emph{ net}, struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, u8\emph{ hopcount}, struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ prev}, int\emph{ prev\_port}}{}
Recursively enumerate a RIO network through a master port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_net * net}}] \leavevmode
RIO network being enumerated

\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port to send transactions

\item[{\code{u8 hopcount}}] \leavevmode
Number of hops into the network

\item[{\code{struct rio\_dev * prev}}] \leavevmode
Previous RIO device connected to the enumerated one

\item[{\code{int prev\_port}}] \leavevmode
Port on previous RIO device

\end{description}

\textbf{Description}

Recursively enumerates a RIO network.  Transactions are sent via the
master port passed in \textbf{port}.
\index{rio\_enum\_complete (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_enum_complete}\pysiglinewithargsret{int \bfcode{rio\_enum\_complete}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}}{}
Tests if enumeration of a network is complete

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port to send transaction

\end{description}

\textbf{Description}

Tests the PGCCSR discovered bit for non-zero value (enumeration
complete flag). Return \code{1} if enumeration is complete or \code{0} if
enumeration is incomplete.
\index{rio\_disc\_peer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_disc_peer}\pysiglinewithargsret{int \bfcode{rio\_disc\_peer}}{struct {\hyperref[driver\string-api/rapidio:c.rio_net]{\emph{rio\_net}}} *\emph{ net}, struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}, u16\emph{ destid}, u8\emph{ hopcount}, struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ prev}, int\emph{ prev\_port}}{}
Recursively discovers a RIO network through a master port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_net * net}}] \leavevmode
RIO network being discovered

\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port to send transactions

\item[{\code{u16 destid}}] \leavevmode
Current destination ID in network

\item[{\code{u8 hopcount}}] \leavevmode
Number of hops into the network

\item[{\code{struct rio\_dev * prev}}] \leavevmode
previous rio\_dev

\item[{\code{int prev\_port}}] \leavevmode
previous port number

\end{description}

\textbf{Description}

Recursively discovers a RIO network.  Transactions are sent via the
master port passed in \textbf{port}.
\index{rio\_mport\_is\_active (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_mport_is_active}\pysiglinewithargsret{int \bfcode{rio\_mport\_is\_active}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ port}}{}
Tests if master port link is active

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * port}}] \leavevmode
Master port to test

\end{description}

\textbf{Description}

Reads the port error status CSR for the master port to
determine if the port has an active link.  Returns
\code{RIO\_PORT\_N\_ERR\_STS\_PORT\_OK} if the  master port is active
or \code{0} if it is inactive.
\index{rio\_update\_route\_tables (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_update_route_tables}\pysiglinewithargsret{void \bfcode{rio\_update\_route\_tables}}{struct {\hyperref[driver\string-api/rapidio:c.rio_net]{\emph{rio\_net}}} *\emph{ net}}{}
Updates route tables in switches

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_net * net}}] \leavevmode
RIO network to run update on

\end{description}

\textbf{Description}

For each enumerated device, ensure that each switch in a system
has correct routing entries. Add routes for devices that where
unknown dirung the first enumeration pass through the switch.
\index{rio\_init\_em (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_init_em}\pysiglinewithargsret{void \bfcode{rio\_init\_em}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}}{}
Initializes RIO Error Management (for switches)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device

\end{description}

\textbf{Description}

For each enumerated switch, call device-specific error management
initialization routine (if supplied by the switch driver).
\index{rio\_enum\_mport (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_enum_mport}\pysiglinewithargsret{int \bfcode{rio\_enum\_mport}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, u32\emph{ flags}}{}
Start enumeration through a master port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
Master port to send transactions

\item[{\code{u32 flags}}] \leavevmode
Enumeration control flags

\end{description}

\textbf{Description}

Starts the enumeration process. If somebody has enumerated our
master port device, then give up. If not and we have an active
link, then start recursive peer enumeration. Returns \code{0} if
enumeration succeeds or \code{-EBUSY} if enumeration fails.
\index{rio\_build\_route\_tables (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_build_route_tables}\pysiglinewithargsret{void \bfcode{rio\_build\_route\_tables}}{struct {\hyperref[driver\string-api/rapidio:c.rio_net]{\emph{rio\_net}}} *\emph{ net}}{}
Generate route tables from switch route entries

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_net * net}}] \leavevmode
RIO network to run route tables scan on

\end{description}

\textbf{Description}

For each switch device, generate a route table by copying existing
route entries from the switch.
\index{rio\_disc\_mport (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_disc_mport}\pysiglinewithargsret{int \bfcode{rio\_disc\_mport}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, u32\emph{ flags}}{}
Start discovery through a master port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
Master port to send transactions

\item[{\code{u32 flags}}] \leavevmode
discovery control flags

\end{description}

\textbf{Description}

Starts the discovery process. If we have an active link,
then wait for the signal that enumeration is complete (if wait
is allowed).
When enumeration completion is signaled, start recursive
peer discovery. Returns \code{0} if discovery succeeds or \code{-EBUSY}
on failure.
\index{rio\_basic\_attach (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_basic_attach}\pysiglinewithargsret{int \bfcode{rio\_basic\_attach}}{void}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

When this enumeration/discovery method is loaded as a module this function
registers its specific enumeration and discover routines for all available
RapidIO mport devices. The ``scan'' command line parameter controls ability of
the module to start RapidIO enumeration/discovery automatically.

Returns 0 for success or -EIO if unable to register itself.

This enumeration/discovery method cannot be unloaded and therefore does not
provide a matching cleanup\_module routine.


\subsection{Driver functionality}
\label{driver-api/rapidio:driver-functionality}\index{rio\_setup\_inb\_dbell (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_setup_inb_dbell}\pysiglinewithargsret{int \bfcode{rio\_setup\_inb\_dbell}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, void *\emph{ dev\_id}, struct resource *\emph{ res}, void (*dinb) (struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, void\emph{ *dev\_id}, u16\emph{ src}, u16\emph{ dst}, u16\emph{ info}}{}
bind inbound doorbell callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
RIO master port to bind the doorbell callback

\item[{\code{void * dev\_id}}] \leavevmode
Device specific pointer to pass on event

\item[{\code{struct resource * res}}] \leavevmode
Doorbell message resource

\item[{\code{void (*) (struct rio\_mport * mport, void *dev\_id, u16 src, u16 dst, u16 info) dinb}}] \leavevmode
Callback to execute when doorbell is received

\end{description}

\textbf{Description}

Adds a doorbell resource/callback pair into a port's
doorbell event list. Returns 0 if the request has been
satisfied.
\index{rio\_chk\_dev\_route (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_chk_dev_route}\pysiglinewithargsret{int \bfcode{rio\_chk\_dev\_route}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} **\emph{ nrdev}, int *\emph{ npnum}}{}
Validate route to the specified device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO device failed to respond

\item[{\code{struct rio\_dev ** nrdev}}] \leavevmode
Last active device on the route to rdev

\item[{\code{int * npnum}}] \leavevmode
nrdev's port number on the route to rdev

\end{description}

\textbf{Description}

Follows a route to the specified RIO device to determine the last available
device (and corresponding RIO port) on the route.
\index{rio\_chk\_dev\_access (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_chk_dev_access}\pysiglinewithargsret{int \bfcode{rio\_chk\_dev\_access}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}}{}
Validate access to the specified device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
Pointer to RIO device control structure

\end{description}
\index{rio\_get\_input\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_get_input_status}\pysiglinewithargsret{int \bfcode{rio\_get\_input\_status}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, int\emph{ pnum}, u32 *\emph{ lnkresp}}{}
Sends a Link-Request/Input-Status control symbol and returns link-response (if requested).

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
RIO devive to issue Input-status command

\item[{\code{int pnum}}] \leavevmode
Device port number to issue the command

\item[{\code{u32 * lnkresp}}] \leavevmode
Response from a link partner

\end{description}
\index{rio\_clr\_err\_stopped (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_clr_err_stopped}\pysiglinewithargsret{int \bfcode{rio\_clr\_err\_stopped}}{struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}, u32\emph{ pnum}, u32\emph{ err\_status}}{}
Clears port Error-stopped states.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_dev * rdev}}] \leavevmode
Pointer to RIO device control structure

\item[{\code{u32 pnum}}] \leavevmode
Switch port number to clear errors

\item[{\code{u32 err\_status}}] \leavevmode
port error status (if 0 reads register from device)

\end{description}

\textbf{Description}

TODO: Currently this routine is not compatible with recovery process
specified for idt\_gen3 RapidIO switch devices. It has to be reviewed
to implement universal recovery process that is compatible full range
off available devices.
IDT gen3 switch driver now implements HW-specific error handler that
issues soft port reset to the port to reset ERR\_STOP bits and ackIDs.
\index{rio\_std\_route\_add\_entry (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_std_route_add_entry}\pysiglinewithargsret{int \bfcode{rio\_std\_route\_add\_entry}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, u16\emph{ destid}, u8\emph{ hopcount}, u16\emph{ table}, u16\emph{ route\_destid}, u8\emph{ route\_port}}{}
Add switch route table entry using standard registers defined in RIO specification rev.1.3

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
Master port to issue transaction

\item[{\code{u16 destid}}] \leavevmode
Destination ID of the device

\item[{\code{u8 hopcount}}] \leavevmode
Number of switch hops to the device

\item[{\code{u16 table}}] \leavevmode
routing table ID (global or port-specific)

\item[{\code{u16 route\_destid}}] \leavevmode
destID entry in the RT

\item[{\code{u8 route\_port}}] \leavevmode
destination port for specified destID

\end{description}
\index{rio\_std\_route\_get\_entry (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_std_route_get_entry}\pysiglinewithargsret{int \bfcode{rio\_std\_route\_get\_entry}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, u16\emph{ destid}, u8\emph{ hopcount}, u16\emph{ table}, u16\emph{ route\_destid}, u8 *\emph{ route\_port}}{}
Read switch route table entry (port number) associated with specified destID using standard registers defined in RIO specification rev.1.3

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
Master port to issue transaction

\item[{\code{u16 destid}}] \leavevmode
Destination ID of the device

\item[{\code{u8 hopcount}}] \leavevmode
Number of switch hops to the device

\item[{\code{u16 table}}] \leavevmode
routing table ID (global or port-specific)

\item[{\code{u16 route\_destid}}] \leavevmode
destID entry in the RT

\item[{\code{u8 * route\_port}}] \leavevmode
returned destination port for specified destID

\end{description}
\index{rio\_std\_route\_clr\_table (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_std_route_clr_table}\pysiglinewithargsret{int \bfcode{rio\_std\_route\_clr\_table}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, u16\emph{ destid}, u8\emph{ hopcount}, u16\emph{ table}}{}
Clear swotch route table using standard registers defined in RIO specification rev.1.3.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
Master port to issue transaction

\item[{\code{u16 destid}}] \leavevmode
Destination ID of the device

\item[{\code{u8 hopcount}}] \leavevmode
Number of switch hops to the device

\item[{\code{u16 table}}] \leavevmode
routing table ID (global or port-specific)

\end{description}
\index{rio\_find\_mport (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_find_mport}\pysiglinewithargsret{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} * \bfcode{rio\_find\_mport}}{int\emph{ mport\_id}}{}
find RIO mport by its ID

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int mport\_id}}] \leavevmode
number (ID) of mport device

\end{description}

\textbf{Description}

Given a RIO mport number, the desired mport is located
in the global list of mports. If the mport is found, a pointer to its
data structure is returned.  If no mport is found, \code{NULL} is returned.
\index{rio\_mport\_scan (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_mport_scan}\pysiglinewithargsret{int \bfcode{rio\_mport\_scan}}{int\emph{ mport\_id}}{}
execute enumeration/discovery on the specified mport

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int mport\_id}}] \leavevmode
number (ID) of mport device

\end{description}
\index{RIO\_LOP\_READ (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.RIO_LOP_READ}\pysiglinewithargsret{\bfcode{RIO\_LOP\_READ}}{\emph{size}, \emph{type}, \emph{len}}{}
Generate rio\_local\_read\_config\_* functions

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{size}}] \leavevmode
Size of configuration space read (8, 16, 32 bits)

\item[{\code{type}}] \leavevmode
C type of value argument

\item[{\code{len}}] \leavevmode
Length of configuration space read (1, 2, 4 bytes)

\end{description}

\textbf{Description}

Generates rio\_local\_read\_config\_* functions used to access
configuration space registers on the local device.
\index{RIO\_LOP\_WRITE (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.RIO_LOP_WRITE}\pysiglinewithargsret{\bfcode{RIO\_LOP\_WRITE}}{\emph{size}, \emph{type}, \emph{len}}{}
Generate rio\_local\_write\_config\_* functions

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{size}}] \leavevmode
Size of configuration space write (8, 16, 32 bits)

\item[{\code{type}}] \leavevmode
C type of value argument

\item[{\code{len}}] \leavevmode
Length of configuration space write (1, 2, 4 bytes)

\end{description}

\textbf{Description}

Generates rio\_local\_write\_config\_* functions used to access
configuration space registers on the local device.
\index{RIO\_OP\_READ (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.RIO_OP_READ}\pysiglinewithargsret{\bfcode{RIO\_OP\_READ}}{\emph{size}, \emph{type}, \emph{len}}{}
Generate rio\_mport\_read\_config\_* functions

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{size}}] \leavevmode
Size of configuration space read (8, 16, 32 bits)

\item[{\code{type}}] \leavevmode
C type of value argument

\item[{\code{len}}] \leavevmode
Length of configuration space read (1, 2, 4 bytes)

\end{description}

\textbf{Description}

Generates rio\_mport\_read\_config\_* functions used to access
configuration space registers on the local device.
\index{RIO\_OP\_WRITE (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.RIO_OP_WRITE}\pysiglinewithargsret{\bfcode{RIO\_OP\_WRITE}}{\emph{size}, \emph{type}, \emph{len}}{}
Generate rio\_mport\_write\_config\_* functions

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{size}}] \leavevmode
Size of configuration space write (8, 16, 32 bits)

\item[{\code{type}}] \leavevmode
C type of value argument

\item[{\code{len}}] \leavevmode
Length of configuration space write (1, 2, 4 bytes)

\end{description}

\textbf{Description}

Generates rio\_mport\_write\_config\_* functions used to access
configuration space registers on the local device.


\subsection{Device model support}
\label{driver-api/rapidio:device-model-support}\index{rio\_match\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_match_device}\pysiglinewithargsret{const struct {\hyperref[driver\string-api/basics:c.rio_device_id]{\emph{rio\_device\_id}}} * \bfcode{rio\_match\_device}}{const struct {\hyperref[driver\string-api/basics:c.rio_device_id]{\emph{rio\_device\_id}}} *\emph{ id}, const struct {\hyperref[driver\string-api/rapidio:c.rio_dev]{\emph{rio\_dev}}} *\emph{ rdev}}{}
Tell if a RIO device has a matching RIO device id structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct rio\_device\_id * id}}] \leavevmode
the RIO device id structure to match against

\item[{\code{const struct rio\_dev * rdev}}] \leavevmode
the RIO device structure to match against

\end{description}

\textbf{Description}
\begin{quote}

Used from driver probe and bus matching to check whether a RIO device
matches a device id structure provided by a RIO driver. Returns the
matching {\hyperref[driver\string-api/basics:c.rio_device_id]{\emph{\code{struct rio\_device\_id}}}} or \code{NULL} if there is no match.
\end{quote}
\index{rio\_device\_probe (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_device_probe}\pysiglinewithargsret{int \bfcode{rio\_device\_probe}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
Tell if a RIO device structure has a matching RIO device id structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
the RIO device structure to match against

\end{description}

\textbf{Description}

return 0 and set rio\_dev-\textgreater{}driver when drv claims rio\_dev, else error
\index{rio\_device\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_device_remove}\pysiglinewithargsret{int \bfcode{rio\_device\_remove}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
Remove a RIO device from the system

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
the RIO device structure to match against

\end{description}

\textbf{Description}

Remove a RIO device from the system. If it has an associated
driver, then run the driver \code{remove()} method.  Then update
the reference count.
\index{rio\_match\_bus (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_match_bus}\pysiglinewithargsret{int \bfcode{rio\_match\_bus}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct {\hyperref[driver\string-api/infrastructure:c.device_driver]{\emph{device\_driver}}} *\emph{ drv}}{}
Tell if a RIO device structure has a matching RIO driver device id structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
the standard device structure to match against

\item[{\code{struct device\_driver * drv}}] \leavevmode
the standard driver structure containing the ids to match against

\end{description}

\textbf{Description}
\begin{quote}

Used by a driver to check whether a RIO device present in the
system is in its list of supported devices. Returns 1 if
there is a matching {\hyperref[driver\string-api/basics:c.rio_device_id]{\emph{\code{struct rio\_device\_id}}}} or 0 if there is
no match.
\end{quote}
\index{rio\_bus\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.rio_bus_init}\pysiglinewithargsret{int \bfcode{rio\_bus\_init}}{void}{}
Register the RapidIO bus with the device model

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}
\begin{quote}

Registers the RIO mport device class and RIO bus type with the Linux
device model.
\end{quote}


\subsection{PPC32 support}
\label{driver-api/rapidio:ppc32-support}\index{fsl\_local\_config\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.fsl_local_config_read}\pysiglinewithargsret{int \bfcode{fsl\_local\_config\_read}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, int\emph{ index}, u32\emph{ offset}, int\emph{ len}, u32 *\emph{ data}}{}
Generate a MPC85xx local config space read

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
RapidIO master port info

\item[{\code{int index}}] \leavevmode
ID of RapdiIO interface

\item[{\code{u32 offset}}] \leavevmode
Offset into configuration space

\item[{\code{int len}}] \leavevmode
Length (in bytes) of the maintenance transaction

\item[{\code{u32 * data}}] \leavevmode
Value to be read into

\end{description}

\textbf{Description}

Generates a MPC85xx local configuration space read. Returns \code{0} on
success or \code{-EINVAL} on failure.
\index{fsl\_local\_config\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.fsl_local_config_write}\pysiglinewithargsret{int \bfcode{fsl\_local\_config\_write}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, int\emph{ index}, u32\emph{ offset}, int\emph{ len}, u32\emph{ data}}{}
Generate a MPC85xx local config space write

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
RapidIO master port info

\item[{\code{int index}}] \leavevmode
ID of RapdiIO interface

\item[{\code{u32 offset}}] \leavevmode
Offset into configuration space

\item[{\code{int len}}] \leavevmode
Length (in bytes) of the maintenance transaction

\item[{\code{u32 data}}] \leavevmode
Value to be written

\end{description}

\textbf{Description}

Generates a MPC85xx local configuration space write. Returns \code{0} on
success or \code{-EINVAL} on failure.
\index{fsl\_rio\_config\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.fsl_rio_config_read}\pysiglinewithargsret{int \bfcode{fsl\_rio\_config\_read}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, int\emph{ index}, u16\emph{ destid}, u8\emph{ hopcount}, u32\emph{ offset}, int\emph{ len}, u32 *\emph{ val}}{}
Generate a MPC85xx read maintenance transaction

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
RapidIO master port info

\item[{\code{int index}}] \leavevmode
ID of RapdiIO interface

\item[{\code{u16 destid}}] \leavevmode
Destination ID of transaction

\item[{\code{u8 hopcount}}] \leavevmode
Number of hops to target device

\item[{\code{u32 offset}}] \leavevmode
Offset into configuration space

\item[{\code{int len}}] \leavevmode
Length (in bytes) of the maintenance transaction

\item[{\code{u32 * val}}] \leavevmode
Location to be read into

\end{description}

\textbf{Description}

Generates a MPC85xx read maintenance transaction. Returns \code{0} on
success or \code{-EINVAL} on failure.
\index{fsl\_rio\_config\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.fsl_rio_config_write}\pysiglinewithargsret{int \bfcode{fsl\_rio\_config\_write}}{struct {\hyperref[driver\string-api/rapidio:c.rio_mport]{\emph{rio\_mport}}} *\emph{ mport}, int\emph{ index}, u16\emph{ destid}, u8\emph{ hopcount}, u32\emph{ offset}, int\emph{ len}, u32\emph{ val}}{}
Generate a MPC85xx write maintenance transaction

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rio\_mport * mport}}] \leavevmode
RapidIO master port info

\item[{\code{int index}}] \leavevmode
ID of RapdiIO interface

\item[{\code{u16 destid}}] \leavevmode
Destination ID of transaction

\item[{\code{u8 hopcount}}] \leavevmode
Number of hops to target device

\item[{\code{u32 offset}}] \leavevmode
Offset into configuration space

\item[{\code{int len}}] \leavevmode
Length (in bytes) of the maintenance transaction

\item[{\code{u32 val}}] \leavevmode
Value to be written

\end{description}

\textbf{Description}

Generates an MPC85xx write maintenance transaction. Returns \code{0} on
success or \code{-EINVAL} on failure.
\index{fsl\_rio\_setup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/rapidio:c.fsl_rio_setup}\pysiglinewithargsret{int \bfcode{fsl\_rio\_setup}}{struct platform\_device *\emph{ dev}}{}
Setup Freescale PowerPC RapidIO interface

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct platform\_device * dev}}] \leavevmode
platform\_device pointer

\end{description}

\textbf{Description}

Initializes MPC85xx RapidIO hardware interface, configures
master port with system-specific info, and registers the
master port with the RapidIO subsystem.


\section{Credits}
\label{driver-api/rapidio:credits}
The following people have contributed to the RapidIO subsystem directly
or indirectly:
\begin{enumerate}
\item {} 
Matt Porter\href{mailto:mporter@kernel.crashing.org}{mporter@kernel.crashing.org}

\item {} 
Randy Vinson\href{mailto:rvinson@mvista.com}{rvinson@mvista.com}

\item {} 
Dan Malek\href{mailto:dan@embeddedalley.com}{dan@embeddedalley.com}

\end{enumerate}

The following people have contributed to this document:
\begin{enumerate}
\item {} 
Matt Porter\href{mailto:mporter@kernel.crashing.org}{mporter@kernel.crashing.org}

\end{enumerate}


\chapter{Writing s390 channel device drivers}
\label{driver-api/s390-drivers:writing-s390-channel-device-drivers}\label{driver-api/s390-drivers::doc}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Cornelia Huck

\end{description}\end{quote}


\section{Introduction}
\label{driver-api/s390-drivers:introduction}
This document describes the interfaces available for device drivers that
drive s390 based channel attached I/O devices. This includes interfaces
for interaction with the hardware and interfaces for interacting with
the common driver core. Those interfaces are provided by the s390 common
I/O layer.

The document assumes a familarity with the technical terms associated
with the s390 channel I/O architecture. For a description of this
architecture, please refer to the ``z/Architecture: Principles of
Operation'', IBM publication no. SA22-7832.

While most I/O devices on a s390 system are typically driven through the
channel I/O mechanism described here, there are various other methods
(like the diag interface). These are out of the scope of this document.

The s390 common I/O layer also provides access to some devices that are
not strictly considered I/O devices. They are considered here as well,
although they are not the focus of this document.

Some additional information can also be found in the kernel source under
Documentation/s390/driver-model.txt.


\section{The css bus}
\label{driver-api/s390-drivers:the-css-bus}
The css bus contains the subchannels available on the system. They fall
into several categories:
\begin{itemize}
\item {} 
Standard I/O subchannels, for use by the system. They have a child
device on the ccw bus and are described below.

\item {} 
I/O subchannels bound to the vfio-ccw driver. See
Documentation/s390/vfio-ccw.txt.

\item {} 
Message subchannels. No Linux driver currently exists.

\item {} 
CHSC subchannels (at most one). The chsc subchannel driver can be used
to send asynchronous chsc commands.

\item {} 
eADM subchannels. Used for talking to storage class memory.

\end{itemize}


\section{The ccw bus}
\label{driver-api/s390-drivers:the-ccw-bus}
The ccw bus typically contains the majority of devices available to a
s390 system. Named after the channel command word (ccw), the basic
command structure used to address its devices, the ccw bus contains
so-called channel attached devices. They are addressed via I/O
subchannels, visible on the css bus. A device driver for
channel-attached devices, however, will never interact with the
subchannel directly, but only via the I/O device on the ccw bus, the ccw
device.


\subsection{I/O functions for channel-attached devices}
\label{driver-api/s390-drivers:i-o-functions-for-channel-attached-devices}
Some hardware structures have been translated into C structures for use
by the common I/O layer and device drivers. For more information on the
hardware structures represented here, please consult the Principles of
Operation.
\index{ccw1 (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw1}\pysigline{struct \bfcode{ccw1}}
channel command word

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ccw1 \PYGZob{}
  \PYGZus{}\PYGZus{}u8 cmd\PYGZus{}code;
  \PYGZus{}\PYGZus{}u8 flags;
  \PYGZus{}\PYGZus{}u16 count;
  \PYGZus{}\PYGZus{}u32 cda;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{cmd\_code}}] \leavevmode
command code

\item[{\code{flags}}] \leavevmode
flags, like IDA addressing, etc.

\item[{\code{count}}] \leavevmode
byte count

\item[{\code{cda}}] \leavevmode
data address

\end{description}

\textbf{Description}

The ccw is the basic structure to build channel programs that perform
operations with the device or the control unit. Only Format-1 channel
command words are supported.
\index{ccw0 (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw0}\pysigline{struct \bfcode{ccw0}}
channel command word

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ccw0 \PYGZob{}
  \PYGZus{}\PYGZus{}u8 cmd\PYGZus{}code;
  \PYGZus{}\PYGZus{}u32 cda : 24;
  \PYGZus{}\PYGZus{}u8 flags;
  \PYGZus{}\PYGZus{}u8 reserved;
  \PYGZus{}\PYGZus{}u16 count;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{cmd\_code}}] \leavevmode
command code

\item[{\code{cda}}] \leavevmode
data address

\item[{\code{flags}}] \leavevmode
flags, like IDA addressing, etc.

\item[{\code{reserved}}] \leavevmode
will be ignored

\item[{\code{count}}] \leavevmode
byte count

\end{description}

\textbf{Description}

The format-0 ccw structure.
\index{erw (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.erw}\pysigline{struct \bfcode{erw}}
extended report word

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct erw \PYGZob{}
  \PYGZus{}\PYGZus{}u32 res0  : 3;
  \PYGZus{}\PYGZus{}u32 auth  : 1;
  \PYGZus{}\PYGZus{}u32 pvrf  : 1;
  \PYGZus{}\PYGZus{}u32 cpt   : 1;
  \PYGZus{}\PYGZus{}u32 fsavf : 1;
  \PYGZus{}\PYGZus{}u32 cons  : 1;
  \PYGZus{}\PYGZus{}u32 scavf : 1;
  \PYGZus{}\PYGZus{}u32 fsaf  : 1;
  \PYGZus{}\PYGZus{}u32 scnt  : 6;
  \PYGZus{}\PYGZus{}u32 res16 : 16;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{res0}}] \leavevmode
reserved

\item[{\code{auth}}] \leavevmode
authorization check

\item[{\code{pvrf}}] \leavevmode
path-verification-required flag

\item[{\code{cpt}}] \leavevmode
channel-path timeout

\item[{\code{fsavf}}] \leavevmode
failing storage address validity flag

\item[{\code{cons}}] \leavevmode
concurrent sense

\item[{\code{scavf}}] \leavevmode
secondary ccw address validity flag

\item[{\code{fsaf}}] \leavevmode
failing storage address format

\item[{\code{scnt}}] \leavevmode
sense count, if \textbf{cons} == \code{1}

\item[{\code{res16}}] \leavevmode
reserved

\end{description}
\index{erw\_eadm (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.erw_eadm}\pysigline{struct \bfcode{erw\_eadm}}
EADM Subchannel extended report word

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct erw\PYGZus{}eadm \PYGZob{}
  \PYGZus{}\PYGZus{}u32 : 16;
  \PYGZus{}\PYGZus{}u32 b : 1;
  \PYGZus{}\PYGZus{}u32 r : 1;
  \PYGZus{}\PYGZus{}u32 : 14;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{b}}] \leavevmode
aob error

\item[{\code{r}}] \leavevmode
arsb error

\end{description}
\index{sublog (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.sublog}\pysigline{struct \bfcode{sublog}}
subchannel logout area

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct sublog \PYGZob{}
  \PYGZus{}\PYGZus{}u32 res0  : 1;
  \PYGZus{}\PYGZus{}u32 esf   : 7;
  \PYGZus{}\PYGZus{}u32 lpum  : 8;
  \PYGZus{}\PYGZus{}u32 arep  : 1;
  \PYGZus{}\PYGZus{}u32 fvf   : 5;
  \PYGZus{}\PYGZus{}u32 sacc  : 2;
  \PYGZus{}\PYGZus{}u32 termc : 2;
  \PYGZus{}\PYGZus{}u32 devsc : 1;
  \PYGZus{}\PYGZus{}u32 serr  : 1;
  \PYGZus{}\PYGZus{}u32 ioerr : 1;
  \PYGZus{}\PYGZus{}u32 seqc  : 3;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{res0}}] \leavevmode
reserved

\item[{\code{esf}}] \leavevmode
extended status flags

\item[{\code{lpum}}] \leavevmode
last path used mask

\item[{\code{arep}}] \leavevmode
ancillary report

\item[{\code{fvf}}] \leavevmode
field-validity flags

\item[{\code{sacc}}] \leavevmode
storage access code

\item[{\code{termc}}] \leavevmode
termination code

\item[{\code{devsc}}] \leavevmode
device-status check

\item[{\code{serr}}] \leavevmode
secondary error

\item[{\code{ioerr}}] \leavevmode
i/o-error alert

\item[{\code{seqc}}] \leavevmode
sequence code

\end{description}
\index{esw0 (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.esw0}\pysigline{struct \bfcode{esw0}}
Format 0 Extended Status Word (ESW)

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct esw0 \PYGZob{}
  struct sublog sublog;
  struct erw erw;
  \PYGZus{}\PYGZus{}u32 faddr[2];
  \PYGZus{}\PYGZus{}u32 saddr;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{sublog}}] \leavevmode
subchannel logout

\item[{\code{erw}}] \leavevmode
extended report word

\item[{\code{faddr}}] \leavevmode
failing storage address

\item[{\code{saddr}}] \leavevmode
secondary ccw address

\end{description}
\index{esw1 (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.esw1}\pysigline{struct \bfcode{esw1}}
Format 1 Extended Status Word (ESW)

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct esw1 \PYGZob{}
  \PYGZus{}\PYGZus{}u8 zero0;
  \PYGZus{}\PYGZus{}u8 lpum;
  \PYGZus{}\PYGZus{}u16 zero16;
  struct erw erw;
  \PYGZus{}\PYGZus{}u32 zeros[3];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{zero0}}] \leavevmode
reserved zeros

\item[{\code{lpum}}] \leavevmode
last path used mask

\item[{\code{zero16}}] \leavevmode
reserved zeros

\item[{\code{erw}}] \leavevmode
extended report word

\item[{\code{zeros}}] \leavevmode
three fullwords of zeros

\end{description}
\index{esw2 (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.esw2}\pysigline{struct \bfcode{esw2}}
Format 2 Extended Status Word (ESW)

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct esw2 \PYGZob{}
  \PYGZus{}\PYGZus{}u8 zero0;
  \PYGZus{}\PYGZus{}u8 lpum;
  \PYGZus{}\PYGZus{}u16 dcti;
  struct erw erw;
  \PYGZus{}\PYGZus{}u32 zeros[3];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{zero0}}] \leavevmode
reserved zeros

\item[{\code{lpum}}] \leavevmode
last path used mask

\item[{\code{dcti}}] \leavevmode
device-connect-time interval

\item[{\code{erw}}] \leavevmode
extended report word

\item[{\code{zeros}}] \leavevmode
three fullwords of zeros

\end{description}
\index{esw3 (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.esw3}\pysigline{struct \bfcode{esw3}}
Format 3 Extended Status Word (ESW)

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct esw3 \PYGZob{}
  \PYGZus{}\PYGZus{}u8 zero0;
  \PYGZus{}\PYGZus{}u8 lpum;
  \PYGZus{}\PYGZus{}u16 res;
  struct erw erw;
  \PYGZus{}\PYGZus{}u32 zeros[3];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{zero0}}] \leavevmode
reserved zeros

\item[{\code{lpum}}] \leavevmode
last path used mask

\item[{\code{res}}] \leavevmode
reserved

\item[{\code{erw}}] \leavevmode
extended report word

\item[{\code{zeros}}] \leavevmode
three fullwords of zeros

\end{description}
\index{esw\_eadm (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.esw_eadm}\pysigline{struct \bfcode{esw\_eadm}}
EADM Subchannel Extended Status Word (ESW)

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct esw\PYGZus{}eadm \PYGZob{}
  \PYGZus{}\PYGZus{}u32 sublog;
  struct erw\PYGZus{}eadm erw;
  \PYGZus{}\PYGZus{}u32 : 32;
  \PYGZus{}\PYGZus{}u32 : 32;
  \PYGZus{}\PYGZus{}u32 : 32;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{sublog}}] \leavevmode
subchannel logout

\item[{\code{erw}}] \leavevmode
extended report word

\end{description}
\index{irb (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.irb}\pysigline{struct \bfcode{irb}}
interruption response block

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct irb \PYGZob{}
  union scsw scsw;
  union \PYGZob{}
    struct esw0 esw0;
    struct esw1 esw1;
    struct esw2 esw2;
    struct esw3 esw3;
    struct esw\PYGZus{}eadm eadm;
  \PYGZcb{} esw;
  \PYGZus{}\PYGZus{}u8 ecw[32];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{scsw}}] \leavevmode
subchannel status word

\item[{\code{esw}}] \leavevmode
extended status word

\item[{\code{ecw}}] \leavevmode
extended control word

\end{description}

\textbf{Description}

The irb that is handed to the device driver when an interrupt occurs. For
solicited interrupts, the common I/O layer already performs checks whether
a field is valid; a field not being valid is always passed as \code{0}.
If a unit check occurred, \textbf{ecw} may contain sense data; this is retrieved
by the common I/O layer itself if the device doesn't support concurrent
sense (so that the device driver never needs to perform basic sene itself).
For unsolicited interrupts, the irb is passed as-is (expect for sense data,
if applicable).
\index{ciw (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ciw}\pysigline{struct \bfcode{ciw}}
command information word (CIW) layout

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ciw \PYGZob{}
  \PYGZus{}\PYGZus{}u32 et       :  2;
  \PYGZus{}\PYGZus{}u32 reserved :  2;
  \PYGZus{}\PYGZus{}u32 ct       :  4;
  \PYGZus{}\PYGZus{}u32 cmd      :  8;
  \PYGZus{}\PYGZus{}u32 count    : 16;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{et}}] \leavevmode
entry type

\item[{\code{reserved}}] \leavevmode
reserved bits

\item[{\code{ct}}] \leavevmode
command type

\item[{\code{cmd}}] \leavevmode
command code

\item[{\code{count}}] \leavevmode
command count

\end{description}
\index{ccw\_dev\_id (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_dev_id}\pysigline{struct \bfcode{ccw\_dev\_id}}
unique identifier for ccw devices

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ccw\PYGZus{}dev\PYGZus{}id \PYGZob{}
  u8 ssid;
  u16 devno;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{ssid}}] \leavevmode
subchannel set id

\item[{\code{devno}}] \leavevmode
device number

\end{description}

\textbf{Description}

This structure is not directly based on any hardware structure. The
hardware identifies a device by its device number and its subchannel,
which is in turn identified by its id. In order to get a unique identifier
for ccw devices across subchannel sets, \textbf{struct} ccw\_dev\_id has been
introduced.
\index{ccw\_dev\_id\_is\_equal (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_dev_id_is_equal}\pysiglinewithargsret{int \bfcode{ccw\_dev\_id\_is\_equal}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_dev_id]{\emph{ccw\_dev\_id}}} *\emph{ dev\_id1}, struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_dev_id]{\emph{ccw\_dev\_id}}} *\emph{ dev\_id2}}{}
compare two ccw\_dev\_ids

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_dev\_id * dev\_id1}}] \leavevmode
a ccw\_dev\_id

\item[{\code{struct ccw\_dev\_id * dev\_id2}}] \leavevmode
another ccw\_dev\_id

\end{description}

\textbf{Return}
\begin{quote}

\code{1} if the two structures are equal field-by-field,
\code{0} if not.
\end{quote}

\textbf{Context}

any
\index{pathmask\_to\_pos (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.pathmask_to_pos}\pysiglinewithargsret{u8 \bfcode{pathmask\_to\_pos}}{u8\emph{ mask}}{}
find the position of the left-most bit in a pathmask

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 mask}}] \leavevmode
pathmask with at least one bit set

\end{description}


\subsection{ccw devices}
\label{driver-api/s390-drivers:ccw-devices}
Devices that want to initiate channel I/O need to attach to the ccw bus.
Interaction with the driver core is done via the common I/O layer, which
provides the abstractions of ccw devices and ccw device drivers.

The functions that initiate or terminate channel I/O all act upon a ccw
device structure. Device drivers must not bypass those functions or
strange side effects may happen.
\index{ccw\_device (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device}\pysigline{struct \bfcode{ccw\_device}}
channel attached device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ccw\PYGZus{}device \PYGZob{}
  spinlock\PYGZus{}t *ccwlock;
  struct ccw\PYGZus{}device\PYGZus{}id id;
  struct ccw\PYGZus{}driver *drv;
  struct device dev;
  int online;
  void (*handler) (struct ccw\PYGZus{}device *, unsigned long, struct irb *);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{ccwlock}}] \leavevmode
pointer to device lock

\item[{\code{id}}] \leavevmode
id of this device

\item[{\code{drv}}] \leavevmode
ccw driver for this device

\item[{\code{dev}}] \leavevmode
embedded device structure

\item[{\code{online}}] \leavevmode
online status of device

\item[{\code{handler}}] \leavevmode
interrupt handler

\end{description}

\textbf{Description}

\textbf{handler} is a member of the device rather than the driver since a driver
can have different interrupt handlers for different ccw devices
(multi-subchannel drivers).
\index{ccw\_driver (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_driver}\pysigline{struct \bfcode{ccw\_driver}}
device driver for channel attached devices

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ccw\PYGZus{}driver \PYGZob{}
  struct ccw\PYGZus{}device\PYGZus{}id *ids;
  int (*probe) (struct ccw\PYGZus{}device *);
  void (*remove) (struct ccw\PYGZus{}device *);
  int (*set\PYGZus{}online) (struct ccw\PYGZus{}device *);
  int (*set\PYGZus{}offline) (struct ccw\PYGZus{}device *);
  int (*notify) (struct ccw\PYGZus{}device *, int);
  void (*path\PYGZus{}event) (struct ccw\PYGZus{}device *, int *);
  void (*shutdown) (struct ccw\PYGZus{}device *);
  int (*prepare) (struct ccw\PYGZus{}device *);
  void (*complete) (struct ccw\PYGZus{}device *);
  int (*freeze)(struct ccw\PYGZus{}device *);
  int (*thaw) (struct ccw\PYGZus{}device *);
  int (*restore)(struct ccw\PYGZus{}device *);
  enum uc\PYGZus{}todo (*uc\PYGZus{}handler) (struct ccw\PYGZus{}device *, struct irb *);
  struct device\PYGZus{}driver driver;
  enum interruption\PYGZus{}class int\PYGZus{}class;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{ids}}] \leavevmode
ids supported by this driver

\item[{\code{probe}}] \leavevmode
function called on probe

\item[{\code{remove}}] \leavevmode
function called on remove

\item[{\code{set\_online}}] \leavevmode
called when setting device online

\item[{\code{set\_offline}}] \leavevmode
called when setting device offline

\item[{\code{notify}}] \leavevmode
notify driver of device state changes

\item[{\code{path\_event}}] \leavevmode
notify driver of channel path events

\item[{\code{shutdown}}] \leavevmode
called at device shutdown

\item[{\code{prepare}}] \leavevmode
prepare for pm state transition

\item[{\code{complete}}] \leavevmode
undo work done in \textbf{prepare}

\item[{\code{freeze}}] \leavevmode
callback for freezing during hibernation snapshotting

\item[{\code{thaw}}] \leavevmode
undo work done in \textbf{freeze}

\item[{\code{restore}}] \leavevmode
callback for restoring after hibernation

\item[{\code{uc\_handler}}] \leavevmode
callback for unit check handler

\item[{\code{driver}}] \leavevmode
embedded device driver structure

\item[{\code{int\_class}}] \leavevmode
interruption class to use for accounting interrupts

\end{description}
\index{ccw\_device\_set\_offline (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_set_offline}\pysiglinewithargsret{int \bfcode{ccw\_device\_set\_offline}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}}{}
disable a ccw device for I/O

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
target ccw device

\end{description}

\textbf{Description}

This function calls the driver's \code{set\_offline()} function for \textbf{cdev}, if
given, and then disables \textbf{cdev}.

\textbf{Return}
\begin{quote}

\code{0} on success and a negative error value on failure.
\end{quote}

\textbf{Context}

enabled, ccw device lock not held
\index{ccw\_device\_set\_online (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_set_online}\pysiglinewithargsret{int \bfcode{ccw\_device\_set\_online}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}}{}
enable a ccw device for I/O

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
target ccw device

\end{description}

\textbf{Description}

This function first enables \textbf{cdev} and then calls the driver's \code{set\_online()}
function for \textbf{cdev}, if given. If \code{set\_online()} returns an error, \textbf{cdev} is
disabled again.

\textbf{Return}
\begin{quote}

\code{0} on success and a negative error value on failure.
\end{quote}

\textbf{Context}

enabled, ccw device lock not held
\index{get\_ccwdev\_by\_dev\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.get_ccwdev_by_dev_id}\pysiglinewithargsret{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} * \bfcode{get\_ccwdev\_by\_dev\_id}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_dev_id]{\emph{ccw\_dev\_id}}} *\emph{ dev\_id}}{}
obtain device from a ccw device id

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_dev\_id * dev\_id}}] \leavevmode
id of the device to be searched

\end{description}

\textbf{Description}

This function searches all devices attached to the ccw bus for a device
matching \textbf{dev\_id}.

\textbf{Return}
\begin{quote}

If a device is found its reference count is increased and returned;
else \code{NULL} is returned.
\end{quote}
\index{get\_ccwdev\_by\_busid (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.get_ccwdev_by_busid}\pysiglinewithargsret{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} * \bfcode{get\_ccwdev\_by\_busid}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_driver]{\emph{ccw\_driver}}} *\emph{ cdrv}, const char *\emph{ bus\_id}}{}
obtain device from a bus id

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_driver * cdrv}}] \leavevmode
driver the device is owned by

\item[{\code{const char * bus\_id}}] \leavevmode
bus id of the device to be searched

\end{description}

\textbf{Description}

This function searches all devices owned by \textbf{cdrv} for a device with a bus
id matching \textbf{bus\_id}.

\textbf{Return}
\begin{quote}

If a match is found, its reference count of the found device is increased
and it is returned; else \code{NULL} is returned.
\end{quote}
\index{ccw\_driver\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_driver_register}\pysiglinewithargsret{int \bfcode{ccw\_driver\_register}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_driver]{\emph{ccw\_driver}}} *\emph{ cdriver}}{}
register a ccw driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_driver * cdriver}}] \leavevmode
driver to be registered

\end{description}

\textbf{Description}

This function is mainly a wrapper around {\hyperref[driver\string-api/infrastructure:c.driver_register]{\emph{\code{driver\_register()}}}}.

\textbf{Return}
\begin{quote}

\code{0} on success and a negative error value on failure.
\end{quote}
\index{ccw\_driver\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_driver_unregister}\pysiglinewithargsret{void \bfcode{ccw\_driver\_unregister}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_driver]{\emph{ccw\_driver}}} *\emph{ cdriver}}{}
deregister a ccw driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_driver * cdriver}}] \leavevmode
driver to be deregistered

\end{description}

\textbf{Description}

This function is mainly a wrapper around {\hyperref[driver\string-api/infrastructure:c.driver_unregister]{\emph{\code{driver\_unregister()}}}}.
\index{ccw\_device\_siosl (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_siosl}\pysiglinewithargsret{int \bfcode{ccw\_device\_siosl}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}}{}
initiate logging

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
ccw device

\end{description}

\textbf{Description}

This function is used to invoke model-dependent logging within the channel
subsystem.
\index{ccw\_device\_set\_options\_mask (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_set_options_mask}\pysiglinewithargsret{int \bfcode{ccw\_device\_set\_options\_mask}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, unsigned long\emph{ flags}}{}
set some options and unset the rest

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
device for which the options are to be set

\item[{\code{unsigned long flags}}] \leavevmode
options to be set

\end{description}

\textbf{Description}

All flags specified in \textbf{flags} are set, all flags not specified in \textbf{flags}
are cleared.

\textbf{Return}
\begin{quote}

\code{0} on success, -\code{EINVAL} on an invalid flag combination.
\end{quote}
\index{ccw\_device\_set\_options (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_set_options}\pysiglinewithargsret{int \bfcode{ccw\_device\_set\_options}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, unsigned long\emph{ flags}}{}
set some options

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
device for which the options are to be set

\item[{\code{unsigned long flags}}] \leavevmode
options to be set

\end{description}

\textbf{Description}

All flags specified in \textbf{flags} are set, the remainder is left untouched.

\textbf{Return}
\begin{quote}

\code{0} on success, -\code{EINVAL} if an invalid flag combination would ensue.
\end{quote}
\index{ccw\_device\_clear\_options (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_clear_options}\pysiglinewithargsret{void \bfcode{ccw\_device\_clear\_options}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, unsigned long\emph{ flags}}{}
clear some options

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
device for which the options are to be cleared

\item[{\code{unsigned long flags}}] \leavevmode
options to be cleared

\end{description}

\textbf{Description}

All flags specified in \textbf{flags} are cleared, the remainder is left untouched.
\index{ccw\_device\_is\_pathgroup (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_is_pathgroup}\pysiglinewithargsret{int \bfcode{ccw\_device\_is\_pathgroup}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}}{}
determine if paths to this device are grouped

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
ccw device

\end{description}

\textbf{Description}

Return non-zero if there is a path group, zero otherwise.
\index{ccw\_device\_is\_multipath (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_is_multipath}\pysiglinewithargsret{int \bfcode{ccw\_device\_is\_multipath}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}}{}
determine if device is operating in multipath mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
ccw device

\end{description}

\textbf{Description}

Return non-zero if device is operating in multipath mode, zero otherwise.
\index{ccw\_device\_clear (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_clear}\pysiglinewithargsret{int \bfcode{ccw\_device\_clear}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, unsigned long\emph{ intparm}}{}
terminate I/O request processing

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
target ccw device

\item[{\code{unsigned long intparm}}] \leavevmode
interruption parameter; value is only used if no I/O is
outstanding, otherwise the intparm associated with the I/O request
is returned

\end{description}

\textbf{Description}

{\hyperref[driver\string-api/s390\string-drivers:c.ccw_device_clear]{\emph{\code{ccw\_device\_clear()}}}} calls csch on \textbf{cdev}`s subchannel.

\textbf{Return}
\begin{quote}

\code{0} on success,
-\code{ENODEV} on device not operational,
-\code{EINVAL} on invalid device state.
\end{quote}

\textbf{Context}

Interrupts disabled, ccw device lock held
\index{ccw\_device\_start\_timeout\_key (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_start_timeout_key}\pysiglinewithargsret{int \bfcode{ccw\_device\_start\_timeout\_key}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw1]{\emph{ccw1}}} *\emph{ cpa}, unsigned long\emph{ intparm}, \_\_u8\emph{ lpm}, \_\_u8\emph{ key}, unsigned long\emph{ flags}, int\emph{ expires}}{}
start a s390 channel program with timeout and key

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
target ccw device

\item[{\code{struct ccw1 * cpa}}] \leavevmode
logical start address of channel program

\item[{\code{unsigned long intparm}}] \leavevmode
user specific interruption parameter; will be presented back to
\textbf{cdev}`s interrupt handler. Allows a device driver to associate
the interrupt with a particular I/O request.

\item[{\code{\_\_u8 lpm}}] \leavevmode
defines the channel path to be used for a specific I/O request. A
value of 0 will make cio use the opm.

\item[{\code{\_\_u8 key}}] \leavevmode
storage key to be used for the I/O

\item[{\code{unsigned long flags}}] \leavevmode
additional flags; defines the action to be performed for I/O
processing.

\item[{\code{int expires}}] \leavevmode
timeout value in jiffies

\end{description}

\textbf{Description}

Start a S/390 channel program. When the interrupt arrives, the
IRQ handler is called, either immediately, delayed (dev-end missing,
or sense required) or never (no IRQ handler registered).
This function notifies the device driver if the channel program has not
completed during the time specified by \textbf{expires}. If a timeout occurs, the
channel program is terminated via xsch, hsch or csch, and the device's
interrupt handler will be called with an irb containing ERR\_PTR(-\code{ETIMEDOUT}).

\textbf{Return}
\begin{quote}

\code{0}, if the operation was successful;
-\code{EBUSY}, if the device is busy, or status pending;
-\code{EACCES}, if no path specified in \textbf{lpm} is operational;
-\code{ENODEV}, if the device is not operational.
\end{quote}

\textbf{Context}

Interrupts disabled, ccw device lock held
\index{ccw\_device\_start\_key (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_start_key}\pysiglinewithargsret{int \bfcode{ccw\_device\_start\_key}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw1]{\emph{ccw1}}} *\emph{ cpa}, unsigned long\emph{ intparm}, \_\_u8\emph{ lpm}, \_\_u8\emph{ key}, unsigned long\emph{ flags}}{}
start a s390 channel program with key

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
target ccw device

\item[{\code{struct ccw1 * cpa}}] \leavevmode
logical start address of channel program

\item[{\code{unsigned long intparm}}] \leavevmode
user specific interruption parameter; will be presented back to
\textbf{cdev}`s interrupt handler. Allows a device driver to associate
the interrupt with a particular I/O request.

\item[{\code{\_\_u8 lpm}}] \leavevmode
defines the channel path to be used for a specific I/O request. A
value of 0 will make cio use the opm.

\item[{\code{\_\_u8 key}}] \leavevmode
storage key to be used for the I/O

\item[{\code{unsigned long flags}}] \leavevmode
additional flags; defines the action to be performed for I/O
processing.

\end{description}

\textbf{Description}

Start a S/390 channel program. When the interrupt arrives, the
IRQ handler is called, either immediately, delayed (dev-end missing,
or sense required) or never (no IRQ handler registered).

\textbf{Return}
\begin{quote}

\code{0}, if the operation was successful;
-\code{EBUSY}, if the device is busy, or status pending;
-\code{EACCES}, if no path specified in \textbf{lpm} is operational;
-\code{ENODEV}, if the device is not operational.
\end{quote}

\textbf{Context}

Interrupts disabled, ccw device lock held
\index{ccw\_device\_start (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_start}\pysiglinewithargsret{int \bfcode{ccw\_device\_start}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw1]{\emph{ccw1}}} *\emph{ cpa}, unsigned long\emph{ intparm}, \_\_u8\emph{ lpm}, unsigned long\emph{ flags}}{}
start a s390 channel program

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
target ccw device

\item[{\code{struct ccw1 * cpa}}] \leavevmode
logical start address of channel program

\item[{\code{unsigned long intparm}}] \leavevmode
user specific interruption parameter; will be presented back to
\textbf{cdev}`s interrupt handler. Allows a device driver to associate
the interrupt with a particular I/O request.

\item[{\code{\_\_u8 lpm}}] \leavevmode
defines the channel path to be used for a specific I/O request. A
value of 0 will make cio use the opm.

\item[{\code{unsigned long flags}}] \leavevmode
additional flags; defines the action to be performed for I/O
processing.

\end{description}

\textbf{Description}

Start a S/390 channel program. When the interrupt arrives, the
IRQ handler is called, either immediately, delayed (dev-end missing,
or sense required) or never (no IRQ handler registered).

\textbf{Return}
\begin{quote}

\code{0}, if the operation was successful;
-\code{EBUSY}, if the device is busy, or status pending;
-\code{EACCES}, if no path specified in \textbf{lpm} is operational;
-\code{ENODEV}, if the device is not operational.
\end{quote}

\textbf{Context}

Interrupts disabled, ccw device lock held
\index{ccw\_device\_start\_timeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_start_timeout}\pysiglinewithargsret{int \bfcode{ccw\_device\_start\_timeout}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw1]{\emph{ccw1}}} *\emph{ cpa}, unsigned long\emph{ intparm}, \_\_u8\emph{ lpm}, unsigned long\emph{ flags}, int\emph{ expires}}{}
start a s390 channel program with timeout

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
target ccw device

\item[{\code{struct ccw1 * cpa}}] \leavevmode
logical start address of channel program

\item[{\code{unsigned long intparm}}] \leavevmode
user specific interruption parameter; will be presented back to
\textbf{cdev}`s interrupt handler. Allows a device driver to associate
the interrupt with a particular I/O request.

\item[{\code{\_\_u8 lpm}}] \leavevmode
defines the channel path to be used for a specific I/O request. A
value of 0 will make cio use the opm.

\item[{\code{unsigned long flags}}] \leavevmode
additional flags; defines the action to be performed for I/O
processing.

\item[{\code{int expires}}] \leavevmode
timeout value in jiffies

\end{description}

\textbf{Description}

Start a S/390 channel program. When the interrupt arrives, the
IRQ handler is called, either immediately, delayed (dev-end missing,
or sense required) or never (no IRQ handler registered).
This function notifies the device driver if the channel program has not
completed during the time specified by \textbf{expires}. If a timeout occurs, the
channel program is terminated via xsch, hsch or csch, and the device's
interrupt handler will be called with an irb containing ERR\_PTR(-\code{ETIMEDOUT}).

\textbf{Return}
\begin{quote}

\code{0}, if the operation was successful;
-\code{EBUSY}, if the device is busy, or status pending;
-\code{EACCES}, if no path specified in \textbf{lpm} is operational;
-\code{ENODEV}, if the device is not operational.
\end{quote}

\textbf{Context}

Interrupts disabled, ccw device lock held
\index{ccw\_device\_halt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_halt}\pysiglinewithargsret{int \bfcode{ccw\_device\_halt}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, unsigned long\emph{ intparm}}{}
halt I/O request processing

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
target ccw device

\item[{\code{unsigned long intparm}}] \leavevmode
interruption parameter; value is only used if no I/O is
outstanding, otherwise the intparm associated with the I/O request
is returned

\end{description}

\textbf{Description}

{\hyperref[driver\string-api/s390\string-drivers:c.ccw_device_halt]{\emph{\code{ccw\_device\_halt()}}}} calls hsch on \textbf{cdev}`s subchannel.

\textbf{Return}
\begin{quote}

\code{0} on success,
-\code{ENODEV} on device not operational,
-\code{EINVAL} on invalid device state,
-\code{EBUSY} on device busy or interrupt pending.
\end{quote}

\textbf{Context}

Interrupts disabled, ccw device lock held
\index{ccw\_device\_resume (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_resume}\pysiglinewithargsret{int \bfcode{ccw\_device\_resume}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}}{}
resume channel program execution

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
target ccw device

\end{description}

\textbf{Description}

{\hyperref[driver\string-api/s390\string-drivers:c.ccw_device_resume]{\emph{\code{ccw\_device\_resume()}}}} calls rsch on \textbf{cdev}`s subchannel.

\textbf{Return}
\begin{quote}

\code{0} on success,
-\code{ENODEV} on device not operational,
-\code{EINVAL} on invalid device state,
-\code{EBUSY} on device busy or interrupt pending.
\end{quote}

\textbf{Context}

Interrupts disabled, ccw device lock held
\index{ccw\_device\_get\_ciw (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_get_ciw}\pysiglinewithargsret{struct {\hyperref[driver\string-api/s390\string-drivers:c.ciw]{\emph{ciw}}} * \bfcode{ccw\_device\_get\_ciw}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, \_\_u32\emph{ ct}}{}
Search for CIW command in extended sense data.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
ccw device to inspect

\item[{\code{\_\_u32 ct}}] \leavevmode
command type to look for

\end{description}

\textbf{Description}

During SenseID, command information words (CIWs) describing special
commands available to the device may have been stored in the extended
sense data. This function searches for CIWs of a specified command
type in the extended sense data.

\textbf{Return}
\begin{quote}

\code{NULL} if no extended sense data has been stored or if no CIW of the
specified command type could be found,
else a pointer to the CIW of the specified command type.
\end{quote}
\index{ccw\_device\_get\_path\_mask (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_get_path_mask}\pysiglinewithargsret{\_\_u8 \bfcode{ccw\_device\_get\_path\_mask}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}}{}
get currently available paths

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
ccw device to be queried

\end{description}

\textbf{Return}
\begin{quote}

\code{0} if no subchannel for the device is available,
else the mask of currently available paths for the ccw device's subchannel.
\end{quote}
\index{ccw\_device\_get\_chp\_desc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_get_chp_desc}\pysiglinewithargsret{struct channel\_path\_desc * \bfcode{ccw\_device\_get\_chp\_desc}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, int\emph{ chp\_idx}}{}
return newly allocated channel-path descriptor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
device to obtain the descriptor for

\item[{\code{int chp\_idx}}] \leavevmode
index of the channel path

\end{description}

\textbf{Description}

On success return a newly allocated copy of the channel-path description
data associated with the given channel path. Return \code{NULL} on error.
\index{ccw\_device\_get\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_get_id}\pysiglinewithargsret{void \bfcode{ccw\_device\_get\_id}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_dev_id]{\emph{ccw\_dev\_id}}} *\emph{ dev\_id}}{}
obtain a ccw device id

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
device to obtain the id for

\item[{\code{struct ccw\_dev\_id * dev\_id}}] \leavevmode
where to fill in the values

\end{description}
\index{ccw\_device\_tm\_start\_timeout\_key (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_tm_start_timeout_key}\pysiglinewithargsret{int \bfcode{ccw\_device\_tm\_start\_timeout\_key}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, struct tcw *\emph{ tcw}, unsigned long\emph{ intparm}, u8\emph{ lpm}, u8\emph{ key}, int\emph{ expires}}{}
perform start function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
ccw device on which to perform the start function

\item[{\code{struct tcw * tcw}}] \leavevmode
transport-command word to be started

\item[{\code{unsigned long intparm}}] \leavevmode
user defined parameter to be passed to the interrupt handler

\item[{\code{u8 lpm}}] \leavevmode
mask of paths to use

\item[{\code{u8 key}}] \leavevmode
storage key to use for storage access

\item[{\code{int expires}}] \leavevmode
time span in jiffies after which to abort request

\end{description}

\textbf{Description}

Start the tcw on the given ccw device. Return zero on success, non-zero
otherwise.
\index{ccw\_device\_tm\_start\_key (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_tm_start_key}\pysiglinewithargsret{int \bfcode{ccw\_device\_tm\_start\_key}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, struct tcw *\emph{ tcw}, unsigned long\emph{ intparm}, u8\emph{ lpm}, u8\emph{ key}}{}
perform start function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
ccw device on which to perform the start function

\item[{\code{struct tcw * tcw}}] \leavevmode
transport-command word to be started

\item[{\code{unsigned long intparm}}] \leavevmode
user defined parameter to be passed to the interrupt handler

\item[{\code{u8 lpm}}] \leavevmode
mask of paths to use

\item[{\code{u8 key}}] \leavevmode
storage key to use for storage access

\end{description}

\textbf{Description}

Start the tcw on the given ccw device. Return zero on success, non-zero
otherwise.
\index{ccw\_device\_tm\_start (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_tm_start}\pysiglinewithargsret{int \bfcode{ccw\_device\_tm\_start}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, struct tcw *\emph{ tcw}, unsigned long\emph{ intparm}, u8\emph{ lpm}}{}
perform start function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
ccw device on which to perform the start function

\item[{\code{struct tcw * tcw}}] \leavevmode
transport-command word to be started

\item[{\code{unsigned long intparm}}] \leavevmode
user defined parameter to be passed to the interrupt handler

\item[{\code{u8 lpm}}] \leavevmode
mask of paths to use

\end{description}

\textbf{Description}

Start the tcw on the given ccw device. Return zero on success, non-zero
otherwise.
\index{ccw\_device\_tm\_start\_timeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_tm_start_timeout}\pysiglinewithargsret{int \bfcode{ccw\_device\_tm\_start\_timeout}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, struct tcw *\emph{ tcw}, unsigned long\emph{ intparm}, u8\emph{ lpm}, int\emph{ expires}}{}
perform start function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
ccw device on which to perform the start function

\item[{\code{struct tcw * tcw}}] \leavevmode
transport-command word to be started

\item[{\code{unsigned long intparm}}] \leavevmode
user defined parameter to be passed to the interrupt handler

\item[{\code{u8 lpm}}] \leavevmode
mask of paths to use

\item[{\code{int expires}}] \leavevmode
time span in jiffies after which to abort request

\end{description}

\textbf{Description}

Start the tcw on the given ccw device. Return zero on success, non-zero
otherwise.
\index{ccw\_device\_get\_mdc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_get_mdc}\pysiglinewithargsret{int \bfcode{ccw\_device\_get\_mdc}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, u8\emph{ mask}}{}
accumulate max data count

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
ccw device for which the max data count is accumulated

\item[{\code{u8 mask}}] \leavevmode
mask of paths to use

\end{description}

\textbf{Description}

Return the number of 64K-bytes blocks all paths at least support
for a transport command. Return values \textless{}= 0 indicate failures.
\index{ccw\_device\_tm\_intrg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_tm_intrg}\pysiglinewithargsret{int \bfcode{ccw\_device\_tm\_intrg}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}}{}
perform interrogate function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
ccw device on which to perform the interrogate function

\end{description}

\textbf{Description}

Perform an interrogate function on the given ccw device. Return zero on
success, non-zero otherwise.
\index{ccw\_device\_get\_schid (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccw_device_get_schid}\pysiglinewithargsret{void \bfcode{ccw\_device\_get\_schid}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, struct subchannel\_id *\emph{ schid}}{}
obtain a subchannel id

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
device to obtain the id for

\item[{\code{struct subchannel\_id * schid}}] \leavevmode
where to fill in the values

\end{description}


\subsection{The channel-measurement facility}
\label{driver-api/s390-drivers:the-channel-measurement-facility}
The channel-measurement facility provides a means to collect measurement
data which is made available by the channel subsystem for each channel
attached device.
\index{cmbdata (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.cmbdata}\pysigline{struct \bfcode{cmbdata}}
channel measurement block data for user space

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cmbdata \PYGZob{}
  \PYGZus{}\PYGZus{}u64 size;
  \PYGZus{}\PYGZus{}u64 elapsed\PYGZus{}time;
  \PYGZus{}\PYGZus{}u64 ssch\PYGZus{}rsch\PYGZus{}count;
  \PYGZus{}\PYGZus{}u64 sample\PYGZus{}count;
  \PYGZus{}\PYGZus{}u64 device\PYGZus{}connect\PYGZus{}time;
  \PYGZus{}\PYGZus{}u64 function\PYGZus{}pending\PYGZus{}time;
  \PYGZus{}\PYGZus{}u64 device\PYGZus{}disconnect\PYGZus{}time;
  \PYGZus{}\PYGZus{}u64 control\PYGZus{}unit\PYGZus{}queuing\PYGZus{}time;
  \PYGZus{}\PYGZus{}u64 device\PYGZus{}active\PYGZus{}only\PYGZus{}time;
  \PYGZus{}\PYGZus{}u64 device\PYGZus{}busy\PYGZus{}time;
  \PYGZus{}\PYGZus{}u64 initial\PYGZus{}command\PYGZus{}response\PYGZus{}time;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{size}}] \leavevmode
size of the stored data

\item[{\code{elapsed\_time}}] \leavevmode
time since last sampling

\item[{\code{ssch\_rsch\_count}}] \leavevmode
number of ssch and rsch

\item[{\code{sample\_count}}] \leavevmode
number of samples

\item[{\code{device\_connect\_time}}] \leavevmode
time of device connect

\item[{\code{function\_pending\_time}}] \leavevmode
time of function pending

\item[{\code{device\_disconnect\_time}}] \leavevmode
time of device disconnect

\item[{\code{control\_unit\_queuing\_time}}] \leavevmode
time of control unit queuing

\item[{\code{device\_active\_only\_time}}] \leavevmode
time of device active only

\item[{\code{device\_busy\_time}}] \leavevmode
time of device busy (ext. format)

\item[{\code{initial\_command\_response\_time}}] \leavevmode
initial command response time (ext. format)

\end{description}

\textbf{Description}

All values are stored as 64 bit for simplicity, especially
in 32 bit emulation mode. All time values are normalized to
nanoseconds.
Currently, two formats are known, which differ by the size of
this structure, i.e. the last two members are only set when
the extended channel measurement facility (first shipped in
z990 machines) is activated.
Potentially, more fields could be added, which would result in a
new ioctl number.
\index{enable\_cmf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.enable_cmf}\pysiglinewithargsret{int \bfcode{enable\_cmf}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}}{}
switch on the channel measurement for a specific device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
The ccw device to be enabled

\end{description}

\textbf{Description}
\begin{quote}

Enable channel measurements for \textbf{cdev}. If this is called on a device
for which channel measurement is already enabled a reset of the
measurement data is triggered.
\end{quote}

\textbf{Return}

\code{0} for success or a negative error value.

\textbf{Context}

non-atomic
\index{disable\_cmf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.disable_cmf}\pysiglinewithargsret{int \bfcode{disable\_cmf}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}}{}
switch off the channel measurement for a specific device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
The ccw device to be disabled

\end{description}

\textbf{Return}

\code{0} for success or a negative error value.

\textbf{Context}

non-atomic
\index{cmf\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.cmf_read}\pysiglinewithargsret{u64 \bfcode{cmf\_read}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, int\emph{ index}}{}
read one value from the current channel measurement block

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
the channel to be read

\item[{\code{int index}}] \leavevmode
the index of the value to be read

\end{description}

\textbf{Return}

The value read or \code{0} if the value cannot be read.

\textbf{Context}

any
\index{cmf\_readall (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.cmf_readall}\pysiglinewithargsret{int \bfcode{cmf\_readall}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}, struct {\hyperref[driver\string-api/s390\string-drivers:c.cmbdata]{\emph{cmbdata}}} *\emph{ data}}{}
read the current channel measurement block

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
the channel to be read

\item[{\code{struct cmbdata * data}}] \leavevmode
a pointer to a data block that will be filled

\end{description}

\textbf{Return}

\code{0} on success, a negative error value otherwise.

\textbf{Context}

any


\section{The ccwgroup bus}
\label{driver-api/s390-drivers:the-ccwgroup-bus}
The ccwgroup bus only contains artificial devices, created by the user.
Many networking devices (e.g. qeth) are in fact composed of several ccw
devices (like read, write and data channel for qeth). The ccwgroup bus
provides a mechanism to create a meta-device which contains those ccw
devices as slave devices and can be associated with the netdevice.


\subsection{ccw group devices}
\label{driver-api/s390-drivers:ccw-group-devices}\index{ccwgroup\_device (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccwgroup_device}\pysigline{struct \bfcode{ccwgroup\_device}}
ccw group device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ccwgroup\PYGZus{}device \PYGZob{}
  enum \PYGZob{}
    CCWGROUP\PYGZus{}OFFLINE,
    CCWGROUP\PYGZus{}ONLINE,
  \PYGZcb{} state;
  unsigned int count;
  struct device   dev;
  struct work\PYGZus{}struct ungroup\PYGZus{}work;
  struct ccw\PYGZus{}device *cdev[0];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{state}}] \leavevmode
online/offline state

\item[{\code{count}}] \leavevmode
number of attached slave devices

\item[{\code{dev}}] \leavevmode
embedded device structure

\item[{\code{ungroup\_work}}] \leavevmode
work to be done when a ccwgroup notifier has action
type \code{BUS\_NOTIFY\_UNBIND\_DRIVER}

\item[{\code{cdev}}] \leavevmode
variable number of slave devices, allocated as needed

\end{description}
\index{ccwgroup\_driver (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccwgroup_driver}\pysigline{struct \bfcode{ccwgroup\_driver}}
driver for ccw group devices

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ccwgroup\PYGZus{}driver \PYGZob{}
  int (*setup) (struct ccwgroup\PYGZus{}device *);
  void (*remove) (struct ccwgroup\PYGZus{}device *);
  int (*set\PYGZus{}online) (struct ccwgroup\PYGZus{}device *);
  int (*set\PYGZus{}offline) (struct ccwgroup\PYGZus{}device *);
  void (*shutdown)(struct ccwgroup\PYGZus{}device *);
  int (*prepare) (struct ccwgroup\PYGZus{}device *);
  void (*complete) (struct ccwgroup\PYGZus{}device *);
  int (*freeze)(struct ccwgroup\PYGZus{}device *);
  int (*thaw) (struct ccwgroup\PYGZus{}device *);
  int (*restore)(struct ccwgroup\PYGZus{}device *);
  struct device\PYGZus{}driver driver;
  struct ccw\PYGZus{}driver *ccw\PYGZus{}driver;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{setup}}] \leavevmode
function called during device creation to setup the device

\item[{\code{remove}}] \leavevmode
function called on remove

\item[{\code{set\_online}}] \leavevmode
function called when device is set online

\item[{\code{set\_offline}}] \leavevmode
function called when device is set offline

\item[{\code{shutdown}}] \leavevmode
function called when device is shut down

\item[{\code{prepare}}] \leavevmode
prepare for pm state transition

\item[{\code{complete}}] \leavevmode
undo work done in \textbf{prepare}

\item[{\code{freeze}}] \leavevmode
callback for freezing during hibernation snapshotting

\item[{\code{thaw}}] \leavevmode
undo work done in \textbf{freeze}

\item[{\code{restore}}] \leavevmode
callback for restoring after hibernation

\item[{\code{driver}}] \leavevmode
embedded driver structure

\item[{\code{ccw\_driver}}] \leavevmode
supported ccw\_driver (optional)

\end{description}
\index{ccwgroup\_set\_online (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccwgroup_set_online}\pysiglinewithargsret{int \bfcode{ccwgroup\_set\_online}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccwgroup_device]{\emph{ccwgroup\_device}}} *\emph{ gdev}}{}
enable a ccwgroup device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccwgroup\_device * gdev}}] \leavevmode
target ccwgroup device

\end{description}

\textbf{Description}

This function attempts to put the ccwgroup device into the online state.

\textbf{Return}
\begin{quote}

\code{0} on success and a negative error value on failure.
\end{quote}
\index{ccwgroup\_set\_offline (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccwgroup_set_offline}\pysiglinewithargsret{int \bfcode{ccwgroup\_set\_offline}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccwgroup_device]{\emph{ccwgroup\_device}}} *\emph{ gdev}}{}
disable a ccwgroup device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccwgroup\_device * gdev}}] \leavevmode
target ccwgroup device

\end{description}

\textbf{Description}

This function attempts to put the ccwgroup device into the offline state.

\textbf{Return}
\begin{quote}

\code{0} on success and a negative error value on failure.
\end{quote}
\index{ccwgroup\_create\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccwgroup_create_dev}\pysiglinewithargsret{int \bfcode{ccwgroup\_create\_dev}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ parent}, struct {\hyperref[driver\string-api/s390\string-drivers:c.ccwgroup_driver]{\emph{ccwgroup\_driver}}} *\emph{ gdrv}, int\emph{ num\_devices}, const char *\emph{ buf}}{}
create and register a ccw group device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * parent}}] \leavevmode
parent device for the new device

\item[{\code{struct ccwgroup\_driver * gdrv}}] \leavevmode
driver for the new group device

\item[{\code{int num\_devices}}] \leavevmode
number of slave devices

\item[{\code{const char * buf}}] \leavevmode
buffer containing comma separated bus ids of slave devices

\end{description}

\textbf{Description}

Create and register a new ccw group device as a child of \textbf{parent}. Slave
devices are obtained from the list of bus ids given in \textbf{buf}.

\textbf{Return}
\begin{quote}

\code{0} on success and an error code on failure.
\end{quote}

\textbf{Context}

non-atomic
\index{ccwgroup\_driver\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccwgroup_driver_register}\pysiglinewithargsret{int \bfcode{ccwgroup\_driver\_register}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccwgroup_driver]{\emph{ccwgroup\_driver}}} *\emph{ cdriver}}{}
register a ccw group driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccwgroup\_driver * cdriver}}] \leavevmode
driver to be registered

\end{description}

\textbf{Description}

This function is mainly a wrapper around {\hyperref[driver\string-api/infrastructure:c.driver_register]{\emph{\code{driver\_register()}}}}.
\index{ccwgroup\_driver\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccwgroup_driver_unregister}\pysiglinewithargsret{void \bfcode{ccwgroup\_driver\_unregister}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccwgroup_driver]{\emph{ccwgroup\_driver}}} *\emph{ cdriver}}{}
deregister a ccw group driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccwgroup\_driver * cdriver}}] \leavevmode
driver to be deregistered

\end{description}

\textbf{Description}

This function is mainly a wrapper around {\hyperref[driver\string-api/infrastructure:c.driver_unregister]{\emph{\code{driver\_unregister()}}}}.
\index{ccwgroup\_probe\_ccwdev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccwgroup_probe_ccwdev}\pysiglinewithargsret{int \bfcode{ccwgroup\_probe\_ccwdev}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}}{}
probe function for slave devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
ccw device to be probed

\end{description}

\textbf{Description}

This is a dummy probe function for ccw devices that are slave devices in
a ccw group device.

\textbf{Return}
\begin{quote}

always \code{0}
\end{quote}
\index{ccwgroup\_remove\_ccwdev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.ccwgroup_remove_ccwdev}\pysiglinewithargsret{void \bfcode{ccwgroup\_remove\_ccwdev}}{struct {\hyperref[driver\string-api/s390\string-drivers:c.ccw_device]{\emph{ccw\_device}}} *\emph{ cdev}}{}
remove function for slave devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ccw\_device * cdev}}] \leavevmode
ccw device to be removed

\end{description}

\textbf{Description}

This is a remove function for ccw devices that are slave devices in a ccw
group device. It sets the ccw device offline and also deregisters the
embedding ccw group device.


\section{Generic interfaces}
\label{driver-api/s390-drivers:generic-interfaces}
The following section contains interfaces in use not only by drivers
dealing with ccw devices, but drivers for various other s390 hardware
as well.


\subsection{Adapter interrupts}
\label{driver-api/s390-drivers:adapter-interrupts}
The common I/O layer provides helper functions for dealing with adapter
interrupts and interrupt vectors.
\index{register\_adapter\_interrupt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.register_adapter_interrupt}\pysiglinewithargsret{int \bfcode{register\_adapter\_interrupt}}{struct airq\_struct *\emph{ airq}}{}
register adapter interrupt handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct airq\_struct * airq}}] \leavevmode
pointer to adapter interrupt descriptor

\end{description}

\textbf{Description}

Returns 0 on success, or -EINVAL.
\index{unregister\_adapter\_interrupt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.unregister_adapter_interrupt}\pysiglinewithargsret{void \bfcode{unregister\_adapter\_interrupt}}{struct airq\_struct *\emph{ airq}}{}
unregister adapter interrupt handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct airq\_struct * airq}}] \leavevmode
pointer to adapter interrupt descriptor

\end{description}
\index{airq\_iv\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.airq_iv_create}\pysiglinewithargsret{struct airq\_iv * \bfcode{airq\_iv\_create}}{unsigned long\emph{ bits}, unsigned long\emph{ flags}}{}
create an interrupt vector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long bits}}] \leavevmode
number of bits in the interrupt vector

\item[{\code{unsigned long flags}}] \leavevmode
allocation flags

\end{description}

\textbf{Description}

Returns a pointer to an interrupt vector structure
\index{airq\_iv\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.airq_iv_release}\pysiglinewithargsret{void \bfcode{airq\_iv\_release}}{struct airq\_iv *\emph{ iv}}{}
release an interrupt vector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct airq\_iv * iv}}] \leavevmode
pointer to interrupt vector structure

\end{description}
\index{airq\_iv\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.airq_iv_alloc}\pysiglinewithargsret{unsigned long \bfcode{airq\_iv\_alloc}}{struct airq\_iv *\emph{ iv}, unsigned long\emph{ num}}{}
allocate irq bits from an interrupt vector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct airq\_iv * iv}}] \leavevmode
pointer to an interrupt vector structure

\item[{\code{unsigned long num}}] \leavevmode
number of consecutive irq bits to allocate

\end{description}

\textbf{Description}

Returns the bit number of the first irq in the allocated block of irqs,
or -1UL if no bit is available or the AIRQ\_IV\_ALLOC flag has not been
specified
\index{airq\_iv\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.airq_iv_free}\pysiglinewithargsret{void \bfcode{airq\_iv\_free}}{struct airq\_iv *\emph{ iv}, unsigned long\emph{ bit}, unsigned long\emph{ num}}{}
free irq bits of an interrupt vector

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct airq\_iv * iv}}] \leavevmode
pointer to interrupt vector structure

\item[{\code{unsigned long bit}}] \leavevmode
number of the first irq bit to free

\item[{\code{unsigned long num}}] \leavevmode
number of consecutive irq bits to free

\end{description}
\index{airq\_iv\_scan (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/s390-drivers:c.airq_iv_scan}\pysiglinewithargsret{unsigned long \bfcode{airq\_iv\_scan}}{struct airq\_iv *\emph{ iv}, unsigned long\emph{ start}, unsigned long\emph{ end}}{}
scan interrupt vector for non-zero bits

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct airq\_iv * iv}}] \leavevmode
pointer to interrupt vector structure

\item[{\code{unsigned long start}}] \leavevmode
bit number to start the search

\item[{\code{unsigned long end}}] \leavevmode
bit number to end the search

\end{description}

\textbf{Description}

Returns the bit number of the next non-zero interrupt bit, or
-1UL if the scan completed without finding any more any non-zero bits.


\chapter{VME Device Drivers}
\label{driver-api/vme::doc}\label{driver-api/vme:vme-device-drivers}

\section{Driver registration}
\label{driver-api/vme:driver-registration}
As with other subsystems within the Linux kernel, VME device drivers register
with the VME subsystem, typically called from the devices init routine.  This is
achieved via a call to {\hyperref[driver\string-api/vme:c.vme_register_driver]{\emph{\code{vme\_register\_driver()}}}}.

A pointer to a structure of type {\hyperref[driver\string-api/vme:c.vme_driver]{\emph{\code{struct vme\_driver}}}} must
be provided to the registration function. Along with the maximum number of
devices your driver is able to support.

At the minimum, the `.name', `.match' and `.probe' elements of
{\hyperref[driver\string-api/vme:c.vme_driver]{\emph{\code{struct vme\_driver}}}} should be correctly set. The `.name'
element is a pointer to a string holding the device driver's name.

The `.match' function allows control over which VME devices should be registered
with the driver. The match function should return 1 if a device should be
probed and 0 otherwise. This example match function (from vme\_user.c) limits
the number of devices probed to one:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define USER\PYGZus{}BUS\PYGZus{}MAX    1}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k}{static} \PYG{k+kt}{int} \PYG{n}{vme\PYGZus{}user\PYGZus{}match}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{vme\PYGZus{}dev} \PYG{o}{*}\PYG{n}{vdev}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{vdev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{id}\PYG{p}{.}\PYG{n}{num} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{USER\PYGZus{}BUS\PYGZus{}MAX}\PYG{p}{)}
                \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The `.probe' element should contain a pointer to the probe routine. The
probe routine is passed a {\hyperref[driver\string-api/vme:c.vme_dev]{\emph{\code{struct vme\_dev}}}} pointer as an
argument.

Here, the `num' field refers to the sequential device ID for this specific
driver. The bridge number (or bus number) can be accessed using
dev-\textgreater{}bridge-\textgreater{}num.

A function is also provided to unregister the driver from the VME core called
{\hyperref[driver\string-api/vme:c.vme_unregister_driver]{\emph{\code{vme\_unregister\_driver()}}}} and should usually be called from the device
driver's exit routine.


\section{Resource management}
\label{driver-api/vme:resource-management}
Once a driver has registered with the VME core the provided match routine will
be called the number of times specified during the registration. If a match
succeeds, a non-zero value should be returned. A zero return value indicates
failure. For all successful matches, the probe routine of the corresponding
driver is called. The probe routine is passed a pointer to the devices
device structure. This pointer should be saved, it will be required for
requesting VME resources.

The driver can request ownership of one or more master windows
({\hyperref[driver\string-api/vme:c.vme_master_request]{\emph{\code{vme\_master\_request()}}}}), slave windows ({\hyperref[driver\string-api/vme:c.vme_slave_request]{\emph{\code{vme\_slave\_request()}}}})
and/or dma channels ({\hyperref[driver\string-api/vme:c.vme_dma_request]{\emph{\code{vme\_dma\_request()}}}}). Rather than allowing the device
driver to request a specific window or DMA channel (which may be used by a
different driver) the API allows a resource to be assigned based on the required
attributes of the driver in question. For slave windows these attributes are
split into the VME address spaces that need to be accessed in `aspace' and VME
bus cycle types required in `cycle'. Master windows add a further set of
attributes in `width' specifying the required data transfer widths. These
attributes are defined as bitmasks and as such any combination of the
attributes can be requested for a single window, the core will assign a window
that meets the requirements, returning a pointer of type vme\_resource that
should be used to identify the allocated resource when it is used. For DMA
controllers, the request function requires the potential direction of any
transfers to be provided in the route attributes. This is typically VME-to-MEM
and/or MEM-to-VME, though some hardware can support VME-to-VME and MEM-to-MEM
transfers as well as test pattern generation. If an unallocated window fitting
the requirements can not be found a NULL pointer will be returned.

Functions are also provided to free window allocations once they are no longer
required. These functions ({\hyperref[driver\string-api/vme:c.vme_master_free]{\emph{\code{vme\_master\_free()}}}}, {\hyperref[driver\string-api/vme:c.vme_slave_free]{\emph{\code{vme\_slave\_free()}}}}
and {\hyperref[driver\string-api/vme:c.vme_dma_free]{\emph{\code{vme\_dma\_free()}}}}) should be passed the pointer to the resource
provided during resource allocation.


\section{Master windows}
\label{driver-api/vme:master-windows}
Master windows provide access from the local processor{[}s{]} out onto the VME bus.
The number of windows available and the available access modes is dependent on
the underlying chipset. A window must be configured before it can be used.


\subsection{Master window configuration}
\label{driver-api/vme:master-window-configuration}
Once a master window has been assigned {\hyperref[driver\string-api/vme:c.vme_master_set]{\emph{\code{vme\_master\_set()}}}} can be used to
configure it and {\hyperref[driver\string-api/vme:c.vme_master_get]{\emph{\code{vme\_master\_get()}}}} to retrieve the current settings. The
address spaces, transfer widths and cycle types are the same as described
under resource management, however some of the options are mutually exclusive.
For example, only one address space may be specified.


\subsection{Master window access}
\label{driver-api/vme:master-window-access}
The function {\hyperref[driver\string-api/vme:c.vme_master_read]{\emph{\code{vme\_master\_read()}}}} can be used to read from and
{\hyperref[driver\string-api/vme:c.vme_master_write]{\emph{\code{vme\_master\_write()}}}} used to write to configured master windows.

In addition to simple reads and writes, {\hyperref[driver\string-api/vme:c.vme_master_rmw]{\emph{\code{vme\_master\_rmw()}}}} is provided to
do a read-modify-write transaction. Parts of a VME window can also be mapped
into user space memory using {\hyperref[driver\string-api/vme:c.vme_master_mmap]{\emph{\code{vme\_master\_mmap()}}}}.


\section{Slave windows}
\label{driver-api/vme:slave-windows}
Slave windows provide devices on the VME bus access into mapped portions of the
local memory. The number of windows available and the access modes that can be
used is dependent on the underlying chipset. A window must be configured before
it can be used.


\subsection{Slave window configuration}
\label{driver-api/vme:slave-window-configuration}
Once a slave window has been assigned {\hyperref[driver\string-api/vme:c.vme_slave_set]{\emph{\code{vme\_slave\_set()}}}} can be used to
configure it and {\hyperref[driver\string-api/vme:c.vme_slave_get]{\emph{\code{vme\_slave\_get()}}}} to retrieve the current settings.

The address spaces, transfer widths and cycle types are the same as described
under resource management, however some of the options are mutually exclusive.
For example, only one address space may be specified.


\subsection{Slave window buffer allocation}
\label{driver-api/vme:slave-window-buffer-allocation}
Functions are provided to allow the user to allocate
({\hyperref[driver\string-api/vme:c.vme_alloc_consistent]{\emph{\code{vme\_alloc\_consistent()}}}}) and free ({\hyperref[driver\string-api/vme:c.vme_free_consistent]{\emph{\code{vme\_free\_consistent()}}}})
contiguous buffers which will be accessible by the VME bridge. These functions
do not have to be used, other methods can be used to allocate a buffer, though
care must be taken to ensure that they are contiguous and accessible by the VME
bridge.


\subsection{Slave window access}
\label{driver-api/vme:slave-window-access}
Slave windows map local memory onto the VME bus, the standard methods for
accessing memory should be used.


\section{DMA channels}
\label{driver-api/vme:dma-channels}
The VME DMA transfer provides the ability to run link-list DMA transfers. The
API introduces the concept of DMA lists. Each DMA list is a link-list which can
be passed to a DMA controller. Multiple lists can be created, extended,
executed, reused and destroyed.


\subsection{List Management}
\label{driver-api/vme:list-management}
The function {\hyperref[driver\string-api/vme:c.vme_new_dma_list]{\emph{\code{vme\_new\_dma\_list()}}}} is provided to create and
{\hyperref[driver\string-api/vme:c.vme_dma_list_free]{\emph{\code{vme\_dma\_list\_free()}}}} to destroy DMA lists. Execution of a list will not
automatically destroy the list, thus enabling a list to be reused for repetitive
tasks.


\subsection{List Population}
\label{driver-api/vme:list-population}
An item can be added to a list using {\hyperref[driver\string-api/vme:c.vme_dma_list_add]{\emph{\code{vme\_dma\_list\_add()}}}} (the source and
destination attributes need to be created before calling this function, this is
covered under ``Transfer Attributes'').

\begin{notice}{note}{Note:}
The detailed attributes of the transfers source and destination
are not checked until an entry is added to a DMA list, the request
for a DMA channel purely checks the directions in which the
controller is expected to transfer data. As a result it is
possible for this call to return an error, for example if the
source or destination is in an unsupported VME address space.
\end{notice}


\subsection{Transfer Attributes}
\label{driver-api/vme:transfer-attributes}
The attributes for the source and destination are handled separately from adding
an item to a list. This is due to the diverse attributes required for each type
of source and destination. There are functions to create attributes for PCI, VME
and pattern sources and destinations (where appropriate):
\begin{itemize}
\item {} 
PCI source or destination: {\hyperref[driver\string-api/vme:c.vme_dma_pci_attribute]{\emph{\code{vme\_dma\_pci\_attribute()}}}}

\item {} 
VME source or destination: {\hyperref[driver\string-api/vme:c.vme_dma_vme_attribute]{\emph{\code{vme\_dma\_vme\_attribute()}}}}

\item {} 
Pattern source: {\hyperref[driver\string-api/vme:c.vme_dma_pattern_attribute]{\emph{\code{vme\_dma\_pattern\_attribute()}}}}

\end{itemize}

The function {\hyperref[driver\string-api/vme:c.vme_dma_free_attribute]{\emph{\code{vme\_dma\_free\_attribute()}}}} should be used to free an
attribute.


\subsection{List Execution}
\label{driver-api/vme:list-execution}
The function {\hyperref[driver\string-api/vme:c.vme_dma_list_exec]{\emph{\code{vme\_dma\_list\_exec()}}}} queues a list for execution and will
return once the list has been executed.


\section{Interrupts}
\label{driver-api/vme:interrupts}
The VME API provides functions to attach and detach callbacks to specific VME
level and status ID combinations and for the generation of VME interrupts with
specific VME level and status IDs.


\subsection{Attaching Interrupt Handlers}
\label{driver-api/vme:attaching-interrupt-handlers}
The function {\hyperref[driver\string-api/vme:c.vme_irq_request]{\emph{\code{vme\_irq\_request()}}}} can be used to attach and
{\hyperref[driver\string-api/vme:c.vme_irq_free]{\emph{\code{vme\_irq\_free()}}}} to free a specific VME level and status ID combination.
Any given combination can only be assigned a single callback function. A void
pointer parameter is provided, the value of which is passed to the callback
function, the use of this pointer is user undefined. The callback parameters are
as follows. Care must be taken in writing a callback function, callback
functions run in interrupt context:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{callback}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{level}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{statid}\PYG{p}{,} \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{priv}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}


\subsection{Interrupt Generation}
\label{driver-api/vme:interrupt-generation}
The function {\hyperref[driver\string-api/vme:c.vme_irq_generate]{\emph{\code{vme\_irq\_generate()}}}} can be used to generate a VME interrupt
at a given VME level and VME status ID.


\section{Location monitors}
\label{driver-api/vme:location-monitors}
The VME API provides the following functionality to configure the location
monitor.


\subsection{Location Monitor Management}
\label{driver-api/vme:location-monitor-management}
The function {\hyperref[driver\string-api/vme:c.vme_lm_request]{\emph{\code{vme\_lm\_request()}}}} is provided to request the use of a block
of location monitors and {\hyperref[driver\string-api/vme:c.vme_lm_free]{\emph{\code{vme\_lm\_free()}}}} to free them after they are no
longer required. Each block may provide a number of location monitors,
monitoring adjacent locations. The function {\hyperref[driver\string-api/vme:c.vme_lm_count]{\emph{\code{vme\_lm\_count()}}}} can be used
to determine how many locations are provided.


\subsection{Location Monitor Configuration}
\label{driver-api/vme:location-monitor-configuration}
Once a bank of location monitors has been allocated, the function
{\hyperref[driver\string-api/vme:c.vme_lm_set]{\emph{\code{vme\_lm\_set()}}}} is provided to configure the location and mode of the
location monitor. The function {\hyperref[driver\string-api/vme:c.vme_lm_get]{\emph{\code{vme\_lm\_get()}}}} can be used to retrieve
existing settings.


\subsection{Location Monitor Use}
\label{driver-api/vme:location-monitor-use}
The function {\hyperref[driver\string-api/vme:c.vme_lm_attach]{\emph{\code{vme\_lm\_attach()}}}} enables a callback to be attached and
{\hyperref[driver\string-api/vme:c.vme_lm_detach]{\emph{\code{vme\_lm\_detach()}}}} allows on to be detached from each location monitor
location. Each location monitor can monitor a number of adjacent locations. The
callback function is declared as follows.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{callback}\PYG{p}{(}\PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{data}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}


\section{Slot Detection}
\label{driver-api/vme:slot-detection}
The function {\hyperref[driver\string-api/vme:c.vme_slot_num]{\emph{\code{vme\_slot\_num()}}}} returns the slot ID of the provided bridge.


\section{Bus Detection}
\label{driver-api/vme:bus-detection}
The function {\hyperref[driver\string-api/vme:c.vme_bus_num]{\emph{\code{vme\_bus\_num()}}}} returns the bus ID of the provided bridge.


\section{VME API}
\label{driver-api/vme:vme-api}\index{vme\_dev (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_dev}\pysigline{struct \bfcode{vme\_dev}}
Structure representing a VME device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct vme\PYGZus{}dev \PYGZob{}
  int num;
  struct vme\PYGZus{}bridge *bridge;
  struct device dev;
  struct list\PYGZus{}head drv\PYGZus{}list;
  struct list\PYGZus{}head bridge\PYGZus{}list;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{num}}] \leavevmode
The device number

\item[{\code{bridge}}] \leavevmode
Pointer to the bridge device this device is on

\item[{\code{dev}}] \leavevmode
Internal device structure

\item[{\code{drv\_list}}] \leavevmode
List of devices (per driver)

\item[{\code{bridge\_list}}] \leavevmode
List of devices (per bridge)

\end{description}
\index{vme\_driver (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_driver}\pysigline{struct \bfcode{vme\_driver}}
Structure representing a VME driver

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct vme\PYGZus{}driver \PYGZob{}
  const char *name;
  int (*match)(struct vme\PYGZus{}dev *);
  int (*probe)(struct vme\PYGZus{}dev *);
  int (*remove)(struct vme\PYGZus{}dev *);
  struct device\PYGZus{}driver driver;
  struct list\PYGZus{}head devices;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
Driver name, should be unique among VME drivers and usually the same
as the module name.

\item[{\code{match}}] \leavevmode
Callback used to determine whether probe should be run.

\item[{\code{probe}}] \leavevmode
Callback for device binding, called when new device is detected.

\item[{\code{remove}}] \leavevmode
Callback, called on device removal.

\item[{\code{driver}}] \leavevmode
Underlying generic device driver structure.

\item[{\code{devices}}] \leavevmode
List of VME devices (struct vme\_dev) associated with this driver.

\end{description}
\index{vme\_alloc\_consistent (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_alloc_consistent}\pysiglinewithargsret{void * \bfcode{vme\_alloc\_consistent}}{struct vme\_resource *\emph{ resource}, size\_t\emph{ size}, dma\_addr\_t *\emph{ dma}}{}
Allocate contiguous memory.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME resource.

\item[{\code{size\_t size}}] \leavevmode
Size of allocation required.

\item[{\code{dma\_addr\_t * dma}}] \leavevmode
Pointer to variable to store physical address of allocation.

\end{description}

\textbf{Description}

Allocate a contiguous block of memory for use by the driver. This is used to
create the buffers for the slave windows.

\textbf{Return}

Virtual address of allocation on success, NULL on failure.
\index{vme\_free\_consistent (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_free_consistent}\pysiglinewithargsret{void \bfcode{vme\_free\_consistent}}{struct vme\_resource *\emph{ resource}, size\_t\emph{ size}, void *\emph{ vaddr}, dma\_addr\_t\emph{ dma}}{}
Free previously allocated memory.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME resource.

\item[{\code{size\_t size}}] \leavevmode
Size of allocation to free.

\item[{\code{void * vaddr}}] \leavevmode
Virtual address of allocation.

\item[{\code{dma\_addr\_t dma}}] \leavevmode
Physical address of allocation.

\end{description}

\textbf{Description}

Free previously allocated block of contiguous memory.
\index{vme\_get\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_get_size}\pysiglinewithargsret{size\_t \bfcode{vme\_get\_size}}{struct vme\_resource *\emph{ resource}}{}
Helper function returning size of a VME window

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME slave or master resource.

\end{description}

\textbf{Description}

Determine the size of the VME window provided. This is a helper
function, wrappering the call to vme\_master\_get or vme\_slave\_get
depending on the type of window resource handed to it.

\textbf{Return}

Size of the window on success, zero on failure.
\index{vme\_slave\_request (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_slave_request}\pysiglinewithargsret{struct vme\_resource * \bfcode{vme\_slave\_request}}{struct {\hyperref[driver\string-api/vme:c.vme_dev]{\emph{vme\_dev}}} *\emph{ vdev}, u32\emph{ address}, u32\emph{ cycle}}{}
Request a VME slave window resource.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_dev * vdev}}] \leavevmode
Pointer to VME device struct vme\_dev assigned to driver instance.

\item[{\code{u32 address}}] \leavevmode
Required VME address space.

\item[{\code{u32 cycle}}] \leavevmode
Required VME data transfer cycle type.

\end{description}

\textbf{Description}

Request use of a VME window resource capable of being set for the requested
address space and data transfer cycle.

\textbf{Return}

Pointer to VME resource on success, NULL on failure.
\index{vme\_slave\_set (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_slave_set}\pysiglinewithargsret{int \bfcode{vme\_slave\_set}}{struct vme\_resource *\emph{ resource}, int\emph{ enabled}, unsigned long long\emph{ vme\_base}, unsigned long long\emph{ size}, dma\_addr\_t\emph{ buf\_base}, u32\emph{ aspace}, u32\emph{ cycle}}{}
Set VME slave window configuration.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME slave resource.

\item[{\code{int enabled}}] \leavevmode
State to which the window should be configured.

\item[{\code{unsigned long long vme\_base}}] \leavevmode
Base address for the window.

\item[{\code{unsigned long long size}}] \leavevmode
Size of the VME window.

\item[{\code{dma\_addr\_t buf\_base}}] \leavevmode
Based address of buffer used to provide VME slave window storage.

\item[{\code{u32 aspace}}] \leavevmode
VME address space for the VME window.

\item[{\code{u32 cycle}}] \leavevmode
VME data transfer cycle type for the VME window.

\end{description}

\textbf{Description}

Set configuration for provided VME slave window.

\textbf{Return}
\begin{description}
\item[{Zero on success, -EINVAL if operation is not supported on this}] \leavevmode
device, if an invalid resource has been provided or invalid
attributes are provided. Hardware specific errors may also be
returned.

\end{description}
\index{vme\_slave\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_slave_get}\pysiglinewithargsret{int \bfcode{vme\_slave\_get}}{struct vme\_resource *\emph{ resource}, int *\emph{ enabled}, unsigned long long *\emph{ vme\_base}, unsigned long long *\emph{ size}, dma\_addr\_t *\emph{ buf\_base}, u32 *\emph{ aspace}, u32 *\emph{ cycle}}{}
Retrieve VME slave window configuration.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME slave resource.

\item[{\code{int * enabled}}] \leavevmode
Pointer to variable for storing state.

\item[{\code{unsigned long long * vme\_base}}] \leavevmode
Pointer to variable for storing window base address.

\item[{\code{unsigned long long * size}}] \leavevmode
Pointer to variable for storing window size.

\item[{\code{dma\_addr\_t * buf\_base}}] \leavevmode
Pointer to variable for storing slave buffer base address.

\item[{\code{u32 * aspace}}] \leavevmode
Pointer to variable for storing VME address space.

\item[{\code{u32 * cycle}}] \leavevmode
Pointer to variable for storing VME data transfer cycle type.

\end{description}

\textbf{Description}

Return configuration for provided VME slave window.

\textbf{Return}
\begin{description}
\item[{Zero on success, -EINVAL if operation is not supported on this}] \leavevmode
device or if an invalid resource has been provided.

\end{description}
\index{vme\_slave\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_slave_free}\pysiglinewithargsret{void \bfcode{vme\_slave\_free}}{struct vme\_resource *\emph{ resource}}{}
Free VME slave window

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME slave resource.

\end{description}

\textbf{Description}

Free the provided slave resource so that it may be reallocated.
\index{vme\_master\_request (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_master_request}\pysiglinewithargsret{struct vme\_resource * \bfcode{vme\_master\_request}}{struct {\hyperref[driver\string-api/vme:c.vme_dev]{\emph{vme\_dev}}} *\emph{ vdev}, u32\emph{ address}, u32\emph{ cycle}, u32\emph{ dwidth}}{}
Request a VME master window resource.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_dev * vdev}}] \leavevmode
Pointer to VME device struct vme\_dev assigned to driver instance.

\item[{\code{u32 address}}] \leavevmode
Required VME address space.

\item[{\code{u32 cycle}}] \leavevmode
Required VME data transfer cycle type.

\item[{\code{u32 dwidth}}] \leavevmode
Required VME data transfer width.

\end{description}

\textbf{Description}

Request use of a VME window resource capable of being set for the requested
address space, data transfer cycle and width.

\textbf{Return}

Pointer to VME resource on success, NULL on failure.
\index{vme\_master\_set (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_master_set}\pysiglinewithargsret{int \bfcode{vme\_master\_set}}{struct vme\_resource *\emph{ resource}, int\emph{ enabled}, unsigned long long\emph{ vme\_base}, unsigned long long\emph{ size}, u32\emph{ aspace}, u32\emph{ cycle}, u32\emph{ dwidth}}{}
Set VME master window configuration.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME master resource.

\item[{\code{int enabled}}] \leavevmode
State to which the window should be configured.

\item[{\code{unsigned long long vme\_base}}] \leavevmode
Base address for the window.

\item[{\code{unsigned long long size}}] \leavevmode
Size of the VME window.

\item[{\code{u32 aspace}}] \leavevmode
VME address space for the VME window.

\item[{\code{u32 cycle}}] \leavevmode
VME data transfer cycle type for the VME window.

\item[{\code{u32 dwidth}}] \leavevmode
VME data transfer width for the VME window.

\end{description}

\textbf{Description}

Set configuration for provided VME master window.

\textbf{Return}
\begin{description}
\item[{Zero on success, -EINVAL if operation is not supported on this}] \leavevmode
device, if an invalid resource has been provided or invalid
attributes are provided. Hardware specific errors may also be
returned.

\end{description}
\index{vme\_master\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_master_get}\pysiglinewithargsret{int \bfcode{vme\_master\_get}}{struct vme\_resource *\emph{ resource}, int *\emph{ enabled}, unsigned long long *\emph{ vme\_base}, unsigned long long *\emph{ size}, u32 *\emph{ aspace}, u32 *\emph{ cycle}, u32 *\emph{ dwidth}}{}
Retrieve VME master window configuration.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME master resource.

\item[{\code{int * enabled}}] \leavevmode
Pointer to variable for storing state.

\item[{\code{unsigned long long * vme\_base}}] \leavevmode
Pointer to variable for storing window base address.

\item[{\code{unsigned long long * size}}] \leavevmode
Pointer to variable for storing window size.

\item[{\code{u32 * aspace}}] \leavevmode
Pointer to variable for storing VME address space.

\item[{\code{u32 * cycle}}] \leavevmode
Pointer to variable for storing VME data transfer cycle type.

\item[{\code{u32 * dwidth}}] \leavevmode
Pointer to variable for storing VME data transfer width.

\end{description}

\textbf{Description}

Return configuration for provided VME master window.

\textbf{Return}
\begin{description}
\item[{Zero on success, -EINVAL if operation is not supported on this}] \leavevmode
device or if an invalid resource has been provided.

\end{description}
\index{vme\_master\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_master_read}\pysiglinewithargsret{ssize\_t \bfcode{vme\_master\_read}}{struct vme\_resource *\emph{ resource}, void *\emph{ buf}, size\_t\emph{ count}, loff\_t\emph{ offset}}{}
Read data from VME space into a buffer.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME master resource.

\item[{\code{void * buf}}] \leavevmode
Pointer to buffer where data should be transferred.

\item[{\code{size\_t count}}] \leavevmode
Number of bytes to transfer.

\item[{\code{loff\_t offset}}] \leavevmode
Offset into VME master window at which to start transfer.

\end{description}

\textbf{Description}

Perform read of count bytes of data from location on VME bus which maps into
the VME master window at offset to buf.

\textbf{Return}
\begin{description}
\item[{Number of bytes read, -EINVAL if resource is not a VME master}] \leavevmode
resource or read operation is not supported. -EFAULT returned if
invalid offset is provided. Hardware specific errors may also be
returned.

\end{description}
\index{vme\_master\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_master_write}\pysiglinewithargsret{ssize\_t \bfcode{vme\_master\_write}}{struct vme\_resource *\emph{ resource}, void *\emph{ buf}, size\_t\emph{ count}, loff\_t\emph{ offset}}{}
Write data out to VME space from a buffer.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME master resource.

\item[{\code{void * buf}}] \leavevmode
Pointer to buffer holding data to transfer.

\item[{\code{size\_t count}}] \leavevmode
Number of bytes to transfer.

\item[{\code{loff\_t offset}}] \leavevmode
Offset into VME master window at which to start transfer.

\end{description}

\textbf{Description}

Perform write of count bytes of data from buf to location on VME bus which
maps into the VME master window at offset.

\textbf{Return}
\begin{description}
\item[{Number of bytes written, -EINVAL if resource is not a VME master}] \leavevmode
resource or write operation is not supported. -EFAULT returned if
invalid offset is provided. Hardware specific errors may also be
returned.

\end{description}
\index{vme\_master\_rmw (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_master_rmw}\pysiglinewithargsret{unsigned int \bfcode{vme\_master\_rmw}}{struct vme\_resource *\emph{ resource}, unsigned int\emph{ mask}, unsigned int\emph{ compare}, unsigned int\emph{ swap}, loff\_t\emph{ offset}}{}
Perform read-modify-write cycle.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME master resource.

\item[{\code{unsigned int mask}}] \leavevmode
Bits to be compared and swapped in operation.

\item[{\code{unsigned int compare}}] \leavevmode
Bits to be compared with data read from offset.

\item[{\code{unsigned int swap}}] \leavevmode
Bits to be swapped in data read from offset.

\item[{\code{loff\_t offset}}] \leavevmode
Offset into VME master window at which to perform operation.

\end{description}

\textbf{Description}

Perform read-modify-write cycle on provided location:
- Location on VME bus is read.
- Bits selected by mask are compared with compare.
- Where a selected bit matches that in compare and are selected in swap,
the bit is swapped.
- Result written back to location on VME bus.

\textbf{Return}
\begin{description}
\item[{Bytes written on success, -EINVAL if resource is not a VME master}] \leavevmode
resource or RMW operation is not supported. Hardware specific
errors may also be returned.

\end{description}
\index{vme\_master\_mmap (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_master_mmap}\pysiglinewithargsret{int \bfcode{vme\_master\_mmap}}{struct vme\_resource *\emph{ resource}, struct vm\_area\_struct *\emph{ vma}}{}
Mmap region of VME master window.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME master resource.

\item[{\code{struct vm\_area\_struct * vma}}] \leavevmode
Pointer to definition of user mapping.

\end{description}

\textbf{Description}

Memory map a region of the VME master window into user space.

\textbf{Return}
\begin{description}
\item[{Zero on success, -EINVAL if resource is not a VME master}] \leavevmode
resource or -EFAULT if map exceeds window size. Other generic mmap
errors may also be returned.

\end{description}
\index{vme\_master\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_master_free}\pysiglinewithargsret{void \bfcode{vme\_master\_free}}{struct vme\_resource *\emph{ resource}}{}
Free VME master window

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME master resource.

\end{description}

\textbf{Description}

Free the provided master resource so that it may be reallocated.
\index{vme\_dma\_request (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_dma_request}\pysiglinewithargsret{struct vme\_resource * \bfcode{vme\_dma\_request}}{struct {\hyperref[driver\string-api/vme:c.vme_dev]{\emph{vme\_dev}}} *\emph{ vdev}, u32\emph{ route}}{}
Request a DMA controller.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_dev * vdev}}] \leavevmode
Pointer to VME device struct vme\_dev assigned to driver instance.

\item[{\code{u32 route}}] \leavevmode
Required src/destination combination.

\end{description}

\textbf{Description}

Request a VME DMA controller with capability to perform transfers bewteen
requested source/destination combination.

\textbf{Return}

Pointer to VME DMA resource on success, NULL on failure.
\index{vme\_new\_dma\_list (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_new_dma_list}\pysiglinewithargsret{struct vme\_dma\_list * \bfcode{vme\_new\_dma\_list}}{struct vme\_resource *\emph{ resource}}{}
Create new VME DMA list.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME DMA resource.

\end{description}

\textbf{Description}

Create a new VME DMA list. It is the responsibility of the user to free
the list once it is no longer required with {\hyperref[driver\string-api/vme:c.vme_dma_list_free]{\emph{\code{vme\_dma\_list\_free()}}}}.

\textbf{Return}
\begin{description}
\item[{Pointer to new VME DMA list, NULL on allocation failure or invalid}] \leavevmode
VME DMA resource.

\end{description}
\index{vme\_dma\_pattern\_attribute (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_dma_pattern_attribute}\pysiglinewithargsret{struct vme\_dma\_attr * \bfcode{vme\_dma\_pattern\_attribute}}{u32\emph{ pattern}, u32\emph{ type}}{}
Create ``Pattern'' type VME DMA list attribute.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u32 pattern}}] \leavevmode
Value to use used as pattern

\item[{\code{u32 type}}] \leavevmode
Type of pattern to be written.

\end{description}

\textbf{Description}

Create VME DMA list attribute for pattern generation. It is the
responsibility of the user to free used attributes using
{\hyperref[driver\string-api/vme:c.vme_dma_free_attribute]{\emph{\code{vme\_dma\_free\_attribute()}}}}.

\textbf{Return}

Pointer to VME DMA attribute, NULL on failure.
\index{vme\_dma\_pci\_attribute (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_dma_pci_attribute}\pysiglinewithargsret{struct vme\_dma\_attr * \bfcode{vme\_dma\_pci\_attribute}}{dma\_addr\_t\emph{ address}}{}
Create ``PCI'' type VME DMA list attribute.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{dma\_addr\_t address}}] \leavevmode
PCI base address for DMA transfer.

\end{description}

\textbf{Description}

Create VME DMA list attribute pointing to a location on PCI for DMA
transfers. It is the responsibility of the user to free used attributes
using {\hyperref[driver\string-api/vme:c.vme_dma_free_attribute]{\emph{\code{vme\_dma\_free\_attribute()}}}}.

\textbf{Return}

Pointer to VME DMA attribute, NULL on failure.
\index{vme\_dma\_vme\_attribute (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_dma_vme_attribute}\pysiglinewithargsret{struct vme\_dma\_attr * \bfcode{vme\_dma\_vme\_attribute}}{unsigned long long\emph{ address}, u32\emph{ aspace}, u32\emph{ cycle}, u32\emph{ dwidth}}{}
Create ``VME'' type VME DMA list attribute.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long long address}}] \leavevmode
VME base address for DMA transfer.

\item[{\code{u32 aspace}}] \leavevmode
VME address space to use for DMA transfer.

\item[{\code{u32 cycle}}] \leavevmode
VME bus cycle to use for DMA transfer.

\item[{\code{u32 dwidth}}] \leavevmode
VME data width to use for DMA transfer.

\end{description}

\textbf{Description}

Create VME DMA list attribute pointing to a location on the VME bus for DMA
transfers. It is the responsibility of the user to free used attributes
using {\hyperref[driver\string-api/vme:c.vme_dma_free_attribute]{\emph{\code{vme\_dma\_free\_attribute()}}}}.

\textbf{Return}

Pointer to VME DMA attribute, NULL on failure.
\index{vme\_dma\_free\_attribute (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_dma_free_attribute}\pysiglinewithargsret{void \bfcode{vme\_dma\_free\_attribute}}{struct vme\_dma\_attr *\emph{ attributes}}{}
Free DMA list attribute.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_dma\_attr * attributes}}] \leavevmode
Pointer to DMA list attribute.

\end{description}

\textbf{Description}

Free VME DMA list attribute. VME DMA list attributes can be safely freed
once {\hyperref[driver\string-api/vme:c.vme_dma_list_add]{\emph{\code{vme\_dma\_list\_add()}}}} has returned.
\index{vme\_dma\_list\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_dma_list_add}\pysiglinewithargsret{int \bfcode{vme\_dma\_list\_add}}{struct vme\_dma\_list *\emph{ list}, struct vme\_dma\_attr *\emph{ src}, struct vme\_dma\_attr *\emph{ dest}, size\_t\emph{ count}}{}
Add enty to a VME DMA list.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_dma\_list * list}}] \leavevmode
Pointer to VME list.

\item[{\code{struct vme\_dma\_attr * src}}] \leavevmode
Pointer to DMA list attribute to use as source.

\item[{\code{struct vme\_dma\_attr * dest}}] \leavevmode
Pointer to DMA list attribute to use as destination.

\item[{\code{size\_t count}}] \leavevmode
Number of bytes to transfer.

\end{description}

\textbf{Description}

Add an entry to the provided VME DMA list. Entry requires pointers to source
and destination DMA attributes and a count.

Please note, the attributes supported as source and destinations for
transfers are hardware dependent.

\textbf{Return}
\begin{description}
\item[{Zero on success, -EINVAL if operation is not supported on this}] \leavevmode
device or if the link list has already been submitted for execution.
Hardware specific errors also possible.

\end{description}
\index{vme\_dma\_list\_exec (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_dma_list_exec}\pysiglinewithargsret{int \bfcode{vme\_dma\_list\_exec}}{struct vme\_dma\_list *\emph{ list}}{}
Queue a VME DMA list for execution.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_dma\_list * list}}] \leavevmode
Pointer to VME list.

\end{description}

\textbf{Description}

Queue the provided VME DMA list for execution. The call will return once the
list has been executed.

\textbf{Return}
\begin{description}
\item[{Zero on success, -EINVAL if operation is not supported on this}] \leavevmode
device. Hardware specific errors also possible.

\end{description}
\index{vme\_dma\_list\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_dma_list_free}\pysiglinewithargsret{int \bfcode{vme\_dma\_list\_free}}{struct vme\_dma\_list *\emph{ list}}{}
Free a VME DMA list.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_dma\_list * list}}] \leavevmode
Pointer to VME list.

\end{description}

\textbf{Description}

Free the provided DMA list and all its entries.

\textbf{Return}
\begin{description}
\item[{Zero on success, -EINVAL on invalid VME resource, -EBUSY if resource}] \leavevmode
is still in use. Hardware specific errors also possible.

\end{description}
\index{vme\_dma\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_dma_free}\pysiglinewithargsret{int \bfcode{vme\_dma\_free}}{struct vme\_resource *\emph{ resource}}{}
Free a VME DMA resource.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME DMA resource.

\end{description}

\textbf{Description}

Free the provided DMA resource so that it may be reallocated.

\textbf{Return}
\begin{description}
\item[{Zero on success, -EINVAL on invalid VME resource, -EBUSY if resource}] \leavevmode
is still active.

\end{description}
\index{vme\_irq\_request (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_irq_request}\pysiglinewithargsret{int \bfcode{vme\_irq\_request}}{struct {\hyperref[driver\string-api/vme:c.vme_dev]{\emph{vme\_dev}}} *\emph{ vdev}, int\emph{ level}, int\emph{ statid}, void (*callback)\emph{ (int}, int, void\emph{ *}, void *\emph{ priv\_data}}{}
Request a specific VME interrupt.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_dev * vdev}}] \leavevmode
Pointer to VME device struct vme\_dev assigned to driver instance.

\item[{\code{int level}}] \leavevmode
Interrupt priority being requested.

\item[{\code{int statid}}] \leavevmode
Interrupt vector being requested.

\item[{\code{void (*)(int, int, void *) callback}}] \leavevmode
Pointer to callback function called when VME interrupt/vector
received.

\item[{\code{void * priv\_data}}] \leavevmode
Generic pointer that will be passed to the callback function.

\end{description}

\textbf{Description}

Request callback to be attached as a handler for VME interrupts with provided
level and statid.

\textbf{Return}
\begin{description}
\item[{Zero on success, -EINVAL on invalid vme device, level or if the}] \leavevmode
function is not supported, -EBUSY if the level/statid combination is
already in use. Hardware specific errors also possible.

\end{description}
\index{vme\_irq\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_irq_free}\pysiglinewithargsret{void \bfcode{vme\_irq\_free}}{struct {\hyperref[driver\string-api/vme:c.vme_dev]{\emph{vme\_dev}}} *\emph{ vdev}, int\emph{ level}, int\emph{ statid}}{}
Free a VME interrupt.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_dev * vdev}}] \leavevmode
Pointer to VME device struct vme\_dev assigned to driver instance.

\item[{\code{int level}}] \leavevmode
Interrupt priority of interrupt being freed.

\item[{\code{int statid}}] \leavevmode
Interrupt vector of interrupt being freed.

\end{description}

\textbf{Description}

Remove previously attached callback from VME interrupt priority/vector.
\index{vme\_irq\_generate (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_irq_generate}\pysiglinewithargsret{int \bfcode{vme\_irq\_generate}}{struct {\hyperref[driver\string-api/vme:c.vme_dev]{\emph{vme\_dev}}} *\emph{ vdev}, int\emph{ level}, int\emph{ statid}}{}
Generate VME interrupt.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_dev * vdev}}] \leavevmode
Pointer to VME device struct vme\_dev assigned to driver instance.

\item[{\code{int level}}] \leavevmode
Interrupt priority at which to assert the interrupt.

\item[{\code{int statid}}] \leavevmode
Interrupt vector to associate with the interrupt.

\end{description}

\textbf{Description}

Generate a VME interrupt of the provided level and with the provided
statid.

\textbf{Return}
\begin{description}
\item[{Zero on success, -EINVAL on invalid vme device, level or if the}] \leavevmode
function is not supported. Hardware specific errors also possible.

\end{description}
\index{vme\_lm\_request (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_lm_request}\pysiglinewithargsret{struct vme\_resource * \bfcode{vme\_lm\_request}}{struct {\hyperref[driver\string-api/vme:c.vme_dev]{\emph{vme\_dev}}} *\emph{ vdev}}{}
Request a VME location monitor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_dev * vdev}}] \leavevmode
Pointer to VME device struct vme\_dev assigned to driver instance.

\end{description}

\textbf{Description}

Allocate a location monitor resource to the driver. A location monitor
allows the driver to monitor accesses to a contiguous number of
addresses on the VME bus.

\textbf{Return}

Pointer to a VME resource on success or NULL on failure.
\index{vme\_lm\_count (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_lm_count}\pysiglinewithargsret{int \bfcode{vme\_lm\_count}}{struct vme\_resource *\emph{ resource}}{}
Determine number of VME Addresses monitored

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME location monitor resource.

\end{description}

\textbf{Description}

The number of contiguous addresses monitored is hardware dependent.
Return the number of contiguous addresses monitored by the
location monitor.

\textbf{Return}
\begin{description}
\item[{Count of addresses monitored or -EINVAL when provided with an}] \leavevmode
invalid location monitor resource.

\end{description}
\index{vme\_lm\_set (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_lm_set}\pysiglinewithargsret{int \bfcode{vme\_lm\_set}}{struct vme\_resource *\emph{ resource}, unsigned long long\emph{ lm\_base}, u32\emph{ aspace}, u32\emph{ cycle}}{}
Configure location monitor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME location monitor resource.

\item[{\code{unsigned long long lm\_base}}] \leavevmode
Base address to monitor.

\item[{\code{u32 aspace}}] \leavevmode
VME address space to monitor.

\item[{\code{u32 cycle}}] \leavevmode
VME bus cycle type to monitor.

\end{description}

\textbf{Description}

Set the base address, address space and cycle type of accesses to be
monitored by the location monitor.

\textbf{Return}
\begin{description}
\item[{Zero on success, -EINVAL when provided with an invalid location}] \leavevmode
monitor resource or function is not supported. Hardware specific
errors may also be returned.

\end{description}
\index{vme\_lm\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_lm_get}\pysiglinewithargsret{int \bfcode{vme\_lm\_get}}{struct vme\_resource *\emph{ resource}, unsigned long long *\emph{ lm\_base}, u32 *\emph{ aspace}, u32 *\emph{ cycle}}{}
Retrieve location monitor settings

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME location monitor resource.

\item[{\code{unsigned long long * lm\_base}}] \leavevmode
Pointer used to output the base address monitored.

\item[{\code{u32 * aspace}}] \leavevmode
Pointer used to output the address space monitored.

\item[{\code{u32 * cycle}}] \leavevmode
Pointer used to output the VME bus cycle type monitored.

\end{description}

\textbf{Description}

Retrieve the base address, address space and cycle type of accesses to
be monitored by the location monitor.

\textbf{Return}
\begin{description}
\item[{Zero on success, -EINVAL when provided with an invalid location}] \leavevmode
monitor resource or function is not supported. Hardware specific
errors may also be returned.

\end{description}
\index{vme\_lm\_attach (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_lm_attach}\pysiglinewithargsret{int \bfcode{vme\_lm\_attach}}{struct vme\_resource *\emph{ resource}, int\emph{ monitor}, void (*callback) (void\emph{ *}, void *\emph{ data}}{}
Provide callback for location monitor address

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME location monitor resource.

\item[{\code{int monitor}}] \leavevmode
Offset to which callback should be attached.

\item[{\code{void (*)(void *) callback}}] \leavevmode
Pointer to callback function called when triggered.

\item[{\code{void * data}}] \leavevmode
Generic pointer that will be passed to the callback function.

\end{description}

\textbf{Description}

Attach a callback to the specificed offset into the location monitors
monitored addresses. A generic pointer is provided to allow data to be
passed to the callback when called.

\textbf{Return}
\begin{description}
\item[{Zero on success, -EINVAL when provided with an invalid location}] \leavevmode
monitor resource or function is not supported. Hardware specific
errors may also be returned.

\end{description}
\index{vme\_lm\_detach (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_lm_detach}\pysiglinewithargsret{int \bfcode{vme\_lm\_detach}}{struct vme\_resource *\emph{ resource}, int\emph{ monitor}}{}
Remove callback for location monitor address

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME location monitor resource.

\item[{\code{int monitor}}] \leavevmode
Offset to which callback should be removed.

\end{description}

\textbf{Description}

Remove the callback associated with the specificed offset into the
location monitors monitored addresses.

\textbf{Return}
\begin{description}
\item[{Zero on success, -EINVAL when provided with an invalid location}] \leavevmode
monitor resource or function is not supported. Hardware specific
errors may also be returned.

\end{description}
\index{vme\_lm\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_lm_free}\pysiglinewithargsret{void \bfcode{vme\_lm\_free}}{struct vme\_resource *\emph{ resource}}{}
Free allocated VME location monitor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_resource * resource}}] \leavevmode
Pointer to VME location monitor resource.

\end{description}

\textbf{Description}

Free allocation of a VME location monitor.
\begin{description}
\item[{WARNING: This function currently expects that any callbacks that have}] \leavevmode
been attached to the location monitor have been removed.

\end{description}

\textbf{Return}
\begin{description}
\item[{Zero on success, -EINVAL when provided with an invalid location}] \leavevmode
monitor resource.

\end{description}
\index{vme\_slot\_num (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_slot_num}\pysiglinewithargsret{int \bfcode{vme\_slot\_num}}{struct {\hyperref[driver\string-api/vme:c.vme_dev]{\emph{vme\_dev}}} *\emph{ vdev}}{}
Retrieve slot ID

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_dev * vdev}}] \leavevmode
Pointer to VME device struct vme\_dev assigned to driver instance.

\end{description}

\textbf{Description}

Retrieve the slot ID associated with the provided VME device.

\textbf{Return}
\begin{description}
\item[{The slot ID on success, -EINVAL if VME bridge cannot be determined}] \leavevmode
or the function is not supported. Hardware specific errors may also
be returned.

\end{description}
\index{vme\_bus\_num (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_bus_num}\pysiglinewithargsret{int \bfcode{vme\_bus\_num}}{struct {\hyperref[driver\string-api/vme:c.vme_dev]{\emph{vme\_dev}}} *\emph{ vdev}}{}
Retrieve bus number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_dev * vdev}}] \leavevmode
Pointer to VME device struct vme\_dev assigned to driver instance.

\end{description}

\textbf{Description}

Retrieve the bus enumeration associated with the provided VME device.

\textbf{Return}
\begin{description}
\item[{The bus number on success, -EINVAL if VME bridge cannot be}] \leavevmode
determined.

\end{description}
\index{vme\_register\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_register_driver}\pysiglinewithargsret{int \bfcode{vme\_register\_driver}}{struct {\hyperref[driver\string-api/vme:c.vme_driver]{\emph{vme\_driver}}} *\emph{ drv}, unsigned int\emph{ ndevs}}{}
Register a VME driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_driver * drv}}] \leavevmode
Pointer to VME driver structure to register.

\item[{\code{unsigned int ndevs}}] \leavevmode
Maximum number of devices to allow to be enumerated.

\end{description}

\textbf{Description}

Register a VME device driver with the VME subsystem.

\textbf{Return}

Zero on success, error value on registration failure.
\index{vme\_unregister\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/vme:c.vme_unregister_driver}\pysiglinewithargsret{void \bfcode{vme\_unregister\_driver}}{struct {\hyperref[driver\string-api/vme:c.vme_driver]{\emph{vme\_driver}}} *\emph{ drv}}{}
Unregister a VME driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vme\_driver * drv}}] \leavevmode
Pointer to VME driver structure to unregister.

\end{description}

\textbf{Description}

Unregister a VME device driver from the VME subsystem.


\chapter{Linux 802.11 Driver Developer's Guide}
\label{driver-api/80211/index::doc}\label{driver-api/80211/index:linux-802-11-driver-developer-s-guide}

\section{Introduction}
\label{driver-api/80211/introduction:introduction}\label{driver-api/80211/introduction::doc}
Explaining wireless 802.11 networking in the Linux kernel

Copyright 2007-2009 Johannes Berg

These books attempt to give a description of the various subsystems
that play a role in 802.11 wireless networking in Linux. Since these
books are for kernel developers they attempts to document the
structures and functions used in the kernel as well as giving a
higher-level overview.

The reader is expected to be familiar with the 802.11 standard as
published by the IEEE in 802.11-2007 (or possibly later versions).
References to this standard will be given as ``802.11-2007 8.1.5''.


\section{cfg80211 subsystem}
\label{driver-api/80211/cfg80211::doc}\label{driver-api/80211/cfg80211:cfg80211-subsystem}
cfg80211 is the configuration API for 802.11 devices in Linux. It bridges
userspace and drivers, and offers some utility functionality associated
with 802.11. cfg80211 must, directly or indirectly via mac80211, be used
by all modern wireless drivers in Linux, so that they offer a consistent
API through nl80211. For backward compatibility, cfg80211 also offers
wireless extensions to userspace, but hides them from drivers completely.

Additionally, cfg80211 contains code to help enforce regulatory spectrum
use restrictions.


\subsection{Device registration}
\label{driver-api/80211/cfg80211:device-registration}
In order for a driver to use cfg80211, it must register the hardware device
with cfg80211. This happens through a number of hardware capability structs
described below.

The fundamental structure for each device is the `wiphy', of which each
instance describes a physical wireless device connected to the system. Each
such wiphy can have zero, one, or many virtual interfaces associated with
it, which need to be identified as such by pointing the network interface's
\textbf{ieee80211\_ptr} pointer to a {\hyperref[driver\string-api/80211/cfg80211:c.wireless_dev]{\emph{\code{struct wireless\_dev}}}} which further describes
the wireless part of the interface, normally this struct is embedded in the
network interface's private data area. Drivers can optionally allow creating
or destroying virtual interfaces on the fly, but without at least one or the
ability to create some the wireless device isn't useful.

Each wiphy structure contains device capability information, and also has
a pointer to the various operations the driver offers. The definitions and
structures here describe these capabilities in detail.
\index{ieee80211\_channel\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_channel_flags}\pysigline{enum \bfcode{ieee80211\_channel\_flags}}
channel flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{IEEE80211\_CHAN\_DISABLED}}] \leavevmode
This channel is disabled.

\item[{\code{IEEE80211\_CHAN\_NO\_IR}}] \leavevmode
do not initiate radiation, this includes
sending probe requests or beaconing.

\item[{\code{IEEE80211\_CHAN\_RADAR}}] \leavevmode
Radar detection is required on this channel.

\item[{\code{IEEE80211\_CHAN\_NO\_HT40PLUS}}] \leavevmode
extension channel above this channel
is not permitted.

\item[{\code{IEEE80211\_CHAN\_NO\_HT40MINUS}}] \leavevmode
extension channel below this channel
is not permitted.

\item[{\code{IEEE80211\_CHAN\_NO\_OFDM}}] \leavevmode
OFDM is not allowed on this channel.

\item[{\code{IEEE80211\_CHAN\_NO\_80MHZ}}] \leavevmode
If the driver supports 80 MHz on the band,
this flag indicates that an 80 MHz channel cannot use this
channel as the control or any of the secondary channels.
This may be due to the driver or due to regulatory bandwidth
restrictions.

\item[{\code{IEEE80211\_CHAN\_NO\_160MHZ}}] \leavevmode
If the driver supports 160 MHz on the band,
this flag indicates that an 160 MHz channel cannot use this
channel as the control or any of the secondary channels.
This may be due to the driver or due to regulatory bandwidth
restrictions.

\item[{\code{IEEE80211\_CHAN\_INDOOR\_ONLY}}] \leavevmode
see \code{NL80211\_FREQUENCY\_ATTR\_INDOOR\_ONLY}

\item[{\code{IEEE80211\_CHAN\_IR\_CONCURRENT}}] \leavevmode
see \code{NL80211\_FREQUENCY\_ATTR\_IR\_CONCURRENT}

\item[{\code{IEEE80211\_CHAN\_NO\_20MHZ}}] \leavevmode
20 MHz bandwidth is not permitted
on this channel.

\item[{\code{IEEE80211\_CHAN\_NO\_10MHZ}}] \leavevmode
10 MHz bandwidth is not permitted
on this channel.

\end{description}

\textbf{Description}

Channel flags set by the regulatory control code.
\index{ieee80211\_channel (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_channel}\pysigline{struct \bfcode{ieee80211\_channel}}
channel definition

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}channel \PYGZob{}
  enum nl80211\PYGZus{}band band;
  u16 center\PYGZus{}freq;
  u16 hw\PYGZus{}value;
  u32 flags;
  int max\PYGZus{}antenna\PYGZus{}gain;
  int max\PYGZus{}power;
  int max\PYGZus{}reg\PYGZus{}power;
  bool beacon\PYGZus{}found;
  u32 orig\PYGZus{}flags;
  int orig\PYGZus{}mag, orig\PYGZus{}mpwr;
  enum nl80211\PYGZus{}dfs\PYGZus{}state dfs\PYGZus{}state;
  unsigned long dfs\PYGZus{}state\PYGZus{}entered;
  unsigned int dfs\PYGZus{}cac\PYGZus{}ms;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{band}}] \leavevmode
band this channel belongs to.

\item[{\code{center\_freq}}] \leavevmode
center frequency in MHz

\item[{\code{hw\_value}}] \leavevmode
hardware-specific value for the channel

\item[{\code{flags}}] \leavevmode
channel flags from {\hyperref[driver\string-api/80211/cfg80211:c.ieee80211_channel_flags]{\emph{\code{enum ieee80211\_channel\_flags}}}}.

\item[{\code{max\_antenna\_gain}}] \leavevmode
maximum antenna gain in dBi

\item[{\code{max\_power}}] \leavevmode
maximum transmission power (in dBm)

\item[{\code{max\_reg\_power}}] \leavevmode
maximum regulatory transmission power (in dBm)

\item[{\code{beacon\_found}}] \leavevmode
helper to regulatory code to indicate when a beacon
has been found on this channel. Use \code{regulatory\_hint\_found\_beacon()}
to enable this, this is useful only on 5 GHz band.

\item[{\code{orig\_flags}}] \leavevmode
channel flags at registration time, used by regulatory
code to support devices with additional restrictions

\item[{\code{orig\_mag}}] \leavevmode
internal use

\item[{\code{orig\_mpwr}}] \leavevmode
internal use

\item[{\code{dfs\_state}}] \leavevmode
current state of this channel. Only relevant if radar is required
on this channel.

\item[{\code{dfs\_state\_entered}}] \leavevmode
timestamp (jiffies) when the dfs state was entered.

\item[{\code{dfs\_cac\_ms}}] \leavevmode
DFS CAC time in milliseconds, this is valid for DFS channels.

\end{description}

\textbf{Description}

This structure describes a single channel for use
with cfg80211.
\index{ieee80211\_rate\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_rate_flags}\pysigline{enum \bfcode{ieee80211\_rate\_flags}}
rate flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{IEEE80211\_RATE\_SHORT\_PREAMBLE}}] \leavevmode
Hardware can send with short
preamble on this bitrate; only relevant in 2.4GHz band and
with CCK rates.

\item[{\code{IEEE80211\_RATE\_MANDATORY\_A}}] \leavevmode
This bitrate is a mandatory rate
when used with 802.11a (on the 5 GHz band); filled by the
core code when registering the wiphy.

\item[{\code{IEEE80211\_RATE\_MANDATORY\_B}}] \leavevmode
This bitrate is a mandatory rate
when used with 802.11b (on the 2.4 GHz band); filled by the
core code when registering the wiphy.

\item[{\code{IEEE80211\_RATE\_MANDATORY\_G}}] \leavevmode
This bitrate is a mandatory rate
when used with 802.11g (on the 2.4 GHz band); filled by the
core code when registering the wiphy.

\item[{\code{IEEE80211\_RATE\_ERP\_G}}] \leavevmode
This is an ERP rate in 802.11g mode.

\item[{\code{IEEE80211\_RATE\_SUPPORTS\_5MHZ}}] \leavevmode
Rate can be used in 5 MHz mode

\item[{\code{IEEE80211\_RATE\_SUPPORTS\_10MHZ}}] \leavevmode
Rate can be used in 10 MHz mode

\end{description}

\textbf{Description}

Hardware/specification flags for rates. These are structured
in a way that allows using the same bitrate structure for
different bands/PHY modes.
\index{ieee80211\_rate (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_rate}\pysigline{struct \bfcode{ieee80211\_rate}}
bitrate definition

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}rate \PYGZob{}
  u32 flags;
  u16 bitrate;
  u16 hw\PYGZus{}value, hw\PYGZus{}value\PYGZus{}short;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{flags}}] \leavevmode
rate-specific flags

\item[{\code{bitrate}}] \leavevmode
bitrate in units of 100 Kbps

\item[{\code{hw\_value}}] \leavevmode
driver/hardware value for this rate

\item[{\code{hw\_value\_short}}] \leavevmode
driver/hardware value for this rate when
short preamble is used

\end{description}

\textbf{Description}

This structure describes a bitrate that an 802.11 PHY can
operate with. The two values \textbf{hw\_value} and \textbf{hw\_value\_short}
are only for driver use when pointers to this structure are
passed around.
\index{ieee80211\_sta\_ht\_cap (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_sta_ht_cap}\pysigline{struct \bfcode{ieee80211\_sta\_ht\_cap}}
STA's HT capabilities

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}sta\PYGZus{}ht\PYGZus{}cap \PYGZob{}
  u16 cap;
  bool ht\PYGZus{}supported;
  u8 ampdu\PYGZus{}factor;
  u8 ampdu\PYGZus{}density;
  struct ieee80211\PYGZus{}mcs\PYGZus{}info mcs;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{cap}}] \leavevmode
HT capabilities map as described in 802.11n spec

\item[{\code{ht\_supported}}] \leavevmode
is HT supported by the STA

\item[{\code{ampdu\_factor}}] \leavevmode
Maximum A-MPDU length factor

\item[{\code{ampdu\_density}}] \leavevmode
Minimum A-MPDU spacing

\item[{\code{mcs}}] \leavevmode
Supported MCS rates

\end{description}

\textbf{Description}

This structure describes most essential parameters needed
to describe 802.11n HT capabilities for an STA.
\index{ieee80211\_supported\_band (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_supported_band}\pysigline{struct \bfcode{ieee80211\_supported\_band}}
frequency band definition

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}supported\PYGZus{}band \PYGZob{}
  struct ieee80211\PYGZus{}channel *channels;
  struct ieee80211\PYGZus{}rate *bitrates;
  enum nl80211\PYGZus{}band band;
  int n\PYGZus{}channels;
  int n\PYGZus{}bitrates;
  struct ieee80211\PYGZus{}sta\PYGZus{}ht\PYGZus{}cap ht\PYGZus{}cap;
  struct ieee80211\PYGZus{}sta\PYGZus{}vht\PYGZus{}cap vht\PYGZus{}cap;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{channels}}] \leavevmode
Array of channels the hardware can operate in
in this band.

\item[{\code{bitrates}}] \leavevmode
Array of bitrates the hardware can operate with
in this band. Must be sorted to give a valid ``supported
rates'' IE, i.e. CCK rates first, then OFDM.

\item[{\code{band}}] \leavevmode
the band this structure represents

\item[{\code{n\_channels}}] \leavevmode
Number of channels in \textbf{channels}

\item[{\code{n\_bitrates}}] \leavevmode
Number of bitrates in \textbf{bitrates}

\item[{\code{ht\_cap}}] \leavevmode
HT capabilities in this band

\item[{\code{vht\_cap}}] \leavevmode
VHT capabilities in this band

\end{description}

\textbf{Description}

This structure describes a frequency band a wiphy
is able to operate in.
\index{cfg80211\_signal\_type (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_signal_type}\pysigline{enum \bfcode{cfg80211\_signal\_type}}
signal type

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{CFG80211\_SIGNAL\_TYPE\_NONE}}] \leavevmode
no signal strength information available

\item[{\code{CFG80211\_SIGNAL\_TYPE\_MBM}}] \leavevmode
signal strength in mBm (100*dBm)

\item[{\code{CFG80211\_SIGNAL\_TYPE\_UNSPEC}}] \leavevmode
signal strength, increasing from 0 through 100

\end{description}
\index{wiphy\_params\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.wiphy_params_flags}\pysigline{enum \bfcode{wiphy\_params\_flags}}
set\_wiphy\_params bitfield values

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{WIPHY\_PARAM\_RETRY\_SHORT}}] \leavevmode
wiphy-\textgreater{}retry\_short has changed

\item[{\code{WIPHY\_PARAM\_RETRY\_LONG}}] \leavevmode
wiphy-\textgreater{}retry\_long has changed

\item[{\code{WIPHY\_PARAM\_FRAG\_THRESHOLD}}] \leavevmode
wiphy-\textgreater{}frag\_threshold has changed

\item[{\code{WIPHY\_PARAM\_RTS\_THRESHOLD}}] \leavevmode
wiphy-\textgreater{}rts\_threshold has changed

\item[{\code{WIPHY\_PARAM\_COVERAGE\_CLASS}}] \leavevmode
coverage class changed

\item[{\code{WIPHY\_PARAM\_DYN\_ACK}}] \leavevmode
dynack has been enabled

\end{description}
\index{wiphy\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.wiphy_flags}\pysigline{enum \bfcode{wiphy\_flags}}
wiphy capability flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{WIPHY\_FLAG\_NETNS\_OK}}] \leavevmode
if not set, do not allow changing the netns of this
wiphy at all

\item[{\code{WIPHY\_FLAG\_PS\_ON\_BY\_DEFAULT}}] \leavevmode
if set to true, powersave will be enabled
by default -- this flag will be set depending on the kernel's default
on {\hyperref[driver\string-api/80211/cfg80211:c.wiphy_new]{\emph{\code{wiphy\_new()}}}}, but can be changed by the driver if it has a good
reason to override the default

\item[{\code{WIPHY\_FLAG\_4ADDR\_AP}}] \leavevmode
supports 4addr mode even on AP (with a single station
on a VLAN interface)

\item[{\code{WIPHY\_FLAG\_4ADDR\_STATION}}] \leavevmode
supports 4addr mode even as a station

\item[{\code{WIPHY\_FLAG\_CONTROL\_PORT\_PROTOCOL}}] \leavevmode
This device supports setting the
control port protocol ethertype. The device also honours the
control\_port\_no\_encrypt flag.

\item[{\code{WIPHY\_FLAG\_IBSS\_RSN}}] \leavevmode
The device supports IBSS RSN.

\item[{\code{WIPHY\_FLAG\_MESH\_AUTH}}] \leavevmode
The device supports mesh authentication by routing
auth frames to userspace. See \textbf{NL80211\_MESH\_SETUP\_USERSPACE\_AUTH}.

\item[{\code{WIPHY\_FLAG\_SUPPORTS\_FW\_ROAM}}] \leavevmode
The device supports roaming feature in the
firmware.

\item[{\code{WIPHY\_FLAG\_AP\_UAPSD}}] \leavevmode
The device supports uapsd on AP.

\item[{\code{WIPHY\_FLAG\_SUPPORTS\_TDLS}}] \leavevmode
The device supports TDLS (802.11z) operation.

\item[{\code{WIPHY\_FLAG\_TDLS\_EXTERNAL\_SETUP}}] \leavevmode
The device does not handle TDLS (802.11z)
link setup/discovery operations internally. Setup, discovery and
teardown packets should be sent through the \textbf{NL80211\_CMD\_TDLS\_MGMT}
command. When this flag is not set, \textbf{NL80211\_CMD\_TDLS\_OPER} should be
used for asking the driver/firmware to perform a TDLS operation.

\item[{\code{WIPHY\_FLAG\_HAVE\_AP\_SME}}] \leavevmode
device integrates AP SME

\item[{\code{WIPHY\_FLAG\_REPORTS\_OBSS}}] \leavevmode
the device will report beacons from other BSSes
when there are virtual interfaces in AP mode by calling
\code{cfg80211\_report\_obss\_beacon()}.

\item[{\code{WIPHY\_FLAG\_AP\_PROBE\_RESP\_OFFLOAD}}] \leavevmode
When operating as an AP, the device
responds to probe-requests in hardware.

\item[{\code{WIPHY\_FLAG\_OFFCHAN\_TX}}] \leavevmode
Device supports direct off-channel TX.

\item[{\code{WIPHY\_FLAG\_HAS\_REMAIN\_ON\_CHANNEL}}] \leavevmode
Device supports remain-on-channel call.

\item[{\code{WIPHY\_FLAG\_SUPPORTS\_5\_10\_MHZ}}] \leavevmode
Device supports 5 MHz and 10 MHz channels.

\item[{\code{WIPHY\_FLAG\_HAS\_CHANNEL\_SWITCH}}] \leavevmode
Device supports channel switch in
beaconing mode (AP, IBSS, Mesh, ...).

\item[{\code{WIPHY\_FLAG\_HAS\_STATIC\_WEP}}] \leavevmode
The device supports static WEP key installation
before connection.

\end{description}
\index{wiphy (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.wiphy}\pysigline{struct \bfcode{wiphy}}
wireless hardware description

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct wiphy \PYGZob{}
  u8 perm\PYGZus{}addr[ETH\PYGZus{}ALEN];
  u8 addr\PYGZus{}mask[ETH\PYGZus{}ALEN];
  struct mac\PYGZus{}address *addresses;
  const struct ieee80211\PYGZus{}txrx\PYGZus{}stypes *mgmt\PYGZus{}stypes;
  const struct ieee80211\PYGZus{}iface\PYGZus{}combination *iface\PYGZus{}combinations;
  int n\PYGZus{}iface\PYGZus{}combinations;
  u16 software\PYGZus{}iftypes;
  u16 n\PYGZus{}addresses;
  u16 interface\PYGZus{}modes;
  u16 max\PYGZus{}acl\PYGZus{}mac\PYGZus{}addrs;
  u32 flags, regulatory\PYGZus{}flags, features;
  u8 ext\PYGZus{}features[DIV\PYGZus{}ROUND\PYGZus{}UP(NUM\PYGZus{}NL80211\PYGZus{}EXT\PYGZus{}FEATURES, 8)];
  u32 ap\PYGZus{}sme\PYGZus{}capa;
  enum cfg80211\PYGZus{}signal\PYGZus{}type signal\PYGZus{}type;
  int bss\PYGZus{}priv\PYGZus{}size;
  u8 max\PYGZus{}scan\PYGZus{}ssids;
  u8 max\PYGZus{}sched\PYGZus{}scan\PYGZus{}reqs;
  u8 max\PYGZus{}sched\PYGZus{}scan\PYGZus{}ssids;
  u8 max\PYGZus{}match\PYGZus{}sets;
  u16 max\PYGZus{}scan\PYGZus{}ie\PYGZus{}len;
  u16 max\PYGZus{}sched\PYGZus{}scan\PYGZus{}ie\PYGZus{}len;
  u32 max\PYGZus{}sched\PYGZus{}scan\PYGZus{}plans;
  u32 max\PYGZus{}sched\PYGZus{}scan\PYGZus{}plan\PYGZus{}interval;
  u32 max\PYGZus{}sched\PYGZus{}scan\PYGZus{}plan\PYGZus{}iterations;
  int n\PYGZus{}cipher\PYGZus{}suites;
  const u32 *cipher\PYGZus{}suites;
  u8 retry\PYGZus{}short;
  u8 retry\PYGZus{}long;
  u32 frag\PYGZus{}threshold;
  u32 rts\PYGZus{}threshold;
  u8 coverage\PYGZus{}class;
  char fw\PYGZus{}version[ETHTOOL\PYGZus{}FWVERS\PYGZus{}LEN];
  u32 hw\PYGZus{}version;
\PYGZsh{}ifdef CONFIG\PYGZus{}PM;
  const struct wiphy\PYGZus{}wowlan\PYGZus{}support *wowlan;
  struct cfg80211\PYGZus{}wowlan *wowlan\PYGZus{}config;
\PYGZsh{}endif;
  u16 max\PYGZus{}remain\PYGZus{}on\PYGZus{}channel\PYGZus{}duration;
  u8 max\PYGZus{}num\PYGZus{}pmkids;
  u32 available\PYGZus{}antennas\PYGZus{}tx;
  u32 available\PYGZus{}antennas\PYGZus{}rx;
  u32 probe\PYGZus{}resp\PYGZus{}offload;
  const u8 *extended\PYGZus{}capabilities, *extended\PYGZus{}capabilities\PYGZus{}mask;
  u8 extended\PYGZus{}capabilities\PYGZus{}len;
  const struct wiphy\PYGZus{}iftype\PYGZus{}ext\PYGZus{}capab *iftype\PYGZus{}ext\PYGZus{}capab;
  unsigned int num\PYGZus{}iftype\PYGZus{}ext\PYGZus{}capab;
  const void *privid;
  struct ieee80211\PYGZus{}supported\PYGZus{}band *bands[NUM\PYGZus{}NL80211\PYGZus{}BANDS];
  void (*reg\PYGZus{}notifier)(struct wiphy *wiphy, struct regulatory\PYGZus{}request *request);
  const struct ieee80211\PYGZus{}regdomain \PYGZus{}\PYGZus{}rcu *regd;
  struct device dev;
  bool registered;
  struct dentry *debugfsdir;
  const struct ieee80211\PYGZus{}ht\PYGZus{}cap *ht\PYGZus{}capa\PYGZus{}mod\PYGZus{}mask;
  const struct ieee80211\PYGZus{}vht\PYGZus{}cap *vht\PYGZus{}capa\PYGZus{}mod\PYGZus{}mask;
  struct list\PYGZus{}head wdev\PYGZus{}list;
  possible\PYGZus{}net\PYGZus{}t \PYGZus{}net;
\PYGZsh{}ifdef CONFIG\PYGZus{}CFG80211\PYGZus{}WEXT;
  const struct iw\PYGZus{}handler\PYGZus{}def *wext;
\PYGZsh{}endif;
  const struct wiphy\PYGZus{}coalesce\PYGZus{}support *coalesce;
  const struct wiphy\PYGZus{}vendor\PYGZus{}command *vendor\PYGZus{}commands;
  const struct nl80211\PYGZus{}vendor\PYGZus{}cmd\PYGZus{}info *vendor\PYGZus{}events;
  int n\PYGZus{}vendor\PYGZus{}commands, n\PYGZus{}vendor\PYGZus{}events;
  u16 max\PYGZus{}ap\PYGZus{}assoc\PYGZus{}sta;
  u8 max\PYGZus{}num\PYGZus{}csa\PYGZus{}counters;
  u8 max\PYGZus{}adj\PYGZus{}channel\PYGZus{}rssi\PYGZus{}comp;
  u32 bss\PYGZus{}select\PYGZus{}support;
  u64 cookie\PYGZus{}counter;
  u8 nan\PYGZus{}supported\PYGZus{}bands;
  char priv[0] ;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{perm\_addr}}] \leavevmode
permanent MAC address of this device

\item[{\code{addr\_mask}}] \leavevmode
If the device supports multiple MAC addresses by masking,
set this to a mask with variable bits set to 1, e.g. if the last
four bits are variable then set it to 00-00-00-00-00-0f. The actual
variable bits shall be determined by the interfaces added, with
interfaces not matching the mask being rejected to be brought up.

\item[{\code{addresses}}] \leavevmode
If the device has more than one address, set this pointer
to a list of addresses (6 bytes each). The first one will be used
by default for perm\_addr. In this case, the mask should be set to
all-zeroes. In this case it is assumed that the device can handle
the same number of arbitrary MAC addresses.

\item[{\code{mgmt\_stypes}}] \leavevmode
bitmasks of frame subtypes that can be subscribed to or
transmitted through nl80211, points to an array indexed by interface
type

\item[{\code{iface\_combinations}}] \leavevmode
Valid interface combinations array, should not
list single interface types.

\item[{\code{n\_iface\_combinations}}] \leavevmode
number of entries in \textbf{iface\_combinations} array.

\item[{\code{software\_iftypes}}] \leavevmode
bitmask of software interface types, these are not
subject to any restrictions since they are purely managed in SW.

\item[{\code{n\_addresses}}] \leavevmode
number of addresses in \textbf{addresses}.

\item[{\code{interface\_modes}}] \leavevmode
bitmask of interfaces types valid for this wiphy,
must be set by driver

\item[{\code{max\_acl\_mac\_addrs}}] \leavevmode
Maximum number of MAC addresses that the device
supports for ACL.

\item[{\code{flags}}] \leavevmode
wiphy flags, see {\hyperref[driver\string-api/80211/cfg80211:c.wiphy_flags]{\emph{\code{enum wiphy\_flags}}}}

\item[{\code{regulatory\_flags}}] \leavevmode
wiphy regulatory flags, see
\code{enum ieee80211\_regulatory\_flags}

\item[{\code{features}}] \leavevmode
features advertised to nl80211, see \code{enum nl80211\_feature\_flags}.

\item[{\code{ext\_features}}] \leavevmode
extended features advertised to nl80211, see
\code{enum nl80211\_ext\_feature\_index}.

\item[{\code{ap\_sme\_capa}}] \leavevmode
AP SME capabilities, flags from \code{enum nl80211\_ap\_sme\_features}.

\item[{\code{signal\_type}}] \leavevmode
signal type reported in {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_bss]{\emph{\code{struct cfg80211\_bss}}}}.

\item[{\code{bss\_priv\_size}}] \leavevmode
each BSS struct has private data allocated with it,
this variable determines its size

\item[{\code{max\_scan\_ssids}}] \leavevmode
maximum number of SSIDs the device can scan for in
any given scan

\item[{\code{max\_sched\_scan\_reqs}}] \leavevmode
maximum number of scheduled scan requests that
the device can run concurrently.

\item[{\code{max\_sched\_scan\_ssids}}] \leavevmode
maximum number of SSIDs the device can scan
for in any given scheduled scan

\item[{\code{max\_match\_sets}}] \leavevmode
maximum number of match sets the device can handle
when performing a scheduled scan, 0 if filtering is not
supported.

\item[{\code{max\_scan\_ie\_len}}] \leavevmode
maximum length of user-controlled IEs device can
add to probe request frames transmitted during a scan, must not
include fixed IEs like supported rates

\item[{\code{max\_sched\_scan\_ie\_len}}] \leavevmode
same as max\_scan\_ie\_len, but for scheduled
scans

\item[{\code{max\_sched\_scan\_plans}}] \leavevmode
maximum number of scan plans (scan interval and number
of iterations) for scheduled scan supported by the device.

\item[{\code{max\_sched\_scan\_plan\_interval}}] \leavevmode
maximum interval (in seconds) for a
single scan plan supported by the device.

\item[{\code{max\_sched\_scan\_plan\_iterations}}] \leavevmode
maximum number of iterations for a single
scan plan supported by the device.

\item[{\code{n\_cipher\_suites}}] \leavevmode
number of supported cipher suites

\item[{\code{cipher\_suites}}] \leavevmode
supported cipher suites

\item[{\code{retry\_short}}] \leavevmode
Retry limit for short frames (dot11ShortRetryLimit)

\item[{\code{retry\_long}}] \leavevmode
Retry limit for long frames (dot11LongRetryLimit)

\item[{\code{frag\_threshold}}] \leavevmode
Fragmentation threshold (dot11FragmentationThreshold);
-1 = fragmentation disabled, only odd values \textgreater{}= 256 used

\item[{\code{rts\_threshold}}] \leavevmode
RTS threshold (dot11RTSThreshold); -1 = RTS/CTS disabled

\item[{\code{coverage\_class}}] \leavevmode
current coverage class

\item[{\code{fw\_version}}] \leavevmode
firmware version for ethtool reporting

\item[{\code{hw\_version}}] \leavevmode
hardware version for ethtool reporting

\item[{\code{wowlan}}] \leavevmode
WoWLAN support information

\item[{\code{wowlan\_config}}] \leavevmode
current WoWLAN configuration; this should usually not be
used since access to it is necessarily racy, use the parameter passed
to the \code{suspend()} operation instead.

\item[{\code{max\_remain\_on\_channel\_duration}}] \leavevmode
Maximum time a remain-on-channel operation
may request, if implemented.

\item[{\code{max\_num\_pmkids}}] \leavevmode
maximum number of PMKIDs supported by device

\item[{\code{available\_antennas\_tx}}] \leavevmode
bitmap of antennas which are available to be
configured as TX antennas. Antenna configuration commands will be
rejected unless this or \textbf{available\_antennas\_rx} is set.

\item[{\code{available\_antennas\_rx}}] \leavevmode
bitmap of antennas which are available to be
configured as RX antennas. Antenna configuration commands will be
rejected unless this or \textbf{available\_antennas\_tx} is set.

\item[{\code{probe\_resp\_offload}}] \leavevmode
Bitmap of supported protocols for probe response offloading.
See \code{enum nl80211\_probe\_resp\_offload\_support\_attr}. Only valid
when the wiphy flag \textbf{WIPHY\_FLAG\_AP\_PROBE\_RESP\_OFFLOAD} is set.

\item[{\code{extended\_capabilities}}] \leavevmode
extended capabilities supported by the driver,
additional capabilities might be supported by userspace; these are
the 802.11 extended capabilities (``Extended Capabilities element'')
and are in the same format as in the information element. See
802.11-2012 8.4.2.29 for the defined fields. These are the default
extended capabilities to be used if the capabilities are not specified
for a specific interface type in iftype\_ext\_capab.

\item[{\code{extended\_capabilities\_mask}}] \leavevmode
mask of the valid values

\item[{\code{extended\_capabilities\_len}}] \leavevmode
length of the extended capabilities

\item[{\code{iftype\_ext\_capab}}] \leavevmode
array of extended capabilities per interface type

\item[{\code{num\_iftype\_ext\_capab}}] \leavevmode
number of interface types for which extended
capabilities are specified separately.

\item[{\code{privid}}] \leavevmode
a pointer that drivers can use to identify if an arbitrary
wiphy is theirs, e.g. in global notifiers

\item[{\code{bands}}] \leavevmode
information about bands/channels supported by this device

\item[{\code{reg\_notifier}}] \leavevmode
the driver's regulatory notification callback,
note that if your driver uses {\hyperref[driver\string-api/80211/cfg80211:c.wiphy_apply_custom_regulatory]{\emph{\code{wiphy\_apply\_custom\_regulatory()}}}}
the reg\_notifier's request can be passed as NULL

\item[{\code{regd}}] \leavevmode
the driver's regulatory domain, if one was requested via
the {\hyperref[driver\string-api/80211/cfg80211:c.regulatory_hint]{\emph{\code{regulatory\_hint()}}}} API. This can be used by the driver
on the \code{reg\_notifier()} if it chooses to ignore future
regulatory domain changes caused by other drivers.

\item[{\code{dev}}] \leavevmode
(virtual) struct device for this wiphy

\item[{\code{registered}}] \leavevmode
helps synchronize suspend/resume with wiphy unregister

\item[{\code{debugfsdir}}] \leavevmode
debugfs directory used for this wiphy, will be renamed
automatically on wiphy renames

\item[{\code{ht\_capa\_mod\_mask}}] \leavevmode
Specify what ht\_cap values can be over-ridden.
If null, then none can be over-ridden.

\item[{\code{vht\_capa\_mod\_mask}}] \leavevmode
Specify what VHT capabilities can be over-ridden.
If null, then none can be over-ridden.

\item[{\code{wdev\_list}}] \leavevmode
the list of associated (virtual) interfaces; this list must
not be modified by the driver, but can be read with RTNL/RCU protection.

\item[{\code{\_net}}] \leavevmode
the network namespace this wiphy currently lives in

\item[{\code{wext}}] \leavevmode
wireless extension handlers

\item[{\code{coalesce}}] \leavevmode
packet coalescing support information

\item[{\code{vendor\_commands}}] \leavevmode
array of vendor commands supported by the hardware

\item[{\code{vendor\_events}}] \leavevmode
array of vendor events supported by the hardware

\item[{\code{n\_vendor\_commands}}] \leavevmode
number of vendor commands

\item[{\code{n\_vendor\_events}}] \leavevmode
number of vendor events

\item[{\code{max\_ap\_assoc\_sta}}] \leavevmode
maximum number of associated stations supported in AP mode
(including P2P GO) or 0 to indicate no such limit is advertised. The
driver is allowed to advertise a theoretical limit that it can reach in
some cases, but may not always reach.

\item[{\code{max\_num\_csa\_counters}}] \leavevmode
Number of supported csa\_counters in beacons
and probe responses.  This value should be set if the driver
wishes to limit the number of csa counters. Default (0) means
infinite.

\item[{\code{max\_adj\_channel\_rssi\_comp}}] \leavevmode
max offset of between the channel on which the
frame was sent and the channel on which the frame was heard for which
the reported rssi is still valid. If a driver is able to compensate the
low rssi when a frame is heard on different channel, then it should set
this variable to the maximal offset for which it can compensate.
This value should be set in MHz.

\item[{\code{bss\_select\_support}}] \leavevmode
bitmask indicating the BSS selection criteria supported
by the driver in the .:c:func:\emph{connect()} callback. The bit position maps to the
attribute indices defined in \code{enum nl80211\_bss\_select\_attr}.

\item[{\code{cookie\_counter}}] \leavevmode
unique generic cookie counter, used to identify objects.

\item[{\code{nan\_supported\_bands}}] \leavevmode
bands supported by the device in NAN mode, a
bitmap of \code{enum nl80211\_band} values.  For instance, for
NL80211\_BAND\_2GHZ, bit 0 would be set
(i.e. BIT(NL80211\_BAND\_2GHZ)).

\item[{\code{priv}}] \leavevmode
driver private data (sized according to {\hyperref[driver\string-api/80211/cfg80211:c.wiphy_new]{\emph{\code{wiphy\_new()}}}} parameter)

\end{description}
\index{wireless\_dev (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.wireless_dev}\pysigline{struct \bfcode{wireless\_dev}}
wireless device state

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct wireless\PYGZus{}dev \PYGZob{}
  struct wiphy *wiphy;
  enum nl80211\PYGZus{}iftype iftype;
  struct list\PYGZus{}head list;
  struct net\PYGZus{}device *netdev;
  u32 identifier;
  struct list\PYGZus{}head mgmt\PYGZus{}registrations;
  spinlock\PYGZus{}t mgmt\PYGZus{}registrations\PYGZus{}lock;
  struct mutex mtx;
  bool use\PYGZus{}4addr, is\PYGZus{}running;
  u8 address[ETH\PYGZus{}ALEN] ;
  u8 ssid[IEEE80211\PYGZus{}MAX\PYGZus{}SSID\PYGZus{}LEN];
  u8 ssid\PYGZus{}len, mesh\PYGZus{}id\PYGZus{}len, mesh\PYGZus{}id\PYGZus{}up\PYGZus{}len;
  struct cfg80211\PYGZus{}conn *conn;
  struct cfg80211\PYGZus{}cached\PYGZus{}keys *connect\PYGZus{}keys;
  enum ieee80211\PYGZus{}bss\PYGZus{}type conn\PYGZus{}bss\PYGZus{}type;
  u32 conn\PYGZus{}owner\PYGZus{}nlportid;
  struct work\PYGZus{}struct disconnect\PYGZus{}wk;
  u8 disconnect\PYGZus{}bssid[ETH\PYGZus{}ALEN];
  struct list\PYGZus{}head event\PYGZus{}list;
  spinlock\PYGZus{}t event\PYGZus{}lock;
  struct cfg80211\PYGZus{}internal\PYGZus{}bss *current\PYGZus{}bss;
  struct cfg80211\PYGZus{}chan\PYGZus{}def preset\PYGZus{}chandef;
  struct cfg80211\PYGZus{}chan\PYGZus{}def chandef;
  bool ibss\PYGZus{}fixed;
  bool ibss\PYGZus{}dfs\PYGZus{}possible;
  bool ps;
  int ps\PYGZus{}timeout;
  int beacon\PYGZus{}interval;
  u32 ap\PYGZus{}unexpected\PYGZus{}nlportid;
  u32 owner\PYGZus{}nlportid;
  bool nl\PYGZus{}owner\PYGZus{}dead;
  bool cac\PYGZus{}started;
  unsigned long cac\PYGZus{}start\PYGZus{}time;
  unsigned int cac\PYGZus{}time\PYGZus{}ms;
\PYGZsh{}ifdef CONFIG\PYGZus{}CFG80211\PYGZus{}WEXT;
  struct \PYGZob{}
    struct cfg80211\PYGZus{}ibss\PYGZus{}params ibss;
    struct cfg80211\PYGZus{}connect\PYGZus{}params connect;
    struct cfg80211\PYGZus{}cached\PYGZus{}keys *keys;
    const u8 *ie;
    size\PYGZus{}t ie\PYGZus{}len;
    u8 bssid[ETH\PYGZus{}ALEN], prev\PYGZus{}bssid[ETH\PYGZus{}ALEN];
    u8 ssid[IEEE80211\PYGZus{}MAX\PYGZus{}SSID\PYGZus{}LEN];
    s8 default\PYGZus{}key, default\PYGZus{}mgmt\PYGZus{}key;
    bool prev\PYGZus{}bssid\PYGZus{}valid;
  \PYGZcb{} wext;
\PYGZsh{}endif;
  struct cfg80211\PYGZus{}cqm\PYGZus{}config *cqm\PYGZus{}config;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{wiphy}}] \leavevmode
pointer to hardware description

\item[{\code{iftype}}] \leavevmode
interface type

\item[{\code{list}}] \leavevmode
(private) Used to collect the interfaces

\item[{\code{netdev}}] \leavevmode
(private) Used to reference back to the netdev, may be \code{NULL}

\item[{\code{identifier}}] \leavevmode
(private) Identifier used in nl80211 to identify this
wireless device if it has no netdev

\item[{\code{mgmt\_registrations}}] \leavevmode
list of registrations for management frames

\item[{\code{mgmt\_registrations\_lock}}] \leavevmode
lock for the list

\item[{\code{mtx}}] \leavevmode
mutex used to lock data in this struct, may be used by drivers
and some API functions require it held

\item[{\code{use\_4addr}}] \leavevmode
indicates 4addr mode is used on this interface, must be
set by driver (if supported) on add\_interface BEFORE registering the
netdev and may otherwise be used by driver read-only, will be update
by cfg80211 on change\_interface

\item[{\code{is\_running}}] \leavevmode
true if this is a non-netdev device that has been started, e.g.
the P2P Device.

\item[{\code{address}}] \leavevmode
The address for this device, valid only if \textbf{netdev} is \code{NULL}

\item[{\code{ssid}}] \leavevmode
(private) Used by the internal configuration code

\item[{\code{ssid\_len}}] \leavevmode
(private) Used by the internal configuration code

\item[{\code{mesh\_id\_len}}] \leavevmode
(private) Used by the internal configuration code

\item[{\code{mesh\_id\_up\_len}}] \leavevmode
(private) Used by the internal configuration code

\item[{\code{conn}}] \leavevmode
(private) cfg80211 software SME connection state machine data

\item[{\code{connect\_keys}}] \leavevmode
(private) keys to set after connection is established

\item[{\code{conn\_bss\_type}}] \leavevmode
connecting/connected BSS type

\item[{\code{conn\_owner\_nlportid}}] \leavevmode
(private) connection owner socket port ID

\item[{\code{disconnect\_wk}}] \leavevmode
(private) auto-disconnect work

\item[{\code{disconnect\_bssid}}] \leavevmode
(private) the BSSID to use for auto-disconnect

\item[{\code{event\_list}}] \leavevmode
(private) list for internal event processing

\item[{\code{event\_lock}}] \leavevmode
(private) lock for event list

\item[{\code{current\_bss}}] \leavevmode
(private) Used by the internal configuration code

\item[{\code{preset\_chandef}}] \leavevmode
(private) Used by the internal configuration code to
track the channel to be used for AP later

\item[{\code{chandef}}] \leavevmode
(private) Used by the internal configuration code to track
the user-set channel definition.

\item[{\code{ibss\_fixed}}] \leavevmode
(private) IBSS is using fixed BSSID

\item[{\code{ibss\_dfs\_possible}}] \leavevmode
(private) IBSS may change to a DFS channel

\item[{\code{ps}}] \leavevmode
powersave mode is enabled

\item[{\code{ps\_timeout}}] \leavevmode
dynamic powersave timeout

\item[{\code{beacon\_interval}}] \leavevmode
beacon interval used on this device for transmitting
beacons, 0 when not valid

\item[{\code{ap\_unexpected\_nlportid}}] \leavevmode
(private) netlink port ID of application
registered for unexpected class 3 frames (AP mode)

\item[{\code{owner\_nlportid}}] \leavevmode
(private) owner socket port ID

\item[{\code{nl\_owner\_dead}}] \leavevmode
(private) owner socket went away

\item[{\code{cac\_started}}] \leavevmode
true if DFS channel availability check has been started

\item[{\code{cac\_start\_time}}] \leavevmode
timestamp (jiffies) when the dfs state was entered.

\item[{\code{cac\_time\_ms}}] \leavevmode
CAC time in ms

\item[{\code{wext}}] \leavevmode
(private) Used by the internal wireless extensions compat code

\item[{\code{cqm\_config}}] \leavevmode
(private) nl80211 RSSI monitor state

\end{description}

\textbf{Description}

For netdevs, this structure must be allocated by the driver
that uses the ieee80211\_ptr field in struct net\_device (this
is intentional so it can be allocated along with the netdev.)
It need not be registered then as netdev registration will
be intercepted by cfg80211 to see the new wireless device.

For non-netdev uses, it must also be allocated by the driver
in response to the cfg80211 callbacks that require it, as
there's no netdev registration in that case it may not be
allocated outside of callback operations that return it.
\index{wiphy\_new (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.wiphy_new}\pysiglinewithargsret{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} * \bfcode{wiphy\_new}}{const struct {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_ops]{\emph{cfg80211\_ops}}} *\emph{ ops}, int\emph{ sizeof\_priv}}{}
create a new wiphy for use with cfg80211

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct cfg80211\_ops * ops}}] \leavevmode
The configuration operations for this device

\item[{\code{int sizeof\_priv}}] \leavevmode
The size of the private area to allocate

\end{description}

\textbf{Description}

Create a new wiphy and associate the given operations with it.
\textbf{sizeof\_priv} bytes are allocated for private use.

\textbf{Return}

A pointer to the new wiphy. This pointer must be
assigned to each netdev's ieee80211\_ptr for proper operation.
\index{wiphy\_read\_of\_freq\_limits (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.wiphy_read_of_freq_limits}\pysiglinewithargsret{void \bfcode{wiphy\_read\_of\_freq\_limits}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}}{}
read frequency limits from device tree

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
the wireless device to get extra limits for

\end{description}

\textbf{Description}

Some devices may have extra limitations specified in DT. This may be useful
for chipsets that normally support more bands but are limited due to board
design (e.g. by antennas or external power amplifier).

This function reads info from DT and uses it to \emph{modify} channels (disable
unavailable ones). It's usually a \emph{bad} idea to use it in drivers with
shared channel data as DT limitations are device specific. You should make
sure to call it only if channels in wiphy are copied and can be modified
without affecting other devices.

As this function access device node it has to be called after set\_wiphy\_dev.
It also modifies channels so they have to be set first.
If using this helper, call it before {\hyperref[driver\string-api/80211/cfg80211:c.wiphy_register]{\emph{\code{wiphy\_register()}}}}.
\index{wiphy\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.wiphy_register}\pysiglinewithargsret{int \bfcode{wiphy\_register}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}}{}
register a wiphy with cfg80211

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
The wiphy to register.

\end{description}

\textbf{Return}

A non-negative wiphy index or a negative error code.
\index{wiphy\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.wiphy_unregister}\pysiglinewithargsret{void \bfcode{wiphy\_unregister}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}}{}
deregister a wiphy from cfg80211

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
The wiphy to unregister.

\end{description}

\textbf{Description}

After this call, no more requests can be made with this priv
pointer, but the call may sleep to wait for an outstanding
request that is being handled.
\index{wiphy\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.wiphy_free}\pysiglinewithargsret{void \bfcode{wiphy\_free}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}}{}
free wiphy

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
The wiphy to free

\end{description}
\index{wiphy\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.wiphy_name}\pysiglinewithargsret{const char * \bfcode{wiphy\_name}}{const struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}}{}
get wiphy name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct wiphy * wiphy}}] \leavevmode
The wiphy whose name to return

\end{description}

\textbf{Return}

The name of \textbf{wiphy}.
\index{wiphy\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.wiphy_dev}\pysiglinewithargsret{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} * \bfcode{wiphy\_dev}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}}{}
get wiphy dev pointer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
The wiphy whose device struct to look up

\end{description}

\textbf{Return}

The dev of \textbf{wiphy}.
\index{wiphy\_priv (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.wiphy_priv}\pysiglinewithargsret{void * \bfcode{wiphy\_priv}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}}{}
return priv from wiphy

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
the wiphy whose priv pointer to return

\end{description}

\textbf{Return}

The priv of \textbf{wiphy}.
\index{priv\_to\_wiphy (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.priv_to_wiphy}\pysiglinewithargsret{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} * \bfcode{priv\_to\_wiphy}}{void *\emph{ priv}}{}
return the wiphy containing the priv

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * priv}}] \leavevmode
a pointer previously returned by wiphy\_priv

\end{description}

\textbf{Return}

The wiphy of \textbf{priv}.
\index{set\_wiphy\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.set_wiphy_dev}\pysiglinewithargsret{void \bfcode{set\_wiphy\_dev}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
set device pointer for wiphy

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
The wiphy whose device to bind

\item[{\code{struct device * dev}}] \leavevmode
The device to parent it to

\end{description}
\index{wdev\_priv (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.wdev_priv}\pysiglinewithargsret{void * \bfcode{wdev\_priv}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wireless_dev]{\emph{wireless\_dev}}} *\emph{ wdev}}{}
return wiphy priv from wireless\_dev

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wireless\_dev * wdev}}] \leavevmode
The wireless device whose wiphy's priv pointer to return

\end{description}

\textbf{Return}

The wiphy priv of \textbf{wdev}.
\index{ieee80211\_iface\_limit (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_iface_limit}\pysigline{struct \bfcode{ieee80211\_iface\_limit}}
limit on certain interface types

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}iface\PYGZus{}limit \PYGZob{}
  u16 max;
  u16 types;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{max}}] \leavevmode
maximum number of interfaces of these types

\item[{\code{types}}] \leavevmode
interface types (bits)

\end{description}
\index{ieee80211\_iface\_combination (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_iface_combination}\pysigline{struct \bfcode{ieee80211\_iface\_combination}}
possible interface combination

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}iface\PYGZus{}combination \PYGZob{}
  const struct ieee80211\PYGZus{}iface\PYGZus{}limit *limits;
  u32 num\PYGZus{}different\PYGZus{}channels;
  u16 max\PYGZus{}interfaces;
  u8 n\PYGZus{}limits;
  bool beacon\PYGZus{}int\PYGZus{}infra\PYGZus{}match;
  u8 radar\PYGZus{}detect\PYGZus{}widths;
  u8 radar\PYGZus{}detect\PYGZus{}regions;
  u32 beacon\PYGZus{}int\PYGZus{}min\PYGZus{}gcd;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{limits}}] \leavevmode
limits for the given interface types

\item[{\code{num\_different\_channels}}] \leavevmode
can use up to this many different channels

\item[{\code{max\_interfaces}}] \leavevmode
maximum number of interfaces in total allowed in this group

\item[{\code{n\_limits}}] \leavevmode
number of limitations

\item[{\code{beacon\_int\_infra\_match}}] \leavevmode
In this combination, the beacon intervals between infrastructure
and AP types must match. This is required only in special cases.

\item[{\code{radar\_detect\_widths}}] \leavevmode
bitmap of channel widths supported for radar detection

\item[{\code{radar\_detect\_regions}}] \leavevmode
bitmap of regions supported for radar detection

\item[{\code{beacon\_int\_min\_gcd}}] \leavevmode
This interface combination supports different beacon intervals.
\begin{description}
\item[{= 0}] \leavevmode
all beacon intervals for different interface must be same.

\item[{\textgreater{} 0}] \leavevmode
any beacon interval for the interface part of this combination AND
GCD of all beacon intervals from beaconing interfaces of this
combination must be greater or equal to this value.

\end{description}

\end{description}

\textbf{Description}

With this structure the driver can describe which interface
combinations it supports concurrently.

\textbf{Examples}
\begin{enumerate}
\item {} 
Allow \#STA \textless{}= 1, \#AP \textless{}= 1, matching BI, channels = 1, 2 total:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{ieee80211\PYGZus{}iface\PYGZus{}limit} \PYG{n}{limits1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}
        \PYG{p}{\PYGZob{}} \PYG{p}{.}\PYG{n}{max} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{.}\PYG{n}{types} \PYG{o}{=} \PYG{n}{BIT}\PYG{p}{(}\PYG{n}{NL80211\PYGZus{}IFTYPE\PYGZus{}STATION}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}} \PYG{p}{.}\PYG{n}{max} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{.}\PYG{n}{types} \PYG{o}{=} \PYG{n}{BIT}\PYG{p}{(}\PYG{n}{NL80211\PYGZus{}IFTYPE\PYGZus{}AP}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{struct} \PYG{n}{ieee80211\PYGZus{}iface\PYGZus{}combination} \PYG{n}{combination1} \PYG{o}{=} \PYG{p}{\PYGZob{}}
        \PYG{p}{.}\PYG{n}{limits} \PYG{o}{=} \PYG{n}{limits1}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{n\PYGZus{}limits} \PYG{o}{=} \PYG{n}{ARRAY\PYGZus{}SIZE}\PYG{p}{(}\PYG{n}{limits1}\PYG{p}{)}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{max\PYGZus{}interfaces} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{beacon\PYGZus{}int\PYGZus{}infra\PYGZus{}match} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

\item {} 
Allow \#\{AP, P2P-GO\} \textless{}= 8, channels = 1, 8 total:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{ieee80211\PYGZus{}iface\PYGZus{}limit} \PYG{n}{limits2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}
        \PYG{p}{\PYGZob{}} \PYG{p}{.}\PYG{n}{max} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{p}{.}\PYG{n}{types} \PYG{o}{=} \PYG{n}{BIT}\PYG{p}{(}\PYG{n}{NL80211\PYGZus{}IFTYPE\PYGZus{}AP}\PYG{p}{)} \PYG{o}{\textbar{}}
                             \PYG{n}{BIT}\PYG{p}{(}\PYG{n}{NL80211\PYGZus{}IFTYPE\PYGZus{}P2P\PYGZus{}GO}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{struct} \PYG{n}{ieee80211\PYGZus{}iface\PYGZus{}combination} \PYG{n}{combination2} \PYG{o}{=} \PYG{p}{\PYGZob{}}
        \PYG{p}{.}\PYG{n}{limits} \PYG{o}{=} \PYG{n}{limits2}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{n\PYGZus{}limits} \PYG{o}{=} \PYG{n}{ARRAY\PYGZus{}SIZE}\PYG{p}{(}\PYG{n}{limits2}\PYG{p}{)}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{max\PYGZus{}interfaces} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{num\PYGZus{}different\PYGZus{}channels} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

\item {} 
Allow \#STA \textless{}= 1, \#\{P2P-client,P2P-GO\} \textless{}= 3 on two channels, 4 total.

This allows for an infrastructure connection and three P2P connections.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{ieee80211\PYGZus{}iface\PYGZus{}limit} \PYG{n}{limits3}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}
        \PYG{p}{\PYGZob{}} \PYG{p}{.}\PYG{n}{max} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{.}\PYG{n}{types} \PYG{o}{=} \PYG{n}{BIT}\PYG{p}{(}\PYG{n}{NL80211\PYGZus{}IFTYPE\PYGZus{}STATION}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}} \PYG{p}{.}\PYG{n}{max} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{.}\PYG{n}{types} \PYG{o}{=} \PYG{n}{BIT}\PYG{p}{(}\PYG{n}{NL80211\PYGZus{}IFTYPE\PYGZus{}P2P\PYGZus{}GO}\PYG{p}{)} \PYG{o}{\textbar{}}
                             \PYG{n}{BIT}\PYG{p}{(}\PYG{n}{NL80211\PYGZus{}IFTYPE\PYGZus{}P2P\PYGZus{}CLIENT}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{struct} \PYG{n}{ieee80211\PYGZus{}iface\PYGZus{}combination} \PYG{n}{combination3} \PYG{o}{=} \PYG{p}{\PYGZob{}}
        \PYG{p}{.}\PYG{n}{limits} \PYG{o}{=} \PYG{n}{limits3}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{n\PYGZus{}limits} \PYG{o}{=} \PYG{n}{ARRAY\PYGZus{}SIZE}\PYG{p}{(}\PYG{n}{limits3}\PYG{p}{)}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{max\PYGZus{}interfaces} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{num\PYGZus{}different\PYGZus{}channels} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

\end{enumerate}
\index{cfg80211\_check\_combinations (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_check_combinations}\pysiglinewithargsret{int \bfcode{cfg80211\_check\_combinations}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}, struct iface\_combination\_params *\emph{ params}}{}
check interface combinations

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
the wiphy

\item[{\code{struct iface\_combination\_params * params}}] \leavevmode
the interface combinations parameter

\end{description}

\textbf{Description}

This function can be called by the driver to check whether a
combination of interfaces and their types are allowed according to
the interface combinations.


\subsection{Actions and configuration}
\label{driver-api/80211/cfg80211:actions-and-configuration}
Each wireless device and each virtual interface offer a set of configuration
operations and other actions that are invoked by userspace. Each of these
actions is described in the operations structure, and the parameters these
operations use are described separately.

Additionally, some operations are asynchronous and expect to get status
information via some functions that drivers need to call.

Scanning and BSS list handling with its associated functionality is described
in a separate chapter.
\index{cfg80211\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_ops}\pysigline{struct \bfcode{cfg80211\_ops}}
backend description for wireless configuration

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cfg80211\PYGZus{}ops \PYGZob{}
  int (*suspend)(struct wiphy *wiphy, struct cfg80211\PYGZus{}wowlan *wow);
  int (*resume)(struct wiphy *wiphy);
  void (*set\PYGZus{}wakeup)(struct wiphy *wiphy, bool enabled);
  struct wireless\PYGZus{}dev * (*add\PYGZus{}virtual\PYGZus{}intf)(struct wiphy *wiphy,const char *name,unsigned char name\PYGZus{}assign\PYGZus{}type,enum nl80211\PYGZus{}iftype type, struct vif\PYGZus{}params *params);
  int (*del\PYGZus{}virtual\PYGZus{}intf)(struct wiphy *wiphy, struct wireless\PYGZus{}dev *wdev);
  int (*change\PYGZus{}virtual\PYGZus{}intf)(struct wiphy *wiphy,struct net\PYGZus{}device *dev,enum nl80211\PYGZus{}iftype type, struct vif\PYGZus{}params *params);
  int (*add\PYGZus{}key)(struct wiphy *wiphy, struct net\PYGZus{}device *netdev,u8 key\PYGZus{}index, bool pairwise, const u8 *mac\PYGZus{}addr, struct key\PYGZus{}params *params);
  int (*get\PYGZus{}key)(struct wiphy *wiphy, struct net\PYGZus{}device *netdev,u8 key\PYGZus{}index, bool pairwise, const u8 *mac\PYGZus{}addr,void *cookie, void (*callback)(void *cookie, struct key\PYGZus{}params*));
  int (*del\PYGZus{}key)(struct wiphy *wiphy, struct net\PYGZus{}device *netdev, u8 key\PYGZus{}index, bool pairwise, const u8 *mac\PYGZus{}addr);
  int (*set\PYGZus{}default\PYGZus{}key)(struct wiphy *wiphy,struct net\PYGZus{}device *netdev, u8 key\PYGZus{}index, bool unicast, bool multicast);
  int (*set\PYGZus{}default\PYGZus{}mgmt\PYGZus{}key)(struct wiphy *wiphy,struct net\PYGZus{}device *netdev, u8 key\PYGZus{}index);
  int (*start\PYGZus{}ap)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, struct cfg80211\PYGZus{}ap\PYGZus{}settings *settings);
  int (*change\PYGZus{}beacon)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, struct cfg80211\PYGZus{}beacon\PYGZus{}data *info);
  int (*stop\PYGZus{}ap)(struct wiphy *wiphy, struct net\PYGZus{}device *dev);
  int (*add\PYGZus{}station)(struct wiphy *wiphy, struct net\PYGZus{}device *dev,const u8 *mac, struct station\PYGZus{}parameters *params);
  int (*del\PYGZus{}station)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, struct station\PYGZus{}del\PYGZus{}parameters *params);
  int (*change\PYGZus{}station)(struct wiphy *wiphy, struct net\PYGZus{}device *dev,const u8 *mac, struct station\PYGZus{}parameters *params);
  int (*get\PYGZus{}station)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, const u8 *mac, struct station\PYGZus{}info *sinfo);
  int (*dump\PYGZus{}station)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, int idx, u8 *mac, struct station\PYGZus{}info *sinfo);
  int (*add\PYGZus{}mpath)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, const u8 *dst, const u8 *next\PYGZus{}hop);
  int (*del\PYGZus{}mpath)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, const u8 *dst);
  int (*change\PYGZus{}mpath)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, const u8 *dst, const u8 *next\PYGZus{}hop);
  int (*get\PYGZus{}mpath)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, u8 *dst, u8 *next\PYGZus{}hop, struct mpath\PYGZus{}info *pinfo);
  int (*dump\PYGZus{}mpath)(struct wiphy *wiphy, struct net\PYGZus{}device *dev,int idx, u8 *dst, u8 *next\PYGZus{}hop, struct mpath\PYGZus{}info *pinfo);
  int (*get\PYGZus{}mpp)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, u8 *dst, u8 *mpp, struct mpath\PYGZus{}info *pinfo);
  int (*dump\PYGZus{}mpp)(struct wiphy *wiphy, struct net\PYGZus{}device *dev,int idx, u8 *dst, u8 *mpp, struct mpath\PYGZus{}info *pinfo);
  int (*get\PYGZus{}mesh\PYGZus{}config)(struct wiphy *wiphy,struct net\PYGZus{}device *dev, struct mesh\PYGZus{}config *conf);
  int (*update\PYGZus{}mesh\PYGZus{}config)(struct wiphy *wiphy,struct net\PYGZus{}device *dev, u32 mask, const struct mesh\PYGZus{}config *nconf);
  int (*join\PYGZus{}mesh)(struct wiphy *wiphy, struct net\PYGZus{}device *dev,const struct mesh\PYGZus{}config *conf, const struct mesh\PYGZus{}setup *setup);
  int (*leave\PYGZus{}mesh)(struct wiphy *wiphy, struct net\PYGZus{}device *dev);
  int (*join\PYGZus{}ocb)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, struct ocb\PYGZus{}setup *setup);
  int (*leave\PYGZus{}ocb)(struct wiphy *wiphy, struct net\PYGZus{}device *dev);
  int (*change\PYGZus{}bss)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, struct bss\PYGZus{}parameters *params);
  int (*set\PYGZus{}txq\PYGZus{}params)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, struct ieee80211\PYGZus{}txq\PYGZus{}params *params);
  int (*libertas\PYGZus{}set\PYGZus{}mesh\PYGZus{}channel)(struct wiphy *wiphy,struct net\PYGZus{}device *dev, struct ieee80211\PYGZus{}channel *chan);
  int (*set\PYGZus{}monitor\PYGZus{}channel)(struct wiphy *wiphy, struct cfg80211\PYGZus{}chan\PYGZus{}def *chandef);
  int (*scan)(struct wiphy *wiphy, struct cfg80211\PYGZus{}scan\PYGZus{}request *request);
  void (*abort\PYGZus{}scan)(struct wiphy *wiphy, struct wireless\PYGZus{}dev *wdev);
  int (*auth)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, struct cfg80211\PYGZus{}auth\PYGZus{}request *req);
  int (*assoc)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, struct cfg80211\PYGZus{}assoc\PYGZus{}request *req);
  int (*deauth)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, struct cfg80211\PYGZus{}deauth\PYGZus{}request *req);
  int (*disassoc)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, struct cfg80211\PYGZus{}disassoc\PYGZus{}request *req);
  int (*connect)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, struct cfg80211\PYGZus{}connect\PYGZus{}params *sme);
  int (*update\PYGZus{}connect\PYGZus{}params)(struct wiphy *wiphy,struct net\PYGZus{}device *dev,struct cfg80211\PYGZus{}connect\PYGZus{}params *sme, u32 changed);
  int (*disconnect)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, u16 reason\PYGZus{}code);
  int (*join\PYGZus{}ibss)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, struct cfg80211\PYGZus{}ibss\PYGZus{}params *params);
  int (*leave\PYGZus{}ibss)(struct wiphy *wiphy, struct net\PYGZus{}device *dev);
  int (*set\PYGZus{}mcast\PYGZus{}rate)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, int rate[NUM\PYGZus{}NL80211\PYGZus{}BANDS]);
  int (*set\PYGZus{}wiphy\PYGZus{}params)(struct wiphy *wiphy, u32 changed);
  int (*set\PYGZus{}tx\PYGZus{}power)(struct wiphy *wiphy, struct wireless\PYGZus{}dev *wdev, enum nl80211\PYGZus{}tx\PYGZus{}power\PYGZus{}setting type, int mbm);
  int (*get\PYGZus{}tx\PYGZus{}power)(struct wiphy *wiphy, struct wireless\PYGZus{}dev *wdev, int *dbm);
  int (*set\PYGZus{}wds\PYGZus{}peer)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, const u8 *addr);
  void (*rfkill\PYGZus{}poll)(struct wiphy *wiphy);
\PYGZsh{}ifdef CONFIG\PYGZus{}NL80211\PYGZus{}TESTMODE;
  int (*testmode\PYGZus{}cmd)(struct wiphy *wiphy, struct wireless\PYGZus{}dev *wdev, void *data, int len);
  int (*testmode\PYGZus{}dump)(struct wiphy *wiphy, struct sk\PYGZus{}buff *skb,struct netlink\PYGZus{}callback *cb, void *data, int len);
\PYGZsh{}endif;
  int (*set\PYGZus{}bitrate\PYGZus{}mask)(struct wiphy *wiphy,struct net\PYGZus{}device *dev,const u8 *peer, const struct cfg80211\PYGZus{}bitrate\PYGZus{}mask *mask);
  int (*dump\PYGZus{}survey)(struct wiphy *wiphy, struct net\PYGZus{}device *netdev, int idx, struct survey\PYGZus{}info *info);
  int (*set\PYGZus{}pmksa)(struct wiphy *wiphy, struct net\PYGZus{}device *netdev, struct cfg80211\PYGZus{}pmksa *pmksa);
  int (*del\PYGZus{}pmksa)(struct wiphy *wiphy, struct net\PYGZus{}device *netdev, struct cfg80211\PYGZus{}pmksa *pmksa);
  int (*flush\PYGZus{}pmksa)(struct wiphy *wiphy, struct net\PYGZus{}device *netdev);
  int (*remain\PYGZus{}on\PYGZus{}channel)(struct wiphy *wiphy,struct wireless\PYGZus{}dev *wdev,struct ieee80211\PYGZus{}channel *chan,unsigned int duration, u64 *cookie);
  int (*cancel\PYGZus{}remain\PYGZus{}on\PYGZus{}channel)(struct wiphy *wiphy,struct wireless\PYGZus{}dev *wdev, u64 cookie);
  int (*mgmt\PYGZus{}tx)(struct wiphy *wiphy, struct wireless\PYGZus{}dev *wdev,struct cfg80211\PYGZus{}mgmt\PYGZus{}tx\PYGZus{}params *params, u64 *cookie);
  int (*mgmt\PYGZus{}tx\PYGZus{}cancel\PYGZus{}wait)(struct wiphy *wiphy,struct wireless\PYGZus{}dev *wdev, u64 cookie);
  int (*set\PYGZus{}power\PYGZus{}mgmt)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, bool enabled, int timeout);
  int (*set\PYGZus{}cqm\PYGZus{}rssi\PYGZus{}config)(struct wiphy *wiphy,struct net\PYGZus{}device *dev, s32 rssi\PYGZus{}thold, u32 rssi\PYGZus{}hyst);
  int (*set\PYGZus{}cqm\PYGZus{}rssi\PYGZus{}range\PYGZus{}config)(struct wiphy *wiphy,struct net\PYGZus{}device *dev, s32 rssi\PYGZus{}low, s32 rssi\PYGZus{}high);
  int (*set\PYGZus{}cqm\PYGZus{}txe\PYGZus{}config)(struct wiphy *wiphy,struct net\PYGZus{}device *dev, u32 rate, u32 pkts, u32 intvl);
  void (*mgmt\PYGZus{}frame\PYGZus{}register)(struct wiphy *wiphy,struct wireless\PYGZus{}dev *wdev, u16 frame\PYGZus{}type, bool reg);
  int (*set\PYGZus{}antenna)(struct wiphy *wiphy, u32 tx\PYGZus{}ant, u32 rx\PYGZus{}ant);
  int (*get\PYGZus{}antenna)(struct wiphy *wiphy, u32 *tx\PYGZus{}ant, u32 *rx\PYGZus{}ant);
  int (*sched\PYGZus{}scan\PYGZus{}start)(struct wiphy *wiphy,struct net\PYGZus{}device *dev, struct cfg80211\PYGZus{}sched\PYGZus{}scan\PYGZus{}request *request);
  int (*sched\PYGZus{}scan\PYGZus{}stop)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, u64 reqid);
  int (*set\PYGZus{}rekey\PYGZus{}data)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, struct cfg80211\PYGZus{}gtk\PYGZus{}rekey\PYGZus{}data *data);
  int (*tdls\PYGZus{}mgmt)(struct wiphy *wiphy, struct net\PYGZus{}device *dev,const u8 *peer, u8 action\PYGZus{}code,  u8 dialog\PYGZus{}token,u16 status\PYGZus{}code, u32 peer\PYGZus{}capability, bool initiator, const u8 *buf, size\PYGZus{}t len);
  int (*tdls\PYGZus{}oper)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, const u8 *peer, enum nl80211\PYGZus{}tdls\PYGZus{}operation oper);
  int (*probe\PYGZus{}client)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, const u8 *peer, u64 *cookie);
  int (*set\PYGZus{}noack\PYGZus{}map)(struct wiphy *wiphy,struct net\PYGZus{}device *dev, u16 noack\PYGZus{}map);
  int (*get\PYGZus{}channel)(struct wiphy *wiphy,struct wireless\PYGZus{}dev *wdev, struct cfg80211\PYGZus{}chan\PYGZus{}def *chandef);
  int (*start\PYGZus{}p2p\PYGZus{}device)(struct wiphy *wiphy, struct wireless\PYGZus{}dev *wdev);
  void (*stop\PYGZus{}p2p\PYGZus{}device)(struct wiphy *wiphy, struct wireless\PYGZus{}dev *wdev);
  int (*set\PYGZus{}mac\PYGZus{}acl)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, const struct cfg80211\PYGZus{}acl\PYGZus{}data *params);
  int (*start\PYGZus{}radar\PYGZus{}detection)(struct wiphy *wiphy,struct net\PYGZus{}device *dev,struct cfg80211\PYGZus{}chan\PYGZus{}def *chandef, u32 cac\PYGZus{}time\PYGZus{}ms);
  int (*update\PYGZus{}ft\PYGZus{}ies)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, struct cfg80211\PYGZus{}update\PYGZus{}ft\PYGZus{}ies\PYGZus{}params *ftie);
  int (*crit\PYGZus{}proto\PYGZus{}start)(struct wiphy *wiphy,struct wireless\PYGZus{}dev *wdev,enum nl80211\PYGZus{}crit\PYGZus{}proto\PYGZus{}id protocol, u16 duration);
  void (*crit\PYGZus{}proto\PYGZus{}stop)(struct wiphy *wiphy, struct wireless\PYGZus{}dev *wdev);
  int (*set\PYGZus{}coalesce)(struct wiphy *wiphy, struct cfg80211\PYGZus{}coalesce *coalesce);
  int (*channel\PYGZus{}switch)(struct wiphy *wiphy,struct net\PYGZus{}device *dev, struct cfg80211\PYGZus{}csa\PYGZus{}settings *params);
  int (*set\PYGZus{}qos\PYGZus{}map)(struct wiphy *wiphy,struct net\PYGZus{}device *dev, struct cfg80211\PYGZus{}qos\PYGZus{}map *qos\PYGZus{}map);
  int (*set\PYGZus{}ap\PYGZus{}chanwidth)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, struct cfg80211\PYGZus{}chan\PYGZus{}def *chandef);
  int (*add\PYGZus{}tx\PYGZus{}ts)(struct wiphy *wiphy, struct net\PYGZus{}device *dev,u8 tsid, const u8 *peer, u8 user\PYGZus{}prio, u16 admitted\PYGZus{}time);
  int (*del\PYGZus{}tx\PYGZus{}ts)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, u8 tsid, const u8 *peer);
  int (*tdls\PYGZus{}channel\PYGZus{}switch)(struct wiphy *wiphy,struct net\PYGZus{}device *dev,const u8 *addr, u8 oper\PYGZus{}class, struct cfg80211\PYGZus{}chan\PYGZus{}def *chandef);
  void (*tdls\PYGZus{}cancel\PYGZus{}channel\PYGZus{}switch)(struct wiphy *wiphy,struct net\PYGZus{}device *dev, const u8 *addr);
  int (*start\PYGZus{}nan)(struct wiphy *wiphy, struct wireless\PYGZus{}dev *wdev, struct cfg80211\PYGZus{}nan\PYGZus{}conf *conf);
  void (*stop\PYGZus{}nan)(struct wiphy *wiphy, struct wireless\PYGZus{}dev *wdev);
  int (*add\PYGZus{}nan\PYGZus{}func)(struct wiphy *wiphy, struct wireless\PYGZus{}dev *wdev, struct cfg80211\PYGZus{}nan\PYGZus{}func *nan\PYGZus{}func);
  void (*del\PYGZus{}nan\PYGZus{}func)(struct wiphy *wiphy, struct wireless\PYGZus{}dev *wdev, u64 cookie);
  int (*nan\PYGZus{}change\PYGZus{}conf)(struct wiphy *wiphy,struct wireless\PYGZus{}dev *wdev,struct cfg80211\PYGZus{}nan\PYGZus{}conf *conf, u32 changes);
  int (*set\PYGZus{}multicast\PYGZus{}to\PYGZus{}unicast)(struct wiphy *wiphy,struct net\PYGZus{}device *dev, const bool enabled);
  int (*set\PYGZus{}pmk)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, const struct cfg80211\PYGZus{}pmk\PYGZus{}conf *conf);
  int (*del\PYGZus{}pmk)(struct wiphy *wiphy, struct net\PYGZus{}device *dev, const u8 *aa);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{suspend}}] \leavevmode
wiphy device needs to be suspended. The variable \textbf{wow} will
be \code{NULL} or contain the enabled Wake-on-Wireless triggers that are
configured for the device.

\item[{\code{resume}}] \leavevmode
wiphy device needs to be resumed

\item[{\code{set\_wakeup}}] \leavevmode
Called when WoWLAN is enabled/disabled, use this callback
to call \code{device\_set\_wakeup\_enable()} to enable/disable wakeup from
the device.

\item[{\code{add\_virtual\_intf}}] \leavevmode
create a new virtual interface with the given name,
must set the struct wireless\_dev's iftype. Beware: You must create
the new netdev in the wiphy's network namespace! Returns the struct
wireless\_dev, or an ERR\_PTR. For P2P device wdevs, the driver must
also set the address member in the wdev.

\item[{\code{del\_virtual\_intf}}] \leavevmode
remove the virtual interface

\item[{\code{change\_virtual\_intf}}] \leavevmode
change type/configuration of virtual interface,
keep the struct wireless\_dev's iftype updated.

\item[{\code{add\_key}}] \leavevmode
add a key with the given parameters. \textbf{mac\_addr} will be \code{NULL}
when adding a group key.

\item[{\code{get\_key}}] \leavevmode
get information about the key with the given parameters.
\textbf{mac\_addr} will be \code{NULL} when requesting information for a group
key. All pointers given to the \textbf{callback} function need not be valid
after it returns. This function should return an error if it is
not possible to retrieve the key, -ENOENT if it doesn't exist.

\item[{\code{del\_key}}] \leavevmode
remove a key given the \textbf{mac\_addr} (\code{NULL} for a group key)
and \textbf{key\_index}, return -ENOENT if the key doesn't exist.

\item[{\code{set\_default\_key}}] \leavevmode
set the default key on an interface

\item[{\code{set\_default\_mgmt\_key}}] \leavevmode
set the default management frame key on an interface

\item[{\code{start\_ap}}] \leavevmode
Start acting in AP mode defined by the parameters.

\item[{\code{change\_beacon}}] \leavevmode
Change the beacon parameters for an access point mode
interface. This should reject the call when AP mode wasn't started.

\item[{\code{stop\_ap}}] \leavevmode
Stop being an AP, including stopping beaconing.

\item[{\code{add\_station}}] \leavevmode
Add a new station.

\item[{\code{del\_station}}] \leavevmode
Remove a station

\item[{\code{change\_station}}] \leavevmode
Modify a given station. Note that flags changes are not much
validated in cfg80211, in particular the auth/assoc/authorized flags
might come to the driver in invalid combinations -- make sure to check
them, also against the existing state! Drivers must call
\code{cfg80211\_check\_station\_change()} to validate the information.

\item[{\code{get\_station}}] \leavevmode
get station information for the station identified by \textbf{mac}

\item[{\code{dump\_station}}] \leavevmode
dump station callback -- resume dump at index \textbf{idx}

\item[{\code{add\_mpath}}] \leavevmode
add a fixed mesh path

\item[{\code{del\_mpath}}] \leavevmode
delete a given mesh path

\item[{\code{change\_mpath}}] \leavevmode
change a given mesh path

\item[{\code{get\_mpath}}] \leavevmode
get a mesh path for the given parameters

\item[{\code{dump\_mpath}}] \leavevmode
dump mesh path callback -- resume dump at index \textbf{idx}

\item[{\code{get\_mpp}}] \leavevmode
get a mesh proxy path for the given parameters

\item[{\code{dump\_mpp}}] \leavevmode
dump mesh proxy path callback -- resume dump at index \textbf{idx}

\item[{\code{get\_mesh\_config}}] \leavevmode
Get the current mesh configuration

\item[{\code{update\_mesh\_config}}] \leavevmode
Update mesh parameters on a running mesh.
The mask is a bitfield which tells us which parameters to
set, and which to leave alone.

\item[{\code{join\_mesh}}] \leavevmode
join the mesh network with the specified parameters
(invoked with the wireless\_dev mutex held)

\item[{\code{leave\_mesh}}] \leavevmode
leave the current mesh network
(invoked with the wireless\_dev mutex held)

\item[{\code{join\_ocb}}] \leavevmode
join the OCB network with the specified parameters
(invoked with the wireless\_dev mutex held)

\item[{\code{leave\_ocb}}] \leavevmode
leave the current OCB network
(invoked with the wireless\_dev mutex held)

\item[{\code{change\_bss}}] \leavevmode
Modify parameters for a given BSS.

\item[{\code{set\_txq\_params}}] \leavevmode
Set TX queue parameters

\item[{\code{libertas\_set\_mesh\_channel}}] \leavevmode
Only for backward compatibility for libertas,
as it doesn't implement join\_mesh and needs to set the channel to
join the mesh instead.

\item[{\code{set\_monitor\_channel}}] \leavevmode
Set the monitor mode channel for the device. If other
interfaces are active this callback should reject the configuration.
If no interfaces are active or the device is down, the channel should
be stored for when a monitor interface becomes active.

\item[{\code{scan}}] \leavevmode
Request to do a scan. If returning zero, the scan request is given
the driver, and will be valid until passed to {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_scan_done]{\emph{\code{cfg80211\_scan\_done()}}}}.
For scan results, call {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_inform_bss]{\emph{\code{cfg80211\_inform\_bss()}}}}; you can call this outside
the scan/scan\_done bracket too.

\item[{\code{abort\_scan}}] \leavevmode
Tell the driver to abort an ongoing scan. The driver shall
indicate the status of the scan through {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_scan_done]{\emph{\code{cfg80211\_scan\_done()}}}}.

\item[{\code{auth}}] \leavevmode
Request to authenticate with the specified peer
(invoked with the wireless\_dev mutex held)

\item[{\code{assoc}}] \leavevmode
Request to (re)associate with the specified peer
(invoked with the wireless\_dev mutex held)

\item[{\code{deauth}}] \leavevmode
Request to deauthenticate from the specified peer
(invoked with the wireless\_dev mutex held)

\item[{\code{disassoc}}] \leavevmode
Request to disassociate from the specified peer
(invoked with the wireless\_dev mutex held)

\item[{\code{connect}}] \leavevmode
Connect to the ESS with the specified parameters. When connected,
call {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_result]{\emph{\code{cfg80211\_connect\_result()}}}}/{\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_bss]{\emph{\code{cfg80211\_connect\_bss()}}}} with status code
\code{WLAN\_STATUS\_SUCCESS}. If the connection fails for some reason, call
{\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_result]{\emph{\code{cfg80211\_connect\_result()}}}}/{\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_bss]{\emph{\code{cfg80211\_connect\_bss()}}}} with the status code
from the AP or {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_timeout]{\emph{\code{cfg80211\_connect\_timeout()}}}} if no frame with status code
was received.
The driver is allowed to roam to other BSSes within the ESS when the
other BSS matches the connect parameters. When such roaming is initiated
by the driver, the driver is expected to verify that the target matches
the configured security parameters and to use Reassociation Request
frame instead of Association Request frame.
The connect function can also be used to request the driver to perform a
specific roam when connected to an ESS. In that case, the prev\_bssid
parameter is set to the BSSID of the currently associated BSS as an
indication of requesting reassociation.
In both the driver-initiated and new \code{connect()} call initiated roaming
cases, the result of roaming is indicated with a call to
{\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_roamed]{\emph{\code{cfg80211\_roamed()}}}}. (invoked with the wireless\_dev mutex held)

\item[{\code{update\_connect\_params}}] \leavevmode
Update the connect parameters while connected to a
BSS. The updated parameters can be used by driver/firmware for
subsequent BSS selection (roaming) decisions and to form the
Authentication/(Re)Association Request frames. This call does not
request an immediate disassociation or reassociation with the current
BSS, i.e., this impacts only subsequent (re)associations. The bits in
changed are defined in \code{enum cfg80211\_connect\_params\_changed}.
(invoked with the wireless\_dev mutex held)

\item[{\code{disconnect}}] \leavevmode
Disconnect from the BSS/ESS or stop connection attempts if
connection is in progress. Once done, call {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_disconnected]{\emph{\code{cfg80211\_disconnected()}}}} in
case connection was already established (invoked with the
wireless\_dev mutex held), otherwise call {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_timeout]{\emph{\code{cfg80211\_connect\_timeout()}}}}.

\item[{\code{join\_ibss}}] \leavevmode
Join the specified IBSS (or create if necessary). Once done, call
{\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_ibss_joined]{\emph{\code{cfg80211\_ibss\_joined()}}}}, also call that function when changing BSSID due
to a merge.
(invoked with the wireless\_dev mutex held)

\item[{\code{leave\_ibss}}] \leavevmode
Leave the IBSS.
(invoked with the wireless\_dev mutex held)

\item[{\code{set\_mcast\_rate}}] \leavevmode
Set the specified multicast rate (only if vif is in ADHOC or
MESH mode)

\item[{\code{set\_wiphy\_params}}] \leavevmode
Notify that wiphy parameters have changed;
\textbf{changed} bitfield (see {\hyperref[driver\string-api/80211/cfg80211:c.wiphy_params_flags]{\emph{\code{enum wiphy\_params\_flags}}}}) describes which values
have changed. The actual parameter values are available in
struct wiphy. If returning an error, no value should be changed.

\item[{\code{set\_tx\_power}}] \leavevmode
set the transmit power according to the parameters,
the power passed is in mBm, to get dBm use \code{MBM\_TO\_DBM()}. The
wdev may be \code{NULL} if power was set for the wiphy, and will
always be \code{NULL} unless the driver supports per-vif TX power
(as advertised by the nl80211 feature flag.)

\item[{\code{get\_tx\_power}}] \leavevmode
store the current TX power into the dbm variable;
return 0 if successful

\item[{\code{set\_wds\_peer}}] \leavevmode
set the WDS peer for a WDS interface

\item[{\code{rfkill\_poll}}] \leavevmode
polls the hw rfkill line, use cfg80211 reporting
functions to adjust rfkill hw state

\item[{\code{testmode\_cmd}}] \leavevmode
run a test mode command; \textbf{wdev} may be \code{NULL}

\item[{\code{testmode\_dump}}] \leavevmode
Implement a test mode dump. The cb-\textgreater{}args{[}2{]} and up may be
used by the function, but 0 and 1 must not be touched. Additionally,
return error codes other than -ENOBUFS and -ENOENT will terminate the
dump and return to userspace with an error, so be careful. If any data
was passed in from userspace then the data/len arguments will be present
and point to the data contained in \code{NL80211\_ATTR\_TESTDATA}.

\item[{\code{set\_bitrate\_mask}}] \leavevmode
set the bitrate mask configuration

\item[{\code{dump\_survey}}] \leavevmode
get site survey information.

\item[{\code{set\_pmksa}}] \leavevmode
Cache a PMKID for a BSSID. This is mostly useful for fullmac
devices running firmwares capable of generating the (re) association
RSN IE. It allows for faster roaming between WPA2 BSSIDs.

\item[{\code{del\_pmksa}}] \leavevmode
Delete a cached PMKID.

\item[{\code{flush\_pmksa}}] \leavevmode
Flush all cached PMKIDs.

\item[{\code{remain\_on\_channel}}] \leavevmode
Request the driver to remain awake on the specified
channel for the specified duration to complete an off-channel
operation (e.g., public action frame exchange). When the driver is
ready on the requested channel, it must indicate this with an event
notification by calling {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_ready_on_channel]{\emph{\code{cfg80211\_ready\_on\_channel()}}}}.

\item[{\code{cancel\_remain\_on\_channel}}] \leavevmode
Cancel an on-going remain-on-channel operation.
This allows the operation to be terminated prior to timeout based on
the duration value.

\item[{\code{mgmt\_tx}}] \leavevmode
Transmit a management frame.

\item[{\code{mgmt\_tx\_cancel\_wait}}] \leavevmode
Cancel the wait time from transmitting a management
frame on another channel

\item[{\code{set\_power\_mgmt}}] \leavevmode
Configure WLAN power management. A timeout value of -1
allows the driver to adjust the dynamic ps timeout value.

\item[{\code{set\_cqm\_rssi\_config}}] \leavevmode
Configure connection quality monitor RSSI threshold.
After configuration, the driver should (soon) send an event indicating
the current level is above/below the configured threshold; this may
need some care when the configuration is changed (without first being
disabled.)

\item[{\code{set\_cqm\_rssi\_range\_config}}] \leavevmode
Configure two RSSI thresholds in the
connection quality monitor.  An event is to be sent only when the
signal level is found to be outside the two values.  The driver should
set \code{NL80211\_EXT\_FEATURE\_CQM\_RSSI\_LIST} if this method is implemented.
If it is provided then there's no point providing \textbf{set\_cqm\_rssi\_config}.

\item[{\code{set\_cqm\_txe\_config}}] \leavevmode
Configure connection quality monitor TX error
thresholds.

\item[{\code{mgmt\_frame\_register}}] \leavevmode
Notify driver that a management frame type was
registered. The callback is allowed to sleep.

\item[{\code{set\_antenna}}] \leavevmode
Set antenna configuration (tx\_ant, rx\_ant) on the device.
Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may
reject TX/RX mask combinations they cannot support by returning -EINVAL
(also see nl80211.h \textbf{NL80211\_ATTR\_WIPHY\_ANTENNA\_TX}).

\item[{\code{get\_antenna}}] \leavevmode
Get current antenna configuration from device (tx\_ant, rx\_ant).

\item[{\code{sched\_scan\_start}}] \leavevmode
Tell the driver to start a scheduled scan.

\item[{\code{sched\_scan\_stop}}] \leavevmode
Tell the driver to stop an ongoing scheduled scan with
given request id. This call must stop the scheduled scan and be ready
for starting a new one before it returns, i.e. \textbf{sched\_scan\_start} may be
called immediately after that again and should not fail in that case.
The driver should not call \code{cfg80211\_sched\_scan\_stopped()} for a requested
stop (when this method returns 0).

\item[{\code{set\_rekey\_data}}] \leavevmode
give the data necessary for GTK rekeying to the driver

\item[{\code{tdls\_mgmt}}] \leavevmode
Transmit a TDLS management frame.

\item[{\code{tdls\_oper}}] \leavevmode
Perform a high-level TDLS operation (e.g. TDLS link setup).

\item[{\code{probe\_client}}] \leavevmode
probe an associated client, must return a cookie that it
later passes to \code{cfg80211\_probe\_status()}.

\item[{\code{set\_noack\_map}}] \leavevmode
Set the NoAck Map for the TIDs.

\item[{\code{get\_channel}}] \leavevmode
Get the current operating channel for the virtual interface.
For monitor interfaces, it should return \code{NULL} unless there's a single
current monitoring channel.

\item[{\code{start\_p2p\_device}}] \leavevmode
Start the given P2P device.

\item[{\code{stop\_p2p\_device}}] \leavevmode
Stop the given P2P device.

\item[{\code{set\_mac\_acl}}] \leavevmode
Sets MAC address control list in AP and P2P GO mode.
Parameters include ACL policy, an array of MAC address of stations
and the number of MAC addresses. If there is already a list in driver
this new list replaces the existing one. Driver has to clear its ACL
when number of MAC addresses entries is passed as 0. Drivers which
advertise the support for MAC based ACL have to implement this callback.

\item[{\code{start\_radar\_detection}}] \leavevmode
Start radar detection in the driver.

\item[{\code{update\_ft\_ies}}] \leavevmode
Provide updated Fast BSS Transition information to the
driver. If the SME is in the driver/firmware, this information can be
used in building Authentication and Reassociation Request frames.

\item[{\code{crit\_proto\_start}}] \leavevmode
Indicates a critical protocol needs more link reliability
for a given duration (milliseconds). The protocol is provided so the
driver can take the most appropriate actions.

\item[{\code{crit\_proto\_stop}}] \leavevmode
Indicates critical protocol no longer needs increased link
reliability. This operation can not fail.

\item[{\code{set\_coalesce}}] \leavevmode
Set coalesce parameters.

\item[{\code{channel\_switch}}] \leavevmode
initiate channel-switch procedure (with CSA). Driver is
responsible for veryfing if the switch is possible. Since this is
inherently tricky driver may decide to disconnect an interface later
with \code{cfg80211\_stop\_iface()}. This doesn't mean driver can accept
everything. It should do it's best to verify requests and reject them
as soon as possible.

\item[{\code{set\_qos\_map}}] \leavevmode
Set QoS mapping information to the driver

\item[{\code{set\_ap\_chanwidth}}] \leavevmode
Set the AP (including P2P GO) mode channel width for the
given interface This is used e.g. for dynamic HT 20/40 MHz channel width
changes during the lifetime of the BSS.

\item[{\code{add\_tx\_ts}}] \leavevmode
validate (if admitted\_time is 0) or add a TX TS to the device
with the given parameters; action frame exchange has been handled by
userspace so this just has to modify the TX path to take the TS into
account.
If the admitted time is 0 just validate the parameters to make sure
the session can be created at all; it is valid to just always return
success for that but that may result in inefficient behaviour (handshake
with the peer followed by immediate teardown when the addition is later
rejected)

\item[{\code{del\_tx\_ts}}] \leavevmode
remove an existing TX TS

\item[{\code{tdls\_channel\_switch}}] \leavevmode
Start channel-switching with a TDLS peer. The driver
is responsible for continually initiating channel-switching operations
and returning to the base channel for communication with the AP.

\item[{\code{tdls\_cancel\_channel\_switch}}] \leavevmode
Stop channel-switching with a TDLS peer. Both
peers must be on the base channel when the call completes.

\item[{\code{start\_nan}}] \leavevmode
Start the NAN interface.

\item[{\code{stop\_nan}}] \leavevmode
Stop the NAN interface.

\item[{\code{add\_nan\_func}}] \leavevmode
Add a NAN function. Returns negative value on failure.
On success \textbf{nan\_func} ownership is transferred to the driver and
it may access it outside of the scope of this function. The driver
should free the \textbf{nan\_func} when no longer needed by calling
\code{cfg80211\_free\_nan\_func()}.
On success the driver should assign an instance\_id in the
provided \textbf{nan\_func}.

\item[{\code{del\_nan\_func}}] \leavevmode
Delete a NAN function.

\item[{\code{nan\_change\_conf}}] \leavevmode
changes NAN configuration. The changed parameters must
be specified in \textbf{changes} (using \code{enum cfg80211\_nan\_conf\_changes});
All other parameters must be ignored.

\item[{\code{set\_multicast\_to\_unicast}}] \leavevmode
configure multicast to unicast conversion for BSS

\item[{\code{set\_pmk}}] \leavevmode
configure the PMK to be used for offloaded 802.1X 4-Way handshake.
If not deleted through \textbf{del\_pmk} the PMK remains valid until disconnect
upon which the driver should clear it.
(invoked with the wireless\_dev mutex held)

\item[{\code{del\_pmk}}] \leavevmode
delete the previously configured PMK for the given authenticator.
(invoked with the wireless\_dev mutex held)

\end{description}

\textbf{Description}

This struct is registered by fullmac card drivers and/or wireless stacks
in order to handle configuration requests on their interfaces.

All callbacks except where otherwise noted should return 0
on success or a negative error code.

All operations are currently invoked under rtnl for consistency with the
wireless extensions but this is subject to reevaluation as soon as this
code is used more widely and we have a first user without wext.
\index{vif\_params (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.vif_params}\pysigline{struct \bfcode{vif\_params}}
describes virtual interface parameters

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct vif\PYGZus{}params \PYGZob{}
  u32 flags;
  int use\PYGZus{}4addr;
  u8 macaddr[ETH\PYGZus{}ALEN];
  const u8 *vht\PYGZus{}mumimo\PYGZus{}groups;
  const u8 *vht\PYGZus{}mumimo\PYGZus{}follow\PYGZus{}addr;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{flags}}] \leavevmode
monitor interface flags, unchanged if 0, otherwise
\code{MONITOR\_FLAG\_CHANGED} will be set

\item[{\code{use\_4addr}}] \leavevmode
use 4-address frames

\item[{\code{macaddr}}] \leavevmode
address to use for this virtual interface.
If this parameter is set to zero address the driver may
determine the address as needed.
This feature is only fully supported by drivers that enable the
\code{NL80211\_FEATURE\_MAC\_ON\_CREATE} flag.  Others may support creating
*     only p2p devices with specified MAC.

\item[{\code{vht\_mumimo\_groups}}] \leavevmode
MU-MIMO groupID, used for monitoring MU-MIMO packets
belonging to that MU-MIMO groupID; \code{NULL} if not changed

\item[{\code{vht\_mumimo\_follow\_addr}}] \leavevmode
MU-MIMO follow address, used for monitoring
MU-MIMO packets going to the specified station; \code{NULL} if not changed

\end{description}
\index{key\_params (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.key_params}\pysigline{struct \bfcode{key\_params}}
key information

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct key\PYGZus{}params \PYGZob{}
  const u8 *key;
  const u8 *seq;
  int key\PYGZus{}len;
  int seq\PYGZus{}len;
  u32 cipher;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{key}}] \leavevmode
key material

\item[{\code{seq}}] \leavevmode
sequence counter (IV/PN) for TKIP and CCMP keys, only used
with the \code{get\_key()} callback, must be in little endian,
length given by \textbf{seq\_len}.

\item[{\code{key\_len}}] \leavevmode
length of key material

\item[{\code{seq\_len}}] \leavevmode
length of \textbf{seq}.

\item[{\code{cipher}}] \leavevmode
cipher suite selector

\end{description}

\textbf{Description}

Information about a key
\index{survey\_info\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.survey_info_flags}\pysigline{enum \bfcode{survey\_info\_flags}}
survey information flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{SURVEY\_INFO\_NOISE\_DBM}}] \leavevmode
noise (in dBm) was filled in

\item[{\code{SURVEY\_INFO\_IN\_USE}}] \leavevmode
channel is currently being used

\item[{\code{SURVEY\_INFO\_TIME}}] \leavevmode
active time (in ms) was filled in

\item[{\code{SURVEY\_INFO\_TIME\_BUSY}}] \leavevmode
busy time was filled in

\item[{\code{SURVEY\_INFO\_TIME\_EXT\_BUSY}}] \leavevmode
extension channel busy time was filled in

\item[{\code{SURVEY\_INFO\_TIME\_RX}}] \leavevmode
receive time was filled in

\item[{\code{SURVEY\_INFO\_TIME\_TX}}] \leavevmode
transmit time was filled in

\item[{\code{SURVEY\_INFO\_TIME\_SCAN}}] \leavevmode
scan time was filled in

\end{description}

\textbf{Description}

Used by the driver to indicate which info in {\hyperref[driver\string-api/80211/cfg80211:c.survey_info]{\emph{\code{struct survey\_info}}}}
it has filled in during the \code{get\_survey()}.
\index{survey\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.survey_info}\pysigline{struct \bfcode{survey\_info}}
channel survey response

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct survey\PYGZus{}info \PYGZob{}
  struct ieee80211\PYGZus{}channel *channel;
  u64 time;
  u64 time\PYGZus{}busy;
  u64 time\PYGZus{}ext\PYGZus{}busy;
  u64 time\PYGZus{}rx;
  u64 time\PYGZus{}tx;
  u64 time\PYGZus{}scan;
  u32 filled;
  s8 noise;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{channel}}] \leavevmode
the channel this survey record reports, may be \code{NULL} for a single
record to report global statistics

\item[{\code{time}}] \leavevmode
amount of time in ms the radio was turn on (on the channel)

\item[{\code{time\_busy}}] \leavevmode
amount of time the primary channel was sensed busy

\item[{\code{time\_ext\_busy}}] \leavevmode
amount of time the extension channel was sensed busy

\item[{\code{time\_rx}}] \leavevmode
amount of time the radio spent receiving data

\item[{\code{time\_tx}}] \leavevmode
amount of time the radio spent transmitting data

\item[{\code{time\_scan}}] \leavevmode
amount of time the radio spent for scanning

\item[{\code{filled}}] \leavevmode
bitflag of flags from {\hyperref[driver\string-api/80211/cfg80211:c.survey_info_flags]{\emph{\code{enum survey\_info\_flags}}}}

\item[{\code{noise}}] \leavevmode
channel noise in dBm. This and all following fields are
optional

\end{description}

\textbf{Description}

Used by \code{dump\_survey()} to report back per-channel survey information.

This structure can later be expanded with things like
channel duty cycle etc.
\index{cfg80211\_beacon\_data (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_beacon_data}\pysigline{struct \bfcode{cfg80211\_beacon\_data}}
beacon data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cfg80211\PYGZus{}beacon\PYGZus{}data \PYGZob{}
  const u8 *head, *tail;
  const u8 *beacon\PYGZus{}ies;
  const u8 *proberesp\PYGZus{}ies;
  const u8 *assocresp\PYGZus{}ies;
  const u8 *probe\PYGZus{}resp;
  size\PYGZus{}t head\PYGZus{}len, tail\PYGZus{}len;
  size\PYGZus{}t beacon\PYGZus{}ies\PYGZus{}len;
  size\PYGZus{}t proberesp\PYGZus{}ies\PYGZus{}len;
  size\PYGZus{}t assocresp\PYGZus{}ies\PYGZus{}len;
  size\PYGZus{}t probe\PYGZus{}resp\PYGZus{}len;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{head}}] \leavevmode
head portion of beacon (before TIM IE)
or \code{NULL} if not changed

\item[{\code{tail}}] \leavevmode
tail portion of beacon (after TIM IE)
or \code{NULL} if not changed

\item[{\code{beacon\_ies}}] \leavevmode
extra information element(s) to add into Beacon frames or \code{NULL}

\item[{\code{proberesp\_ies}}] \leavevmode
extra information element(s) to add into Probe Response
frames or \code{NULL}

\item[{\code{assocresp\_ies}}] \leavevmode
extra information element(s) to add into (Re)Association
Response frames or \code{NULL}

\item[{\code{probe\_resp}}] \leavevmode
probe response template (AP mode only)

\item[{\code{head\_len}}] \leavevmode
length of \textbf{head}

\item[{\code{tail\_len}}] \leavevmode
length of \textbf{tail}

\item[{\code{beacon\_ies\_len}}] \leavevmode
length of beacon\_ies in octets

\item[{\code{proberesp\_ies\_len}}] \leavevmode
length of proberesp\_ies in octets

\item[{\code{assocresp\_ies\_len}}] \leavevmode
length of assocresp\_ies in octets

\item[{\code{probe\_resp\_len}}] \leavevmode
length of probe response template (\textbf{probe\_resp})

\end{description}
\index{cfg80211\_ap\_settings (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_ap_settings}\pysigline{struct \bfcode{cfg80211\_ap\_settings}}
AP configuration

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cfg80211\PYGZus{}ap\PYGZus{}settings \PYGZob{}
  struct cfg80211\PYGZus{}chan\PYGZus{}def chandef;
  struct cfg80211\PYGZus{}beacon\PYGZus{}data beacon;
  int beacon\PYGZus{}interval, dtim\PYGZus{}period;
  const u8 *ssid;
  size\PYGZus{}t ssid\PYGZus{}len;
  enum nl80211\PYGZus{}hidden\PYGZus{}ssid hidden\PYGZus{}ssid;
  struct cfg80211\PYGZus{}crypto\PYGZus{}settings crypto;
  bool privacy;
  enum nl80211\PYGZus{}auth\PYGZus{}type auth\PYGZus{}type;
  enum nl80211\PYGZus{}smps\PYGZus{}mode smps\PYGZus{}mode;
  int inactivity\PYGZus{}timeout;
  u8 p2p\PYGZus{}ctwindow;
  bool p2p\PYGZus{}opp\PYGZus{}ps;
  const struct cfg80211\PYGZus{}acl\PYGZus{}data *acl;
  bool pbss;
  struct cfg80211\PYGZus{}bitrate\PYGZus{}mask beacon\PYGZus{}rate;
  const struct ieee80211\PYGZus{}ht\PYGZus{}cap *ht\PYGZus{}cap;
  const struct ieee80211\PYGZus{}vht\PYGZus{}cap *vht\PYGZus{}cap;
  bool ht\PYGZus{}required, vht\PYGZus{}required;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{chandef}}] \leavevmode
defines the channel to use

\item[{\code{beacon}}] \leavevmode
beacon data

\item[{\code{beacon\_interval}}] \leavevmode
beacon interval

\item[{\code{dtim\_period}}] \leavevmode
DTIM period

\item[{\code{ssid}}] \leavevmode
SSID to be used in the BSS (note: may be \code{NULL} if not provided from
user space)

\item[{\code{ssid\_len}}] \leavevmode
length of \textbf{ssid}

\item[{\code{hidden\_ssid}}] \leavevmode
whether to hide the SSID in Beacon/Probe Response frames

\item[{\code{crypto}}] \leavevmode
crypto settings

\item[{\code{privacy}}] \leavevmode
the BSS uses privacy

\item[{\code{auth\_type}}] \leavevmode
Authentication type (algorithm)

\item[{\code{smps\_mode}}] \leavevmode
SMPS mode

\item[{\code{inactivity\_timeout}}] \leavevmode
time in seconds to determine station's inactivity.

\item[{\code{p2p\_ctwindow}}] \leavevmode
P2P CT Window

\item[{\code{p2p\_opp\_ps}}] \leavevmode
P2P opportunistic PS

\item[{\code{acl}}] \leavevmode
ACL configuration used by the drivers which has support for
MAC address based access control

\item[{\code{pbss}}] \leavevmode
If set, start as a PCP instead of AP. Relevant for DMG
networks.

\item[{\code{beacon\_rate}}] \leavevmode
bitrate to be used for beacons

\item[{\code{ht\_cap}}] \leavevmode
HT capabilities (or \code{NULL} if HT isn't enabled)

\item[{\code{vht\_cap}}] \leavevmode
VHT capabilities (or \code{NULL} if VHT isn't enabled)

\item[{\code{ht\_required}}] \leavevmode
stations must support HT

\item[{\code{vht\_required}}] \leavevmode
stations must support VHT

\end{description}

\textbf{Description}

Used to configure an AP interface.
\index{station\_parameters (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.station_parameters}\pysigline{struct \bfcode{station\_parameters}}
station parameters

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct station\PYGZus{}parameters \PYGZob{}
  const u8 *supported\PYGZus{}rates;
  struct net\PYGZus{}device *vlan;
  u32 sta\PYGZus{}flags\PYGZus{}mask, sta\PYGZus{}flags\PYGZus{}set;
  u32 sta\PYGZus{}modify\PYGZus{}mask;
  int listen\PYGZus{}interval;
  u16 aid;
  u16 peer\PYGZus{}aid;
  u8 supported\PYGZus{}rates\PYGZus{}len;
  u8 plink\PYGZus{}action;
  u8 plink\PYGZus{}state;
  const struct ieee80211\PYGZus{}ht\PYGZus{}cap *ht\PYGZus{}capa;
  const struct ieee80211\PYGZus{}vht\PYGZus{}cap *vht\PYGZus{}capa;
  u8 uapsd\PYGZus{}queues;
  u8 max\PYGZus{}sp;
  enum nl80211\PYGZus{}mesh\PYGZus{}power\PYGZus{}mode local\PYGZus{}pm;
  u16 capability;
  const u8 *ext\PYGZus{}capab;
  u8 ext\PYGZus{}capab\PYGZus{}len;
  const u8 *supported\PYGZus{}channels;
  u8 supported\PYGZus{}channels\PYGZus{}len;
  const u8 *supported\PYGZus{}oper\PYGZus{}classes;
  u8 supported\PYGZus{}oper\PYGZus{}classes\PYGZus{}len;
  u8 opmode\PYGZus{}notif;
  bool opmode\PYGZus{}notif\PYGZus{}used;
  int support\PYGZus{}p2p\PYGZus{}ps;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{supported\_rates}}] \leavevmode
supported rates in IEEE 802.11 format
(or NULL for no change)

\item[{\code{vlan}}] \leavevmode
vlan interface station should belong to

\item[{\code{sta\_flags\_mask}}] \leavevmode
station flags that changed
(bitmask of BIT(\code{NL80211\_STA\_FLAG\_}...))

\item[{\code{sta\_flags\_set}}] \leavevmode
station flags values
(bitmask of BIT(\code{NL80211\_STA\_FLAG\_}...))

\item[{\code{sta\_modify\_mask}}] \leavevmode
bitmap indicating which parameters changed
(for those that don't have a natural ``no change'' value),
see \code{enum station\_parameters\_apply\_mask}

\item[{\code{listen\_interval}}] \leavevmode
listen interval or -1 for no change

\item[{\code{aid}}] \leavevmode
AID or zero for no change

\item[{\code{peer\_aid}}] \leavevmode
mesh peer AID or zero for no change

\item[{\code{supported\_rates\_len}}] \leavevmode
number of supported rates

\item[{\code{plink\_action}}] \leavevmode
plink action to take

\item[{\code{plink\_state}}] \leavevmode
set the peer link state for a station

\item[{\code{ht\_capa}}] \leavevmode
HT capabilities of station

\item[{\code{vht\_capa}}] \leavevmode
VHT capabilities of station

\item[{\code{uapsd\_queues}}] \leavevmode
bitmap of queues configured for uapsd. same format
as the AC bitmap in the QoS info field

\item[{\code{max\_sp}}] \leavevmode
max Service Period. same format as the MAX\_SP in the
QoS info field (but already shifted down)

\item[{\code{local\_pm}}] \leavevmode
local link-specific mesh power save mode (no change when set
to unknown)

\item[{\code{capability}}] \leavevmode
station capability

\item[{\code{ext\_capab}}] \leavevmode
extended capabilities of the station

\item[{\code{ext\_capab\_len}}] \leavevmode
number of extended capabilities

\item[{\code{supported\_channels}}] \leavevmode
supported channels in IEEE 802.11 format

\item[{\code{supported\_channels\_len}}] \leavevmode
number of supported channels

\item[{\code{supported\_oper\_classes}}] \leavevmode
supported oper classes in IEEE 802.11 format

\item[{\code{supported\_oper\_classes\_len}}] \leavevmode
number of supported operating classes

\item[{\code{opmode\_notif}}] \leavevmode
operating mode field from Operating Mode Notification

\item[{\code{opmode\_notif\_used}}] \leavevmode
information if operating mode field is used

\item[{\code{support\_p2p\_ps}}] \leavevmode
information if station supports P2P PS mechanism

\end{description}

\textbf{Description}

Used to change and create a new station.
\index{rate\_info\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.rate_info_flags}\pysigline{enum \bfcode{rate\_info\_flags}}
bitrate info flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{RATE\_INFO\_FLAGS\_MCS}}] \leavevmode
mcs field filled with HT MCS

\item[{\code{RATE\_INFO\_FLAGS\_VHT\_MCS}}] \leavevmode
mcs field filled with VHT MCS

\item[{\code{RATE\_INFO\_FLAGS\_SHORT\_GI}}] \leavevmode
400ns guard interval

\item[{\code{RATE\_INFO\_FLAGS\_60G}}] \leavevmode
60GHz MCS

\end{description}

\textbf{Description}

Used by the driver to indicate the specific rate transmission
type for 802.11n transmissions.
\index{rate\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.rate_info}\pysigline{struct \bfcode{rate\_info}}
bitrate information

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct rate\PYGZus{}info \PYGZob{}
  u8 flags;
  u8 mcs;
  u16 legacy;
  u8 nss;
  u8 bw;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{flags}}] \leavevmode
bitflag of flags from {\hyperref[driver\string-api/80211/cfg80211:c.rate_info_flags]{\emph{\code{enum rate\_info\_flags}}}}

\item[{\code{mcs}}] \leavevmode
mcs index if struct describes a 802.11n bitrate

\item[{\code{legacy}}] \leavevmode
bitrate in 100kbit/s for 802.11abg

\item[{\code{nss}}] \leavevmode
number of streams (VHT only)

\item[{\code{bw}}] \leavevmode
bandwidth (from \code{enum rate\_info\_bw})

\end{description}

\textbf{Description}

Information about a receiving or transmitting bitrate
\index{station\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.station_info}\pysigline{struct \bfcode{station\_info}}
station information

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct station\PYGZus{}info \PYGZob{}
  u64 filled;
  u32 connected\PYGZus{}time;
  u32 inactive\PYGZus{}time;
  u64 rx\PYGZus{}bytes;
  u64 tx\PYGZus{}bytes;
  u16 llid;
  u16 plid;
  u8 plink\PYGZus{}state;
  s8 signal;
  s8 signal\PYGZus{}avg;
  u8 chains;
  s8 chain\PYGZus{}signal[IEEE80211\PYGZus{}MAX\PYGZus{}CHAINS];
  s8 chain\PYGZus{}signal\PYGZus{}avg[IEEE80211\PYGZus{}MAX\PYGZus{}CHAINS];
  struct rate\PYGZus{}info txrate;
  struct rate\PYGZus{}info rxrate;
  u32 rx\PYGZus{}packets;
  u32 tx\PYGZus{}packets;
  u32 tx\PYGZus{}retries;
  u32 tx\PYGZus{}failed;
  u32 rx\PYGZus{}dropped\PYGZus{}misc;
  struct sta\PYGZus{}bss\PYGZus{}parameters bss\PYGZus{}param;
  struct nl80211\PYGZus{}sta\PYGZus{}flag\PYGZus{}update sta\PYGZus{}flags;
  int generation;
  const u8 *assoc\PYGZus{}req\PYGZus{}ies;
  size\PYGZus{}t assoc\PYGZus{}req\PYGZus{}ies\PYGZus{}len;
  u32 beacon\PYGZus{}loss\PYGZus{}count;
  s64 t\PYGZus{}offset;
  enum nl80211\PYGZus{}mesh\PYGZus{}power\PYGZus{}mode local\PYGZus{}pm;
  enum nl80211\PYGZus{}mesh\PYGZus{}power\PYGZus{}mode peer\PYGZus{}pm;
  enum nl80211\PYGZus{}mesh\PYGZus{}power\PYGZus{}mode nonpeer\PYGZus{}pm;
  u32 expected\PYGZus{}throughput;
  u64 rx\PYGZus{}beacon;
  u64 rx\PYGZus{}duration;
  u8 rx\PYGZus{}beacon\PYGZus{}signal\PYGZus{}avg;
  struct cfg80211\PYGZus{}tid\PYGZus{}stats pertid[IEEE80211\PYGZus{}NUM\PYGZus{}TIDS + 1];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{filled}}] \leavevmode
bitflag of flags using the bits of \code{enum nl80211\_sta\_info} to
indicate the relevant values in this struct for them

\item[{\code{connected\_time}}] \leavevmode
time(in secs) since a station is last connected

\item[{\code{inactive\_time}}] \leavevmode
time since last station activity (tx/rx) in milliseconds

\item[{\code{rx\_bytes}}] \leavevmode
bytes (size of MPDUs) received from this station

\item[{\code{tx\_bytes}}] \leavevmode
bytes (size of MPDUs) transmitted to this station

\item[{\code{llid}}] \leavevmode
mesh local link id

\item[{\code{plid}}] \leavevmode
mesh peer link id

\item[{\code{plink\_state}}] \leavevmode
mesh peer link state

\item[{\code{signal}}] \leavevmode
The signal strength, type depends on the wiphy's signal\_type.
For CFG80211\_SIGNAL\_TYPE\_MBM, value is expressed in \_dBm\_.

\item[{\code{signal\_avg}}] \leavevmode
Average signal strength, type depends on the wiphy's signal\_type.
For CFG80211\_SIGNAL\_TYPE\_MBM, value is expressed in \_dBm\_.

\item[{\code{chains}}] \leavevmode
bitmask for filled values in \textbf{chain\_signal}, \textbf{chain\_signal\_avg}

\item[{\code{chain\_signal}}] \leavevmode
per-chain signal strength of last received packet in dBm

\item[{\code{chain\_signal\_avg}}] \leavevmode
per-chain signal strength average in dBm

\item[{\code{txrate}}] \leavevmode
current unicast bitrate from this station

\item[{\code{rxrate}}] \leavevmode
current unicast bitrate to this station

\item[{\code{rx\_packets}}] \leavevmode
packets (MSDUs \& MMPDUs) received from this station

\item[{\code{tx\_packets}}] \leavevmode
packets (MSDUs \& MMPDUs) transmitted to this station

\item[{\code{tx\_retries}}] \leavevmode
cumulative retry counts (MPDUs)

\item[{\code{tx\_failed}}] \leavevmode
number of failed transmissions (MPDUs) (retries exceeded, no ACK)

\item[{\code{rx\_dropped\_misc}}] \leavevmode
Dropped for un-specified reason.

\item[{\code{bss\_param}}] \leavevmode
current BSS parameters

\item[{\code{sta\_flags}}] \leavevmode
station flags mask \& values

\item[{\code{generation}}] \leavevmode
generation number for nl80211 dumps.
This number should increase every time the list of stations
changes, i.e. when a station is added or removed, so that
userspace can tell whether it got a consistent snapshot.

\item[{\code{assoc\_req\_ies}}] \leavevmode
IEs from (Re)Association Request.
This is used only when in AP mode with drivers that do not use
user space MLME/SME implementation. The information is provided for
the {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_new_sta]{\emph{\code{cfg80211\_new\_sta()}}}} calls to notify user space of the IEs.

\item[{\code{assoc\_req\_ies\_len}}] \leavevmode
Length of assoc\_req\_ies buffer in octets.

\item[{\code{beacon\_loss\_count}}] \leavevmode
Number of times beacon loss event has triggered.

\item[{\code{t\_offset}}] \leavevmode
Time offset of the station relative to this host.

\item[{\code{local\_pm}}] \leavevmode
local mesh STA power save mode

\item[{\code{peer\_pm}}] \leavevmode
peer mesh STA power save mode

\item[{\code{nonpeer\_pm}}] \leavevmode
non-peer mesh STA power save mode

\item[{\code{expected\_throughput}}] \leavevmode
expected throughput in kbps (including 802.11 headers)
towards this station.

\item[{\code{rx\_beacon}}] \leavevmode
number of beacons received from this peer

\item[{\code{rx\_duration}}] \leavevmode
aggregate PPDU duration(usecs) for all the frames from a peer

\item[{\code{rx\_beacon\_signal\_avg}}] \leavevmode
signal strength average (in dBm) for beacons received
from this peer

\item[{\code{pertid}}] \leavevmode
per-TID statistics, see \code{struct cfg80211\_tid\_stats}, using the last
(IEEE80211\_NUM\_TIDS) index for MSDUs not encapsulated in QoS-MPDUs.

\end{description}

\textbf{Description}

Station information filled by driver for \code{get\_station()} and dump\_station.
\index{monitor\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.monitor_flags}\pysigline{enum \bfcode{monitor\_flags}}
monitor flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{MONITOR\_FLAG\_CHANGED}}] \leavevmode
set if the flags were changed

\item[{\code{MONITOR\_FLAG\_FCSFAIL}}] \leavevmode
pass frames with bad FCS

\item[{\code{MONITOR\_FLAG\_PLCPFAIL}}] \leavevmode
pass frames with bad PLCP

\item[{\code{MONITOR\_FLAG\_CONTROL}}] \leavevmode
pass control frames

\item[{\code{MONITOR\_FLAG\_OTHER\_BSS}}] \leavevmode
disable BSSID filtering

\item[{\code{MONITOR\_FLAG\_COOK\_FRAMES}}] \leavevmode
report frames after processing

\item[{\code{MONITOR\_FLAG\_ACTIVE}}] \leavevmode
active monitor, ACKs frames on its MAC address

\end{description}

\textbf{Description}

Monitor interface configuration flags. Note that these must be the bits
according to the nl80211 flags.
\index{mpath\_info\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.mpath_info_flags}\pysigline{enum \bfcode{mpath\_info\_flags}}
mesh path information flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{MPATH\_INFO\_FRAME\_QLEN}}] \leavevmode
\textbf{frame\_qlen} filled

\item[{\code{MPATH\_INFO\_SN}}] \leavevmode
\textbf{sn} filled

\item[{\code{MPATH\_INFO\_METRIC}}] \leavevmode
\textbf{metric} filled

\item[{\code{MPATH\_INFO\_EXPTIME}}] \leavevmode
\textbf{exptime} filled

\item[{\code{MPATH\_INFO\_DISCOVERY\_TIMEOUT}}] \leavevmode
\textbf{discovery\_timeout} filled

\item[{\code{MPATH\_INFO\_DISCOVERY\_RETRIES}}] \leavevmode
\textbf{discovery\_retries} filled

\item[{\code{MPATH\_INFO\_FLAGS}}] \leavevmode
\textbf{flags} filled

\end{description}

\textbf{Description}

Used by the driver to indicate which info in {\hyperref[driver\string-api/80211/cfg80211:c.mpath_info]{\emph{\code{struct mpath\_info}}}} it has filled
in during \code{get\_station()} or \code{dump\_station()}.
\index{mpath\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.mpath_info}\pysigline{struct \bfcode{mpath\_info}}
mesh path information

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct mpath\PYGZus{}info \PYGZob{}
  u32 filled;
  u32 frame\PYGZus{}qlen;
  u32 sn;
  u32 metric;
  u32 exptime;
  u32 discovery\PYGZus{}timeout;
  u8 discovery\PYGZus{}retries;
  u8 flags;
  int generation;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{filled}}] \leavevmode
bitfield of flags from {\hyperref[driver\string-api/80211/cfg80211:c.mpath_info_flags]{\emph{\code{enum mpath\_info\_flags}}}}

\item[{\code{frame\_qlen}}] \leavevmode
number of queued frames for this destination

\item[{\code{sn}}] \leavevmode
target sequence number

\item[{\code{metric}}] \leavevmode
metric (cost) of this mesh path

\item[{\code{exptime}}] \leavevmode
expiration time for the mesh path from now, in msecs

\item[{\code{discovery\_timeout}}] \leavevmode
total mesh path discovery timeout, in msecs

\item[{\code{discovery\_retries}}] \leavevmode
mesh path discovery retries

\item[{\code{flags}}] \leavevmode
mesh path flags

\item[{\code{generation}}] \leavevmode
generation number for nl80211 dumps.
This number should increase every time the list of mesh paths
changes, i.e. when a station is added or removed, so that
userspace can tell whether it got a consistent snapshot.

\end{description}

\textbf{Description}

Mesh path information filled by driver for \code{get\_mpath()} and \code{dump\_mpath()}.
\index{bss\_parameters (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.bss_parameters}\pysigline{struct \bfcode{bss\_parameters}}
BSS parameters

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct bss\PYGZus{}parameters \PYGZob{}
  int use\PYGZus{}cts\PYGZus{}prot;
  int use\PYGZus{}short\PYGZus{}preamble;
  int use\PYGZus{}short\PYGZus{}slot\PYGZus{}time;
  const u8 *basic\PYGZus{}rates;
  u8 basic\PYGZus{}rates\PYGZus{}len;
  int ap\PYGZus{}isolate;
  int ht\PYGZus{}opmode;
  s8 p2p\PYGZus{}ctwindow, p2p\PYGZus{}opp\PYGZus{}ps;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{use\_cts\_prot}}] \leavevmode
Whether to use CTS protection
(0 = no, 1 = yes, -1 = do not change)

\item[{\code{use\_short\_preamble}}] \leavevmode
Whether the use of short preambles is allowed
(0 = no, 1 = yes, -1 = do not change)

\item[{\code{use\_short\_slot\_time}}] \leavevmode
Whether the use of short slot time is allowed
(0 = no, 1 = yes, -1 = do not change)

\item[{\code{basic\_rates}}] \leavevmode
basic rates in IEEE 802.11 format
(or NULL for no change)

\item[{\code{basic\_rates\_len}}] \leavevmode
number of basic rates

\item[{\code{ap\_isolate}}] \leavevmode
do not forward packets between connected stations

\item[{\code{ht\_opmode}}] \leavevmode
HT Operation mode
(u16 = opmode, -1 = do not change)

\item[{\code{p2p\_ctwindow}}] \leavevmode
P2P CT Window (-1 = no change)

\item[{\code{p2p\_opp\_ps}}] \leavevmode
P2P opportunistic PS (-1 = no change)

\end{description}

\textbf{Description}

Used to change BSS parameters (mainly for AP mode).
\index{ieee80211\_txq\_params (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_txq_params}\pysigline{struct \bfcode{ieee80211\_txq\_params}}
TX queue parameters

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}txq\PYGZus{}params \PYGZob{}
  enum nl80211\PYGZus{}ac ac;
  u16 txop;
  u16 cwmin;
  u16 cwmax;
  u8 aifs;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{ac}}] \leavevmode
AC identifier

\item[{\code{txop}}] \leavevmode
Maximum burst time in units of 32 usecs, 0 meaning disabled

\item[{\code{cwmin}}] \leavevmode
Minimum contention window {[}a value of the form 2\textasciicircum{}n-1 in the range
1..32767{]}

\item[{\code{cwmax}}] \leavevmode
Maximum contention window {[}a value of the form 2\textasciicircum{}n-1 in the range
1..32767{]}

\item[{\code{aifs}}] \leavevmode
Arbitration interframe space {[}0..255{]}

\end{description}
\index{cfg80211\_crypto\_settings (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_crypto_settings}\pysigline{struct \bfcode{cfg80211\_crypto\_settings}}
Crypto settings

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cfg80211\PYGZus{}crypto\PYGZus{}settings \PYGZob{}
  u32 wpa\PYGZus{}versions;
  u32 cipher\PYGZus{}group;
  int n\PYGZus{}ciphers\PYGZus{}pairwise;
  u32 ciphers\PYGZus{}pairwise[NL80211\PYGZus{}MAX\PYGZus{}NR\PYGZus{}CIPHER\PYGZus{}SUITES];
  int n\PYGZus{}akm\PYGZus{}suites;
  u32 akm\PYGZus{}suites[NL80211\PYGZus{}MAX\PYGZus{}NR\PYGZus{}AKM\PYGZus{}SUITES];
  bool control\PYGZus{}port;
  \PYGZus{}\PYGZus{}be16 control\PYGZus{}port\PYGZus{}ethertype;
  bool control\PYGZus{}port\PYGZus{}no\PYGZus{}encrypt;
  struct key\PYGZus{}params *wep\PYGZus{}keys;
  int wep\PYGZus{}tx\PYGZus{}key;
  const u8 *psk;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{wpa\_versions}}] \leavevmode
indicates which, if any, WPA versions are enabled
(from enum nl80211\_wpa\_versions)

\item[{\code{cipher\_group}}] \leavevmode
group key cipher suite (or 0 if unset)

\item[{\code{n\_ciphers\_pairwise}}] \leavevmode
number of AP supported unicast ciphers

\item[{\code{ciphers\_pairwise}}] \leavevmode
unicast key cipher suites

\item[{\code{n\_akm\_suites}}] \leavevmode
number of AKM suites

\item[{\code{akm\_suites}}] \leavevmode
AKM suites

\item[{\code{control\_port}}] \leavevmode
Whether user space controls IEEE 802.1X port, i.e.,
sets/clears \code{NL80211\_STA\_FLAG\_AUTHORIZED}. If true, the driver is
required to assume that the port is unauthorized until authorized by
user space. Otherwise, port is marked authorized by default.

\item[{\code{control\_port\_ethertype}}] \leavevmode
the control port protocol that should be
allowed through even on unauthorized ports

\item[{\code{control\_port\_no\_encrypt}}] \leavevmode
TRUE to prevent encryption of control port
protocol frames.

\item[{\code{wep\_keys}}] \leavevmode
static WEP keys, if not NULL points to an array of
CFG80211\_MAX\_WEP\_KEYS WEP keys

\item[{\code{wep\_tx\_key}}] \leavevmode
key index (0..3) of the default TX static WEP key

\item[{\code{psk}}] \leavevmode
PSK (for devices supporting 4-way-handshake offload)

\end{description}
\index{cfg80211\_auth\_request (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_auth_request}\pysigline{struct \bfcode{cfg80211\_auth\_request}}
Authentication request data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cfg80211\PYGZus{}auth\PYGZus{}request \PYGZob{}
  struct cfg80211\PYGZus{}bss *bss;
  const u8 *ie;
  size\PYGZus{}t ie\PYGZus{}len;
  enum nl80211\PYGZus{}auth\PYGZus{}type auth\PYGZus{}type;
  const u8 *key;
  u8 key\PYGZus{}len, key\PYGZus{}idx;
  const u8 *auth\PYGZus{}data;
  size\PYGZus{}t auth\PYGZus{}data\PYGZus{}len;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{bss}}] \leavevmode
The BSS to authenticate with, the callee must obtain a reference
to it if it needs to keep it.

\item[{\code{ie}}] \leavevmode
Extra IEs to add to Authentication frame or \code{NULL}

\item[{\code{ie\_len}}] \leavevmode
Length of ie buffer in octets

\item[{\code{auth\_type}}] \leavevmode
Authentication type (algorithm)

\item[{\code{key}}] \leavevmode
WEP key for shared key authentication

\item[{\code{key\_len}}] \leavevmode
length of WEP key for shared key authentication

\item[{\code{key\_idx}}] \leavevmode
index of WEP key for shared key authentication

\item[{\code{auth\_data}}] \leavevmode
Fields and elements in Authentication frames. This contains
the authentication frame body (non-IE and IE data), excluding the
Authentication algorithm number, i.e., starting at the Authentication
transaction sequence number field.

\item[{\code{auth\_data\_len}}] \leavevmode
Length of auth\_data buffer in octets

\end{description}

\textbf{Description}

This structure provides information needed to complete IEEE 802.11
authentication.
\index{cfg80211\_assoc\_request (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_assoc_request}\pysigline{struct \bfcode{cfg80211\_assoc\_request}}
(Re)Association request data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cfg80211\PYGZus{}assoc\PYGZus{}request \PYGZob{}
  struct cfg80211\PYGZus{}bss *bss;
  const u8 *ie, *prev\PYGZus{}bssid;
  size\PYGZus{}t ie\PYGZus{}len;
  struct cfg80211\PYGZus{}crypto\PYGZus{}settings crypto;
  bool use\PYGZus{}mfp;
  u32 flags;
  struct ieee80211\PYGZus{}ht\PYGZus{}cap ht\PYGZus{}capa;
  struct ieee80211\PYGZus{}ht\PYGZus{}cap ht\PYGZus{}capa\PYGZus{}mask;
  struct ieee80211\PYGZus{}vht\PYGZus{}cap vht\PYGZus{}capa, vht\PYGZus{}capa\PYGZus{}mask;
  const u8 *fils\PYGZus{}kek;
  size\PYGZus{}t fils\PYGZus{}kek\PYGZus{}len;
  const u8 *fils\PYGZus{}nonces;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{bss}}] \leavevmode
The BSS to associate with. If the call is successful the driver is
given a reference that it must give back to \code{cfg80211\_send\_rx\_assoc()}
or to {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_assoc_timeout]{\emph{\code{cfg80211\_assoc\_timeout()}}}}. To ensure proper refcounting, new
association requests while already associating must be rejected.

\item[{\code{ie}}] \leavevmode
Extra IEs to add to (Re)Association Request frame or \code{NULL}

\item[{\code{prev\_bssid}}] \leavevmode
previous BSSID, if not \code{NULL} use reassociate frame. This is used
to indicate a request to reassociate within the ESS instead of a request
do the initial association with the ESS. When included, this is set to
the BSSID of the current association, i.e., to the value that is
included in the Current AP address field of the Reassociation Request
frame.

\item[{\code{ie\_len}}] \leavevmode
Length of ie buffer in octets

\item[{\code{crypto}}] \leavevmode
crypto settings

\item[{\code{use\_mfp}}] \leavevmode
Use management frame protection (IEEE 802.11w) in this association

\item[{\code{flags}}] \leavevmode
See \code{enum cfg80211\_assoc\_req\_flags}

\item[{\code{ht\_capa}}] \leavevmode
HT Capabilities over-rides.  Values set in ht\_capa\_mask
will be used in ht\_capa.  Un-supported values will be ignored.

\item[{\code{ht\_capa\_mask}}] \leavevmode
The bits of ht\_capa which are to be used.

\item[{\code{vht\_capa}}] \leavevmode
VHT capability override

\item[{\code{vht\_capa\_mask}}] \leavevmode
VHT capability mask indicating which fields to use

\item[{\code{fils\_kek}}] \leavevmode
FILS KEK for protecting (Re)Association Request/Response frame or
\code{NULL} if FILS is not used.

\item[{\code{fils\_kek\_len}}] \leavevmode
Length of fils\_kek in octets

\item[{\code{fils\_nonces}}] \leavevmode
FILS nonces (part of AAD) for protecting (Re)Association
Request/Response frame or \code{NULL} if FILS is not used. This field starts
with 16 octets of STA Nonce followed by 16 octets of AP Nonce.

\end{description}

\textbf{Description}

This structure provides information needed to complete IEEE 802.11
(re)association.
\index{cfg80211\_deauth\_request (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_deauth_request}\pysigline{struct \bfcode{cfg80211\_deauth\_request}}
Deauthentication request data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cfg80211\PYGZus{}deauth\PYGZus{}request \PYGZob{}
  const u8 *bssid;
  const u8 *ie;
  size\PYGZus{}t ie\PYGZus{}len;
  u16 reason\PYGZus{}code;
  bool local\PYGZus{}state\PYGZus{}change;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{bssid}}] \leavevmode
the BSSID of the BSS to deauthenticate from

\item[{\code{ie}}] \leavevmode
Extra IEs to add to Deauthentication frame or \code{NULL}

\item[{\code{ie\_len}}] \leavevmode
Length of ie buffer in octets

\item[{\code{reason\_code}}] \leavevmode
The reason code for the deauthentication

\item[{\code{local\_state\_change}}] \leavevmode
if set, change local state only and
do not set a deauth frame

\end{description}

\textbf{Description}

This structure provides information needed to complete IEEE 802.11
deauthentication.
\index{cfg80211\_disassoc\_request (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_disassoc_request}\pysigline{struct \bfcode{cfg80211\_disassoc\_request}}
Disassociation request data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cfg80211\PYGZus{}disassoc\PYGZus{}request \PYGZob{}
  struct cfg80211\PYGZus{}bss *bss;
  const u8 *ie;
  size\PYGZus{}t ie\PYGZus{}len;
  u16 reason\PYGZus{}code;
  bool local\PYGZus{}state\PYGZus{}change;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{bss}}] \leavevmode
the BSS to disassociate from

\item[{\code{ie}}] \leavevmode
Extra IEs to add to Disassociation frame or \code{NULL}

\item[{\code{ie\_len}}] \leavevmode
Length of ie buffer in octets

\item[{\code{reason\_code}}] \leavevmode
The reason code for the disassociation

\item[{\code{local\_state\_change}}] \leavevmode
This is a request for a local state only, i.e., no
Disassociation frame is to be transmitted.

\end{description}

\textbf{Description}

This structure provides information needed to complete IEEE 802.11
disassociation.
\index{cfg80211\_ibss\_params (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_ibss_params}\pysigline{struct \bfcode{cfg80211\_ibss\_params}}
IBSS parameters

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cfg80211\PYGZus{}ibss\PYGZus{}params \PYGZob{}
  const u8 *ssid;
  const u8 *bssid;
  struct cfg80211\PYGZus{}chan\PYGZus{}def chandef;
  const u8 *ie;
  u8 ssid\PYGZus{}len, ie\PYGZus{}len;
  u16 beacon\PYGZus{}interval;
  u32 basic\PYGZus{}rates;
  bool channel\PYGZus{}fixed;
  bool privacy;
  bool control\PYGZus{}port;
  bool userspace\PYGZus{}handles\PYGZus{}dfs;
  int mcast\PYGZus{}rate[NUM\PYGZus{}NL80211\PYGZus{}BANDS];
  struct ieee80211\PYGZus{}ht\PYGZus{}cap ht\PYGZus{}capa;
  struct ieee80211\PYGZus{}ht\PYGZus{}cap ht\PYGZus{}capa\PYGZus{}mask;
  struct key\PYGZus{}params *wep\PYGZus{}keys;
  int wep\PYGZus{}tx\PYGZus{}key;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{ssid}}] \leavevmode
The SSID, will always be non-null.

\item[{\code{bssid}}] \leavevmode
Fixed BSSID requested, maybe be \code{NULL}, if set do not
search for IBSSs with a different BSSID.

\item[{\code{chandef}}] \leavevmode
defines the channel to use if no other IBSS to join can be found

\item[{\code{ie}}] \leavevmode
information element(s) to include in the beacon

\item[{\code{ssid\_len}}] \leavevmode
The length of the SSID, will always be non-zero.

\item[{\code{ie\_len}}] \leavevmode
length of that

\item[{\code{beacon\_interval}}] \leavevmode
beacon interval to use

\item[{\code{basic\_rates}}] \leavevmode
bitmap of basic rates to use when creating the IBSS

\item[{\code{channel\_fixed}}] \leavevmode
The channel should be fixed -- do not search for
IBSSs to join on other channels.

\item[{\code{privacy}}] \leavevmode
this is a protected network, keys will be configured
after joining

\item[{\code{control\_port}}] \leavevmode
whether user space controls IEEE 802.1X port, i.e.,
sets/clears \code{NL80211\_STA\_FLAG\_AUTHORIZED}. If true, the driver is
required to assume that the port is unauthorized until authorized by
user space. Otherwise, port is marked authorized by default.

\item[{\code{userspace\_handles\_dfs}}] \leavevmode
whether user space controls DFS operation, i.e.
changes the channel when a radar is detected. This is required
to operate on DFS channels.

\item[{\code{mcast\_rate}}] \leavevmode
per-band multicast rate index + 1 (0: disabled)

\item[{\code{ht\_capa}}] \leavevmode
HT Capabilities over-rides.  Values set in ht\_capa\_mask
will be used in ht\_capa.  Un-supported values will be ignored.

\item[{\code{ht\_capa\_mask}}] \leavevmode
The bits of ht\_capa which are to be used.

\item[{\code{wep\_keys}}] \leavevmode
static WEP keys, if not NULL points to an array of
CFG80211\_MAX\_WEP\_KEYS WEP keys

\item[{\code{wep\_tx\_key}}] \leavevmode
key index (0..3) of the default TX static WEP key

\end{description}

\textbf{Description}

This structure defines the IBSS parameters for the \code{join\_ibss()}
method.
\index{cfg80211\_connect\_params (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_connect_params}\pysigline{struct \bfcode{cfg80211\_connect\_params}}
Connection parameters

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cfg80211\PYGZus{}connect\PYGZus{}params \PYGZob{}
  struct ieee80211\PYGZus{}channel *channel;
  struct ieee80211\PYGZus{}channel *channel\PYGZus{}hint;
  const u8 *bssid;
  const u8 *bssid\PYGZus{}hint;
  const u8 *ssid;
  size\PYGZus{}t ssid\PYGZus{}len;
  enum nl80211\PYGZus{}auth\PYGZus{}type auth\PYGZus{}type;
  const u8 *ie;
  size\PYGZus{}t ie\PYGZus{}len;
  bool privacy;
  enum nl80211\PYGZus{}mfp mfp;
  struct cfg80211\PYGZus{}crypto\PYGZus{}settings crypto;
  const u8 *key;
  u8 key\PYGZus{}len, key\PYGZus{}idx;
  u32 flags;
  int bg\PYGZus{}scan\PYGZus{}period;
  struct ieee80211\PYGZus{}ht\PYGZus{}cap ht\PYGZus{}capa;
  struct ieee80211\PYGZus{}ht\PYGZus{}cap ht\PYGZus{}capa\PYGZus{}mask;
  struct ieee80211\PYGZus{}vht\PYGZus{}cap vht\PYGZus{}capa;
  struct ieee80211\PYGZus{}vht\PYGZus{}cap vht\PYGZus{}capa\PYGZus{}mask;
  bool pbss;
  struct cfg80211\PYGZus{}bss\PYGZus{}selection bss\PYGZus{}select;
  const u8 *prev\PYGZus{}bssid;
  const u8 *fils\PYGZus{}erp\PYGZus{}username;
  size\PYGZus{}t fils\PYGZus{}erp\PYGZus{}username\PYGZus{}len;
  const u8 *fils\PYGZus{}erp\PYGZus{}realm;
  size\PYGZus{}t fils\PYGZus{}erp\PYGZus{}realm\PYGZus{}len;
  u16 fils\PYGZus{}erp\PYGZus{}next\PYGZus{}seq\PYGZus{}num;
  const u8 *fils\PYGZus{}erp\PYGZus{}rrk;
  size\PYGZus{}t fils\PYGZus{}erp\PYGZus{}rrk\PYGZus{}len;
  bool want\PYGZus{}1x;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{channel}}] \leavevmode
The channel to use or \code{NULL} if not specified (auto-select based
on scan results)

\item[{\code{channel\_hint}}] \leavevmode
The channel of the recommended BSS for initial connection or
\code{NULL} if not specified

\item[{\code{bssid}}] \leavevmode
The AP BSSID or \code{NULL} if not specified (auto-select based on scan
results)

\item[{\code{bssid\_hint}}] \leavevmode
The recommended AP BSSID for initial connection to the BSS or
\code{NULL} if not specified. Unlike the \textbf{bssid} parameter, the driver is
allowed to ignore this \textbf{bssid\_hint} if it has knowledge of a better BSS
to use.

\item[{\code{ssid}}] \leavevmode
SSID

\item[{\code{ssid\_len}}] \leavevmode
Length of ssid in octets

\item[{\code{auth\_type}}] \leavevmode
Authentication type (algorithm)

\item[{\code{ie}}] \leavevmode
IEs for association request

\item[{\code{ie\_len}}] \leavevmode
Length of assoc\_ie in octets

\item[{\code{privacy}}] \leavevmode
indicates whether privacy-enabled APs should be used

\item[{\code{mfp}}] \leavevmode
indicate whether management frame protection is used

\item[{\code{crypto}}] \leavevmode
crypto settings

\item[{\code{key}}] \leavevmode
WEP key for shared key authentication

\item[{\code{key\_len}}] \leavevmode
length of WEP key for shared key authentication

\item[{\code{key\_idx}}] \leavevmode
index of WEP key for shared key authentication

\item[{\code{flags}}] \leavevmode
See \code{enum cfg80211\_assoc\_req\_flags}

\item[{\code{bg\_scan\_period}}] \leavevmode
Background scan period in seconds
or -1 to indicate that default value is to be used.

\item[{\code{ht\_capa}}] \leavevmode
HT Capabilities over-rides.  Values set in ht\_capa\_mask
will be used in ht\_capa.  Un-supported values will be ignored.

\item[{\code{ht\_capa\_mask}}] \leavevmode
The bits of ht\_capa which are to be used.

\item[{\code{vht\_capa}}] \leavevmode
VHT Capability overrides

\item[{\code{vht\_capa\_mask}}] \leavevmode
The bits of vht\_capa which are to be used.

\item[{\code{pbss}}] \leavevmode
if set, connect to a PCP instead of AP. Valid for DMG
networks.

\item[{\code{bss\_select}}] \leavevmode
criteria to be used for BSS selection.

\item[{\code{prev\_bssid}}] \leavevmode
previous BSSID, if not \code{NULL} use reassociate frame. This is used
to indicate a request to reassociate within the ESS instead of a request
do the initial association with the ESS. When included, this is set to
the BSSID of the current association, i.e., to the value that is
included in the Current AP address field of the Reassociation Request
frame.

\item[{\code{fils\_erp\_username}}] \leavevmode
EAP re-authentication protocol (ERP) username part of the
NAI or \code{NULL} if not specified. This is used to construct FILS wrapped
data IE.

\item[{\code{fils\_erp\_username\_len}}] \leavevmode
Length of \textbf{fils\_erp\_username} in octets.

\item[{\code{fils\_erp\_realm}}] \leavevmode
EAP re-authentication protocol (ERP) realm part of NAI or
\code{NULL} if not specified. This specifies the domain name of ER server and
is used to construct FILS wrapped data IE.

\item[{\code{fils\_erp\_realm\_len}}] \leavevmode
Length of \textbf{fils\_erp\_realm} in octets.

\item[{\code{fils\_erp\_next\_seq\_num}}] \leavevmode
The next sequence number to use in the FILS ERP
messages. This is also used to construct FILS wrapped data IE.

\item[{\code{fils\_erp\_rrk}}] \leavevmode
ERP re-authentication Root Key (rRK) used to derive additional
keys in FILS or \code{NULL} if not specified.

\item[{\code{fils\_erp\_rrk\_len}}] \leavevmode
Length of \textbf{fils\_erp\_rrk} in octets.

\item[{\code{want\_1x}}] \leavevmode
indicates user-space supports and wants to use 802.1X driver
offload of 4-way handshake.

\end{description}

\textbf{Description}

This structure provides information needed to complete IEEE 802.11
authentication and association.
\index{cfg80211\_pmksa (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_pmksa}\pysigline{struct \bfcode{cfg80211\_pmksa}}
PMK Security Association

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cfg80211\PYGZus{}pmksa \PYGZob{}
  const u8 *bssid;
  const u8 *pmkid;
  const u8 *pmk;
  size\PYGZus{}t pmk\PYGZus{}len;
  const u8 *ssid;
  size\PYGZus{}t ssid\PYGZus{}len;
  const u8 *cache\PYGZus{}id;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{bssid}}] \leavevmode
The AP's BSSID (may be \code{NULL}).

\item[{\code{pmkid}}] \leavevmode
The identifier to refer a PMKSA.

\item[{\code{pmk}}] \leavevmode
The PMK for the PMKSA identified by \textbf{pmkid}. This is used for key
derivation by a FILS STA. Otherwise, \code{NULL}.

\item[{\code{pmk\_len}}] \leavevmode
Length of the \textbf{pmk}. The length of \textbf{pmk} can differ depending on
the hash algorithm used to generate this.

\item[{\code{ssid}}] \leavevmode
SSID to specify the ESS within which a PMKSA is valid when using FILS
cache identifier (may be \code{NULL}).

\item[{\code{ssid\_len}}] \leavevmode
Length of the \textbf{ssid} in octets.

\item[{\code{cache\_id}}] \leavevmode
2-octet cache identifier advertized by a FILS AP identifying the
scope of PMKSA. This is valid only if \textbf{ssid\_len} is non-zero (may be
\code{NULL}).

\end{description}

\textbf{Description}

This structure is passed to the set/\code{del\_pmksa()} method for PMKSA
caching.
\index{cfg80211\_rx\_mlme\_mgmt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_rx_mlme_mgmt}\pysiglinewithargsret{void \bfcode{cfg80211\_rx\_mlme\_mgmt}}{struct net\_device *\emph{ dev}, const u8 *\emph{ buf}, size\_t\emph{ len}}{}
notification of processed MLME management frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{const u8 * buf}}] \leavevmode
authentication frame (header + body)

\item[{\code{size\_t len}}] \leavevmode
length of the frame data

\end{description}

\textbf{Description}

This function is called whenever an authentication, disassociation or
deauthentication frame has been received and processed in station mode.
After being asked to authenticate via cfg80211\_ops::\code{auth()} the driver must
call either this function or {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_auth_timeout]{\emph{\code{cfg80211\_auth\_timeout()}}}}.
After being asked to associate via cfg80211\_ops::\code{assoc()} the driver must
call either this function or {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_auth_timeout]{\emph{\code{cfg80211\_auth\_timeout()}}}}.
While connected, the driver must calls this for received and processed
disassociation and deauthentication frames. If the frame couldn't be used
because it was unprotected, the driver must call the function
\code{cfg80211\_rx\_unprot\_mlme\_mgmt()} instead.

This function may sleep. The caller must hold the corresponding wdev's mutex.
\index{cfg80211\_auth\_timeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_auth_timeout}\pysiglinewithargsret{void \bfcode{cfg80211\_auth\_timeout}}{struct net\_device *\emph{ dev}, const u8 *\emph{ addr}}{}
notification of timed out authentication

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{const u8 * addr}}] \leavevmode
The MAC address of the device with which the authentication timed out

\end{description}

\textbf{Description}

This function may sleep. The caller must hold the corresponding wdev's
mutex.
\index{cfg80211\_rx\_assoc\_resp (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_rx_assoc_resp}\pysiglinewithargsret{void \bfcode{cfg80211\_rx\_assoc\_resp}}{struct net\_device *\emph{ dev}, struct {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_bss]{\emph{cfg80211\_bss}}} *\emph{ bss}, const u8 *\emph{ buf}, size\_t\emph{ len}, int\emph{ uapsd\_queues}}{}
notification of processed association response

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{struct cfg80211\_bss * bss}}] \leavevmode
the BSS that association was requested with, ownership of the pointer
moves to cfg80211 in this call

\item[{\code{const u8 * buf}}] \leavevmode
authentication frame (header + body)

\item[{\code{size\_t len}}] \leavevmode
length of the frame data

\item[{\code{int uapsd\_queues}}] \leavevmode
bitmap of queues configured for uapsd. Same format
as the AC bitmap in the QoS info field

\end{description}

\textbf{Description}

After being asked to associate via cfg80211\_ops::\code{assoc()} the driver must
call either this function or {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_auth_timeout]{\emph{\code{cfg80211\_auth\_timeout()}}}}.

This function may sleep. The caller must hold the corresponding wdev's mutex.
\index{cfg80211\_assoc\_timeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_assoc_timeout}\pysiglinewithargsret{void \bfcode{cfg80211\_assoc\_timeout}}{struct net\_device *\emph{ dev}, struct {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_bss]{\emph{cfg80211\_bss}}} *\emph{ bss}}{}
notification of timed out association

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{struct cfg80211\_bss * bss}}] \leavevmode
The BSS entry with which association timed out.

\end{description}

\textbf{Description}

This function may sleep. The caller must hold the corresponding wdev's mutex.
\index{cfg80211\_tx\_mlme\_mgmt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_tx_mlme_mgmt}\pysiglinewithargsret{void \bfcode{cfg80211\_tx\_mlme\_mgmt}}{struct net\_device *\emph{ dev}, const u8 *\emph{ buf}, size\_t\emph{ len}}{}
notification of transmitted deauth/disassoc frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{const u8 * buf}}] \leavevmode
802.11 frame (header + body)

\item[{\code{size\_t len}}] \leavevmode
length of the frame data

\end{description}

\textbf{Description}

This function is called whenever deauthentication has been processed in
station mode. This includes both received deauthentication frames and
locally generated ones. This function may sleep. The caller must hold the
corresponding wdev's mutex.
\index{cfg80211\_ibss\_joined (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_ibss_joined}\pysiglinewithargsret{void \bfcode{cfg80211\_ibss\_joined}}{struct net\_device *\emph{ dev}, const u8 *\emph{ bssid}, struct {\hyperref[driver\string-api/80211/cfg80211:c.ieee80211_channel]{\emph{ieee80211\_channel}}} *\emph{ channel}, gfp\_t\emph{ gfp}}{}
notify cfg80211 that device joined an IBSS

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{const u8 * bssid}}] \leavevmode
the BSSID of the IBSS joined

\item[{\code{struct ieee80211\_channel * channel}}] \leavevmode
the channel of the IBSS joined

\item[{\code{gfp\_t gfp}}] \leavevmode
allocation flags

\end{description}

\textbf{Description}

This function notifies cfg80211 that the device joined an IBSS or
switched to a different BSSID. Before this function can be called,
either a beacon has to have been received from the IBSS, or one of
the cfg80211\_inform\_bss\{,\_frame\} functions must have been called
with the locally generated beacon -- this guarantees that there is
always a scan result for this IBSS. cfg80211 will handle the rest.
\index{cfg80211\_connect\_resp\_params (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_connect_resp_params}\pysigline{struct \bfcode{cfg80211\_connect\_resp\_params}}
Connection response params

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cfg80211\PYGZus{}connect\PYGZus{}resp\PYGZus{}params \PYGZob{}
  int status;
  const u8 *bssid;
  struct cfg80211\PYGZus{}bss *bss;
  const u8 *req\PYGZus{}ie;
  size\PYGZus{}t req\PYGZus{}ie\PYGZus{}len;
  const u8 *resp\PYGZus{}ie;
  size\PYGZus{}t resp\PYGZus{}ie\PYGZus{}len;
  const u8 *fils\PYGZus{}kek;
  size\PYGZus{}t fils\PYGZus{}kek\PYGZus{}len;
  bool update\PYGZus{}erp\PYGZus{}next\PYGZus{}seq\PYGZus{}num;
  u16 fils\PYGZus{}erp\PYGZus{}next\PYGZus{}seq\PYGZus{}num;
  const u8 *pmk;
  size\PYGZus{}t pmk\PYGZus{}len;
  const u8 *pmkid;
  enum nl80211\PYGZus{}timeout\PYGZus{}reason timeout\PYGZus{}reason;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{status}}] \leavevmode
Status code, \code{WLAN\_STATUS\_SUCCESS} for successful connection, use
\code{WLAN\_STATUS\_UNSPECIFIED\_FAILURE} if your device cannot give you
the real status code for failures. If this call is used to report a
failure due to a timeout (e.g., not receiving an Authentication frame
from the AP) instead of an explicit rejection by the AP, -1 is used to
indicate that this is a failure, but without a status code.
\textbf{timeout\_reason} is used to report the reason for the timeout in that
case.

\item[{\code{bssid}}] \leavevmode
The BSSID of the AP (may be \code{NULL})

\item[{\code{bss}}] \leavevmode
Entry of bss to which STA got connected to, can be obtained through
\code{cfg80211\_get\_bss()} (may be \code{NULL}). Only one parameter among \textbf{bssid} and
\textbf{bss} needs to be specified.

\item[{\code{req\_ie}}] \leavevmode
Association request IEs (may be \code{NULL})

\item[{\code{req\_ie\_len}}] \leavevmode
Association request IEs length

\item[{\code{resp\_ie}}] \leavevmode
Association response IEs (may be \code{NULL})

\item[{\code{resp\_ie\_len}}] \leavevmode
Association response IEs length

\item[{\code{fils\_kek}}] \leavevmode
KEK derived from a successful FILS connection (may be \code{NULL})

\item[{\code{fils\_kek\_len}}] \leavevmode
Length of \textbf{fils\_kek} in octets

\item[{\code{update\_erp\_next\_seq\_num}}] \leavevmode
Boolean value to specify whether the value in
\textbf{fils\_erp\_next\_seq\_num} is valid.

\item[{\code{fils\_erp\_next\_seq\_num}}] \leavevmode
The next sequence number to use in ERP message in
FILS Authentication. This value should be specified irrespective of the
status for a FILS connection.

\item[{\code{pmk}}] \leavevmode
A new PMK if derived from a successful FILS connection (may be \code{NULL}).

\item[{\code{pmk\_len}}] \leavevmode
Length of \textbf{pmk} in octets

\item[{\code{pmkid}}] \leavevmode
A new PMKID if derived from a successful FILS connection or the PMKID
used for this FILS connection (may be \code{NULL}).

\item[{\code{timeout\_reason}}] \leavevmode
Reason for connection timeout. This is used when the
connection fails due to a timeout instead of an explicit rejection from
the AP. \code{NL80211\_TIMEOUT\_UNSPECIFIED} is used when the timeout reason is
not known. This value is used only if \textbf{status} \textless{} 0 to indicate that the
failure is due to a timeout and not due to explicit rejection by the AP.
This value is ignored in other cases (\textbf{status} \textgreater{}= 0).

\end{description}
\index{cfg80211\_connect\_done (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_connect_done}\pysiglinewithargsret{void \bfcode{cfg80211\_connect\_done}}{struct net\_device *\emph{ dev}, struct {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_resp_params]{\emph{cfg80211\_connect\_resp\_params}}} *\emph{ params}, gfp\_t\emph{ gfp}}{}
notify cfg80211 of connection result

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{struct cfg80211\_connect\_resp\_params * params}}] \leavevmode
connection response parameters

\item[{\code{gfp\_t gfp}}] \leavevmode
allocation flags

\end{description}

\textbf{Description}

It should be called by the underlying driver once execution of the connection
request from \code{connect()} has been completed. This is similar to
{\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_bss]{\emph{\code{cfg80211\_connect\_bss()}}}}, but takes a structure pointer for connection response
parameters. Only one of the functions among {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_bss]{\emph{\code{cfg80211\_connect\_bss()}}}},
{\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_result]{\emph{\code{cfg80211\_connect\_result()}}}}, {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_timeout]{\emph{\code{cfg80211\_connect\_timeout()}}}},
and {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_done]{\emph{\code{cfg80211\_connect\_done()}}}} should be called.
\index{cfg80211\_connect\_result (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_connect_result}\pysiglinewithargsret{void \bfcode{cfg80211\_connect\_result}}{struct net\_device *\emph{ dev}, const u8 *\emph{ bssid}, const u8 *\emph{ req\_ie}, size\_t\emph{ req\_ie\_len}, const u8 *\emph{ resp\_ie}, size\_t\emph{ resp\_ie\_len}, u16\emph{ status}, gfp\_t\emph{ gfp}}{}
notify cfg80211 of connection result

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{const u8 * bssid}}] \leavevmode
the BSSID of the AP

\item[{\code{const u8 * req\_ie}}] \leavevmode
association request IEs (maybe be \code{NULL})

\item[{\code{size\_t req\_ie\_len}}] \leavevmode
association request IEs length

\item[{\code{const u8 * resp\_ie}}] \leavevmode
association response IEs (may be \code{NULL})

\item[{\code{size\_t resp\_ie\_len}}] \leavevmode
assoc response IEs length

\item[{\code{u16 status}}] \leavevmode
status code, \code{WLAN\_STATUS\_SUCCESS} for successful connection, use
\code{WLAN\_STATUS\_UNSPECIFIED\_FAILURE} if your device cannot give you
the real status code for failures.

\item[{\code{gfp\_t gfp}}] \leavevmode
allocation flags

\end{description}

\textbf{Description}

It should be called by the underlying driver once execution of the connection
request from \code{connect()} has been completed. This is similar to
{\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_bss]{\emph{\code{cfg80211\_connect\_bss()}}}} which allows the exact bss entry to be specified. Only
one of the functions among {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_bss]{\emph{\code{cfg80211\_connect\_bss()}}}}, {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_result]{\emph{\code{cfg80211\_connect\_result()}}}},
{\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_timeout]{\emph{\code{cfg80211\_connect\_timeout()}}}}, and {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_done]{\emph{\code{cfg80211\_connect\_done()}}}} should be called.
\index{cfg80211\_connect\_bss (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_connect_bss}\pysiglinewithargsret{void \bfcode{cfg80211\_connect\_bss}}{struct net\_device *\emph{ dev}, const u8 *\emph{ bssid}, struct {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_bss]{\emph{cfg80211\_bss}}} *\emph{ bss}, const u8 *\emph{ req\_ie}, size\_t\emph{ req\_ie\_len}, const u8 *\emph{ resp\_ie}, size\_t\emph{ resp\_ie\_len}, int\emph{ status}, gfp\_t\emph{ gfp}, enum nl80211\_timeout\_reason\emph{ timeout\_reason}}{}
notify cfg80211 of connection result

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{const u8 * bssid}}] \leavevmode
the BSSID of the AP

\item[{\code{struct cfg80211\_bss * bss}}] \leavevmode
entry of bss to which STA got connected to, can be obtained
through cfg80211\_get\_bss (may be \code{NULL})

\item[{\code{const u8 * req\_ie}}] \leavevmode
association request IEs (maybe be \code{NULL})

\item[{\code{size\_t req\_ie\_len}}] \leavevmode
association request IEs length

\item[{\code{const u8 * resp\_ie}}] \leavevmode
association response IEs (may be \code{NULL})

\item[{\code{size\_t resp\_ie\_len}}] \leavevmode
assoc response IEs length

\item[{\code{int status}}] \leavevmode
status code, \code{WLAN\_STATUS\_SUCCESS} for successful connection, use
\code{WLAN\_STATUS\_UNSPECIFIED\_FAILURE} if your device cannot give you
the real status code for failures. If this call is used to report a
failure due to a timeout (e.g., not receiving an Authentication frame
from the AP) instead of an explicit rejection by the AP, -1 is used to
indicate that this is a failure, but without a status code.
\textbf{timeout\_reason} is used to report the reason for the timeout in that
case.

\item[{\code{gfp\_t gfp}}] \leavevmode
allocation flags

\item[{\code{enum nl80211\_timeout\_reason timeout\_reason}}] \leavevmode
reason for connection timeout. This is used when the
connection fails due to a timeout instead of an explicit rejection from
the AP. \code{NL80211\_TIMEOUT\_UNSPECIFIED} is used when the timeout reason is
not known. This value is used only if \textbf{status} \textless{} 0 to indicate that the
failure is due to a timeout and not due to explicit rejection by the AP.
This value is ignored in other cases (\textbf{status} \textgreater{}= 0).

\end{description}

\textbf{Description}

It should be called by the underlying driver once execution of the connection
request from \code{connect()} has been completed. This is similar to
{\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_result]{\emph{\code{cfg80211\_connect\_result()}}}}, but with the option of identifying the exact bss
entry for the connection. Only one of the functions among
{\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_bss]{\emph{\code{cfg80211\_connect\_bss()}}}}, {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_result]{\emph{\code{cfg80211\_connect\_result()}}}},
{\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_timeout]{\emph{\code{cfg80211\_connect\_timeout()}}}}, and {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_done]{\emph{\code{cfg80211\_connect\_done()}}}} should be called.
\index{cfg80211\_connect\_timeout (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_connect_timeout}\pysiglinewithargsret{void \bfcode{cfg80211\_connect\_timeout}}{struct net\_device *\emph{ dev}, const u8 *\emph{ bssid}, const u8 *\emph{ req\_ie}, size\_t\emph{ req\_ie\_len}, gfp\_t\emph{ gfp}, enum nl80211\_timeout\_reason\emph{ timeout\_reason}}{}
notify cfg80211 of connection timeout

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{const u8 * bssid}}] \leavevmode
the BSSID of the AP

\item[{\code{const u8 * req\_ie}}] \leavevmode
association request IEs (maybe be \code{NULL})

\item[{\code{size\_t req\_ie\_len}}] \leavevmode
association request IEs length

\item[{\code{gfp\_t gfp}}] \leavevmode
allocation flags

\item[{\code{enum nl80211\_timeout\_reason timeout\_reason}}] \leavevmode
reason for connection timeout.

\end{description}

\textbf{Description}

It should be called by the underlying driver whenever \code{connect()} has failed
in a sequence where no explicit authentication/association rejection was
received from the AP. This could happen, e.g., due to not being able to send
out the Authentication or Association Request frame or timing out while
waiting for the response. Only one of the functions among
{\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_bss]{\emph{\code{cfg80211\_connect\_bss()}}}}, {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_result]{\emph{\code{cfg80211\_connect\_result()}}}},
{\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_timeout]{\emph{\code{cfg80211\_connect\_timeout()}}}}, and {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_connect_done]{\emph{\code{cfg80211\_connect\_done()}}}} should be called.
\index{cfg80211\_roamed (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_roamed}\pysiglinewithargsret{void \bfcode{cfg80211\_roamed}}{struct net\_device *\emph{ dev}, struct cfg80211\_roam\_info *\emph{ info}, gfp\_t\emph{ gfp}}{}
notify cfg80211 of roaming

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{struct cfg80211\_roam\_info * info}}] \leavevmode
information about the new BSS. struct \code{cfg80211\_roam\_info}.

\item[{\code{gfp\_t gfp}}] \leavevmode
allocation flags

\end{description}

\textbf{Description}

This function may be called with the driver passing either the BSSID of the
new AP or passing the bss entry to avoid a race in timeout of the bss entry.
It should be called by the underlying driver whenever it roamed from one AP
to another while connected. Drivers which have roaming implemented in
firmware should pass the bss entry to avoid a race in bss entry timeout where
the bss entry of the new AP is seen in the driver, but gets timed out by the
time it is accessed in \code{\_\_cfg80211\_roamed()} due to delay in scheduling
rdev-\textgreater{}event\_work. In case of any failures, the reference is released
either in {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_roamed]{\emph{\code{cfg80211\_roamed()}}}} or in \code{\_\_cfg80211\_romed()}, Otherwise, it will be
released while diconneting from the current bss.
\index{cfg80211\_disconnected (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_disconnected}\pysiglinewithargsret{void \bfcode{cfg80211\_disconnected}}{struct net\_device *\emph{ dev}, u16\emph{ reason}, const u8 *\emph{ ie}, size\_t\emph{ ie\_len}, bool\emph{ locally\_generated}, gfp\_t\emph{ gfp}}{}
notify cfg80211 that connection was dropped

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{u16 reason}}] \leavevmode
reason code for the disconnection, set it to 0 if unknown

\item[{\code{const u8 * ie}}] \leavevmode
information elements of the deauth/disassoc frame (may be \code{NULL})

\item[{\code{size\_t ie\_len}}] \leavevmode
length of IEs

\item[{\code{bool locally\_generated}}] \leavevmode
disconnection was requested locally

\item[{\code{gfp\_t gfp}}] \leavevmode
allocation flags

\end{description}

\textbf{Description}

After it calls this function, the driver should enter an idle state
and not try to connect to any AP any more.
\index{cfg80211\_ready\_on\_channel (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_ready_on_channel}\pysiglinewithargsret{void \bfcode{cfg80211\_ready\_on\_channel}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wireless_dev]{\emph{wireless\_dev}}} *\emph{ wdev}, u64\emph{ cookie}, struct {\hyperref[driver\string-api/80211/cfg80211:c.ieee80211_channel]{\emph{ieee80211\_channel}}} *\emph{ chan}, unsigned int\emph{ duration}, gfp\_t\emph{ gfp}}{}
notification of remain\_on\_channel start

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wireless\_dev * wdev}}] \leavevmode
wireless device

\item[{\code{u64 cookie}}] \leavevmode
the request cookie

\item[{\code{struct ieee80211\_channel * chan}}] \leavevmode
The current channel (from remain\_on\_channel request)

\item[{\code{unsigned int duration}}] \leavevmode
Duration in milliseconds that the driver intents to remain on the
channel

\item[{\code{gfp\_t gfp}}] \leavevmode
allocation flags

\end{description}
\index{cfg80211\_remain\_on\_channel\_expired (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_remain_on_channel_expired}\pysiglinewithargsret{void \bfcode{cfg80211\_remain\_on\_channel\_expired}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wireless_dev]{\emph{wireless\_dev}}} *\emph{ wdev}, u64\emph{ cookie}, struct {\hyperref[driver\string-api/80211/cfg80211:c.ieee80211_channel]{\emph{ieee80211\_channel}}} *\emph{ chan}, gfp\_t\emph{ gfp}}{}
remain\_on\_channel duration expired

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wireless\_dev * wdev}}] \leavevmode
wireless device

\item[{\code{u64 cookie}}] \leavevmode
the request cookie

\item[{\code{struct ieee80211\_channel * chan}}] \leavevmode
The current channel (from remain\_on\_channel request)

\item[{\code{gfp\_t gfp}}] \leavevmode
allocation flags

\end{description}
\index{cfg80211\_new\_sta (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_new_sta}\pysiglinewithargsret{void \bfcode{cfg80211\_new\_sta}}{struct net\_device *\emph{ dev}, const u8 *\emph{ mac\_addr}, struct {\hyperref[driver\string-api/80211/cfg80211:c.station_info]{\emph{station\_info}}} *\emph{ sinfo}, gfp\_t\emph{ gfp}}{}
notify userspace about station

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
the netdev

\item[{\code{const u8 * mac\_addr}}] \leavevmode
the station's address

\item[{\code{struct station\_info * sinfo}}] \leavevmode
the station information

\item[{\code{gfp\_t gfp}}] \leavevmode
allocation flags

\end{description}
\index{cfg80211\_rx\_mgmt (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_rx_mgmt}\pysiglinewithargsret{bool \bfcode{cfg80211\_rx\_mgmt}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wireless_dev]{\emph{wireless\_dev}}} *\emph{ wdev}, int\emph{ freq}, int\emph{ sig\_dbm}, const u8 *\emph{ buf}, size\_t\emph{ len}, u32\emph{ flags}}{}
notification of received, unprocessed management frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wireless\_dev * wdev}}] \leavevmode
wireless device receiving the frame

\item[{\code{int freq}}] \leavevmode
Frequency on which the frame was received in MHz

\item[{\code{int sig\_dbm}}] \leavevmode
signal strength in dBm, or 0 if unknown

\item[{\code{const u8 * buf}}] \leavevmode
Management frame (header + body)

\item[{\code{size\_t len}}] \leavevmode
length of the frame data

\item[{\code{u32 flags}}] \leavevmode
flags, as defined in enum nl80211\_rxmgmt\_flags

\end{description}

\textbf{Description}

This function is called whenever an Action frame is received for a station
mode interface, but is not processed in kernel.

\textbf{Return}

\code{true} if a user space application has registered for this frame.
For action frames, that makes it responsible for rejecting unrecognized
action frames; \code{false} otherwise, in which case for action frames the
driver is responsible for rejecting the frame.
\index{cfg80211\_mgmt\_tx\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_mgmt_tx_status}\pysiglinewithargsret{void \bfcode{cfg80211\_mgmt\_tx\_status}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wireless_dev]{\emph{wireless\_dev}}} *\emph{ wdev}, u64\emph{ cookie}, const u8 *\emph{ buf}, size\_t\emph{ len}, bool\emph{ ack}, gfp\_t\emph{ gfp}}{}
notification of TX status for management frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wireless\_dev * wdev}}] \leavevmode
wireless device receiving the frame

\item[{\code{u64 cookie}}] \leavevmode
Cookie returned by cfg80211\_ops::\code{mgmt\_tx()}

\item[{\code{const u8 * buf}}] \leavevmode
Management frame (header + body)

\item[{\code{size\_t len}}] \leavevmode
length of the frame data

\item[{\code{bool ack}}] \leavevmode
Whether frame was acknowledged

\item[{\code{gfp\_t gfp}}] \leavevmode
context flags

\end{description}

\textbf{Description}

This function is called whenever a management frame was requested to be
transmitted with cfg80211\_ops::\code{mgmt\_tx()} to report the TX status of the
transmission attempt.
\index{cfg80211\_cqm\_rssi\_notify (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_cqm_rssi_notify}\pysiglinewithargsret{void \bfcode{cfg80211\_cqm\_rssi\_notify}}{struct net\_device *\emph{ dev}, enum nl80211\_cqm\_rssi\_threshold\_event\emph{ rssi\_event}, s32\emph{ rssi\_level}, gfp\_t\emph{ gfp}}{}
connection quality monitoring rssi event

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{enum nl80211\_cqm\_rssi\_threshold\_event rssi\_event}}] \leavevmode
the triggered RSSI event

\item[{\code{s32 rssi\_level}}] \leavevmode
new RSSI level value or 0 if not available

\item[{\code{gfp\_t gfp}}] \leavevmode
context flags

\end{description}

\textbf{Description}

This function is called when a configured connection quality monitoring
rssi threshold reached event occurs.
\index{cfg80211\_cqm\_pktloss\_notify (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_cqm_pktloss_notify}\pysiglinewithargsret{void \bfcode{cfg80211\_cqm\_pktloss\_notify}}{struct net\_device *\emph{ dev}, const u8 *\emph{ peer}, u32\emph{ num\_packets}, gfp\_t\emph{ gfp}}{}
notify userspace about packetloss to peer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{const u8 * peer}}] \leavevmode
peer's MAC address

\item[{\code{u32 num\_packets}}] \leavevmode
how many packets were lost -- should be a fixed threshold
but probably no less than maybe 50, or maybe a throughput dependent
threshold (to account for temporary interference)

\item[{\code{gfp\_t gfp}}] \leavevmode
context flags

\end{description}
\index{cfg80211\_michael\_mic\_failure (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_michael_mic_failure}\pysiglinewithargsret{void \bfcode{cfg80211\_michael\_mic\_failure}}{struct net\_device *\emph{ dev}, const u8 *\emph{ addr}, enum nl80211\_key\_type\emph{ key\_type}, int\emph{ key\_id}, const u8 *\emph{ tsc}, gfp\_t\emph{ gfp}}{}
notification of Michael MIC failure (TKIP)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{const u8 * addr}}] \leavevmode
The source MAC address of the frame

\item[{\code{enum nl80211\_key\_type key\_type}}] \leavevmode
The key type that the received frame used

\item[{\code{int key\_id}}] \leavevmode
Key identifier (0..3). Can be -1 if missing.

\item[{\code{const u8 * tsc}}] \leavevmode
The TSC value of the frame that generated the MIC failure (6 octets)

\item[{\code{gfp\_t gfp}}] \leavevmode
allocation flags

\end{description}

\textbf{Description}

This function is called whenever the local MAC detects a MIC failure in a
received frame. This matches with MLME-MICHAELMICFAILURE.:c:func:\emph{indication()}
primitive.


\subsection{Scanning and BSS list handling}
\label{driver-api/80211/cfg80211:scanning-and-bss-list-handling}
The scanning process itself is fairly simple, but cfg80211 offers quite
a bit of helper functionality. To start a scan, the scan operation will
be invoked with a scan definition. This scan definition contains the
channels to scan, and the SSIDs to send probe requests for (including the
wildcard, if desired). A passive scan is indicated by having no SSIDs to
probe. Additionally, a scan request may contain extra information elements
that should be added to the probe request. The IEs are guaranteed to be
well-formed, and will not exceed the maximum length the driver advertised
in the wiphy structure.

When scanning finds a BSS, cfg80211 needs to be notified of that, because
it is responsible for maintaining the BSS list; the driver should not
maintain a list itself. For this notification, various functions exist.

Since drivers do not maintain a BSS list, there are also a number of
functions to search for a BSS and obtain information about it from the
BSS structure cfg80211 maintains. The BSS list is also made available
to userspace.
\index{cfg80211\_ssid (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_ssid}\pysigline{struct \bfcode{cfg80211\_ssid}}
SSID description

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cfg80211\PYGZus{}ssid \PYGZob{}
  u8 ssid[IEEE80211\PYGZus{}MAX\PYGZus{}SSID\PYGZus{}LEN];
  u8 ssid\PYGZus{}len;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{ssid}}] \leavevmode
the SSID

\item[{\code{ssid\_len}}] \leavevmode
length of the ssid

\end{description}
\index{cfg80211\_scan\_request (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_scan_request}\pysigline{struct \bfcode{cfg80211\_scan\_request}}
scan request description

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cfg80211\PYGZus{}scan\PYGZus{}request \PYGZob{}
  struct cfg80211\PYGZus{}ssid *ssids;
  int n\PYGZus{}ssids;
  u32 n\PYGZus{}channels;
  enum nl80211\PYGZus{}bss\PYGZus{}scan\PYGZus{}width scan\PYGZus{}width;
  const u8 *ie;
  size\PYGZus{}t ie\PYGZus{}len;
  u16 duration;
  bool duration\PYGZus{}mandatory;
  u32 flags;
  u32 rates[NUM\PYGZus{}NL80211\PYGZus{}BANDS];
  struct wireless\PYGZus{}dev *wdev;
  u8 mac\PYGZus{}addr[ETH\PYGZus{}ALEN] ;
  u8 mac\PYGZus{}addr\PYGZus{}mask[ETH\PYGZus{}ALEN] ;
  u8 bssid[ETH\PYGZus{}ALEN] ;
  struct wiphy *wiphy;
  unsigned long scan\PYGZus{}start;
  struct cfg80211\PYGZus{}scan\PYGZus{}info info;
  bool notified;
  bool no\PYGZus{}cck;
  struct ieee80211\PYGZus{}channel *channels[0];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{ssids}}] \leavevmode
SSIDs to scan for (active scan only)

\item[{\code{n\_ssids}}] \leavevmode
number of SSIDs

\item[{\code{n\_channels}}] \leavevmode
total number of channels to scan

\item[{\code{scan\_width}}] \leavevmode
channel width for scanning

\item[{\code{ie}}] \leavevmode
optional information element(s) to add into Probe Request or \code{NULL}

\item[{\code{ie\_len}}] \leavevmode
length of ie in octets

\item[{\code{duration}}] \leavevmode
how long to listen on each channel, in TUs. If
\code{duration\_mandatory} is not set, this is the maximum dwell time and
the actual dwell time may be shorter.

\item[{\code{duration\_mandatory}}] \leavevmode
if set, the scan duration must be as specified by the
\code{duration} field.

\item[{\code{flags}}] \leavevmode
bit field of flags controlling operation

\item[{\code{rates}}] \leavevmode
bitmap of rates to advertise for each band

\item[{\code{wdev}}] \leavevmode
the wireless device to scan for

\item[{\code{mac\_addr}}] \leavevmode
MAC address used with randomisation

\item[{\code{mac\_addr\_mask}}] \leavevmode
MAC address mask used with randomisation, bits that
are 0 in the mask should be randomised, bits that are 1 should
be taken from the \textbf{mac\_addr}

\item[{\code{bssid}}] \leavevmode
BSSID to scan for (most commonly, the wildcard BSSID)

\item[{\code{wiphy}}] \leavevmode
the wiphy this was for

\item[{\code{scan\_start}}] \leavevmode
time (in jiffies) when the scan started

\item[{\code{info}}] \leavevmode
(internal) information about completed scan

\item[{\code{notified}}] \leavevmode
(internal) scan request was notified as done or aborted

\item[{\code{no\_cck}}] \leavevmode
used to send probe requests at non CCK rate in 2GHz band

\item[{\code{channels}}] \leavevmode
channels to scan on.

\end{description}
\index{cfg80211\_scan\_done (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_scan_done}\pysiglinewithargsret{void \bfcode{cfg80211\_scan\_done}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_scan_request]{\emph{cfg80211\_scan\_request}}} *\emph{ request}, struct cfg80211\_scan\_info *\emph{ info}}{}
notify that scan finished

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct cfg80211\_scan\_request * request}}] \leavevmode
the corresponding scan request

\item[{\code{struct cfg80211\_scan\_info * info}}] \leavevmode
information about the completed scan

\end{description}
\index{cfg80211\_bss (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_bss}\pysigline{struct \bfcode{cfg80211\_bss}}
BSS description

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cfg80211\PYGZus{}bss \PYGZob{}
  struct ieee80211\PYGZus{}channel *channel;
  enum nl80211\PYGZus{}bss\PYGZus{}scan\PYGZus{}width scan\PYGZus{}width;
  const struct cfg80211\PYGZus{}bss\PYGZus{}ies \PYGZus{}\PYGZus{}rcu *ies;
  const struct cfg80211\PYGZus{}bss\PYGZus{}ies \PYGZus{}\PYGZus{}rcu *beacon\PYGZus{}ies;
  const struct cfg80211\PYGZus{}bss\PYGZus{}ies \PYGZus{}\PYGZus{}rcu *proberesp\PYGZus{}ies;
  struct cfg80211\PYGZus{}bss *hidden\PYGZus{}beacon\PYGZus{}bss;
  s32 signal;
  u16 beacon\PYGZus{}interval;
  u16 capability;
  u8 bssid[ETH\PYGZus{}ALEN];
  u8 chains;
  s8 chain\PYGZus{}signal[IEEE80211\PYGZus{}MAX\PYGZus{}CHAINS];
  u8 priv[0] ;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{channel}}] \leavevmode
channel this BSS is on

\item[{\code{scan\_width}}] \leavevmode
width of the control channel

\item[{\code{ies}}] \leavevmode
the information elements (Note that there is no guarantee that these
are well-formed!); this is a pointer to either the beacon\_ies or
proberesp\_ies depending on whether Probe Response frame has been
received. It is always non-\code{NULL}.

\item[{\code{beacon\_ies}}] \leavevmode
the information elements from the last Beacon frame
(implementation note: if \textbf{hidden\_beacon\_bss} is set this struct doesn't
own the beacon\_ies, but they're just pointers to the ones from the
\textbf{hidden\_beacon\_bss} struct)

\item[{\code{proberesp\_ies}}] \leavevmode
the information elements from the last Probe Response frame

\item[{\code{hidden\_beacon\_bss}}] \leavevmode
in case this BSS struct represents a probe response from
a BSS that hides the SSID in its beacon, this points to the BSS struct
that holds the beacon data. \textbf{beacon\_ies} is still valid, of course, and
points to the same data as hidden\_beacon\_bss-\textgreater{}beacon\_ies in that case.

\item[{\code{signal}}] \leavevmode
signal strength value (type depends on the wiphy's signal\_type)

\item[{\code{beacon\_interval}}] \leavevmode
the beacon interval as from the frame

\item[{\code{capability}}] \leavevmode
the capability field in host byte order

\item[{\code{bssid}}] \leavevmode
BSSID of the BSS

\item[{\code{chains}}] \leavevmode
bitmask for filled values in \textbf{chain\_signal}.

\item[{\code{chain\_signal}}] \leavevmode
per-chain signal strength of last received BSS in dBm.

\item[{\code{priv}}] \leavevmode
private area for driver use, has at least wiphy-\textgreater{}bss\_priv\_size bytes

\end{description}

\textbf{Description}

This structure describes a BSS (which may also be a mesh network)
for use in scan results and similar.
\index{cfg80211\_inform\_bss (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_inform_bss}\pysigline{struct \bfcode{cfg80211\_inform\_bss}}
BSS inform data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cfg80211\PYGZus{}inform\PYGZus{}bss \PYGZob{}
  struct ieee80211\PYGZus{}channel *chan;
  enum nl80211\PYGZus{}bss\PYGZus{}scan\PYGZus{}width scan\PYGZus{}width;
  s32 signal;
  u64 boottime\PYGZus{}ns;
  u64 parent\PYGZus{}tsf;
  u8 parent\PYGZus{}bssid[ETH\PYGZus{}ALEN] ;
  u8 chains;
  s8 chain\PYGZus{}signal[IEEE80211\PYGZus{}MAX\PYGZus{}CHAINS];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{chan}}] \leavevmode
channel the frame was received on

\item[{\code{scan\_width}}] \leavevmode
scan width that was used

\item[{\code{signal}}] \leavevmode
signal strength value, according to the wiphy's
signal type

\item[{\code{boottime\_ns}}] \leavevmode
timestamp (CLOCK\_BOOTTIME) when the information was
received; should match the time when the frame was actually
received by the device (not just by the host, in case it was
buffered on the device) and be accurate to about 10ms.
If the frame isn't buffered, just passing the return value of
\code{ktime\_get\_boot\_ns()} is likely appropriate.

\item[{\code{parent\_tsf}}] \leavevmode
the time at the start of reception of the first octet of the
timestamp field of the frame. The time is the TSF of the BSS specified
by \code{parent\_bssid}.

\item[{\code{parent\_bssid}}] \leavevmode
the BSS according to which \code{parent\_tsf} is set. This is set to
the BSS that requested the scan in which the beacon/probe was received.

\item[{\code{chains}}] \leavevmode
bitmask for filled values in \textbf{chain\_signal}.

\item[{\code{chain\_signal}}] \leavevmode
per-chain signal strength of last received BSS in dBm.

\end{description}
\index{cfg80211\_inform\_bss\_frame\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_inform_bss_frame_data}\pysiglinewithargsret{struct {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_bss]{\emph{cfg80211\_bss}}} * \bfcode{cfg80211\_inform\_bss\_frame\_data}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}, struct {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_inform_bss]{\emph{cfg80211\_inform\_bss}}} *\emph{ data}, struct ieee80211\_mgmt *\emph{ mgmt}, size\_t\emph{ len}, gfp\_t\emph{ gfp}}{}
inform cfg80211 of a received BSS frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
the wiphy reporting the BSS

\item[{\code{struct cfg80211\_inform\_bss * data}}] \leavevmode
the BSS metadata

\item[{\code{struct ieee80211\_mgmt * mgmt}}] \leavevmode
the management frame (probe response or beacon)

\item[{\code{size\_t len}}] \leavevmode
length of the management frame

\item[{\code{gfp\_t gfp}}] \leavevmode
context flags

\end{description}

\textbf{Description}

This informs cfg80211 that BSS information was found and
the BSS should be updated/added.

\textbf{Return}

A referenced struct, must be released with \code{cfg80211\_put\_bss()}!
Or \code{NULL} on error.
\index{cfg80211\_inform\_bss\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_inform_bss_data}\pysiglinewithargsret{struct {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_bss]{\emph{cfg80211\_bss}}} * \bfcode{cfg80211\_inform\_bss\_data}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}, struct {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_inform_bss]{\emph{cfg80211\_inform\_bss}}} *\emph{ data}, enum cfg80211\_bss\_frame\_type\emph{ ftype}, const u8 *\emph{ bssid}, u64\emph{ tsf}, u16\emph{ capability}, u16\emph{ beacon\_interval}, const u8 *\emph{ ie}, size\_t\emph{ ielen}, gfp\_t\emph{ gfp}}{}
inform cfg80211 of a new BSS

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
the wiphy reporting the BSS

\item[{\code{struct cfg80211\_inform\_bss * data}}] \leavevmode
the BSS metadata

\item[{\code{enum cfg80211\_bss\_frame\_type ftype}}] \leavevmode
frame type (if known)

\item[{\code{const u8 * bssid}}] \leavevmode
the BSSID of the BSS

\item[{\code{u64 tsf}}] \leavevmode
the TSF sent by the peer in the beacon/probe response (or 0)

\item[{\code{u16 capability}}] \leavevmode
the capability field sent by the peer

\item[{\code{u16 beacon\_interval}}] \leavevmode
the beacon interval announced by the peer

\item[{\code{const u8 * ie}}] \leavevmode
additional IEs sent by the peer

\item[{\code{size\_t ielen}}] \leavevmode
length of the additional IEs

\item[{\code{gfp\_t gfp}}] \leavevmode
context flags

\end{description}

\textbf{Description}

This informs cfg80211 that BSS information was found and
the BSS should be updated/added.

\textbf{Return}

A referenced struct, must be released with \code{cfg80211\_put\_bss()}!
Or \code{NULL} on error.
\index{cfg80211\_unlink\_bss (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_unlink_bss}\pysiglinewithargsret{void \bfcode{cfg80211\_unlink\_bss}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}, struct {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_bss]{\emph{cfg80211\_bss}}} *\emph{ bss}}{}
unlink BSS from internal data structures

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
the wiphy

\item[{\code{struct cfg80211\_bss * bss}}] \leavevmode
the bss to remove

\end{description}

\textbf{Description}

This function removes the given BSS from the internal data structures
thereby making it no longer show up in scan results etc. Use this
function when you detect a BSS is gone. Normally BSSes will also time
out, so it is not necessary to use this function at all.
\index{cfg80211\_find\_ie (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_find_ie}\pysiglinewithargsret{const u8 * \bfcode{cfg80211\_find\_ie}}{u8\emph{ eid}, const u8 *\emph{ ies}, int\emph{ len}}{}
find information element in data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 eid}}] \leavevmode
element ID

\item[{\code{const u8 * ies}}] \leavevmode
data consisting of IEs

\item[{\code{int len}}] \leavevmode
length of data

\end{description}

\textbf{Return}

\code{NULL} if the element ID could not be found or if
the element is invalid (claims to be longer than the given
data), or a pointer to the first byte of the requested
element, that is the byte containing the element ID.

\textbf{Note}

There are no checks on the element length other than
having to fit into the given data.
\index{ieee80211\_bss\_get\_ie (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_bss_get_ie}\pysiglinewithargsret{const u8 * \bfcode{ieee80211\_bss\_get\_ie}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_bss]{\emph{cfg80211\_bss}}} *\emph{ bss}, u8\emph{ ie}}{}
find IE with given ID

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct cfg80211\_bss * bss}}] \leavevmode
the bss to search

\item[{\code{u8 ie}}] \leavevmode
the IE ID

\end{description}

\textbf{Description}

Note that the return value is an RCU-protected pointer, so
\code{rcu\_read\_lock()} must be held when calling this function.

\textbf{Return}

\code{NULL} if not found.


\subsection{Utility functions}
\label{driver-api/80211/cfg80211:utility-functions}
cfg80211 offers a number of utility functions that can be useful.
\index{ieee80211\_channel\_to\_frequency (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_channel_to_frequency}\pysiglinewithargsret{int \bfcode{ieee80211\_channel\_to\_frequency}}{int\emph{ chan}, enum nl80211\_band\emph{ band}}{}
convert channel number to frequency

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int chan}}] \leavevmode
channel number

\item[{\code{enum nl80211\_band band}}] \leavevmode
band, necessary due to channel number overlap

\end{description}

\textbf{Return}

The corresponding frequency (in MHz), or 0 if the conversion failed.
\index{ieee80211\_frequency\_to\_channel (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_frequency_to_channel}\pysiglinewithargsret{int \bfcode{ieee80211\_frequency\_to\_channel}}{int\emph{ freq}}{}
convert frequency to channel number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int freq}}] \leavevmode
center frequency

\end{description}

\textbf{Return}

The corresponding channel, or 0 if the conversion failed.
\index{ieee80211\_get\_channel (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_get_channel}\pysiglinewithargsret{struct {\hyperref[driver\string-api/80211/cfg80211:c.ieee80211_channel]{\emph{ieee80211\_channel}}} * \bfcode{ieee80211\_get\_channel}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}, int\emph{ freq}}{}
get channel struct from wiphy for specified frequency

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
the struct wiphy to get the channel for

\item[{\code{int freq}}] \leavevmode
the center frequency of the channel

\end{description}

\textbf{Return}

The channel struct from \textbf{wiphy} at \textbf{freq}.
\index{ieee80211\_get\_response\_rate (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_get_response_rate}\pysiglinewithargsret{struct {\hyperref[driver\string-api/80211/cfg80211:c.ieee80211_rate]{\emph{ieee80211\_rate}}} * \bfcode{ieee80211\_get\_response\_rate}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.ieee80211_supported_band]{\emph{ieee80211\_supported\_band}}} *\emph{ sband}, u32\emph{ basic\_rates}, int\emph{ bitrate}}{}
get basic rate for a given rate

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_supported\_band * sband}}] \leavevmode
the band to look for rates in

\item[{\code{u32 basic\_rates}}] \leavevmode
bitmap of basic rates

\item[{\code{int bitrate}}] \leavevmode
the bitrate for which to find the basic rate

\end{description}

\textbf{Return}

The basic rate corresponding to a given bitrate, that
is the next lower bitrate contained in the basic rate map,
which is, for this function, given as a bitmap of indices of
rates in the band's bitrate table.
\index{ieee80211\_hdrlen (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_hdrlen}\pysiglinewithargsret{unsigned int \_\_attribute\_const\_\_ \bfcode{ieee80211\_hdrlen}}{\_\_le16\emph{ fc}}{}
get header length in bytes from frame control

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_le16 fc}}] \leavevmode
frame control field in little-endian format

\end{description}

\textbf{Return}

The header length in bytes.
\index{ieee80211\_get\_hdrlen\_from\_skb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_get_hdrlen_from_skb}\pysiglinewithargsret{unsigned int \bfcode{ieee80211\_get\_hdrlen\_from\_skb}}{const struct sk\_buff *\emph{ skb}}{}
get header length from data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
the frame

\end{description}

\textbf{Description}

Given an skb with a raw 802.11 header at the data pointer this function
returns the 802.11 header length.

\textbf{Return}

The 802.11 header length in bytes (not including encryption
headers). Or 0 if the data in the sk\_buff is too short to contain a valid
802.11 header.
\index{ieee80211\_radiotap\_iterator (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_radiotap_iterator}\pysigline{struct \bfcode{ieee80211\_radiotap\_iterator}}
tracks walk thru present radiotap args

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}radiotap\PYGZus{}iterator \PYGZob{}
  struct ieee80211\PYGZus{}radiotap\PYGZus{}header *\PYGZus{}rtheader;
  const struct ieee80211\PYGZus{}radiotap\PYGZus{}vendor\PYGZus{}namespaces *\PYGZus{}vns;
  const struct ieee80211\PYGZus{}radiotap\PYGZus{}namespace *current\PYGZus{}namespace;
  unsigned char *\PYGZus{}arg, *\PYGZus{}next\PYGZus{}ns\PYGZus{}data;
  \PYGZus{}\PYGZus{}le32 *\PYGZus{}next\PYGZus{}bitmap;
  unsigned char *this\PYGZus{}arg;
  int this\PYGZus{}arg\PYGZus{}index;
  int this\PYGZus{}arg\PYGZus{}size;
  int is\PYGZus{}radiotap\PYGZus{}ns;
  int \PYGZus{}max\PYGZus{}length;
  int \PYGZus{}arg\PYGZus{}index;
  uint32\PYGZus{}t \PYGZus{}bitmap\PYGZus{}shifter;
  int \PYGZus{}reset\PYGZus{}on\PYGZus{}ext;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{\_rtheader}}] \leavevmode
pointer to the radiotap header we are walking through

\item[{\code{\_vns}}] \leavevmode
vendor namespace definitions

\item[{\code{current\_namespace}}] \leavevmode
pointer to the current namespace definition
(or internally \code{NULL} if the current namespace is unknown)

\item[{\code{\_arg}}] \leavevmode
next argument pointer

\item[{\code{\_next\_ns\_data}}] \leavevmode
beginning of the next namespace's data

\item[{\code{\_next\_bitmap}}] \leavevmode
internal pointer to next present u32

\item[{\code{this\_arg}}] \leavevmode
pointer to current radiotap arg; it is valid after each
call to \code{ieee80211\_radiotap\_iterator\_next()} but also after
\code{ieee80211\_radiotap\_iterator\_init()} where it will point to
the beginning of the actual data portion

\item[{\code{this\_arg\_index}}] \leavevmode
index of current arg, valid after each successful call
to \code{ieee80211\_radiotap\_iterator\_next()}

\item[{\code{this\_arg\_size}}] \leavevmode
length of the current arg, for convenience

\item[{\code{is\_radiotap\_ns}}] \leavevmode
indicates whether the current namespace is the default
radiotap namespace or not

\item[{\code{\_max\_length}}] \leavevmode
length of radiotap header in cpu byte ordering

\item[{\code{\_arg\_index}}] \leavevmode
next argument index

\item[{\code{\_bitmap\_shifter}}] \leavevmode
internal shifter for curr u32 bitmap, b0 set == arg present

\item[{\code{\_reset\_on\_ext}}] \leavevmode
internal; reset the arg index to 0 when going to the
next bitmap word

\end{description}

\textbf{Description}

Describes the radiotap parser state. Fields prefixed with an underscore
must not be used by users of the parser, only by the parser internally.


\subsection{Data path helpers}
\label{driver-api/80211/cfg80211:data-path-helpers}
In addition to generic utilities, cfg80211 also offers
functions that help implement the data path for devices
that do not do the 802.11/802.3 conversion on the device.
\index{ieee80211\_data\_to\_8023 (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_data_to_8023}\pysiglinewithargsret{int \bfcode{ieee80211\_data\_to\_8023}}{struct sk\_buff *\emph{ skb}, const u8 *\emph{ addr}, enum nl80211\_iftype\emph{ iftype}}{}
convert an 802.11 data frame to 802.3

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
the 802.11 data frame

\item[{\code{const u8 * addr}}] \leavevmode
the device MAC address

\item[{\code{enum nl80211\_iftype iftype}}] \leavevmode
the virtual interface type

\end{description}

\textbf{Return}

0 on success. Non-zero on error.
\index{ieee80211\_amsdu\_to\_8023s (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.ieee80211_amsdu_to_8023s}\pysiglinewithargsret{void \bfcode{ieee80211\_amsdu\_to\_8023s}}{struct sk\_buff *\emph{ skb}, struct sk\_buff\_head *\emph{ list}, const u8 *\emph{ addr}, enum nl80211\_iftype\emph{ iftype}, const unsigned int\emph{ extra\_headroom}, const u8 *\emph{ check\_da}, const u8 *\emph{ check\_sa}}{}
decode an IEEE 802.11n A-MSDU frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
The input A-MSDU frame without any headers.

\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
The output list of 802.3 frames. It must be allocated and
initialized by by the caller.

\item[{\code{const u8 * addr}}] \leavevmode
The device MAC address.

\item[{\code{enum nl80211\_iftype iftype}}] \leavevmode
The device interface type.

\item[{\code{const unsigned int extra\_headroom}}] \leavevmode
The hardware extra headroom for SKBs in the \textbf{list}.

\item[{\code{const u8 * check\_da}}] \leavevmode
DA to check in the inner ethernet header, or NULL

\item[{\code{const u8 * check\_sa}}] \leavevmode
SA to check in the inner ethernet header, or NULL

\end{description}

\textbf{Description}

Decode an IEEE 802.11 A-MSDU and convert it to a list of 802.3 frames.
The \textbf{list} will be empty if the decode fails. The \textbf{skb} must be fully
header-less before being passed in here; it is freed in this function.
\index{cfg80211\_classify8021d (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_classify8021d}\pysiglinewithargsret{unsigned int \bfcode{cfg80211\_classify8021d}}{struct sk\_buff *\emph{ skb}, struct cfg80211\_qos\_map *\emph{ qos\_map}}{}
determine the 802.1p/1d tag for a data frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
the data frame

\item[{\code{struct cfg80211\_qos\_map * qos\_map}}] \leavevmode
Interworking QoS mapping or \code{NULL} if not in use

\end{description}

\textbf{Return}

The 802.1p/1d tag.


\subsection{Regulatory enforcement infrastructure}
\label{driver-api/80211/cfg80211:regulatory-enforcement-infrastructure}
TODO
\index{regulatory\_hint (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.regulatory_hint}\pysiglinewithargsret{int \bfcode{regulatory\_hint}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}, const char *\emph{ alpha2}}{}
driver hint to the wireless core a regulatory domain

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
the wireless device giving the hint (used only for reporting
conflicts)

\item[{\code{const char * alpha2}}] \leavevmode
the ISO/IEC 3166 alpha2 the driver claims its regulatory domain
should be in. If \textbf{rd} is set this should be NULL. Note that if you
set this to NULL you should still set rd-\textgreater{}alpha2 to some accepted
alpha2.

\end{description}

\textbf{Description}

Wireless drivers can use this function to hint to the wireless core
what it believes should be the current regulatory domain by
giving it an ISO/IEC 3166 alpha2 country code it knows its regulatory
domain should be in or by providing a completely build regulatory domain.
If the driver provides an ISO/IEC 3166 alpha2 userspace will be queried
for a regulatory domain structure for the respective country.

The wiphy must have been registered to cfg80211 prior to this call.
For cfg80211 drivers this means you must first use {\hyperref[driver\string-api/80211/cfg80211:c.wiphy_register]{\emph{\code{wiphy\_register()}}}},
for mac80211 drivers you must first use {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_register_hw]{\emph{\code{ieee80211\_register\_hw()}}}}.

Drivers should check the return value, its possible you can get
an -ENOMEM.

\textbf{Return}

0 on success. -ENOMEM.
\index{wiphy\_apply\_custom\_regulatory (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.wiphy_apply_custom_regulatory}\pysiglinewithargsret{void \bfcode{wiphy\_apply\_custom\_regulatory}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}, const struct ieee80211\_regdomain *\emph{ regd}}{}
apply a custom driver regulatory domain

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
the wireless device we want to process the regulatory domain on

\item[{\code{const struct ieee80211\_regdomain * regd}}] \leavevmode
the custom regulatory domain to use for this wiphy

\end{description}

\textbf{Description}

Drivers can sometimes have custom regulatory domains which do not apply
to a specific country. Drivers can use this to apply such custom regulatory
domains. This routine must be called prior to wiphy registration. The
custom regulatory domain will be trusted completely and as such previous
default channel settings will be disregarded. If no rule is found for a
channel on the regulatory domain the channel will be disabled.
Drivers using this for a wiphy should also set the wiphy flag
REGULATORY\_CUSTOM\_REG or cfg80211 will set it for the wiphy
that called this helper.
\index{freq\_reg\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.freq_reg_info}\pysiglinewithargsret{const struct ieee80211\_reg\_rule * \bfcode{freq\_reg\_info}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}, u32\emph{ center\_freq}}{}
get regulatory information for the given frequency

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
the wiphy for which we want to process this rule for

\item[{\code{u32 center\_freq}}] \leavevmode
Frequency in KHz for which we want regulatory information for

\end{description}

\textbf{Description}

Use this function to get the regulatory rule for a specific frequency on
a given wireless device. If the device has a specific regulatory domain
it wants to follow we respect that unless a country IE has been received
and processed already.

\textbf{Return}

A valid pointer, or, when an error occurs, for example if no rule
can be found, the return value is encoded using \code{ERR\_PTR()}. Use \code{IS\_ERR()} to
check and \code{PTR\_ERR()} to obtain the numeric return value. The numeric return
value will be -ERANGE if we determine the given center\_freq does not even
have a regulatory rule for a frequency range in the center\_freq's band.
See \code{freq\_in\_rule\_band()} for our current definition of a band -- this is
purely subjective and right now it's 802.11 specific.


\subsection{RFkill integration}
\label{driver-api/80211/cfg80211:rfkill-integration}
RFkill integration in cfg80211 is almost invisible to drivers,
as cfg80211 automatically registers an rfkill instance for each
wireless device it knows about. Soft kill is also translated
into disconnecting and turning all interfaces off, drivers are
expected to turn off the device when all interfaces are down.

However, devices may have a hard RFkill line, in which case they
also need to interact with the rfkill subsystem, via cfg80211.
They can do this with a few helper functions documented here.
\index{wiphy\_rfkill\_set\_hw\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.wiphy_rfkill_set_hw_state}\pysiglinewithargsret{void \bfcode{wiphy\_rfkill\_set\_hw\_state}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}, bool\emph{ blocked}}{}
notify cfg80211 about hw block state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
the wiphy

\item[{\code{bool blocked}}] \leavevmode
block status

\end{description}
\index{wiphy\_rfkill\_start\_polling (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.wiphy_rfkill_start_polling}\pysiglinewithargsret{void \bfcode{wiphy\_rfkill\_start\_polling}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}}{}
start polling rfkill

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
the wiphy

\end{description}
\index{wiphy\_rfkill\_stop\_polling (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.wiphy_rfkill_stop_polling}\pysiglinewithargsret{void \bfcode{wiphy\_rfkill\_stop\_polling}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}}{}
stop polling rfkill

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
the wiphy

\end{description}


\subsection{Test mode}
\label{driver-api/80211/cfg80211:test-mode}
Test mode is a set of utility functions to allow drivers to
interact with driver-specific tools to aid, for instance,
factory programming.

This chapter describes how drivers interact with it, for more
information see the nl80211 book's chapter on it.
\index{cfg80211\_testmode\_alloc\_reply\_skb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_testmode_alloc_reply_skb}\pysiglinewithargsret{struct sk\_buff * \bfcode{cfg80211\_testmode\_alloc\_reply\_skb}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}, int\emph{ approxlen}}{}
allocate testmode reply

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
the wiphy

\item[{\code{int approxlen}}] \leavevmode
an upper bound of the length of the data that will
be put into the skb

\end{description}

\textbf{Description}

This function allocates and pre-fills an skb for a reply to
the testmode command. Since it is intended for a reply, calling
it outside of the \textbf{testmode\_cmd} operation is invalid.

The returned skb is pre-filled with the wiphy index and set up in
a way that any data that is put into the skb (with \code{skb\_put()},
\code{nla\_put()} or similar) will end up being within the
\code{NL80211\_ATTR\_TESTDATA} attribute, so all that needs to be done
with the skb is adding data for the corresponding userspace tool
which can then read that data out of the testdata attribute. You
must not modify the skb in any other way.

When done, call {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_testmode_reply]{\emph{\code{cfg80211\_testmode\_reply()}}}} with the skb and return
its error code as the result of the \textbf{testmode\_cmd} operation.

\textbf{Return}

An allocated and pre-filled skb. \code{NULL} if any errors happen.
\index{cfg80211\_testmode\_reply (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_testmode_reply}\pysiglinewithargsret{int \bfcode{cfg80211\_testmode\_reply}}{struct sk\_buff *\emph{ skb}}{}
send the reply skb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
The skb, must have been allocated with
{\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_testmode_alloc_reply_skb]{\emph{\code{cfg80211\_testmode\_alloc\_reply\_skb()}}}}

\end{description}

\textbf{Description}

Since calling this function will usually be the last thing
before returning from the \textbf{testmode\_cmd} you should return
the error code.  Note that this function consumes the skb
regardless of the return value.

\textbf{Return}

An error code or 0 on success.
\index{cfg80211\_testmode\_alloc\_event\_skb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_testmode_alloc_event_skb}\pysiglinewithargsret{struct sk\_buff * \bfcode{cfg80211\_testmode\_alloc\_event\_skb}}{struct {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{wiphy}}} *\emph{ wiphy}, int\emph{ approxlen}, gfp\_t\emph{ gfp}}{}
allocate testmode event

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wiphy * wiphy}}] \leavevmode
the wiphy

\item[{\code{int approxlen}}] \leavevmode
an upper bound of the length of the data that will
be put into the skb

\item[{\code{gfp\_t gfp}}] \leavevmode
allocation flags

\end{description}

\textbf{Description}

This function allocates and pre-fills an skb for an event on the
testmode multicast group.

The returned skb is set up in the same way as with
{\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_testmode_alloc_reply_skb]{\emph{\code{cfg80211\_testmode\_alloc\_reply\_skb()}}}} but prepared for an event. As
there, you should simply add data to it that will then end up in the
\code{NL80211\_ATTR\_TESTDATA} attribute. Again, you must not modify the skb
in any other way.

When done filling the skb, call {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_testmode_event]{\emph{\code{cfg80211\_testmode\_event()}}}} with the
skb to send the event.

\textbf{Return}

An allocated and pre-filled skb. \code{NULL} if any errors happen.
\index{cfg80211\_testmode\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/cfg80211:c.cfg80211_testmode_event}\pysiglinewithargsret{void \bfcode{cfg80211\_testmode\_event}}{struct sk\_buff *\emph{ skb}, gfp\_t\emph{ gfp}}{}
send the event

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
The skb, must have been allocated with
{\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_testmode_alloc_event_skb]{\emph{\code{cfg80211\_testmode\_alloc\_event\_skb()}}}}

\item[{\code{gfp\_t gfp}}] \leavevmode
allocation flags

\end{description}

\textbf{Description}

This function sends the given \textbf{skb}, which must have been allocated
by {\hyperref[driver\string-api/80211/cfg80211:c.cfg80211_testmode_alloc_event_skb]{\emph{\code{cfg80211\_testmode\_alloc\_event\_skb()}}}}, as an event. It always
consumes it.


\section{mac80211 subsystem (basics)}
\label{driver-api/80211/mac80211:mac80211-subsystem-basics}\label{driver-api/80211/mac80211::doc}
You should read and understand the information contained within this
part of the book while implementing a mac80211 driver. In some chapters,
advanced usage is noted, those may be skipped if this isn't needed.

This part of the book only covers station and monitor mode
functionality, additional information required to implement the other
modes is covered in the second part of the book.


\subsection{Basic hardware handling}
\label{driver-api/80211/mac80211:basic-hardware-handling}
TBD

This chapter shall contain information on getting a hw struct allocated
and registered with mac80211.

Since it is required to allocate rates/modes before registering a hw
struct, this chapter shall also contain information on setting up the
rate/mode structs.

Additionally, some discussion about the callbacks and the general
programming model should be in here, including the definition of
ieee80211\_ops which will be referred to a lot.

Finally, a discussion of hardware capabilities should be done with
references to other parts of the book.
\index{ieee80211\_hw (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_hw}\pysigline{struct \bfcode{ieee80211\_hw}}
hardware information and state

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}hw \PYGZob{}
  struct ieee80211\PYGZus{}conf conf;
  struct wiphy *wiphy;
  const char *rate\PYGZus{}control\PYGZus{}algorithm;
  void *priv;
  unsigned long flags[BITS\PYGZus{}TO\PYGZus{}LONGS(NUM\PYGZus{}IEEE80211\PYGZus{}HW\PYGZus{}FLAGS)];
  unsigned int extra\PYGZus{}tx\PYGZus{}headroom;
  unsigned int extra\PYGZus{}beacon\PYGZus{}tailroom;
  int vif\PYGZus{}data\PYGZus{}size;
  int sta\PYGZus{}data\PYGZus{}size;
  int chanctx\PYGZus{}data\PYGZus{}size;
  int txq\PYGZus{}data\PYGZus{}size;
  u16 queues;
  u16 max\PYGZus{}listen\PYGZus{}interval;
  s8 max\PYGZus{}signal;
  u8 max\PYGZus{}rates;
  u8 max\PYGZus{}report\PYGZus{}rates;
  u8 max\PYGZus{}rate\PYGZus{}tries;
  u8 max\PYGZus{}rx\PYGZus{}aggregation\PYGZus{}subframes;
  u8 max\PYGZus{}tx\PYGZus{}aggregation\PYGZus{}subframes;
  u8 max\PYGZus{}tx\PYGZus{}fragments;
  u8 offchannel\PYGZus{}tx\PYGZus{}hw\PYGZus{}queue;
  u8 radiotap\PYGZus{}mcs\PYGZus{}details;
  u16 radiotap\PYGZus{}vht\PYGZus{}details;
  struct \PYGZob{}
    int units\PYGZus{}pos;
    s16 accuracy;
  \PYGZcb{} radiotap\PYGZus{}timestamp;
  netdev\PYGZus{}features\PYGZus{}t netdev\PYGZus{}features;
  u8 uapsd\PYGZus{}queues;
  u8 uapsd\PYGZus{}max\PYGZus{}sp\PYGZus{}len;
  u8 n\PYGZus{}cipher\PYGZus{}schemes;
  const struct ieee80211\PYGZus{}cipher\PYGZus{}scheme *cipher\PYGZus{}schemes;
  u8 max\PYGZus{}nan\PYGZus{}de\PYGZus{}entries;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{conf}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_conf]{\emph{\code{struct ieee80211\_conf}}}}, device configuration, don't use.

\item[{\code{wiphy}}] \leavevmode
This points to the {\hyperref[driver\string-api/80211/cfg80211:c.wiphy]{\emph{\code{struct wiphy}}}} allocated for this
802.11 PHY. You must fill in the \textbf{perm\_addr} and \textbf{dev}
members of this structure using {\hyperref[driver\string-api/80211/mac80211:c.SET_IEEE80211_DEV]{\emph{\code{SET\_IEEE80211\_DEV()}}}}
and {\hyperref[driver\string-api/80211/mac80211:c.SET_IEEE80211_PERM_ADDR]{\emph{\code{SET\_IEEE80211\_PERM\_ADDR()}}}}. Additionally, all supported
bands (with channels, bitrates) are registered here.

\item[{\code{rate\_control\_algorithm}}] \leavevmode
rate control algorithm for this hardware.
If unset (NULL), the default algorithm will be used. Must be
set before calling {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_register_hw]{\emph{\code{ieee80211\_register\_hw()}}}}.

\item[{\code{priv}}] \leavevmode
pointer to private area that was allocated for driver use
along with this structure.

\item[{\code{flags}}] \leavevmode
hardware flags, see {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw_flags]{\emph{\code{enum ieee80211\_hw\_flags}}}}.

\item[{\code{extra\_tx\_headroom}}] \leavevmode
headroom to reserve in each transmit skb
for use by the driver (e.g. for transmit headers.)

\item[{\code{extra\_beacon\_tailroom}}] \leavevmode
tailroom to reserve in each beacon tx skb.
Can be used by drivers to add extra IEs.

\item[{\code{vif\_data\_size}}] \leavevmode
size (in bytes) of the drv\_priv data area
within {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{\code{struct ieee80211\_vif}}}}.

\item[{\code{sta\_data\_size}}] \leavevmode
size (in bytes) of the drv\_priv data area
within {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta]{\emph{\code{struct ieee80211\_sta}}}}.

\item[{\code{chanctx\_data\_size}}] \leavevmode
size (in bytes) of the drv\_priv data area
within \code{struct ieee80211\_chanctx\_conf}.

\item[{\code{txq\_data\_size}}] \leavevmode
size (in bytes) of the drv\_priv data area
within \textbf{struct} ieee80211\_txq.

\item[{\code{queues}}] \leavevmode
number of available hardware transmit queues for
data packets. WMM/QoS requires at least four, these
queues need to have configurable access parameters.

\item[{\code{max\_listen\_interval}}] \leavevmode
max listen interval in units of beacon interval
that HW supports

\item[{\code{max\_signal}}] \leavevmode
Maximum value for signal (rssi) in RX information, used
only when \textbf{IEEE80211\_HW\_SIGNAL\_UNSPEC} or \textbf{IEEE80211\_HW\_SIGNAL\_DB}

\item[{\code{max\_rates}}] \leavevmode
maximum number of alternate rate retry stages the hw
can handle.

\item[{\code{max\_report\_rates}}] \leavevmode
maximum number of alternate rate retry stages
the hw can report back.

\item[{\code{max\_rate\_tries}}] \leavevmode
maximum number of tries for each stage

\item[{\code{max\_rx\_aggregation\_subframes}}] \leavevmode
maximum buffer size (number of
sub-frames) to be used for A-MPDU block ack receiver
aggregation.
This is only relevant if the device has restrictions on the
number of subframes, if it relies on mac80211 to do reordering
it shouldn't be set.

\item[{\code{max\_tx\_aggregation\_subframes}}] \leavevmode
maximum number of subframes in an
aggregate an HT driver will transmit. Though ADDBA will advertise
a constant value of 64 as some older APs can crash if the window
size is smaller (an example is LinkSys WRT120N with FW v1.0.07
build 002 Jun 18 2012).

\item[{\code{max\_tx\_fragments}}] \leavevmode
maximum number of tx buffers per (A)-MSDU, sum
of 1 + skb\_shinfo(skb)-\textgreater{}nr\_frags for each skb in the frag\_list.

\item[{\code{offchannel\_tx\_hw\_queue}}] \leavevmode
HW queue ID to use for offchannel TX
(if \code{IEEE80211\_HW\_QUEUE\_CONTROL} is set)

\item[{\code{radiotap\_mcs\_details}}] \leavevmode
lists which MCS information can the HW
reports, by default it is set to \_MCS, \_GI and \_BW but doesn't
include \_FMT. Use \code{IEEE80211\_RADIOTAP\_MCS\_HAVE\_}* values, only
adding \_BW is supported today.

\item[{\code{radiotap\_vht\_details}}] \leavevmode
lists which VHT MCS information the HW reports,
the default is \_GI \textbar{} \_BANDWIDTH.
Use the \code{IEEE80211\_RADIOTAP\_VHT\_KNOWN\_}* values.

\item[{\code{radiotap\_timestamp}}] \leavevmode
Information for the radiotap timestamp field; if the
`units\_pos' member is set to a non-negative value it must be set to
a combination of a IEEE80211\_RADIOTAP\_TIMESTAMP\_UNIT\_* and a
IEEE80211\_RADIOTAP\_TIMESTAMP\_SPOS\_* value, and then the timestamp
field will be added and populated from the {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_rx_status]{\emph{\code{struct ieee80211\_rx\_status}}}}
device\_timestamp. If the `accuracy' member is non-negative, it's put
into the accuracy radiotap field and the accuracy known flag is set.

\item[{\code{netdev\_features}}] \leavevmode
netdev features to be set in each netdev created
from this HW. Note that not all features are usable with mac80211,
other features will be rejected during HW registration.

\item[{\code{uapsd\_queues}}] \leavevmode
This bitmap is included in (re)association frame to indicate
for each access category if it is uAPSD trigger-enabled and delivery-
enabled. Use IEEE80211\_WMM\_IE\_STA\_QOSINFO\_AC\_* to set this bitmap.
Each bit corresponds to different AC. Value `1' in specific bit means
that corresponding AC is both trigger- and delivery-enabled. `0' means
neither enabled.

\item[{\code{uapsd\_max\_sp\_len}}] \leavevmode
maximum number of total buffered frames the WMM AP may
deliver to a WMM STA during any Service Period triggered by the WMM STA.
Use IEEE80211\_WMM\_IE\_STA\_QOSINFO\_SP\_* for correct values.

\item[{\code{n\_cipher\_schemes}}] \leavevmode
a size of an array of cipher schemes definitions.

\item[{\code{cipher\_schemes}}] \leavevmode
a pointer to an array of cipher scheme definitions
supported by HW.

\item[{\code{max\_nan\_de\_entries}}] \leavevmode
maximum number of NAN DE functions supported by the
device.

\end{description}

\textbf{Description}

This structure contains the configuration and hardware
information for an 802.11 PHY.
\index{ieee80211\_hw\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_hw_flags}\pysigline{enum \bfcode{ieee80211\_hw\_flags}}
hardware flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{IEEE80211\_HW\_HAS\_RATE\_CONTROL}}] \leavevmode
The hardware or firmware includes rate control, and cannot be
controlled by the stack. As such, no rate control algorithm
should be instantiated, and the TX rate reported to userspace
will be taken from the TX status instead of the rate control
algorithm.
Note that this requires that the driver implement a number of
callbacks so it has the correct information, it needs to have
the \textbf{set\_rts\_threshold} callback and must look at the BSS config
\textbf{use\_cts\_prot} for G/N protection, \textbf{use\_short\_slot} for slot
timing in 2.4 GHz and \textbf{use\_short\_preamble} for preambles for
CCK frames.

\item[{\code{IEEE80211\_HW\_RX\_INCLUDES\_FCS}}] \leavevmode
Indicates that received frames passed to the stack include
the FCS at the end.

\item[{\code{IEEE80211\_HW\_HOST\_BROADCAST\_PS\_BUFFERING}}] \leavevmode
Some wireless LAN chipsets buffer broadcast/multicast frames
for power saving stations in the hardware/firmware and others
rely on the host system for such buffering. This option is used
to configure the IEEE 802.11 upper layer to buffer broadcast and
multicast frames when there are power saving stations so that
the driver can fetch them with {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_get_buffered_bc]{\emph{\code{ieee80211\_get\_buffered\_bc()}}}}.

\item[{\code{IEEE80211\_HW\_SIGNAL\_UNSPEC}}] \leavevmode
Hardware can provide signal values but we don't know its units. We
expect values between 0 and \textbf{max\_signal}.
If possible please provide dB or dBm instead.

\item[{\code{IEEE80211\_HW\_SIGNAL\_DBM}}] \leavevmode
Hardware gives signal values in dBm, decibel difference from
one milliwatt. This is the preferred method since it is standardized
between different devices. \textbf{max\_signal} does not need to be set.

\item[{\code{IEEE80211\_HW\_NEED\_DTIM\_BEFORE\_ASSOC}}] \leavevmode
This device needs to get data from beacon before association (i.e.
dtim\_period).

\item[{\code{IEEE80211\_HW\_SPECTRUM\_MGMT}}] \leavevmode
Hardware supports spectrum management defined in 802.11h
Measurement, Channel Switch, Quieting, TPC

\item[{\code{IEEE80211\_HW\_AMPDU\_AGGREGATION}}] \leavevmode
Hardware supports 11n A-MPDU aggregation.

\item[{\code{IEEE80211\_HW\_SUPPORTS\_PS}}] \leavevmode
Hardware has power save support (i.e. can go to sleep).

\item[{\code{IEEE80211\_HW\_PS\_NULLFUNC\_STACK}}] \leavevmode
Hardware requires nullfunc frame handling in stack, implies
stack support for dynamic PS.

\item[{\code{IEEE80211\_HW\_SUPPORTS\_DYNAMIC\_PS}}] \leavevmode
Hardware has support for dynamic PS.

\item[{\code{IEEE80211\_HW\_MFP\_CAPABLE}}] \leavevmode
Hardware supports management frame protection (MFP, IEEE 802.11w).

\item[{\code{IEEE80211\_HW\_WANT\_MONITOR\_VIF}}] \leavevmode
The driver would like to be informed of
a virtual monitor interface when monitor interfaces are the only
active interfaces.

\item[{\code{IEEE80211\_HW\_NO\_AUTO\_VIF}}] \leavevmode
The driver would like for no wlanX to
be created.  It is expected user-space will create vifs as
desired (and thus have them named as desired).

\item[{\code{IEEE80211\_HW\_SW\_CRYPTO\_CONTROL}}] \leavevmode
The driver wants to control which of the
crypto algorithms can be done in software - so don't automatically
try to fall back to it if hardware crypto fails, but do so only if
the driver returns 1. This also forces the driver to advertise its
supported cipher suites.

\item[{\code{IEEE80211\_HW\_SUPPORT\_FAST\_XMIT}}] \leavevmode
The driver/hardware supports fast-xmit,
this currently requires only the ability to calculate the duration
for frames.

\item[{\code{IEEE80211\_HW\_REPORTS\_TX\_ACK\_STATUS}}] \leavevmode
Hardware can provide ack status reports of Tx frames to
the stack.

\item[{\code{IEEE80211\_HW\_CONNECTION\_MONITOR}}] \leavevmode
The hardware performs its own connection monitoring, including
periodic keep-alives to the AP and probing the AP on beacon loss.

\item[{\code{IEEE80211\_HW\_QUEUE\_CONTROL}}] \leavevmode
The driver wants to control per-interface
queue mapping in order to use different queues (not just one per AC)
for different virtual interfaces. See the doc section on HW queue
control for more details.

\item[{\code{IEEE80211\_HW\_SUPPORTS\_PER\_STA\_GTK}}] \leavevmode
The device's crypto engine supports
per-station GTKs as used by IBSS RSN or during fast transition. If
the device doesn't support per-station GTKs, but can be asked not
to decrypt group addressed frames, then IBSS RSN support is still
possible but software crypto will be used. Advertise the wiphy flag
only in that case.

\item[{\code{IEEE80211\_HW\_AP\_LINK\_PS}}] \leavevmode
When operating in AP mode the device
autonomously manages the PS status of connected stations. When
this flag is set mac80211 will not trigger PS mode for connected
stations based on the PM bit of incoming frames.
Use \code{ieee80211\_start\_ps()}/\code{ieee8021\_end\_ps()} to manually configure
the PS mode of connected stations.

\item[{\code{IEEE80211\_HW\_TX\_AMPDU\_SETUP\_IN\_HW}}] \leavevmode
The device handles TX A-MPDU session
setup strictly in HW. mac80211 should not attempt to do this in
software.

\item[{\code{IEEE80211\_HW\_SUPPORTS\_RC\_TABLE}}] \leavevmode
The driver supports using a rate
selection table provided by the rate control algorithm.

\item[{\code{IEEE80211\_HW\_P2P\_DEV\_ADDR\_FOR\_INTF}}] \leavevmode
Use the P2P Device address for any
P2P Interface. This will be honoured even if more than one interface
is supported.

\item[{\code{IEEE80211\_HW\_TIMING\_BEACON\_ONLY}}] \leavevmode
Use sync timing from beacon frames
only, to allow getting TBTT of a DTIM beacon.

\item[{\code{IEEE80211\_HW\_SUPPORTS\_HT\_CCK\_RATES}}] \leavevmode
Hardware supports mixing HT/CCK rates
and can cope with CCK rates in an aggregation session (e.g. by not
using aggregation for such frames.)

\item[{\code{IEEE80211\_HW\_CHANCTX\_STA\_CSA}}] \leavevmode
Support 802.11h based channel-switch (CSA)
for a single active channel while using channel contexts. When support
is not enabled the default action is to disconnect when getting the
CSA frame.

\item[{\code{IEEE80211\_HW\_SUPPORTS\_CLONED\_SKBS}}] \leavevmode
The driver will never modify the payload
or tailroom of TX skbs without copying them first.

\item[{\code{IEEE80211\_HW\_SINGLE\_SCAN\_ON\_ALL\_BANDS}}] \leavevmode
The HW supports scanning on all bands
in one command, mac80211 doesn't have to run separate scans per band.

\item[{\code{IEEE80211\_HW\_TDLS\_WIDER\_BW}}] \leavevmode
The device/driver supports wider bandwidth
than then BSS bandwidth for a TDLS link on the base channel.

\item[{\code{IEEE80211\_HW\_SUPPORTS\_AMSDU\_IN\_AMPDU}}] \leavevmode
The driver supports receiving A-MSDUs
within A-MPDU.

\item[{\code{IEEE80211\_HW\_BEACON\_TX\_STATUS}}] \leavevmode
The device/driver provides TX status
for sent beacons.

\item[{\code{IEEE80211\_HW\_NEEDS\_UNIQUE\_STA\_ADDR}}] \leavevmode
Hardware (or driver) requires that each
station has a unique address, i.e. each station entry can be identified
by just its MAC address; this prevents, for example, the same station
from connecting to two virtual AP interfaces at the same time.

\item[{\code{IEEE80211\_HW\_SUPPORTS\_REORDERING\_BUFFER}}] \leavevmode
Hardware (or driver) manages the
reordering buffer internally, guaranteeing mac80211 receives frames in
order and does not need to manage its own reorder buffer or BA session
timeout.

\item[{\code{IEEE80211\_HW\_USES\_RSS}}] \leavevmode
The device uses RSS and thus requires parallel RX,
which implies using per-CPU station statistics.

\item[{\code{IEEE80211\_HW\_TX\_AMSDU}}] \leavevmode
Hardware (or driver) supports software aggregated
A-MSDU frames. Requires software tx queueing and fast-xmit support.
When not using minstrel/minstrel\_ht rate control, the driver must
limit the maximum A-MSDU size based on the current tx rate by setting
max\_rc\_amsdu\_len in struct ieee80211\_sta.

\item[{\code{IEEE80211\_HW\_TX\_FRAG\_LIST}}] \leavevmode
Hardware (or driver) supports sending frag\_list
skbs, needed for zero-copy software A-MSDU.

\item[{\code{IEEE80211\_HW\_REPORTS\_LOW\_ACK}}] \leavevmode
The driver (or firmware) reports low ack event
by \code{ieee80211\_report\_low\_ack()} based on its own algorithm. For such
drivers, mac80211 packet loss mechanism will not be triggered and driver
is completely depending on firmware event for station kickout.

\item[{\code{IEEE80211\_HW\_SUPPORTS\_TX\_FRAG}}] \leavevmode
Hardware does fragmentation by itself.
The stack will not do fragmentation.
The callback for \textbf{set\_frag\_threshold} should be set as well.

\item[{\code{IEEE80211\_HW\_SUPPORTS\_TDLS\_BUFFER\_STA}}] \leavevmode
Hardware supports buffer STA on
TDLS links.

\item[{\code{NUM\_IEEE80211\_HW\_FLAGS}}] \leavevmode
number of hardware flags, used for sizing arrays

\end{description}

\textbf{Description}

These flags are used to indicate hardware capabilities to
the stack. Generally, flags here should have their meaning
done in a way that the simplest hardware doesn't need setting
any particular flags. There are some exceptions to this rule,
however, so you are advised to review these flags carefully.
\index{SET\_IEEE80211\_DEV (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.SET_IEEE80211_DEV}\pysiglinewithargsret{void \bfcode{SET\_IEEE80211\_DEV}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}}{}
set device for 802.11 hardware

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{\code{struct ieee80211\_hw}}}} to set the device for

\item[{\code{struct device * dev}}] \leavevmode
the {\hyperref[driver\string-api/infrastructure:c.device]{\emph{\code{struct device}}}} of this 802.11 device

\end{description}
\index{SET\_IEEE80211\_PERM\_ADDR (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.SET_IEEE80211_PERM_ADDR}\pysiglinewithargsret{void \bfcode{SET\_IEEE80211\_PERM\_ADDR}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, const u8 *\emph{ addr}}{}
set the permanent MAC address for 802.11 hardware

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{\code{struct ieee80211\_hw}}}} to set the MAC address for

\item[{\code{const u8 * addr}}] \leavevmode
the address to set

\end{description}
\index{ieee80211\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_ops}\pysigline{struct \bfcode{ieee80211\_ops}}
callbacks from mac80211 to the driver

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}ops \PYGZob{}
  void (*tx)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}tx\PYGZus{}control *control, struct sk\PYGZus{}buff *skb);
  int (*start)(struct ieee80211\PYGZus{}hw *hw);
  void (*stop)(struct ieee80211\PYGZus{}hw *hw);
\PYGZsh{}ifdef CONFIG\PYGZus{}PM;
  int (*suspend)(struct ieee80211\PYGZus{}hw *hw, struct cfg80211\PYGZus{}wowlan *wowlan);
  int (*resume)(struct ieee80211\PYGZus{}hw *hw);
  void (*set\PYGZus{}wakeup)(struct ieee80211\PYGZus{}hw *hw, bool enabled);
\PYGZsh{}endif;
  int (*add\PYGZus{}interface)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif);
  int (*change\PYGZus{}interface)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, enum nl80211\PYGZus{}iftype new\PYGZus{}type, bool p2p);
  void (*remove\PYGZus{}interface)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif);
  int (*config)(struct ieee80211\PYGZus{}hw *hw, u32 changed);
  void (*bss\PYGZus{}info\PYGZus{}changed)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif,struct ieee80211\PYGZus{}bss\PYGZus{}conf *info, u32 changed);
  int (*start\PYGZus{}ap)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif);
  void (*stop\PYGZus{}ap)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif);
  u64 (*prepare\PYGZus{}multicast)(struct ieee80211\PYGZus{}hw *hw, struct netdev\PYGZus{}hw\PYGZus{}addr\PYGZus{}list *mc\PYGZus{}list);
  void (*configure\PYGZus{}filter)(struct ieee80211\PYGZus{}hw *hw,unsigned int changed\PYGZus{}flags,unsigned int *total\PYGZus{}flags, u64 multicast);
  void (*config\PYGZus{}iface\PYGZus{}filter)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif,unsigned int filter\PYGZus{}flags, unsigned int changed\PYGZus{}flags);
  int (*set\PYGZus{}tim)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}sta *sta, bool set);
  int (*set\PYGZus{}key)(struct ieee80211\PYGZus{}hw *hw, enum set\PYGZus{}key\PYGZus{}cmd cmd,struct ieee80211\PYGZus{}vif *vif, struct ieee80211\PYGZus{}sta *sta, struct ieee80211\PYGZus{}key\PYGZus{}conf *key);
  void (*update\PYGZus{}tkip\PYGZus{}key)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif,struct ieee80211\PYGZus{}key\PYGZus{}conf *conf,struct ieee80211\PYGZus{}sta *sta, u32 iv32, u16 *phase1key);
  void (*set\PYGZus{}rekey\PYGZus{}data)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, struct cfg80211\PYGZus{}gtk\PYGZus{}rekey\PYGZus{}data *data);
  void (*set\PYGZus{}default\PYGZus{}unicast\PYGZus{}key)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif, int idx);
  int (*hw\PYGZus{}scan)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif, struct ieee80211\PYGZus{}scan\PYGZus{}request *req);
  void (*cancel\PYGZus{}hw\PYGZus{}scan)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif);
  int (*sched\PYGZus{}scan\PYGZus{}start)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif,struct cfg80211\PYGZus{}sched\PYGZus{}scan\PYGZus{}request *req, struct ieee80211\PYGZus{}scan\PYGZus{}ies *ies);
  int (*sched\PYGZus{}scan\PYGZus{}stop)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif);
  void (*sw\PYGZus{}scan\PYGZus{}start)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, const u8 *mac\PYGZus{}addr);
  void (*sw\PYGZus{}scan\PYGZus{}complete)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif);
  int (*get\PYGZus{}stats)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}low\PYGZus{}level\PYGZus{}stats *stats);
  void (*get\PYGZus{}key\PYGZus{}seq)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}key\PYGZus{}conf *key, struct ieee80211\PYGZus{}key\PYGZus{}seq *seq);
  int (*set\PYGZus{}frag\PYGZus{}threshold)(struct ieee80211\PYGZus{}hw *hw, u32 value);
  int (*set\PYGZus{}rts\PYGZus{}threshold)(struct ieee80211\PYGZus{}hw *hw, u32 value);
  int (*sta\PYGZus{}add)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif, struct ieee80211\PYGZus{}sta *sta);
  int (*sta\PYGZus{}remove)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif, struct ieee80211\PYGZus{}sta *sta);
\PYGZsh{}ifdef CONFIG\PYGZus{}MAC80211\PYGZus{}DEBUGFS;
  void (*sta\PYGZus{}add\PYGZus{}debugfs)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif,struct ieee80211\PYGZus{}sta *sta, struct dentry *dir);
\PYGZsh{}endif;
  void (*sta\PYGZus{}notify)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif, enum sta\PYGZus{}notify\PYGZus{}cmd, struct ieee80211\PYGZus{}sta *sta);
  int (*sta\PYGZus{}state)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif,struct ieee80211\PYGZus{}sta *sta,enum ieee80211\PYGZus{}sta\PYGZus{}state old\PYGZus{}state, enum ieee80211\PYGZus{}sta\PYGZus{}state new\PYGZus{}state);
  void (*sta\PYGZus{}pre\PYGZus{}rcu\PYGZus{}remove)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, struct ieee80211\PYGZus{}sta *sta);
  void (*sta\PYGZus{}rc\PYGZus{}update)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif,struct ieee80211\PYGZus{}sta *sta, u32 changed);
  void (*sta\PYGZus{}rate\PYGZus{}tbl\PYGZus{}update)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, struct ieee80211\PYGZus{}sta *sta);
  void (*sta\PYGZus{}statistics)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif,struct ieee80211\PYGZus{}sta *sta, struct station\PYGZus{}info *sinfo);
  int (*conf\PYGZus{}tx)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, u16 ac, const struct ieee80211\PYGZus{}tx\PYGZus{}queue\PYGZus{}params *params);
  u64 (*get\PYGZus{}tsf)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif);
  void (*set\PYGZus{}tsf)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif, u64 tsf);
  void (*offset\PYGZus{}tsf)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif, s64 offset);
  void (*reset\PYGZus{}tsf)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif);
  int (*tx\PYGZus{}last\PYGZus{}beacon)(struct ieee80211\PYGZus{}hw *hw);
  int (*ampdu\PYGZus{}action)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, struct ieee80211\PYGZus{}ampdu\PYGZus{}params *params);
  int (*get\PYGZus{}survey)(struct ieee80211\PYGZus{}hw *hw, int idx, struct survey\PYGZus{}info *survey);
  void (*rfkill\PYGZus{}poll)(struct ieee80211\PYGZus{}hw *hw);
  void (*set\PYGZus{}coverage\PYGZus{}class)(struct ieee80211\PYGZus{}hw *hw, s16 coverage\PYGZus{}class);
\PYGZsh{}ifdef CONFIG\PYGZus{}NL80211\PYGZus{}TESTMODE;
  int (*testmode\PYGZus{}cmd)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif, void *data, int len);
  int (*testmode\PYGZus{}dump)(struct ieee80211\PYGZus{}hw *hw, struct sk\PYGZus{}buff *skb,struct netlink\PYGZus{}callback *cb, void *data, int len);
\PYGZsh{}endif;
  void (*flush)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif, u32 queues, bool drop);
  void (*channel\PYGZus{}switch)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, struct ieee80211\PYGZus{}channel\PYGZus{}switch *ch\PYGZus{}switch);
  int (*set\PYGZus{}antenna)(struct ieee80211\PYGZus{}hw *hw, u32 tx\PYGZus{}ant, u32 rx\PYGZus{}ant);
  int (*get\PYGZus{}antenna)(struct ieee80211\PYGZus{}hw *hw, u32 *tx\PYGZus{}ant, u32 *rx\PYGZus{}ant);
  int (*remain\PYGZus{}on\PYGZus{}channel)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif,struct ieee80211\PYGZus{}channel *chan,int duration, enum ieee80211\PYGZus{}roc\PYGZus{}type type);
  int (*cancel\PYGZus{}remain\PYGZus{}on\PYGZus{}channel)(struct ieee80211\PYGZus{}hw *hw);
  int (*set\PYGZus{}ringparam)(struct ieee80211\PYGZus{}hw *hw, u32 tx, u32 rx);
  void (*get\PYGZus{}ringparam)(struct ieee80211\PYGZus{}hw *hw, u32 *tx, u32 *tx\PYGZus{}max, u32 *rx, u32 *rx\PYGZus{}max);
  bool (*tx\PYGZus{}frames\PYGZus{}pending)(struct ieee80211\PYGZus{}hw *hw);
  int (*set\PYGZus{}bitrate\PYGZus{}mask)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif, const struct cfg80211\PYGZus{}bitrate\PYGZus{}mask *mask);
  void (*event\PYGZus{}callback)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, const struct ieee80211\PYGZus{}event *event);
  void (*allow\PYGZus{}buffered\PYGZus{}frames)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}sta *sta,u16 tids, int num\PYGZus{}frames,enum ieee80211\PYGZus{}frame\PYGZus{}release\PYGZus{}type reason, bool more\PYGZus{}data);
  void (*release\PYGZus{}buffered\PYGZus{}frames)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}sta *sta,u16 tids, int num\PYGZus{}frames,enum ieee80211\PYGZus{}frame\PYGZus{}release\PYGZus{}type reason, bool more\PYGZus{}data);
  int (*get\PYGZus{}et\PYGZus{}sset\PYGZus{}count)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif, int sset);
  void (*get\PYGZus{}et\PYGZus{}stats)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, struct ethtool\PYGZus{}stats *stats, u64 *data);
  void (*get\PYGZus{}et\PYGZus{}strings)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, u32 sset, u8 *data);
  void (*mgd\PYGZus{}prepare\PYGZus{}tx)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif);
  void (*mgd\PYGZus{}protect\PYGZus{}tdls\PYGZus{}discover)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif);
  int (*add\PYGZus{}chanctx)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}chanctx\PYGZus{}conf *ctx);
  void (*remove\PYGZus{}chanctx)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}chanctx\PYGZus{}conf *ctx);
  void (*change\PYGZus{}chanctx)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}chanctx\PYGZus{}conf *ctx, u32 changed);
  int (*assign\PYGZus{}vif\PYGZus{}chanctx)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, struct ieee80211\PYGZus{}chanctx\PYGZus{}conf *ctx);
  void (*unassign\PYGZus{}vif\PYGZus{}chanctx)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, struct ieee80211\PYGZus{}chanctx\PYGZus{}conf *ctx);
  int (*switch\PYGZus{}vif\PYGZus{}chanctx)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif\PYGZus{}chanctx\PYGZus{}switch *vifs,int n\PYGZus{}vifs, enum ieee80211\PYGZus{}chanctx\PYGZus{}switch\PYGZus{}mode mode);
  void (*reconfig\PYGZus{}complete)(struct ieee80211\PYGZus{}hw *hw, enum ieee80211\PYGZus{}reconfig\PYGZus{}type reconfig\PYGZus{}type);
\PYGZsh{}if IS\PYGZus{}ENABLED(CONFIG\PYGZus{}IPV6);
  void (*ipv6\PYGZus{}addr\PYGZus{}change)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, struct inet6\PYGZus{}dev *idev);
\PYGZsh{}endif;
  void (*channel\PYGZus{}switch\PYGZus{}beacon)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, struct cfg80211\PYGZus{}chan\PYGZus{}def *chandef);
  int (*pre\PYGZus{}channel\PYGZus{}switch)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, struct ieee80211\PYGZus{}channel\PYGZus{}switch *ch\PYGZus{}switch);
  int (*post\PYGZus{}channel\PYGZus{}switch)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif);
  int (*join\PYGZus{}ibss)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif);
  void (*leave\PYGZus{}ibss)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif);
  u32 (*get\PYGZus{}expected\PYGZus{}throughput)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}sta *sta);
  int (*get\PYGZus{}txpower)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif, int *dbm);
  int (*tdls\PYGZus{}channel\PYGZus{}switch)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif,struct ieee80211\PYGZus{}sta *sta, u8 oper\PYGZus{}class,struct cfg80211\PYGZus{}chan\PYGZus{}def *chandef, struct sk\PYGZus{}buff *tmpl\PYGZus{}skb, u32 ch\PYGZus{}sw\PYGZus{}tm\PYGZus{}ie);
  void (*tdls\PYGZus{}cancel\PYGZus{}channel\PYGZus{}switch)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, struct ieee80211\PYGZus{}sta *sta);
  void (*tdls\PYGZus{}recv\PYGZus{}channel\PYGZus{}switch)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, struct ieee80211\PYGZus{}tdls\PYGZus{}ch\PYGZus{}sw\PYGZus{}params *params);
  void (*wake\PYGZus{}tx\PYGZus{}queue)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}txq *txq);
  void (*sync\PYGZus{}rx\PYGZus{}queues)(struct ieee80211\PYGZus{}hw *hw);
  int (*start\PYGZus{}nan)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, struct cfg80211\PYGZus{}nan\PYGZus{}conf *conf);
  int (*stop\PYGZus{}nan)(struct ieee80211\PYGZus{}hw *hw, struct ieee80211\PYGZus{}vif *vif);
  int (*nan\PYGZus{}change\PYGZus{}conf)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, struct cfg80211\PYGZus{}nan\PYGZus{}conf *conf, u32 changes);
  int (*add\PYGZus{}nan\PYGZus{}func)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, const struct cfg80211\PYGZus{}nan\PYGZus{}func *nan\PYGZus{}func);
  void (*del\PYGZus{}nan\PYGZus{}func)(struct ieee80211\PYGZus{}hw *hw,struct ieee80211\PYGZus{}vif *vif, u8 instance\PYGZus{}id);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{tx}}] \leavevmode
Handler that 802.11 module calls for each transmitted frame.
skb contains the buffer starting from the IEEE 802.11 header.
The low-level driver should send the frame out based on
configuration in the TX control data. This handler should,
preferably, never fail and stop queues appropriately.
Must be atomic.

\item[{\code{start}}] \leavevmode
Called before the first netdevice attached to the hardware
is enabled. This should turn on the hardware and must turn on
frame reception (for possibly enabled monitor interfaces.)
Returns negative error codes, these may be seen in userspace,
or zero.
When the device is started it should not have a MAC address
to avoid acknowledging frames before a non-monitor device
is added.
Must be implemented and can sleep.

\item[{\code{stop}}] \leavevmode
Called after last netdevice attached to the hardware
is disabled. This should turn off the hardware (at least
it must turn off frame reception.)
May be called right after add\_interface if that rejects
an interface. If you added any work onto the mac80211 workqueue
you should ensure to cancel it on this callback.
Must be implemented and can sleep.

\item[{\code{suspend}}] \leavevmode
Suspend the device; mac80211 itself will quiesce before and
stop transmitting and doing any other configuration, and then
ask the device to suspend. This is only invoked when WoWLAN is
configured, otherwise the device is deconfigured completely and
reconfigured at resume time.
The driver may also impose special conditions under which it
wants to use the ``normal'' suspend (deconfigure), say if it only
supports WoWLAN when the device is associated. In this case, it
must return 1 from this function.

\item[{\code{resume}}] \leavevmode
If WoWLAN was configured, this indicates that mac80211 is
now resuming its operation, after this the device must be fully
functional again. If this returns an error, the only way out is
to also unregister the device. If it returns 1, then mac80211
will also go through the regular complete restart on resume.

\item[{\code{set\_wakeup}}] \leavevmode
Enable or disable wakeup when WoWLAN configuration is
modified. The reason is that \code{device\_set\_wakeup\_enable()} is
supposed to be called when the configuration changes, not only
in \code{suspend()}.

\item[{\code{add\_interface}}] \leavevmode
Called when a netdevice attached to the hardware is
enabled. Because it is not called for monitor mode devices, \textbf{start}
and \textbf{stop} must be implemented.
The driver should perform any initialization it needs before
the device can be enabled. The initial configuration for the
interface is given in the conf parameter.
The callback may refuse to add an interface by returning a
negative error code (which will be seen in userspace.)
Must be implemented and can sleep.

\item[{\code{change\_interface}}] \leavevmode
Called when a netdevice changes type. This callback
is optional, but only if it is supported can interface types be
switched while the interface is UP. The callback may sleep.
Note that while an interface is being switched, it will not be
found by the interface iteration callbacks.

\item[{\code{remove\_interface}}] \leavevmode
Notifies a driver that an interface is going down.
The \textbf{stop} callback is called after this if it is the last interface
and no monitor interfaces are present.
When all interfaces are removed, the MAC address in the hardware
must be cleared so the device no longer acknowledges packets,
the mac\_addr member of the conf structure is, however, set to the
MAC address of the device going away.
Hence, this callback must be implemented. It can sleep.

\item[{\code{config}}] \leavevmode
Handler for configuration requests. IEEE 802.11 code calls this
function to change hardware configuration, e.g., channel.
This function should never fail but returns a negative error code
if it does. The callback can sleep.

\item[{\code{bss\_info\_changed}}] \leavevmode
Handler for configuration requests related to BSS
parameters that may vary during BSS's lifespan, and may affect low
level driver (e.g. assoc/disassoc status, erp parameters).
This function should not be used if no BSS has been set, unless
for association indication. The \textbf{changed} parameter indicates which
of the bss parameters has changed when a call is made. The callback
can sleep.

\item[{\code{start\_ap}}] \leavevmode
Start operation on the AP interface, this is called after all the
information in bss\_conf is set and beacon can be retrieved. A channel
context is bound before this is called. Note that if the driver uses
software scan or ROC, this (and \textbf{stop\_ap}) isn't called when the AP is
just ``paused'' for scanning/ROC, which is indicated by the beacon being
disabled/enabled via \textbf{bss\_info\_changed}.

\item[{\code{stop\_ap}}] \leavevmode
Stop operation on the AP interface.

\item[{\code{prepare\_multicast}}] \leavevmode
Prepare for multicast filter configuration.
This callback is optional, and its return value is passed
to \code{configure\_filter()}. This callback must be atomic.

\item[{\code{configure\_filter}}] \leavevmode
Configure the device's RX filter.
See the section ``Frame filtering'' for more information.
This callback must be implemented and can sleep.

\item[{\code{config\_iface\_filter}}] \leavevmode
Configure the interface's RX filter.
This callback is optional and is used to configure which frames
should be passed to mac80211. The filter\_flags is the combination
of FIF\_* flags. The changed\_flags is a bit mask that indicates
which flags are changed.
This callback can sleep.

\item[{\code{set\_tim}}] \leavevmode
Set TIM bit. mac80211 calls this function when a TIM bit
must be set or cleared for a given STA. Must be atomic.

\item[{\code{set\_key}}] \leavevmode
See the section ``Hardware crypto acceleration''
This callback is only called between add\_interface and
remove\_interface calls, i.e. while the given virtual interface
is enabled.
Returns a negative error code if the key can't be added.
The callback can sleep.

\item[{\code{update\_tkip\_key}}] \leavevmode
See the section ``Hardware crypto acceleration''
This callback will be called in the context of Rx. Called for drivers
which set IEEE80211\_KEY\_FLAG\_TKIP\_REQ\_RX\_P1\_KEY.
The callback must be atomic.

\item[{\code{set\_rekey\_data}}] \leavevmode
If the device supports GTK rekeying, for example while the
host is suspended, it can assign this callback to retrieve the data
necessary to do GTK rekeying, this is the KEK, KCK and replay counter.
After rekeying was done it should (for example during resume) notify
userspace of the new replay counter using \code{ieee80211\_gtk\_rekey\_notify()}.

\item[{\code{set\_default\_unicast\_key}}] \leavevmode
Set the default (unicast) key index, useful for
WEP when the device sends data packets autonomously, e.g. for ARP
offloading. The index can be 0-3, or -1 for unsetting it.

\item[{\code{hw\_scan}}] \leavevmode
Ask the hardware to service the scan request, no need to start
the scan state machine in stack. The scan must honour the channel
configuration done by the regulatory agent in the wiphy's
registered bands. The hardware (or the driver) needs to make sure
that power save is disabled.
The \textbf{req} ie/ie\_len members are rewritten by mac80211 to contain the
entire IEs after the SSID, so that drivers need not look at these
at all but just send them after the SSID -- mac80211 includes the
(extended) supported rates and HT information (where applicable).
When the scan finishes, {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_scan_completed]{\emph{\code{ieee80211\_scan\_completed()}}}} must be called;
note that it also must be called when the scan cannot finish due to
any error unless this callback returned a negative error code.
The callback can sleep.

\item[{\code{cancel\_hw\_scan}}] \leavevmode
Ask the low-level tp cancel the active hw scan.
The driver should ask the hardware to cancel the scan (if possible),
but the scan will be completed only after the driver will call
{\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_scan_completed]{\emph{\code{ieee80211\_scan\_completed()}}}}.
This callback is needed for wowlan, to prevent enqueueing a new
scan\_work after the low-level driver was already suspended.
The callback can sleep.

\item[{\code{sched\_scan\_start}}] \leavevmode
Ask the hardware to start scanning repeatedly at
specific intervals.  The driver must call the
\code{ieee80211\_sched\_scan\_results()} function whenever it finds results.
This process will continue until sched\_scan\_stop is called.

\item[{\code{sched\_scan\_stop}}] \leavevmode
Tell the hardware to stop an ongoing scheduled scan.
In this case, \code{ieee80211\_sched\_scan\_stopped()} must not be called.

\item[{\code{sw\_scan\_start}}] \leavevmode
Notifier function that is called just before a software scan
is started. Can be NULL, if the driver doesn't need this notification.
The mac\_addr parameter allows supporting NL80211\_SCAN\_FLAG\_RANDOM\_ADDR,
the driver may set the NL80211\_FEATURE\_SCAN\_RANDOM\_MAC\_ADDR flag if it
can use this parameter. The callback can sleep.

\item[{\code{sw\_scan\_complete}}] \leavevmode
Notifier function that is called just after a
software scan finished. Can be NULL, if the driver doesn't need
this notification.
The callback can sleep.

\item[{\code{get\_stats}}] \leavevmode
Return low-level statistics.
Returns zero if statistics are available.
The callback can sleep.

\item[{\code{get\_key\_seq}}] \leavevmode
If your device implements encryption in hardware and does
IV/PN assignment then this callback should be provided to read the
IV/PN for the given key from hardware.
The callback must be atomic.

\item[{\code{set\_frag\_threshold}}] \leavevmode
Configuration of fragmentation threshold. Assign this
if the device does fragmentation by itself. Note that to prevent the
stack from doing fragmentation IEEE80211\_HW\_SUPPORTS\_TX\_FRAG
should be set as well.
The callback can sleep.

\item[{\code{set\_rts\_threshold}}] \leavevmode
Configuration of RTS threshold (if device needs it)
The callback can sleep.

\item[{\code{sta\_add}}] \leavevmode
Notifies low level driver about addition of an associated station,
AP, IBSS/WDS/mesh peer etc. This callback can sleep.

\item[{\code{sta\_remove}}] \leavevmode
Notifies low level driver about removal of an associated
station, AP, IBSS/WDS/mesh peer etc. Note that after the callback
returns it isn't safe to use the pointer, not even RCU protected;
no RCU grace period is guaranteed between returning here and freeing
the station. See \textbf{sta\_pre\_rcu\_remove} if needed.
This callback can sleep.

\item[{\code{sta\_add\_debugfs}}] \leavevmode
Drivers can use this callback to add debugfs files
when a station is added to mac80211's station list. This callback
should be within a CONFIG\_MAC80211\_DEBUGFS conditional. This
callback can sleep.

\item[{\code{sta\_notify}}] \leavevmode
Notifies low level driver about power state transition of an
associated station, AP,  IBSS/WDS/mesh peer etc. For a VIF operating
in AP mode, this callback will not be called when the flag
\code{IEEE80211\_HW\_AP\_LINK\_PS} is set. Must be atomic.

\item[{\code{sta\_state}}] \leavevmode
Notifies low level driver about state transition of a
station (which can be the AP, a client, IBSS/WDS/mesh peer etc.)
This callback is mutually exclusive with \textbf{sta\_add}/\textbf{sta\_remove}.
It must not fail for down transitions but may fail for transitions
up the list of states. Also note that after the callback returns it
isn't safe to use the pointer, not even RCU protected - no RCU grace
period is guaranteed between returning here and freeing the station.
See \textbf{sta\_pre\_rcu\_remove} if needed.
The callback can sleep.

\item[{\code{sta\_pre\_rcu\_remove}}] \leavevmode
Notify driver about station removal before RCU
synchronisation. This is useful if a driver needs to have station
pointers protected using RCU, it can then use this call to clear
the pointers instead of waiting for an RCU grace period to elapse
in \textbf{sta\_state}.
The callback can sleep.

\item[{\code{sta\_rc\_update}}] \leavevmode
Notifies the driver of changes to the bitrates that can be
used to transmit to the station. The changes are advertised with bits
from {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_rate_control_changed]{\emph{\code{enum ieee80211\_rate\_control\_changed}}}} and the values are reflected
in the station data. This callback should only be used when the driver
uses hardware rate control (\code{IEEE80211\_HW\_HAS\_RATE\_CONTROL}) since
otherwise the rate control algorithm is notified directly.
Must be atomic.

\item[{\code{sta\_rate\_tbl\_update}}] \leavevmode
Notifies the driver that the rate table changed. This
is only used if the configured rate control algorithm actually uses
the new rate table API, and is therefore optional. Must be atomic.

\item[{\code{sta\_statistics}}] \leavevmode
Get statistics for this station. For example with beacon
filtering, the statistics kept by mac80211 might not be accurate, so
let the driver pre-fill the statistics. The driver can fill most of
the values (indicating which by setting the filled bitmap), but not
all of them make sense - see the source for which ones are possible.
Statistics that the driver doesn't fill will be filled by mac80211.
The callback can sleep.

\item[{\code{conf\_tx}}] \leavevmode
Configure TX queue parameters (EDCF (aifs, cw\_min, cw\_max),
bursting) for a hardware TX queue.
Returns a negative error code on failure.
The callback can sleep.

\item[{\code{get\_tsf}}] \leavevmode
Get the current TSF timer value from firmware/hardware. Currently,
this is only used for IBSS mode BSSID merging and debugging. Is not a
required function.
The callback can sleep.

\item[{\code{set\_tsf}}] \leavevmode
Set the TSF timer to the specified value in the firmware/hardware.
Currently, this is only used for IBSS mode debugging. Is not a
required function.
The callback can sleep.

\item[{\code{offset\_tsf}}] \leavevmode
Offset the TSF timer by the specified value in the
firmware/hardware.  Preferred to set\_tsf as it avoids delay between
calling \code{set\_tsf()} and hardware getting programmed, which will show up
as TSF delay. Is not a required function.
The callback can sleep.

\item[{\code{reset\_tsf}}] \leavevmode
Reset the TSF timer and allow firmware/hardware to synchronize
with other STAs in the IBSS. This is only used in IBSS mode. This
function is optional if the firmware/hardware takes full care of
TSF synchronization.
The callback can sleep.

\item[{\code{tx\_last\_beacon}}] \leavevmode
Determine whether the last IBSS beacon was sent by us.
This is needed only for IBSS mode and the result of this function is
used to determine whether to reply to Probe Requests.
Returns non-zero if this device sent the last beacon.
The callback can sleep.

\item[{\code{ampdu\_action}}] \leavevmode
Perform a certain A-MPDU action.
The RA/TID combination determines the destination and TID we want
the ampdu action to be performed for. The action is defined through
ieee80211\_ampdu\_mlme\_action.
When the action is set to \code{IEEE80211\_AMPDU\_TX\_OPERATIONAL} the driver
may neither send aggregates containing more subframes than \textbf{buf\_size}
nor send aggregates in a way that lost frames would exceed the
buffer size. If just limiting the aggregate size, this would be
possible with a buf\_size of 8:
\begin{itemize}
\item {} 
\code{TX: 1.....7}

\item {} 
\code{RX:  2....7} (lost frame \#1)

\item {} 
\code{TX:        8..1...}

\end{itemize}

which is invalid since \#1 was now re-transmitted well past the
buffer size of 8. Correct ways to retransmit \#1 would be:
\begin{itemize}
\item {} 
\code{TX:        1   or}

\item {} 
\code{TX:        18  or}

\item {} 
\code{TX:        81}

\end{itemize}

Even \code{189} would be wrong since 1 could be lost again.

Returns a negative error code on failure.
The callback can sleep.

\item[{\code{get\_survey}}] \leavevmode
Return per-channel survey information

\item[{\code{rfkill\_poll}}] \leavevmode
Poll rfkill hardware state. If you need this, you also
need to set wiphy-\textgreater{}rfkill\_poll to \code{true} before registration,
and need to call {\hyperref[driver\string-api/80211/cfg80211:c.wiphy_rfkill_set_hw_state]{\emph{\code{wiphy\_rfkill\_set\_hw\_state()}}}} in the callback.
The callback can sleep.

\item[{\code{set\_coverage\_class}}] \leavevmode
Set slot time for given coverage class as specified
in IEEE 802.11-2007 section 17.3.8.6 and modify ACK timeout
accordingly; coverage class equals to -1 to enable ACK timeout
estimation algorithm (dynack). To disable dynack set valid value for
coverage class. This callback is not required and may sleep.

\item[{\code{testmode\_cmd}}] \leavevmode
Implement a cfg80211 test mode command. The passed \textbf{vif} may
be \code{NULL}. The callback can sleep.

\item[{\code{testmode\_dump}}] \leavevmode
Implement a cfg80211 test mode dump. The callback can sleep.

\item[{\code{flush}}] \leavevmode
Flush all pending frames from the hardware queue, making sure
that the hardware queues are empty. The \textbf{queues} parameter is a bitmap
of queues to flush, which is useful if different virtual interfaces
use different hardware queues; it may also indicate all queues.
If the parameter \textbf{drop} is set to \code{true}, pending frames may be dropped.
Note that vif can be NULL.
The callback can sleep.

\item[{\code{channel\_switch}}] \leavevmode
Drivers that need (or want) to offload the channel
switch operation for CSAs received from the AP may implement this
callback. They must then call \code{ieee80211\_chswitch\_done()} to indicate
completion of the channel switch.

\item[{\code{set\_antenna}}] \leavevmode
Set antenna configuration (tx\_ant, rx\_ant) on the device.
Parameters are bitmaps of allowed antennas to use for TX/RX. Drivers may
reject TX/RX mask combinations they cannot support by returning -EINVAL
(also see nl80211.h \textbf{NL80211\_ATTR\_WIPHY\_ANTENNA\_TX}).

\item[{\code{get\_antenna}}] \leavevmode
Get current antenna configuration from device (tx\_ant, rx\_ant).

\item[{\code{remain\_on\_channel}}] \leavevmode
Starts an off-channel period on the given channel, must
call back to \code{ieee80211\_ready\_on\_channel()} when on that channel. Note
that normal channel traffic is not stopped as this is intended for hw
offload. Frames to transmit on the off-channel channel are transmitted
normally except for the \code{IEEE80211\_TX\_CTL\_TX\_OFFCHAN} flag. When the
duration (which will always be non-zero) expires, the driver must call
\code{ieee80211\_remain\_on\_channel\_expired()}.
Note that this callback may be called while the device is in IDLE and
must be accepted in this case.
This callback may sleep.

\item[{\code{cancel\_remain\_on\_channel}}] \leavevmode
Requests that an ongoing off-channel period is
aborted before it expires. This callback may sleep.

\item[{\code{set\_ringparam}}] \leavevmode
Set tx and rx ring sizes.

\item[{\code{get\_ringparam}}] \leavevmode
Get tx and rx ring current and maximum sizes.

\item[{\code{tx\_frames\_pending}}] \leavevmode
Check if there is any pending frame in the hardware
queues before entering power save.

\item[{\code{set\_bitrate\_mask}}] \leavevmode
Set a mask of rates to be used for rate control selection
when transmitting a frame. Currently only legacy rates are handled.
The callback can sleep.

\item[{\code{event\_callback}}] \leavevmode
Notify driver about any event in mac80211. See
\code{enum ieee80211\_event\_type} for the different types.
The callback must be atomic.

\item[{\code{allow\_buffered\_frames}}] \leavevmode
Prepare device to allow the given number of frames
to go out to the given station. The frames will be sent by mac80211
via the usual TX path after this call. The TX information for frames
released will also have the \code{IEEE80211\_TX\_CTL\_NO\_PS\_BUFFER} flag set
and the last one will also have \code{IEEE80211\_TX\_STATUS\_EOSP} set. In case
frames from multiple TIDs are released and the driver might reorder
them between the TIDs, it must set the \code{IEEE80211\_TX\_STATUS\_EOSP} flag
on the last frame and clear it on all others and also handle the EOSP
bit in the QoS header correctly. Alternatively, it can also call the
{\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta_eosp]{\emph{\code{ieee80211\_sta\_eosp()}}}} function.
The \textbf{tids} parameter is a bitmap and tells the driver which TIDs the
frames will be on; it will at most have two bits set.
This callback must be atomic.

\item[{\code{release\_buffered\_frames}}] \leavevmode
Release buffered frames according to the given
parameters. In the case where the driver buffers some frames for
sleeping stations mac80211 will use this callback to tell the driver
to release some frames, either for PS-poll or uAPSD.
Note that if the \textbf{more\_data} parameter is \code{false} the driver must check
if there are more frames on the given TIDs, and if there are more than
the frames being released then it must still set the more-data bit in
the frame. If the \textbf{more\_data} parameter is \code{true}, then of course the
more-data bit must always be set.
The \textbf{tids} parameter tells the driver which TIDs to release frames
from, for PS-poll it will always have only a single bit set.
In the case this is used for a PS-poll initiated release, the
\textbf{num\_frames} parameter will always be 1 so code can be shared. In
this case the driver must also set \code{IEEE80211\_TX\_STATUS\_EOSP} flag
on the TX status (and must report TX status) so that the PS-poll
period is properly ended. This is used to avoid sending multiple
responses for a retried PS-poll frame.
In the case this is used for uAPSD, the \textbf{num\_frames} parameter may be
bigger than one, but the driver may send fewer frames (it must send
at least one, however). In this case it is also responsible for
setting the EOSP flag in the QoS header of the frames. Also, when the
service period ends, the driver must set \code{IEEE80211\_TX\_STATUS\_EOSP}
on the last frame in the SP. Alternatively, it may call the function
{\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta_eosp]{\emph{\code{ieee80211\_sta\_eosp()}}}} to inform mac80211 of the end of the SP.
This callback must be atomic.

\item[{\code{get\_et\_sset\_count}}] \leavevmode
Ethtool API to get string-set count.

\item[{\code{get\_et\_stats}}] \leavevmode
Ethtool API to get a set of u64 stats.

\item[{\code{get\_et\_strings}}] \leavevmode
Ethtool API to get a set of strings to describe stats
and perhaps other supported types of ethtool data-sets.

\item[{\code{mgd\_prepare\_tx}}] \leavevmode
Prepare for transmitting a management frame for association
before associated. In multi-channel scenarios, a virtual interface is
bound to a channel before it is associated, but as it isn't associated
yet it need not necessarily be given airtime, in particular since any
transmission to a P2P GO needs to be synchronized against the GO's
powersave state. mac80211 will call this function before transmitting a
management frame prior to having successfully associated to allow the
driver to give it channel time for the transmission, to get a response
and to be able to synchronize with the GO.
The callback will be called before each transmission and upon return
mac80211 will transmit the frame right away.
The callback is optional and can (should!) sleep.

\item[{\code{mgd\_protect\_tdls\_discover}}] \leavevmode
Protect a TDLS discovery session. After sending
a TDLS discovery-request, we expect a reply to arrive on the AP's
channel. We must stay on the channel (no PSM, scan, etc.), since a TDLS
setup-response is a direct packet not buffered by the AP.
mac80211 will call this function just before the transmission of a TDLS
discovery-request. The recommended period of protection is at least
2 * (DTIM period).
The callback is optional and can sleep.

\item[{\code{add\_chanctx}}] \leavevmode
Notifies device driver about new channel context creation.
This callback may sleep.

\item[{\code{remove\_chanctx}}] \leavevmode
Notifies device driver about channel context destruction.
This callback may sleep.

\item[{\code{change\_chanctx}}] \leavevmode
Notifies device driver about channel context changes that
may happen when combining different virtual interfaces on the same
channel context with different settings
This callback may sleep.

\item[{\code{assign\_vif\_chanctx}}] \leavevmode
Notifies device driver about channel context being bound
to vif. Possible use is for hw queue remapping.
This callback may sleep.

\item[{\code{unassign\_vif\_chanctx}}] \leavevmode
Notifies device driver about channel context being
unbound from vif.
This callback may sleep.

\item[{\code{switch\_vif\_chanctx}}] \leavevmode
switch a number of vifs from one chanctx to
another, as specified in the list of
\textbf{ieee80211\_vif\_chanctx\_switch} passed to the driver, according
to the mode defined in \code{ieee80211\_chanctx\_switch\_mode}.
This callback may sleep.

\item[{\code{reconfig\_complete}}] \leavevmode
Called after a call to \code{ieee80211\_restart\_hw()} and
during resume, when the reconfiguration has completed.
This can help the driver implement the reconfiguration step (and
indicate mac80211 is ready to receive frames).
This callback may sleep.

\item[{\code{ipv6\_addr\_change}}] \leavevmode
IPv6 address assignment on the given interface changed.
Currently, this is only called for managed or P2P client interfaces.
This callback is optional; it must not sleep.

\item[{\code{channel\_switch\_beacon}}] \leavevmode
Starts a channel switch to a new channel.
Beacons are modified to include CSA or ECSA IEs before calling this
function. The corresponding count fields in these IEs must be
decremented, and when they reach 1 the driver must call
\code{ieee80211\_csa\_finish()}. Drivers which use {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_beacon_get]{\emph{\code{ieee80211\_beacon\_get()}}}}
get the csa counter decremented by mac80211, but must check if it is
1 using \code{ieee80211\_csa\_is\_complete()} after the beacon has been
transmitted and then call \code{ieee80211\_csa\_finish()}.
If the CSA count starts as zero or 1, this function will not be called,
since there won't be any time to beacon before the switch anyway.

\item[{\code{pre\_channel\_switch}}] \leavevmode
This is an optional callback that is called
before a channel switch procedure is started (ie. when a STA
gets a CSA or a userspace initiated channel-switch), allowing
the driver to prepare for the channel switch.

\item[{\code{post\_channel\_switch}}] \leavevmode
This is an optional callback that is called
after a channel switch procedure is completed, allowing the
driver to go back to a normal configuration.

\item[{\code{join\_ibss}}] \leavevmode
Join an IBSS (on an IBSS interface); this is called after all
information in bss\_conf is set up and the beacon can be retrieved. A
channel context is bound before this is called.

\item[{\code{leave\_ibss}}] \leavevmode
Leave the IBSS again.

\item[{\code{get\_expected\_throughput}}] \leavevmode
extract the expected throughput towards the
specified station. The returned value is expressed in Kbps. It returns 0
if the RC algorithm does not have proper data to provide.

\item[{\code{get\_txpower}}] \leavevmode
get current maximum tx power (in dBm) based on configuration
and hardware limits.

\item[{\code{tdls\_channel\_switch}}] \leavevmode
Start channel-switching with a TDLS peer. The driver
is responsible for continually initiating channel-switching operations
and returning to the base channel for communication with the AP. The
driver receives a channel-switch request template and the location of
the switch-timing IE within the template as part of the invocation.
The template is valid only within the call, and the driver can
optionally copy the skb for further re-use.

\item[{\code{tdls\_cancel\_channel\_switch}}] \leavevmode
Stop channel-switching with a TDLS peer. Both
peers must be on the base channel when the call completes.

\item[{\code{tdls\_recv\_channel\_switch}}] \leavevmode
a TDLS channel-switch related frame (request or
response) has been received from a remote peer. The driver gets
parameters parsed from the incoming frame and may use them to continue
an ongoing channel-switch operation. In addition, a channel-switch
response template is provided, together with the location of the
switch-timing IE within the template. The skb can only be used within
the function call.

\item[{\code{wake\_tx\_queue}}] \leavevmode
Called when new packets have been added to the queue.

\item[{\code{sync\_rx\_queues}}] \leavevmode
Process all pending frames in RSS queues. This is a
synchronization which is needed in case driver has in its RSS queues
pending frames that were received prior to the control path action
currently taken (e.g. disassociation) but are not processed yet.

\item[{\code{start\_nan}}] \leavevmode
join an existing NAN cluster, or create a new one.

\item[{\code{stop\_nan}}] \leavevmode
leave the NAN cluster.

\item[{\code{nan\_change\_conf}}] \leavevmode
change NAN configuration. The data in cfg80211\_nan\_conf
contains full new configuration and changes specify which parameters
are changed with respect to the last NAN config.
The driver gets both full configuration and the changed parameters since
some devices may need the full configuration while others need only the
changed parameters.

\item[{\code{add\_nan\_func}}] \leavevmode
Add a NAN function. Returns 0 on success. The data in
cfg80211\_nan\_func must not be referenced outside the scope of
this call.

\item[{\code{del\_nan\_func}}] \leavevmode
Remove a NAN function. The driver must call
\code{ieee80211\_nan\_func\_terminated()} with
NL80211\_NAN\_FUNC\_TERM\_REASON\_USER\_REQUEST reason code upon removal.

\end{description}

\textbf{Description}

This structure contains various callbacks that the driver may
handle or, in some cases, must handle, for example to configure
the hardware to a new channel or to transmit a frame.
\index{ieee80211\_alloc\_hw (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_alloc_hw}\pysiglinewithargsret{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} * \bfcode{ieee80211\_alloc\_hw}}{size\_t\emph{ priv\_data\_len}, const struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_ops]{\emph{ieee80211\_ops}}} *\emph{ ops}}{}
Allocate a new hardware device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{size\_t priv\_data\_len}}] \leavevmode
length of private data

\item[{\code{const struct ieee80211\_ops * ops}}] \leavevmode
callbacks for this device

\end{description}

\textbf{Description}

This must be called once for each hardware device. The returned pointer
must be used to refer to this device when calling other functions.
mac80211 allocates a private data area for the driver pointed to by
\textbf{priv} in {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{\code{struct ieee80211\_hw}}}}, the size of this area is given as
\textbf{priv\_data\_len}.

\textbf{Return}

A pointer to the new hardware device, or \code{NULL} on error.
\index{ieee80211\_register\_hw (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_register_hw}\pysiglinewithargsret{int \bfcode{ieee80211\_register\_hw}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}}{}
Register hardware device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the device to register as returned by {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_alloc_hw]{\emph{\code{ieee80211\_alloc\_hw()}}}}

\end{description}

\textbf{Description}

You must call this function before any other functions in
mac80211. Note that before a hardware can be registered, you
need to fill the contained wiphy's information.

\textbf{Return}

0 on success. An error code otherwise.
\index{ieee80211\_unregister\_hw (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_unregister_hw}\pysiglinewithargsret{void \bfcode{ieee80211\_unregister\_hw}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}}{}
Unregister a hardware device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware to unregister

\end{description}

\textbf{Description}

This function instructs mac80211 to free allocated resources
and unregister netdevices from the networking subsystem.
\index{ieee80211\_free\_hw (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_free_hw}\pysiglinewithargsret{void \bfcode{ieee80211\_free\_hw}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}}{}
free hardware descriptor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware to free

\end{description}

\textbf{Description}

This function frees everything that was allocated, including the
private data for the driver. You must call {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_unregister_hw]{\emph{\code{ieee80211\_unregister\_hw()}}}}
before calling this function.


\subsection{PHY configuration}
\label{driver-api/80211/mac80211:phy-configuration}
TBD

This chapter should describe PHY handling including start/stop callbacks
and the various structures used.
\index{ieee80211\_conf (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_conf}\pysigline{struct \bfcode{ieee80211\_conf}}
configuration of the device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}conf \PYGZob{}
  u32 flags;
  int power\PYGZus{}level, dynamic\PYGZus{}ps\PYGZus{}timeout;
  u16 listen\PYGZus{}interval;
  u8 ps\PYGZus{}dtim\PYGZus{}period;
  u8 long\PYGZus{}frame\PYGZus{}max\PYGZus{}tx\PYGZus{}count, short\PYGZus{}frame\PYGZus{}max\PYGZus{}tx\PYGZus{}count;
  struct cfg80211\PYGZus{}chan\PYGZus{}def chandef;
  bool radar\PYGZus{}enabled;
  enum ieee80211\PYGZus{}smps\PYGZus{}mode smps\PYGZus{}mode;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{flags}}] \leavevmode
configuration flags defined above

\item[{\code{power\_level}}] \leavevmode
requested transmit power (in dBm), backward compatibility
value only that is set to the minimum of all interfaces

\item[{\code{dynamic\_ps\_timeout}}] \leavevmode
The dynamic powersave timeout (in ms), see the
powersave documentation below. This variable is valid only when
the CONF\_PS flag is set.

\item[{\code{listen\_interval}}] \leavevmode
listen interval in units of beacon interval

\item[{\code{ps\_dtim\_period}}] \leavevmode
The DTIM period of the AP we're connected to, for use
in power saving. Power saving will not be enabled until a beacon
has been received and the DTIM period is known.

\item[{\code{long\_frame\_max\_tx\_count}}] \leavevmode
Maximum number of transmissions for a ``long'' frame
(a frame not RTS protected), called ``dot11LongRetryLimit'' in 802.11,
but actually means the number of transmissions not the number of retries

\item[{\code{short\_frame\_max\_tx\_count}}] \leavevmode
Maximum number of transmissions for a ``short''
frame, called ``dot11ShortRetryLimit'' in 802.11, but actually means the
number of transmissions not the number of retries

\item[{\code{chandef}}] \leavevmode
the channel definition to tune to

\item[{\code{radar\_enabled}}] \leavevmode
whether radar detection is enabled

\item[{\code{smps\_mode}}] \leavevmode
spatial multiplexing powersave mode; note that
\code{IEEE80211\_SMPS\_STATIC} is used when the device is not
configured for an HT channel.
Note that this is only valid if channel contexts are not used,
otherwise each channel context has the number of chains listed.

\end{description}

\textbf{Description}

This struct indicates how the driver shall configure the hardware.
\index{ieee80211\_conf\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_conf_flags}\pysigline{enum \bfcode{ieee80211\_conf\_flags}}
configuration flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{IEEE80211\_CONF\_MONITOR}}] \leavevmode
there's a monitor interface present -- use this
to determine for example whether to calculate timestamps for packets
or not, do not use instead of filter flags!

\item[{\code{IEEE80211\_CONF\_PS}}] \leavevmode
Enable 802.11 power save mode (managed mode only).
This is the power save mode defined by IEEE 802.11-2007 section 11.2,
meaning that the hardware still wakes up for beacons, is able to
transmit frames and receive the possible acknowledgment frames.
Not to be confused with hardware specific wakeup/sleep states,
driver is responsible for that. See the section ``Powersave support''
for more.

\item[{\code{IEEE80211\_CONF\_IDLE}}] \leavevmode
The device is running, but idle; if the flag is set
the driver should be prepared to handle configuration requests but
may turn the device off as much as possible. Typically, this flag will
be set when an interface is set UP but not associated or scanning, but
it can also be unset in that case when monitor interfaces are active.

\item[{\code{IEEE80211\_CONF\_OFFCHANNEL}}] \leavevmode
The device is currently not on its main
operating channel.

\end{description}

\textbf{Description}

Flags to define PHY configuration options


\subsection{Virtual interfaces}
\label{driver-api/80211/mac80211:virtual-interfaces}
TBD

This chapter should describe virtual interface basics that are relevant
to the driver (VLANs, MGMT etc are not.) It should explain the use of
the add\_iface/remove\_iface callbacks as well as the interface
configuration callbacks.

Things related to AP mode should be discussed there.

Things related to supporting multiple interfaces should be in the
appropriate chapter, a BIG FAT note should be here about this though and
the recommendation to allow only a single interface in STA mode at
first!
\index{ieee80211\_vif (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_vif}\pysigline{struct \bfcode{ieee80211\_vif}}
per-interface data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}vif \PYGZob{}
  enum nl80211\PYGZus{}iftype type;
  struct ieee80211\PYGZus{}bss\PYGZus{}conf bss\PYGZus{}conf;
  u8 addr[ETH\PYGZus{}ALEN] ;
  bool p2p;
  bool csa\PYGZus{}active;
  bool mu\PYGZus{}mimo\PYGZus{}owner;
  u8 cab\PYGZus{}queue;
  u8 hw\PYGZus{}queue[IEEE80211\PYGZus{}NUM\PYGZus{}ACS];
  struct ieee80211\PYGZus{}txq *txq;
  struct ieee80211\PYGZus{}chanctx\PYGZus{}conf \PYGZus{}\PYGZus{}rcu *chanctx\PYGZus{}conf;
  u32 driver\PYGZus{}flags;
\PYGZsh{}ifdef CONFIG\PYGZus{}MAC80211\PYGZus{}DEBUGFS;
  struct dentry *debugfs\PYGZus{}dir;
\PYGZsh{}endif;
  unsigned int probe\PYGZus{}req\PYGZus{}reg;
  u8 drv\PYGZus{}priv[0] ;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{type}}] \leavevmode
type of this virtual interface

\item[{\code{bss\_conf}}] \leavevmode
BSS configuration for this interface, either our own
or the BSS we're associated to

\item[{\code{addr}}] \leavevmode
address of this interface

\item[{\code{p2p}}] \leavevmode
indicates whether this AP or STA interface is a p2p
interface, i.e. a GO or p2p-sta respectively

\item[{\code{csa\_active}}] \leavevmode
marks whether a channel switch is going on. Internally it is
write-protected by sdata\_lock and local-\textgreater{}mtx so holding either is fine
for read access.

\item[{\code{mu\_mimo\_owner}}] \leavevmode
indicates interface owns MU-MIMO capability

\item[{\code{cab\_queue}}] \leavevmode
content-after-beacon (DTIM beacon really) queue, AP mode only

\item[{\code{hw\_queue}}] \leavevmode
hardware queue for each AC

\item[{\code{txq}}] \leavevmode
the multicast data TX queue (if driver uses the TXQ abstraction)

\item[{\code{chanctx\_conf}}] \leavevmode
The channel context this interface is assigned to, or \code{NULL}
when it is not assigned. This pointer is RCU-protected due to the TX
path needing to access it; even though the netdev carrier will always
be off when it is \code{NULL} there can still be races and packets could be
processed after it switches back to \code{NULL}.

\item[{\code{driver\_flags}}] \leavevmode
flags/capabilities the driver has for this interface,
these need to be set (or cleared) when the interface is added
or, if supported by the driver, the interface type is changed
at runtime, mac80211 will never touch this field

\item[{\code{debugfs\_dir}}] \leavevmode
debugfs dentry, can be used by drivers to create own per
interface debug files. Note that it will be NULL for the virtual
monitor interface (if that is requested.)

\item[{\code{probe\_req\_reg}}] \leavevmode
probe requests should be reported to mac80211 for this
interface.

\item[{\code{drv\_priv}}] \leavevmode
data area for driver use, will always be aligned to
sizeof(void *).

\end{description}

\textbf{Description}

Data in this structure is continually present for driver
use during the life of a virtual interface.


\subsection{Receive and transmit processing}
\label{driver-api/80211/mac80211:receive-and-transmit-processing}

\subsubsection{what should be here}
\label{driver-api/80211/mac80211:what-should-be-here}
TBD

This should describe the receive and transmit paths in mac80211/the
drivers as well as transmit status handling.


\subsubsection{Frame format}
\label{driver-api/80211/mac80211:frame-format}
As a general rule, when frames are passed between mac80211 and the driver,
they start with the IEEE 802.11 header and include the same octets that are
sent over the air except for the FCS which should be calculated by the
hardware.

There are, however, various exceptions to this rule for advanced features:

The first exception is for hardware encryption and decryption offload
where the IV/ICV may or may not be generated in hardware.

Secondly, when the hardware handles fragmentation, the frame handed to
the driver from mac80211 is the MSDU, not the MPDU.


\subsubsection{Packet alignment}
\label{driver-api/80211/mac80211:packet-alignment}
Drivers always need to pass packets that are aligned to two-byte boundaries
to the stack.

Additionally, should, if possible, align the payload data in a way that
guarantees that the contained IP header is aligned to a four-byte
boundary. In the case of regular frames, this simply means aligning the
payload to a four-byte boundary (because either the IP header is directly
contained, or IV/RFC1042 headers that have a length divisible by four are
in front of it).  If the payload data is not properly aligned and the
architecture doesn't support efficient unaligned operations, mac80211
will align the data.

With A-MSDU frames, however, the payload data address must yield two modulo
four because there are 14-byte 802.3 headers within the A-MSDU frames that
push the IP header further back to a multiple of four again. Thankfully, the
specs were sane enough this time around to require padding each A-MSDU
subframe to a length that is a multiple of four.

Padding like Atheros hardware adds which is between the 802.11 header and
the payload is not supported, the driver is required to move the 802.11
header to be directly in front of the payload in that case.


\subsubsection{Calling into mac80211 from interrupts}
\label{driver-api/80211/mac80211:calling-into-mac80211-from-interrupts}
Only {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_status_irqsafe]{\emph{\code{ieee80211\_tx\_status\_irqsafe()}}}} and {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_rx_irqsafe]{\emph{\code{ieee80211\_rx\_irqsafe()}}}} can be
called in hardware interrupt context. The low-level driver must not call any
other functions in hardware interrupt context. If there is a need for such
call, the low-level driver should first ACK the interrupt and perform the
IEEE 802.11 code call after this, e.g. from a scheduled workqueue or even
tasklet function.
\begin{description}
\item[{NOTE: If the driver opts to use the \code{\_irqsafe()} functions, it may not also}] \leavevmode
use the non-IRQ-safe functions!

\end{description}


\subsubsection{functions/definitions}
\label{driver-api/80211/mac80211:functions-definitions}\index{ieee80211\_rx\_status (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_rx_status}\pysigline{struct \bfcode{ieee80211\_rx\_status}}
receive status

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}rx\PYGZus{}status \PYGZob{}
  u64 mactime;
  u64 boottime\PYGZus{}ns;
  u32 device\PYGZus{}timestamp;
  u32 ampdu\PYGZus{}reference;
  u32 flag;
  u16 freq;
  u8 enc\PYGZus{}flags;
  u8 encoding:2, bw:3;
  u8 rate\PYGZus{}idx;
  u8 nss;
  u8 rx\PYGZus{}flags;
  u8 band;
  u8 antenna;
  s8 signal;
  u8 chains;
  s8 chain\PYGZus{}signal[IEEE80211\PYGZus{}MAX\PYGZus{}CHAINS];
  u8 ampdu\PYGZus{}delimiter\PYGZus{}crc;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{mactime}}] \leavevmode
value in microseconds of the 64-bit Time Synchronization Function
(TSF) timer when the first data symbol (MPDU) arrived at the hardware.

\item[{\code{boottime\_ns}}] \leavevmode
CLOCK\_BOOTTIME timestamp the frame was received at, this is
needed only for beacons and probe responses that update the scan cache.

\item[{\code{device\_timestamp}}] \leavevmode
arbitrary timestamp for the device, mac80211 doesn't use
it but can store it and pass it back to the driver for synchronisation

\item[{\code{ampdu\_reference}}] \leavevmode
A-MPDU reference number, must be a different value for
each A-MPDU but the same for each subframe within one A-MPDU

\item[{\code{flag}}] \leavevmode
\code{RX\_FLAG\_}*

\item[{\code{freq}}] \leavevmode
frequency the radio was tuned to when receiving this frame, in MHz
This field must be set for management frames, but isn't strictly needed
for data (other) frames - for those it only affects radiotap reporting.

\item[{\code{enc\_flags}}] \leavevmode
uses bits from \code{enum mac80211\_rx\_encoding\_flags}

\item[{\code{encoding}}] \leavevmode
\code{enum mac80211\_rx\_encoding}

\item[{\code{bw}}] \leavevmode
\code{enum rate\_info\_bw}

\item[{\code{rate\_idx}}] \leavevmode
index of data rate into band's supported rates or MCS index if
HT or VHT is used (\code{RX\_FLAG\_HT}/\code{RX\_FLAG\_VHT})

\item[{\code{nss}}] \leavevmode
number of streams (VHT and HE only)

\item[{\code{rx\_flags}}] \leavevmode
internal RX flags for mac80211

\item[{\code{band}}] \leavevmode
the active band when this frame was received

\item[{\code{antenna}}] \leavevmode
antenna used

\item[{\code{signal}}] \leavevmode
signal strength when receiving this frame, either in dBm, in dB or
unspecified depending on the hardware capabilities flags
\textbf{IEEE80211\_HW\_SIGNAL\_*}

\item[{\code{chains}}] \leavevmode
bitmask of receive chains for which separate signal strength
values were filled.

\item[{\code{chain\_signal}}] \leavevmode
per-chain signal strength, in dBm (unlike \textbf{signal}, doesn't
support dB or unspecified units)

\item[{\code{ampdu\_delimiter\_crc}}] \leavevmode
A-MPDU delimiter CRC

\end{description}

\textbf{Description}

The low-level driver should provide this information (the subset
supported by hardware) to the 802.11 code with each received
frame, in the skb's control buffer (cb).
\index{mac80211\_rx\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.mac80211_rx_flags}\pysigline{enum \bfcode{mac80211\_rx\_flags}}
receive flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{RX\_FLAG\_MMIC\_ERROR}}] \leavevmode
Michael MIC error was reported on this frame.
Use together with \code{RX\_FLAG\_MMIC\_STRIPPED}.

\item[{\code{RX\_FLAG\_DECRYPTED}}] \leavevmode
This frame was decrypted in hardware.

\item[{\code{RX\_FLAG\_MACTIME\_PLCP\_START}}] \leavevmode
The timestamp passed in the RX status (\textbf{mactime}
field) is valid and contains the time the SYNC preamble was received.

\item[{\code{RX\_FLAG\_MMIC\_STRIPPED}}] \leavevmode
the Michael MIC is stripped off this frame,
verification has been done by the hardware.

\item[{\code{RX\_FLAG\_IV\_STRIPPED}}] \leavevmode
The IV and ICV are stripped from this frame.
If this flag is set, the stack cannot do any replay detection
hence the driver or hardware will have to do that.

\item[{\code{RX\_FLAG\_FAILED\_FCS\_CRC}}] \leavevmode
Set this flag if the FCS check failed on
the frame.

\item[{\code{RX\_FLAG\_FAILED\_PLCP\_CRC}}] \leavevmode
Set this flag if the PCLP check failed on
the frame.

\item[{\code{RX\_FLAG\_MACTIME\_START}}] \leavevmode
The timestamp passed in the RX status (\textbf{mactime}
field) is valid and contains the time the first symbol of the MPDU
was received. This is useful in monitor mode and for proper IBSS
merging.

\item[{\code{RX\_FLAG\_NO\_SIGNAL\_VAL}}] \leavevmode
The signal strength value is not present.
Valid only for data frames (mainly A-MPDU)

\item[{\code{RX\_FLAG\_AMPDU\_DETAILS}}] \leavevmode
A-MPDU details are known, in particular the reference
number (\textbf{ampdu\_reference}) must be populated and be a distinct number for
each A-MPDU

\item[{\code{RX\_FLAG\_PN\_VALIDATED}}] \leavevmode
Currently only valid for CCMP/GCMP frames, this
flag indicates that the PN was verified for replay protection.
Note that this flag is also currently only supported when a frame
is also decrypted (ie. \textbf{RX\_FLAG\_DECRYPTED} must be set)

\item[{\code{RX\_FLAG\_DUP\_VALIDATED}}] \leavevmode
The driver should set this flag if it did
de-duplication by itself.

\item[{\code{RX\_FLAG\_AMPDU\_LAST\_KNOWN}}] \leavevmode
last subframe is known, should be set on all
subframes of a single A-MPDU

\item[{\code{RX\_FLAG\_AMPDU\_IS\_LAST}}] \leavevmode
this subframe is the last subframe of the A-MPDU

\item[{\code{RX\_FLAG\_AMPDU\_DELIM\_CRC\_ERROR}}] \leavevmode
A delimiter CRC error has been detected
on this subframe

\item[{\code{RX\_FLAG\_AMPDU\_DELIM\_CRC\_KNOWN}}] \leavevmode
The delimiter CRC field is known (the CRC
is stored in the \textbf{ampdu\_delimiter\_crc} field)

\item[{\code{RX\_FLAG\_MACTIME\_END}}] \leavevmode
The timestamp passed in the RX status (\textbf{mactime}
field) is valid and contains the time the last symbol of the MPDU
(including FCS) was received.

\item[{\code{RX\_FLAG\_ONLY\_MONITOR}}] \leavevmode
Report frame only to monitor interfaces without
processing it in any regular way.
This is useful if drivers offload some frames but still want to report
them for sniffing purposes.

\item[{\code{RX\_FLAG\_SKIP\_MONITOR}}] \leavevmode
Process and report frame to all interfaces except
monitor interfaces.
This is useful if drivers offload some frames but still want to report
them for sniffing purposes.

\item[{\code{RX\_FLAG\_AMSDU\_MORE}}] \leavevmode
Some drivers may prefer to report separate A-MSDU
subframes instead of a one huge frame for performance reasons.
All, but the last MSDU from an A-MSDU should have this flag set. E.g.
if an A-MSDU has 3 frames, the first 2 must have the flag set, while
the 3rd (last) one must not have this flag set. The flag is used to
deal with retransmission/duplication recovery properly since A-MSDU
subframes share the same sequence number. Reported subframes can be
either regular MSDU or singly A-MSDUs. Subframes must not be
interleaved with other frames.

\item[{\code{RX\_FLAG\_RADIOTAP\_VENDOR\_DATA}}] \leavevmode
This frame contains vendor-specific
radiotap data in the skb-\textgreater{}data (before the frame) as described by
the \code{struct ieee80211\_vendor\_radiotap}.

\item[{\code{RX\_FLAG\_MIC\_STRIPPED}}] \leavevmode
The mic was stripped of this packet. Decryption was
done by the hardware

\item[{\code{RX\_FLAG\_ALLOW\_SAME\_PN}}] \leavevmode
Allow the same PN as same packet before.
This is used for AMSDU subframes which can have the same PN as
the first subframe.

\item[{\code{RX\_FLAG\_ICV\_STRIPPED}}] \leavevmode
The ICV is stripped from this frame. CRC checking must
be done in the hardware.

\end{description}

\textbf{Description}

These flags are used with the \textbf{flag} member of {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_rx_status]{\emph{\code{struct ieee80211\_rx\_status}}}}.
\index{mac80211\_tx\_info\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.mac80211_tx_info_flags}\pysigline{enum \bfcode{mac80211\_tx\_info\_flags}}
flags to describe transmission information/status

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{IEEE80211\_TX\_CTL\_REQ\_TX\_STATUS}}] \leavevmode
require TX status callback for this frame.

\item[{\code{IEEE80211\_TX\_CTL\_ASSIGN\_SEQ}}] \leavevmode
The driver has to assign a sequence
number to this frame, taking care of not overwriting the fragment
number and increasing the sequence number only when the
IEEE80211\_TX\_CTL\_FIRST\_FRAGMENT flag is set. mac80211 will properly
assign sequence numbers to QoS-data frames but cannot do so correctly
for non-QoS-data and management frames because beacons need them from
that counter as well and mac80211 cannot guarantee proper sequencing.
If this flag is set, the driver should instruct the hardware to
assign a sequence number to the frame or assign one itself. Cf. IEEE
802.11-2007 7.1.3.4.1 paragraph 3. This flag will always be set for
beacons and always be clear for frames without a sequence number field.

\item[{\code{IEEE80211\_TX\_CTL\_NO\_ACK}}] \leavevmode
tell the low level not to wait for an ack

\item[{\code{IEEE80211\_TX\_CTL\_CLEAR\_PS\_FILT}}] \leavevmode
clear powersave filter for destination
station

\item[{\code{IEEE80211\_TX\_CTL\_FIRST\_FRAGMENT}}] \leavevmode
this is a first fragment of the frame

\item[{\code{IEEE80211\_TX\_CTL\_SEND\_AFTER\_DTIM}}] \leavevmode
send this frame after DTIM beacon

\item[{\code{IEEE80211\_TX\_CTL\_AMPDU}}] \leavevmode
this frame should be sent as part of an A-MPDU

\item[{\code{IEEE80211\_TX\_CTL\_INJECTED}}] \leavevmode
Frame was injected, internal to mac80211.

\item[{\code{IEEE80211\_TX\_STAT\_TX\_FILTERED}}] \leavevmode
The frame was not transmitted
because the destination STA was in powersave mode. Note that to
avoid race conditions, the filter must be set by the hardware or
firmware upon receiving a frame that indicates that the station
went to sleep (must be done on device to filter frames already on
the queue) and may only be unset after mac80211 gives the OK for
that by setting the IEEE80211\_TX\_CTL\_CLEAR\_PS\_FILT (see above),
since only then is it guaranteed that no more frames are in the
hardware queue.

\item[{\code{IEEE80211\_TX\_STAT\_ACK}}] \leavevmode
Frame was acknowledged

\item[{\code{IEEE80211\_TX\_STAT\_AMPDU}}] \leavevmode
The frame was aggregated, so status
is for the whole aggregation.

\item[{\code{IEEE80211\_TX\_STAT\_AMPDU\_NO\_BACK}}] \leavevmode
no block ack was returned,
so consider using block ack request (BAR).

\item[{\code{IEEE80211\_TX\_CTL\_RATE\_CTRL\_PROBE}}] \leavevmode
internal to mac80211, can be
set by rate control algorithms to indicate probe rate, will
be cleared for fragmented frames (except on the last fragment)

\item[{\code{IEEE80211\_TX\_INTFL\_OFFCHAN\_TX\_OK}}] \leavevmode
Internal to mac80211. Used to indicate
that a frame can be transmitted while the queues are stopped for
off-channel operation.

\item[{\code{IEEE80211\_TX\_INTFL\_NEED\_TXPROCESSING}}] \leavevmode
completely internal to mac80211,
used to indicate that a pending frame requires TX processing before
it can be sent out.

\item[{\code{IEEE80211\_TX\_INTFL\_RETRIED}}] \leavevmode
completely internal to mac80211,
used to indicate that a frame was already retried due to PS

\item[{\code{IEEE80211\_TX\_INTFL\_DONT\_ENCRYPT}}] \leavevmode
completely internal to mac80211,
used to indicate frame should not be encrypted

\item[{\code{IEEE80211\_TX\_CTL\_NO\_PS\_BUFFER}}] \leavevmode
This frame is a response to a poll
frame (PS-Poll or uAPSD) or a non-bufferable MMPDU and must
be sent although the station is in powersave mode.

\item[{\code{IEEE80211\_TX\_CTL\_MORE\_FRAMES}}] \leavevmode
More frames will be passed to the
transmit function after the current frame, this can be used
by drivers to kick the DMA queue only if unset or when the
queue gets full.

\item[{\code{IEEE80211\_TX\_INTFL\_RETRANSMISSION}}] \leavevmode
This frame is being retransmitted
after TX status because the destination was asleep, it must not
be modified again (no seqno assignment, crypto, etc.)

\item[{\code{IEEE80211\_TX\_INTFL\_MLME\_CONN\_TX}}] \leavevmode
This frame was transmitted by the MLME
code for connection establishment, this indicates that its status
should kick the MLME state machine.

\item[{\code{IEEE80211\_TX\_INTFL\_NL80211\_FRAME\_TX}}] \leavevmode
Frame was requested through nl80211
MLME command (internal to mac80211 to figure out whether to send TX
status to user space)

\item[{\code{IEEE80211\_TX\_CTL\_LDPC}}] \leavevmode
tells the driver to use LDPC for this frame

\item[{\code{IEEE80211\_TX\_CTL\_STBC}}] \leavevmode
Enables Space-Time Block Coding (STBC) for this
frame and selects the maximum number of streams that it can use.

\item[{\code{IEEE80211\_TX\_CTL\_TX\_OFFCHAN}}] \leavevmode
Marks this packet to be transmitted on
the off-channel channel when a remain-on-channel offload is done
in hardware -- normal packets still flow and are expected to be
handled properly by the device.

\item[{\code{IEEE80211\_TX\_INTFL\_TKIP\_MIC\_FAILURE}}] \leavevmode
Marks this packet to be used for TKIP
testing. It will be sent out with incorrect Michael MIC key to allow
TKIP countermeasures to be tested.

\item[{\code{IEEE80211\_TX\_CTL\_NO\_CCK\_RATE}}] \leavevmode
This frame will be sent at non CCK rate.
This flag is actually used for management frame especially for P2P
frames not being sent at CCK rate in 2GHz band.

\item[{\code{IEEE80211\_TX\_STATUS\_EOSP}}] \leavevmode
This packet marks the end of service period,
when its status is reported the service period ends. For frames in
an SP that mac80211 transmits, it is already set; for driver frames
the driver may set this flag. It is also used to do the same for
PS-Poll responses.

\item[{\code{IEEE80211\_TX\_CTL\_USE\_MINRATE}}] \leavevmode
This frame will be sent at lowest rate.
This flag is used to send nullfunc frame at minimum rate when
the nullfunc is used for connection monitoring purpose.

\item[{\code{IEEE80211\_TX\_CTL\_DONTFRAG}}] \leavevmode
Don't fragment this packet even if it
would be fragmented by size (this is optional, only used for
monitor injection).

\item[{\code{IEEE80211\_TX\_STAT\_NOACK\_TRANSMITTED}}] \leavevmode
A frame that was marked with
IEEE80211\_TX\_CTL\_NO\_ACK has been successfully transmitted without
any errors (like issues specific to the driver/HW).
This flag must not be set for frames that don't request no-ack
behaviour with IEEE80211\_TX\_CTL\_NO\_ACK.

\end{description}

\textbf{Description}

These flags are used with the \textbf{flags} member of {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_info]{\emph{\code{ieee80211\_tx\_info}}}}.

\textbf{Note}
\begin{description}
\item[{If you have to add new flags to the enumeration, then don't}] \leavevmode
forget to update \code{IEEE80211\_TX\_TEMPORARY\_FLAGS} when necessary.

\end{description}
\index{mac80211\_tx\_control\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.mac80211_tx_control_flags}\pysigline{enum \bfcode{mac80211\_tx\_control\_flags}}
flags to describe transmit control

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{IEEE80211\_TX\_CTRL\_PORT\_CTRL\_PROTO}}] \leavevmode
this frame is a port control
protocol frame (e.g. EAP)

\item[{\code{IEEE80211\_TX\_CTRL\_PS\_RESPONSE}}] \leavevmode
This frame is a response to a poll
frame (PS-Poll or uAPSD).

\item[{\code{IEEE80211\_TX\_CTRL\_RATE\_INJECT}}] \leavevmode
This frame is injected with rate information

\item[{\code{IEEE80211\_TX\_CTRL\_AMSDU}}] \leavevmode
This frame is an A-MSDU frame

\item[{\code{IEEE80211\_TX\_CTRL\_FAST\_XMIT}}] \leavevmode
This frame is going through the fast\_xmit path

\end{description}

\textbf{Description}

These flags are used in tx\_info-\textgreater{}control.flags.
\index{mac80211\_rate\_control\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.mac80211_rate_control_flags}\pysigline{enum \bfcode{mac80211\_rate\_control\_flags}}
per-rate flags set by the Rate Control algorithm.

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{IEEE80211\_TX\_RC\_USE\_RTS\_CTS}}] \leavevmode
Use RTS/CTS exchange for this rate.

\item[{\code{IEEE80211\_TX\_RC\_USE\_CTS\_PROTECT}}] \leavevmode
CTS-to-self protection is required.
This is set if the current BSS requires ERP protection.

\item[{\code{IEEE80211\_TX\_RC\_USE\_SHORT\_PREAMBLE}}] \leavevmode
Use short preamble.

\item[{\code{IEEE80211\_TX\_RC\_MCS}}] \leavevmode
HT rate.

\item[{\code{IEEE80211\_TX\_RC\_GREEN\_FIELD}}] \leavevmode
Indicates whether this rate should be used in
Greenfield mode.

\item[{\code{IEEE80211\_TX\_RC\_40\_MHZ\_WIDTH}}] \leavevmode
Indicates if the Channel Width should be 40 MHz.

\item[{\code{IEEE80211\_TX\_RC\_DUP\_DATA}}] \leavevmode
The frame should be transmitted on both of the
adjacent 20 MHz channels, if the current channel type is
NL80211\_CHAN\_HT40MINUS or NL80211\_CHAN\_HT40PLUS.

\item[{\code{IEEE80211\_TX\_RC\_SHORT\_GI}}] \leavevmode
Short Guard interval should be used for this rate.

\item[{\code{IEEE80211\_TX\_RC\_VHT\_MCS}}] \leavevmode
VHT MCS rate, in this case the idx field is split
into a higher 4 bits (Nss) and lower 4 bits (MCS number)

\item[{\code{IEEE80211\_TX\_RC\_80\_MHZ\_WIDTH}}] \leavevmode
Indicates 80 MHz transmission

\item[{\code{IEEE80211\_TX\_RC\_160\_MHZ\_WIDTH}}] \leavevmode
Indicates 160 MHz transmission
(80+80 isn't supported yet)

\end{description}

\textbf{Description}

These flags are set by the Rate control algorithm for each rate during tx,
in the \textbf{flags} member of struct ieee80211\_tx\_rate.
\index{ieee80211\_tx\_rate (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_tx_rate}\pysigline{struct \bfcode{ieee80211\_tx\_rate}}
rate selection/status

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}tx\PYGZus{}rate \PYGZob{}
  s8 idx;
  u16 count:5, flags:11;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{idx}}] \leavevmode
rate index to attempt to send with

\item[{\code{count}}] \leavevmode
number of tries in this rate before going to the next rate

\item[{\code{flags}}] \leavevmode
rate control flags ({\hyperref[driver\string-api/80211/mac80211:c.mac80211_rate_control_flags]{\emph{\code{enum mac80211\_rate\_control\_flags}}}})

\end{description}

\textbf{Description}

A value of -1 for \textbf{idx} indicates an invalid rate and, if used
in an array of retry rates, that no more rates should be tried.

When used for transmit status reporting, the driver should
always report the rate along with the flags it used.

{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_info]{\emph{\code{struct ieee80211\_tx\_info}}}} contains an array of these structs
in the control information, and it will be filled by the rate
control algorithm according to what should be sent. For example,
if this array contains, in the format \{ \textless{}idx\textgreater{}, \textless{}count\textgreater{} \} the
information:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{} 3, 2 \PYGZcb{}, \PYGZob{} 2, 2 \PYGZcb{}, \PYGZob{} 1, 4 \PYGZcb{}, \PYGZob{} \PYGZhy{}1, 0 \PYGZcb{}, \PYGZob{} \PYGZhy{}1, 0 \PYGZcb{}
\end{Verbatim}

then this means that the frame should be transmitted
up to twice at rate 3, up to twice at rate 2, and up to four
times at rate 1 if it doesn't get acknowledged. Say it gets
acknowledged by the peer after the fifth attempt, the status
information should then contain:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{} 3, 2 \PYGZcb{}, \PYGZob{} 2, 2 \PYGZcb{}, \PYGZob{} 1, 1 \PYGZcb{}, \PYGZob{} \PYGZhy{}1, 0 \PYGZcb{} ...
\end{Verbatim}

since it was transmitted twice at rate 3, twice at rate 2
and once at rate 1 after which we received an acknowledgement.
\index{ieee80211\_tx\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_tx_info}\pysigline{struct \bfcode{ieee80211\_tx\_info}}
skb transmit information

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}tx\PYGZus{}info \PYGZob{}
  u32 flags;
  u8 band;
  u8 hw\PYGZus{}queue;
  u16 ack\PYGZus{}frame\PYGZus{}id;
  union \PYGZob{}
    struct \PYGZob{}
      union \PYGZob{}
        struct \PYGZob{}
          struct ieee80211\PYGZus{}tx\PYGZus{}rate rates[ IEEE80211\PYGZus{}TX\PYGZus{}MAX\PYGZus{}RATES];
          s8 rts\PYGZus{}cts\PYGZus{}rate\PYGZus{}idx;
          u8 use\PYGZus{}rts:1;
          u8 use\PYGZus{}cts\PYGZus{}prot:1;
          u8 short\PYGZus{}preamble:1;
          u8 skip\PYGZus{}table:1;
        \PYGZcb{};
        unsigned long jiffies;
      \PYGZcb{};
      struct ieee80211\PYGZus{}vif *vif;
      struct ieee80211\PYGZus{}key\PYGZus{}conf *hw\PYGZus{}key;
      u32 flags;
      codel\PYGZus{}time\PYGZus{}t enqueue\PYGZus{}time;
    \PYGZcb{} control;
    struct \PYGZob{}
      u64 cookie;
    \PYGZcb{} ack;
    struct \PYGZob{}
      struct ieee80211\PYGZus{}tx\PYGZus{}rate rates[IEEE80211\PYGZus{}TX\PYGZus{}MAX\PYGZus{}RATES];
      s32 ack\PYGZus{}signal;
      u8 ampdu\PYGZus{}ack\PYGZus{}len;
      u8 ampdu\PYGZus{}len;
      u8 antenna;
      u16 tx\PYGZus{}time;
      void *status\PYGZus{}driver\PYGZus{}data[19 / sizeof(void *)];
    \PYGZcb{} status;
    struct \PYGZob{}
      struct ieee80211\PYGZus{}tx\PYGZus{}rate driver\PYGZus{}rates[ IEEE80211\PYGZus{}TX\PYGZus{}MAX\PYGZus{}RATES];
      u8 pad[4];
      void *rate\PYGZus{}driver\PYGZus{}data[ IEEE80211\PYGZus{}TX\PYGZus{}INFO\PYGZus{}RATE\PYGZus{}DRIVER\PYGZus{}DATA\PYGZus{}SIZE / sizeof(void *)];
    \PYGZcb{};
    void *driver\PYGZus{}data[ IEEE80211\PYGZus{}TX\PYGZus{}INFO\PYGZus{}DRIVER\PYGZus{}DATA\PYGZus{}SIZE / sizeof(void *)];
  \PYGZcb{};
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{flags}}] \leavevmode
transmit info flags, defined above

\item[{\code{band}}] \leavevmode
the band to transmit on (use for checking for races)

\item[{\code{hw\_queue}}] \leavevmode
HW queue to put the frame on, \code{skb\_get\_queue\_mapping()} gives the AC

\item[{\code{ack\_frame\_id}}] \leavevmode
internal frame ID for TX status, used internally

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{control}}] \leavevmode
union for control data

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{\{unnamed\_struct\}}}] \leavevmode
anonymous

\item[{\code{status}}] \leavevmode
union for status data

\item[{\code{\{unnamed\_struct\}}}] \leavevmode
anonymous

\item[{\code{driver\_data}}] \leavevmode
array of driver\_data pointers

\end{description}

\textbf{Description}
\begin{description}
\item[{This structure is placed in skb-\textgreater{}cb for three uses:}] \leavevmode\begin{enumerate}
\item {} 
mac80211 TX control - mac80211 tells the driver what to do

\item {} 
driver internal use (if applicable)

\item {} 
TX status information - driver tells mac80211 what happened

\end{enumerate}

\end{description}
\index{ieee80211\_tx\_info\_clear\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_tx_info_clear_status}\pysiglinewithargsret{void \bfcode{ieee80211\_tx\_info\_clear\_status}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_info]{\emph{ieee80211\_tx\_info}}} *\emph{ info}}{}
clear TX status

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_tx\_info * info}}] \leavevmode
The {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_info]{\emph{\code{struct ieee80211\_tx\_info}}}} to be cleared.

\end{description}

\textbf{Description}

When the driver passes an skb back to mac80211, it must report
a number of things in TX status. This function clears everything
in the TX status but the rate control information (it does clear
the count since you need to fill that in anyway).

\textbf{NOTE}
\begin{description}
\item[{You can only use this function if you do NOT use}] \leavevmode
info-\textgreater{}driver\_data! Use info-\textgreater{}rate\_driver\_data
instead if you need only the less space that allows.

\end{description}
\index{ieee80211\_rx (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_rx}\pysiglinewithargsret{void \bfcode{ieee80211\_rx}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct sk\_buff *\emph{ skb}}{}
receive frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware this frame came in on

\item[{\code{struct sk\_buff * skb}}] \leavevmode
the buffer to receive, owned by mac80211 after this call

\end{description}

\textbf{Description}

Use this function to hand received frames to mac80211. The receive
buffer in \textbf{skb} must start with an IEEE 802.11 header. In case of a
paged \textbf{skb} is used, the driver is recommended to put the ieee80211
header of the frame on the linear part of the \textbf{skb} to avoid memory
allocation and/or memcpy by the stack.

This function may not be called in IRQ context. Calls to this function
for a single hardware must be synchronized against each other. Calls to
this function, {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_rx_ni]{\emph{\code{ieee80211\_rx\_ni()}}}} and {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_rx_irqsafe]{\emph{\code{ieee80211\_rx\_irqsafe()}}}} may not be
mixed for a single hardware. Must not run concurrently with
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_status]{\emph{\code{ieee80211\_tx\_status()}}}} or {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_status_ni]{\emph{\code{ieee80211\_tx\_status\_ni()}}}}.

In process context use instead {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_rx_ni]{\emph{\code{ieee80211\_rx\_ni()}}}}.
\index{ieee80211\_rx\_ni (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_rx_ni}\pysiglinewithargsret{void \bfcode{ieee80211\_rx\_ni}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct sk\_buff *\emph{ skb}}{}
receive frame (in process context)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware this frame came in on

\item[{\code{struct sk\_buff * skb}}] \leavevmode
the buffer to receive, owned by mac80211 after this call

\end{description}

\textbf{Description}

Like {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_rx]{\emph{\code{ieee80211\_rx()}}}} but can be called in process context
(internally disables bottom halves).

Calls to this function, {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_rx]{\emph{\code{ieee80211\_rx()}}}} and {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_rx_irqsafe]{\emph{\code{ieee80211\_rx\_irqsafe()}}}} may
not be mixed for a single hardware. Must not run concurrently with
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_status]{\emph{\code{ieee80211\_tx\_status()}}}} or {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_status_ni]{\emph{\code{ieee80211\_tx\_status\_ni()}}}}.
\index{ieee80211\_rx\_irqsafe (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_rx_irqsafe}\pysiglinewithargsret{void \bfcode{ieee80211\_rx\_irqsafe}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct sk\_buff *\emph{ skb}}{}
receive frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware this frame came in on

\item[{\code{struct sk\_buff * skb}}] \leavevmode
the buffer to receive, owned by mac80211 after this call

\end{description}

\textbf{Description}

Like {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_rx]{\emph{\code{ieee80211\_rx()}}}} but can be called in IRQ context
(internally defers to a tasklet.)

Calls to this function, {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_rx]{\emph{\code{ieee80211\_rx()}}}} or {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_rx_ni]{\emph{\code{ieee80211\_rx\_ni()}}}} may not
be mixed for a single hardware.Must not run concurrently with
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_status]{\emph{\code{ieee80211\_tx\_status()}}}} or {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_status_ni]{\emph{\code{ieee80211\_tx\_status\_ni()}}}}.
\index{ieee80211\_tx\_status (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_tx_status}\pysigline{struct \bfcode{ieee80211\_tx\_status}}
extended tx staus info for rate control

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}tx\PYGZus{}status \PYGZob{}
  struct ieee80211\PYGZus{}sta *sta;
  struct ieee80211\PYGZus{}tx\PYGZus{}info *info;
  struct sk\PYGZus{}buff *skb;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{sta}}] \leavevmode
Station that the packet was transmitted for

\item[{\code{info}}] \leavevmode
Basic tx status information

\item[{\code{skb}}] \leavevmode
Packet skb (can be NULL if not provided by the driver)

\end{description}
\index{ieee80211\_tx\_status (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{void \bfcode{ieee80211\_tx\_status}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct sk\_buff *\emph{ skb}}{}
transmit status callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware the frame was transmitted by

\item[{\code{struct sk\_buff * skb}}] \leavevmode
the frame that was transmitted, owned by mac80211 after this call

\end{description}

\textbf{Description}

Call this function for all transmitted frames after they have been
transmitted. It is permissible to not call this function for
multicast frames but this can affect statistics.

This function may not be called in IRQ context. Calls to this function
for a single hardware must be synchronized against each other. Calls
to this function, {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_status_ni]{\emph{\code{ieee80211\_tx\_status\_ni()}}}} and {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_status_irqsafe]{\emph{\code{ieee80211\_tx\_status\_irqsafe()}}}}
may not be mixed for a single hardware. Must not run concurrently with
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_rx]{\emph{\code{ieee80211\_rx()}}}} or {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_rx_ni]{\emph{\code{ieee80211\_rx\_ni()}}}}.
\index{ieee80211\_tx\_status\_ni (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_tx_status_ni}\pysiglinewithargsret{void \bfcode{ieee80211\_tx\_status\_ni}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct sk\_buff *\emph{ skb}}{}
transmit status callback (in process context)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware the frame was transmitted by

\item[{\code{struct sk\_buff * skb}}] \leavevmode
the frame that was transmitted, owned by mac80211 after this call

\end{description}

\textbf{Description}

Like {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_status]{\emph{\code{ieee80211\_tx\_status()}}}} but can be called in process context.

Calls to this function, {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_status]{\emph{\code{ieee80211\_tx\_status()}}}} and
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_status_irqsafe]{\emph{\code{ieee80211\_tx\_status\_irqsafe()}}}} may not be mixed
for a single hardware.
\index{ieee80211\_tx\_status\_irqsafe (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_tx_status_irqsafe}\pysiglinewithargsret{void \bfcode{ieee80211\_tx\_status\_irqsafe}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct sk\_buff *\emph{ skb}}{}
IRQ-safe transmit status callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware the frame was transmitted by

\item[{\code{struct sk\_buff * skb}}] \leavevmode
the frame that was transmitted, owned by mac80211 after this call

\end{description}

\textbf{Description}

Like {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_status]{\emph{\code{ieee80211\_tx\_status()}}}} but can be called in IRQ context
(internally defers to a tasklet.)

Calls to this function, {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_status]{\emph{\code{ieee80211\_tx\_status()}}}} and
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_status_ni]{\emph{\code{ieee80211\_tx\_status\_ni()}}}} may not be mixed for a single hardware.
\index{ieee80211\_rts\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_rts_get}\pysiglinewithargsret{void \bfcode{ieee80211\_rts\_get}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{ieee80211\_vif}}} *\emph{ vif}, const void *\emph{ frame}, size\_t\emph{ frame\_len}, const struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_info]{\emph{ieee80211\_tx\_info}}} *\emph{ frame\_txctl}, struct ieee80211\_rts *\emph{ rts}}{}
RTS frame generation function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
pointer obtained from {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_alloc_hw]{\emph{\code{ieee80211\_alloc\_hw()}}}}.

\item[{\code{struct ieee80211\_vif * vif}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{\code{struct ieee80211\_vif}}}} pointer from the add\_interface callback.

\item[{\code{const void * frame}}] \leavevmode
pointer to the frame that is going to be protected by the RTS.

\item[{\code{size\_t frame\_len}}] \leavevmode
the frame length (in octets).

\item[{\code{const struct ieee80211\_tx\_info * frame\_txctl}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_info]{\emph{\code{struct ieee80211\_tx\_info}}}} of the frame.

\item[{\code{struct ieee80211\_rts * rts}}] \leavevmode
The buffer where to store the RTS frame.

\end{description}

\textbf{Description}

If the RTS frames are generated by the host system (i.e., not in
hardware/firmware), the low-level driver uses this function to receive
the next RTS frame from the 802.11 code. The low-level is responsible
for calling this function before and RTS frame is needed.
\index{ieee80211\_rts\_duration (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_rts_duration}\pysiglinewithargsret{\_\_le16 \bfcode{ieee80211\_rts\_duration}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{ieee80211\_vif}}} *\emph{ vif}, size\_t\emph{ frame\_len}, const struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_info]{\emph{ieee80211\_tx\_info}}} *\emph{ frame\_txctl}}{}
Get the duration field for an RTS frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
pointer obtained from {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_alloc_hw]{\emph{\code{ieee80211\_alloc\_hw()}}}}.

\item[{\code{struct ieee80211\_vif * vif}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{\code{struct ieee80211\_vif}}}} pointer from the add\_interface callback.

\item[{\code{size\_t frame\_len}}] \leavevmode
the length of the frame that is going to be protected by the RTS.

\item[{\code{const struct ieee80211\_tx\_info * frame\_txctl}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_info]{\emph{\code{struct ieee80211\_tx\_info}}}} of the frame.

\end{description}

\textbf{Description}

If the RTS is generated in firmware, but the host system must provide
the duration field, the low-level driver uses this function to receive
the duration field value in little-endian byteorder.

\textbf{Return}

The duration.
\index{ieee80211\_ctstoself\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_ctstoself_get}\pysiglinewithargsret{void \bfcode{ieee80211\_ctstoself\_get}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{ieee80211\_vif}}} *\emph{ vif}, const void *\emph{ frame}, size\_t\emph{ frame\_len}, const struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_info]{\emph{ieee80211\_tx\_info}}} *\emph{ frame\_txctl}, struct ieee80211\_cts *\emph{ cts}}{}
CTS-to-self frame generation function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
pointer obtained from {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_alloc_hw]{\emph{\code{ieee80211\_alloc\_hw()}}}}.

\item[{\code{struct ieee80211\_vif * vif}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{\code{struct ieee80211\_vif}}}} pointer from the add\_interface callback.

\item[{\code{const void * frame}}] \leavevmode
pointer to the frame that is going to be protected by the CTS-to-self.

\item[{\code{size\_t frame\_len}}] \leavevmode
the frame length (in octets).

\item[{\code{const struct ieee80211\_tx\_info * frame\_txctl}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_info]{\emph{\code{struct ieee80211\_tx\_info}}}} of the frame.

\item[{\code{struct ieee80211\_cts * cts}}] \leavevmode
The buffer where to store the CTS-to-self frame.

\end{description}

\textbf{Description}

If the CTS-to-self frames are generated by the host system (i.e., not in
hardware/firmware), the low-level driver uses this function to receive
the next CTS-to-self frame from the 802.11 code. The low-level is responsible
for calling this function before and CTS-to-self frame is needed.
\index{ieee80211\_ctstoself\_duration (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_ctstoself_duration}\pysiglinewithargsret{\_\_le16 \bfcode{ieee80211\_ctstoself\_duration}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{ieee80211\_vif}}} *\emph{ vif}, size\_t\emph{ frame\_len}, const struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_info]{\emph{ieee80211\_tx\_info}}} *\emph{ frame\_txctl}}{}
Get the duration field for a CTS-to-self frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
pointer obtained from {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_alloc_hw]{\emph{\code{ieee80211\_alloc\_hw()}}}}.

\item[{\code{struct ieee80211\_vif * vif}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{\code{struct ieee80211\_vif}}}} pointer from the add\_interface callback.

\item[{\code{size\_t frame\_len}}] \leavevmode
the length of the frame that is going to be protected by the CTS-to-self.

\item[{\code{const struct ieee80211\_tx\_info * frame\_txctl}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_tx_info]{\emph{\code{struct ieee80211\_tx\_info}}}} of the frame.

\end{description}

\textbf{Description}

If the CTS-to-self is generated in firmware, but the host system must provide
the duration field, the low-level driver uses this function to receive
the duration field value in little-endian byteorder.

\textbf{Return}

The duration.
\index{ieee80211\_generic\_frame\_duration (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_generic_frame_duration}\pysiglinewithargsret{\_\_le16 \bfcode{ieee80211\_generic\_frame\_duration}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{ieee80211\_vif}}} *\emph{ vif}, enum nl80211\_band\emph{ band}, size\_t\emph{ frame\_len}, struct {\hyperref[driver\string-api/80211/cfg80211:c.ieee80211_rate]{\emph{ieee80211\_rate}}} *\emph{ rate}}{}
Calculate the duration field for a frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
pointer obtained from {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_alloc_hw]{\emph{\code{ieee80211\_alloc\_hw()}}}}.

\item[{\code{struct ieee80211\_vif * vif}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{\code{struct ieee80211\_vif}}}} pointer from the add\_interface callback.

\item[{\code{enum nl80211\_band band}}] \leavevmode
the band to calculate the frame duration on

\item[{\code{size\_t frame\_len}}] \leavevmode
the length of the frame.

\item[{\code{struct ieee80211\_rate * rate}}] \leavevmode
the rate at which the frame is going to be transmitted.

\end{description}

\textbf{Description}

Calculate the duration field of some generic frame, given its
length and transmission rate (in 100kbps).

\textbf{Return}

The duration.
\index{ieee80211\_wake\_queue (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_wake_queue}\pysiglinewithargsret{void \bfcode{ieee80211\_wake\_queue}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, int\emph{ queue}}{}
wake specific queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
pointer as obtained from {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_alloc_hw]{\emph{\code{ieee80211\_alloc\_hw()}}}}.

\item[{\code{int queue}}] \leavevmode
queue number (counted from zero).

\end{description}

\textbf{Description}

Drivers should use this function instead of netif\_wake\_queue.
\index{ieee80211\_stop\_queue (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_stop_queue}\pysiglinewithargsret{void \bfcode{ieee80211\_stop\_queue}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, int\emph{ queue}}{}
stop specific queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
pointer as obtained from {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_alloc_hw]{\emph{\code{ieee80211\_alloc\_hw()}}}}.

\item[{\code{int queue}}] \leavevmode
queue number (counted from zero).

\end{description}

\textbf{Description}

Drivers should use this function instead of netif\_stop\_queue.
\index{ieee80211\_wake\_queues (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_wake_queues}\pysiglinewithargsret{void \bfcode{ieee80211\_wake\_queues}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}}{}
wake all queues

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
pointer as obtained from {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_alloc_hw]{\emph{\code{ieee80211\_alloc\_hw()}}}}.

\end{description}

\textbf{Description}

Drivers should use this function instead of netif\_wake\_queue.
\index{ieee80211\_stop\_queues (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_stop_queues}\pysiglinewithargsret{void \bfcode{ieee80211\_stop\_queues}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}}{}
stop all queues

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
pointer as obtained from {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_alloc_hw]{\emph{\code{ieee80211\_alloc\_hw()}}}}.

\end{description}

\textbf{Description}

Drivers should use this function instead of netif\_stop\_queue.
\index{ieee80211\_queue\_stopped (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_queue_stopped}\pysiglinewithargsret{int \bfcode{ieee80211\_queue\_stopped}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, int\emph{ queue}}{}
test status of the queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
pointer as obtained from {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_alloc_hw]{\emph{\code{ieee80211\_alloc\_hw()}}}}.

\item[{\code{int queue}}] \leavevmode
queue number (counted from zero).

\end{description}

\textbf{Description}

Drivers should use this function instead of netif\_stop\_queue.

\textbf{Return}

\code{true} if the queue is stopped. \code{false} otherwise.


\subsection{Frame filtering}
\label{driver-api/80211/mac80211:frame-filtering}
mac80211 requires to see many management frames for proper
operation, and users may want to see many more frames when
in monitor mode. However, for best CPU usage and power consumption,
having as few frames as possible percolate through the stack is
desirable. Hence, the hardware should filter as much as possible.

To achieve this, mac80211 uses filter flags (see below) to tell
the driver's \code{configure\_filter()} function which frames should be
passed to mac80211 and which should be filtered out.

Before \code{configure\_filter()} is invoked, the \code{prepare\_multicast()}
callback is invoked with the parameters \textbf{mc\_count} and \textbf{mc\_list}
for the combined multicast address list of all virtual interfaces.
It's use is optional, and it returns a u64 that is passed to
\code{configure\_filter()}. Additionally, \code{configure\_filter()} has the
arguments \textbf{changed\_flags} telling which flags were changed and
\textbf{total\_flags} with the new flag states.

If your device has no multicast address filters your driver will
need to check both the \code{FIF\_ALLMULTI} flag and the \textbf{mc\_count}
parameter to see whether multicast frames should be accepted
or dropped.

All unsupported flags in \textbf{total\_flags} must be cleared.
Hardware does not support a flag if it is incapable of \_passing\_
the frame to the stack. Otherwise the driver must ignore
the flag, but not clear it.
You must \_only\_ clear the flag (announce no support for the
flag to mac80211) if you are not able to pass the packet type
to the stack (so the hardware always filters it).
So for example, you should clear \textbf{FIF\_CONTROL}, if your hardware
always filters control frames. If your hardware always passes
control frames to the kernel and is incapable of filtering them,
you do \_not\_ clear the \textbf{FIF\_CONTROL} flag.
This rule applies to all other FIF flags as well.
\index{ieee80211\_filter\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_filter_flags}\pysigline{enum \bfcode{ieee80211\_filter\_flags}}
hardware filter flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{FIF\_ALLMULTI}}] \leavevmode
pass all multicast frames, this is used if requested
by the user or if the hardware is not capable of filtering by
multicast address.

\item[{\code{FIF\_FCSFAIL}}] \leavevmode
pass frames with failed FCS (but you need to set the
\code{RX\_FLAG\_FAILED\_FCS\_CRC} for them)

\item[{\code{FIF\_PLCPFAIL}}] \leavevmode
pass frames with failed PLCP CRC (but you need to set
the \code{RX\_FLAG\_FAILED\_PLCP\_CRC} for them

\item[{\code{FIF\_BCN\_PRBRESP\_PROMISC}}] \leavevmode
This flag is set during scanning to indicate
to the hardware that it should not filter beacons or probe responses
by BSSID. Filtering them can greatly reduce the amount of processing
mac80211 needs to do and the amount of CPU wakeups, so you should
honour this flag if possible.

\item[{\code{FIF\_CONTROL}}] \leavevmode
pass control frames (except for PS Poll) addressed to this
station

\item[{\code{FIF\_OTHER\_BSS}}] \leavevmode
pass frames destined to other BSSes

\item[{\code{FIF\_PSPOLL}}] \leavevmode
pass PS Poll frames

\item[{\code{FIF\_PROBE\_REQ}}] \leavevmode
pass probe request frames

\end{description}

\textbf{Description}

These flags determine what the filter in hardware should be
programmed to let through and what should not be passed to the
stack. It is always safe to pass more frames than requested,
but this has negative impact on power consumption.


\subsection{The mac80211 workqueue}
\label{driver-api/80211/mac80211:the-mac80211-workqueue}
mac80211 provides its own workqueue for drivers and internal mac80211 use.
The workqueue is a single threaded workqueue and can only be accessed by
helpers for sanity checking. Drivers must ensure all work added onto the
mac80211 workqueue should be cancelled on the driver \code{stop()} callback.

mac80211 will flushed the workqueue upon interface removal and during
suspend.

All work performed on the mac80211 workqueue must not acquire the RTNL lock.
\index{ieee80211\_queue\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_queue_work}\pysiglinewithargsret{void \bfcode{ieee80211\_queue\_work}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct work\_struct *\emph{ work}}{}
add work onto the mac80211 workqueue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware struct for the interface we are adding work for

\item[{\code{struct work\_struct * work}}] \leavevmode
the work we want to add onto the mac80211 workqueue

\end{description}

\textbf{Description}

Drivers and mac80211 use this to add work onto the mac80211 workqueue.
This helper ensures drivers are not queueing work when they should not be.
\index{ieee80211\_queue\_delayed\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211:c.ieee80211_queue_delayed_work}\pysiglinewithargsret{void \bfcode{ieee80211\_queue\_delayed\_work}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct delayed\_work *\emph{ dwork}, unsigned long\emph{ delay}}{}
add work onto the mac80211 workqueue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware struct for the interface we are adding work for

\item[{\code{struct delayed\_work * dwork}}] \leavevmode
delayable work to queue onto the mac80211 workqueue

\item[{\code{unsigned long delay}}] \leavevmode
number of jiffies to wait before queueing

\end{description}

\textbf{Description}

Drivers and mac80211 use this to queue delayed work onto the mac80211
workqueue.


\section{mac80211 subsystem (advanced)}
\label{driver-api/80211/mac80211-advanced:mac80211-subsystem-advanced}\label{driver-api/80211/mac80211-advanced::doc}
Information contained within this part of the book is of interest only
for advanced interaction of mac80211 with drivers to exploit more
hardware capabilities and improve performance.


\subsection{LED support}
\label{driver-api/80211/mac80211-advanced:led-support}
Mac80211 supports various ways of blinking LEDs. Wherever possible,
device LEDs should be exposed as LED class devices and hooked up to the
appropriate trigger, which will then be triggered appropriately by
mac80211.
\index{ieee80211\_get\_tx\_led\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_get_tx_led_name}\pysiglinewithargsret{const char * \bfcode{ieee80211\_get\_tx\_led\_name}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}}{}
get name of TX LED

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware to get the LED trigger name for

\end{description}

\textbf{Description}

mac80211 creates a transmit LED trigger for each wireless hardware
that can be used to drive LEDs if your driver registers a LED device.
This function returns the name (or \code{NULL} if not configured for LEDs)
of the trigger so you can automatically link the LED device.

\textbf{Return}

The name of the LED trigger. \code{NULL} if not configured for LEDs.
\index{ieee80211\_get\_rx\_led\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_get_rx_led_name}\pysiglinewithargsret{const char * \bfcode{ieee80211\_get\_rx\_led\_name}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}}{}
get name of RX LED

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware to get the LED trigger name for

\end{description}

\textbf{Description}

mac80211 creates a receive LED trigger for each wireless hardware
that can be used to drive LEDs if your driver registers a LED device.
This function returns the name (or \code{NULL} if not configured for LEDs)
of the trigger so you can automatically link the LED device.

\textbf{Return}

The name of the LED trigger. \code{NULL} if not configured for LEDs.
\index{ieee80211\_get\_assoc\_led\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_get_assoc_led_name}\pysiglinewithargsret{const char * \bfcode{ieee80211\_get\_assoc\_led\_name}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}}{}
get name of association LED

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware to get the LED trigger name for

\end{description}

\textbf{Description}

mac80211 creates a association LED trigger for each wireless hardware
that can be used to drive LEDs if your driver registers a LED device.
This function returns the name (or \code{NULL} if not configured for LEDs)
of the trigger so you can automatically link the LED device.

\textbf{Return}

The name of the LED trigger. \code{NULL} if not configured for LEDs.
\index{ieee80211\_get\_radio\_led\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_get_radio_led_name}\pysiglinewithargsret{const char * \bfcode{ieee80211\_get\_radio\_led\_name}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}}{}
get name of radio LED

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware to get the LED trigger name for

\end{description}

\textbf{Description}

mac80211 creates a radio change LED trigger for each wireless hardware
that can be used to drive LEDs if your driver registers a LED device.
This function returns the name (or \code{NULL} if not configured for LEDs)
of the trigger so you can automatically link the LED device.

\textbf{Return}

The name of the LED trigger. \code{NULL} if not configured for LEDs.
\index{ieee80211\_tpt\_blink (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_tpt_blink}\pysigline{struct \bfcode{ieee80211\_tpt\_blink}}
throughput blink description

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}tpt\PYGZus{}blink \PYGZob{}
  int throughput;
  int blink\PYGZus{}time;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{throughput}}] \leavevmode
throughput in Kbit/sec

\item[{\code{blink\_time}}] \leavevmode
blink time in milliseconds
(full cycle, ie. one off + one on period)

\end{description}
\index{ieee80211\_tpt\_led\_trigger\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_tpt_led_trigger_flags}\pysigline{enum \bfcode{ieee80211\_tpt\_led\_trigger\_flags}}
throughput trigger flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{IEEE80211\_TPT\_LEDTRIG\_FL\_RADIO}}] \leavevmode
enable blinking with radio

\item[{\code{IEEE80211\_TPT\_LEDTRIG\_FL\_WORK}}] \leavevmode
enable blinking when working

\item[{\code{IEEE80211\_TPT\_LEDTRIG\_FL\_CONNECTED}}] \leavevmode
enable blinking when at least one
interface is connected in some way, including being an AP

\end{description}
\index{ieee80211\_create\_tpt\_led\_trigger (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_create_tpt_led_trigger}\pysiglinewithargsret{const char * \bfcode{ieee80211\_create\_tpt\_led\_trigger}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, unsigned int\emph{ flags}, const struct {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_tpt_blink]{\emph{ieee80211\_tpt\_blink}}} *\emph{ blink\_table}, unsigned int\emph{ blink\_table\_len}}{}
create throughput LED trigger

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware to create the trigger for

\item[{\code{unsigned int flags}}] \leavevmode
trigger flags, see {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_tpt_led_trigger_flags]{\emph{\code{enum ieee80211\_tpt\_led\_trigger\_flags}}}}

\item[{\code{const struct ieee80211\_tpt\_blink * blink\_table}}] \leavevmode
the blink table -- needs to be ordered by throughput

\item[{\code{unsigned int blink\_table\_len}}] \leavevmode
size of the blink table

\end{description}

\textbf{Return}

\code{NULL} (in case of error, or if no LED triggers are
configured) or the name of the new trigger.

\textbf{Note}

This function must be called before {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_register_hw]{\emph{\code{ieee80211\_register\_hw()}}}}.


\subsection{Hardware crypto acceleration}
\label{driver-api/80211/mac80211-advanced:hardware-crypto-acceleration}
mac80211 is capable of taking advantage of many hardware
acceleration designs for encryption and decryption operations.

The \code{set\_key()} callback in the {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_ops]{\emph{\code{struct ieee80211\_ops}}}} for a given
device is called to enable hardware acceleration of encryption and
decryption. The callback takes a \textbf{sta} parameter that will be NULL
for default keys or keys used for transmission only, or point to
the station information for the peer for individual keys.
Multiple transmission keys with the same key index may be used when
VLANs are configured for an access point.

When transmitting, the TX control data will use the \textbf{hw\_key\_idx}
selected by the driver by modifying the {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_key_conf]{\emph{\code{struct ieee80211\_key\_conf}}}}
pointed to by the \textbf{key} parameter to the \code{set\_key()} function.

The \code{set\_key()} call for the \code{SET\_KEY} command should return 0 if
the key is now in use, -\code{EOPNOTSUPP} or -\code{ENOSPC} if it couldn't be
added; if you return 0 then hw\_key\_idx must be assigned to the
hardware key index, you are free to use the full u8 range.

Note that in the case that the \textbf{IEEE80211\_HW\_SW\_CRYPTO\_CONTROL} flag is
set, mac80211 will not automatically fall back to software crypto if
enabling hardware crypto failed. The \code{set\_key()} call may also return the
value 1 to permit this specific key/algorithm to be done in software.

When the cmd is \code{DISABLE\_KEY} then it must succeed.

Note that it is permissible to not decrypt a frame even if a key
for it has been uploaded to hardware, the stack will not make any
decision based on whether a key has been uploaded or not but rather
based on the receive flags.

The {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_key_conf]{\emph{\code{struct ieee80211\_key\_conf}}}} structure pointed to by the \textbf{key}
parameter is guaranteed to be valid until another call to \code{set\_key()}
removes it, but it can only be used as a cookie to differentiate
keys.

In TKIP some HW need to be provided a phase 1 key, for RX decryption
acceleration (i.e. iwlwifi). Those drivers should provide update\_tkip\_key
handler.
The \code{update\_tkip\_key()} call updates the driver with the new phase 1 key.
This happens every time the iv16 wraps around (every 65536 packets). The
\code{set\_key()} call will happen only once for each key (unless the AP did
rekeying), it will not include a valid phase 1 key. The valid phase 1 key is
provided by update\_tkip\_key only. The trigger that makes mac80211 call this
handler is software decryption with wrap around of iv16.

The \code{set\_default\_unicast\_key()} call updates the default WEP key index
configured to the hardware for WEP encryption type. This is required
for devices that support offload of data packets (e.g. ARP responses).
\index{set\_key\_cmd (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.set_key_cmd}\pysigline{enum \bfcode{set\_key\_cmd}}
key command

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{SET\_KEY}}] \leavevmode
a key is set

\item[{\code{DISABLE\_KEY}}] \leavevmode
a key must be disabled

\end{description}

\textbf{Description}

Used with the \code{set\_key()} callback in {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_ops]{\emph{\code{struct ieee80211\_ops}}}}, this
indicates whether a key is being removed or added.
\index{ieee80211\_key\_conf (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_key_conf}\pysigline{struct \bfcode{ieee80211\_key\_conf}}
key information

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}key\PYGZus{}conf \PYGZob{}
  atomic64\PYGZus{}t tx\PYGZus{}pn;
  u32 cipher;
  u8 icv\PYGZus{}len;
  u8 iv\PYGZus{}len;
  u8 hw\PYGZus{}key\PYGZus{}idx;
  s8 keyidx;
  u16 flags;
  u8 keylen;
  u8 key[0];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{tx\_pn}}] \leavevmode
PN used for TX keys, may be used by the driver as well if it
needs to do software PN assignment by itself (e.g. due to TSO)

\item[{\code{cipher}}] \leavevmode
The key's cipher suite selector.

\item[{\code{icv\_len}}] \leavevmode
The ICV length for this key type

\item[{\code{iv\_len}}] \leavevmode
The IV length for this key type

\item[{\code{hw\_key\_idx}}] \leavevmode
To be set by the driver, this is the key index the driver
wants to be given when a frame is transmitted and needs to be
encrypted in hardware.

\item[{\code{keyidx}}] \leavevmode
the key index (0-3)

\item[{\code{flags}}] \leavevmode
key flags, see {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_key_flags]{\emph{\code{enum ieee80211\_key\_flags}}}}.

\item[{\code{keylen}}] \leavevmode
key material length

\item[{\code{key}}] \leavevmode
key material. For ALG\_TKIP the key is encoded as a 256-bit (32 byte)
data block:
- Temporal Encryption Key (128 bits)
- Temporal Authenticator Tx MIC Key (64 bits)
- Temporal Authenticator Rx MIC Key (64 bits)

\end{description}

\textbf{Description}

This key information is given by mac80211 to the driver by
the \code{set\_key()} callback in {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_ops]{\emph{\code{struct ieee80211\_ops}}}}.
\index{ieee80211\_key\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_key_flags}\pysigline{enum \bfcode{ieee80211\_key\_flags}}
key flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{IEEE80211\_KEY\_FLAG\_GENERATE\_IV\_MGMT}}] \leavevmode
This flag should be set by the
driver for a CCMP/GCMP key to indicate that is requires IV generation
only for managment frames (MFP).

\item[{\code{IEEE80211\_KEY\_FLAG\_GENERATE\_IV}}] \leavevmode
This flag should be set by the
driver to indicate that it requires IV generation for this
particular key. Setting this flag does not necessarily mean that SKBs
will have sufficient tailroom for ICV or MIC.

\item[{\code{IEEE80211\_KEY\_FLAG\_GENERATE\_MMIC}}] \leavevmode
This flag should be set by
the driver for a TKIP key if it requires Michael MIC
generation in software.

\item[{\code{IEEE80211\_KEY\_FLAG\_PAIRWISE}}] \leavevmode
Set by mac80211, this flag indicates
that the key is pairwise rather then a shared key.

\item[{\code{IEEE80211\_KEY\_FLAG\_SW\_MGMT\_TX}}] \leavevmode
This flag should be set by the driver for a
CCMP/GCMP key if it requires CCMP/GCMP encryption of management frames
(MFP) to be done in software.

\item[{\code{IEEE80211\_KEY\_FLAG\_PUT\_IV\_SPACE}}] \leavevmode
This flag should be set by the driver
if space should be prepared for the IV, but the IV
itself should not be generated. Do not set together with
\textbf{IEEE80211\_KEY\_FLAG\_GENERATE\_IV} on the same key. Setting this flag does
not necessarily mean that SKBs will have sufficient tailroom for ICV or
MIC.

\item[{\code{IEEE80211\_KEY\_FLAG\_RX\_MGMT}}] \leavevmode
This key will be used to decrypt received
management frames. The flag can help drivers that have a hardware
crypto implementation that doesn't deal with management frames
properly by allowing them to not upload the keys to hardware and
fall back to software crypto. Note that this flag deals only with
RX, if your crypto engine can't deal with TX you can also set the
\code{IEEE80211\_KEY\_FLAG\_SW\_MGMT\_TX} flag to encrypt such frames in SW.

\item[{\code{IEEE80211\_KEY\_FLAG\_RESERVE\_TAILROOM}}] \leavevmode
This flag should be set by the
driver for a key to indicate that sufficient tailroom must always
be reserved for ICV or MIC, even when HW encryption is enabled.

\item[{\code{IEEE80211\_KEY\_FLAG\_PUT\_MIC\_SPACE}}] \leavevmode
This flag should be set by the driver for
a TKIP key if it only requires MIC space. Do not set together with
\textbf{IEEE80211\_KEY\_FLAG\_GENERATE\_MMIC} on the same key.

\end{description}

\textbf{Description}

These flags are used for communication about keys between the driver
and mac80211, with the \textbf{flags} parameter of {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_key_conf]{\emph{\code{struct ieee80211\_key\_conf}}}}.
\index{ieee80211\_get\_tkip\_p1k (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_get_tkip_p1k}\pysiglinewithargsret{void \bfcode{ieee80211\_get\_tkip\_p1k}}{struct {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_key_conf]{\emph{ieee80211\_key\_conf}}} *\emph{ keyconf}, struct sk\_buff *\emph{ skb}, u16 *\emph{ p1k}}{}
get a TKIP phase 1 key

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_key\_conf * keyconf}}] \leavevmode
the parameter passed with the set key

\item[{\code{struct sk\_buff * skb}}] \leavevmode
the packet to take the IV32 value from that will be encrypted
with this P1K

\item[{\code{u16 * p1k}}] \leavevmode
a buffer to which the key will be written, as 5 u16 values

\end{description}

\textbf{Description}

This function returns the TKIP phase 1 key for the IV32 taken
from the given packet.
\index{ieee80211\_get\_tkip\_p1k\_iv (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_get_tkip_p1k_iv}\pysiglinewithargsret{void \bfcode{ieee80211\_get\_tkip\_p1k\_iv}}{struct {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_key_conf]{\emph{ieee80211\_key\_conf}}} *\emph{ keyconf}, u32\emph{ iv32}, u16 *\emph{ p1k}}{}
get a TKIP phase 1 key for IV32

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_key\_conf * keyconf}}] \leavevmode
the parameter passed with the set key

\item[{\code{u32 iv32}}] \leavevmode
IV32 to get the P1K for

\item[{\code{u16 * p1k}}] \leavevmode
a buffer to which the key will be written, as 5 u16 values

\end{description}

\textbf{Description}

This function returns the TKIP phase 1 key for the given IV32.
\index{ieee80211\_get\_tkip\_p2k (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_get_tkip_p2k}\pysiglinewithargsret{void \bfcode{ieee80211\_get\_tkip\_p2k}}{struct {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_key_conf]{\emph{ieee80211\_key\_conf}}} *\emph{ keyconf}, struct sk\_buff *\emph{ skb}, u8 *\emph{ p2k}}{}
get a TKIP phase 2 key

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_key\_conf * keyconf}}] \leavevmode
the parameter passed with the set key

\item[{\code{struct sk\_buff * skb}}] \leavevmode
the packet to take the IV32/IV16 values from that will be
encrypted with this key

\item[{\code{u8 * p2k}}] \leavevmode
a buffer to which the key will be written, 16 bytes

\end{description}

\textbf{Description}

This function computes the TKIP RC4 key for the IV values
in the packet.


\subsection{Powersave support}
\label{driver-api/80211/mac80211-advanced:powersave-support}
mac80211 has support for various powersave implementations.

First, it can support hardware that handles all powersaving by itself,
such hardware should simply set the \code{IEEE80211\_HW\_SUPPORTS\_PS} hardware
flag. In that case, it will be told about the desired powersave mode
with the \code{IEEE80211\_CONF\_PS} flag depending on the association status.
The hardware must take care of sending nullfunc frames when necessary,
i.e. when entering and leaving powersave mode. The hardware is required
to look at the AID in beacons and signal to the AP that it woke up when
it finds traffic directed to it.

\code{IEEE80211\_CONF\_PS} flag enabled means that the powersave mode defined in
IEEE 802.11-2007 section 11.2 is enabled. This is not to be confused
with hardware wakeup and sleep states. Driver is responsible for waking
up the hardware before issuing commands to the hardware and putting it
back to sleep at appropriate times.

When PS is enabled, hardware needs to wakeup for beacons and receive the
buffered multicast/broadcast frames after the beacon. Also it must be
possible to send frames and receive the acknowledment frame.

Other hardware designs cannot send nullfunc frames by themselves and also
need software support for parsing the TIM bitmap. This is also supported
by mac80211 by combining the \code{IEEE80211\_HW\_SUPPORTS\_PS} and
\code{IEEE80211\_HW\_PS\_NULLFUNC\_STACK} flags. The hardware is of course still
required to pass up beacons. The hardware is still required to handle
waking up for multicast traffic; if it cannot the driver must handle that
as best as it can, mac80211 is too slow to do that.

Dynamic powersave is an extension to normal powersave in which the
hardware stays awake for a user-specified period of time after sending a
frame so that reply frames need not be buffered and therefore delayed to
the next wakeup. It's compromise of getting good enough latency when
there's data traffic and still saving significantly power in idle
periods.

Dynamic powersave is simply supported by mac80211 enabling and disabling
PS based on traffic. Driver needs to only set \code{IEEE80211\_HW\_SUPPORTS\_PS}
flag and mac80211 will handle everything automatically. Additionally,
hardware having support for the dynamic PS feature may set the
\code{IEEE80211\_HW\_SUPPORTS\_DYNAMIC\_PS} flag to indicate that it can support
dynamic PS mode itself. The driver needs to look at the
\textbf{dynamic\_ps\_timeout} hardware configuration value and use it that value
whenever \code{IEEE80211\_CONF\_PS} is set. In this case mac80211 will disable
dynamic PS feature in stack and will just keep \code{IEEE80211\_CONF\_PS}
enabled whenever user has enabled powersave.

Driver informs U-APSD client support by enabling
\code{IEEE80211\_VIF\_SUPPORTS\_UAPSD} flag. The mode is configured through the
uapsd parameter in \code{conf\_tx()} operation. Hardware needs to send the QoS
Nullfunc frames and stay awake until the service period has ended. To
utilize U-APSD, dynamic powersave is disabled for voip AC and all frames
from that AC are transmitted with powersave enabled.

Note: U-APSD client mode is not yet supported with
\code{IEEE80211\_HW\_PS\_NULLFUNC\_STACK}.


\subsection{Beacon filter support}
\label{driver-api/80211/mac80211-advanced:beacon-filter-support}
Some hardware have beacon filter support to reduce host cpu wakeups
which will reduce system power consumption. It usually works so that
the firmware creates a checksum of the beacon but omits all constantly
changing elements (TSF, TIM etc). Whenever the checksum changes the
beacon is forwarded to the host, otherwise it will be just dropped. That
way the host will only receive beacons where some relevant information
(for example ERP protection or WMM settings) have changed.

Beacon filter support is advertised with the \code{IEEE80211\_VIF\_BEACON\_FILTER}
interface capability. The driver needs to enable beacon filter support
whenever power save is enabled, that is \code{IEEE80211\_CONF\_PS} is set. When
power save is enabled, the stack will not check for beacon loss and the
driver needs to notify about loss of beacons with {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_beacon_loss]{\emph{\code{ieee80211\_beacon\_loss()}}}}.

The time (or number of beacons missed) until the firmware notifies the
driver of a beacon loss event (which in turn causes the driver to call
{\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_beacon_loss]{\emph{\code{ieee80211\_beacon\_loss()}}}}) should be configurable and will be controlled
by mac80211 and the roaming algorithm in the future.

Since there may be constantly changing information elements that nothing
in the software stack cares about, we will, in the future, have mac80211
tell the driver which information elements are interesting in the sense
that we want to see changes in them. This will include
\begin{itemize}
\item {} 
a list of information element IDs

\item {} 
a list of OUIs for the vendor information element

\end{itemize}

Ideally, the hardware would filter out any beacons without changes in the
requested elements, but if it cannot support that it may, at the expense
of some efficiency, filter out only a subset. For example, if the device
doesn't support checking for OUIs it should pass up all changes in all
vendor information elements.

Note that change, for the sake of simplification, also includes information
elements appearing or disappearing from the beacon.

Some hardware supports an ``ignore list'' instead, just make sure nothing
that was requested is on the ignore list, and include commonly changing
information element IDs in the ignore list, for example 11 (BSS load) and
the various vendor-assigned IEs with unknown contents (128, 129, 133-136,
149, 150, 155, 156, 173, 176, 178, 179, 219); for forward compatibility
it could also include some currently unused IDs.

In addition to these capabilities, hardware should support notifying the
host of changes in the beacon RSSI. This is relevant to implement roaming
when no traffic is flowing (when traffic is flowing we see the RSSI of
the received data packets). This can consist in notifying the host when
the RSSI changes significantly or when it drops below or rises above
configurable thresholds. In the future these thresholds will also be
configured by mac80211 (which gets them from userspace) to implement
them as the roaming algorithm requires.

If the hardware cannot implement this, the driver should ask it to
periodically pass beacon frames to the host so that software can do the
signal strength threshold checking.
\index{ieee80211\_beacon\_loss (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_beacon_loss}\pysiglinewithargsret{void \bfcode{ieee80211\_beacon\_loss}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{ieee80211\_vif}}} *\emph{ vif}}{}
inform hardware does not receive beacons

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_vif * vif}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{\code{struct ieee80211\_vif}}}} pointer from the add\_interface callback.

\end{description}

\textbf{Description}

When beacon filtering is enabled with \code{IEEE80211\_VIF\_BEACON\_FILTER} and
\code{IEEE80211\_CONF\_PS} is set, the driver needs to inform whenever the
hardware is not receiving beacons with this function.


\subsection{Multiple queues and QoS support}
\label{driver-api/80211/mac80211-advanced:multiple-queues-and-qos-support}
TBD
\index{ieee80211\_tx\_queue\_params (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_tx_queue_params}\pysigline{struct \bfcode{ieee80211\_tx\_queue\_params}}
transmit queue configuration

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}tx\PYGZus{}queue\PYGZus{}params \PYGZob{}
  u16 txop;
  u16 cw\PYGZus{}min;
  u16 cw\PYGZus{}max;
  u8 aifs;
  bool acm;
  bool uapsd;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{txop}}] \leavevmode
maximum burst time in units of 32 usecs, 0 meaning disabled

\item[{\code{cw\_min}}] \leavevmode
minimum contention window {[}a value of the form
2\textasciicircum{}n-1 in the range 1..32767{]}

\item[{\code{cw\_max}}] \leavevmode
maximum contention window {[}like \textbf{cw\_min}{]}

\item[{\code{aifs}}] \leavevmode
arbitration interframe space {[}0..255{]}

\item[{\code{acm}}] \leavevmode
is mandatory admission control required for the access category

\item[{\code{uapsd}}] \leavevmode
is U-APSD mode enabled for the queue

\end{description}

\textbf{Description}

The information provided in this structure is required for QoS
transmit queue configuration. Cf. IEEE 802.11 7.3.2.29.


\subsection{Access point mode support}
\label{driver-api/80211/mac80211-advanced:access-point-mode-support}
TBD

Some parts of the if\_conf should be discussed here instead

Insert notes about VLAN interfaces with hw crypto here or in the hw
crypto chapter.


\subsubsection{support for powersaving clients}
\label{driver-api/80211/mac80211-advanced:support-for-powersaving-clients}
In order to implement AP and P2P GO modes, mac80211 has support for
client powersaving, both ``legacy'' PS (PS-Poll/null data) and uAPSD.
There currently is no support for sAPSD.

There is one assumption that mac80211 makes, namely that a client
will not poll with PS-Poll and trigger with uAPSD at the same time.
Both are supported, and both can be used by the same client, but
they can't be used concurrently by the same client. This simplifies
the driver code.

The first thing to keep in mind is that there is a flag for complete
driver implementation: \code{IEEE80211\_HW\_AP\_LINK\_PS}. If this flag is set,
mac80211 expects the driver to handle most of the state machine for
powersaving clients and will ignore the PM bit in incoming frames.
Drivers then use {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta_ps_transition]{\emph{\code{ieee80211\_sta\_ps\_transition()}}}} to inform mac80211 of
stations' powersave transitions. In this mode, mac80211 also doesn't
handle PS-Poll/uAPSD.

In the mode without \code{IEEE80211\_HW\_AP\_LINK\_PS}, mac80211 will check the
PM bit in incoming frames for client powersave transitions. When a
station goes to sleep, we will stop transmitting to it. There is,
however, a race condition: a station might go to sleep while there is
data buffered on hardware queues. If the device has support for this
it will reject frames, and the driver should give the frames back to
mac80211 with the \code{IEEE80211\_TX\_STAT\_TX\_FILTERED} flag set which will
cause mac80211 to retry the frame when the station wakes up. The
driver is also notified of powersave transitions by calling its
\textbf{sta\_notify} callback.

When the station is asleep, it has three choices: it can wake up,
it can PS-Poll, or it can possibly start a uAPSD service period.
Waking up is implemented by simply transmitting all buffered (and
filtered) frames to the station. This is the easiest case. When
the station sends a PS-Poll or a uAPSD trigger frame, mac80211
will inform the driver of this with the \textbf{allow\_buffered\_frames}
callback; this callback is optional. mac80211 will then transmit
the frames as usual and set the \code{IEEE80211\_TX\_CTL\_NO\_PS\_BUFFER}
on each frame. The last frame in the service period (or the only
response to a PS-Poll) also has \code{IEEE80211\_TX\_STATUS\_EOSP} set to
indicate that it ends the service period; as this frame must have
TX status report it also sets \code{IEEE80211\_TX\_CTL\_REQ\_TX\_STATUS}.
When TX status is reported for this frame, the service period is
marked has having ended and a new one can be started by the peer.

Additionally, non-bufferable MMPDUs can also be transmitted by
mac80211 with the \code{IEEE80211\_TX\_CTL\_NO\_PS\_BUFFER} set in them.

Another race condition can happen on some devices like iwlwifi
when there are frames queued for the station and it wakes up
or polls; the frames that are already queued could end up being
transmitted first instead, causing reordering and/or wrong
processing of the EOSP. The cause is that allowing frames to be
transmitted to a certain station is out-of-band communication to
the device. To allow this problem to be solved, the driver can
call {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta_block_awake]{\emph{\code{ieee80211\_sta\_block\_awake()}}}} if frames are buffered when it
is notified that the station went to sleep. When all these frames
have been filtered (see above), it must call the function again
to indicate that the station is no longer blocked.

If the driver buffers frames in the driver for aggregation in any
way, it must use the {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta_set_buffered]{\emph{\code{ieee80211\_sta\_set\_buffered()}}}} call when it is
notified of the station going to sleep to inform mac80211 of any
TIDs that have frames buffered. Note that when a station wakes up
this information is reset (hence the requirement to call it when
informed of the station going to sleep). Then, when a service
period starts for any reason, \textbf{release\_buffered\_frames} is called
with the number of frames to be released and which TIDs they are
to come from. In this case, the driver is responsible for setting
the EOSP (for uAPSD) and MORE\_DATA bits in the released frames,
to help the \textbf{more\_data} parameter is passed to tell the driver if
there is more data on other TIDs -- the TIDs to release frames
from are ignored since mac80211 doesn't know how many frames the
buffers for those TIDs contain.

If the driver also implement GO mode, where absence periods may
shorten service periods (or abort PS-Poll responses), it must
filter those response frames except in the case of frames that
are buffered in the driver -- those must remain buffered to avoid
reordering. Because it is possible that no frames are released
in this case, the driver must call {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta_eosp]{\emph{\code{ieee80211\_sta\_eosp()}}}}
to indicate to mac80211 that the service period ended anyway.

Finally, if frames from multiple TIDs are released from mac80211
but the driver might reorder them, it must clear \& set the flags
appropriately (only the last frame may have \code{IEEE80211\_TX\_STATUS\_EOSP})
and also take care of the EOSP and MORE\_DATA bits in the frame.
The driver may also use {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta_eosp]{\emph{\code{ieee80211\_sta\_eosp()}}}} in this case.

Note that if the driver ever buffers frames other than QoS-data
frames, it must take care to never send a non-QoS-data frame as
the last frame in a service period, adding a QoS-nulldata frame
after a non-QoS-data frame if needed.
\index{ieee80211\_get\_buffered\_bc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_get_buffered_bc}\pysiglinewithargsret{struct sk\_buff * \bfcode{ieee80211\_get\_buffered\_bc}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{ieee80211\_vif}}} *\emph{ vif}}{}
accessing buffered broadcast and multicast frames

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
pointer as obtained from {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_alloc_hw]{\emph{\code{ieee80211\_alloc\_hw()}}}}.

\item[{\code{struct ieee80211\_vif * vif}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{\code{struct ieee80211\_vif}}}} pointer from the add\_interface callback.

\end{description}

\textbf{Description}

Function for accessing buffered broadcast and multicast frames. If
hardware/firmware does not implement buffering of broadcast/multicast
frames when power saving is used, 802.11 code buffers them in the host
memory. The low-level driver uses this function to fetch next buffered
frame. In most cases, this is used when generating beacon frame.

\textbf{Return}

A pointer to the next buffered skb or NULL if no more buffered
frames are available.

\textbf{Note}

buffered frames are returned only after DTIM beacon frame was
generated with {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_beacon_get]{\emph{\code{ieee80211\_beacon\_get()}}}} and the low-level driver must thus
call {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_beacon_get]{\emph{\code{ieee80211\_beacon\_get()}}}} first. {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_get_buffered_bc]{\emph{\code{ieee80211\_get\_buffered\_bc()}}}} returns
NULL if the previous generated beacon was not DTIM, so the low-level driver
does not need to check for DTIM beacons separately and should be able to
use common code for all beacons.
\index{ieee80211\_beacon\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_beacon_get}\pysiglinewithargsret{struct sk\_buff * \bfcode{ieee80211\_beacon\_get}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{ieee80211\_vif}}} *\emph{ vif}}{}
beacon generation function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
pointer obtained from {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_alloc_hw]{\emph{\code{ieee80211\_alloc\_hw()}}}}.

\item[{\code{struct ieee80211\_vif * vif}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{\code{struct ieee80211\_vif}}}} pointer from the add\_interface callback.

\end{description}

\textbf{Description}

See \code{ieee80211\_beacon\_get\_tim()}.

\textbf{Return}

See \code{ieee80211\_beacon\_get\_tim()}.
\index{ieee80211\_sta\_eosp (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_sta_eosp}\pysiglinewithargsret{void \bfcode{ieee80211\_sta\_eosp}}{struct {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta]{\emph{ieee80211\_sta}}} *\emph{ pubsta}}{}
notify mac80211 about end of SP

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_sta * pubsta}}] \leavevmode
the station

\end{description}

\textbf{Description}

When a device transmits frames in a way that it can't tell
mac80211 in the TX status about the EOSP, it must clear the
\code{IEEE80211\_TX\_STATUS\_EOSP} bit and call this function instead.
This applies for PS-Poll as well as uAPSD.

Note that just like with \code{\_tx\_status()} and \code{\_rx()} drivers must
not mix calls to irqsafe/non-irqsafe versions, this function
must not be mixed with those either. Use the all irqsafe, or
all non-irqsafe, don't mix!
\begin{description}
\item[{NB: the \_irqsafe version of this function doesn't exist, no}] \leavevmode
driver needs it right now. Don't call this function if
you'd need the \_irqsafe version, look at the git history
and restore the \_irqsafe version!

\end{description}
\index{ieee80211\_frame\_release\_type (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_frame_release_type}\pysigline{enum \bfcode{ieee80211\_frame\_release\_type}}
frame release reason

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{IEEE80211\_FRAME\_RELEASE\_PSPOLL}}] \leavevmode
frame released for PS-Poll

\item[{\code{IEEE80211\_FRAME\_RELEASE\_UAPSD}}] \leavevmode
frame(s) released due to
frame received on trigger-enabled AC

\end{description}
\index{ieee80211\_sta\_ps\_transition (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_sta_ps_transition}\pysiglinewithargsret{int \bfcode{ieee80211\_sta\_ps\_transition}}{struct {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta]{\emph{ieee80211\_sta}}} *\emph{ sta}, bool\emph{ start}}{}
PS transition for connected sta

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_sta * sta}}] \leavevmode
currently connected sta

\item[{\code{bool start}}] \leavevmode
start or stop PS

\end{description}

\textbf{Description}

When operating in AP mode with the \code{IEEE80211\_HW\_AP\_LINK\_PS}
flag set, use this function to inform mac80211 about a connected station
entering/leaving PS mode.

This function may not be called in IRQ context or with softirqs enabled.

Calls to this function for a single hardware must be synchronized against
each other.

\textbf{Return}

0 on success. -EINVAL when the requested PS mode is already set.
\index{ieee80211\_sta\_ps\_transition\_ni (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_sta_ps_transition_ni}\pysiglinewithargsret{int \bfcode{ieee80211\_sta\_ps\_transition\_ni}}{struct {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta]{\emph{ieee80211\_sta}}} *\emph{ sta}, bool\emph{ start}}{}
PS transition for connected sta (in process context)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_sta * sta}}] \leavevmode
currently connected sta

\item[{\code{bool start}}] \leavevmode
start or stop PS

\end{description}

\textbf{Description}

Like {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta_ps_transition]{\emph{\code{ieee80211\_sta\_ps\_transition()}}}} but can be called in process context
(internally disables bottom halves). Concurrent call restriction still
applies.

\textbf{Return}

Like {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta_ps_transition]{\emph{\code{ieee80211\_sta\_ps\_transition()}}}}.
\index{ieee80211\_sta\_set\_buffered (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_sta_set_buffered}\pysiglinewithargsret{void \bfcode{ieee80211\_sta\_set\_buffered}}{struct {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta]{\emph{ieee80211\_sta}}} *\emph{ sta}, u8\emph{ tid}, bool\emph{ buffered}}{}
inform mac80211 about driver-buffered frames

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_sta * sta}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta]{\emph{\code{struct ieee80211\_sta}}}} pointer for the sleeping station

\item[{\code{u8 tid}}] \leavevmode
the TID that has buffered frames

\item[{\code{bool buffered}}] \leavevmode
indicates whether or not frames are buffered for this TID

\end{description}

\textbf{Description}

If a driver buffers frames for a powersave station instead of passing
them back to mac80211 for retransmission, the station may still need
to be told that there are buffered frames via the TIM bit.

This function informs mac80211 whether or not there are frames that are
buffered in the driver for a given TID; mac80211 can then use this data
to set the TIM bit (NOTE: This may call back into the driver's set\_tim
call! Beware of the locking!)

If all frames are released to the station (due to PS-poll or uAPSD)
then the driver needs to inform mac80211 that there no longer are
frames buffered. However, when the station wakes up mac80211 assumes
that all buffered frames will be transmitted and clears this data,
drivers need to make sure they inform mac80211 about all buffered
frames on the sleep transition (\code{sta\_notify()} with \code{STA\_NOTIFY\_SLEEP}).

Note that technically mac80211 only needs to know this per AC, not per
TID, but since driver buffering will inevitably happen per TID (since
it is related to aggregation) it is easier to make mac80211 map the
TID to the AC as required instead of keeping track in all drivers that
use this API.
\index{ieee80211\_sta\_block\_awake (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_sta_block_awake}\pysiglinewithargsret{void \bfcode{ieee80211\_sta\_block\_awake}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta]{\emph{ieee80211\_sta}}} *\emph{ pubsta}, bool\emph{ block}}{}
block station from waking up

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware

\item[{\code{struct ieee80211\_sta * pubsta}}] \leavevmode
the station

\item[{\code{bool block}}] \leavevmode
whether to block or unblock

\end{description}

\textbf{Description}

Some devices require that all frames that are on the queues
for a specific station that went to sleep are flushed before
a poll response or frames after the station woke up can be
delivered to that it. Note that such frames must be rejected
by the driver as filtered, with the appropriate status flag.

This function allows implementing this mode in a race-free
manner.

To do this, a driver must keep track of the number of frames
still enqueued for a specific station. If this number is not
zero when the station goes to sleep, the driver must call
this function to force mac80211 to consider the station to
be asleep regardless of the station's actual state. Once the
number of outstanding frames reaches zero, the driver must
call this function again to unblock the station. That will
cause mac80211 to be able to send ps-poll responses, and if
the station queried in the meantime then frames will also
be sent out as a result of this. Additionally, the driver
will be notified that the station woke up some time after
it is unblocked, regardless of whether the station actually
woke up while blocked or not.


\subsection{Supporting multiple virtual interfaces}
\label{driver-api/80211/mac80211-advanced:supporting-multiple-virtual-interfaces}
TBD

Note: WDS with identical MAC address should almost always be OK

Insert notes about having multiple virtual interfaces with different MAC
addresses here, note which configurations are supported by mac80211, add
notes about supporting hw crypto with it.
\index{ieee80211\_iterate\_active\_interfaces (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_iterate_active_interfaces}\pysiglinewithargsret{void \bfcode{ieee80211\_iterate\_active\_interfaces}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, u32\emph{ iter\_flags}, void (*iterator) (void\emph{ *data}, u8\emph{ *mac}, struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{ieee80211\_vif}}}\emph{ *vif}, void *\emph{ data}}{}
iterate active interfaces

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware struct of which the interfaces should be iterated over

\item[{\code{u32 iter\_flags}}] \leavevmode
iteration flags, see \code{enum ieee80211\_interface\_iteration\_flags}

\item[{\code{void (*)(void *data, u8 *mac, struct ieee80211\_vif *vif) iterator}}] \leavevmode
the iterator function to call

\item[{\code{void * data}}] \leavevmode
first argument of the iterator function

\end{description}

\textbf{Description}

This function iterates over the interfaces associated with a given
hardware that are currently active and calls the callback for them.
This function allows the iterator function to sleep, when the iterator
function is atomic \textbf{ieee80211\_iterate\_active\_interfaces\_atomic} can
be used.
Does not iterate over a new interface during \code{add\_interface()}.
\index{ieee80211\_iterate\_active\_interfaces\_atomic (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_iterate_active_interfaces_atomic}\pysiglinewithargsret{void \bfcode{ieee80211\_iterate\_active\_interfaces\_atomic}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, u32\emph{ iter\_flags}, void (*iterator) (void\emph{ *data}, u8\emph{ *mac}, struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{ieee80211\_vif}}}\emph{ *vif}, void *\emph{ data}}{}
iterate active interfaces

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware struct of which the interfaces should be iterated over

\item[{\code{u32 iter\_flags}}] \leavevmode
iteration flags, see \code{enum ieee80211\_interface\_iteration\_flags}

\item[{\code{void (*)(void *data, u8 *mac, struct ieee80211\_vif *vif) iterator}}] \leavevmode
the iterator function to call, cannot sleep

\item[{\code{void * data}}] \leavevmode
first argument of the iterator function

\end{description}

\textbf{Description}

This function iterates over the interfaces associated with a given
hardware that are currently active and calls the callback for them.
This function requires the iterator callback function to be atomic,
if that is not desired, use \textbf{ieee80211\_iterate\_active\_interfaces} instead.
Does not iterate over a new interface during \code{add\_interface()}.


\subsection{Station handling}
\label{driver-api/80211/mac80211-advanced:station-handling}
TODO
\index{ieee80211\_sta (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_sta}\pysigline{struct \bfcode{ieee80211\_sta}}
station table entry

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}sta \PYGZob{}
  u32 supp\PYGZus{}rates[NUM\PYGZus{}NL80211\PYGZus{}BANDS];
  u8 addr[ETH\PYGZus{}ALEN];
  u16 aid;
  struct ieee80211\PYGZus{}sta\PYGZus{}ht\PYGZus{}cap ht\PYGZus{}cap;
  struct ieee80211\PYGZus{}sta\PYGZus{}vht\PYGZus{}cap vht\PYGZus{}cap;
  u8 max\PYGZus{}rx\PYGZus{}aggregation\PYGZus{}subframes;
  bool wme;
  u8 uapsd\PYGZus{}queues;
  u8 max\PYGZus{}sp;
  u8 rx\PYGZus{}nss;
  enum ieee80211\PYGZus{}sta\PYGZus{}rx\PYGZus{}bandwidth bandwidth;
  enum ieee80211\PYGZus{}smps\PYGZus{}mode smps\PYGZus{}mode;
  struct ieee80211\PYGZus{}sta\PYGZus{}rates \PYGZus{}\PYGZus{}rcu *rates;
  bool tdls;
  bool tdls\PYGZus{}initiator;
  bool mfp;
  u8 max\PYGZus{}amsdu\PYGZus{}subframes;
  u16 max\PYGZus{}amsdu\PYGZus{}len;
  bool support\PYGZus{}p2p\PYGZus{}ps;
  u16 max\PYGZus{}rc\PYGZus{}amsdu\PYGZus{}len;
  struct ieee80211\PYGZus{}txq *txq[IEEE80211\PYGZus{}NUM\PYGZus{}TIDS];
  u8 drv\PYGZus{}priv[0] ;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{supp\_rates}}] \leavevmode
Bitmap of supported rates (per band)

\item[{\code{addr}}] \leavevmode
MAC address

\item[{\code{aid}}] \leavevmode
AID we assigned to the station if we're an AP

\item[{\code{ht\_cap}}] \leavevmode
HT capabilities of this STA; restricted to our own capabilities

\item[{\code{vht\_cap}}] \leavevmode
VHT capabilities of this STA; restricted to our own capabilities

\item[{\code{max\_rx\_aggregation\_subframes}}] \leavevmode
maximal amount of frames in a single AMPDU
that this station is allowed to transmit to us.
Can be modified by driver.

\item[{\code{wme}}] \leavevmode
indicates whether the STA supports QoS/WME (if local devices does,
otherwise always false)

\item[{\code{uapsd\_queues}}] \leavevmode
bitmap of queues configured for uapsd. Only valid
if wme is supported. The bits order is like in
IEEE80211\_WMM\_IE\_STA\_QOSINFO\_AC\_*.

\item[{\code{max\_sp}}] \leavevmode
max Service Period. Only valid if wme is supported.

\item[{\code{rx\_nss}}] \leavevmode
in HT/VHT, the maximum number of spatial streams the
station can receive at the moment, changed by operating mode
notifications and capabilities. The value is only valid after
the station moves to associated state.

\item[{\code{bandwidth}}] \leavevmode
current bandwidth the station can receive with

\item[{\code{smps\_mode}}] \leavevmode
current SMPS mode (off, static or dynamic)

\item[{\code{rates}}] \leavevmode
rate control selection table

\item[{\code{tdls}}] \leavevmode
indicates whether the STA is a TDLS peer

\item[{\code{tdls\_initiator}}] \leavevmode
indicates the STA is an initiator of the TDLS link. Only
valid if the STA is a TDLS peer in the first place.

\item[{\code{mfp}}] \leavevmode
indicates whether the STA uses management frame protection or not.

\item[{\code{max\_amsdu\_subframes}}] \leavevmode
indicates the maximal number of MSDUs in a single
A-MSDU. Taken from the Extended Capabilities element. 0 means
unlimited.

\item[{\code{max\_amsdu\_len}}] \leavevmode
indicates the maximal length of an A-MSDU in bytes.
This field is always valid for packets with a VHT preamble.
For packets with a HT preamble, additional limits apply:
\begin{itemize}
\item {} 
If the skb is transmitted as part of a BA agreement, the
A-MSDU maximal size is min(max\_amsdu\_len, 4065) bytes.

\item {} 
If the skb is not part of a BA aggreement, the A-MSDU maximal
size is min(max\_amsdu\_len, 7935) bytes.

\end{itemize}

Both additional HT limits must be enforced by the low level
driver. This is defined by the spec (IEEE 802.11-2012 section
8.3.2.2 NOTE 2).

\item[{\code{support\_p2p\_ps}}] \leavevmode
indicates whether the STA supports P2P PS mechanism or not.

\item[{\code{max\_rc\_amsdu\_len}}] \leavevmode
Maximum A-MSDU size in bytes recommended by rate control.

\item[{\code{txq}}] \leavevmode
per-TID data TX queues (if driver uses the TXQ abstraction)

\item[{\code{drv\_priv}}] \leavevmode
data area for driver use, will always be aligned to
sizeof(void *), size is determined in hw information.

\end{description}

\textbf{Description}

A station table entry represents a station we are possibly
communicating with. Since stations are RCU-managed in
mac80211, any ieee80211\_sta pointer you get access to must
either be protected by \code{rcu\_read\_lock()} explicitly or implicitly,
or you must take good care to not use such a pointer after a
call to your sta\_remove callback that removed it.
\index{sta\_notify\_cmd (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.sta_notify_cmd}\pysigline{enum \bfcode{sta\_notify\_cmd}}
sta notify command

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{STA\_NOTIFY\_SLEEP}}] \leavevmode
a station is now sleeping

\item[{\code{STA\_NOTIFY\_AWAKE}}] \leavevmode
a sleeping station woke up

\end{description}

\textbf{Description}

Used with the \code{sta\_notify()} callback in {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_ops]{\emph{\code{struct ieee80211\_ops}}}}, this
indicates if an associated station made a power state transition.
\index{ieee80211\_find\_sta (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_find_sta}\pysiglinewithargsret{struct {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta]{\emph{ieee80211\_sta}}} * \bfcode{ieee80211\_find\_sta}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{ieee80211\_vif}}} *\emph{ vif}, const u8 *\emph{ addr}}{}
find a station

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_vif * vif}}] \leavevmode
virtual interface to look for station on

\item[{\code{const u8 * addr}}] \leavevmode
station's address

\end{description}

\textbf{Return}

The station, if found. \code{NULL} otherwise.

\textbf{Note}

This function must be called under RCU lock and the
resulting pointer is only valid under RCU lock as well.
\index{ieee80211\_find\_sta\_by\_ifaddr (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_find_sta_by_ifaddr}\pysiglinewithargsret{struct {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta]{\emph{ieee80211\_sta}}} * \bfcode{ieee80211\_find\_sta\_by\_ifaddr}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, const u8 *\emph{ addr}, const u8 *\emph{ localaddr}}{}
find a station on hardware

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
pointer as obtained from {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_alloc_hw]{\emph{\code{ieee80211\_alloc\_hw()}}}}

\item[{\code{const u8 * addr}}] \leavevmode
remote station's address

\item[{\code{const u8 * localaddr}}] \leavevmode
local address (vif-\textgreater{}sdata-\textgreater{}vif.addr). Use NULL for `any'.

\end{description}

\textbf{Return}

The station, if found. \code{NULL} otherwise.

\textbf{Note}

This function must be called under RCU lock and the
resulting pointer is only valid under RCU lock as well.

\textbf{NOTE}
\begin{description}
\item[{You may pass NULL for localaddr, but then you will just get}] \leavevmode
the first STA that matches the remote address `addr'.
We can have multiple STA associated with multiple
logical stations (e.g. consider a station connecting to another
BSSID on the same AP hardware without disconnecting first).
In this case, the result of this method with localaddr NULL
is not reliable.

\end{description}

DO NOT USE THIS FUNCTION with localaddr NULL if at all possible.


\subsection{Hardware scan offload}
\label{driver-api/80211/mac80211-advanced:hardware-scan-offload}
TBD
\index{ieee80211\_scan\_completed (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_scan_completed}\pysiglinewithargsret{void \bfcode{ieee80211\_scan\_completed}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_hw]{\emph{ieee80211\_hw}}} *\emph{ hw}, struct cfg80211\_scan\_info *\emph{ info}}{}
completed hardware scan

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_hw * hw}}] \leavevmode
the hardware that finished the scan

\item[{\code{struct cfg80211\_scan\_info * info}}] \leavevmode
information about the completed scan

\end{description}

\textbf{Description}

When hardware scan offload is used (i.e. the \code{hw\_scan()} callback is
assigned) this function needs to be called by the driver to notify
mac80211 that the scan finished. This function can be called from
any context, including hardirq context.


\subsection{Aggregation}
\label{driver-api/80211/mac80211-advanced:aggregation}

\subsubsection{TX A-MPDU aggregation}
\label{driver-api/80211/mac80211-advanced:tx-a-mpdu-aggregation}
Aggregation on the TX side requires setting the hardware flag
\code{IEEE80211\_HW\_AMPDU\_AGGREGATION}. The driver will then be handed
packets with a flag indicating A-MPDU aggregation. The driver
or device is responsible for actually aggregating the frames,
as well as deciding how many and which to aggregate.

When TX aggregation is started by some subsystem (usually the rate
control algorithm would be appropriate) by calling the
{\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_start_tx_ba_session]{\emph{\code{ieee80211\_start\_tx\_ba\_session()}}}} function, the driver will be
notified via its \textbf{ampdu\_action} function, with the
\code{IEEE80211\_AMPDU\_TX\_START} action.

In response to that, the driver is later required to call the
{\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_start_tx_ba_cb_irqsafe]{\emph{\code{ieee80211\_start\_tx\_ba\_cb\_irqsafe()}}}} function, which will really
start the aggregation session after the peer has also responded.
If the peer responds negatively, the session will be stopped
again right away. Note that it is possible for the aggregation
session to be stopped before the driver has indicated that it
is done setting it up, in which case it must not indicate the
setup completion.

Also note that, since we also need to wait for a response from
the peer, the driver is notified of the completion of the
handshake by the \code{IEEE80211\_AMPDU\_TX\_OPERATIONAL} action to the
\textbf{ampdu\_action} callback.

Similarly, when the aggregation session is stopped by the peer
or something calling {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_stop_tx_ba_session]{\emph{\code{ieee80211\_stop\_tx\_ba\_session()}}}}, the driver's
\textbf{ampdu\_action} function will be called with the action
\code{IEEE80211\_AMPDU\_TX\_STOP}. In this case, the call must not fail,
and the driver must later call {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_stop_tx_ba_cb_irqsafe]{\emph{\code{ieee80211\_stop\_tx\_ba\_cb\_irqsafe()}}}}.
Note that the sta can get destroyed before the BA tear down is
complete.


\subsubsection{RX A-MPDU aggregation}
\label{driver-api/80211/mac80211-advanced:rx-a-mpdu-aggregation}
Aggregation on the RX side requires only implementing the
\textbf{ampdu\_action} callback that is invoked to start/stop any
block-ack sessions for RX aggregation.

When RX aggregation is started by the peer, the driver is
notified via \textbf{ampdu\_action} function, with the
\code{IEEE80211\_AMPDU\_RX\_START} action, and may reject the request
in which case a negative response is sent to the peer, if it
accepts it a positive response is sent.

While the session is active, the device/driver are required
to de-aggregate frames and pass them up one by one to mac80211,
which will handle the reorder buffer.

When the aggregation session is stopped again by the peer or
ourselves, the driver's \textbf{ampdu\_action} function will be called
with the action \code{IEEE80211\_AMPDU\_RX\_STOP}. In this case, the
call must not fail.
\index{ieee80211\_ampdu\_mlme\_action (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_ampdu_mlme_action}\pysigline{enum \bfcode{ieee80211\_ampdu\_mlme\_action}}
A-MPDU actions

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{IEEE80211\_AMPDU\_RX\_START}}] \leavevmode
start RX aggregation

\item[{\code{IEEE80211\_AMPDU\_RX\_STOP}}] \leavevmode
stop RX aggregation

\item[{\code{IEEE80211\_AMPDU\_TX\_START}}] \leavevmode
start TX aggregation

\item[{\code{IEEE80211\_AMPDU\_TX\_STOP\_CONT}}] \leavevmode
stop TX aggregation but continue transmitting
queued packets, now unaggregated. After all packets are transmitted the
driver has to call {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_stop_tx_ba_cb_irqsafe]{\emph{\code{ieee80211\_stop\_tx\_ba\_cb\_irqsafe()}}}}.

\item[{\code{IEEE80211\_AMPDU\_TX\_STOP\_FLUSH}}] \leavevmode
stop TX aggregation and flush all packets,
called when the station is removed. There's no need or reason to call
{\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_stop_tx_ba_cb_irqsafe]{\emph{\code{ieee80211\_stop\_tx\_ba\_cb\_irqsafe()}}}} in this case as mac80211 assumes the
session is gone and removes the station.

\item[{\code{IEEE80211\_AMPDU\_TX\_STOP\_FLUSH\_CONT}}] \leavevmode
called when TX aggregation is stopped
but the driver hasn't called {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_stop_tx_ba_cb_irqsafe]{\emph{\code{ieee80211\_stop\_tx\_ba\_cb\_irqsafe()}}}} yet and
now the connection is dropped and the station will be removed. Drivers
should clean up and drop remaining packets when this is called.

\item[{\code{IEEE80211\_AMPDU\_TX\_OPERATIONAL}}] \leavevmode
TX aggregation has become operational

\end{description}

\textbf{Description}

These flags are used with the \code{ampdu\_action()} callback in
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_ops]{\emph{\code{struct ieee80211\_ops}}}} to indicate which action is needed.

Note that drivers MUST be able to deal with a TX aggregation
session being stopped even before they OK'ed starting it by
calling ieee80211\_start\_tx\_ba\_cb\_irqsafe, because the peer
might receive the addBA frame and send a delBA right away!


\subsection{Spatial Multiplexing Powersave (SMPS)}
\label{driver-api/80211/mac80211-advanced:spatial-multiplexing-powersave-smps}
SMPS (Spatial multiplexing power save) is a mechanism to conserve
power in an 802.11n implementation. For details on the mechanism
and rationale, please refer to 802.11 (as amended by 802.11n-2009)
``11.2.3 SM power save''.

The mac80211 implementation is capable of sending action frames
to update the AP about the station's SMPS mode, and will instruct
the driver to enter the specific mode. It will also announce the
requested SMPS mode during the association handshake. Hardware
support for this feature is required, and can be indicated by
hardware flags.

The default mode will be ``automatic'', which nl80211/cfg80211
defines to be dynamic SMPS in (regular) powersave, and SMPS
turned off otherwise.

To support this feature, the driver must set the appropriate
hardware support flags, and handle the SMPS flag to the \code{config()}
operation. It will then with this mechanism be instructed to
enter the requested SMPS mode while associated to an HT AP.
\index{ieee80211\_request\_smps (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_request_smps}\pysiglinewithargsret{void \bfcode{ieee80211\_request\_smps}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{ieee80211\_vif}}} *\emph{ vif}, enum {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_smps_mode]{\emph{ieee80211\_smps\_mode}}}\emph{ smps\_mode}}{}
request SM PS transition

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_vif * vif}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{\code{struct ieee80211\_vif}}}} pointer from the add\_interface callback.

\item[{\code{enum ieee80211\_smps\_mode smps\_mode}}] \leavevmode
new SM PS mode

\end{description}

\textbf{Description}

This allows the driver to request an SM PS transition in managed
mode. This is useful when the driver has more information than
the stack about possible interference, for example by bluetooth.
\index{ieee80211\_smps\_mode (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_smps_mode}\pysigline{enum \bfcode{ieee80211\_smps\_mode}}
spatial multiplexing power save mode

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{IEEE80211\_SMPS\_AUTOMATIC}}] \leavevmode
automatic

\item[{\code{IEEE80211\_SMPS\_OFF}}] \leavevmode
off

\item[{\code{IEEE80211\_SMPS\_STATIC}}] \leavevmode
static

\item[{\code{IEEE80211\_SMPS\_DYNAMIC}}] \leavevmode
dynamic

\item[{\code{IEEE80211\_SMPS\_NUM\_MODES}}] \leavevmode
internal, don't use

\end{description}

TBD

This part of the book describes the rate control algorithm interface and
how it relates to mac80211 and drivers.


\subsection{Rate Control API}
\label{driver-api/80211/mac80211-advanced:rate-control-api}
TBD
\index{ieee80211\_start\_tx\_ba\_session (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_start_tx_ba_session}\pysiglinewithargsret{int \bfcode{ieee80211\_start\_tx\_ba\_session}}{struct {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta]{\emph{ieee80211\_sta}}} *\emph{ sta}, u16\emph{ tid}, u16\emph{ timeout}}{}
Start a tx Block Ack session.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_sta * sta}}] \leavevmode
the station for which to start a BA session

\item[{\code{u16 tid}}] \leavevmode
the TID to BA on.

\item[{\code{u16 timeout}}] \leavevmode
session timeout value (in TUs)

\end{description}

\textbf{Return}

success if addBA request was sent, failure otherwise

Although mac80211/low level driver/user space application can estimate
the need to start aggregation on a certain RA/TID, the session level
will be managed by the mac80211.
\index{ieee80211\_start\_tx\_ba\_cb\_irqsafe (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_start_tx_ba_cb_irqsafe}\pysiglinewithargsret{void \bfcode{ieee80211\_start\_tx\_ba\_cb\_irqsafe}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{ieee80211\_vif}}} *\emph{ vif}, const u8 *\emph{ ra}, u16\emph{ tid}}{}
low level driver ready to aggregate.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_vif * vif}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{\code{struct ieee80211\_vif}}}} pointer from the add\_interface callback

\item[{\code{const u8 * ra}}] \leavevmode
receiver address of the BA session recipient.

\item[{\code{u16 tid}}] \leavevmode
the TID to BA on.

\end{description}

\textbf{Description}

This function must be called by low level driver once it has
finished with preparations for the BA session. It can be called
from any context.
\index{ieee80211\_stop\_tx\_ba\_session (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_stop_tx_ba_session}\pysiglinewithargsret{int \bfcode{ieee80211\_stop\_tx\_ba\_session}}{struct {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta]{\emph{ieee80211\_sta}}} *\emph{ sta}, u16\emph{ tid}}{}
Stop a Block Ack session.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_sta * sta}}] \leavevmode
the station whose BA session to stop

\item[{\code{u16 tid}}] \leavevmode
the TID to stop BA.

\end{description}

\textbf{Return}

negative error if the TID is invalid, or no aggregation active

Although mac80211/low level driver/user space application can estimate
the need to stop aggregation on a certain RA/TID, the session level
will be managed by the mac80211.
\index{ieee80211\_stop\_tx\_ba\_cb\_irqsafe (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_stop_tx_ba_cb_irqsafe}\pysiglinewithargsret{void \bfcode{ieee80211\_stop\_tx\_ba\_cb\_irqsafe}}{struct {\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{ieee80211\_vif}}} *\emph{ vif}, const u8 *\emph{ ra}, u16\emph{ tid}}{}
low level driver ready to stop aggregate.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_vif * vif}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211:c.ieee80211_vif]{\emph{\code{struct ieee80211\_vif}}}} pointer from the add\_interface callback

\item[{\code{const u8 * ra}}] \leavevmode
receiver address of the BA session recipient.

\item[{\code{u16 tid}}] \leavevmode
the desired TID to BA on.

\end{description}

\textbf{Description}

This function must be called by low level driver once it has
finished with preparations for the BA session tear down. It
can be called from any context.
\index{ieee80211\_rate\_control\_changed (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_rate_control_changed}\pysigline{enum \bfcode{ieee80211\_rate\_control\_changed}}
flags to indicate what changed

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{IEEE80211\_RC\_BW\_CHANGED}}] \leavevmode
The bandwidth that can be used to transmit
to this station changed. The actual bandwidth is in the station
information -- for HT20/40 the IEEE80211\_HT\_CAP\_SUP\_WIDTH\_20\_40
flag changes, for HT and VHT the bandwidth field changes.

\item[{\code{IEEE80211\_RC\_SMPS\_CHANGED}}] \leavevmode
The SMPS state of the station changed.

\item[{\code{IEEE80211\_RC\_SUPP\_RATES\_CHANGED}}] \leavevmode
The supported rate set of this peer
changed (in IBSS mode) due to discovering more information about
the peer.

\item[{\code{IEEE80211\_RC\_NSS\_CHANGED}}] \leavevmode
N\_SS (number of spatial streams) was changed
by the peer

\end{description}
\index{ieee80211\_tx\_rate\_control (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_tx_rate_control}\pysigline{struct \bfcode{ieee80211\_tx\_rate\_control}}
rate control information for/from RC algo

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ieee80211\PYGZus{}tx\PYGZus{}rate\PYGZus{}control \PYGZob{}
  struct ieee80211\PYGZus{}hw *hw;
  struct ieee80211\PYGZus{}supported\PYGZus{}band *sband;
  struct ieee80211\PYGZus{}bss\PYGZus{}conf *bss\PYGZus{}conf;
  struct sk\PYGZus{}buff *skb;
  struct ieee80211\PYGZus{}tx\PYGZus{}rate reported\PYGZus{}rate;
  bool rts, short\PYGZus{}preamble;
  u32 rate\PYGZus{}idx\PYGZus{}mask;
  u8 *rate\PYGZus{}idx\PYGZus{}mcs\PYGZus{}mask;
  bool bss;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{hw}}] \leavevmode
The hardware the algorithm is invoked for.

\item[{\code{sband}}] \leavevmode
The band this frame is being transmitted on.

\item[{\code{bss\_conf}}] \leavevmode
the current BSS configuration

\item[{\code{skb}}] \leavevmode
the skb that will be transmitted, the control information in it needs
to be filled in

\item[{\code{reported\_rate}}] \leavevmode
The rate control algorithm can fill this in to indicate
which rate should be reported to userspace as the current rate and
used for rate calculations in the mesh network.

\item[{\code{rts}}] \leavevmode
whether RTS will be used for this frame because it is longer than the
RTS threshold

\item[{\code{short\_preamble}}] \leavevmode
whether mac80211 will request short-preamble transmission
if the selected rate supports it

\item[{\code{rate\_idx\_mask}}] \leavevmode
user-requested (legacy) rate mask

\item[{\code{rate\_idx\_mcs\_mask}}] \leavevmode
user-requested MCS rate mask (NULL if not in use)

\item[{\code{bss}}] \leavevmode
whether this frame is sent out in AP or IBSS mode

\end{description}
\index{rate\_control\_send\_low (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.rate_control_send_low}\pysiglinewithargsret{bool \bfcode{rate\_control\_send\_low}}{struct {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta]{\emph{ieee80211\_sta}}} *\emph{ sta}, void *\emph{ priv\_sta}, struct {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_tx_rate_control]{\emph{ieee80211\_tx\_rate\_control}}} *\emph{ txrc}}{}
helper for drivers for management/no-ack frames

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ieee80211\_sta * sta}}] \leavevmode
{\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta]{\emph{\code{struct ieee80211\_sta}}}} pointer to the target destination. Note
that this may be null.

\item[{\code{void * priv\_sta}}] \leavevmode
private rate control structure. This may be null.

\item[{\code{struct ieee80211\_tx\_rate\_control * txrc}}] \leavevmode
rate control information we sholud populate for mac80211.

\end{description}

\textbf{Description}

Rate control algorithms that agree to use the lowest rate to
send management frames and NO\_ACK data with the respective hw
retries should use this in the beginning of their mac80211 get\_rate
callback. If true is returned the rate control can simply return.
If false is returned we guarantee that sta and sta and priv\_sta is
not null.

Rate control algorithms wishing to do more intelligent selection of
rate for multicast/broadcast frames may choose to not use this.

TBD

This part of the book describes mac80211 internals.


\subsection{Key handling}
\label{driver-api/80211/mac80211-advanced:key-handling}

\subsubsection{Key handling basics}
\label{driver-api/80211/mac80211-advanced:key-handling-basics}
Key handling in mac80211 is done based on per-interface (sub\_if\_data)
keys and per-station keys. Since each station belongs to an interface,
each station key also belongs to that interface.

Hardware acceleration is done on a best-effort basis for algorithms
that are implemented in software,  for each key the hardware is asked
to enable that key for offloading but if it cannot do that the key is
simply kept for software encryption (unless it is for an algorithm
that isn't implemented in software).
There is currently no way of knowing whether a key is handled in SW
or HW except by looking into debugfs.

All key management is internally protected by a mutex. Within all
other parts of mac80211, key references are, just as STA structure
references, protected by RCU. Note, however, that some things are
unprotected, namely the key-\textgreater{}sta dereferences within the hardware
acceleration functions. This means that \code{sta\_info\_destroy()} must
remove the key which waits for an RCU grace period.


\subsubsection{MORE TBD}
\label{driver-api/80211/mac80211-advanced:more-tbd}
TBD


\subsection{Receive processing}
\label{driver-api/80211/mac80211-advanced:receive-processing}
TBD


\subsection{Transmit processing}
\label{driver-api/80211/mac80211-advanced:transmit-processing}
TBD


\subsection{Station info handling}
\label{driver-api/80211/mac80211-advanced:station-info-handling}

\subsubsection{Programming information}
\label{driver-api/80211/mac80211-advanced:programming-information}\index{sta\_info (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.sta_info}\pysigline{struct \bfcode{sta\_info}}
STA information

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct sta\PYGZus{}info \PYGZob{}
  struct list\PYGZus{}head list, free\PYGZus{}list;
  struct rcu\PYGZus{}head rcu\PYGZus{}head;
  struct rhlist\PYGZus{}head hash\PYGZus{}node;
  u8 addr[ETH\PYGZus{}ALEN];
  struct ieee80211\PYGZus{}local *local;
  struct ieee80211\PYGZus{}sub\PYGZus{}if\PYGZus{}data *sdata;
  struct ieee80211\PYGZus{}key \PYGZus{}\PYGZus{}rcu *gtk[NUM\PYGZus{}DEFAULT\PYGZus{}KEYS + NUM\PYGZus{}DEFAULT\PYGZus{}MGMT\PYGZus{}KEYS];
  struct ieee80211\PYGZus{}key \PYGZus{}\PYGZus{}rcu *ptk[NUM\PYGZus{}DEFAULT\PYGZus{}KEYS];
  u8 ptk\PYGZus{}idx;
  struct rate\PYGZus{}control\PYGZus{}ref *rate\PYGZus{}ctrl;
  void *rate\PYGZus{}ctrl\PYGZus{}priv;
  spinlock\PYGZus{}t rate\PYGZus{}ctrl\PYGZus{}lock;
  spinlock\PYGZus{}t lock;
  struct ieee80211\PYGZus{}fast\PYGZus{}tx \PYGZus{}\PYGZus{}rcu *fast\PYGZus{}tx;
  struct ieee80211\PYGZus{}fast\PYGZus{}rx \PYGZus{}\PYGZus{}rcu *fast\PYGZus{}rx;
  struct ieee80211\PYGZus{}sta\PYGZus{}rx\PYGZus{}stats \PYGZus{}\PYGZus{}percpu *pcpu\PYGZus{}rx\PYGZus{}stats;
\PYGZsh{}ifdef CONFIG\PYGZus{}MAC80211\PYGZus{}MESH;
  struct mesh\PYGZus{}sta *mesh;
\PYGZsh{}endif;
  struct work\PYGZus{}struct drv\PYGZus{}deliver\PYGZus{}wk;
  u16 listen\PYGZus{}interval;
  bool dead;
  bool removed;
  bool uploaded;
  enum ieee80211\PYGZus{}sta\PYGZus{}state sta\PYGZus{}state;
  unsigned long \PYGZus{}flags;
  spinlock\PYGZus{}t ps\PYGZus{}lock;
  struct sk\PYGZus{}buff\PYGZus{}head ps\PYGZus{}tx\PYGZus{}buf[IEEE80211\PYGZus{}NUM\PYGZus{}ACS];
  struct sk\PYGZus{}buff\PYGZus{}head tx\PYGZus{}filtered[IEEE80211\PYGZus{}NUM\PYGZus{}ACS];
  unsigned long driver\PYGZus{}buffered\PYGZus{}tids;
  unsigned long txq\PYGZus{}buffered\PYGZus{}tids;
  long last\PYGZus{}connected;
  struct ieee80211\PYGZus{}sta\PYGZus{}rx\PYGZus{}stats rx\PYGZus{}stats;
  struct \PYGZob{}
    struct ewma\PYGZus{}signal signal;
    struct ewma\PYGZus{}signal chain\PYGZus{}signal[IEEE80211\PYGZus{}MAX\PYGZus{}CHAINS];
  \PYGZcb{} rx\PYGZus{}stats\PYGZus{}avg;
  \PYGZus{}\PYGZus{}le16 last\PYGZus{}seq\PYGZus{}ctrl[IEEE80211\PYGZus{}NUM\PYGZus{}TIDS + 1];
  struct \PYGZob{}
    unsigned long filtered;
    unsigned long retry\PYGZus{}failed, retry\PYGZus{}count;
    unsigned int lost\PYGZus{}packets;
    unsigned long last\PYGZus{}tdls\PYGZus{}pkt\PYGZus{}time;
    u64 msdu\PYGZus{}retries[IEEE80211\PYGZus{}NUM\PYGZus{}TIDS + 1];
    u64 msdu\PYGZus{}failed[IEEE80211\PYGZus{}NUM\PYGZus{}TIDS + 1];
    unsigned long last\PYGZus{}ack;
  \PYGZcb{} status\PYGZus{}stats;
  struct \PYGZob{}
    u64 packets[IEEE80211\PYGZus{}NUM\PYGZus{}ACS];
    u64 bytes[IEEE80211\PYGZus{}NUM\PYGZus{}ACS];
    struct ieee80211\PYGZus{}tx\PYGZus{}rate last\PYGZus{}rate;
    u64 msdu[IEEE80211\PYGZus{}NUM\PYGZus{}TIDS + 1];
  \PYGZcb{} tx\PYGZus{}stats;
  u16 tid\PYGZus{}seq[IEEE80211\PYGZus{}QOS\PYGZus{}CTL\PYGZus{}TID\PYGZus{}MASK + 1];
  struct sta\PYGZus{}ampdu\PYGZus{}mlme ampdu\PYGZus{}mlme;
\PYGZsh{}ifdef CONFIG\PYGZus{}MAC80211\PYGZus{}DEBUGFS;
  struct dentry *debugfs\PYGZus{}dir;
\PYGZsh{}endif;
  enum ieee80211\PYGZus{}sta\PYGZus{}rx\PYGZus{}bandwidth cur\PYGZus{}max\PYGZus{}bandwidth;
  enum ieee80211\PYGZus{}smps\PYGZus{}mode known\PYGZus{}smps\PYGZus{}mode;
  const struct ieee80211\PYGZus{}cipher\PYGZus{}scheme *cipher\PYGZus{}scheme;
  struct codel\PYGZus{}params cparams;
  u8 reserved\PYGZus{}tid;
  struct cfg80211\PYGZus{}chan\PYGZus{}def tdls\PYGZus{}chandef;
  struct ieee80211\PYGZus{}sta sta;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{list}}] \leavevmode
global linked list entry

\item[{\code{free\_list}}] \leavevmode
list entry for keeping track of stations to free

\item[{\code{rcu\_head}}] \leavevmode
RCU head used for freeing this station struct

\item[{\code{hash\_node}}] \leavevmode
hash node for rhashtable

\item[{\code{addr}}] \leavevmode
station's MAC address - duplicated from public part to
let the hash table work with just a single cacheline

\item[{\code{local}}] \leavevmode
pointer to the global information

\item[{\code{sdata}}] \leavevmode
virtual interface this station belongs to

\item[{\code{gtk}}] \leavevmode
group keys negotiated with this station, if any

\item[{\code{ptk}}] \leavevmode
peer keys negotiated with this station, if any

\item[{\code{ptk\_idx}}] \leavevmode
last installed peer key index

\item[{\code{rate\_ctrl}}] \leavevmode
rate control algorithm reference

\item[{\code{rate\_ctrl\_priv}}] \leavevmode
rate control private per-STA pointer

\item[{\code{rate\_ctrl\_lock}}] \leavevmode
spinlock used to protect rate control data
(data inside the algorithm, so serializes calls there)

\item[{\code{lock}}] \leavevmode
used for locking all fields that require locking, see comments
in the header file.

\item[{\code{fast\_tx}}] \leavevmode
TX fastpath information

\item[{\code{fast\_rx}}] \leavevmode
RX fastpath information

\item[{\code{pcpu\_rx\_stats}}] \leavevmode
per-CPU RX statistics, assigned only if the driver needs
this (by advertising the USES\_RSS hw flag)

\item[{\code{mesh}}] \leavevmode
mesh STA information

\item[{\code{drv\_deliver\_wk}}] \leavevmode
used for delivering frames after driver PS unblocking

\item[{\code{listen\_interval}}] \leavevmode
listen interval of this station, when we're acting as AP

\item[{\code{dead}}] \leavevmode
set to true when sta is unlinked

\item[{\code{removed}}] \leavevmode
set to true when sta is being removed from sta\_list

\item[{\code{uploaded}}] \leavevmode
set to true when sta is uploaded to the driver

\item[{\code{sta\_state}}] \leavevmode
duplicates information about station state (for debug)

\item[{\code{\_flags}}] \leavevmode
STA flags, see {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.ieee80211_sta_info_flags]{\emph{\code{enum ieee80211\_sta\_info\_flags}}}}, do not use directly

\item[{\code{ps\_lock}}] \leavevmode
used for powersave (when mac80211 is the AP) related locking

\item[{\code{ps\_tx\_buf}}] \leavevmode
buffers (per AC) of frames to transmit to this station
when it leaves power saving state or polls

\item[{\code{tx\_filtered}}] \leavevmode
buffers (per AC) of frames we already tried to
transmit but were filtered by hardware due to STA having
entered power saving state, these are also delivered to
the station when it leaves powersave or polls for frames

\item[{\code{driver\_buffered\_tids}}] \leavevmode
bitmap of TIDs the driver has data buffered on

\item[{\code{txq\_buffered\_tids}}] \leavevmode
bitmap of TIDs that mac80211 has txq data buffered on

\item[{\code{last\_connected}}] \leavevmode
time (in seconds) when a station got connected

\item[{\code{rx\_stats}}] \leavevmode
RX statistics

\item[{\code{last\_seq\_ctrl}}] \leavevmode
last received seq/frag number from this STA (per TID
plus one for non-QoS frames)

\item[{\code{status\_stats}}] \leavevmode
TX status statistics

\item[{\code{tx\_stats}}] \leavevmode
TX statistics

\item[{\code{tid\_seq}}] \leavevmode
per-TID sequence numbers for sending to this STA

\item[{\code{ampdu\_mlme}}] \leavevmode
A-MPDU state machine state

\item[{\code{debugfs\_dir}}] \leavevmode
debug filesystem directory dentry

\item[{\code{cur\_max\_bandwidth}}] \leavevmode
maximum bandwidth to use for TX to the station,
taken from HT/VHT capabilities or VHT operating mode notification

\item[{\code{known\_smps\_mode}}] \leavevmode
the smps\_mode the client thinks we are in. Relevant for
AP only.

\item[{\code{cipher\_scheme}}] \leavevmode
optional cipher scheme for this station

\item[{\code{cparams}}] \leavevmode
CoDel parameters for this station.

\item[{\code{reserved\_tid}}] \leavevmode
reserved TID (if any, otherwise IEEE80211\_TID\_UNRESERVED)

\item[{\code{tdls\_chandef}}] \leavevmode
a TDLS peer can have a wider chandef that is compatible to
the BSS one.

\item[{\code{sta}}] \leavevmode
station information we share with the driver

\end{description}

\textbf{Description}

This structure collects information about a station that
mac80211 is communicating with.
\index{ieee80211\_sta\_info\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.ieee80211_sta_info_flags}\pysigline{enum \bfcode{ieee80211\_sta\_info\_flags}}
Stations flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{WLAN\_STA\_AUTH}}] \leavevmode
Station is authenticated.

\item[{\code{WLAN\_STA\_ASSOC}}] \leavevmode
Station is associated.

\item[{\code{WLAN\_STA\_PS\_STA}}] \leavevmode
Station is in power-save mode

\item[{\code{WLAN\_STA\_AUTHORIZED}}] \leavevmode
Station is authorized to send/receive traffic.
This bit is always checked so needs to be enabled for all stations
when virtual port control is not in use.

\item[{\code{WLAN\_STA\_SHORT\_PREAMBLE}}] \leavevmode
Station is capable of receiving short-preamble
frames.

\item[{\code{WLAN\_STA\_WDS}}] \leavevmode
Station is one of our WDS peers.

\item[{\code{WLAN\_STA\_CLEAR\_PS\_FILT}}] \leavevmode
Clear PS filter in hardware (using the
IEEE80211\_TX\_CTL\_CLEAR\_PS\_FILT control flag) when the next
frame to this station is transmitted.

\item[{\code{WLAN\_STA\_MFP}}] \leavevmode
Management frame protection is used with this STA.

\item[{\code{WLAN\_STA\_BLOCK\_BA}}] \leavevmode
Used to deny ADDBA requests (both TX and RX)
during suspend/resume and station removal.

\item[{\code{WLAN\_STA\_PS\_DRIVER}}] \leavevmode
driver requires keeping this station in
power-save mode logically to flush frames that might still
be in the queues

\item[{\code{WLAN\_STA\_PSPOLL}}] \leavevmode
Station sent PS-poll while driver was keeping
station in power-save mode, reply when the driver unblocks.

\item[{\code{WLAN\_STA\_TDLS\_PEER}}] \leavevmode
Station is a TDLS peer.

\item[{\code{WLAN\_STA\_TDLS\_PEER\_AUTH}}] \leavevmode
This TDLS peer is authorized to send direct
packets. This means the link is enabled.

\item[{\code{WLAN\_STA\_TDLS\_INITIATOR}}] \leavevmode
We are the initiator of the TDLS link with this
station.

\item[{\code{WLAN\_STA\_TDLS\_CHAN\_SWITCH}}] \leavevmode
This TDLS peer supports TDLS channel-switching

\item[{\code{WLAN\_STA\_TDLS\_OFF\_CHANNEL}}] \leavevmode
The local STA is currently off-channel with this
TDLS peer

\item[{\code{WLAN\_STA\_TDLS\_WIDER\_BW}}] \leavevmode
This TDLS peer supports working on a wider bw on
the BSS base channel.

\item[{\code{WLAN\_STA\_UAPSD}}] \leavevmode
Station requested unscheduled SP while driver was
keeping station in power-save mode, reply when the driver
unblocks the station.

\item[{\code{WLAN\_STA\_SP}}] \leavevmode
Station is in a service period, so don't try to
reply to other uAPSD trigger frames or PS-Poll.

\item[{\code{WLAN\_STA\_4ADDR\_EVENT}}] \leavevmode
4-addr event was already sent for this frame.

\item[{\code{WLAN\_STA\_INSERTED}}] \leavevmode
This station is inserted into the hash table.

\item[{\code{WLAN\_STA\_RATE\_CONTROL}}] \leavevmode
rate control was initialized for this station.

\item[{\code{WLAN\_STA\_TOFFSET\_KNOWN}}] \leavevmode
toffset calculated for this station is valid.

\item[{\code{WLAN\_STA\_MPSP\_OWNER}}] \leavevmode
local STA is owner of a mesh Peer Service Period.

\item[{\code{WLAN\_STA\_MPSP\_RECIPIENT}}] \leavevmode
local STA is recipient of a MPSP.

\item[{\code{WLAN\_STA\_PS\_DELIVER}}] \leavevmode
station woke up, but we're still blocking TX
until pending frames are delivered

\item[{\code{NUM\_WLAN\_STA\_FLAGS}}] \leavevmode
number of defined flags

\end{description}

\textbf{Description}

These flags are used with {\hyperref[driver\string-api/80211/mac80211\string-advanced:c.sta_info]{\emph{\code{struct sta\_info}}}}`s \textbf{flags} member, but
only indirectly with \code{set\_sta\_flag()} and friends.


\subsubsection{STA information lifetime rules}
\label{driver-api/80211/mac80211-advanced:sta-information-lifetime-rules}
STA info structures ({\hyperref[driver\string-api/80211/mac80211\string-advanced:c.sta_info]{\emph{\code{struct sta\_info}}}}) are managed in a hash table
for faster lookup and a list for iteration. They are managed using
RCU, i.e. access to the list and hash table is protected by RCU.

Upon allocating a STA info structure with \code{sta\_info\_alloc()}, the caller
owns that structure. It must then insert it into the hash table using
either \code{sta\_info\_insert()} or \code{sta\_info\_insert\_rcu()}; only in the latter
case (which acquires an rcu read section but must not be called from
within one) will the pointer still be valid after the call. Note that
the caller may not do much with the STA info before inserting it, in
particular, it may not start any mesh peer link management or add
encryption keys.

When the insertion fails (\code{sta\_info\_insert()}) returns non-zero), the
structure will have been freed by \code{sta\_info\_insert()}!

Station entries are added by mac80211 when you establish a link with a
peer. This means different things for the different type of interfaces
we support. For a regular station this mean we add the AP sta when we
receive an association response from the AP. For IBSS this occurs when
get to know about a peer on the same IBSS. For WDS we add the sta for
the peer immediately upon device open. When using AP mode we add stations
for each respective station upon request from userspace through nl80211.

In order to remove a STA info structure, various sta\_info\_destroy\_*()
calls are available.

There is no concept of ownership on a STA entry, each structure is
owned by the global hash table/list until it is removed. All users of
the structure need to be RCU protected so that the structure won't be
freed before they are done using it.


\subsection{Aggregation}
\label{driver-api/80211/mac80211-advanced:id1}\index{sta\_ampdu\_mlme (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.sta_ampdu_mlme}\pysigline{struct \bfcode{sta\_ampdu\_mlme}}
STA aggregation information.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct sta\PYGZus{}ampdu\PYGZus{}mlme \PYGZob{}
  struct mutex mtx;
  struct tid\PYGZus{}ampdu\PYGZus{}rx \PYGZus{}\PYGZus{}rcu *tid\PYGZus{}rx[IEEE80211\PYGZus{}NUM\PYGZus{}TIDS];
  u8 tid\PYGZus{}rx\PYGZus{}token[IEEE80211\PYGZus{}NUM\PYGZus{}TIDS];
  unsigned long tid\PYGZus{}rx\PYGZus{}timer\PYGZus{}expired[BITS\PYGZus{}TO\PYGZus{}LONGS(IEEE80211\PYGZus{}NUM\PYGZus{}TIDS)];
  unsigned long tid\PYGZus{}rx\PYGZus{}stop\PYGZus{}requested[BITS\PYGZus{}TO\PYGZus{}LONGS(IEEE80211\PYGZus{}NUM\PYGZus{}TIDS)];
  unsigned long tid\PYGZus{}rx\PYGZus{}manage\PYGZus{}offl[BITS\PYGZus{}TO\PYGZus{}LONGS(2 * IEEE80211\PYGZus{}NUM\PYGZus{}TIDS)];
  unsigned long agg\PYGZus{}session\PYGZus{}valid[BITS\PYGZus{}TO\PYGZus{}LONGS(IEEE80211\PYGZus{}NUM\PYGZus{}TIDS)];
  unsigned long unexpected\PYGZus{}agg[BITS\PYGZus{}TO\PYGZus{}LONGS(IEEE80211\PYGZus{}NUM\PYGZus{}TIDS)];
  struct work\PYGZus{}struct work;
  struct tid\PYGZus{}ampdu\PYGZus{}tx \PYGZus{}\PYGZus{}rcu *tid\PYGZus{}tx[IEEE80211\PYGZus{}NUM\PYGZus{}TIDS];
  struct tid\PYGZus{}ampdu\PYGZus{}tx *tid\PYGZus{}start\PYGZus{}tx[IEEE80211\PYGZus{}NUM\PYGZus{}TIDS];
  unsigned long last\PYGZus{}addba\PYGZus{}req\PYGZus{}time[IEEE80211\PYGZus{}NUM\PYGZus{}TIDS];
  u8 addba\PYGZus{}req\PYGZus{}num[IEEE80211\PYGZus{}NUM\PYGZus{}TIDS];
  u8 dialog\PYGZus{}token\PYGZus{}allocator;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{mtx}}] \leavevmode
mutex to protect all TX data (except non-NULL assignments
to tid\_tx{[}idx{]}, which are protected by the sta spinlock)
tid\_start\_tx is also protected by sta-\textgreater{}lock.

\item[{\code{tid\_rx}}] \leavevmode
aggregation info for Rx per TID -- RCU protected

\item[{\code{tid\_rx\_token}}] \leavevmode
dialog tokens for valid aggregation sessions

\item[{\code{tid\_rx\_timer\_expired}}] \leavevmode
bitmap indicating on which TIDs the
RX timer expired until the work for it runs

\item[{\code{tid\_rx\_stop\_requested}}] \leavevmode
bitmap indicating which BA sessions per TID the
driver requested to close until the work for it runs

\item[{\code{tid\_rx\_manage\_offl}}] \leavevmode
bitmap indicating which BA sessions were requested
to be treated as started/stopped due to offloading

\item[{\code{agg\_session\_valid}}] \leavevmode
bitmap indicating which TID has a rx BA session open on

\item[{\code{unexpected\_agg}}] \leavevmode
bitmap indicating which TID already sent a delBA due to
unexpected aggregation related frames outside a session

\item[{\code{work}}] \leavevmode
work struct for starting/stopping aggregation

\item[{\code{tid\_tx}}] \leavevmode
aggregation info for Tx per TID

\item[{\code{tid\_start\_tx}}] \leavevmode
sessions where start was requested

\item[{\code{last\_addba\_req\_time}}] \leavevmode
timestamp of the last addBA request.

\item[{\code{addba\_req\_num}}] \leavevmode
number of times addBA request has been sent.

\item[{\code{dialog\_token\_allocator}}] \leavevmode
dialog token enumerator for each new session;

\end{description}
\index{tid\_ampdu\_tx (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.tid_ampdu_tx}\pysigline{struct \bfcode{tid\_ampdu\_tx}}
TID aggregation information (Tx).

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct tid\PYGZus{}ampdu\PYGZus{}tx \PYGZob{}
  struct rcu\PYGZus{}head rcu\PYGZus{}head;
  struct timer\PYGZus{}list session\PYGZus{}timer;
  struct timer\PYGZus{}list addba\PYGZus{}resp\PYGZus{}timer;
  struct sk\PYGZus{}buff\PYGZus{}head pending;
  struct sta\PYGZus{}info *sta;
  unsigned long state;
  unsigned long last\PYGZus{}tx;
  u16 timeout;
  u8 dialog\PYGZus{}token;
  u8 stop\PYGZus{}initiator;
  bool tx\PYGZus{}stop;
  u8 buf\PYGZus{}size;
  u16 failed\PYGZus{}bar\PYGZus{}ssn;
  bool bar\PYGZus{}pending;
  bool amsdu;
  u8 tid;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{rcu\_head}}] \leavevmode
rcu head for freeing structure

\item[{\code{session\_timer}}] \leavevmode
check if we keep Tx-ing on the TID (by timeout value)

\item[{\code{addba\_resp\_timer}}] \leavevmode
timer for peer's response to addba request

\item[{\code{pending}}] \leavevmode
pending frames queue -- use sta's spinlock to protect

\item[{\code{sta}}] \leavevmode
station we are attached to

\item[{\code{state}}] \leavevmode
session state (see above)

\item[{\code{last\_tx}}] \leavevmode
jiffies of last tx activity

\item[{\code{timeout}}] \leavevmode
session timeout value to be filled in ADDBA requests

\item[{\code{dialog\_token}}] \leavevmode
dialog token for aggregation session

\item[{\code{stop\_initiator}}] \leavevmode
initiator of a session stop

\item[{\code{tx\_stop}}] \leavevmode
TX DelBA frame when stopping

\item[{\code{buf\_size}}] \leavevmode
reorder buffer size at receiver

\item[{\code{failed\_bar\_ssn}}] \leavevmode
ssn of the last failed BAR tx attempt

\item[{\code{bar\_pending}}] \leavevmode
BAR needs to be re-sent

\item[{\code{amsdu}}] \leavevmode
support A-MSDU withing A-MDPU

\item[{\code{tid}}] \leavevmode
TID number

\end{description}

\textbf{Description}

This structure's lifetime is managed by RCU, assignments to
the array holding it must hold the aggregation mutex.

The TX path can access it under RCU lock-free if, and
only if, the state has the flag \code{HT\_AGG\_STATE\_OPERATIONAL}
set. Otherwise, the TX path must also acquire the spinlock
and re-check the state, see comments in the tx code
touching it.
\index{tid\_ampdu\_rx (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/80211/mac80211-advanced:c.tid_ampdu_rx}\pysigline{struct \bfcode{tid\_ampdu\_rx}}
TID aggregation information (Rx).

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct tid\PYGZus{}ampdu\PYGZus{}rx \PYGZob{}
  struct rcu\PYGZus{}head rcu\PYGZus{}head;
  spinlock\PYGZus{}t reorder\PYGZus{}lock;
  u64 reorder\PYGZus{}buf\PYGZus{}filtered;
  struct sk\PYGZus{}buff\PYGZus{}head *reorder\PYGZus{}buf;
  unsigned long *reorder\PYGZus{}time;
  struct sta\PYGZus{}info *sta;
  struct timer\PYGZus{}list session\PYGZus{}timer;
  struct timer\PYGZus{}list reorder\PYGZus{}timer;
  unsigned long last\PYGZus{}rx;
  u16 head\PYGZus{}seq\PYGZus{}num;
  u16 stored\PYGZus{}mpdu\PYGZus{}num;
  u16 ssn;
  u16 buf\PYGZus{}size;
  u16 timeout;
  u8 tid;
  u8 auto\PYGZus{}seq:1,removed:1, started:1;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{rcu\_head}}] \leavevmode
RCU head used for freeing this struct

\item[{\code{reorder\_lock}}] \leavevmode
serializes access to reorder buffer, see below.

\item[{\code{reorder\_buf\_filtered}}] \leavevmode
bitmap indicating where there are filtered frames in
the reorder buffer that should be ignored when releasing frames

\item[{\code{reorder\_buf}}] \leavevmode
buffer to reorder incoming aggregated MPDUs. An MPDU may be an
A-MSDU with individually reported subframes.

\item[{\code{reorder\_time}}] \leavevmode
jiffies when skb was added

\item[{\code{sta}}] \leavevmode
station we are attached to

\item[{\code{session\_timer}}] \leavevmode
check if peer keeps Tx-ing on the TID (by timeout value)

\item[{\code{reorder\_timer}}] \leavevmode
releases expired frames from the reorder buffer.

\item[{\code{last\_rx}}] \leavevmode
jiffies of last rx activity

\item[{\code{head\_seq\_num}}] \leavevmode
head sequence number in reordering buffer.

\item[{\code{stored\_mpdu\_num}}] \leavevmode
number of MPDUs in reordering buffer

\item[{\code{ssn}}] \leavevmode
Starting Sequence Number expected to be aggregated.

\item[{\code{buf\_size}}] \leavevmode
buffer size for incoming A-MPDUs

\item[{\code{timeout}}] \leavevmode
reset timer value (in TUs).

\item[{\code{tid}}] \leavevmode
TID number

\item[{\code{auto\_seq}}] \leavevmode
used for offloaded BA sessions to automatically pick head\_seq\_and
and ssn.

\item[{\code{removed}}] \leavevmode
this session is removed (but might have been found due to RCU)

\item[{\code{started}}] \leavevmode
this session has started (head ssn or higher was received)

\end{description}

\textbf{Description}

This structure's lifetime is managed by RCU, assignments to
the array holding it must hold the aggregation mutex.

The \textbf{reorder\_lock} is used to protect the members of this
struct, except for \textbf{timeout}, \textbf{buf\_size} and \textbf{dialog\_token},
which are constant across the lifetime of the struct (the
dialog token being used only for debugging).


\subsection{Synchronisation}
\label{driver-api/80211/mac80211-advanced:synchronisation}
TBD

Locking, lots of RCU


\chapter{The Userspace I/O HOWTO}
\label{driver-api/uio-howto:the-userspace-i-o-howto}\label{driver-api/uio-howto::doc}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Hans-Jürgen Koch Linux developer, Linutronix

\item[{Date}] \leavevmode
2006-12-11

\end{description}\end{quote}


\section{About this document}
\label{driver-api/uio-howto:about-this-document}

\subsection{Translations}
\label{driver-api/uio-howto:translations}
If you know of any translations for this document, or you are interested
in translating it, please email me \href{mailto:hjk@hansjkoch.de}{hjk@hansjkoch.de}.


\subsection{Preface}
\label{driver-api/uio-howto:preface}
For many types of devices, creating a Linux kernel driver is overkill.
All that is really needed is some way to handle an interrupt and provide
access to the memory space of the device. The logic of controlling the
device does not necessarily have to be within the kernel, as the device
does not need to take advantage of any of other resources that the
kernel provides. One such common class of devices that are like this are
for industrial I/O cards.

To address this situation, the userspace I/O system (UIO) was designed.
For typical industrial I/O cards, only a very small kernel module is
needed. The main part of the driver will run in user space. This
simplifies development and reduces the risk of serious bugs within a
kernel module.

Please note that UIO is not an universal driver interface. Devices that
are already handled well by other kernel subsystems (like networking or
serial or USB) are no candidates for an UIO driver. Hardware that is
ideally suited for an UIO driver fulfills all of the following:
\begin{itemize}
\item {} 
The device has memory that can be mapped. The device can be
controlled completely by writing to this memory.

\item {} 
The device usually generates interrupts.

\item {} 
The device does not fit into one of the standard kernel subsystems.

\end{itemize}


\subsection{Acknowledgments}
\label{driver-api/uio-howto:acknowledgments}
I'd like to thank Thomas Gleixner and Benedikt Spranger of Linutronix,
who have not only written most of the UIO code, but also helped greatly
writing this HOWTO by giving me all kinds of background information.


\subsection{Feedback}
\label{driver-api/uio-howto:feedback}
Find something wrong with this document? (Or perhaps something right?) I
would love to hear from you. Please email me at \href{mailto:hjk@hansjkoch.de}{hjk@hansjkoch.de}.


\section{About UIO}
\label{driver-api/uio-howto:about-uio}
If you use UIO for your card's driver, here's what you get:
\begin{itemize}
\item {} 
only one small kernel module to write and maintain.

\item {} 
develop the main part of your driver in user space, with all the
tools and libraries you're used to.

\item {} 
bugs in your driver won't crash the kernel.

\item {} 
updates of your driver can take place without recompiling the kernel.

\end{itemize}


\subsection{How UIO works}
\label{driver-api/uio-howto:how-uio-works}
Each UIO device is accessed through a device file and several sysfs
attribute files. The device file will be called \code{/dev/uio0} for the
first device, and \code{/dev/uio1}, \code{/dev/uio2} and so on for subsequent
devices.

\code{/dev/uioX} is used to access the address space of the card. Just use
\code{mmap()} to access registers or RAM locations of your card.

Interrupts are handled by reading from \code{/dev/uioX}. A blocking
\code{read()} from \code{/dev/uioX} will return as soon as an
interrupt occurs. You can also use \code{select()} on
\code{/dev/uioX} to wait for an interrupt. The integer value read from
\code{/dev/uioX} represents the total interrupt count. You can use this
number to figure out if you missed some interrupts.

For some hardware that has more than one interrupt source internally,
but not separate IRQ mask and status registers, there might be
situations where userspace cannot determine what the interrupt source
was if the kernel handler disables them by writing to the chip's IRQ
register. In such a case, the kernel has to disable the IRQ completely
to leave the chip's register untouched. Now the userspace part can
determine the cause of the interrupt, but it cannot re-enable
interrupts. Another cornercase is chips where re-enabling interrupts is
a read-modify-write operation to a combined IRQ status/acknowledge
register. This would be racy if a new interrupt occurred simultaneously.

To address these problems, UIO also implements a write() function. It is
normally not used and can be ignored for hardware that has only a single
interrupt source or has separate IRQ mask and status registers. If you
need it, however, a write to \code{/dev/uioX} will call the
\code{irqcontrol()} function implemented by the driver. You have
to write a 32-bit value that is usually either 0 or 1 to disable or
enable interrupts. If a driver does not implement
\code{irqcontrol()}, \code{write()} will return with
\code{-ENOSYS}.

To handle interrupts properly, your custom kernel module can provide its
own interrupt handler. It will automatically be called by the built-in
handler.

For cards that don't generate interrupts but need to be polled, there is
the possibility to set up a timer that triggers the interrupt handler at
configurable time intervals. This interrupt simulation is done by
calling {\hyperref[driver\string-api/infrastructure:c.uio_event_notify]{\emph{\code{uio\_event\_notify()}}}} from the timer's event
handler.

Each driver provides attributes that are used to read or write
variables. These attributes are accessible through sysfs files. A custom
kernel driver module can add its own attributes to the device owned by
the uio driver, but not added to the UIO device itself at this time.
This might change in the future if it would be found to be useful.

The following standard attributes are provided by the UIO framework:
\begin{itemize}
\item {} 
\code{name}: The name of your device. It is recommended to use the name
of your kernel module for this.

\item {} 
\code{version}: A version string defined by your driver. This allows the
user space part of your driver to deal with different versions of the
kernel module.

\item {} 
\code{event}: The total number of interrupts handled by the driver since
the last time the device node was read.

\end{itemize}

These attributes appear under the \code{/sys/class/uio/uioX} directory.
Please note that this directory might be a symlink, and not a real
directory. Any userspace code that accesses it must be able to handle
this.

Each UIO device can make one or more memory regions available for memory
mapping. This is necessary because some industrial I/O cards require
access to more than one PCI memory region in a driver.

Each mapping has its own directory in sysfs, the first mapping appears
as \code{/sys/class/uio/uioX/maps/map0/}. Subsequent mappings create
directories \code{map1/}, \code{map2/}, and so on. These directories will only
appear if the size of the mapping is not 0.

Each \code{mapX/} directory contains four read-only files that show
attributes of the memory:
\begin{itemize}
\item {} 
\code{name}: A string identifier for this mapping. This is optional, the
string can be empty. Drivers can set this to make it easier for
userspace to find the correct mapping.

\item {} 
\code{addr}: The address of memory that can be mapped.

\item {} 
\code{size}: The size, in bytes, of the memory pointed to by addr.

\item {} 
\code{offset}: The offset, in bytes, that has to be added to the pointer
returned by \code{mmap()} to get to the actual device memory.
This is important if the device's memory is not page aligned.
Remember that pointers returned by \code{mmap()} are always
page aligned, so it is good style to always add this offset.

\end{itemize}

From userspace, the different mappings are distinguished by adjusting
the \code{offset} parameter of the \code{mmap()} call. To map the
memory of mapping N, you have to use N times the page size as your
offset:

\begin{Verbatim}[commandchars=\\\{\}]
offset = N * getpagesize();
\end{Verbatim}

Sometimes there is hardware with memory-like regions that can not be
mapped with the technique described here, but there are still ways to
access them from userspace. The most common example are x86 ioports. On
x86 systems, userspace can access these ioports using
\code{ioperm()}, \code{iopl()}, \code{inb()},
\code{outb()}, and similar functions.

Since these ioport regions can not be mapped, they will not appear under
\code{/sys/class/uio/uioX/maps/} like the normal memory described above.
Without information about the port regions a hardware has to offer, it
becomes difficult for the userspace part of the driver to find out which
ports belong to which UIO device.

To address this situation, the new directory
\code{/sys/class/uio/uioX/portio/} was added. It only exists if the driver
wants to pass information about one or more port regions to userspace.
If that is the case, subdirectories named \code{port0}, \code{port1}, and so
on, will appear underneath \code{/sys/class/uio/uioX/portio/}.

Each \code{portX/} directory contains four read-only files that show name,
start, size, and type of the port region:
\begin{itemize}
\item {} 
\code{name}: A string identifier for this port region. The string is
optional and can be empty. Drivers can set it to make it easier for
userspace to find a certain port region.

\item {} 
\code{start}: The first port of this region.

\item {} 
\code{size}: The number of ports in this region.

\item {} 
\code{porttype}: A string describing the type of port.

\end{itemize}


\section{Writing your own kernel module}
\label{driver-api/uio-howto:writing-your-own-kernel-module}
Please have a look at \code{uio\_cif.c} as an example. The following
paragraphs explain the different sections of this file.


\subsection{struct uio\_info}
\label{driver-api/uio-howto:struct-uio-info}
This structure tells the framework the details of your driver, Some of
the members are required, others are optional.
\begin{itemize}
\item {} 
\code{const char *name}: Required. The name of your driver as it will
appear in sysfs. I recommend using the name of your module for this.

\item {} 
\code{const char *version}: Required. This string appears in
\code{/sys/class/uio/uioX/version}.

\item {} 
\code{struct uio\_mem mem{[} MAX\_UIO\_MAPS {]}}: Required if you have memory
that can be mapped with \code{mmap()}. For each mapping you
need to fill one of the \code{uio\_mem} structures. See the description
below for details.

\item {} 
\code{struct uio\_port port{[} MAX\_UIO\_PORTS\_REGIONS {]}}: Required if you
want to pass information about ioports to userspace. For each port
region you need to fill one of the \code{uio\_port} structures. See the
description below for details.

\item {} 
\code{long irq}: Required. If your hardware generates an interrupt, it's
your modules task to determine the irq number during initialization.
If you don't have a hardware generated interrupt but want to trigger
the interrupt handler in some other way, set \code{irq} to
\code{UIO\_IRQ\_CUSTOM}. If you had no interrupt at all, you could set
\code{irq} to \code{UIO\_IRQ\_NONE}, though this rarely makes sense.

\item {} 
\code{unsigned long irq\_flags}: Required if you've set \code{irq} to a
hardware interrupt number. The flags given here will be used in the
call to \code{request\_irq()}.

\item {} 
\code{int (*mmap)(struct uio\_info *info, struct vm\_area\_struct *vma)}:
Optional. If you need a special \code{mmap()}
function, you can set it here. If this pointer is not NULL, your
\code{mmap()} will be called instead of the built-in one.

\item {} 
\code{int (*open)(struct uio\_info *info, struct inode *inode)}:
Optional. You might want to have your own \code{open()},
e.g. to enable interrupts only when your device is actually used.

\item {} 
\code{int (*release)(struct uio\_info *info, struct inode *inode)}:
Optional. If you define your own \code{open()}, you will
probably also want a custom \code{release()} function.

\item {} 
\code{int (*irqcontrol)(struct uio\_info *info, s32 irq\_on)}:
Optional. If you need to be able to enable or disable interrupts
from userspace by writing to \code{/dev/uioX}, you can implement this
function. The parameter \code{irq\_on} will be 0 to disable interrupts
and 1 to enable them.

\end{itemize}

Usually, your device will have one or more memory regions that can be
mapped to user space. For each region, you have to set up a
\code{struct uio\_mem} in the \code{mem{[}{]}} array. Here's a description of the
fields of \code{struct uio\_mem}:
\begin{itemize}
\item {} 
\code{const char *name}: Optional. Set this to help identify the memory
region, it will show up in the corresponding sysfs node.

\item {} 
\code{int memtype}: Required if the mapping is used. Set this to
\code{UIO\_MEM\_PHYS} if you you have physical memory on your card to be
mapped. Use \code{UIO\_MEM\_LOGICAL} for logical memory (e.g. allocated
with \code{kmalloc()}). There's also \code{UIO\_MEM\_VIRTUAL} for
virtual memory.

\item {} 
\code{phys\_addr\_t addr}: Required if the mapping is used. Fill in the
address of your memory block. This address is the one that appears in
sysfs.

\item {} 
\code{resource\_size\_t size}: Fill in the size of the memory block that
\code{addr} points to. If \code{size} is zero, the mapping is considered
unused. Note that you \emph{must} initialize \code{size} with zero for all
unused mappings.

\item {} 
\code{void *internal\_addr}: If you have to access this memory region
from within your kernel module, you will want to map it internally by
using something like {\hyperref[driver\string-api/device\string-io:c.ioremap]{\emph{\code{ioremap()}}}}. Addresses returned by
this function cannot be mapped to user space, so you must not store
it in \code{addr}. Use \code{internal\_addr} instead to remember such an
address.

\end{itemize}

Please do not touch the \code{map} element of \code{struct uio\_mem}! It is
used by the UIO framework to set up sysfs files for this mapping. Simply
leave it alone.

Sometimes, your device can have one or more port regions which can not
be mapped to userspace. But if there are other possibilities for
userspace to access these ports, it makes sense to make information
about the ports available in sysfs. For each region, you have to set up
a \code{struct uio\_port} in the \code{port{[}{]}} array. Here's a description of
the fields of \code{struct uio\_port}:
\begin{itemize}
\item {} 
\code{char *porttype}: Required. Set this to one of the predefined
constants. Use \code{UIO\_PORT\_X86} for the ioports found in x86
architectures.

\item {} 
\code{unsigned long start}: Required if the port region is used. Fill in
the number of the first port of this region.

\item {} 
\code{unsigned long size}: Fill in the number of ports in this region.
If \code{size} is zero, the region is considered unused. Note that you
\emph{must} initialize \code{size} with zero for all unused regions.

\end{itemize}

Please do not touch the \code{portio} element of \code{struct uio\_port}! It is
used internally by the UIO framework to set up sysfs files for this
region. Simply leave it alone.


\subsection{Adding an interrupt handler}
\label{driver-api/uio-howto:adding-an-interrupt-handler}
What you need to do in your interrupt handler depends on your hardware
and on how you want to handle it. You should try to keep the amount of
code in your kernel interrupt handler low. If your hardware requires no
action that you \emph{have} to perform after each interrupt, then your
handler can be empty.

If, on the other hand, your hardware \emph{needs} some action to be performed
after each interrupt, then you \emph{must} do it in your kernel module. Note
that you cannot rely on the userspace part of your driver. Your
userspace program can terminate at any time, possibly leaving your
hardware in a state where proper interrupt handling is still required.

There might also be applications where you want to read data from your
hardware at each interrupt and buffer it in a piece of kernel memory
you've allocated for that purpose. With this technique you could avoid
loss of data if your userspace program misses an interrupt.

A note on shared interrupts: Your driver should support interrupt
sharing whenever this is possible. It is possible if and only if your
driver can detect whether your hardware has triggered the interrupt or
not. This is usually done by looking at an interrupt status register. If
your driver sees that the IRQ bit is actually set, it will perform its
actions, and the handler returns IRQ\_HANDLED. If the driver detects
that it was not your hardware that caused the interrupt, it will do
nothing and return IRQ\_NONE, allowing the kernel to call the next
possible interrupt handler.

If you decide not to support shared interrupts, your card won't work in
computers with no free interrupts. As this frequently happens on the PC
platform, you can save yourself a lot of trouble by supporting interrupt
sharing.


\subsection{Using uio\_pdrv for platform devices}
\label{driver-api/uio-howto:using-uio-pdrv-for-platform-devices}
In many cases, UIO drivers for platform devices can be handled in a
generic way. In the same place where you define your
\code{struct platform\_device}, you simply also implement your interrupt
handler and fill your \code{struct uio\_info}. A pointer to this
\code{struct uio\_info} is then used as \code{platform\_data} for your platform
device.

You also need to set up an array of \code{struct resource} containing
addresses and sizes of your memory mappings. This information is passed
to the driver using the \code{.resource} and \code{.num\_resources} elements of
\code{struct platform\_device}.

You now have to set the \code{.name} element of \code{struct platform\_device}
to \code{"uio\_pdrv"} to use the generic UIO platform device driver. This
driver will fill the \code{mem{[}{]}} array according to the resources given,
and register the device.

The advantage of this approach is that you only have to edit a file you
need to edit anyway. You do not have to create an extra driver.


\subsection{Using uio\_pdrv\_genirq for platform devices}
\label{driver-api/uio-howto:using-uio-pdrv-genirq-for-platform-devices}
Especially in embedded devices, you frequently find chips where the irq
pin is tied to its own dedicated interrupt line. In such cases, where
you can be really sure the interrupt is not shared, we can take the
concept of \code{uio\_pdrv} one step further and use a generic interrupt
handler. That's what \code{uio\_pdrv\_genirq} does.

The setup for this driver is the same as described above for
\code{uio\_pdrv}, except that you do not implement an interrupt handler. The
\code{.handler} element of \code{struct uio\_info} must remain \code{NULL}. The
\code{.irq\_flags} element must not contain \code{IRQF\_SHARED}.

You will set the \code{.name} element of \code{struct platform\_device} to
\code{"uio\_pdrv\_genirq"} to use this driver.

The generic interrupt handler of \code{uio\_pdrv\_genirq} will simply disable
the interrupt line using \code{disable\_irq\_nosync()}. After
doing its work, userspace can reenable the interrupt by writing
0x00000001 to the UIO device file. The driver already implements an
\code{irq\_control()} to make this possible, you must not
implement your own.

Using \code{uio\_pdrv\_genirq} not only saves a few lines of interrupt
handler code. You also do not need to know anything about the chip's
internal registers to create the kernel part of the driver. All you need
to know is the irq number of the pin the chip is connected to.


\subsection{Using uio\_dmem\_genirq for platform devices}
\label{driver-api/uio-howto:using-uio-dmem-genirq-for-platform-devices}
In addition to statically allocated memory ranges, they may also be a
desire to use dynamically allocated regions in a user space driver. In
particular, being able to access memory made available through the
dma-mapping API, may be particularly useful. The \code{uio\_dmem\_genirq}
driver provides a way to accomplish this.

This driver is used in a similar manner to the \code{"uio\_pdrv\_genirq"}
driver with respect to interrupt configuration and handling.

Set the \code{.name} element of \code{struct platform\_device} to
\code{"uio\_dmem\_genirq"} to use this driver.

When using this driver, fill in the \code{.platform\_data} element of
\code{struct platform\_device}, which is of type
\code{struct uio\_dmem\_genirq\_pdata} and which contains the following
elements:
\begin{itemize}
\item {} 
\code{struct uio\_info uioinfo}: The same structure used as the
\code{uio\_pdrv\_genirq} platform data

\item {} 
\code{unsigned int *dynamic\_region\_sizes}: Pointer to list of sizes of
dynamic memory regions to be mapped into user space.

\item {} 
\code{unsigned int num\_dynamic\_regions}: Number of elements in
\code{dynamic\_region\_sizes} array.

\end{itemize}

The dynamic regions defined in the platform data will be appended to the
{}`{}` mem{[}{]} {}`{}` array after the platform device resources, which implies
that the total number of static and dynamic memory regions cannot exceed
\code{MAX\_UIO\_MAPS}.

The dynamic memory regions will be allocated when the UIO device file,
\code{/dev/uioX} is opened. Similar to static memory resources, the memory
region information for dynamic regions is then visible via sysfs at
\code{/sys/class/uio/uioX/maps/mapY/*}. The dynamic memory regions will be
freed when the UIO device file is closed. When no processes are holding
the device file open, the address returned to userspace is \textasciitilde{}0.


\section{Writing a driver in userspace}
\label{driver-api/uio-howto:writing-a-driver-in-userspace}
Once you have a working kernel module for your hardware, you can write
the userspace part of your driver. You don't need any special libraries,
your driver can be written in any reasonable language, you can use
floating point numbers and so on. In short, you can use all the tools
and libraries you'd normally use for writing a userspace application.


\subsection{Getting information about your UIO device}
\label{driver-api/uio-howto:getting-information-about-your-uio-device}
Information about all UIO devices is available in sysfs. The first thing
you should do in your driver is check \code{name} and \code{version} to make
sure your talking to the right device and that its kernel driver has the
version you expect.

You should also make sure that the memory mapping you need exists and
has the size you expect.

There is a tool called \code{lsuio} that lists UIO devices and their
attributes. It is available here:

\href{http://www.osadl.org/projects/downloads/UIO/user/}{http://www.osadl.org/projects/downloads/UIO/user/}

With \code{lsuio} you can quickly check if your kernel module is loaded and
which attributes it exports. Have a look at the manpage for details.

The source code of \code{lsuio} can serve as an example for getting
information about an UIO device. The file \code{uio\_helper.c} contains a
lot of functions you could use in your userspace driver code.


\subsection{mmap() device memory}
\label{driver-api/uio-howto:mmap-device-memory}
After you made sure you've got the right device with the memory mappings
you need, all you have to do is to call \code{mmap()} to map the
device's memory to userspace.

The parameter \code{offset} of the \code{mmap()} call has a special
meaning for UIO devices: It is used to select which mapping of your
device you want to map. To map the memory of mapping N, you have to use
N times the page size as your offset:

\begin{Verbatim}[commandchars=\\\{\}]
offset = N * getpagesize();
\end{Verbatim}

N starts from zero, so if you've got only one memory range to map, set
\code{offset = 0}. A drawback of this technique is that memory is always
mapped beginning with its start address.


\subsection{Waiting for interrupts}
\label{driver-api/uio-howto:waiting-for-interrupts}
After you successfully mapped your devices memory, you can access it
like an ordinary array. Usually, you will perform some initialization.
After that, your hardware starts working and will generate an interrupt
as soon as it's finished, has some data available, or needs your
attention because an error occurred.

\code{/dev/uioX} is a read-only file. A \code{read()} will always
block until an interrupt occurs. There is only one legal value for the
\code{count} parameter of \code{read()}, and that is the size of a
signed 32 bit integer (4). Any other value for \code{count} causes
\code{read()} to fail. The signed 32 bit integer read is the
interrupt count of your device. If the value is one more than the value
you read the last time, everything is OK. If the difference is greater
than one, you missed interrupts.

You can also use \code{select()} on \code{/dev/uioX}.


\section{Generic PCI UIO driver}
\label{driver-api/uio-howto:generic-pci-uio-driver}
The generic driver is a kernel module named uio\_pci\_generic. It can
work with any device compliant to PCI 2.3 (circa 2002) and any compliant
PCI Express device. Using this, you only need to write the userspace
driver, removing the need to write a hardware-specific kernel module.


\subsection{Making the driver recognize the device}
\label{driver-api/uio-howto:making-the-driver-recognize-the-device}
Since the driver does not declare any device ids, it will not get loaded
automatically and will not automatically bind to any devices, you must
load it and allocate id to the driver yourself. For example:

\begin{Verbatim}[commandchars=\\\{\}]
modprobe uio\PYGZus{}pci\PYGZus{}generic
echo \PYGZdq{}8086 10f5\PYGZdq{} \PYGZgt{} /sys/bus/pci/drivers/uio\PYGZus{}pci\PYGZus{}generic/new\PYGZus{}id
\end{Verbatim}

If there already is a hardware specific kernel driver for your device,
the generic driver still won't bind to it, in this case if you want to
use the generic driver (why would you?) you'll have to manually unbind
the hardware specific driver and bind the generic driver, like this:

\begin{Verbatim}[commandchars=\\\{\}]
echo \PYGZhy{}n 0000:00:19.0 \PYGZgt{} /sys/bus/pci/drivers/e1000e/unbind
echo \PYGZhy{}n 0000:00:19.0 \PYGZgt{} /sys/bus/pci/drivers/uio\PYGZus{}pci\PYGZus{}generic/bind
\end{Verbatim}

You can verify that the device has been bound to the driver by looking
for it in sysfs, for example like the following:

\begin{Verbatim}[commandchars=\\\{\}]
ls \PYGZhy{}l /sys/bus/pci/devices/0000:00:19.0/driver
\end{Verbatim}

Which if successful should print:

\begin{Verbatim}[commandchars=\\\{\}]
.../0000:00:19.0/driver \PYGZhy{}\PYGZgt{} ../../../bus/pci/drivers/uio\PYGZus{}pci\PYGZus{}generic
\end{Verbatim}

Note that the generic driver will not bind to old PCI 2.2 devices. If
binding the device failed, run the following command:

\begin{Verbatim}[commandchars=\\\{\}]
dmesg
\end{Verbatim}

and look in the output for failure reasons.


\subsection{Things to know about uio\_pci\_generic}
\label{driver-api/uio-howto:things-to-know-about-uio-pci-generic}
Interrupts are handled using the Interrupt Disable bit in the PCI
command register and Interrupt Status bit in the PCI status register.
All devices compliant to PCI 2.3 (circa 2002) and all compliant PCI
Express devices should support these bits. uio\_pci\_generic detects
this support, and won't bind to devices which do not support the
Interrupt Disable Bit in the command register.

On each interrupt, uio\_pci\_generic sets the Interrupt Disable bit.
This prevents the device from generating further interrupts until the
bit is cleared. The userspace driver should clear this bit before
blocking and waiting for more interrupts.


\subsection{Writing userspace driver using uio\_pci\_generic}
\label{driver-api/uio-howto:writing-userspace-driver-using-uio-pci-generic}
Userspace driver can use pci sysfs interface, or the libpci library that
wraps it, to talk to the device and to re-enable interrupts by writing
to the command register.


\subsection{Example code using uio\_pci\_generic}
\label{driver-api/uio-howto:example-code-using-uio-pci-generic}
Here is some sample userspace driver code using uio\_pci\_generic:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}stdlib.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}stdio.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}unistd.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}sys/types.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}sys/stat.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}fcntl.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}errno.h\PYGZgt{}

int main()
\PYGZob{}
    int uiofd;
    int configfd;
    int err;
    int i;
    unsigned icount;
    unsigned char command\PYGZus{}high;

    uiofd = open(\PYGZdq{}/dev/uio0\PYGZdq{}, O\PYGZus{}RDONLY);
    if (uiofd \PYGZlt{} 0) \PYGZob{}
        perror(\PYGZdq{}uio open:\PYGZdq{});
        return errno;
    \PYGZcb{}
    configfd = open(\PYGZdq{}/sys/class/uio/uio0/device/config\PYGZdq{}, O\PYGZus{}RDWR);
    if (configfd \PYGZlt{} 0) \PYGZob{}
        perror(\PYGZdq{}config open:\PYGZdq{});
        return errno;
    \PYGZcb{}

    /* Read and cache command value */
    err = pread(configfd, \PYGZam{}command\PYGZus{}high, 1, 5);
    if (err != 1) \PYGZob{}
        perror(\PYGZdq{}command config read:\PYGZdq{});
        return errno;
    \PYGZcb{}
    command\PYGZus{}high \PYGZam{}= \PYGZti{}0x4;

    for(i = 0;; ++i) \PYGZob{}
        /* Print out a message, for debugging. */
        if (i == 0)
            fprintf(stderr, \PYGZdq{}Started uio test driver.\PYGZbs{}n\PYGZdq{});
        else
            fprintf(stderr, \PYGZdq{}Interrupts: \PYGZpc{}d\PYGZbs{}n\PYGZdq{}, icount);

        /****************************************/
        /* Here we got an interrupt from the
           device. Do something to it. */
        /****************************************/

        /* Re\PYGZhy{}enable interrupts. */
        err = pwrite(configfd, \PYGZam{}command\PYGZus{}high, 1, 5);
        if (err != 1) \PYGZob{}
            perror(\PYGZdq{}config write:\PYGZdq{});
            break;
        \PYGZcb{}

        /* Wait for next interrupt. */
        err = read(uiofd, \PYGZam{}icount, 4);
        if (err != 4) \PYGZob{}
            perror(\PYGZdq{}uio read:\PYGZdq{});
            break;
        \PYGZcb{}

    \PYGZcb{}
    return errno;
\PYGZcb{}
\end{Verbatim}


\section{Generic Hyper-V UIO driver}
\label{driver-api/uio-howto:generic-hyper-v-uio-driver}
The generic driver is a kernel module named uio\_hv\_generic. It
supports devices on the Hyper-V VMBus similar to uio\_pci\_generic on
PCI bus.


\subsection{Making the driver recognize the device}
\label{driver-api/uio-howto:id1}
Since the driver does not declare any device GUID's, it will not get
loaded automatically and will not automatically bind to any devices, you
must load it and allocate id to the driver yourself. For example, to use
the network device class GUID:

\begin{Verbatim}[commandchars=\\\{\}]
modprobe uio\PYGZus{}hv\PYGZus{}generic
echo \PYGZdq{}f8615163\PYGZhy{}df3e\PYGZhy{}46c5\PYGZhy{}913f\PYGZhy{}f2d2f965ed0e\PYGZdq{} \PYGZgt{} /sys/bus/vmbus/drivers/uio\PYGZus{}hv\PYGZus{}generic/new\PYGZus{}id
\end{Verbatim}

If there already is a hardware specific kernel driver for the device,
the generic driver still won't bind to it, in this case if you want to
use the generic driver for a userspace library you'll have to manually unbind
the hardware specific driver and bind the generic driver, using the device specific GUID
like this:

\begin{Verbatim}[commandchars=\\\{\}]
echo \PYGZhy{}n ed963694\PYGZhy{}e847\PYGZhy{}4b2a\PYGZhy{}85af\PYGZhy{}bc9cfc11d6f3 \PYGZgt{} /sys/bus/vmbus/drivers/hv\PYGZus{}netvsc/unbind
echo \PYGZhy{}n ed963694\PYGZhy{}e847\PYGZhy{}4b2a\PYGZhy{}85af\PYGZhy{}bc9cfc11d6f3 \PYGZgt{} /sys/bus/vmbus/drivers/uio\PYGZus{}hv\PYGZus{}generic/bind
\end{Verbatim}

You can verify that the device has been bound to the driver by looking
for it in sysfs, for example like the following:

\begin{Verbatim}[commandchars=\\\{\}]
ls \PYGZhy{}l /sys/bus/vmbus/devices/ed963694\PYGZhy{}e847\PYGZhy{}4b2a\PYGZhy{}85af\PYGZhy{}bc9cfc11d6f3/driver
\end{Verbatim}

Which if successful should print:

\begin{Verbatim}[commandchars=\\\{\}]
.../ed963694\PYGZhy{}e847\PYGZhy{}4b2a\PYGZhy{}85af\PYGZhy{}bc9cfc11d6f3/driver \PYGZhy{}\PYGZgt{} ../../../bus/vmbus/drivers/uio\PYGZus{}hv\PYGZus{}generic
\end{Verbatim}


\subsection{Things to know about uio\_hv\_generic}
\label{driver-api/uio-howto:things-to-know-about-uio-hv-generic}
On each interrupt, uio\_hv\_generic sets the Interrupt Disable bit. This
prevents the device from generating further interrupts until the bit is
cleared. The userspace driver should clear this bit before blocking and
waiting for more interrupts.

When host rescinds a device, the interrupt file descriptor is marked down
and any reads of the interrupt file descriptor will return -EIO. Similar
to a closed socket or disconnected serial device.
\begin{description}
\item[{The vmbus device regions are mapped into uio device resources:}] \leavevmode\begin{enumerate}
\setcounter{enumi}{-1}
\item {} 
Channel ring buffers: guest to host and host to guest

\item {} 
Guest to host interrupt signalling pages

\item {} 
Guest to host monitor page

\item {} 
Network receive buffer region

\item {} 
Network send buffer region

\end{enumerate}

\end{description}


\section{Further information}
\label{driver-api/uio-howto:further-information}\begin{itemize}
\item {} 
\href{http://www.osadl.org}{OSADL homepage.}

\item {} 
\href{http://www.linutronix.de}{Linutronix homepage.}

\end{itemize}


\chapter{Linux Firmware API}
\label{driver-api/firmware/index::doc}\label{driver-api/firmware/index:linux-firmware-api}

\section{Introduction}
\label{driver-api/firmware/introduction:introduction}\label{driver-api/firmware/introduction::doc}
The firmware API enables kernel code to request files required
for functionality from userspace, the uses vary:
\begin{itemize}
\item {} 
Microcode for CPU errata

\item {} 
Device driver firmware, required to be loaded onto device
microcontrollers

\item {} 
Device driver information data (calibration data, EEPROM overrides),
some of which can be completely optional.

\end{itemize}


\subsection{Types of firmware requests}
\label{driver-api/firmware/introduction:types-of-firmware-requests}
There are two types of calls:
\begin{itemize}
\item {} 
Synchronous

\item {} 
Asynchronous

\end{itemize}

Which one you use vary depending on your requirements, the rule of thumb
however is you should strive to use the asynchronous APIs unless you also
are already using asynchronous initialization mechanisms which will not
stall or delay boot. Even if loading firmware does not take a lot of time
processing firmware might, and this can still delay boot or initialization,
as such mechanisms such as asynchronous probe can help supplement drivers.


\section{Firmware API core features}
\label{driver-api/firmware/core:firmware-api-core-features}\label{driver-api/firmware/core::doc}
The firmware API has a rich set of core features available. This section
documents these features.


\subsection{Firmware search paths}
\label{driver-api/firmware/fw_search_path::doc}\label{driver-api/firmware/fw_search_path:firmware-search-paths}
The following search paths are used to look for firmware on your
root filesystem.
\begin{itemize}
\item {} 
fw\_path\_para - module parameter - default is empty so this is ignored

\item {} 
/lib/firmware/updates/UTS\_RELEASE/

\item {} 
/lib/firmware/updates/

\item {} 
/lib/firmware/UTS\_RELEASE/

\item {} 
/lib/firmware/

\end{itemize}

The module parameter `'path'' can be passed to the firmware\_class module
to activate the first optional custom fw\_path\_para. The custom path can
only be up to 256 characters long. The kernel parameter passed would be:
\begin{itemize}
\item {} 
`firmware\_class.path=\$CUSTOMIZED\_PATH'

\end{itemize}

There is an alternative to customize the path at run time after bootup, you
can use the file:
\begin{itemize}
\item {} 
/sys/module/firmware\_class/parameters/path

\end{itemize}

You would echo into it your custom path and firmware requested will be
searched for there first.


\subsection{Built-in firmware}
\label{driver-api/firmware/built-in-fw::doc}\label{driver-api/firmware/built-in-fw:built-in-firmware}
Firmware can be built-in to the kernel, this means building the firmware
into vmlinux directly, to enable avoiding having to look for firmware from
the filesystem. Instead, firmware can be looked for inside the kernel
directly. You can enable built-in firmware using the kernel configuration
options:
\begin{itemize}
\item {} 
CONFIG\_EXTRA\_FIRMWARE

\item {} 
CONFIG\_EXTRA\_FIRMWARE\_DIR

\end{itemize}

There are a few reasons why you might want to consider building your firmware
into the kernel with CONFIG\_EXTRA\_FIRMWARE:
\begin{itemize}
\item {} 
Speed

\item {} 
Firmware is needed for accessing the boot device, and the user doesn't
want to stuff the firmware into the boot initramfs.

\end{itemize}

Even if you have these needs there are a few reasons why you may not be
able to make use of built-in firmware:
\begin{itemize}
\item {} 
Legalese - firmware is non-GPL compatible

\item {} 
Some firmware may be optional

\item {} 
Firmware upgrades are possible, therefore a new firmware would implicate
a complete kernel rebuild.

\item {} 
Some firmware files may be really large in size. The remote-proc subsystem
is an example subsystem which deals with these sorts of firmware

\item {} 
The firmware may need to be scraped out from some device specific location
dynamically, an example is calibration data for for some WiFi chipsets. This
calibration data can be unique per sold device.

\end{itemize}


\subsection{Firmware cache}
\label{driver-api/firmware/firmware_cache:firmware-cache}\label{driver-api/firmware/firmware_cache::doc}
When Linux resumes from suspend some device drivers require firmware lookups to
re-initialize devices. During resume there may be a period of time during which
firmware lookups are not possible, during this short period of time firmware
requests will fail. Time is of essence though, and delaying drivers to wait for
the root filesystem for firmware delays user experience with device
functionality. In order to support these requirements the firmware
infrastructure implements a firmware cache for device drivers for most API
calls, automatically behind the scenes.

The firmware cache makes using certain firmware API calls safe during a device
driver's suspend and resume callback.  Users of these API calls needn't cache
the firmware by themselves for dealing with firmware loss during system resume.

The firmware cache works by requesting for firmware prior to suspend and
caching it in memory. Upon resume device drivers using the firmware API will
have access to the firmware immediately, without having to wait for the root
filesystem to mount or dealing with possible race issues with lookups as the
root filesystem mounts.

Some implementation details about the firmware cache setup:
\begin{itemize}
\item {} 
The firmware cache is setup by adding a devres entry for each device that
uses all synchronous call except {\hyperref[driver\string-api/infrastructure:c.request_firmware_into_buf]{\emph{\code{request\_firmware\_into\_buf()}}}}.

\item {} 
If an asynchronous call is used the firmware cache is only set up for a
device if if the second argument (uevent) to request\_firmware\_nowait() is
true. When uevent is true it requests that a kobject uevent be sent to
userspace for the firmware request. For details refer to the Fackback
mechanism documented below.

\item {} 
If the firmware cache is determined to be needed as per the above two
criteria the firmware cache is setup by adding a devres entry for the
device making the firmware request.

\item {} 
The firmware devres entry is maintained throughout the lifetime of the
device. This means that even if you release\_firmware() the firmware cache
will still be used on resume from suspend.

\item {} 
The timeout for the fallback mechanism is temporarily reduced to 10 seconds
as the firmware cache is set up during suspend, the timeout is set back to
the old value you had configured after the cache is set up.

\item {} 
Upon suspend any pending non-uevent firmware requests are killed to avoid
stalling the kernel, this is done with kill\_requests\_without\_uevent(). Kernel
calls requiring the non-uevent therefore need to implement their own firmware
cache mechanism but must not use the firmware API on suspend.

\end{itemize}


\subsection{Direct filesystem lookup}
\label{driver-api/firmware/direct-fs-lookup:direct-filesystem-lookup}\label{driver-api/firmware/direct-fs-lookup::doc}
Direct filesystem lookup is the most common form of firmware lookup performed
by the kernel. The kernel looks for the firmware directly on the root
filesystem in the paths documented in the section `Firmware search paths'.
The filesystem lookup is implemented in fw\_get\_filesystem\_firmware(), it
uses common core kernel file loader facility kernel\_read\_file\_from\_path().
The max path allowed is PATH\_MAX -- currently this is 4096 characters.

It is recommended you keep /lib/firmware paths on your root filesystem,
avoid having a separate partition for them in order to avoid possible
races with lookups and avoid uses of the custom fallback mechanisms
documented below.


\subsubsection{Firmware and initramfs}
\label{driver-api/firmware/direct-fs-lookup:firmware-and-initramfs}
Drivers which are built-in to the kernel should have the firmware integrated
also as part of the initramfs used to boot the kernel given that otherwise
a race is possible with loading the driver and the real rootfs not yet being
available. Stuffing the firmware into initramfs resolves this race issue,
however note that using initrd does not suffice to address the same race.

There are circumstances that justify not wanting to include firmware into
initramfs, such as dealing with large firmware firmware files for the
remote-proc subsystem. For such cases using a userspace fallback mechanism
is currently the only viable solution as only userspace can know for sure
when the real rootfs is ready and mounted.


\subsection{Fallback mechanisms}
\label{driver-api/firmware/fallback-mechanisms:fallback-mechanisms}\label{driver-api/firmware/fallback-mechanisms::doc}
A fallback mechanism is supported to allow to overcome failures to do a direct
filesystem lookup on the root filesystem or when the firmware simply cannot be
installed for practical reasons on the root filesystem. The kernel
configuration options related to supporting the firmware fallback mechanism are:
\begin{itemize}
\item {} 
CONFIG\_FW\_LOADER\_USER\_HELPER: enables building the firmware fallback
mechanism. Most distributions enable this option today. If enabled but
CONFIG\_FW\_LOADER\_USER\_HELPER\_FALLBACK is disabled, only the custom fallback
mechanism is available and for the request\_firmware\_nowait() call.

\item {} 
CONFIG\_FW\_LOADER\_USER\_HELPER\_FALLBACK: force enables each request to
enable the kobject uevent fallback mechanism on all firmware API calls
except request\_firmware\_direct(). Most distributions disable this option
today. The call request\_firmware\_nowait() allows for one alternative
fallback mechanism: if this kconfig option is enabled and your second
argument to request\_firmware\_nowait(), uevent, is set to false you are
informing the kernel that you have a custom fallback mechanism and it will
manually load the firmware. Read below for more details.

\end{itemize}

Note that this means when having this configuration:

CONFIG\_FW\_LOADER\_USER\_HELPER=y
CONFIG\_FW\_LOADER\_USER\_HELPER\_FALLBACK=n

the kobject uevent fallback mechanism will never take effect even
for request\_firmware\_nowait() when uevent is set to true.


\subsubsection{Justifying the firmware fallback mechanism}
\label{driver-api/firmware/fallback-mechanisms:justifying-the-firmware-fallback-mechanism}
Direct filesystem lookups may fail for a variety of reasons. Known reasons for
this are worth itemizing and documenting as it justifies the need for the
fallback mechanism:
\begin{itemize}
\item {} 
Race against access with the root filesystem upon bootup.

\item {} 
Races upon resume from suspend. This is resolved by the firmware cache, but
the firmware cache is only supported if you use uevents, and its not
supported for request\_firmware\_into\_buf().

\item {} \begin{description}
\item[{Firmware is not accessible through typical means:}] \leavevmode\begin{itemize}
\item {} 
It cannot be installed into the root filesystem

\item {} 
The firmware provides very unique device specific data tailored for
the unit gathered with local information. An example is calibration
data for WiFi chipsets for mobile devices. This calibration data is
not common to all units, but tailored per unit.  Such information may
be installed on a separate flash partition other than where the root
filesystem is provided.

\end{itemize}

\end{description}

\end{itemize}


\subsubsection{Types of fallback mechanisms}
\label{driver-api/firmware/fallback-mechanisms:types-of-fallback-mechanisms}
There are really two fallback mechanisms available using one shared sysfs
interface as a loading facility:
\begin{itemize}
\item {} 
Kobject uevent fallback mechanism

\item {} 
Custom fallback mechanism

\end{itemize}

First lets document the shared sysfs loading facility.


\subsubsection{Firmware sysfs loading facility}
\label{driver-api/firmware/fallback-mechanisms:firmware-sysfs-loading-facility}
In order to help device drivers upload firmware using a fallback mechanism
the firmware infrastructure creates a sysfs interface to enable userspace
to load and indicate when firmware is ready. The sysfs directory is created
via fw\_create\_instance(). This call creates a new struct device named after
the firmware requested, and establishes it in the device hierarchy by
associating the device used to make the request as the device's parent.
The sysfs directory's file attributes are defined and controlled through
the new device's class (firmware\_class) and group (fw\_dev\_attr\_groups).
This is actually where the original firmware\_class.c file name comes from,
as originally the only firmware loading mechanism available was the
mechanism we now use as a fallback mechanism.

To load firmware using the sysfs interface we expose a loading indicator,
and a file upload firmware into:
\begin{itemize}
\item {} 
/sys/\$DEVPATH/loading

\item {} 
/sys/\$DEVPATH/data

\end{itemize}

To upload firmware you will echo 1 onto the loading file to indicate
you are loading firmware. You then cat the firmware into the data file,
and you notify the kernel the firmware is ready by echo'ing 0 onto
the loading file.

The firmware device used to help load firmware using sysfs is only created if
direct firmware loading fails and if the fallback mechanism is enabled for your
firmware request, this is set up with fw\_load\_from\_user\_helper().  It is
important to re-iterate that no device is created if a direct filesystem lookup
succeeded.

Using:

\begin{Verbatim}[commandchars=\\\{\}]
echo 1 \PYGZgt{} /sys/\PYGZdl{}DEVPATH/loading
\end{Verbatim}

Will clean any previous partial load at once and make the firmware API
return an error. When loading firmware the firmware\_class grows a buffer
for the firmware in PAGE\_SIZE increments to hold the image as it comes in.

firmware\_data\_read() and firmware\_loading\_show() are just provided for the
test\_firmware driver for testing, they are not called in normal use or
expected to be used regularly by userspace.


\subsubsection{Firmware kobject uevent fallback mechanism}
\label{driver-api/firmware/fallback-mechanisms:firmware-kobject-uevent-fallback-mechanism}
Since a device is created for the sysfs interface to help load firmware as a
fallback mechanism userspace can be informed of the addition of the device by
relying on kobject uevents. The addition of the device into the device
hierarchy means the fallback mechanism for firmware loading has been initiated.
For details of implementation refer to \_request\_firmware\_load(), in particular
on the use of dev\_set\_uevent\_suppress() and kobject\_uevent().

The kernel's kobject uevent mechanism is implemented in lib/kobject\_uevent.c,
it issues uevents to userspace. As a supplement to kobject uevents Linux
distributions could also enable CONFIG\_UEVENT\_HELPER\_PATH, which makes use of
core kernel's usermode helper (UMH) functionality to call out to a userspace
helper for kobject uevents. In practice though no standard distribution has
ever used the CONFIG\_UEVENT\_HELPER\_PATH. If CONFIG\_UEVENT\_HELPER\_PATH is
enabled this binary would be called each time kobject\_uevent\_env() gets called
in the kernel for each kobject uevent triggered.

Different implementations have been supported in userspace to take advantage of
this fallback mechanism. When firmware loading was only possible using the
sysfs mechanism the userspace component ``hotplug'' provided the functionality of
monitoring for kobject events. Historically this was superseded be systemd's
udev, however firmware loading support was removed from udev as of systemd
commit be2ea723b1d0 (``udev: remove userspace firmware loading support'')
as of v217 on August, 2014. This means most Linux distributions today are
not using or taking advantage of the firmware fallback mechanism provided
by kobject uevents. This is specially exacerbated due to the fact that most
distributions today disable CONFIG\_FW\_LOADER\_USER\_HELPER\_FALLBACK.

Refer to do\_firmware\_uevent() for details of the kobject event variables
setup. Variables passwdd with a kobject add event:
\begin{itemize}
\item {} 
FIRMWARE=firmware name

\item {} 
TIMEOUT=timeout value

\item {} 
ASYNC=whether or not the API request was asynchronous

\end{itemize}

By default DEVPATH is set by the internal kernel kobject infrastructure.
Below is an example simple kobject uevent script:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} Both \PYGZdl{}DEVPATH and \PYGZdl{}FIRMWARE are already provided in the environment.
MY\PYGZus{}FW\PYGZus{}DIR=/lib/firmware/
echo 1 \PYGZgt{} /sys/\PYGZdl{}DEVPATH/loading
cat \PYGZdl{}MY\PYGZus{}FW\PYGZus{}DIR/\PYGZdl{}FIRMWARE \PYGZgt{} /sys/\PYGZdl{}DEVPATH/data
echo 0 \PYGZgt{} /sys/\PYGZdl{}DEVPATH/loading
\end{Verbatim}


\subsubsection{Firmware custom fallback mechanism}
\label{driver-api/firmware/fallback-mechanisms:firmware-custom-fallback-mechanism}
Users of the request\_firmware\_nowait() call have yet another option available
at their disposal: rely on the sysfs fallback mechanism but request that no
kobject uevents be issued to userspace. The original logic behind this
was that utilities other than udev might be required to lookup firmware
in non-traditional paths -- paths outside of the listing documented in the
section `Direct filesystem lookup'. This option is not available to any of
the other API calls as uevents are always forced for them.

Since uevents are only meaningful if the fallback mechanism is enabled
in your kernel it would seem odd to enable uevents with kernels that do not
have the fallback mechanism enabled in their kernels. Unfortunately we also
rely on the uevent flag which can be disabled by request\_firmware\_nowait() to
also setup the firmware cache for firmware requests. As documented above,
the firmware cache is only set up if uevent is enabled for an API call.
Although this can disable the firmware cache for request\_firmware\_nowait()
calls, users of this API should not use it for the purposes of disabling
the cache as that was not the original purpose of the flag. Not setting
the uevent flag means you want to opt-in for the firmware fallback mechanism
but you want to suppress kobject uevents, as you have a custom solution which
will monitor for your device addition into the device hierarchy somehow and
load firmware for you through a custom path.


\subsubsection{Firmware fallback timeout}
\label{driver-api/firmware/fallback-mechanisms:firmware-fallback-timeout}
The firmware fallback mechanism has a timeout. If firmware is not loaded
onto the sysfs interface by the timeout value an error is sent to the
driver. By default the timeout is set to 60 seconds if uevents are
desirable, otherwise MAX\_JIFFY\_OFFSET is used (max timeout possible).
The logic behind using MAX\_JIFFY\_OFFSET for non-uevents is that a custom
solution will have as much time as it needs to load firmware.

You can customize the firmware timeout by echo'ing your desired timeout into
the following file:
\begin{itemize}
\item {} 
/sys/class/firmware/timeout

\end{itemize}

If you echo 0 into it means MAX\_JIFFY\_OFFSET will be used. The data type
for the timeout is an int.


\subsection{Firmware lookup order}
\label{driver-api/firmware/lookup-order:firmware-lookup-order}\label{driver-api/firmware/lookup-order::doc}
Different functionality is available to enable firmware to be found.
Below is chronological order of how firmware will be looked for once
a driver issues a firmware API call.
\begin{itemize}
\item {} 
The `'Built-in firmware'' is checked first, if the firmware is present we
return it immediately

\item {} 
The `'Firmware cache'' is looked at next. If the firmware is found we
return it immediately

\item {} 
The `'Direct filesystem lookup'' is performed next, if found we
return it immediately

\item {} 
If no firmware has been found and the fallback mechanism was enabled
the sysfs interface is created. After this either a kobject uevent
is issued or the custom firmware loading is relied upon for firmware
loading up to the timeout value.

\end{itemize}


\section{request\_firmware API}
\label{driver-api/firmware/request_firmware:request-firmware-api}\label{driver-api/firmware/request_firmware::doc}
You would typically load firmware and then load it into your device somehow.
The typical firmware work flow is reflected below:

\begin{Verbatim}[commandchars=\\\{\}]
if(request\PYGZus{}firmware(\PYGZam{}fw\PYGZus{}entry, \PYGZdl{}FIRMWARE, device) == 0)
       copy\PYGZus{}fw\PYGZus{}to\PYGZus{}device(fw\PYGZus{}entry\PYGZhy{}\PYGZgt{}data, fw\PYGZus{}entry\PYGZhy{}\PYGZgt{}size);
release\PYGZus{}firmware(fw\PYGZus{}entry);
\end{Verbatim}


\subsection{Synchronous firmware requests}
\label{driver-api/firmware/request_firmware:synchronous-firmware-requests}
Synchronous firmware requests will wait until the firmware is found or until
an error is returned.


\subsubsection{request\_firmware}
\label{driver-api/firmware/request_firmware:request-firmware}\index{request\_firmware (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/firmware/request_firmware:c.request_firmware}\pysiglinewithargsret{int \bfcode{request\_firmware}}{const struct firmware **\emph{ firmware\_p}, const char *\emph{ name}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ device}}{}
send firmware request and wait for it

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct firmware ** firmware\_p}}] \leavevmode
pointer to firmware image

\item[{\code{const char * name}}] \leavevmode
name of firmware file

\item[{\code{struct device * device}}] \leavevmode
device for which firmware is being loaded

\end{description}

\textbf{Description}
\begin{quote}

\textbf{firmware\_p} will be used to return a firmware image by the name
of \textbf{name} for device \textbf{device}.

Should be called from user context where sleeping is allowed.

\textbf{name} will be used as \$FIRMWARE in the uevent environment and
should be distinctive enough not to be confused with any other
firmware image for this or any other device.

Caller must hold the reference count of \textbf{device}.

The function can be called safely inside device's suspend and
resume callback.
\end{quote}


\subsubsection{request\_firmware\_direct}
\label{driver-api/firmware/request_firmware:request-firmware-direct}\index{request\_firmware\_direct (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/firmware/request_firmware:c.request_firmware_direct}\pysiglinewithargsret{int \bfcode{request\_firmware\_direct}}{const struct firmware **\emph{ firmware\_p}, const char *\emph{ name}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ device}}{}
load firmware directly without usermode helper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct firmware ** firmware\_p}}] \leavevmode
pointer to firmware image

\item[{\code{const char * name}}] \leavevmode
name of firmware file

\item[{\code{struct device * device}}] \leavevmode
device for which firmware is being loaded

\end{description}

\textbf{Description}

This function works pretty much like {\hyperref[driver\string-api/infrastructure:c.request_firmware]{\emph{\code{request\_firmware()}}}}, but this doesn't
fall back to usermode helper even if the firmware couldn't be loaded
directly from fs.  Hence it's useful for loading optional firmwares, which
aren't always present, without extra long timeouts of udev.


\subsubsection{request\_firmware\_into\_buf}
\label{driver-api/firmware/request_firmware:request-firmware-into-buf}\index{request\_firmware\_into\_buf (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/firmware/request_firmware:c.request_firmware_into_buf}\pysiglinewithargsret{int \bfcode{request\_firmware\_into\_buf}}{const struct firmware **\emph{ firmware\_p}, const char *\emph{ name}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ device}, void *\emph{ buf}, size\_t\emph{ size}}{}
load firmware into a previously allocated buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct firmware ** firmware\_p}}] \leavevmode
pointer to firmware image

\item[{\code{const char * name}}] \leavevmode
name of firmware file

\item[{\code{struct device * device}}] \leavevmode
device for which firmware is being loaded and DMA region allocated

\item[{\code{void * buf}}] \leavevmode
address of buffer to load firmware into

\item[{\code{size\_t size}}] \leavevmode
size of buffer

\end{description}

\textbf{Description}

This function works pretty much like {\hyperref[driver\string-api/infrastructure:c.request_firmware]{\emph{\code{request\_firmware()}}}}, but it doesn't
allocate a buffer to hold the firmware data. Instead, the firmware
is loaded directly into the buffer pointed to by \textbf{buf} and the \textbf{firmware\_p}
data member is pointed at \textbf{buf}.

This function doesn't cache firmware either.


\subsection{Asynchronous firmware requests}
\label{driver-api/firmware/request_firmware:asynchronous-firmware-requests}
Asynchronous firmware requests allow driver code to not have to wait
until the firmware or an error is returned. Function callbacks are
provided so that when the firmware or an error is found the driver is
informed through the callback. request\_firmware\_nowait() cannot be called
in atomic contexts.


\subsubsection{request\_firmware\_nowait}
\label{driver-api/firmware/request_firmware:request-firmware-nowait}\index{request\_firmware\_nowait (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/firmware/request_firmware:c.request_firmware_nowait}\pysiglinewithargsret{int \bfcode{request\_firmware\_nowait}}{struct module *\emph{ module}, bool\emph{ uevent}, const char *\emph{ name}, struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ device}, gfp\_t\emph{ gfp}, void *\emph{ context}, void (*cont) (const struct firmware\emph{ *fw}, void\emph{ *context}}{}
asynchronous version of request\_firmware

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct module * module}}] \leavevmode
module requesting the firmware

\item[{\code{bool uevent}}] \leavevmode
sends uevent to copy the firmware image if this flag
is non-zero else the firmware copy must be done manually.

\item[{\code{const char * name}}] \leavevmode
name of firmware file

\item[{\code{struct device * device}}] \leavevmode
device for which firmware is being loaded

\item[{\code{gfp\_t gfp}}] \leavevmode
allocation flags

\item[{\code{void * context}}] \leavevmode
will be passed over to \textbf{cont}, and
\textbf{fw} may be \code{NULL} if firmware request fails.

\item[{\code{void (*)(const struct firmware *fw, void *context) cont}}] \leavevmode
function will be called asynchronously when the firmware
request is over.

\end{description}

\textbf{Description}
\begin{quote}

Caller must hold the reference count of \textbf{device}.
\begin{description}
\item[{Asynchronous variant of {\hyperref[driver\string-api/infrastructure:c.request_firmware]{\emph{\code{request\_firmware()}}}} for user contexts:}] \leavevmode\begin{itemize}
\item {} 
sleep for as small periods as possible since it may
increase kernel boot time of built-in device drivers
requesting firmware in their -\textgreater{}:c:func:\emph{probe()} methods, if
\textbf{gfp} is GFP\_KERNEL.

\item {} 
can't sleep at all if \textbf{gfp} is GFP\_ATOMIC.

\end{itemize}

\end{description}
\end{quote}


\subsection{request firmware API expected driver use}
\label{driver-api/firmware/request_firmware:request-firmware-api-expected-driver-use}
Once an API call returns you process the firmware and then release the
firmware. For example if you used request\_firmware() and it returns,
the driver has the firmware image accessible in fw\_entry-\textgreater{}\{data,size\}.
If something went wrong request\_firmware() returns non-zero and fw\_entry
is set to NULL. Once your driver is done with processing the firmware it
can call call release\_firmware(fw\_entry) to release the firmware image
and any related resource.


\section{Other Firmware Interfaces}
\label{driver-api/firmware/other_interfaces:other-firmware-interfaces}\label{driver-api/firmware/other_interfaces::doc}

\subsection{DMI Interfaces}
\label{driver-api/firmware/other_interfaces:dmi-interfaces}\index{dmi\_check\_system (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/firmware/other_interfaces:c.dmi_check_system}\pysiglinewithargsret{int \bfcode{dmi\_check\_system}}{const struct dmi\_system\_id *\emph{ list}}{}
check system DMI data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct dmi\_system\_id * list}}] \leavevmode
array of dmi\_system\_id structures to match against
All non-null elements of the list must match
their slot's (field index's) data (i.e., each
list string must be a substring of the specified
DMI slot's string data) to be considered a
successful match.

\end{description}

\textbf{Description}
\begin{quote}

Walk the blacklist table running matching functions until someone
returns non zero or we hit the end. Callback function is called for
each successful match. Returns the number of matches.

dmi\_scan\_machine must be called before this function is called.
\end{quote}
\index{dmi\_first\_match (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/firmware/other_interfaces:c.dmi_first_match}\pysiglinewithargsret{const struct dmi\_system\_id * \bfcode{dmi\_first\_match}}{const struct dmi\_system\_id *\emph{ list}}{}
find dmi\_system\_id structure matching system DMI data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct dmi\_system\_id * list}}] \leavevmode
array of dmi\_system\_id structures to match against
All non-null elements of the list must match
their slot's (field index's) data (i.e., each
list string must be a substring of the specified
DMI slot's string data) to be considered a
successful match.

\end{description}

\textbf{Description}
\begin{quote}

Walk the blacklist table until the first match is found.  Return the
pointer to the matching entry or NULL if there's no match.

dmi\_scan\_machine must be called before this function is called.
\end{quote}
\index{dmi\_get\_system\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/firmware/other_interfaces:c.dmi_get_system_info}\pysiglinewithargsret{const char * \bfcode{dmi\_get\_system\_info}}{int\emph{ field}}{}
return DMI data value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int field}}] \leavevmode
data index (see enum dmi\_field)

\end{description}

\textbf{Description}
\begin{quote}

Returns one DMI data value, can be used to perform
complex DMI data checks.
\end{quote}
\index{dmi\_name\_in\_vendors (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/firmware/other_interfaces:c.dmi_name_in_vendors}\pysiglinewithargsret{int \bfcode{dmi\_name\_in\_vendors}}{const char *\emph{ str}}{}
Check if string is in the DMI system or board vendor name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * str}}] \leavevmode
Case sensitive Name

\end{description}
\index{dmi\_find\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/firmware/other_interfaces:c.dmi_find_device}\pysiglinewithargsret{const struct dmi\_device * \bfcode{dmi\_find\_device}}{int\emph{ type}, const char *\emph{ name}, const struct dmi\_device *\emph{ from}}{}
find onboard device by type/name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int type}}] \leavevmode
device type or \code{DMI\_DEV\_TYPE\_ANY} to match all device types

\item[{\code{const char * name}}] \leavevmode
device name string or \code{NULL} to match all

\item[{\code{const struct dmi\_device * from}}] \leavevmode
previous device found in search, or \code{NULL} for new search.

\end{description}

\textbf{Description}
\begin{quote}

Iterates through the list of known onboard devices. If a device is
found with a matching \textbf{type} and \textbf{name}, a pointer to its device
structure is returned.  Otherwise, \code{NULL} is returned.
A new search is initiated by passing \code{NULL} as the \textbf{from} argument.
If \textbf{from} is not \code{NULL}, searches continue from next device.
\end{quote}
\index{dmi\_get\_date (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/firmware/other_interfaces:c.dmi_get_date}\pysiglinewithargsret{bool \bfcode{dmi\_get\_date}}{int\emph{ field}, int *\emph{ yearp}, int *\emph{ monthp}, int *\emph{ dayp}}{}
parse a DMI date

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int field}}] \leavevmode
data index (see enum dmi\_field)

\item[{\code{int * yearp}}] \leavevmode
optional out parameter for the year

\item[{\code{int * monthp}}] \leavevmode
optional out parameter for the month

\item[{\code{int * dayp}}] \leavevmode
optional out parameter for the day

\end{description}

\textbf{Description}
\begin{quote}

The date field is assumed to be in the form resembling
{[}mm{[}/dd{]}{]}/yy{[}yy{]} and the result is stored in the out
parameters any or all of which can be omitted.

If the field doesn't exist, all out parameters are set to zero
and false is returned.  Otherwise, true is returned with any
invalid part of date set to zero.

On return, year, month and day are guaranteed to be in the
range of {[}0,9999{]}, {[}0,12{]} and {[}0,31{]} respectively.
\end{quote}
\index{dmi\_walk (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/firmware/other_interfaces:c.dmi_walk}\pysiglinewithargsret{int \bfcode{dmi\_walk}}{void (*decode) (const struct dmi\_header\emph{ *}, void\emph{ *}, void *\emph{ private\_data}}{}
Walk the DMI table and get called back for every record

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void (*)(const struct dmi\_header *, void *) decode}}] \leavevmode
Callback function

\item[{\code{void * private\_data}}] \leavevmode
Private data to be passed to the callback function

\end{description}

\textbf{Description}
\begin{quote}

Returns 0 on success, -ENXIO if DMI is not selected or not present,
or a different negative error code if DMI walking fails.
\end{quote}
\index{dmi\_match (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/firmware/other_interfaces:c.dmi_match}\pysiglinewithargsret{bool \bfcode{dmi\_match}}{enum dmi\_field\emph{ f}, const char *\emph{ str}}{}
compare a string to the dmi field (if exists)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{enum dmi\_field f}}] \leavevmode
DMI field identifier

\item[{\code{const char * str}}] \leavevmode
string to compare the DMI field to

\end{description}

\textbf{Description}

Returns true if the requested field equals to the str (including NULL).


\subsection{EDD Interfaces}
\label{driver-api/firmware/other_interfaces:edd-interfaces}\index{edd\_show\_raw\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/firmware/other_interfaces:c.edd_show_raw_data}\pysiglinewithargsret{ssize\_t \bfcode{edd\_show\_raw\_data}}{struct edd\_device *\emph{ edev}, char *\emph{ buf}}{}
copies raw data to buffer for userspace to parse

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edd\_device * edev}}] \leavevmode
target edd\_device

\item[{\code{char * buf}}] \leavevmode
output buffer

\end{description}

\textbf{Return}

number of bytes written, or -EINVAL on failure
\index{edd\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/firmware/other_interfaces:c.edd_release}\pysiglinewithargsret{void \bfcode{edd\_release}}{struct kobject *\emph{ kobj}}{}
free edd structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kobject * kobj}}] \leavevmode
kobject of edd structure

\end{description}

\textbf{Description}
\begin{quote}

This is called when the refcount of the edd structure
reaches 0. This should happen right after we unregister,
but just in case, we use the release callback anyway.
\end{quote}
\index{edd\_dev\_is\_type (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/firmware/other_interfaces:c.edd_dev_is_type}\pysiglinewithargsret{int \bfcode{edd\_dev\_is\_type}}{struct edd\_device *\emph{ edev}, const char *\emph{ type}}{}
is this EDD device a `type' device?

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edd\_device * edev}}] \leavevmode
target edd\_device

\item[{\code{const char * type}}] \leavevmode
a host bus or interface identifier string per the EDD spec

\end{description}

\textbf{Description}

Returns 1 (TRUE) if it is a `type' device, 0 otherwise.
\index{edd\_get\_pci\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/firmware/other_interfaces:c.edd_get_pci_dev}\pysiglinewithargsret{struct pci\_dev * \bfcode{edd\_get\_pci\_dev}}{struct edd\_device *\emph{ edev}}{}
finds pci\_dev that matches edev

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct edd\_device * edev}}] \leavevmode
edd\_device

\end{description}

\textbf{Description}

Returns pci\_dev if found, or NULL
\index{edd\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/firmware/other_interfaces:c.edd_init}\pysiglinewithargsret{int \bfcode{edd\_init}}{void}{}
creates sysfs tree of EDD data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}


\chapter{PINCTRL (PIN CONTROL) subsystem}
\label{driver-api/pinctl:pinctrl-pin-control-subsystem}\label{driver-api/pinctl::doc}
This document outlines the pin control subsystem in Linux

This subsystem deals with:
\begin{itemize}
\item {} 
Enumerating and naming controllable pins

\item {} 
Multiplexing of pins, pads, fingers (etc) see below for details

\item {} 
Configuration of pins, pads, fingers (etc), such as software-controlled
biasing and driving mode specific pins, such as pull-up/down, open drain,
load capacitance etc.

\end{itemize}


\section{Top-level interface}
\label{driver-api/pinctl:top-level-interface}
Definition of PIN CONTROLLER:
\begin{itemize}
\item {} 
A pin controller is a piece of hardware, usually a set of registers, that
can control PINs. It may be able to multiplex, bias, set load capacitance,
set drive strength, etc. for individual pins or groups of pins.

\end{itemize}

Definition of PIN:
\begin{itemize}
\item {} 
PINS are equal to pads, fingers, balls or whatever packaging input or
output line you want to control and these are denoted by unsigned integers
in the range 0..maxpin. This numberspace is local to each PIN CONTROLLER, so
there may be several such number spaces in a system. This pin space may
be sparse - i.e. there may be gaps in the space with numbers where no
pin exists.

\end{itemize}

When a PIN CONTROLLER is instantiated, it will register a descriptor to the
pin control framework, and this descriptor contains an array of pin descriptors
describing the pins handled by this specific pin controller.

Here is an example of a PGA (Pin Grid Array) chip seen from underneath:

\begin{Verbatim}[commandchars=\\\{\}]
     A   B   C   D   E   F   G   H

8    o   o   o   o   o   o   o   o

7    o   o   o   o   o   o   o   o

6    o   o   o   o   o   o   o   o

5    o   o   o   o   o   o   o   o

4    o   o   o   o   o   o   o   o

3    o   o   o   o   o   o   o   o

2    o   o   o   o   o   o   o   o

1    o   o   o   o   o   o   o   o
\end{Verbatim}

To register a pin controller and name all the pins on this package we can do
this in our driver:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}linux/pinctrl/pinctrl.h\PYGZgt{}

const struct pinctrl\PYGZus{}pin\PYGZus{}desc foo\PYGZus{}pins[] = \PYGZob{}
        PINCTRL\PYGZus{}PIN(0, \PYGZdq{}A8\PYGZdq{}),
        PINCTRL\PYGZus{}PIN(1, \PYGZdq{}B8\PYGZdq{}),
        PINCTRL\PYGZus{}PIN(2, \PYGZdq{}C8\PYGZdq{}),
        ...
        PINCTRL\PYGZus{}PIN(61, \PYGZdq{}F1\PYGZdq{}),
        PINCTRL\PYGZus{}PIN(62, \PYGZdq{}G1\PYGZdq{}),
        PINCTRL\PYGZus{}PIN(63, \PYGZdq{}H1\PYGZdq{}),
\PYGZcb{};

static struct pinctrl\PYGZus{}desc foo\PYGZus{}desc = \PYGZob{}
        .name = \PYGZdq{}foo\PYGZdq{},
        .pins = foo\PYGZus{}pins,
        .npins = ARRAY\PYGZus{}SIZE(foo\PYGZus{}pins),
        .owner = THIS\PYGZus{}MODULE,
\PYGZcb{};

int \PYGZus{}\PYGZus{}init foo\PYGZus{}probe(void)
\PYGZob{}
        int error;

        struct pinctrl\PYGZus{}dev *pctl;

        error = pinctrl\PYGZus{}register\PYGZus{}and\PYGZus{}init(\PYGZam{}foo\PYGZus{}desc, \PYGZlt{}PARENT\PYGZgt{},
                                          NULL, \PYGZam{}pctl);
        if (error)
                return error;

        return pinctrl\PYGZus{}enable(pctl);
\PYGZcb{}
\end{Verbatim}

To enable the pinctrl subsystem and the subgroups for PINMUX and PINCONF and
selected drivers, you need to select them from your machine's Kconfig entry,
since these are so tightly integrated with the machines they are used on.
See for example arch/arm/mach-u300/Kconfig for an example.

Pins usually have fancier names than this. You can find these in the datasheet
for your chip. Notice that the core pinctrl.h file provides a fancy macro
called PINCTRL\_PIN() to create the struct entries. As you can see I enumerated
the pins from 0 in the upper left corner to 63 in the lower right corner.
This enumeration was arbitrarily chosen, in practice you need to think
through your numbering system so that it matches the layout of registers
and such things in your driver, or the code may become complicated. You must
also consider matching of offsets to the GPIO ranges that may be handled by
the pin controller.

For a padring with 467 pads, as opposed to actual pins, I used an enumeration
like this, walking around the edge of the chip, which seems to be industry
standard too (all these pads had names, too):

\begin{Verbatim}[commandchars=\\\{\}]
  0 ..... 104
466        105
  .        .
  .        .
358        224
 357 .... 225
\end{Verbatim}


\section{Pin groups}
\label{driver-api/pinctl:pin-groups}
Many controllers need to deal with groups of pins, so the pin controller
subsystem has a mechanism for enumerating groups of pins and retrieving the
actual enumerated pins that are part of a certain group.

For example, say that we have a group of pins dealing with an SPI interface
on \{ 0, 8, 16, 24 \}, and a group of pins dealing with an I2C interface on pins
on \{ 24, 25 \}.

These two groups are presented to the pin control subsystem by implementing
some generic pinctrl\_ops like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}linux/pinctrl/pinctrl.h\PYGZgt{}

struct foo\PYGZus{}group \PYGZob{}
        const char *name;
        const unsigned int *pins;
        const unsigned num\PYGZus{}pins;
\PYGZcb{};

static const unsigned int spi0\PYGZus{}pins[] = \PYGZob{} 0, 8, 16, 24 \PYGZcb{};
static const unsigned int i2c0\PYGZus{}pins[] = \PYGZob{} 24, 25 \PYGZcb{};

static const struct foo\PYGZus{}group foo\PYGZus{}groups[] = \PYGZob{}
        \PYGZob{}
                .name = \PYGZdq{}spi0\PYGZus{}grp\PYGZdq{},
                .pins = spi0\PYGZus{}pins,
                .num\PYGZus{}pins = ARRAY\PYGZus{}SIZE(spi0\PYGZus{}pins),
        \PYGZcb{},
        \PYGZob{}
                .name = \PYGZdq{}i2c0\PYGZus{}grp\PYGZdq{},
                .pins = i2c0\PYGZus{}pins,
                .num\PYGZus{}pins = ARRAY\PYGZus{}SIZE(i2c0\PYGZus{}pins),
        \PYGZcb{},
\PYGZcb{};


static int foo\PYGZus{}get\PYGZus{}groups\PYGZus{}count(struct pinctrl\PYGZus{}dev *pctldev)
\PYGZob{}
        return ARRAY\PYGZus{}SIZE(foo\PYGZus{}groups);
\PYGZcb{}

static const char *foo\PYGZus{}get\PYGZus{}group\PYGZus{}name(struct pinctrl\PYGZus{}dev *pctldev,
                                unsigned selector)
\PYGZob{}
        return foo\PYGZus{}groups[selector].name;
\PYGZcb{}

static int foo\PYGZus{}get\PYGZus{}group\PYGZus{}pins(struct pinctrl\PYGZus{}dev *pctldev, unsigned selector,
                        const unsigned **pins,
                        unsigned *num\PYGZus{}pins)
\PYGZob{}
        *pins = (unsigned *) foo\PYGZus{}groups[selector].pins;
        *num\PYGZus{}pins = foo\PYGZus{}groups[selector].num\PYGZus{}pins;
        return 0;
\PYGZcb{}

static struct pinctrl\PYGZus{}ops foo\PYGZus{}pctrl\PYGZus{}ops = \PYGZob{}
        .get\PYGZus{}groups\PYGZus{}count = foo\PYGZus{}get\PYGZus{}groups\PYGZus{}count,
        .get\PYGZus{}group\PYGZus{}name = foo\PYGZus{}get\PYGZus{}group\PYGZus{}name,
        .get\PYGZus{}group\PYGZus{}pins = foo\PYGZus{}get\PYGZus{}group\PYGZus{}pins,
\PYGZcb{};


static struct pinctrl\PYGZus{}desc foo\PYGZus{}desc = \PYGZob{}
...
.pctlops = \PYGZam{}foo\PYGZus{}pctrl\PYGZus{}ops,
\PYGZcb{};
\end{Verbatim}

The pin control subsystem will call the .get\_groups\_count() function to
determine the total number of legal selectors, then it will call the other functions
to retrieve the name and pins of the group. Maintaining the data structure of
the groups is up to the driver, this is just a simple example - in practice you
may need more entries in your group structure, for example specific register
ranges associated with each group and so on.


\section{Pin configuration}
\label{driver-api/pinctl:pin-configuration}
Pins can sometimes be software-configured in various ways, mostly related
to their electronic properties when used as inputs or outputs. For example you
may be able to make an output pin high impedance, or ``tristate'' meaning it is
effectively disconnected. You may be able to connect an input pin to VDD or GND
using a certain resistor value - pull up and pull down - so that the pin has a
stable value when nothing is driving the rail it is connected to, or when it's
unconnected.

Pin configuration can be programmed by adding configuration entries into the
mapping table; see section ``Board/machine configuration'' below.

The format and meaning of the configuration parameter, PLATFORM\_X\_PULL\_UP
above, is entirely defined by the pin controller driver.

The pin configuration driver implements callbacks for changing pin
configuration in the pin controller ops like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}linux/pinctrl/pinctrl.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}linux/pinctrl/pinconf.h\PYGZgt{}
\PYGZsh{}include \PYGZdq{}platform\PYGZus{}x\PYGZus{}pindefs.h\PYGZdq{}

static int foo\PYGZus{}pin\PYGZus{}config\PYGZus{}get(struct pinctrl\PYGZus{}dev *pctldev,
                unsigned offset,
                unsigned long *config)
\PYGZob{}
        struct my\PYGZus{}conftype conf;

        ... Find setting for pin @ offset ...

        *config = (unsigned long) conf;
\PYGZcb{}

static int foo\PYGZus{}pin\PYGZus{}config\PYGZus{}set(struct pinctrl\PYGZus{}dev *pctldev,
                unsigned offset,
                unsigned long config)
\PYGZob{}
        struct my\PYGZus{}conftype *conf = (struct my\PYGZus{}conftype *) config;

        switch (conf) \PYGZob{}
                case PLATFORM\PYGZus{}X\PYGZus{}PULL\PYGZus{}UP:
                ...
                \PYGZcb{}
        \PYGZcb{}
\PYGZcb{}

static int foo\PYGZus{}pin\PYGZus{}config\PYGZus{}group\PYGZus{}get (struct pinctrl\PYGZus{}dev *pctldev,
                unsigned selector,
                unsigned long *config)
\PYGZob{}
        ...
\PYGZcb{}

static int foo\PYGZus{}pin\PYGZus{}config\PYGZus{}group\PYGZus{}set (struct pinctrl\PYGZus{}dev *pctldev,
                unsigned selector,
                unsigned long config)
\PYGZob{}
        ...
\PYGZcb{}

static struct pinconf\PYGZus{}ops foo\PYGZus{}pconf\PYGZus{}ops = \PYGZob{}
        .pin\PYGZus{}config\PYGZus{}get = foo\PYGZus{}pin\PYGZus{}config\PYGZus{}get,
        .pin\PYGZus{}config\PYGZus{}set = foo\PYGZus{}pin\PYGZus{}config\PYGZus{}set,
        .pin\PYGZus{}config\PYGZus{}group\PYGZus{}get = foo\PYGZus{}pin\PYGZus{}config\PYGZus{}group\PYGZus{}get,
        .pin\PYGZus{}config\PYGZus{}group\PYGZus{}set = foo\PYGZus{}pin\PYGZus{}config\PYGZus{}group\PYGZus{}set,
\PYGZcb{};

/* Pin config operations are handled by some pin controller */
static struct pinctrl\PYGZus{}desc foo\PYGZus{}desc = \PYGZob{}
        ...
        .confops = \PYGZam{}foo\PYGZus{}pconf\PYGZus{}ops,
\PYGZcb{};
\end{Verbatim}

Since some controllers have special logic for handling entire groups of pins
they can exploit the special whole-group pin control function. The
pin\_config\_group\_set() callback is allowed to return the error code -EAGAIN,
for groups it does not want to handle, or if it just wants to do some
group-level handling and then fall through to iterate over all pins, in which
case each individual pin will be treated by separate pin\_config\_set() calls as
well.


\section{Interaction with the GPIO subsystem}
\label{driver-api/pinctl:interaction-with-the-gpio-subsystem}
The GPIO drivers may want to perform operations of various types on the same
physical pins that are also registered as pin controller pins.

First and foremost, the two subsystems can be used as completely orthogonal,
see the section named ``pin control requests from drivers'' and
``drivers needing both pin control and GPIOs'' below for details. But in some
situations a cross-subsystem mapping between pins and GPIOs is needed.

Since the pin controller subsystem has its pinspace local to the pin controller
we need a mapping so that the pin control subsystem can figure out which pin
controller handles control of a certain GPIO pin. Since a single pin controller
may be muxing several GPIO ranges (typically SoCs that have one set of pins,
but internally several GPIO silicon blocks, each modelled as a struct
gpio\_chip) any number of GPIO ranges can be added to a pin controller instance
like this:

\begin{Verbatim}[commandchars=\\\{\}]
struct gpio\PYGZus{}chip chip\PYGZus{}a;
struct gpio\PYGZus{}chip chip\PYGZus{}b;

static struct pinctrl\PYGZus{}gpio\PYGZus{}range gpio\PYGZus{}range\PYGZus{}a = \PYGZob{}
        .name = \PYGZdq{}chip a\PYGZdq{},
        .id = 0,
        .base = 32,
        .pin\PYGZus{}base = 32,
        .npins = 16,
        .gc = \PYGZam{}chip\PYGZus{}a;
\PYGZcb{};

static struct pinctrl\PYGZus{}gpio\PYGZus{}range gpio\PYGZus{}range\PYGZus{}b = \PYGZob{}
        .name = \PYGZdq{}chip b\PYGZdq{},
        .id = 0,
        .base = 48,
        .pin\PYGZus{}base = 64,
        .npins = 8,
        .gc = \PYGZam{}chip\PYGZus{}b;
\PYGZcb{};

\PYGZob{}
        struct pinctrl\PYGZus{}dev *pctl;
        ...
        pinctrl\PYGZus{}add\PYGZus{}gpio\PYGZus{}range(pctl, \PYGZam{}gpio\PYGZus{}range\PYGZus{}a);
        pinctrl\PYGZus{}add\PYGZus{}gpio\PYGZus{}range(pctl, \PYGZam{}gpio\PYGZus{}range\PYGZus{}b);
\PYGZcb{}
\end{Verbatim}

So this complex system has one pin controller handling two different
GPIO chips. ``chip a'' has 16 pins and ``chip b'' has 8 pins. The ``chip a'' and
``chip b'' have different .pin\_base, which means a start pin number of the
GPIO range.

The GPIO range of ``chip a'' starts from the GPIO base of 32 and actual
pin range also starts from 32. However ``chip b'' has different starting
offset for the GPIO range and pin range. The GPIO range of ``chip b'' starts
from GPIO number 48, while the pin range of ``chip b'' starts from 64.

We can convert a gpio number to actual pin number using this ``pin\_base''.
They are mapped in the global GPIO pin space at:
\begin{description}
\item[{chip a:}] \leavevmode\begin{itemize}
\item {} 
GPIO range : {[}32 .. 47{]}

\item {} 
pin range  : {[}32 .. 47{]}

\end{itemize}

\item[{chip b:}] \leavevmode\begin{itemize}
\item {} 
GPIO range : {[}48 .. 55{]}

\item {} 
pin range  : {[}64 .. 71{]}

\end{itemize}

\end{description}

The above examples assume the mapping between the GPIOs and pins is
linear. If the mapping is sparse or haphazard, an array of arbitrary pin
numbers can be encoded in the range like this:

\begin{Verbatim}[commandchars=\\\{\}]
static const unsigned range\PYGZus{}pins[] = \PYGZob{} 14, 1, 22, 17, 10, 8, 6, 2 \PYGZcb{};

static struct pinctrl\PYGZus{}gpio\PYGZus{}range gpio\PYGZus{}range = \PYGZob{}
        .name = \PYGZdq{}chip\PYGZdq{},
        .id = 0,
        .base = 32,
        .pins = \PYGZam{}range\PYGZus{}pins,
        .npins = ARRAY\PYGZus{}SIZE(range\PYGZus{}pins),
        .gc = \PYGZam{}chip;
\PYGZcb{};
\end{Verbatim}

In this case the pin\_base property will be ignored. If the name of a pin
group is known, the pins and npins elements of the above structure can be
initialised using the function pinctrl\_get\_group\_pins(), e.g. for pin
group ``foo'':

\begin{Verbatim}[commandchars=\\\{\}]
pinctrl\PYGZus{}get\PYGZus{}group\PYGZus{}pins(pctl, \PYGZdq{}foo\PYGZdq{}, \PYGZam{}gpio\PYGZus{}range.pins,
                       \PYGZam{}gpio\PYGZus{}range.npins);
\end{Verbatim}

When GPIO-specific functions in the pin control subsystem are called, these
ranges will be used to look up the appropriate pin controller by inspecting
and matching the pin to the pin ranges across all controllers. When a
pin controller handling the matching range is found, GPIO-specific functions
will be called on that specific pin controller.

For all functionalities dealing with pin biasing, pin muxing etc, the pin
controller subsystem will look up the corresponding pin number from the passed
in gpio number, and use the range's internals to retrieve a pin number. After
that, the subsystem passes it on to the pin control driver, so the driver
will get a pin number into its handled number range. Further it is also passed
the range ID value, so that the pin controller knows which range it should
deal with.

Calling pinctrl\_add\_gpio\_range from pinctrl driver is DEPRECATED. Please see
section 2.1 of Documentation/devicetree/bindings/gpio/gpio.txt on how to bind
pinctrl and gpio drivers.


\section{PINMUX interfaces}
\label{driver-api/pinctl:pinmux-interfaces}
These calls use the pinmux\_* naming prefix.  No other calls should use that
prefix.


\section{What is pinmuxing?}
\label{driver-api/pinctl:what-is-pinmuxing}
PINMUX, also known as padmux, ballmux, alternate functions or mission modes
is a way for chip vendors producing some kind of electrical packages to use
a certain physical pin (ball, pad, finger, etc) for multiple mutually exclusive
functions, depending on the application. By ``application'' in this context
we usually mean a way of soldering or wiring the package into an electronic
system, even though the framework makes it possible to also change the function
at runtime.

Here is an example of a PGA (Pin Grid Array) chip seen from underneath:

\begin{Verbatim}[commandchars=\\\{\}]
     A   B   C   D   E   F   G   H
   +\PYGZhy{}\PYGZhy{}\PYGZhy{}+
8  \textbar{} o \textbar{} o   o   o   o   o   o   o
   \textbar{}   \textbar{}
7  \textbar{} o \textbar{} o   o   o   o   o   o   o
   \textbar{}   \textbar{}
6  \textbar{} o \textbar{} o   o   o   o   o   o   o
   +\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+
5  \textbar{} o \textbar{} o \textbar{} o   o   o   o   o   o
   +\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+               +\PYGZhy{}\PYGZhy{}\PYGZhy{}+
4    o   o   o   o   o   o \textbar{} o \textbar{} o
                           \textbar{}   \textbar{}
3    o   o   o   o   o   o \textbar{} o \textbar{} o
                           \textbar{}   \textbar{}
2    o   o   o   o   o   o \textbar{} o \textbar{} o
   +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+
1  \textbar{} o   o \textbar{} o   o \textbar{} o   o \textbar{} o \textbar{} o \textbar{}
   +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{Verbatim}

This is not tetris. The game to think of is chess. Not all PGA/BGA packages
are chessboard-like, big ones have ``holes'' in some arrangement according to
different design patterns, but we're using this as a simple example. Of the
pins you see some will be taken by things like a few VCC and GND to feed power
to the chip, and quite a few will be taken by large ports like an external
memory interface. The remaining pins will often be subject to pin multiplexing.

The example 8x8 PGA package above will have pin numbers 0 through 63 assigned
to its physical pins. It will name the pins \{ A1, A2, A3 ... H6, H7, H8 \} using
pinctrl\_register\_pins() and a suitable data set as shown earlier.

In this 8x8 BGA package the pins \{ A8, A7, A6, A5 \} can be used as an SPI port
(these are four pins: CLK, RXD, TXD, FRM). In that case, pin B5 can be used as
some general-purpose GPIO pin. However, in another setting, pins \{ A5, B5 \} can
be used as an I2C port (these are just two pins: SCL, SDA). Needless to say,
we cannot use the SPI port and I2C port at the same time. However in the inside
of the package the silicon performing the SPI logic can alternatively be routed
out on pins \{ G4, G3, G2, G1 \}.

On the bottom row at \{ A1, B1, C1, D1, E1, F1, G1, H1 \} we have something
special - it's an external MMC bus that can be 2, 4 or 8 bits wide, and it will
consume 2, 4 or 8 pins respectively, so either \{ A1, B1 \} are taken or
\{ A1, B1, C1, D1 \} or all of them. If we use all 8 bits, we cannot use the SPI
port on pins \{ G4, G3, G2, G1 \} of course.

This way the silicon blocks present inside the chip can be multiplexed ``muxed''
out on different pin ranges. Often contemporary SoC (systems on chip) will
contain several I2C, SPI, SDIO/MMC, etc silicon blocks that can be routed to
different pins by pinmux settings.

Since general-purpose I/O pins (GPIO) are typically always in shortage, it is
common to be able to use almost any pin as a GPIO pin if it is not currently
in use by some other I/O port.


\section{Pinmux conventions}
\label{driver-api/pinctl:pinmux-conventions}
The purpose of the pinmux functionality in the pin controller subsystem is to
abstract and provide pinmux settings to the devices you choose to instantiate
in your machine configuration. It is inspired by the clk, GPIO and regulator
subsystems, so devices will request their mux setting, but it's also possible
to request a single pin for e.g. GPIO.

Definitions:
\begin{itemize}
\item {} 
FUNCTIONS can be switched in and out by a driver residing with the pin
control subsystem in the drivers/pinctrl/* directory of the kernel. The
pin control driver knows the possible functions. In the example above you can
identify three pinmux functions, one for spi, one for i2c and one for mmc.

\item {} 
FUNCTIONS are assumed to be enumerable from zero in a one-dimensional array.
In this case the array could be something like: \{ spi0, i2c0, mmc0 \}
for the three available functions.

\item {} 
FUNCTIONS have PIN GROUPS as defined on the generic level - so a certain
function is \emph{always} associated with a certain set of pin groups, could
be just a single one, but could also be many. In the example above the
function i2c is associated with the pins \{ A5, B5 \}, enumerated as
\{ 24, 25 \} in the controller pin space.

The Function spi is associated with pin groups \{ A8, A7, A6, A5 \}
and \{ G4, G3, G2, G1 \}, which are enumerated as \{ 0, 8, 16, 24 \} and
\{ 38, 46, 54, 62 \} respectively.

Group names must be unique per pin controller, no two groups on the same
controller may have the same name.

\item {} 
The combination of a FUNCTION and a PIN GROUP determine a certain function
for a certain set of pins. The knowledge of the functions and pin groups
and their machine-specific particulars are kept inside the pinmux driver,
from the outside only the enumerators are known, and the driver core can
request:
\begin{itemize}
\item {} 
The name of a function with a certain selector (\textgreater{}= 0)

\item {} 
A list of groups associated with a certain function

\item {} 
That a certain group in that list to be activated for a certain function

\end{itemize}

As already described above, pin groups are in turn self-descriptive, so
the core will retrieve the actual pin range in a certain group from the
driver.

\item {} 
FUNCTIONS and GROUPS on a certain PIN CONTROLLER are MAPPED to a certain
device by the board file, device tree or similar machine setup configuration
mechanism, similar to how regulators are connected to devices, usually by
name. Defining a pin controller, function and group thus uniquely identify
the set of pins to be used by a certain device. (If only one possible group
of pins is available for the function, no group name need to be supplied -
the core will simply select the first and only group available.)

In the example case we can define that this particular machine shall
use device spi0 with pinmux function fspi0 group gspi0 and i2c0 on function
fi2c0 group gi2c0, on the primary pin controller, we get mappings
like these:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{}
        \PYGZob{}\PYGZdq{}map\PYGZhy{}spi0\PYGZdq{}, spi0, pinctrl0, fspi0, gspi0\PYGZcb{},
        \PYGZob{}\PYGZdq{}map\PYGZhy{}i2c0\PYGZdq{}, i2c0, pinctrl0, fi2c0, gi2c0\PYGZcb{}
\PYGZcb{}
\end{Verbatim}

Every map must be assigned a state name, pin controller, device and
function. The group is not compulsory - if it is omitted the first group
presented by the driver as applicable for the function will be selected,
which is useful for simple cases.

It is possible to map several groups to the same combination of device,
pin controller and function. This is for cases where a certain function on
a certain pin controller may use different sets of pins in different
configurations.

\item {} 
PINS for a certain FUNCTION using a certain PIN GROUP on a certain
PIN CONTROLLER are provided on a first-come first-serve basis, so if some
other device mux setting or GPIO pin request has already taken your physical
pin, you will be denied the use of it. To get (activate) a new setting, the
old one has to be put (deactivated) first.

\end{itemize}

Sometimes the documentation and hardware registers will be oriented around
pads (or ``fingers'') rather than pins - these are the soldering surfaces on the
silicon inside the package, and may or may not match the actual number of
pins/balls underneath the capsule. Pick some enumeration that makes sense to
you. Define enumerators only for the pins you can control if that makes sense.

Assumptions:

We assume that the number of possible function maps to pin groups is limited by
the hardware. I.e. we assume that there is no system where any function can be
mapped to any pin, like in a phone exchange. So the available pin groups for
a certain function will be limited to a few choices (say up to eight or so),
not hundreds or any amount of choices. This is the characteristic we have found
by inspecting available pinmux hardware, and a necessary assumption since we
expect pinmux drivers to present \emph{all} possible function vs pin group mappings
to the subsystem.


\section{Pinmux drivers}
\label{driver-api/pinctl:pinmux-drivers}
The pinmux core takes care of preventing conflicts on pins and calling
the pin controller driver to execute different settings.

It is the responsibility of the pinmux driver to impose further restrictions
(say for example infer electronic limitations due to load, etc.) to determine
whether or not the requested function can actually be allowed, and in case it
is possible to perform the requested mux setting, poke the hardware so that
this happens.

Pinmux drivers are required to supply a few callback functions, some are
optional. Usually the set\_mux() function is implemented, writing values into
some certain registers to activate a certain mux setting for a certain pin.

A simple driver for the above example will work by setting bits 0, 1, 2, 3 or 4
into some register named MUX to select a certain function with a certain
group of pins would work something like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}linux/pinctrl/pinctrl.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}linux/pinctrl/pinmux.h\PYGZgt{}

struct foo\PYGZus{}group \PYGZob{}
        const char *name;
        const unsigned int *pins;
        const unsigned num\PYGZus{}pins;
\PYGZcb{};

static const unsigned spi0\PYGZus{}0\PYGZus{}pins[] = \PYGZob{} 0, 8, 16, 24 \PYGZcb{};
static const unsigned spi0\PYGZus{}1\PYGZus{}pins[] = \PYGZob{} 38, 46, 54, 62 \PYGZcb{};
static const unsigned i2c0\PYGZus{}pins[] = \PYGZob{} 24, 25 \PYGZcb{};
static const unsigned mmc0\PYGZus{}1\PYGZus{}pins[] = \PYGZob{} 56, 57 \PYGZcb{};
static const unsigned mmc0\PYGZus{}2\PYGZus{}pins[] = \PYGZob{} 58, 59 \PYGZcb{};
static const unsigned mmc0\PYGZus{}3\PYGZus{}pins[] = \PYGZob{} 60, 61, 62, 63 \PYGZcb{};

static const struct foo\PYGZus{}group foo\PYGZus{}groups[] = \PYGZob{}
        \PYGZob{}
                .name = \PYGZdq{}spi0\PYGZus{}0\PYGZus{}grp\PYGZdq{},
                .pins = spi0\PYGZus{}0\PYGZus{}pins,
                .num\PYGZus{}pins = ARRAY\PYGZus{}SIZE(spi0\PYGZus{}0\PYGZus{}pins),
        \PYGZcb{},
        \PYGZob{}
                .name = \PYGZdq{}spi0\PYGZus{}1\PYGZus{}grp\PYGZdq{},
                .pins = spi0\PYGZus{}1\PYGZus{}pins,
                .num\PYGZus{}pins = ARRAY\PYGZus{}SIZE(spi0\PYGZus{}1\PYGZus{}pins),
        \PYGZcb{},
        \PYGZob{}
                .name = \PYGZdq{}i2c0\PYGZus{}grp\PYGZdq{},
                .pins = i2c0\PYGZus{}pins,
                .num\PYGZus{}pins = ARRAY\PYGZus{}SIZE(i2c0\PYGZus{}pins),
        \PYGZcb{},
        \PYGZob{}
                .name = \PYGZdq{}mmc0\PYGZus{}1\PYGZus{}grp\PYGZdq{},
                .pins = mmc0\PYGZus{}1\PYGZus{}pins,
                .num\PYGZus{}pins = ARRAY\PYGZus{}SIZE(mmc0\PYGZus{}1\PYGZus{}pins),
        \PYGZcb{},
        \PYGZob{}
                .name = \PYGZdq{}mmc0\PYGZus{}2\PYGZus{}grp\PYGZdq{},
                .pins = mmc0\PYGZus{}2\PYGZus{}pins,
                .num\PYGZus{}pins = ARRAY\PYGZus{}SIZE(mmc0\PYGZus{}2\PYGZus{}pins),
        \PYGZcb{},
        \PYGZob{}
                .name = \PYGZdq{}mmc0\PYGZus{}3\PYGZus{}grp\PYGZdq{},
                .pins = mmc0\PYGZus{}3\PYGZus{}pins,
                .num\PYGZus{}pins = ARRAY\PYGZus{}SIZE(mmc0\PYGZus{}3\PYGZus{}pins),
        \PYGZcb{},
\PYGZcb{};


static int foo\PYGZus{}get\PYGZus{}groups\PYGZus{}count(struct pinctrl\PYGZus{}dev *pctldev)
\PYGZob{}
        return ARRAY\PYGZus{}SIZE(foo\PYGZus{}groups);
\PYGZcb{}

static const char *foo\PYGZus{}get\PYGZus{}group\PYGZus{}name(struct pinctrl\PYGZus{}dev *pctldev,
                                unsigned selector)
\PYGZob{}
        return foo\PYGZus{}groups[selector].name;
\PYGZcb{}

static int foo\PYGZus{}get\PYGZus{}group\PYGZus{}pins(struct pinctrl\PYGZus{}dev *pctldev, unsigned selector,
                        unsigned ** const pins,
                        unsigned * const num\PYGZus{}pins)
\PYGZob{}
        *pins = (unsigned *) foo\PYGZus{}groups[selector].pins;
        *num\PYGZus{}pins = foo\PYGZus{}groups[selector].num\PYGZus{}pins;
        return 0;
\PYGZcb{}

static struct pinctrl\PYGZus{}ops foo\PYGZus{}pctrl\PYGZus{}ops = \PYGZob{}
        .get\PYGZus{}groups\PYGZus{}count = foo\PYGZus{}get\PYGZus{}groups\PYGZus{}count,
        .get\PYGZus{}group\PYGZus{}name = foo\PYGZus{}get\PYGZus{}group\PYGZus{}name,
        .get\PYGZus{}group\PYGZus{}pins = foo\PYGZus{}get\PYGZus{}group\PYGZus{}pins,
\PYGZcb{};

struct foo\PYGZus{}pmx\PYGZus{}func \PYGZob{}
        const char *name;
        const char * const *groups;
        const unsigned num\PYGZus{}groups;
\PYGZcb{};

static const char * const spi0\PYGZus{}groups[] = \PYGZob{} \PYGZdq{}spi0\PYGZus{}0\PYGZus{}grp\PYGZdq{}, \PYGZdq{}spi0\PYGZus{}1\PYGZus{}grp\PYGZdq{} \PYGZcb{};
static const char * const i2c0\PYGZus{}groups[] = \PYGZob{} \PYGZdq{}i2c0\PYGZus{}grp\PYGZdq{} \PYGZcb{};
static const char * const mmc0\PYGZus{}groups[] = \PYGZob{} \PYGZdq{}mmc0\PYGZus{}1\PYGZus{}grp\PYGZdq{}, \PYGZdq{}mmc0\PYGZus{}2\PYGZus{}grp\PYGZdq{},
                                        \PYGZdq{}mmc0\PYGZus{}3\PYGZus{}grp\PYGZdq{} \PYGZcb{};

static const struct foo\PYGZus{}pmx\PYGZus{}func foo\PYGZus{}functions[] = \PYGZob{}
        \PYGZob{}
                .name = \PYGZdq{}spi0\PYGZdq{},
                .groups = spi0\PYGZus{}groups,
                .num\PYGZus{}groups = ARRAY\PYGZus{}SIZE(spi0\PYGZus{}groups),
        \PYGZcb{},
        \PYGZob{}
                .name = \PYGZdq{}i2c0\PYGZdq{},
                .groups = i2c0\PYGZus{}groups,
                .num\PYGZus{}groups = ARRAY\PYGZus{}SIZE(i2c0\PYGZus{}groups),
        \PYGZcb{},
        \PYGZob{}
                .name = \PYGZdq{}mmc0\PYGZdq{},
                .groups = mmc0\PYGZus{}groups,
                .num\PYGZus{}groups = ARRAY\PYGZus{}SIZE(mmc0\PYGZus{}groups),
        \PYGZcb{},
\PYGZcb{};

static int foo\PYGZus{}get\PYGZus{}functions\PYGZus{}count(struct pinctrl\PYGZus{}dev *pctldev)
\PYGZob{}
        return ARRAY\PYGZus{}SIZE(foo\PYGZus{}functions);
\PYGZcb{}

static const char *foo\PYGZus{}get\PYGZus{}fname(struct pinctrl\PYGZus{}dev *pctldev, unsigned selector)
\PYGZob{}
        return foo\PYGZus{}functions[selector].name;
\PYGZcb{}

static int foo\PYGZus{}get\PYGZus{}groups(struct pinctrl\PYGZus{}dev *pctldev, unsigned selector,
                        const char * const **groups,
                        unsigned * const num\PYGZus{}groups)
\PYGZob{}
        *groups = foo\PYGZus{}functions[selector].groups;
        *num\PYGZus{}groups = foo\PYGZus{}functions[selector].num\PYGZus{}groups;
        return 0;
\PYGZcb{}

static int foo\PYGZus{}set\PYGZus{}mux(struct pinctrl\PYGZus{}dev *pctldev, unsigned selector,
                unsigned group)
\PYGZob{}
        u8 regbit = (1 \PYGZlt{}\PYGZlt{} selector + group);

        writeb((readb(MUX)\textbar{}regbit), MUX)
        return 0;
\PYGZcb{}

static struct pinmux\PYGZus{}ops foo\PYGZus{}pmxops = \PYGZob{}
        .get\PYGZus{}functions\PYGZus{}count = foo\PYGZus{}get\PYGZus{}functions\PYGZus{}count,
        .get\PYGZus{}function\PYGZus{}name = foo\PYGZus{}get\PYGZus{}fname,
        .get\PYGZus{}function\PYGZus{}groups = foo\PYGZus{}get\PYGZus{}groups,
        .set\PYGZus{}mux = foo\PYGZus{}set\PYGZus{}mux,
        .strict = true,
\PYGZcb{};

/* Pinmux operations are handled by some pin controller */
static struct pinctrl\PYGZus{}desc foo\PYGZus{}desc = \PYGZob{}
        ...
        .pctlops = \PYGZam{}foo\PYGZus{}pctrl\PYGZus{}ops,
        .pmxops = \PYGZam{}foo\PYGZus{}pmxops,
\PYGZcb{};
\end{Verbatim}

In the example activating muxing 0 and 1 at the same time setting bits
0 and 1, uses one pin in common so they would collide.

The beauty of the pinmux subsystem is that since it keeps track of all
pins and who is using them, it will already have denied an impossible
request like that, so the driver does not need to worry about such
things - when it gets a selector passed in, the pinmux subsystem makes
sure no other device or GPIO assignment is already using the selected
pins. Thus bits 0 and 1 in the control register will never be set at the
same time.

All the above functions are mandatory to implement for a pinmux driver.


\section{Pin control interaction with the GPIO subsystem}
\label{driver-api/pinctl:pin-control-interaction-with-the-gpio-subsystem}
Note that the following implies that the use case is to use a certain pin
from the Linux kernel using the API in \textless{}linux/gpio.h\textgreater{} with gpio\_request()
and similar functions. There are cases where you may be using something
that your datasheet calls ``GPIO mode'', but actually is just an electrical
configuration for a certain device. See the section below named
``GPIO mode pitfalls'' for more details on this scenario.

The public pinmux API contains two functions named pinctrl\_gpio\_request()
and pinctrl\_gpio\_free(). These two functions shall \emph{ONLY} be called from
gpiolib-based drivers as part of their gpio\_request() and
gpio\_free() semantics. Likewise the pinctrl\_gpio\_direction\_{[}input\textbar{}output{]}
shall only be called from within respective gpio\_direction\_{[}input\textbar{}output{]}
gpiolib implementation.

NOTE that platforms and individual drivers shall \emph{NOT} request GPIO pins to be
controlled e.g. muxed in. Instead, implement a proper gpiolib driver and have
that driver request proper muxing and other control for its pins.

The function list could become long, especially if you can convert every
individual pin into a GPIO pin independent of any other pins, and then try
the approach to define every pin as a function.

In this case, the function array would become 64 entries for each GPIO
setting and then the device functions.

For this reason there are two functions a pin control driver can implement
to enable only GPIO on an individual pin: .gpio\_request\_enable() and
.gpio\_disable\_free().

This function will pass in the affected GPIO range identified by the pin
controller core, so you know which GPIO pins are being affected by the request
operation.

If your driver needs to have an indication from the framework of whether the
GPIO pin shall be used for input or output you can implement the
.gpio\_set\_direction() function. As described this shall be called from the
gpiolib driver and the affected GPIO range, pin offset and desired direction
will be passed along to this function.

Alternatively to using these special functions, it is fully allowed to use
named functions for each GPIO pin, the pinctrl\_gpio\_request() will attempt to
obtain the function ``gpioN'' where ``N'' is the global GPIO pin number if no
special GPIO-handler is registered.


\section{GPIO mode pitfalls}
\label{driver-api/pinctl:gpio-mode-pitfalls}
Due to the naming conventions used by hardware engineers, where ``GPIO''
is taken to mean different things than what the kernel does, the developer
may be confused by a datasheet talking about a pin being possible to set
into ``GPIO mode''. It appears that what hardware engineers mean with
``GPIO mode'' is not necessarily the use case that is implied in the kernel
interface \textless{}linux/gpio.h\textgreater{}: a pin that you grab from kernel code and then
either listen for input or drive high/low to assert/deassert some
external line.

Rather hardware engineers think that ``GPIO mode'' means that you can
software-control a few electrical properties of the pin that you would
not be able to control if the pin was in some other mode, such as muxed in
for a device.

The GPIO portions of a pin and its relation to a certain pin controller
configuration and muxing logic can be constructed in several ways. Here
are two examples:

\begin{Verbatim}[commandchars=\\\{\}]
(A)
                  pin config
                  logic regs
                  \textbar{}               +\PYGZhy{} SPI
Physical pins \PYGZhy{}\PYGZhy{}\PYGZhy{} pad \PYGZhy{}\PYGZhy{}\PYGZhy{} pinmux \PYGZhy{}+\PYGZhy{} I2C
                          \textbar{}       +\PYGZhy{} mmc
                          \textbar{}       +\PYGZhy{} GPIO
                          pin
                          multiplex
                          logic regs
\end{Verbatim}

Here some electrical properties of the pin can be configured no matter
whether the pin is used for GPIO or not. If you multiplex a GPIO onto a
pin, you can also drive it high/low from ``GPIO'' registers.
Alternatively, the pin can be controlled by a certain peripheral, while
still applying desired pin config properties. GPIO functionality is thus
orthogonal to any other device using the pin.

In this arrangement the registers for the GPIO portions of the pin controller,
or the registers for the GPIO hardware module are likely to reside in a
separate memory range only intended for GPIO driving, and the register
range dealing with pin config and pin multiplexing get placed into a
different memory range and a separate section of the data sheet.

A flag ``strict'' in struct pinmux\_ops is available to check and deny
simultaneous access to the same pin from GPIO and pin multiplexing
consumers on hardware of this type. The pinctrl driver should set this flag
accordingly.

\begin{Verbatim}[commandchars=\\\{\}]
(B)

                  pin config
                  logic regs
                  \textbar{}               +\PYGZhy{} SPI
Physical pins \PYGZhy{}\PYGZhy{}\PYGZhy{} pad \PYGZhy{}\PYGZhy{}\PYGZhy{} pinmux \PYGZhy{}+\PYGZhy{} I2C
                  \textbar{}       \textbar{}       +\PYGZhy{} mmc
                  \textbar{}       \textbar{}
                  GPIO    pin
                          multiplex
                          logic regs
\end{Verbatim}

In this arrangement, the GPIO functionality can always be enabled, such that
e.g. a GPIO input can be used to ``spy'' on the SPI/I2C/MMC signal while it is
pulsed out. It is likely possible to disrupt the traffic on the pin by doing
wrong things on the GPIO block, as it is never really disconnected. It is
possible that the GPIO, pin config and pin multiplex registers are placed into
the same memory range and the same section of the data sheet, although that
need not be the case.

In some pin controllers, although the physical pins are designed in the same
way as (B), the GPIO function still can't be enabled at the same time as the
peripheral functions. So again the ``strict'' flag should be set, denying
simultaneous activation by GPIO and other muxed in devices.

From a kernel point of view, however, these are different aspects of the
hardware and shall be put into different subsystems:
\begin{itemize}
\item {} 
Registers (or fields within registers) that control electrical
properties of the pin such as biasing and drive strength should be
exposed through the pinctrl subsystem, as ``pin configuration'' settings.

\item {} 
Registers (or fields within registers) that control muxing of signals
from various other HW blocks (e.g. I2C, MMC, or GPIO) onto pins should
be exposed through the pinctrl subsystem, as mux functions.

\item {} 
Registers (or fields within registers) that control GPIO functionality
such as setting a GPIO's output value, reading a GPIO's input value, or
setting GPIO pin direction should be exposed through the GPIO subsystem,
and if they also support interrupt capabilities, through the irqchip
abstraction.

\end{itemize}

Depending on the exact HW register design, some functions exposed by the
GPIO subsystem may call into the pinctrl subsystem in order to
co-ordinate register settings across HW modules. In particular, this may
be needed for HW with separate GPIO and pin controller HW modules, where
e.g. GPIO direction is determined by a register in the pin controller HW
module rather than the GPIO HW module.

Electrical properties of the pin such as biasing and drive strength
may be placed at some pin-specific register in all cases or as part
of the GPIO register in case (B) especially. This doesn't mean that such
properties necessarily pertain to what the Linux kernel calls ``GPIO''.

Example: a pin is usually muxed in to be used as a UART TX line. But during
system sleep, we need to put this pin into ``GPIO mode'' and ground it.

If you make a 1-to-1 map to the GPIO subsystem for this pin, you may start
to think that you need to come up with something really complex, that the
pin shall be used for UART TX and GPIO at the same time, that you will grab
a pin control handle and set it to a certain state to enable UART TX to be
muxed in, then twist it over to GPIO mode and use gpio\_direction\_output()
to drive it low during sleep, then mux it over to UART TX again when you
wake up and maybe even gpio\_request/gpio\_free as part of this cycle. This
all gets very complicated.

The solution is to not think that what the datasheet calls ``GPIO mode''
has to be handled by the \textless{}linux/gpio.h\textgreater{} interface. Instead view this as
a certain pin config setting. Look in e.g. \textless{}linux/pinctrl/pinconf-generic.h\textgreater{}
and you find this in the documentation:
\begin{quote}
\begin{description}
\item[{PIN\_CONFIG\_OUTPUT:}] \leavevmode
this will configure the pin in output, use argument
1 to indicate high level, argument 0 to indicate low level.

\end{description}
\end{quote}

So it is perfectly possible to push a pin into ``GPIO mode'' and drive the
line low as part of the usual pin control map. So for example your UART
driver may look like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}linux/pinctrl/consumer.h\PYGZgt{}

struct pinctrl          *pinctrl;
struct pinctrl\PYGZus{}state    *pins\PYGZus{}default;
struct pinctrl\PYGZus{}state    *pins\PYGZus{}sleep;

pins\PYGZus{}default = pinctrl\PYGZus{}lookup\PYGZus{}state(uap\PYGZhy{}\PYGZgt{}pinctrl, PINCTRL\PYGZus{}STATE\PYGZus{}DEFAULT);
pins\PYGZus{}sleep = pinctrl\PYGZus{}lookup\PYGZus{}state(uap\PYGZhy{}\PYGZgt{}pinctrl, PINCTRL\PYGZus{}STATE\PYGZus{}SLEEP);

/* Normal mode */
retval = pinctrl\PYGZus{}select\PYGZus{}state(pinctrl, pins\PYGZus{}default);
/* Sleep mode */
retval = pinctrl\PYGZus{}select\PYGZus{}state(pinctrl, pins\PYGZus{}sleep);
\end{Verbatim}


\subsection{And your machine configuration may look like this:}
\label{driver-api/pinctl:and-your-machine-configuration-may-look-like-this}
\begin{Verbatim}[commandchars=\\\{\}]
static unsigned long uart\PYGZus{}default\PYGZus{}mode[] = \PYGZob{}
        PIN\PYGZus{}CONF\PYGZus{}PACKED(PIN\PYGZus{}CONFIG\PYGZus{}DRIVE\PYGZus{}PUSH\PYGZus{}PULL, 0),
\PYGZcb{};

static unsigned long uart\PYGZus{}sleep\PYGZus{}mode[] = \PYGZob{}
        PIN\PYGZus{}CONF\PYGZus{}PACKED(PIN\PYGZus{}CONFIG\PYGZus{}OUTPUT, 0),
\PYGZcb{};

static struct pinctrl\PYGZus{}map pinmap[] \PYGZus{}\PYGZus{}initdata = \PYGZob{}
        PIN\PYGZus{}MAP\PYGZus{}MUX\PYGZus{}GROUP(\PYGZdq{}uart\PYGZdq{}, PINCTRL\PYGZus{}STATE\PYGZus{}DEFAULT, \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{},
                \PYGZdq{}u0\PYGZus{}group\PYGZdq{}, \PYGZdq{}u0\PYGZdq{}),
        PIN\PYGZus{}MAP\PYGZus{}CONFIGS\PYGZus{}PIN(\PYGZdq{}uart\PYGZdq{}, PINCTRL\PYGZus{}STATE\PYGZus{}DEFAULT, \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{},
                        \PYGZdq{}UART\PYGZus{}TX\PYGZus{}PIN\PYGZdq{}, uart\PYGZus{}default\PYGZus{}mode),
        PIN\PYGZus{}MAP\PYGZus{}MUX\PYGZus{}GROUP(\PYGZdq{}uart\PYGZdq{}, PINCTRL\PYGZus{}STATE\PYGZus{}SLEEP, \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{},
                \PYGZdq{}u0\PYGZus{}group\PYGZdq{}, \PYGZdq{}gpio\PYGZhy{}mode\PYGZdq{}),
        PIN\PYGZus{}MAP\PYGZus{}CONFIGS\PYGZus{}PIN(\PYGZdq{}uart\PYGZdq{}, PINCTRL\PYGZus{}STATE\PYGZus{}SLEEP, \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{},
                        \PYGZdq{}UART\PYGZus{}TX\PYGZus{}PIN\PYGZdq{}, uart\PYGZus{}sleep\PYGZus{}mode),
\PYGZcb{};

foo\PYGZus{}init(void) \PYGZob{}
        pinctrl\PYGZus{}register\PYGZus{}mappings(pinmap, ARRAY\PYGZus{}SIZE(pinmap));
\PYGZcb{}
\end{Verbatim}

Here the pins we want to control are in the ``u0\_group'' and there is some
function called ``u0'' that can be enabled on this group of pins, and then
everything is UART business as usual. But there is also some function
named ``gpio-mode'' that can be mapped onto the same pins to move them into
GPIO mode.

This will give the desired effect without any bogus interaction with the
GPIO subsystem. It is just an electrical configuration used by that device
when going to sleep, it might imply that the pin is set into something the
datasheet calls ``GPIO mode'', but that is not the point: it is still used
by that UART device to control the pins that pertain to that very UART
driver, putting them into modes needed by the UART. GPIO in the Linux
kernel sense are just some 1-bit line, and is a different use case.

How the registers are poked to attain the push or pull, and output low
configuration and the muxing of the ``u0'' or ``gpio-mode'' group onto these
pins is a question for the driver.

Some datasheets will be more helpful and refer to the ``GPIO mode'' as
``low power mode'' rather than anything to do with GPIO. This often means
the same thing electrically speaking, but in this latter case the
software engineers will usually quickly identify that this is some
specific muxing or configuration rather than anything related to the GPIO
API.


\section{Board/machine configuration}
\label{driver-api/pinctl:board-machine-configuration}
Boards and machines define how a certain complete running system is put
together, including how GPIOs and devices are muxed, how regulators are
constrained and how the clock tree looks. Of course pinmux settings are also
part of this.

A pin controller configuration for a machine looks pretty much like a simple
regulator configuration, so for the example array above we want to enable i2c
and spi on the second function mapping:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}linux/pinctrl/machine.h\PYGZgt{}

static const struct pinctrl\PYGZus{}map mapping[] \PYGZus{}\PYGZus{}initconst = \PYGZob{}
        \PYGZob{}
                .dev\PYGZus{}name = \PYGZdq{}foo\PYGZhy{}spi.0\PYGZdq{},
                .name = PINCTRL\PYGZus{}STATE\PYGZus{}DEFAULT,
                .type = PIN\PYGZus{}MAP\PYGZus{}TYPE\PYGZus{}MUX\PYGZus{}GROUP,
                .ctrl\PYGZus{}dev\PYGZus{}name = \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{},
                .data.mux.function = \PYGZdq{}spi0\PYGZdq{},
        \PYGZcb{},
        \PYGZob{}
                .dev\PYGZus{}name = \PYGZdq{}foo\PYGZhy{}i2c.0\PYGZdq{},
                .name = PINCTRL\PYGZus{}STATE\PYGZus{}DEFAULT,
                .type = PIN\PYGZus{}MAP\PYGZus{}TYPE\PYGZus{}MUX\PYGZus{}GROUP,
                .ctrl\PYGZus{}dev\PYGZus{}name = \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{},
                .data.mux.function = \PYGZdq{}i2c0\PYGZdq{},
        \PYGZcb{},
        \PYGZob{}
                .dev\PYGZus{}name = \PYGZdq{}foo\PYGZhy{}mmc.0\PYGZdq{},
                .name = PINCTRL\PYGZus{}STATE\PYGZus{}DEFAULT,
                .type = PIN\PYGZus{}MAP\PYGZus{}TYPE\PYGZus{}MUX\PYGZus{}GROUP,
                .ctrl\PYGZus{}dev\PYGZus{}name = \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{},
                .data.mux.function = \PYGZdq{}mmc0\PYGZdq{},
        \PYGZcb{},
\PYGZcb{};
\end{Verbatim}

The dev\_name here matches to the unique device name that can be used to look
up the device struct (just like with clockdev or regulators). The function name
must match a function provided by the pinmux driver handling this pin range.

As you can see we may have several pin controllers on the system and thus
we need to specify which one of them contains the functions we wish to map.

You register this pinmux mapping to the pinmux subsystem by simply:

\begin{Verbatim}[commandchars=\\\{\}]
ret = pinctrl\PYGZus{}register\PYGZus{}mappings(mapping, ARRAY\PYGZus{}SIZE(mapping));
\end{Verbatim}

Since the above construct is pretty common there is a helper macro to make
it even more compact which assumes you want to use pinctrl-foo and position
0 for mapping, for example:

\begin{Verbatim}[commandchars=\\\{\}]
static struct pinctrl\PYGZus{}map mapping[] \PYGZus{}\PYGZus{}initdata = \PYGZob{}
        PIN\PYGZus{}MAP\PYGZus{}MUX\PYGZus{}GROUP(\PYGZdq{}foo\PYGZhy{}i2c.o\PYGZdq{}, PINCTRL\PYGZus{}STATE\PYGZus{}DEFAULT,
                          \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{}, NULL, \PYGZdq{}i2c0\PYGZdq{}),
\PYGZcb{};
\end{Verbatim}

The mapping table may also contain pin configuration entries. It's common for
each pin/group to have a number of configuration entries that affect it, so
the table entries for configuration reference an array of config parameters
and values. An example using the convenience macros is shown below:

\begin{Verbatim}[commandchars=\\\{\}]
static unsigned long i2c\PYGZus{}grp\PYGZus{}configs[] = \PYGZob{}
        FOO\PYGZus{}PIN\PYGZus{}DRIVEN,
        FOO\PYGZus{}PIN\PYGZus{}PULLUP,
\PYGZcb{};

static unsigned long i2c\PYGZus{}pin\PYGZus{}configs[] = \PYGZob{}
        FOO\PYGZus{}OPEN\PYGZus{}COLLECTOR,
        FOO\PYGZus{}SLEW\PYGZus{}RATE\PYGZus{}SLOW,
\PYGZcb{};

static struct pinctrl\PYGZus{}map mapping[] \PYGZus{}\PYGZus{}initdata = \PYGZob{}
        PIN\PYGZus{}MAP\PYGZus{}MUX\PYGZus{}GROUP(\PYGZdq{}foo\PYGZhy{}i2c.0\PYGZdq{}, PINCTRL\PYGZus{}STATE\PYGZus{}DEFAULT,
                          \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{}, \PYGZdq{}i2c0\PYGZdq{}, \PYGZdq{}i2c0\PYGZdq{}),
        PIN\PYGZus{}MAP\PYGZus{}CONFIGS\PYGZus{}GROUP(\PYGZdq{}foo\PYGZhy{}i2c.0\PYGZdq{}, PINCTRL\PYGZus{}STATE\PYGZus{}DEFAULT,
                              \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{}, \PYGZdq{}i2c0\PYGZdq{}, i2c\PYGZus{}grp\PYGZus{}configs),
        PIN\PYGZus{}MAP\PYGZus{}CONFIGS\PYGZus{}PIN(\PYGZdq{}foo\PYGZhy{}i2c.0\PYGZdq{}, PINCTRL\PYGZus{}STATE\PYGZus{}DEFAULT,
                            \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{}, \PYGZdq{}i2c0scl\PYGZdq{}, i2c\PYGZus{}pin\PYGZus{}configs),
        PIN\PYGZus{}MAP\PYGZus{}CONFIGS\PYGZus{}PIN(\PYGZdq{}foo\PYGZhy{}i2c.0\PYGZdq{}, PINCTRL\PYGZus{}STATE\PYGZus{}DEFAULT,
                            \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{}, \PYGZdq{}i2c0sda\PYGZdq{}, i2c\PYGZus{}pin\PYGZus{}configs),
\PYGZcb{};
\end{Verbatim}

Finally, some devices expect the mapping table to contain certain specific
named states. When running on hardware that doesn't need any pin controller
configuration, the mapping table must still contain those named states, in
order to explicitly indicate that the states were provided and intended to
be empty. Table entry macro PIN\_MAP\_DUMMY\_STATE serves the purpose of defining
a named state without causing any pin controller to be programmed:

\begin{Verbatim}[commandchars=\\\{\}]
static struct pinctrl\PYGZus{}map mapping[] \PYGZus{}\PYGZus{}initdata = \PYGZob{}
        PIN\PYGZus{}MAP\PYGZus{}DUMMY\PYGZus{}STATE(\PYGZdq{}foo\PYGZhy{}i2c.0\PYGZdq{}, PINCTRL\PYGZus{}STATE\PYGZus{}DEFAULT),
\PYGZcb{};
\end{Verbatim}


\section{Complex mappings}
\label{driver-api/pinctl:complex-mappings}
As it is possible to map a function to different groups of pins an optional
.group can be specified like this:

\begin{Verbatim}[commandchars=\\\{\}]
...
\PYGZob{}
        .dev\PYGZus{}name = \PYGZdq{}foo\PYGZhy{}spi.0\PYGZdq{},
        .name = \PYGZdq{}spi0\PYGZhy{}pos\PYGZhy{}A\PYGZdq{},
        .type = PIN\PYGZus{}MAP\PYGZus{}TYPE\PYGZus{}MUX\PYGZus{}GROUP,
        .ctrl\PYGZus{}dev\PYGZus{}name = \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{},
        .function = \PYGZdq{}spi0\PYGZdq{},
        .group = \PYGZdq{}spi0\PYGZus{}0\PYGZus{}grp\PYGZdq{},
\PYGZcb{},
\PYGZob{}
        .dev\PYGZus{}name = \PYGZdq{}foo\PYGZhy{}spi.0\PYGZdq{},
        .name = \PYGZdq{}spi0\PYGZhy{}pos\PYGZhy{}B\PYGZdq{},
        .type = PIN\PYGZus{}MAP\PYGZus{}TYPE\PYGZus{}MUX\PYGZus{}GROUP,
        .ctrl\PYGZus{}dev\PYGZus{}name = \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{},
        .function = \PYGZdq{}spi0\PYGZdq{},
        .group = \PYGZdq{}spi0\PYGZus{}1\PYGZus{}grp\PYGZdq{},
\PYGZcb{},
...
\end{Verbatim}

This example mapping is used to switch between two positions for spi0 at
runtime, as described further below under the heading ``Runtime pinmuxing''.

Further it is possible for one named state to affect the muxing of several
groups of pins, say for example in the mmc0 example above, where you can
additively expand the mmc0 bus from 2 to 4 to 8 pins. If we want to use all
three groups for a total of 2+2+4 = 8 pins (for an 8-bit MMC bus as is the
case), we define a mapping like this:

\begin{Verbatim}[commandchars=\\\{\}]
...
\PYGZob{}
        .dev\PYGZus{}name = \PYGZdq{}foo\PYGZhy{}mmc.0\PYGZdq{},
        .name = \PYGZdq{}2bit\PYGZdq{}
        .type = PIN\PYGZus{}MAP\PYGZus{}TYPE\PYGZus{}MUX\PYGZus{}GROUP,
        .ctrl\PYGZus{}dev\PYGZus{}name = \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{},
        .function = \PYGZdq{}mmc0\PYGZdq{},
        .group = \PYGZdq{}mmc0\PYGZus{}1\PYGZus{}grp\PYGZdq{},
\PYGZcb{},
\PYGZob{}
        .dev\PYGZus{}name = \PYGZdq{}foo\PYGZhy{}mmc.0\PYGZdq{},
        .name = \PYGZdq{}4bit\PYGZdq{}
        .type = PIN\PYGZus{}MAP\PYGZus{}TYPE\PYGZus{}MUX\PYGZus{}GROUP,
        .ctrl\PYGZus{}dev\PYGZus{}name = \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{},
        .function = \PYGZdq{}mmc0\PYGZdq{},
        .group = \PYGZdq{}mmc0\PYGZus{}1\PYGZus{}grp\PYGZdq{},
\PYGZcb{},
\PYGZob{}
        .dev\PYGZus{}name = \PYGZdq{}foo\PYGZhy{}mmc.0\PYGZdq{},
        .name = \PYGZdq{}4bit\PYGZdq{}
        .type = PIN\PYGZus{}MAP\PYGZus{}TYPE\PYGZus{}MUX\PYGZus{}GROUP,
        .ctrl\PYGZus{}dev\PYGZus{}name = \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{},
        .function = \PYGZdq{}mmc0\PYGZdq{},
        .group = \PYGZdq{}mmc0\PYGZus{}2\PYGZus{}grp\PYGZdq{},
\PYGZcb{},
\PYGZob{}
        .dev\PYGZus{}name = \PYGZdq{}foo\PYGZhy{}mmc.0\PYGZdq{},
        .name = \PYGZdq{}8bit\PYGZdq{}
        .type = PIN\PYGZus{}MAP\PYGZus{}TYPE\PYGZus{}MUX\PYGZus{}GROUP,
        .ctrl\PYGZus{}dev\PYGZus{}name = \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{},
        .function = \PYGZdq{}mmc0\PYGZdq{},
        .group = \PYGZdq{}mmc0\PYGZus{}1\PYGZus{}grp\PYGZdq{},
\PYGZcb{},
\PYGZob{}
        .dev\PYGZus{}name = \PYGZdq{}foo\PYGZhy{}mmc.0\PYGZdq{},
        .name = \PYGZdq{}8bit\PYGZdq{}
        .type = PIN\PYGZus{}MAP\PYGZus{}TYPE\PYGZus{}MUX\PYGZus{}GROUP,
        .ctrl\PYGZus{}dev\PYGZus{}name = \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{},
        .function = \PYGZdq{}mmc0\PYGZdq{},
        .group = \PYGZdq{}mmc0\PYGZus{}2\PYGZus{}grp\PYGZdq{},
\PYGZcb{},
\PYGZob{}
        .dev\PYGZus{}name = \PYGZdq{}foo\PYGZhy{}mmc.0\PYGZdq{},
        .name = \PYGZdq{}8bit\PYGZdq{}
        .type = PIN\PYGZus{}MAP\PYGZus{}TYPE\PYGZus{}MUX\PYGZus{}GROUP,
        .ctrl\PYGZus{}dev\PYGZus{}name = \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{},
        .function = \PYGZdq{}mmc0\PYGZdq{},
        .group = \PYGZdq{}mmc0\PYGZus{}3\PYGZus{}grp\PYGZdq{},
\PYGZcb{},
...
\end{Verbatim}

The result of grabbing this mapping from the device with something like
this (see next paragraph):

\begin{Verbatim}[commandchars=\\\{\}]
p = devm\PYGZus{}pinctrl\PYGZus{}get(dev);
s = pinctrl\PYGZus{}lookup\PYGZus{}state(p, \PYGZdq{}8bit\PYGZdq{});
ret = pinctrl\PYGZus{}select\PYGZus{}state(p, s);
\end{Verbatim}

or more simply:

\begin{Verbatim}[commandchars=\\\{\}]
p = devm\PYGZus{}pinctrl\PYGZus{}get\PYGZus{}select(dev, \PYGZdq{}8bit\PYGZdq{});
\end{Verbatim}

Will be that you activate all the three bottom records in the mapping at
once. Since they share the same name, pin controller device, function and
device, and since we allow multiple groups to match to a single device, they
all get selected, and they all get enabled and disable simultaneously by the
pinmux core.


\section{Pin control requests from drivers}
\label{driver-api/pinctl:pin-control-requests-from-drivers}
When a device driver is about to probe the device core will automatically
attempt to issue pinctrl\_get\_select\_default() on these devices.
This way driver writers do not need to add any of the boilerplate code
of the type found below. However when doing fine-grained state selection
and not using the ``default'' state, you may have to do some device driver
handling of the pinctrl handles and states.

So if you just want to put the pins for a certain device into the default
state and be done with it, there is nothing you need to do besides
providing the proper mapping table. The device core will take care of
the rest.

Generally it is discouraged to let individual drivers get and enable pin
control. So if possible, handle the pin control in platform code or some other
place where you have access to all the affected struct device * pointers. In
some cases where a driver needs to e.g. switch between different mux mappings
at runtime this is not possible.

A typical case is if a driver needs to switch bias of pins from normal
operation and going to sleep, moving from the PINCTRL\_STATE\_DEFAULT to
PINCTRL\_STATE\_SLEEP at runtime, re-biasing or even re-muxing pins to save
current in sleep mode.

A driver may request a certain control state to be activated, usually just the
default state like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}linux/pinctrl/consumer.h\PYGZgt{}

struct foo\PYGZus{}state \PYGZob{}
struct pinctrl *p;
struct pinctrl\PYGZus{}state *s;
...
\PYGZcb{};

foo\PYGZus{}probe()
\PYGZob{}
        /* Allocate a state holder named \PYGZdq{}foo\PYGZdq{} etc */
        struct foo\PYGZus{}state *foo = ...;

        foo\PYGZhy{}\PYGZgt{}p = devm\PYGZus{}pinctrl\PYGZus{}get(\PYGZam{}device);
        if (IS\PYGZus{}ERR(foo\PYGZhy{}\PYGZgt{}p)) \PYGZob{}
                /* FIXME: clean up \PYGZdq{}foo\PYGZdq{} here */
                return PTR\PYGZus{}ERR(foo\PYGZhy{}\PYGZgt{}p);
        \PYGZcb{}

        foo\PYGZhy{}\PYGZgt{}s = pinctrl\PYGZus{}lookup\PYGZus{}state(foo\PYGZhy{}\PYGZgt{}p, PINCTRL\PYGZus{}STATE\PYGZus{}DEFAULT);
        if (IS\PYGZus{}ERR(foo\PYGZhy{}\PYGZgt{}s)) \PYGZob{}
                /* FIXME: clean up \PYGZdq{}foo\PYGZdq{} here */
                return PTR\PYGZus{}ERR(s);
        \PYGZcb{}

        ret = pinctrl\PYGZus{}select\PYGZus{}state(foo\PYGZhy{}\PYGZgt{}s);
        if (ret \PYGZlt{} 0) \PYGZob{}
                /* FIXME: clean up \PYGZdq{}foo\PYGZdq{} here */
                return ret;
        \PYGZcb{}
\PYGZcb{}
\end{Verbatim}

This get/lookup/select/put sequence can just as well be handled by bus drivers
if you don't want each and every driver to handle it and you know the
arrangement on your bus.

The semantics of the pinctrl APIs are:
\begin{itemize}
\item {} 
pinctrl\_get() is called in process context to obtain a handle to all pinctrl
information for a given client device. It will allocate a struct from the
kernel memory to hold the pinmux state. All mapping table parsing or similar
slow operations take place within this API.

\item {} 
devm\_pinctrl\_get() is a variant of pinctrl\_get() that causes pinctrl\_put()
to be called automatically on the retrieved pointer when the associated
device is removed. It is recommended to use this function over plain
pinctrl\_get().

\item {} 
pinctrl\_lookup\_state() is called in process context to obtain a handle to a
specific state for a client device. This operation may be slow, too.

\item {} 
pinctrl\_select\_state() programs pin controller hardware according to the
definition of the state as given by the mapping table. In theory, this is a
fast-path operation, since it only involved blasting some register settings
into hardware. However, note that some pin controllers may have their
registers on a slow/IRQ-based bus, so client devices should not assume they
can call pinctrl\_select\_state() from non-blocking contexts.

\item {} 
pinctrl\_put() frees all information associated with a pinctrl handle.

\item {} 
devm\_pinctrl\_put() is a variant of pinctrl\_put() that may be used to
explicitly destroy a pinctrl object returned by devm\_pinctrl\_get().
However, use of this function will be rare, due to the automatic cleanup
that will occur even without calling it.

pinctrl\_get() must be paired with a plain pinctrl\_put().
pinctrl\_get() may not be paired with devm\_pinctrl\_put().
devm\_pinctrl\_get() can optionally be paired with devm\_pinctrl\_put().
devm\_pinctrl\_get() may not be paired with plain pinctrl\_put().

\end{itemize}

Usually the pin control core handled the get/put pair and call out to the
device drivers bookkeeping operations, like checking available functions and
the associated pins, whereas select\_state pass on to the pin controller
driver which takes care of activating and/or deactivating the mux setting by
quickly poking some registers.

The pins are allocated for your device when you issue the devm\_pinctrl\_get()
call, after this you should be able to see this in the debugfs listing of all
pins.

NOTE: the pinctrl system will return -EPROBE\_DEFER if it cannot find the
requested pinctrl handles, for example if the pinctrl driver has not yet
registered. Thus make sure that the error path in your driver gracefully
cleans up and is ready to retry the probing later in the startup process.


\section{Drivers needing both pin control and GPIOs}
\label{driver-api/pinctl:drivers-needing-both-pin-control-and-gpios}
Again, it is discouraged to let drivers lookup and select pin control states
themselves, but again sometimes this is unavoidable.

So say that your driver is fetching its resources like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}linux/pinctrl/consumer.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}linux/gpio.h\PYGZgt{}

struct pinctrl *pinctrl;
int gpio;

pinctrl = devm\PYGZus{}pinctrl\PYGZus{}get\PYGZus{}select\PYGZus{}default(\PYGZam{}dev);
gpio = devm\PYGZus{}gpio\PYGZus{}request(\PYGZam{}dev, 14, \PYGZdq{}foo\PYGZdq{});
\end{Verbatim}

Here we first request a certain pin state and then request GPIO 14 to be
used. If you're using the subsystems orthogonally like this, you should
nominally always get your pinctrl handle and select the desired pinctrl
state BEFORE requesting the GPIO. This is a semantic convention to avoid
situations that can be electrically unpleasant, you will certainly want to
mux in and bias pins in a certain way before the GPIO subsystems starts to
deal with them.

The above can be hidden: using the device core, the pinctrl core may be
setting up the config and muxing for the pins right before the device is
probing, nevertheless orthogonal to the GPIO subsystem.

But there are also situations where it makes sense for the GPIO subsystem
to communicate directly with the pinctrl subsystem, using the latter as a
back-end. This is when the GPIO driver may call out to the functions
described in the section ``Pin control interaction with the GPIO subsystem''
above. This only involves per-pin multiplexing, and will be completely
hidden behind the gpio\_*() function namespace. In this case, the driver
need not interact with the pin control subsystem at all.

If a pin control driver and a GPIO driver is dealing with the same pins
and the use cases involve multiplexing, you MUST implement the pin controller
as a back-end for the GPIO driver like this, unless your hardware design
is such that the GPIO controller can override the pin controller's
multiplexing state through hardware without the need to interact with the
pin control system.


\section{System pin control hogging}
\label{driver-api/pinctl:system-pin-control-hogging}
Pin control map entries can be hogged by the core when the pin controller
is registered. This means that the core will attempt to call pinctrl\_get(),
lookup\_state() and select\_state() on it immediately after the pin control
device has been registered.

This occurs for mapping table entries where the client device name is equal
to the pin controller device name, and the state name is PINCTRL\_STATE\_DEFAULT:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{}
        .dev\PYGZus{}name = \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{},
        .name = PINCTRL\PYGZus{}STATE\PYGZus{}DEFAULT,
        .type = PIN\PYGZus{}MAP\PYGZus{}TYPE\PYGZus{}MUX\PYGZus{}GROUP,
        .ctrl\PYGZus{}dev\PYGZus{}name = \PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{},
        .function = \PYGZdq{}power\PYGZus{}func\PYGZdq{},
\PYGZcb{},
\end{Verbatim}

Since it may be common to request the core to hog a few always-applicable
mux settings on the primary pin controller, there is a convenience macro for
this:

\begin{Verbatim}[commandchars=\\\{\}]
PIN\PYGZus{}MAP\PYGZus{}MUX\PYGZus{}GROUP\PYGZus{}HOG\PYGZus{}DEFAULT(\PYGZdq{}pinctrl\PYGZhy{}foo\PYGZdq{}, NULL /* group */,
                              \PYGZdq{}power\PYGZus{}func\PYGZdq{})
\end{Verbatim}

This gives the exact same result as the above construction.


\section{Runtime pinmuxing}
\label{driver-api/pinctl:runtime-pinmuxing}
It is possible to mux a certain function in and out at runtime, say to move
an SPI port from one set of pins to another set of pins. Say for example for
spi0 in the example above, we expose two different groups of pins for the same
function, but with different named in the mapping as described under
``Advanced mapping'' above. So that for an SPI device, we have two states named
``pos-A'' and ``pos-B''.

This snippet first initializes a state object for both groups (in foo\_probe()),
then muxes the function in the pins defined by group A, and finally muxes it in
on the pins defined by group B:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}linux/pinctrl/consumer.h\PYGZgt{}

struct pinctrl *p;
struct pinctrl\PYGZus{}state *s1, *s2;

foo\PYGZus{}probe()
\PYGZob{}
        /* Setup */
        p = devm\PYGZus{}pinctrl\PYGZus{}get(\PYGZam{}device);
        if (IS\PYGZus{}ERR(p))
                ...

        s1 = pinctrl\PYGZus{}lookup\PYGZus{}state(foo\PYGZhy{}\PYGZgt{}p, \PYGZdq{}pos\PYGZhy{}A\PYGZdq{});
        if (IS\PYGZus{}ERR(s1))
                ...

        s2 = pinctrl\PYGZus{}lookup\PYGZus{}state(foo\PYGZhy{}\PYGZgt{}p, \PYGZdq{}pos\PYGZhy{}B\PYGZdq{});
        if (IS\PYGZus{}ERR(s2))
                ...
\PYGZcb{}

foo\PYGZus{}switch()
\PYGZob{}
        /* Enable on position A */
        ret = pinctrl\PYGZus{}select\PYGZus{}state(s1);
        if (ret \PYGZlt{} 0)
        ...

        ...

        /* Enable on position B */
        ret = pinctrl\PYGZus{}select\PYGZus{}state(s2);
        if (ret \PYGZlt{} 0)
        ...

        ...
\PYGZcb{}
\end{Verbatim}

The above has to be done from process context. The reservation of the pins
will be done when the state is activated, so in effect one specific pin
can be used by different functions at different times on a running system.


\chapter{General Purpose Input/Output (GPIO)}
\label{driver-api/gpio::doc}\label{driver-api/gpio:general-purpose-input-output-gpio}

\section{Core}
\label{driver-api/gpio:core}\index{gpio\_irq\_chip (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpio_irq_chip}\pysigline{struct \bfcode{gpio\_irq\_chip}}
GPIO interrupt controller

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct gpio\PYGZus{}irq\PYGZus{}chip \PYGZob{}
  struct irq\PYGZus{}chip *chip;
  struct irq\PYGZus{}domain *domain;
  const struct irq\PYGZus{}domain\PYGZus{}ops *domain\PYGZus{}ops;
  irq\PYGZus{}flow\PYGZus{}handler\PYGZus{}t handler;
  unsigned int default\PYGZus{}type;
  struct lock\PYGZus{}class\PYGZus{}key *lock\PYGZus{}key;
  struct lock\PYGZus{}class\PYGZus{}key *request\PYGZus{}key;
  irq\PYGZus{}flow\PYGZus{}handler\PYGZus{}t parent\PYGZus{}handler;
  void *parent\PYGZus{}handler\PYGZus{}data;
  unsigned int num\PYGZus{}parents;
  unsigned int *parents;
  unsigned int *map;
  bool threaded;
  bool need\PYGZus{}valid\PYGZus{}mask;
  unsigned long *valid\PYGZus{}mask;
  unsigned int first;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{chip}}] \leavevmode
GPIO IRQ chip implementation, provided by GPIO driver.

\item[{\code{domain}}] \leavevmode
Interrupt translation domain; responsible for mapping between GPIO
hwirq number and Linux IRQ number.

\item[{\code{domain\_ops}}] \leavevmode
Table of interrupt domain operations for this IRQ chip.

\item[{\code{handler}}] \leavevmode
The IRQ handler to use (often a predefined IRQ core function) for
GPIO IRQs, provided by GPIO driver.

\item[{\code{default\_type}}] \leavevmode
Default IRQ triggering type applied during GPIO driver
initialization, provided by GPIO driver.

\item[{\code{lock\_key}}] \leavevmode
Per GPIO IRQ chip lockdep classes.

\item[{\code{parent\_handler}}] \leavevmode
The interrupt handler for the GPIO chip's parent interrupts, may be
NULL if the parent interrupts are nested rather than cascaded.

\item[{\code{parent\_handler\_data}}] \leavevmode
Data associated, and passed to, the handler for the parent
interrupt.

\item[{\code{num\_parents}}] \leavevmode
The number of interrupt parents of a GPIO chip.

\item[{\code{parents}}] \leavevmode
A list of interrupt parents of a GPIO chip. This is owned by the
driver, so the core will only reference this list, not modify it.

\item[{\code{map}}] \leavevmode
A list of interrupt parents for each line of a GPIO chip.

\item[{\code{threaded}}] \leavevmode
True if set the interrupt handling uses nested threads.

\item[{\code{need\_valid\_mask}}] \leavevmode
If set core allocates \textbf{valid\_mask} with all bits set to one.

\item[{\code{valid\_mask}}] \leavevmode
If not \code{NULL} holds bitmask of GPIOs which are valid to be included
in IRQ domain of the chip.

\item[{\code{first}}] \leavevmode
Required for static IRQ allocation. If set, \code{irq\_domain\_add\_simple()}
will allocate and map all IRQs during initialization.

\end{description}
\index{gpio\_chip (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpio_chip}\pysigline{struct \bfcode{gpio\_chip}}
abstract a GPIO controller

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct gpio\PYGZus{}chip \PYGZob{}
  const char              *label;
  struct gpio\PYGZus{}device      *gpiodev;
  struct device           *parent;
  struct module           *owner;
  int (*request)(struct gpio\PYGZus{}chip *chip, unsigned offset);
  void (*free)(struct gpio\PYGZus{}chip *chip, unsigned offset);
  int (*get\PYGZus{}direction)(struct gpio\PYGZus{}chip *chip, unsigned offset);
  int (*direction\PYGZus{}input)(struct gpio\PYGZus{}chip *chip, unsigned offset);
  int (*direction\PYGZus{}output)(struct gpio\PYGZus{}chip *chip, unsigned offset, int value);
  int (*get)(struct gpio\PYGZus{}chip *chip, unsigned offset);
  int (*get\PYGZus{}multiple)(struct gpio\PYGZus{}chip *chip,unsigned long *mask, unsigned long *bits);
  void (*set)(struct gpio\PYGZus{}chip *chip, unsigned offset, int value);
  void (*set\PYGZus{}multiple)(struct gpio\PYGZus{}chip *chip,unsigned long *mask, unsigned long *bits);
  int (*set\PYGZus{}config)(struct gpio\PYGZus{}chip *chip,unsigned offset, unsigned long config);
  int (*to\PYGZus{}irq)(struct gpio\PYGZus{}chip *chip, unsigned offset);
  void (*dbg\PYGZus{}show)(struct seq\PYGZus{}file *s, struct gpio\PYGZus{}chip *chip);
  int base;
  u16 ngpio;
  const char              *const *names;
  bool can\PYGZus{}sleep;
\PYGZsh{}if IS\PYGZus{}ENABLED(CONFIG\PYGZus{}GPIO\PYGZus{}GENERIC);
  unsigned long (*read\PYGZus{}reg)(void \PYGZus{}\PYGZus{}iomem *reg);
  void (*write\PYGZus{}reg)(void \PYGZus{}\PYGZus{}iomem *reg, unsigned long data);
  bool be\PYGZus{}bits;
  void \PYGZus{}\PYGZus{}iomem *reg\PYGZus{}dat;
  void \PYGZus{}\PYGZus{}iomem *reg\PYGZus{}set;
  void \PYGZus{}\PYGZus{}iomem *reg\PYGZus{}clr;
  void \PYGZus{}\PYGZus{}iomem *reg\PYGZus{}dir;
  int bgpio\PYGZus{}bits;
  spinlock\PYGZus{}t bgpio\PYGZus{}lock;
  unsigned long bgpio\PYGZus{}data;
  unsigned long bgpio\PYGZus{}dir;
\PYGZsh{}endif;
\PYGZsh{}ifdef CONFIG\PYGZus{}GPIOLIB\PYGZus{}IRQCHIP;
  struct gpio\PYGZus{}irq\PYGZus{}chip irq;
\PYGZsh{}endif;
\PYGZsh{}if defined(CONFIG\PYGZus{}OF\PYGZus{}GPIO);
  struct device\PYGZus{}node *of\PYGZus{}node;
  unsigned int of\PYGZus{}gpio\PYGZus{}n\PYGZus{}cells;
  int (*of\PYGZus{}xlate)(struct gpio\PYGZus{}chip *gc, const struct of\PYGZus{}phandle\PYGZus{}args *gpiospec, u32 *flags);
\PYGZsh{}endif;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{label}}] \leavevmode
a functional name for the GPIO device, such as a part
number or the name of the SoC IP-block implementing it.

\item[{\code{gpiodev}}] \leavevmode
the internal state holder, opaque struct

\item[{\code{parent}}] \leavevmode
optional parent device providing the GPIOs

\item[{\code{owner}}] \leavevmode
helps prevent removal of modules exporting active GPIOs

\item[{\code{request}}] \leavevmode
optional hook for chip-specific activation, such as
enabling module power and clock; may sleep

\item[{\code{free}}] \leavevmode
optional hook for chip-specific deactivation, such as
disabling module power and clock; may sleep

\item[{\code{get\_direction}}] \leavevmode
returns direction for signal ``offset'', 0=out, 1=in,
(same as GPIOF\_DIR\_XXX), or negative error

\item[{\code{direction\_input}}] \leavevmode
configures signal ``offset'' as input, or returns error

\item[{\code{direction\_output}}] \leavevmode
configures signal ``offset'' as output, or returns error

\item[{\code{get}}] \leavevmode
returns value for signal ``offset'', 0=low, 1=high, or negative error

\item[{\code{get\_multiple}}] \leavevmode
reads values for multiple signals defined by ``mask'' and
stores them in ``bits'', returns 0 on success or negative error

\item[{\code{set}}] \leavevmode
assigns output value for signal ``offset''

\item[{\code{set\_multiple}}] \leavevmode
assigns output values for multiple signals defined by ``mask''

\item[{\code{set\_config}}] \leavevmode
optional hook for all kinds of settings. Uses the same
packed config format as generic pinconf.

\item[{\code{to\_irq}}] \leavevmode
optional hook supporting non-static \code{gpio\_to\_irq()} mappings;
implementation may not sleep

\item[{\code{dbg\_show}}] \leavevmode
optional routine to show contents in debugfs; default code
will be used when this is omitted, but custom code can show extra
state (such as pullup/pulldown configuration).

\item[{\code{base}}] \leavevmode
identifies the first GPIO number handled by this chip;
or, if negative during registration, requests dynamic ID allocation.
DEPRECATION: providing anything non-negative and nailing the base
offset of GPIO chips is deprecated. Please pass -1 as base to
let gpiolib select the chip base in all possible cases. We want to
get rid of the static GPIO number space in the long run.

\item[{\code{ngpio}}] \leavevmode
the number of GPIOs handled by this controller; the last GPIO
handled is (base + ngpio - 1).

\item[{\code{names}}] \leavevmode
if set, must be an array of strings to use as alternative
names for the GPIOs in this chip. Any entry in the array
may be NULL if there is no alias for the GPIO, however the
array must be \textbf{ngpio} entries long.  A name can include a single printk
format specifier for an unsigned int.  It is substituted by the actual
number of the gpio.

\item[{\code{can\_sleep}}] \leavevmode
flag must be set iff \code{get()}/\code{set()} methods sleep, as they
must while accessing GPIO expander chips over I2C or SPI. This
implies that if the chip supports IRQs, these IRQs need to be threaded
as the chip access may sleep when e.g. reading out the IRQ status
registers.

\item[{\code{read\_reg}}] \leavevmode
reader function for generic GPIO

\item[{\code{write\_reg}}] \leavevmode
writer function for generic GPIO

\item[{\code{be\_bits}}] \leavevmode
if the generic GPIO has big endian bit order (bit 31 is representing
line 0, bit 30 is line 1 ... bit 0 is line 31) this is set to true by the
generic GPIO core. It is for internal housekeeping only.

\item[{\code{reg\_dat}}] \leavevmode
data (in) register for generic GPIO

\item[{\code{reg\_set}}] \leavevmode
output set register (out=high) for generic GPIO

\item[{\code{reg\_clr}}] \leavevmode
output clear register (out=low) for generic GPIO

\item[{\code{reg\_dir}}] \leavevmode
direction setting register for generic GPIO

\item[{\code{bgpio\_bits}}] \leavevmode
number of register bits used for a generic GPIO i.e.
\textless{}register width\textgreater{} * 8

\item[{\code{bgpio\_lock}}] \leavevmode
used to lock chip-\textgreater{}bgpio\_data. Also, this is needed to keep
shadowed and real data registers writes together.

\item[{\code{bgpio\_data}}] \leavevmode
shadowed data register for generic GPIO to clear/set bits
safely.

\item[{\code{bgpio\_dir}}] \leavevmode
shadowed direction register for generic GPIO to clear/set
direction safely.

\item[{\code{irq}}] \leavevmode
Integrates interrupt chip functionality with the GPIO chip. Can be
used to handle IRQs for most practical cases.

\item[{\code{of\_node}}] \leavevmode
Pointer to a device tree node representing this GPIO controller.

\item[{\code{of\_gpio\_n\_cells}}] \leavevmode
Number of cells used to form the GPIO specifier.

\item[{\code{of\_xlate}}] \leavevmode
Callback to translate a device tree GPIO specifier into a chip-
relative GPIO number and flags.

\end{description}

\textbf{Description}

A gpio\_chip can help platforms abstract various sources of GPIOs so
they can all be accessed through a common programing interface.
Example sources would be SOC controllers, FPGAs, multifunction
chips, dedicated GPIO expanders, and so on.

Each chip controls a number of signals, identified in method calls
by ``offset'' values in the range 0..(\textbf{ngpio} - 1).  When those signals
are referenced through calls like gpio\_get\_value(gpio), the offset
is calculated by subtracting \textbf{base} from the gpio number.
\index{gpiochip\_add\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_add_data}\pysiglinewithargsret{\bfcode{gpiochip\_add\_data}}{\emph{chip}, \emph{data}}{}
register a gpio\_chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{chip}}] \leavevmode
the chip to register, with chip-\textgreater{}base initialized

\item[{\code{data}}] \leavevmode
driver-private data associated with this chip

\end{description}

\textbf{Context}

potentially before irqs will work

\textbf{Description}

When {\hyperref[driver\string-api/gpio:c.gpiochip_add_data]{\emph{\code{gpiochip\_add\_data()}}}} is called very early during boot, so that GPIOs
can be freely used, the chip-\textgreater{}parent device must be registered before
the gpio framework's \code{arch\_initcall()}.  Otherwise sysfs initialization
for GPIOs will fail rudely.

{\hyperref[driver\string-api/gpio:c.gpiochip_add_data]{\emph{\code{gpiochip\_add\_data()}}}} must only be called after gpiolib initialization,
ie after \code{core\_initcall()}.

If chip-\textgreater{}base is negative, this requests dynamic assignment of
a range of valid GPIOs.

\textbf{Return}

A negative errno if the chip can't be registered, such as because the
chip-\textgreater{}base is invalid or already associated with a different chip.
Otherwise it returns zero as a success code.
\index{gpio\_pin\_range (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpio_pin_range}\pysigline{struct \bfcode{gpio\_pin\_range}}
pin range controlled by a gpio chip

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct gpio\PYGZus{}pin\PYGZus{}range \PYGZob{}
  struct list\PYGZus{}head node;
  struct pinctrl\PYGZus{}dev *pctldev;
  struct pinctrl\PYGZus{}gpio\PYGZus{}range range;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{node}}] \leavevmode
list for maintaining set of pin ranges, used internally

\item[{\code{pctldev}}] \leavevmode
pinctrl device which handles corresponding pins

\item[{\code{range}}] \leavevmode
actual range of pins controlled by a gpio controller

\end{description}
\index{gpio\_to\_desc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpio_to_desc}\pysiglinewithargsret{struct gpio\_desc * \bfcode{gpio\_to\_desc}}{unsigned\emph{ gpio}}{}
Convert a GPIO number to its descriptor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned gpio}}] \leavevmode
global GPIO number

\end{description}

\textbf{Return}

The GPIO descriptor associated with the given GPIO, or \code{NULL} if no GPIO
with the given number exists in the system.
\index{desc\_to\_gpio (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.desc_to_gpio}\pysiglinewithargsret{int \bfcode{desc\_to\_gpio}}{const struct gpio\_desc *\emph{ desc}}{}
convert a GPIO descriptor to the integer namespace

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct gpio\_desc * desc}}] \leavevmode
GPIO descriptor

\end{description}

\textbf{Description}

This should disappear in the future but is needed since we still
use GPIO numbers for error messages and sysfs nodes.

\textbf{Return}

The global GPIO number for the GPIO specified by its descriptor.
\index{gpiod\_to\_chip (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_to_chip}\pysiglinewithargsret{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} * \bfcode{gpiod\_to\_chip}}{const struct gpio\_desc *\emph{ desc}}{}
Return the GPIO chip to which a GPIO descriptor belongs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct gpio\_desc * desc}}] \leavevmode
descriptor to return the chip of

\end{description}
\index{gpiod\_get\_direction (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_get_direction}\pysiglinewithargsret{int \bfcode{gpiod\_get\_direction}}{struct gpio\_desc *\emph{ desc}}{}
return the current direction of a GPIO

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_desc * desc}}] \leavevmode
GPIO to get the direction of

\end{description}

\textbf{Description}

Returns 0 for output, 1 for input, or an error code in case of error.

This function may sleep if {\hyperref[driver\string-api/gpio:c.gpiod_cansleep]{\emph{\code{gpiod\_cansleep()}}}} is true.
\index{gpiochip\_get\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_get_data}\pysiglinewithargsret{void * \bfcode{gpiochip\_get\_data}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ chip}}{}
get per-subdriver data for the chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * chip}}] \leavevmode
GPIO chip

\end{description}

\textbf{Return}

The per-subdriver data for the chip.
\index{gpiochip\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_remove}\pysiglinewithargsret{void \bfcode{gpiochip\_remove}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ chip}}{}
unregister a gpio\_chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * chip}}] \leavevmode
the chip to unregister

\end{description}

\textbf{Description}

A gpio\_chip with any GPIOs still requested may not be removed.
\index{devm\_gpiochip\_add\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.devm_gpiochip_add_data}\pysiglinewithargsret{int \bfcode{devm\_gpiochip\_add\_data}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ chip}, void *\emph{ data}}{}
Resource manager {\hyperref[driver\string-api/gpio:c.gpiochip_add_data]{\emph{\code{gpiochip\_add\_data()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
the device pointer on which irq\_chip belongs to.

\item[{\code{struct gpio\_chip * chip}}] \leavevmode
the chip to register, with chip-\textgreater{}base initialized

\item[{\code{void * data}}] \leavevmode
driver-private data associated with this chip

\end{description}

\textbf{Context}

potentially before irqs will work

\textbf{Description}

The gpio chip automatically be released when the device is unbound.

\textbf{Return}

A negative errno if the chip can't be registered, such as because the
chip-\textgreater{}base is invalid or already associated with a different chip.
Otherwise it returns zero as a success code.
\index{devm\_gpiochip\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.devm_gpiochip_remove}\pysiglinewithargsret{void \bfcode{devm\_gpiochip\_remove}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ chip}}{}
Resource manager of {\hyperref[driver\string-api/gpio:c.gpiochip_remove]{\emph{\code{gpiochip\_remove()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device for which which resource was allocated

\item[{\code{struct gpio\_chip * chip}}] \leavevmode
the chip to remove

\end{description}

\textbf{Description}

A gpio\_chip with any GPIOs still requested may not be removed.
\index{gpiochip\_find (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_find}\pysiglinewithargsret{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} * \bfcode{gpiochip\_find}}{void *\emph{ data}, int (*match) (struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}}\emph{ *chip}, void\emph{ *data}}{}
iterator for locating a specific gpio\_chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * data}}] \leavevmode
data to pass to match function

\item[{\code{int (*)(struct gpio\_chip *chip, void *data) match}}] \leavevmode
Callback function to check gpio\_chip

\end{description}

\textbf{Description}

Similar to bus\_find\_device.  It returns a reference to a gpio\_chip as
determined by a user supplied \textbf{match} callback.  The callback should return
0 if the device doesn't match and non-zero if it does.  If the callback is
non-zero, this function will return to the caller and not iterate over any
more gpio\_chips.
\index{gpiochip\_set\_chained\_irqchip (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_set_chained_irqchip}\pysiglinewithargsret{void \bfcode{gpiochip\_set\_chained\_irqchip}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ gpiochip}, struct irq\_chip *\emph{ irqchip}, unsigned int\emph{ parent\_irq}, irq\_flow\_handler\_t\emph{ parent\_handler}}{}
connects a chained irqchip to a gpiochip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * gpiochip}}] \leavevmode
the gpiochip to set the irqchip chain to

\item[{\code{struct irq\_chip * irqchip}}] \leavevmode
the irqchip to chain to the gpiochip

\item[{\code{unsigned int parent\_irq}}] \leavevmode
the irq number corresponding to the parent IRQ for this
chained irqchip

\item[{\code{irq\_flow\_handler\_t parent\_handler}}] \leavevmode
the parent interrupt handler for the accumulated IRQ
coming out of the gpiochip. If the interrupt is nested rather than
cascaded, pass NULL in this handler argument

\end{description}
\index{gpiochip\_set\_nested\_irqchip (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_set_nested_irqchip}\pysiglinewithargsret{void \bfcode{gpiochip\_set\_nested\_irqchip}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ gpiochip}, struct irq\_chip *\emph{ irqchip}, unsigned int\emph{ parent\_irq}}{}
connects a nested irqchip to a gpiochip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * gpiochip}}] \leavevmode
the gpiochip to set the irqchip nested handler to

\item[{\code{struct irq\_chip * irqchip}}] \leavevmode
the irqchip to nest to the gpiochip

\item[{\code{unsigned int parent\_irq}}] \leavevmode
the irq number corresponding to the parent IRQ for this
nested irqchip

\end{description}
\index{gpiochip\_irq\_map (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_irq_map}\pysiglinewithargsret{int \bfcode{gpiochip\_irq\_map}}{struct irq\_domain *\emph{ d}, unsigned int\emph{ irq}, irq\_hw\_number\_t\emph{ hwirq}}{}
maps an IRQ into a GPIO irqchip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct irq\_domain * d}}] \leavevmode
the irqdomain used by this irqchip

\item[{\code{unsigned int irq}}] \leavevmode
the global irq number used by this GPIO irqchip irq

\item[{\code{irq\_hw\_number\_t hwirq}}] \leavevmode
the local IRQ/GPIO line offset on this gpiochip

\end{description}

\textbf{Description}

This function will set up the mapping for a certain IRQ line on a
gpiochip by assigning the gpiochip as chip data, and using the irqchip
stored inside the gpiochip.
\index{gpiochip\_irqchip\_add\_key (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_irqchip_add_key}\pysiglinewithargsret{int \bfcode{gpiochip\_irqchip\_add\_key}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ gpiochip}, struct irq\_chip *\emph{ irqchip}, unsigned int\emph{ first\_irq}, irq\_flow\_handler\_t\emph{ handler}, unsigned int\emph{ type}, bool\emph{ threaded}, struct lock\_class\_key *\emph{ lock\_key}, struct lock\_class\_key *\emph{ request\_key}}{}
adds an irqchip to a gpiochip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * gpiochip}}] \leavevmode
the gpiochip to add the irqchip to

\item[{\code{struct irq\_chip * irqchip}}] \leavevmode
the irqchip to add to the gpiochip

\item[{\code{unsigned int first\_irq}}] \leavevmode
if not dynamically assigned, the base (first) IRQ to
allocate gpiochip irqs from

\item[{\code{irq\_flow\_handler\_t handler}}] \leavevmode
the irq handler to use (often a predefined irq core function)

\item[{\code{unsigned int type}}] \leavevmode
the default type for IRQs on this irqchip, pass IRQ\_TYPE\_NONE
to have the core avoid setting up any default type in the hardware.

\item[{\code{bool threaded}}] \leavevmode
whether this irqchip uses a nested thread handler

\item[{\code{struct lock\_class\_key * lock\_key}}] \leavevmode
lockdep class for IRQ lock

\item[{\code{struct lock\_class\_key * request\_key}}] \leavevmode
lockdep class for IRQ request

\end{description}

\textbf{Description}

This function closely associates a certain irqchip with a certain
gpiochip, providing an irq domain to translate the local IRQs to
global irqs in the gpiolib core, and making sure that the gpiochip
is passed as chip data to all related functions. Driver callbacks
need to use {\hyperref[driver\string-api/gpio:c.gpiochip_get_data]{\emph{\code{gpiochip\_get\_data()}}}} to get their local state containers back
from the gpiochip passed as chip data. An irqdomain will be stored
in the gpiochip that shall be used by the driver to handle IRQ number
translation. The gpiochip will need to be initialized and registered
before calling this function.

This function will handle two cell:ed simple IRQs and assumes all
the pins on the gpiochip can generate a unique IRQ. Everything else
need to be open coded.
\index{gpiochip\_generic\_request (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_generic_request}\pysiglinewithargsret{int \bfcode{gpiochip\_generic\_request}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ chip}, unsigned\emph{ offset}}{}
request the gpio function for a pin

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * chip}}] \leavevmode
the gpiochip owning the GPIO

\item[{\code{unsigned offset}}] \leavevmode
the offset of the GPIO to request for GPIO function

\end{description}
\index{gpiochip\_generic\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_generic_free}\pysiglinewithargsret{void \bfcode{gpiochip\_generic\_free}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ chip}, unsigned\emph{ offset}}{}
free the gpio function from a pin

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * chip}}] \leavevmode
the gpiochip to request the gpio function for

\item[{\code{unsigned offset}}] \leavevmode
the offset of the GPIO to free from GPIO function

\end{description}
\index{gpiochip\_generic\_config (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_generic_config}\pysiglinewithargsret{int \bfcode{gpiochip\_generic\_config}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ chip}, unsigned\emph{ offset}, unsigned long\emph{ config}}{}
apply configuration for a pin

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * chip}}] \leavevmode
the gpiochip owning the GPIO

\item[{\code{unsigned offset}}] \leavevmode
the offset of the GPIO to apply the configuration

\item[{\code{unsigned long config}}] \leavevmode
the configuration to be applied

\end{description}
\index{gpiochip\_add\_pingroup\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_add_pingroup_range}\pysiglinewithargsret{int \bfcode{gpiochip\_add\_pingroup\_range}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ chip}, struct pinctrl\_dev *\emph{ pctldev}, unsigned int\emph{ gpio\_offset}, const char *\emph{ pin\_group}}{}
add a range for GPIO \textless{}-\textgreater{} pin mapping

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * chip}}] \leavevmode
the gpiochip to add the range for

\item[{\code{struct pinctrl\_dev * pctldev}}] \leavevmode
the pin controller to map to

\item[{\code{unsigned int gpio\_offset}}] \leavevmode
the start offset in the current gpio\_chip number space

\item[{\code{const char * pin\_group}}] \leavevmode
name of the pin group inside the pin controller

\end{description}
\index{gpiochip\_add\_pin\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_add_pin_range}\pysiglinewithargsret{int \bfcode{gpiochip\_add\_pin\_range}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ chip}, const char *\emph{ pinctl\_name}, unsigned int\emph{ gpio\_offset}, unsigned int\emph{ pin\_offset}, unsigned int\emph{ npins}}{}
add a range for GPIO \textless{}-\textgreater{} pin mapping

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * chip}}] \leavevmode
the gpiochip to add the range for

\item[{\code{const char * pinctl\_name}}] \leavevmode
the \code{dev\_name()} of the pin controller to map to

\item[{\code{unsigned int gpio\_offset}}] \leavevmode
the start offset in the current gpio\_chip number space

\item[{\code{unsigned int pin\_offset}}] \leavevmode
the start offset in the pin controller number space

\item[{\code{unsigned int npins}}] \leavevmode
the number of pins from the offset of each pin space (GPIO and
pin controller) to accumulate in this range

\end{description}

\textbf{Return}

0 on success, or a negative error-code on failure.
\index{gpiochip\_remove\_pin\_ranges (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_remove_pin_ranges}\pysiglinewithargsret{void \bfcode{gpiochip\_remove\_pin\_ranges}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ chip}}{}
remove all the GPIO \textless{}-\textgreater{} pin mappings

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * chip}}] \leavevmode
the chip to remove all the mappings for

\end{description}
\index{gpiochip\_is\_requested (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_is_requested}\pysiglinewithargsret{const char * \bfcode{gpiochip\_is\_requested}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ chip}, unsigned\emph{ offset}}{}
return string iff signal was requested

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * chip}}] \leavevmode
controller managing the signal

\item[{\code{unsigned offset}}] \leavevmode
of signal within controller's 0..(ngpio - 1) range

\end{description}

\textbf{Description}

Returns NULL if the GPIO is not currently requested, else a string.
The string returned is the label passed to \code{gpio\_request()}; if none has been
passed it is a meaningless, non-NULL constant.

This function is for use by GPIO controller drivers.  The label can
help with diagnostics, and knowing that the signal is used as a GPIO
can help avoid accidentally multiplexing it to another controller.
\index{gpiochip\_request\_own\_desc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_request_own_desc}\pysiglinewithargsret{struct gpio\_desc * \bfcode{gpiochip\_request\_own\_desc}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ chip}, u16\emph{ hwnum}, const char *\emph{ label}}{}
Allow GPIO chip to request its own descriptor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * chip}}] \leavevmode
GPIO chip

\item[{\code{u16 hwnum}}] \leavevmode
hardware number of the GPIO for which to request the descriptor

\item[{\code{const char * label}}] \leavevmode
label for the GPIO

\end{description}

\textbf{Description}

Function allows GPIO chip drivers to request and use their own GPIO
descriptors via gpiolib API. Difference to \code{gpiod\_request()} is that this
function will not increase reference count of the GPIO chip module. This
allows the GPIO chip module to be unloaded as needed (we assume that the
GPIO chip driver handles freeing the GPIOs it has requested).

\textbf{Return}

A pointer to the GPIO descriptor, or an \code{ERR\_PTR()}-encoded negative error
code on failure.
\index{gpiochip\_free\_own\_desc (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_free_own_desc}\pysiglinewithargsret{void \bfcode{gpiochip\_free\_own\_desc}}{struct gpio\_desc *\emph{ desc}}{}
Free GPIO requested by the chip driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_desc * desc}}] \leavevmode
GPIO descriptor to free

\end{description}

\textbf{Description}

Function frees the given GPIO requested previously with
{\hyperref[driver\string-api/gpio:c.gpiochip_request_own_desc]{\emph{\code{gpiochip\_request\_own\_desc()}}}}.
\index{gpiod\_direction\_input (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_direction_input}\pysiglinewithargsret{int \bfcode{gpiod\_direction\_input}}{struct gpio\_desc *\emph{ desc}}{}
set the GPIO direction to input

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_desc * desc}}] \leavevmode
GPIO to set to input

\end{description}

\textbf{Description}

Set the direction of the passed GPIO to input, such as {\hyperref[driver\string-api/gpio:c.gpiod_get_value]{\emph{\code{gpiod\_get\_value()}}}} can
be called safely on it.

Return 0 in case of success, else an error code.
\index{gpiod\_direction\_output\_raw (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_direction_output_raw}\pysiglinewithargsret{int \bfcode{gpiod\_direction\_output\_raw}}{struct gpio\_desc *\emph{ desc}, int\emph{ value}}{}
set the GPIO direction to output

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_desc * desc}}] \leavevmode
GPIO to set to output

\item[{\code{int value}}] \leavevmode
initial output value of the GPIO

\end{description}

\textbf{Description}

Set the direction of the passed GPIO to output, such as {\hyperref[driver\string-api/gpio:c.gpiod_set_value]{\emph{\code{gpiod\_set\_value()}}}} can
be called safely on it. The initial value of the output must be specified
as raw value on the physical line without regard for the ACTIVE\_LOW status.

Return 0 in case of success, else an error code.
\index{gpiod\_direction\_output (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_direction_output}\pysiglinewithargsret{int \bfcode{gpiod\_direction\_output}}{struct gpio\_desc *\emph{ desc}, int\emph{ value}}{}
set the GPIO direction to output

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_desc * desc}}] \leavevmode
GPIO to set to output

\item[{\code{int value}}] \leavevmode
initial output value of the GPIO

\end{description}

\textbf{Description}

Set the direction of the passed GPIO to output, such as {\hyperref[driver\string-api/gpio:c.gpiod_set_value]{\emph{\code{gpiod\_set\_value()}}}} can
be called safely on it. The initial value of the output must be specified
as the logical value of the GPIO, i.e. taking its ACTIVE\_LOW status into
account.

Return 0 in case of success, else an error code.
\index{gpiod\_set\_debounce (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_set_debounce}\pysiglinewithargsret{int \bfcode{gpiod\_set\_debounce}}{struct gpio\_desc *\emph{ desc}, unsigned\emph{ debounce}}{}
sets \textbf{debounce} time for a GPIO

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_desc * desc}}] \leavevmode
descriptor of the GPIO for which to set debounce time

\item[{\code{unsigned debounce}}] \leavevmode
debounce time in microseconds

\end{description}

\textbf{Return}

0 on success, \code{-ENOTSUPP} if the controller doesn't support setting the
debounce time.
\index{gpiod\_set\_transitory (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_set_transitory}\pysiglinewithargsret{int \bfcode{gpiod\_set\_transitory}}{struct gpio\_desc *\emph{ desc}, bool\emph{ transitory}}{}
Lose or retain GPIO state on suspend or reset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_desc * desc}}] \leavevmode
descriptor of the GPIO for which to configure persistence

\item[{\code{bool transitory}}] \leavevmode
True to lose state on suspend or reset, false for persistence

\end{description}

\textbf{Return}

0 on success, otherwise a negative error code.
\index{gpiod\_is\_active\_low (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_is_active_low}\pysiglinewithargsret{int \bfcode{gpiod\_is\_active\_low}}{const struct gpio\_desc *\emph{ desc}}{}
test whether a GPIO is active-low or not

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct gpio\_desc * desc}}] \leavevmode
the gpio descriptor to test

\end{description}

\textbf{Description}

Returns 1 if the GPIO is active-low, 0 otherwise.
\index{gpiod\_get\_raw\_value (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_get_raw_value}\pysiglinewithargsret{int \bfcode{gpiod\_get\_raw\_value}}{const struct gpio\_desc *\emph{ desc}}{}
return a gpio's raw value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct gpio\_desc * desc}}] \leavevmode
gpio whose value will be returned

\end{description}

\textbf{Description}

Return the GPIO's raw value, i.e. the value of the physical line disregarding
its ACTIVE\_LOW status, or negative errno on failure.

This function should be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.
\index{gpiod\_get\_value (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_get_value}\pysiglinewithargsret{int \bfcode{gpiod\_get\_value}}{const struct gpio\_desc *\emph{ desc}}{}
return a gpio's value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct gpio\_desc * desc}}] \leavevmode
gpio whose value will be returned

\end{description}

\textbf{Description}

Return the GPIO's logical value, i.e. taking the ACTIVE\_LOW status into
account, or negative errno on failure.

This function should be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.
\index{gpiod\_get\_raw\_array\_value (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_get_raw_array_value}\pysiglinewithargsret{int \bfcode{gpiod\_get\_raw\_array\_value}}{unsigned int\emph{ array\_size}, struct gpio\_desc **\emph{ desc\_array}, int *\emph{ value\_array}}{}
read raw values from an array of GPIOs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int array\_size}}] \leavevmode
number of elements in the descriptor / value arrays

\item[{\code{struct gpio\_desc ** desc\_array}}] \leavevmode
array of GPIO descriptors whose values will be read

\item[{\code{int * value\_array}}] \leavevmode
array to store the read values

\end{description}

\textbf{Description}

Read the raw values of the GPIOs, i.e. the values of the physical lines
without regard for their ACTIVE\_LOW status.  Return 0 in case of success,
else an error code.

This function should be called from contexts where we cannot sleep,
and it will complain if the GPIO chip functions potentially sleep.
\index{gpiod\_get\_array\_value (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_get_array_value}\pysiglinewithargsret{int \bfcode{gpiod\_get\_array\_value}}{unsigned int\emph{ array\_size}, struct gpio\_desc **\emph{ desc\_array}, int *\emph{ value\_array}}{}
read values from an array of GPIOs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int array\_size}}] \leavevmode
number of elements in the descriptor / value arrays

\item[{\code{struct gpio\_desc ** desc\_array}}] \leavevmode
array of GPIO descriptors whose values will be read

\item[{\code{int * value\_array}}] \leavevmode
array to store the read values

\end{description}

\textbf{Description}

Read the logical values of the GPIOs, i.e. taking their ACTIVE\_LOW status
into account.  Return 0 in case of success, else an error code.

This function should be called from contexts where we cannot sleep,
and it will complain if the GPIO chip functions potentially sleep.
\index{gpiod\_set\_raw\_value (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_set_raw_value}\pysiglinewithargsret{void \bfcode{gpiod\_set\_raw\_value}}{struct gpio\_desc *\emph{ desc}, int\emph{ value}}{}
assign a gpio's raw value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_desc * desc}}] \leavevmode
gpio whose value will be assigned

\item[{\code{int value}}] \leavevmode
value to assign

\end{description}

\textbf{Description}

Set the raw value of the GPIO, i.e. the value of its physical line without
regard for its ACTIVE\_LOW status.

This function should be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.
\index{gpiod\_set\_value (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_set_value}\pysiglinewithargsret{void \bfcode{gpiod\_set\_value}}{struct gpio\_desc *\emph{ desc}, int\emph{ value}}{}
assign a gpio's value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_desc * desc}}] \leavevmode
gpio whose value will be assigned

\item[{\code{int value}}] \leavevmode
value to assign

\end{description}

\textbf{Description}

Set the logical value of the GPIO, i.e. taking its ACTIVE\_LOW,
OPEN\_DRAIN and OPEN\_SOURCE flags into account.

This function should be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.
\index{gpiod\_set\_raw\_array\_value (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_set_raw_array_value}\pysiglinewithargsret{void \bfcode{gpiod\_set\_raw\_array\_value}}{unsigned int\emph{ array\_size}, struct gpio\_desc **\emph{ desc\_array}, int *\emph{ value\_array}}{}
assign values to an array of GPIOs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int array\_size}}] \leavevmode
number of elements in the descriptor / value arrays

\item[{\code{struct gpio\_desc ** desc\_array}}] \leavevmode
array of GPIO descriptors whose values will be assigned

\item[{\code{int * value\_array}}] \leavevmode
array of values to assign

\end{description}

\textbf{Description}

Set the raw values of the GPIOs, i.e. the values of the physical lines
without regard for their ACTIVE\_LOW status.

This function should be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.
\index{gpiod\_set\_array\_value (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_set_array_value}\pysiglinewithargsret{void \bfcode{gpiod\_set\_array\_value}}{unsigned int\emph{ array\_size}, struct gpio\_desc **\emph{ desc\_array}, int *\emph{ value\_array}}{}
assign values to an array of GPIOs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int array\_size}}] \leavevmode
number of elements in the descriptor / value arrays

\item[{\code{struct gpio\_desc ** desc\_array}}] \leavevmode
array of GPIO descriptors whose values will be assigned

\item[{\code{int * value\_array}}] \leavevmode
array of values to assign

\end{description}

\textbf{Description}

Set the logical values of the GPIOs, i.e. taking their ACTIVE\_LOW status
into account.

This function should be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.
\index{gpiod\_cansleep (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_cansleep}\pysiglinewithargsret{int \bfcode{gpiod\_cansleep}}{const struct gpio\_desc *\emph{ desc}}{}
report whether gpio value access may sleep

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct gpio\_desc * desc}}] \leavevmode
gpio to check

\end{description}
\index{gpiod\_to\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_to_irq}\pysiglinewithargsret{int \bfcode{gpiod\_to\_irq}}{const struct gpio\_desc *\emph{ desc}}{}
return the IRQ corresponding to a GPIO

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct gpio\_desc * desc}}] \leavevmode
gpio whose IRQ will be returned (already requested)

\end{description}

\textbf{Description}

Return the IRQ corresponding to the passed GPIO, or an error code in case of
error.
\index{gpiochip\_lock\_as\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_lock_as_irq}\pysiglinewithargsret{int \bfcode{gpiochip\_lock\_as\_irq}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ chip}, unsigned int\emph{ offset}}{}
lock a GPIO to be used as IRQ

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * chip}}] \leavevmode
the chip the GPIO to lock belongs to

\item[{\code{unsigned int offset}}] \leavevmode
the offset of the GPIO to lock as IRQ

\end{description}

\textbf{Description}

This is used directly by GPIO drivers that want to lock down
a certain GPIO line to be used for IRQs.
\index{gpiochip\_unlock\_as\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiochip_unlock_as_irq}\pysiglinewithargsret{void \bfcode{gpiochip\_unlock\_as\_irq}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ chip}, unsigned int\emph{ offset}}{}
unlock a GPIO used as IRQ

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * chip}}] \leavevmode
the chip the GPIO to lock belongs to

\item[{\code{unsigned int offset}}] \leavevmode
the offset of the GPIO to lock as IRQ

\end{description}

\textbf{Description}

This is used directly by GPIO drivers that want to indicate
that a certain GPIO is no longer used exclusively for IRQ.
\index{gpiod\_get\_raw\_value\_cansleep (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_get_raw_value_cansleep}\pysiglinewithargsret{int \bfcode{gpiod\_get\_raw\_value\_cansleep}}{const struct gpio\_desc *\emph{ desc}}{}
return a gpio's raw value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct gpio\_desc * desc}}] \leavevmode
gpio whose value will be returned

\end{description}

\textbf{Description}

Return the GPIO's raw value, i.e. the value of the physical line disregarding
its ACTIVE\_LOW status, or negative errno on failure.

This function is to be called from contexts that can sleep.
\index{gpiod\_get\_value\_cansleep (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_get_value_cansleep}\pysiglinewithargsret{int \bfcode{gpiod\_get\_value\_cansleep}}{const struct gpio\_desc *\emph{ desc}}{}
return a gpio's value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct gpio\_desc * desc}}] \leavevmode
gpio whose value will be returned

\end{description}

\textbf{Description}

Return the GPIO's logical value, i.e. taking the ACTIVE\_LOW status into
account, or negative errno on failure.

This function is to be called from contexts that can sleep.
\index{gpiod\_get\_raw\_array\_value\_cansleep (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_get_raw_array_value_cansleep}\pysiglinewithargsret{int \bfcode{gpiod\_get\_raw\_array\_value\_cansleep}}{unsigned int\emph{ array\_size}, struct gpio\_desc **\emph{ desc\_array}, int *\emph{ value\_array}}{}
read raw values from an array of GPIOs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int array\_size}}] \leavevmode
number of elements in the descriptor / value arrays

\item[{\code{struct gpio\_desc ** desc\_array}}] \leavevmode
array of GPIO descriptors whose values will be read

\item[{\code{int * value\_array}}] \leavevmode
array to store the read values

\end{description}

\textbf{Description}

Read the raw values of the GPIOs, i.e. the values of the physical lines
without regard for their ACTIVE\_LOW status.  Return 0 in case of success,
else an error code.

This function is to be called from contexts that can sleep.
\index{gpiod\_get\_array\_value\_cansleep (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_get_array_value_cansleep}\pysiglinewithargsret{int \bfcode{gpiod\_get\_array\_value\_cansleep}}{unsigned int\emph{ array\_size}, struct gpio\_desc **\emph{ desc\_array}, int *\emph{ value\_array}}{}
read values from an array of GPIOs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int array\_size}}] \leavevmode
number of elements in the descriptor / value arrays

\item[{\code{struct gpio\_desc ** desc\_array}}] \leavevmode
array of GPIO descriptors whose values will be read

\item[{\code{int * value\_array}}] \leavevmode
array to store the read values

\end{description}

\textbf{Description}

Read the logical values of the GPIOs, i.e. taking their ACTIVE\_LOW status
into account.  Return 0 in case of success, else an error code.

This function is to be called from contexts that can sleep.
\index{gpiod\_set\_raw\_value\_cansleep (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_set_raw_value_cansleep}\pysiglinewithargsret{void \bfcode{gpiod\_set\_raw\_value\_cansleep}}{struct gpio\_desc *\emph{ desc}, int\emph{ value}}{}
assign a gpio's raw value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_desc * desc}}] \leavevmode
gpio whose value will be assigned

\item[{\code{int value}}] \leavevmode
value to assign

\end{description}

\textbf{Description}

Set the raw value of the GPIO, i.e. the value of its physical line without
regard for its ACTIVE\_LOW status.

This function is to be called from contexts that can sleep.
\index{gpiod\_set\_value\_cansleep (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_set_value_cansleep}\pysiglinewithargsret{void \bfcode{gpiod\_set\_value\_cansleep}}{struct gpio\_desc *\emph{ desc}, int\emph{ value}}{}
assign a gpio's value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_desc * desc}}] \leavevmode
gpio whose value will be assigned

\item[{\code{int value}}] \leavevmode
value to assign

\end{description}

\textbf{Description}

Set the logical value of the GPIO, i.e. taking its ACTIVE\_LOW status into
account

This function is to be called from contexts that can sleep.
\index{gpiod\_set\_raw\_array\_value\_cansleep (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_set_raw_array_value_cansleep}\pysiglinewithargsret{void \bfcode{gpiod\_set\_raw\_array\_value\_cansleep}}{unsigned int\emph{ array\_size}, struct gpio\_desc **\emph{ desc\_array}, int *\emph{ value\_array}}{}
assign values to an array of GPIOs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int array\_size}}] \leavevmode
number of elements in the descriptor / value arrays

\item[{\code{struct gpio\_desc ** desc\_array}}] \leavevmode
array of GPIO descriptors whose values will be assigned

\item[{\code{int * value\_array}}] \leavevmode
array of values to assign

\end{description}

\textbf{Description}

Set the raw values of the GPIOs, i.e. the values of the physical lines
without regard for their ACTIVE\_LOW status.

This function is to be called from contexts that can sleep.
\index{gpiod\_set\_array\_value\_cansleep (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_set_array_value_cansleep}\pysiglinewithargsret{void \bfcode{gpiod\_set\_array\_value\_cansleep}}{unsigned int\emph{ array\_size}, struct gpio\_desc **\emph{ desc\_array}, int *\emph{ value\_array}}{}
assign values to an array of GPIOs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int array\_size}}] \leavevmode
number of elements in the descriptor / value arrays

\item[{\code{struct gpio\_desc ** desc\_array}}] \leavevmode
array of GPIO descriptors whose values will be assigned

\item[{\code{int * value\_array}}] \leavevmode
array of values to assign

\end{description}

\textbf{Description}

Set the logical values of the GPIOs, i.e. taking their ACTIVE\_LOW status
into account.

This function is to be called from contexts that can sleep.
\index{gpiod\_add\_lookup\_table (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_add_lookup_table}\pysiglinewithargsret{void \bfcode{gpiod\_add\_lookup\_table}}{struct gpiod\_lookup\_table *\emph{ table}}{}
register GPIO device consumers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpiod\_lookup\_table * table}}] \leavevmode
table of consumers to register

\end{description}
\index{gpiod\_remove\_lookup\_table (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_remove_lookup_table}\pysiglinewithargsret{void \bfcode{gpiod\_remove\_lookup\_table}}{struct gpiod\_lookup\_table *\emph{ table}}{}
unregister GPIO device consumers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpiod\_lookup\_table * table}}] \leavevmode
table of consumers to unregister

\end{description}
\index{gpiod\_count (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_count}\pysiglinewithargsret{int \bfcode{gpiod\_count}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ con\_id}}{}
return the number of GPIOs associated with a device / function or -ENOENT if no GPIO has been assigned to the requested function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
GPIO consumer, can be NULL for system-global GPIOs

\item[{\code{const char * con\_id}}] \leavevmode
function within the GPIO consumer

\end{description}
\index{gpiod\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_get}\pysiglinewithargsret{struct gpio\_desc * \bfcode{gpiod\_get}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ con\_id}, enum gpiod\_flags\emph{ flags}}{}
obtain a GPIO for a given GPIO function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
GPIO consumer, can be NULL for system-global GPIOs

\item[{\code{const char * con\_id}}] \leavevmode
function within the GPIO consumer

\item[{\code{enum gpiod\_flags flags}}] \leavevmode
optional GPIO initialization flags

\end{description}

\textbf{Description}

Return the GPIO descriptor corresponding to the function con\_id of device
dev, -ENOENT if no GPIO has been assigned to the requested function, or
another \code{IS\_ERR()} code if an error occurred while trying to acquire the GPIO.
\index{gpiod\_get\_optional (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_get_optional}\pysiglinewithargsret{struct gpio\_desc * \bfcode{gpiod\_get\_optional}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ con\_id}, enum gpiod\_flags\emph{ flags}}{}
obtain an optional GPIO for a given GPIO function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
GPIO consumer, can be NULL for system-global GPIOs

\item[{\code{const char * con\_id}}] \leavevmode
function within the GPIO consumer

\item[{\code{enum gpiod\_flags flags}}] \leavevmode
optional GPIO initialization flags

\end{description}

\textbf{Description}

This is equivalent to {\hyperref[driver\string-api/gpio:c.gpiod_get]{\emph{\code{gpiod\_get()}}}}, except that when no GPIO was assigned to
the requested function it will return NULL. This is convenient for drivers
that need to handle optional GPIOs.
\index{gpiod\_get\_index (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_get_index}\pysiglinewithargsret{struct gpio\_desc * \bfcode{gpiod\_get\_index}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ con\_id}, unsigned int\emph{ idx}, enum gpiod\_flags\emph{ flags}}{}
obtain a GPIO from a multi-index GPIO function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
GPIO consumer, can be NULL for system-global GPIOs

\item[{\code{const char * con\_id}}] \leavevmode
function within the GPIO consumer

\item[{\code{unsigned int idx}}] \leavevmode
index of the GPIO to obtain in the consumer

\item[{\code{enum gpiod\_flags flags}}] \leavevmode
optional GPIO initialization flags

\end{description}

\textbf{Description}

This variant of {\hyperref[driver\string-api/gpio:c.gpiod_get]{\emph{\code{gpiod\_get()}}}} allows to access GPIOs other than the first
defined one for functions that define several GPIOs.

Return a valid GPIO descriptor, -ENOENT if no GPIO has been assigned to the
requested function and/or index, or another \code{IS\_ERR()} code if an error
occurred while trying to acquire the GPIO.
\index{gpiod\_get\_from\_of\_node (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_get_from_of_node}\pysiglinewithargsret{struct gpio\_desc * \bfcode{gpiod\_get\_from\_of\_node}}{struct device\_node *\emph{ node}, const char *\emph{ propname}, int\emph{ index}, enum gpiod\_flags\emph{ dflags}, const char *\emph{ label}}{}
obtain a GPIO from an OF node

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device\_node * node}}] \leavevmode
handle of the OF node

\item[{\code{const char * propname}}] \leavevmode
name of the DT property representing the GPIO

\item[{\code{int index}}] \leavevmode
index of the GPIO to obtain for the consumer

\item[{\code{enum gpiod\_flags dflags}}] \leavevmode
GPIO initialization flags

\item[{\code{const char * label}}] \leavevmode
label to attach to the requested GPIO

\end{description}

\textbf{Return}

On successful request the GPIO pin is configured in accordance with
provided \textbf{dflags}. If the node does not have the requested GPIO
property, NULL is returned.

In case of error an \code{ERR\_PTR()} is returned.
\index{fwnode\_get\_named\_gpiod (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.fwnode_get_named_gpiod}\pysiglinewithargsret{struct gpio\_desc * \bfcode{fwnode\_get\_named\_gpiod}}{struct fwnode\_handle *\emph{ fwnode}, const char *\emph{ propname}, int\emph{ index}, enum gpiod\_flags\emph{ dflags}, const char *\emph{ label}}{}
obtain a GPIO from firmware node

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fwnode\_handle * fwnode}}] \leavevmode
handle of the firmware node

\item[{\code{const char * propname}}] \leavevmode
name of the firmware property representing the GPIO

\item[{\code{int index}}] \leavevmode
index of the GPIO to obtain for the consumer

\item[{\code{enum gpiod\_flags dflags}}] \leavevmode
GPIO initialization flags

\item[{\code{const char * label}}] \leavevmode
label to attach to the requested GPIO

\end{description}

\textbf{Description}

This function can be used for drivers that get their configuration
from opaque firmware.

The function properly finds the corresponding GPIO using whatever is the
underlying firmware interface and then makes sure that the GPIO
descriptor is requested before it is returned to the caller.

\textbf{Return}

On successful request the GPIO pin is configured in accordance with
provided \textbf{dflags}.

In case of error an \code{ERR\_PTR()} is returned.
\index{gpiod\_get\_index\_optional (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_get_index_optional}\pysiglinewithargsret{struct gpio\_desc * \bfcode{gpiod\_get\_index\_optional}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ con\_id}, unsigned int\emph{ index}, enum gpiod\_flags\emph{ flags}}{}
obtain an optional GPIO from a multi-index GPIO function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
GPIO consumer, can be NULL for system-global GPIOs

\item[{\code{const char * con\_id}}] \leavevmode
function within the GPIO consumer

\item[{\code{unsigned int index}}] \leavevmode
index of the GPIO to obtain in the consumer

\item[{\code{enum gpiod\_flags flags}}] \leavevmode
optional GPIO initialization flags

\end{description}

\textbf{Description}

This is equivalent to {\hyperref[driver\string-api/gpio:c.gpiod_get_index]{\emph{\code{gpiod\_get\_index()}}}}, except that when no GPIO with the
specified index was assigned to the requested function it will return NULL.
This is convenient for drivers that need to handle optional GPIOs.
\index{gpiod\_get\_array (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_get_array}\pysiglinewithargsret{struct gpio\_descs * \bfcode{gpiod\_get\_array}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ con\_id}, enum gpiod\_flags\emph{ flags}}{}
obtain multiple GPIOs from a multi-index GPIO function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
GPIO consumer, can be NULL for system-global GPIOs

\item[{\code{const char * con\_id}}] \leavevmode
function within the GPIO consumer

\item[{\code{enum gpiod\_flags flags}}] \leavevmode
optional GPIO initialization flags

\end{description}

\textbf{Description}

This function acquires all the GPIOs defined under a given function.

Return a struct gpio\_descs containing an array of descriptors, -ENOENT if
no GPIO has been assigned to the requested function, or another \code{IS\_ERR()}
code if an error occurred while trying to acquire the GPIOs.
\index{gpiod\_get\_array\_optional (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_get_array_optional}\pysiglinewithargsret{struct gpio\_descs * \bfcode{gpiod\_get\_array\_optional}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ con\_id}, enum gpiod\_flags\emph{ flags}}{}
obtain multiple GPIOs from a multi-index GPIO function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
GPIO consumer, can be NULL for system-global GPIOs

\item[{\code{const char * con\_id}}] \leavevmode
function within the GPIO consumer

\item[{\code{enum gpiod\_flags flags}}] \leavevmode
optional GPIO initialization flags

\end{description}

\textbf{Description}

This is equivalent to {\hyperref[driver\string-api/gpio:c.gpiod_get_array]{\emph{\code{gpiod\_get\_array()}}}}, except that when no GPIO was
assigned to the requested function it will return NULL.
\index{gpiod\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_put}\pysiglinewithargsret{void \bfcode{gpiod\_put}}{struct gpio\_desc *\emph{ desc}}{}
dispose of a GPIO descriptor

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_desc * desc}}] \leavevmode
GPIO descriptor to dispose of

\end{description}

\textbf{Description}

No descriptor can be used after {\hyperref[driver\string-api/gpio:c.gpiod_put]{\emph{\code{gpiod\_put()}}}} has been called on it.
\index{gpiod\_put\_array (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_put_array}\pysiglinewithargsret{void \bfcode{gpiod\_put\_array}}{struct gpio\_descs *\emph{ descs}}{}
dispose of multiple GPIO descriptors

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_descs * descs}}] \leavevmode
struct gpio\_descs containing an array of descriptors

\end{description}


\section{Legacy API}
\label{driver-api/gpio:legacy-api}
The functions listed in this section are deprecated. The GPIO descriptor based
API described above should be used in new code.
\index{gpio\_request\_one (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpio_request_one}\pysiglinewithargsret{int \bfcode{gpio\_request\_one}}{unsigned\emph{ gpio}, unsigned long\emph{ flags}, const char *\emph{ label}}{}
request a single GPIO with initial configuration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned gpio}}] \leavevmode
the GPIO number

\item[{\code{unsigned long flags}}] \leavevmode
GPIO configuration as specified by GPIOF\_*

\item[{\code{const char * label}}] \leavevmode
a literal description string of this GPIO

\end{description}
\index{gpio\_request\_array (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpio_request_array}\pysiglinewithargsret{int \bfcode{gpio\_request\_array}}{const struct gpio *\emph{ array}, size\_t\emph{ num}}{}
request multiple GPIOs in a single call

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct gpio * array}}] \leavevmode
array of the `struct gpio'

\item[{\code{size\_t num}}] \leavevmode
how many GPIOs in the array

\end{description}
\index{gpio\_free\_array (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpio_free_array}\pysiglinewithargsret{void \bfcode{gpio\_free\_array}}{const struct gpio *\emph{ array}, size\_t\emph{ num}}{}
release multiple GPIOs in a single call

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct gpio * array}}] \leavevmode
array of the `struct gpio'

\item[{\code{size\_t num}}] \leavevmode
how many GPIOs in the array

\end{description}


\section{ACPI support}
\label{driver-api/gpio:acpi-support}\index{acpi\_gpiochip\_request\_interrupts (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.acpi_gpiochip_request_interrupts}\pysiglinewithargsret{void \bfcode{acpi\_gpiochip\_request\_interrupts}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ chip}}{}
Register isr for gpio chip ACPI events

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * chip}}] \leavevmode
GPIO chip

\end{description}

\textbf{Description}

ACPI5 platforms can use GPIO signaled ACPI events. These GPIO interrupts are
handled by ACPI event methods which need to be called from the GPIO
chip's interrupt handler. acpi\_gpiochip\_request\_interrupts finds out which
gpio pins have acpi event methods and assigns interrupt handlers that calls
the acpi event methods for those pins.
\index{acpi\_gpiochip\_free\_interrupts (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.acpi_gpiochip_free_interrupts}\pysiglinewithargsret{void \bfcode{acpi\_gpiochip\_free\_interrupts}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ chip}}{}
Free GPIO ACPI event interrupts.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * chip}}] \leavevmode
GPIO chip

\end{description}

\textbf{Description}

Free interrupts associated with GPIO ACPI event method for the given
GPIO chip.
\index{acpi\_dev\_gpio\_irq\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.acpi_dev_gpio_irq_get}\pysiglinewithargsret{int \bfcode{acpi\_dev\_gpio\_irq\_get}}{struct acpi\_device *\emph{ adev}, int\emph{ index}}{}
Find GpioInt and translate it to Linux IRQ number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct acpi\_device * adev}}] \leavevmode
pointer to a ACPI device to get IRQ from

\item[{\code{int index}}] \leavevmode
index of GpioInt resource (starting from \code{0})

\end{description}

\textbf{Description}

If the device has one or more GpioInt resources, this function can be
used to translate from the GPIO offset in the resource to the Linux IRQ
number.

The function is idempotent, though each time it runs it will configure GPIO
pin direction according to the flags in GpioInt resource.

\textbf{Return}

Linux IRQ number (\textgreater{} \code{0}) on success, negative errno on failure.


\section{Device tree support}
\label{driver-api/gpio:device-tree-support}\index{of\_gpio\_simple\_xlate (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.of_gpio_simple_xlate}\pysiglinewithargsret{int \bfcode{of\_gpio\_simple\_xlate}}{struct {\hyperref[driver\string-api/gpio:c.gpio_chip]{\emph{gpio\_chip}}} *\emph{ gc}, const struct of\_phandle\_args *\emph{ gpiospec}, u32 *\emph{ flags}}{}
translate gpiospec to the GPIO number and flags

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_chip * gc}}] \leavevmode
pointer to the gpio\_chip structure

\item[{\code{const struct of\_phandle\_args * gpiospec}}] \leavevmode
GPIO specifier as found in the device tree

\item[{\code{u32 * flags}}] \leavevmode
a flags pointer to fill in

\end{description}

\textbf{Description}

This is simple translation function, suitable for the most 1:1 mapped
GPIO chips. This function performs only one sanity check: whether GPIO
is less than ngpios (that is specified in the gpio\_chip).
\index{of\_mm\_gpiochip\_add\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.of_mm_gpiochip_add_data}\pysiglinewithargsret{int \bfcode{of\_mm\_gpiochip\_add\_data}}{struct device\_node *\emph{ np}, struct of\_mm\_gpio\_chip *\emph{ mm\_gc}, void *\emph{ data}}{}
Add memory mapped GPIO chip (bank)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device\_node * np}}] \leavevmode
device node of the GPIO chip

\item[{\code{struct of\_mm\_gpio\_chip * mm\_gc}}] \leavevmode
pointer to the of\_mm\_gpio\_chip allocated structure

\item[{\code{void * data}}] \leavevmode
driver data to store in the struct gpio\_chip

\end{description}

\textbf{Description}

To use this function you should allocate and fill mm\_gc with:
\begin{enumerate}
\item {} 
In the gpio\_chip structure:
- all the callbacks
- of\_gpio\_n\_cells
- of\_xlate callback (optional)

\end{enumerate}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
In the of\_mm\_gpio\_chip structure:
- save\_regs callback (optional)

\end{enumerate}

If succeeded, this function will map bank's memory and will
do all necessary work for you. Then you'll able to use .regs
to manage GPIOs from the callbacks.
\index{of\_mm\_gpiochip\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.of_mm_gpiochip_remove}\pysiglinewithargsret{void \bfcode{of\_mm\_gpiochip\_remove}}{struct of\_mm\_gpio\_chip *\emph{ mm\_gc}}{}
Remove memory mapped GPIO chip (bank)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct of\_mm\_gpio\_chip * mm\_gc}}] \leavevmode
pointer to the of\_mm\_gpio\_chip allocated structure

\end{description}


\section{Device-managed API}
\label{driver-api/gpio:device-managed-api}\index{devm\_gpiod\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.devm_gpiod_get}\pysiglinewithargsret{struct gpio\_desc * \bfcode{devm\_gpiod\_get}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ con\_id}, enum gpiod\_flags\emph{ flags}}{}
Resource-managed {\hyperref[driver\string-api/gpio:c.gpiod_get]{\emph{\code{gpiod\_get()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
GPIO consumer

\item[{\code{const char * con\_id}}] \leavevmode
function within the GPIO consumer

\item[{\code{enum gpiod\_flags flags}}] \leavevmode
optional GPIO initialization flags

\end{description}

\textbf{Description}

Managed {\hyperref[driver\string-api/gpio:c.gpiod_get]{\emph{\code{gpiod\_get()}}}}. GPIO descriptors returned from this function are
automatically disposed on driver detach. See {\hyperref[driver\string-api/gpio:c.gpiod_get]{\emph{\code{gpiod\_get()}}}} for detailed
information about behavior and return values.
\index{devm\_gpiod\_get\_optional (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.devm_gpiod_get_optional}\pysiglinewithargsret{struct gpio\_desc * \bfcode{devm\_gpiod\_get\_optional}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ con\_id}, enum gpiod\_flags\emph{ flags}}{}
Resource-managed {\hyperref[driver\string-api/gpio:c.gpiod_get_optional]{\emph{\code{gpiod\_get\_optional()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
GPIO consumer

\item[{\code{const char * con\_id}}] \leavevmode
function within the GPIO consumer

\item[{\code{enum gpiod\_flags flags}}] \leavevmode
optional GPIO initialization flags

\end{description}

\textbf{Description}

Managed {\hyperref[driver\string-api/gpio:c.gpiod_get_optional]{\emph{\code{gpiod\_get\_optional()}}}}. GPIO descriptors returned from this function
are automatically disposed on driver detach. See {\hyperref[driver\string-api/gpio:c.gpiod_get_optional]{\emph{\code{gpiod\_get\_optional()}}}} for
detailed information about behavior and return values.
\index{devm\_gpiod\_get\_index (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.devm_gpiod_get_index}\pysiglinewithargsret{struct gpio\_desc * \bfcode{devm\_gpiod\_get\_index}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ con\_id}, unsigned int\emph{ idx}, enum gpiod\_flags\emph{ flags}}{}
Resource-managed {\hyperref[driver\string-api/gpio:c.gpiod_get_index]{\emph{\code{gpiod\_get\_index()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
GPIO consumer

\item[{\code{const char * con\_id}}] \leavevmode
function within the GPIO consumer

\item[{\code{unsigned int idx}}] \leavevmode
index of the GPIO to obtain in the consumer

\item[{\code{enum gpiod\_flags flags}}] \leavevmode
optional GPIO initialization flags

\end{description}

\textbf{Description}

Managed {\hyperref[driver\string-api/gpio:c.gpiod_get_index]{\emph{\code{gpiod\_get\_index()}}}}. GPIO descriptors returned from this function are
automatically disposed on driver detach. See {\hyperref[driver\string-api/gpio:c.gpiod_get_index]{\emph{\code{gpiod\_get\_index()}}}} for detailed
information about behavior and return values.
\index{devm\_gpiod\_get\_from\_of\_node (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.devm_gpiod_get_from_of_node}\pysiglinewithargsret{struct gpio\_desc * \bfcode{devm\_gpiod\_get\_from\_of\_node}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct device\_node *\emph{ node}, const char *\emph{ propname}, int\emph{ index}, enum gpiod\_flags\emph{ dflags}, const char *\emph{ label}}{}
obtain a GPIO from an OF node

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device for lifecycle management

\item[{\code{struct device\_node * node}}] \leavevmode
handle of the OF node

\item[{\code{const char * propname}}] \leavevmode
name of the DT property representing the GPIO

\item[{\code{int index}}] \leavevmode
index of the GPIO to obtain for the consumer

\item[{\code{enum gpiod\_flags dflags}}] \leavevmode
GPIO initialization flags

\item[{\code{const char * label}}] \leavevmode
label to attach to the requested GPIO

\end{description}

\textbf{Return}

On successful request the GPIO pin is configured in accordance with
provided \textbf{dflags}.

In case of error an \code{ERR\_PTR()} is returned.
\index{devm\_fwnode\_get\_index\_gpiod\_from\_child (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.devm_fwnode_get_index_gpiod_from_child}\pysiglinewithargsret{struct gpio\_desc * \bfcode{devm\_fwnode\_get\_index\_gpiod\_from\_child}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ con\_id}, int\emph{ index}, struct fwnode\_handle *\emph{ child}, enum gpiod\_flags\emph{ flags}, const char *\emph{ label}}{}
get a GPIO descriptor from a device's child node

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
GPIO consumer

\item[{\code{const char * con\_id}}] \leavevmode
function within the GPIO consumer

\item[{\code{int index}}] \leavevmode
index of the GPIO to obtain in the consumer

\item[{\code{struct fwnode\_handle * child}}] \leavevmode
firmware node (child of \textbf{dev})

\item[{\code{enum gpiod\_flags flags}}] \leavevmode
GPIO initialization flags

\item[{\code{const char * label}}] \leavevmode
label to attach to the requested GPIO

\end{description}

\textbf{Description}

GPIO descriptors returned from this function are automatically disposed on
driver detach.

On successful request the GPIO pin is configured in accordance with
provided \textbf{flags}.
\index{devm\_gpiod\_get\_index\_optional (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.devm_gpiod_get_index_optional}\pysiglinewithargsret{struct gpio\_desc * \bfcode{devm\_gpiod\_get\_index\_optional}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ con\_id}, unsigned int\emph{ index}, enum gpiod\_flags\emph{ flags}}{}
Resource-managed {\hyperref[driver\string-api/gpio:c.gpiod_get_index_optional]{\emph{\code{gpiod\_get\_index\_optional()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
GPIO consumer

\item[{\code{const char * con\_id}}] \leavevmode
function within the GPIO consumer

\item[{\code{unsigned int index}}] \leavevmode
index of the GPIO to obtain in the consumer

\item[{\code{enum gpiod\_flags flags}}] \leavevmode
optional GPIO initialization flags

\end{description}

\textbf{Description}

Managed {\hyperref[driver\string-api/gpio:c.gpiod_get_index_optional]{\emph{\code{gpiod\_get\_index\_optional()}}}}. GPIO descriptors returned from this
function are automatically disposed on driver detach. See
{\hyperref[driver\string-api/gpio:c.gpiod_get_index_optional]{\emph{\code{gpiod\_get\_index\_optional()}}}} for detailed information about behavior and
return values.
\index{devm\_gpiod\_get\_array (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.devm_gpiod_get_array}\pysiglinewithargsret{struct gpio\_descs * \bfcode{devm\_gpiod\_get\_array}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ con\_id}, enum gpiod\_flags\emph{ flags}}{}
Resource-managed {\hyperref[driver\string-api/gpio:c.gpiod_get_array]{\emph{\code{gpiod\_get\_array()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
GPIO consumer

\item[{\code{const char * con\_id}}] \leavevmode
function within the GPIO consumer

\item[{\code{enum gpiod\_flags flags}}] \leavevmode
optional GPIO initialization flags

\end{description}

\textbf{Description}

Managed {\hyperref[driver\string-api/gpio:c.gpiod_get_array]{\emph{\code{gpiod\_get\_array()}}}}. GPIO descriptors returned from this function are
automatically disposed on driver detach. See {\hyperref[driver\string-api/gpio:c.gpiod_get_array]{\emph{\code{gpiod\_get\_array()}}}} for detailed
information about behavior and return values.
\index{devm\_gpiod\_get\_array\_optional (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.devm_gpiod_get_array_optional}\pysiglinewithargsret{struct gpio\_descs * \bfcode{devm\_gpiod\_get\_array\_optional}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ con\_id}, enum gpiod\_flags\emph{ flags}}{}
Resource-managed {\hyperref[driver\string-api/gpio:c.gpiod_get_array_optional]{\emph{\code{gpiod\_get\_array\_optional()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
GPIO consumer

\item[{\code{const char * con\_id}}] \leavevmode
function within the GPIO consumer

\item[{\code{enum gpiod\_flags flags}}] \leavevmode
optional GPIO initialization flags

\end{description}

\textbf{Description}

Managed {\hyperref[driver\string-api/gpio:c.gpiod_get_array_optional]{\emph{\code{gpiod\_get\_array\_optional()}}}}. GPIO descriptors returned from this
function are automatically disposed on driver detach.
See {\hyperref[driver\string-api/gpio:c.gpiod_get_array_optional]{\emph{\code{gpiod\_get\_array\_optional()}}}} for detailed information about behavior and
return values.
\index{devm\_gpiod\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.devm_gpiod_put}\pysiglinewithargsret{void \bfcode{devm\_gpiod\_put}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct gpio\_desc *\emph{ desc}}{}
Resource-managed {\hyperref[driver\string-api/gpio:c.gpiod_put]{\emph{\code{gpiod\_put()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
GPIO consumer

\item[{\code{struct gpio\_desc * desc}}] \leavevmode
GPIO descriptor to dispose of

\end{description}

\textbf{Description}

Dispose of a GPIO descriptor obtained with {\hyperref[driver\string-api/gpio:c.devm_gpiod_get]{\emph{\code{devm\_gpiod\_get()}}}} or
{\hyperref[driver\string-api/gpio:c.devm_gpiod_get_index]{\emph{\code{devm\_gpiod\_get\_index()}}}}. Normally this function will not be called as the GPIO
will be disposed of by the resource management code.
\index{devm\_gpiod\_put\_array (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.devm_gpiod_put_array}\pysiglinewithargsret{void \bfcode{devm\_gpiod\_put\_array}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, struct gpio\_descs *\emph{ descs}}{}
Resource-managed {\hyperref[driver\string-api/gpio:c.gpiod_put_array]{\emph{\code{gpiod\_put\_array()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
GPIO consumer

\item[{\code{struct gpio\_descs * descs}}] \leavevmode
GPIO descriptor array to dispose of

\end{description}

\textbf{Description}

Dispose of an array of GPIO descriptors obtained with {\hyperref[driver\string-api/gpio:c.devm_gpiod_get_array]{\emph{\code{devm\_gpiod\_get\_array()}}}}.
Normally this function will not be called as the GPIOs will be disposed of
by the resource management code.
\index{devm\_gpio\_request (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.devm_gpio_request}\pysiglinewithargsret{int \bfcode{devm\_gpio\_request}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, unsigned\emph{ gpio}, const char *\emph{ label}}{}
request a GPIO for a managed device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device to request the GPIO for

\item[{\code{unsigned gpio}}] \leavevmode
GPIO to allocate

\item[{\code{const char * label}}] \leavevmode
the name of the requested GPIO

\end{description}

\textbf{Description}
\begin{quote}

Except for the extra \textbf{dev} argument, this function takes the
same arguments and performs the same function as
\code{gpio\_request()}.  GPIOs requested with this function will be
automatically freed on driver detach.

If an GPIO allocated with this function needs to be freed
separately, {\hyperref[driver\string-api/gpio:c.devm_gpio_free]{\emph{\code{devm\_gpio\_free()}}}} must be used.
\end{quote}
\index{devm\_gpio\_request\_one (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.devm_gpio_request_one}\pysiglinewithargsret{int \bfcode{devm\_gpio\_request\_one}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, unsigned\emph{ gpio}, unsigned long\emph{ flags}, const char *\emph{ label}}{}
request a single GPIO with initial setup

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device to request for

\item[{\code{unsigned gpio}}] \leavevmode
the GPIO number

\item[{\code{unsigned long flags}}] \leavevmode
GPIO configuration as specified by GPIOF\_*

\item[{\code{const char * label}}] \leavevmode
a literal description string of this GPIO

\end{description}
\index{devm\_gpio\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.devm_gpio_free}\pysiglinewithargsret{void \bfcode{devm\_gpio\_free}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, unsigned int\emph{ gpio}}{}
free a GPIO

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device to free GPIO for

\item[{\code{unsigned int gpio}}] \leavevmode
GPIO to free

\end{description}

\textbf{Description}
\begin{quote}

Except for the extra \textbf{dev} argument, this function takes the
same arguments and performs the same function as \code{gpio\_free()}.
This function instead of \code{gpio\_free()} should be used to manually
free GPIOs allocated with {\hyperref[driver\string-api/gpio:c.devm_gpio_request]{\emph{\code{devm\_gpio\_request()}}}}.
\end{quote}


\section{sysfs helpers}
\label{driver-api/gpio:sysfs-helpers}\index{gpiod\_export (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_export}\pysiglinewithargsret{int \bfcode{gpiod\_export}}{struct gpio\_desc *\emph{ desc}, bool\emph{ direction\_may\_change}}{}
export a GPIO through sysfs

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_desc * desc}}] \leavevmode
GPIO to make available, already requested

\item[{\code{bool direction\_may\_change}}] \leavevmode
true if userspace may change GPIO direction

\end{description}

\textbf{Context}

arch\_initcall or later

\textbf{Description}

When drivers want to make a GPIO accessible to userspace after they
have requested it -- perhaps while debugging, or as part of their
public interface -- they may use this routine.  If the GPIO can
change direction (some can't) and the caller allows it, userspace
will see ``direction'' sysfs attribute which may be used to change
the gpio's direction.  A ``value'' attribute will always be provided.

Returns zero on success, else an error.
\index{gpiod\_export\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_export_link}\pysiglinewithargsret{int \bfcode{gpiod\_export\_link}}{struct {\hyperref[driver\string-api/infrastructure:c.device]{\emph{device}}} *\emph{ dev}, const char *\emph{ name}, struct gpio\_desc *\emph{ desc}}{}
create a sysfs link to an exported GPIO node

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device under which to create symlink

\item[{\code{const char * name}}] \leavevmode
name of the symlink

\item[{\code{struct gpio\_desc * desc}}] \leavevmode
GPIO to create symlink to, already exported

\end{description}

\textbf{Description}

Set up a symlink from /sys/.../dev/name to /sys/class/gpio/gpioN
node. Caller is responsible for unlinking.

Returns zero on success, else an error.
\index{gpiod\_unexport (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/gpio:c.gpiod_unexport}\pysiglinewithargsret{void \bfcode{gpiod\_unexport}}{struct gpio\_desc *\emph{ desc}}{}
reverse effect of {\hyperref[driver\string-api/gpio:c.gpiod_export]{\emph{\code{gpiod\_export()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gpio\_desc * desc}}] \leavevmode
GPIO to make unavailable

\end{description}

\textbf{Description}

This is implicit on \code{gpiod\_free()}.


\chapter{Miscellaneous Devices}
\label{driver-api/misc_devices:miscellaneous-devices}\label{driver-api/misc_devices::doc}\index{misc\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/misc_devices:c.misc_register}\pysiglinewithargsret{int \bfcode{misc\_register}}{struct miscdevice *\emph{ misc}}{}
register a miscellaneous device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct miscdevice * misc}}] \leavevmode
device structure

\end{description}

\textbf{Description}
\begin{quote}

Register a miscellaneous device with the kernel. If the minor
number is set to \code{MISC\_DYNAMIC\_MINOR} a minor number is assigned
and placed in the minor field of the structure. For other cases
the minor number requested is used.

The structure passed is linked into the kernel and may not be
destroyed until it has been unregistered. By default, an \code{open()}
syscall to the device sets file-\textgreater{}private\_data to point to the
structure. Drivers don't need open in fops for this.

A zero is returned on success and a negative errno code for
failure.
\end{quote}
\index{misc\_deregister (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/misc_devices:c.misc_deregister}\pysiglinewithargsret{void \bfcode{misc\_deregister}}{struct miscdevice *\emph{ misc}}{}
unregister a miscellaneous device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct miscdevice * misc}}] \leavevmode
device to unregister

\end{description}

\textbf{Description}
\begin{quote}

Unregister a miscellaneous device that was previously
successfully registered with {\hyperref[driver\string-api/misc_devices:c.misc_register]{\emph{\code{misc\_register()}}}}.
\end{quote}


\chapter{DMAEngine documentation}
\label{driver-api/dmaengine/index:dmaengine-documentation}\label{driver-api/dmaengine/index::doc}
DMAEngine documentation provides documents for various aspects of DMAEngine
framework.


\section{DMAEngine documentation}
\label{driver-api/dmaengine/index:id1}
This book helps with DMAengine internal APIs and guide for DMAEngine device
driver writers.


\subsection{DMAengine controller documentation}
\label{driver-api/dmaengine/provider:dmaengine-controller-documentation}\label{driver-api/dmaengine/provider::doc}

\subsubsection{Hardware Introduction}
\label{driver-api/dmaengine/provider:hardware-introduction}
Most of the Slave DMA controllers have the same general principles of
operations.

They have a given number of channels to use for the DMA transfers, and
a given number of requests lines.

Requests and channels are pretty much orthogonal. Channels can be used
to serve several to any requests. To simplify, channels are the
entities that will be doing the copy, and requests what endpoints are
involved.

The request lines actually correspond to physical lines going from the
DMA-eligible devices to the controller itself. Whenever the device
will want to start a transfer, it will assert a DMA request (DRQ) by
asserting that request line.

A very simple DMA controller would only take into account a single
parameter: the transfer size. At each clock cycle, it would transfer a
byte of data from one buffer to another, until the transfer size has
been reached.

That wouldn't work well in the real world, since slave devices might
require a specific number of bits to be transferred in a single
cycle. For example, we may want to transfer as much data as the
physical bus allows to maximize performances when doing a simple
memory copy operation, but our audio device could have a narrower FIFO
that requires data to be written exactly 16 or 24 bits at a time. This
is why most if not all of the DMA controllers can adjust this, using a
parameter called the transfer width.

Moreover, some DMA controllers, whenever the RAM is used as a source
or destination, can group the reads or writes in memory into a buffer,
so instead of having a lot of small memory accesses, which is not
really efficient, you'll get several bigger transfers. This is done
using a parameter called the burst size, that defines how many single
reads/writes it's allowed to do without the controller splitting the
transfer into smaller sub-transfers.

Our theoretical DMA controller would then only be able to do transfers
that involve a single contiguous block of data. However, some of the
transfers we usually have are not, and want to copy data from
non-contiguous buffers to a contiguous buffer, which is called
scatter-gather.

DMAEngine, at least for mem2dev transfers, require support for
scatter-gather. So we're left with two cases here: either we have a
quite simple DMA controller that doesn't support it, and we'll have to
implement it in software, or we have a more advanced DMA controller,
that implements in hardware scatter-gather.

The latter are usually programmed using a collection of chunks to
transfer, and whenever the transfer is started, the controller will go
over that collection, doing whatever we programmed there.

This collection is usually either a table or a linked list. You will
then push either the address of the table and its number of elements,
or the first item of the list to one channel of the DMA controller,
and whenever a DRQ will be asserted, it will go through the collection
to know where to fetch the data from.

Either way, the format of this collection is completely dependent on
your hardware. Each DMA controller will require a different structure,
but all of them will require, for every chunk, at least the source and
destination addresses, whether it should increment these addresses or
not and the three parameters we saw earlier: the burst size, the
transfer width and the transfer size.

The one last thing is that usually, slave devices won't issue DRQ by
default, and you have to enable this in your slave device driver first
whenever you're willing to use DMA.

These were just the general memory-to-memory (also called mem2mem) or
memory-to-device (mem2dev) kind of transfers. Most devices often
support other kind of transfers or memory operations that dmaengine
support and will be detailed later in this document.


\subsubsection{DMA Support in Linux}
\label{driver-api/dmaengine/provider:dma-support-in-linux}
Historically, DMA controller drivers have been implemented using the
async TX API, to offload operations such as memory copy, XOR,
cryptography, etc., basically any memory to memory operation.

Over time, the need for memory to device transfers arose, and
dmaengine was extended. Nowadays, the async TX API is written as a
layer on top of dmaengine, and acts as a client. Still, dmaengine
accommodates that API in some cases, and made some design choices to
ensure that it stayed compatible.

For more information on the Async TX API, please look the relevant
documentation file in Documentation/crypto/async-tx-api.txt.


\subsubsection{DMAEngine APIs}
\label{driver-api/dmaengine/provider:dmaengine-apis}

\paragraph{\texttt{struct dma\_device} Initialization}
\label{driver-api/dmaengine/provider:struct-dma-device-initialization}
Just like any other kernel framework, the whole DMAEngine registration
relies on the driver filling a structure and registering against the
framework. In our case, that structure is dma\_device.

The first thing you need to do in your driver is to allocate this
structure. Any of the usual memory allocators will do, but you'll also
need to initialize a few fields in there:
\begin{itemize}
\item {} 
\code{channels}: should be initialized as a list using the
INIT\_LIST\_HEAD macro for example

\item {} 
\code{src\_addr\_widths}:
should contain a bitmask of the supported source transfer width

\item {} 
\code{dst\_addr\_widths}:
should contain a bitmask of the supported destination transfer width

\item {} 
\code{directions}:
should contain a bitmask of the supported slave directions
(i.e. excluding mem2mem transfers)

\item {} 
\code{residue\_granularity}:
granularity of the transfer residue reported to dma\_set\_residue.
This can be either:
\begin{itemize}
\item {} 
Descriptor:
your device doesn't support any kind of residue
reporting. The framework will only know that a particular
transaction descriptor is done.

\item {} 
Segment:
your device is able to report which chunks have been transferred

\item {} 
Burst:
your device is able to report which burst have been transferred

\end{itemize}

\item {} 
\code{dev}: should hold the pointer to the \code{struct device} associated
to your current driver instance.

\end{itemize}


\paragraph{Supported transaction types}
\label{driver-api/dmaengine/provider:supported-transaction-types}
The next thing you need is to set which transaction types your device
(and driver) supports.

Our \code{dma\_device structure} has a field called cap\_mask that holds the
various types of transaction supported, and you need to modify this
mask using the dma\_cap\_set function, with various flags depending on
transaction types you support as an argument.

All those capabilities are defined in the \code{dma\_transaction\_type enum},
in \code{include/linux/dmaengine.h}

Currently, the types available are:
\begin{itemize}
\item {} 
DMA\_MEMCPY
\begin{itemize}
\item {} 
The device is able to do memory to memory copies

\end{itemize}

\item {} 
DMA\_XOR
\begin{itemize}
\item {} 
The device is able to perform XOR operations on memory areas

\item {} 
Used to accelerate XOR intensive tasks, such as RAID5

\end{itemize}

\item {} 
DMA\_XOR\_VAL
\begin{itemize}
\item {} 
The device is able to perform parity check using the XOR
algorithm against a memory buffer.

\end{itemize}

\item {} 
DMA\_PQ
\begin{itemize}
\item {} 
The device is able to perform RAID6 P+Q computations, P being a
simple XOR, and Q being a Reed-Solomon algorithm.

\end{itemize}

\item {} 
DMA\_PQ\_VAL
\begin{itemize}
\item {} 
The device is able to perform parity check using RAID6 P+Q
algorithm against a memory buffer.

\end{itemize}

\item {} 
DMA\_INTERRUPT
\begin{itemize}
\item {} 
The device is able to trigger a dummy transfer that will
generate periodic interrupts

\item {} 
Used by the client drivers to register a callback that will be
called on a regular basis through the DMA controller interrupt

\end{itemize}

\item {} 
DMA\_PRIVATE
\begin{itemize}
\item {} 
The devices only supports slave transfers, and as such isn't
available for async transfers.

\end{itemize}

\item {} 
DMA\_ASYNC\_TX
\begin{itemize}
\item {} 
Must not be set by the device, and will be set by the framework
if needed

\item {} 
TODO: What is it about?

\end{itemize}

\item {} 
DMA\_SLAVE
\begin{itemize}
\item {} 
The device can handle device to memory transfers, including
scatter-gather transfers.

\item {} 
While in the mem2mem case we were having two distinct types to
deal with a single chunk to copy or a collection of them, here,
we just have a single transaction type that is supposed to
handle both.

\item {} 
If you want to transfer a single contiguous memory buffer,
simply build a scatter list with only one item.

\end{itemize}

\item {} 
DMA\_CYCLIC
\begin{itemize}
\item {} 
The device can handle cyclic transfers.

\item {} 
A cyclic transfer is a transfer where the chunk collection will
loop over itself, with the last item pointing to the first.

\item {} 
It's usually used for audio transfers, where you want to operate
on a single ring buffer that you will fill with your audio data.

\end{itemize}

\item {} 
DMA\_INTERLEAVE
\begin{itemize}
\item {} 
The device supports interleaved transfer.

\item {} 
These transfers can transfer data from a non-contiguous buffer
to a non-contiguous buffer, opposed to DMA\_SLAVE that can
transfer data from a non-contiguous data set to a continuous
destination buffer.

\item {} 
It's usually used for 2d content transfers, in which case you
want to transfer a portion of uncompressed data directly to the
display to print it

\end{itemize}

\end{itemize}

These various types will also affect how the source and destination
addresses change over time.

Addresses pointing to RAM are typically incremented (or decremented)
after each transfer. In case of a ring buffer, they may loop
(DMA\_CYCLIC). Addresses pointing to a device's register (e.g. a FIFO)
are typically fixed.


\paragraph{Device operations}
\label{driver-api/dmaengine/provider:device-operations}
Our dma\_device structure also requires a few function pointers in
order to implement the actual logic, now that we described what
operations we were able to perform.

The functions that we have to fill in there, and hence have to
implement, obviously depend on the transaction types you reported as
supported.
\begin{itemize}
\item {} 
\code{device\_alloc\_chan\_resources}

\item {} 
\code{device\_free\_chan\_resources}
\begin{itemize}
\item {} 
These functions will be called whenever a driver will call
\code{dma\_request\_channel} or \code{dma\_release\_channel} for the first/last
time on the channel associated to that driver.

\item {} 
They are in charge of allocating/freeing all the needed
resources in order for that channel to be useful for your driver.

\item {} 
These functions can sleep.

\end{itemize}

\item {} 
\code{device\_prep\_dma\_*}
\begin{itemize}
\item {} 
These functions are matching the capabilities you registered
previously.

\item {} 
These functions all take the buffer or the scatterlist relevant
for the transfer being prepared, and should create a hardware
descriptor or a list of hardware descriptors from it

\item {} 
These functions can be called from an interrupt context

\item {} 
Any allocation you might do should be using the GFP\_NOWAIT
flag, in order not to potentially sleep, but without depleting
the emergency pool either.

\item {} 
Drivers should try to pre-allocate any memory they might need
during the transfer setup at probe time to avoid putting to
much pressure on the nowait allocator.

\item {} 
It should return a unique instance of the
\code{dma\_async\_tx\_descriptor structure}, that further represents this
particular transfer.

\item {} 
This structure can be initialized using the function
\code{dma\_async\_tx\_descriptor\_init}.

\item {} 
You'll also need to set two fields in this structure:
\begin{itemize}
\item {} 
flags:
TODO: Can it be modified by the driver itself, or
should it be always the flags passed in the arguments

\item {} 
tx\_submit: A pointer to a function you have to implement,
that is supposed to push the current transaction descriptor to a
pending queue, waiting for issue\_pending to be called.

\end{itemize}

\item {} 
In this structure the function pointer callback\_result can be
initialized in order for the submitter to be notified that a
transaction has completed. In the earlier code the function pointer
callback has been used. However it does not provide any status to the
transaction and will be deprecated. The result structure defined as
\code{dmaengine\_result} that is passed in to callback\_result
has two fields:
\begin{itemize}
\item {} 
result: This provides the transfer result defined by
\code{dmaengine\_tx\_result}. Either success or some error condition.

\item {} 
residue: Provides the residue bytes of the transfer for those that
support residue.

\end{itemize}

\end{itemize}

\item {} 
\code{device\_issue\_pending}
\begin{itemize}
\item {} 
Takes the first transaction descriptor in the pending queue,
and starts the transfer. Whenever that transfer is done, it
should move to the next transaction in the list.

\item {} 
This function can be called in an interrupt context

\end{itemize}

\item {} 
\code{device\_tx\_status}
\begin{itemize}
\item {} 
Should report the bytes left to go over on the given channel

\item {} 
Should only care about the transaction descriptor passed as
argument, not the currently active one on a given channel

\item {} 
The tx\_state argument might be NULL

\item {} 
Should use dma\_set\_residue to report it

\item {} 
In the case of a cyclic transfer, it should only take into
account the current period.

\item {} 
This function can be called in an interrupt context.

\end{itemize}

\item {} 
device\_config
\begin{itemize}
\item {} 
Reconfigures the channel with the configuration given as argument

\item {} 
This command should NOT perform synchronously, or on any
currently queued transfers, but only on subsequent ones

\item {} 
In this case, the function will receive a \code{dma\_slave\_config}
structure pointer as an argument, that will detail which
configuration to use.

\item {} 
Even though that structure contains a direction field, this
field is deprecated in favor of the direction argument given to
the prep\_* functions

\item {} 
This call is mandatory for slave operations only. This should NOT be
set or expected to be set for memcpy operations.
If a driver support both, it should use this call for slave
operations only and not for memcpy ones.

\end{itemize}

\item {} 
device\_pause
\begin{itemize}
\item {} 
Pauses a transfer on the channel

\item {} 
This command should operate synchronously on the channel,
pausing right away the work of the given channel

\end{itemize}

\item {} 
device\_resume
\begin{itemize}
\item {} 
Resumes a transfer on the channel

\item {} 
This command should operate synchronously on the channel,
resuming right away the work of the given channel

\end{itemize}

\item {} 
device\_terminate\_all
\begin{itemize}
\item {} 
Aborts all the pending and ongoing transfers on the channel

\item {} 
For aborted transfers the complete callback should not be called

\item {} 
Can be called from atomic context or from within a complete
callback of a descriptor. Must not sleep. Drivers must be able
to handle this correctly.

\item {} 
Termination may be asynchronous. The driver does not have to
wait until the currently active transfer has completely stopped.
See device\_synchronize.

\end{itemize}

\item {} 
device\_synchronize
\begin{itemize}
\item {} 
Must synchronize the termination of a channel to the current
context.

\item {} 
Must make sure that memory for previously submitted
descriptors is no longer accessed by the DMA controller.

\item {} 
Must make sure that all complete callbacks for previously
submitted descriptors have finished running and none are
scheduled to run.

\item {} 
May sleep.

\end{itemize}

\end{itemize}


\subsubsection{Misc notes}
\label{driver-api/dmaengine/provider:misc-notes}
(stuff that should be documented, but don't really know
where to put them)

\code{dma\_run\_dependencies}
\begin{itemize}
\item {} 
Should be called at the end of an async TX transfer, and can be
ignored in the slave transfers case.

\item {} 
Makes sure that dependent operations are run before marking it
as complete.

\end{itemize}

dma\_cookie\_t
\begin{itemize}
\item {} 
it's a DMA transaction ID that will increment over time.

\item {} 
Not really relevant any more since the introduction of \code{virt-dma}
that abstracts it away.

\end{itemize}

DMA\_CTRL\_ACK
\begin{itemize}
\item {} 
If clear, the descriptor cannot be reused by provider until the
client acknowledges receipt, i.e. has has a chance to establish any
dependency chains

\item {} 
This can be acked by invoking async\_tx\_ack()

\item {} 
If set, does not mean descriptor can be reused

\end{itemize}

DMA\_CTRL\_REUSE
\begin{itemize}
\item {} 
If set, the descriptor can be reused after being completed. It should
not be freed by provider if this flag is set.

\item {} 
The descriptor should be prepared for reuse by invoking
\code{dmaengine\_desc\_set\_reuse()} which will set DMA\_CTRL\_REUSE.

\item {} 
\code{dmaengine\_desc\_set\_reuse()} will succeed only when channel support
reusable descriptor as exhibited by capabilities

\item {} 
As a consequence, if a device driver wants to skip the
\code{dma\_map\_sg()} and \code{dma\_unmap\_sg()} in between 2 transfers,
because the DMA'd data wasn't used, it can resubmit the transfer right after
its completion.

\item {} 
Descriptor can be freed in few ways
\begin{itemize}
\item {} 
Clearing DMA\_CTRL\_REUSE by invoking
\code{dmaengine\_desc\_clear\_reuse()} and submitting for last txn

\item {} 
Explicitly invoking \code{dmaengine\_desc\_free()}, this can succeed only
when DMA\_CTRL\_REUSE is already set

\item {} 
Terminating the channel

\end{itemize}

\item {} 
DMA\_PREP\_CMD
\begin{itemize}
\item {} 
If set, the client driver tells DMA controller that passed data in DMA
API is command data.

\item {} 
Interpretation of command data is DMA controller specific. It can be
used for issuing commands to other peripherals/register reads/register
writes for which the descriptor should be in different format from
normal data descriptors.

\end{itemize}

\end{itemize}


\subsubsection{General Design Notes}
\label{driver-api/dmaengine/provider:general-design-notes}
Most of the DMAEngine drivers you'll see are based on a similar design
that handles the end of transfer interrupts in the handler, but defer
most work to a tasklet, including the start of a new transfer whenever
the previous transfer ended.

This is a rather inefficient design though, because the inter-transfer
latency will be not only the interrupt latency, but also the
scheduling latency of the tasklet, which will leave the channel idle
in between, which will slow down the global transfer rate.

You should avoid this kind of practice, and instead of electing a new
transfer in your tasklet, move that part to the interrupt handler in
order to have a shorter idle window (that we can't really avoid
anyway).


\subsubsection{Glossary}
\label{driver-api/dmaengine/provider:glossary}\begin{itemize}
\item {} 
Burst: A number of consecutive read or write operations that
can be queued to buffers before being flushed to memory.

\item {} 
Chunk: A contiguous collection of bursts

\item {} 
Transfer: A collection of chunks (be it contiguous or not)

\end{itemize}


\section{DMAEngine client documentation}
\label{driver-api/dmaengine/index:dmaengine-client-documentation}
This book is a guide to device driver writers on how to use the Slave-DMA
API of the DMAEngine. This is applicable only for slave DMA usage only.


\subsection{DMA Engine API Guide}
\label{driver-api/dmaengine/client::doc}\label{driver-api/dmaengine/client:dma-engine-api-guide}
Vinod Koul \textless{}vinod dot koul at intel.com\textgreater{}

\begin{notice}{note}{Note:}
For DMA Engine usage in async\_tx please see:
\code{Documentation/crypto/async-tx-api.txt}
\end{notice}

Below is a guide to device driver writers on how to use the Slave-DMA API of the
DMA Engine. This is applicable only for slave DMA usage only.


\subsubsection{DMA usage}
\label{driver-api/dmaengine/client:dma-usage}
The slave DMA usage consists of following steps:
\begin{itemize}
\item {} 
Allocate a DMA slave channel

\item {} 
Set slave and controller specific parameters

\item {} 
Get a descriptor for transaction

\item {} 
Submit the transaction

\item {} 
Issue pending requests and wait for callback notification

\end{itemize}

The details of these operations are:
\begin{enumerate}
\item {} 
Allocate a DMA slave channel

Channel allocation is slightly different in the slave DMA context,
client drivers typically need a channel from a particular DMA
controller only and even in some cases a specific channel is desired.
To request a channel dma\_request\_chan() API is used.

Interface:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{dma\PYGZus{}chan} \PYG{o}{*}\PYG{n+nf}{dma\PYGZus{}request\PYGZus{}chan}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{device} \PYG{o}{*}\PYG{n}{dev}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{name}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Which will find and return the \code{name} DMA channel associated with the `dev'
device. The association is done via DT, ACPI or board file based
dma\_slave\_map matching table.

A channel allocated via this interface is exclusive to the caller,
until dma\_release\_channel() is called.

\item {} 
Set slave and controller specific parameters

Next step is always to pass some specific information to the DMA
driver. Most of the generic information which a slave DMA can use
is in struct dma\_slave\_config. This allows the clients to specify
DMA direction, DMA addresses, bus widths, DMA burst lengths etc
for the peripheral.

If some DMA controllers have more parameters to be sent then they
should try to embed struct dma\_slave\_config in their controller
specific structure. That gives flexibility to client to pass more
parameters, if required.

Interface:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{dmaengine\PYGZus{}slave\PYGZus{}config}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{dma\PYGZus{}chan} \PYG{o}{*}\PYG{n}{chan}\PYG{p}{,}
                  \PYG{k}{struct} \PYG{n}{dma\PYGZus{}slave\PYGZus{}config} \PYG{o}{*}\PYG{n}{config}\PYG{p}{)}
\end{Verbatim}

Please see the dma\_slave\_config structure definition in dmaengine.h
for a detailed explanation of the struct members. Please note
that the `direction' member will be going away as it duplicates the
direction given in the prepare call.

\item {} 
Get a descriptor for transaction

\end{enumerate}
\begin{quote}

For slave usage the various modes of slave transfers supported by the
DMA-engine are:
\begin{itemize}
\item {} 
slave\_sg: DMA a list of scatter gather buffers from/to a peripheral

\item {} 
dma\_cyclic: Perform a cyclic DMA operation from/to a peripheral till the
operation is explicitly stopped.

\item {} 
interleaved\_dma: This is common to Slave as well as M2M clients. For slave
address of devices' fifo could be already known to the driver.
Various types of operations could be expressed by setting
appropriate values to the `dma\_interleaved\_template' members.

\end{itemize}

A non-NULL return of this transfer API represents a ``descriptor'' for
the given transaction.

Interface:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{dma\PYGZus{}async\PYGZus{}tx\PYGZus{}descriptor} \PYG{o}{*}\PYG{n+nf}{dmaengine\PYGZus{}prep\PYGZus{}slave\PYGZus{}sg}\PYG{p}{(}
           \PYG{k}{struct} \PYG{n}{dma\PYGZus{}chan} \PYG{o}{*}\PYG{n}{chan}\PYG{p}{,} \PYG{k}{struct} \PYG{n}{scatterlist} \PYG{o}{*}\PYG{n}{sgl}\PYG{p}{,}
           \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{sg\PYGZus{}len}\PYG{p}{,} \PYG{k}{enum} \PYG{n}{dma\PYGZus{}data\PYGZus{}direction} \PYG{n}{direction}\PYG{p}{,}
           \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{flags}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{struct} \PYG{n}{dma\PYGZus{}async\PYGZus{}tx\PYGZus{}descriptor} \PYG{o}{*}\PYG{n+nf}{dmaengine\PYGZus{}prep\PYGZus{}dma\PYGZus{}cyclic}\PYG{p}{(}
           \PYG{k}{struct} \PYG{n}{dma\PYGZus{}chan} \PYG{o}{*}\PYG{n}{chan}\PYG{p}{,} \PYG{n}{dma\PYGZus{}addr\PYGZus{}t} \PYG{n}{buf\PYGZus{}addr}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{buf\PYGZus{}len}\PYG{p}{,}
           \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{period\PYGZus{}len}\PYG{p}{,} \PYG{k}{enum} \PYG{n}{dma\PYGZus{}data\PYGZus{}direction} \PYG{n}{direction}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{struct} \PYG{n}{dma\PYGZus{}async\PYGZus{}tx\PYGZus{}descriptor} \PYG{o}{*}\PYG{n+nf}{dmaengine\PYGZus{}prep\PYGZus{}interleaved\PYGZus{}dma}\PYG{p}{(}
           \PYG{k}{struct} \PYG{n}{dma\PYGZus{}chan} \PYG{o}{*}\PYG{n}{chan}\PYG{p}{,} \PYG{k}{struct} \PYG{n}{dma\PYGZus{}interleaved\PYGZus{}template} \PYG{o}{*}\PYG{n}{xt}\PYG{p}{,}
           \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{flags}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

The peripheral driver is expected to have mapped the scatterlist for
the DMA operation prior to calling dmaengine\_prep\_slave\_sg(), and must
keep the scatterlist mapped until the DMA operation has completed.
The scatterlist must be mapped using the DMA struct device.
If a mapping needs to be synchronized later, dma\_sync\_*\_for\_*() must be
called using the DMA struct device, too.
So, normal setup should look like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{nr\PYGZus{}sg} \PYG{o}{=} \PYG{n}{dma\PYGZus{}map\PYGZus{}sg}\PYG{p}{(}\PYG{n}{chan}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{device}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dev}\PYG{p}{,} \PYG{n}{sgl}\PYG{p}{,} \PYG{n}{sg\PYGZus{}len}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{nr\PYGZus{}sg} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
           \PYG{c+cm}{/* error */}

   \PYG{n}{desc} \PYG{o}{=} \PYG{n}{dmaengine\PYGZus{}prep\PYGZus{}slave\PYGZus{}sg}\PYG{p}{(}\PYG{n}{chan}\PYG{p}{,} \PYG{n}{sgl}\PYG{p}{,} \PYG{n}{nr\PYGZus{}sg}\PYG{p}{,} \PYG{n}{direction}\PYG{p}{,} \PYG{n}{flags}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Once a descriptor has been obtained, the callback information can be
added and the descriptor must then be submitted. Some DMA engine
drivers may hold a spinlock between a successful preparation and
submission so it is important that these two operations are closely
paired.

\begin{notice}{note}{Note:}
Although the async\_tx API specifies that completion callback
routines cannot submit any new operations, this is not the
case for slave/cyclic DMA.

For slave DMA, the subsequent transaction may not be available
for submission prior to callback function being invoked, so
slave DMA callbacks are permitted to prepare and submit a new
transaction.

For cyclic DMA, a callback function may wish to terminate the
DMA via dmaengine\_terminate\_async().

Therefore, it is important that DMA engine drivers drop any
locks before calling the callback function which may cause a
deadlock.

Note that callbacks will always be invoked from the DMA
engines tasklet, never from interrupt context.
\end{notice}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
Submit the transaction

Once the descriptor has been prepared and the callback information
added, it must be placed on the DMA engine drivers pending queue.

Interface:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{dma\PYGZus{}cookie\PYGZus{}t} \PYG{n}{dmaengine\PYGZus{}submit}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{dma\PYGZus{}async\PYGZus{}tx\PYGZus{}descriptor} \PYG{o}{*}\PYG{n}{desc}\PYG{p}{)}
\end{Verbatim}

This returns a cookie can be used to check the progress of DMA engine
activity via other DMA engine calls not covered in this document.

dmaengine\_submit() will not start the DMA operation, it merely adds
it to the pending queue. For this, see step 5, dma\_async\_issue\_pending.

\item {} 
Issue pending DMA requests and wait for callback notification

The transactions in the pending queue can be activated by calling the
issue\_pending API. If channel is idle then the first transaction in
queue is started and subsequent ones queued up.

On completion of each DMA operation, the next in queue is started and
a tasklet triggered. The tasklet will then call the client driver
completion callback routine for notification, if set.

Interface:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{dma\PYGZus{}async\PYGZus{}issue\PYGZus{}pending}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{dma\PYGZus{}chan} \PYG{o}{*}\PYG{n}{chan}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{enumerate}


\paragraph{Further APIs:}
\label{driver-api/dmaengine/client:further-apis}\begin{enumerate}
\item {} 
Terminate APIs

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{dmaengine\PYGZus{}terminate\PYGZus{}sync}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{dma\PYGZus{}chan} \PYG{o}{*}\PYG{n}{chan}\PYG{p}{)}
\PYG{k+kt}{int} \PYG{n}{dmaengine\PYGZus{}terminate\PYGZus{}async}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{dma\PYGZus{}chan} \PYG{o}{*}\PYG{n}{chan}\PYG{p}{)}
\PYG{k+kt}{int} \PYG{n}{dmaengine\PYGZus{}terminate\PYGZus{}all}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{dma\PYGZus{}chan} \PYG{o}{*}\PYG{n}{chan}\PYG{p}{)} \PYG{c+cm}{/* DEPRECATED */}
\end{Verbatim}

This causes all activity for the DMA channel to be stopped, and may
discard data in the DMA FIFO which hasn't been fully transferred.
No callback functions will be called for any incomplete transfers.

Two variants of this function are available.

dmaengine\_terminate\_async() might not wait until the DMA has been fully
stopped or until any running complete callbacks have finished. But it is
possible to call dmaengine\_terminate\_async() from atomic context or from
within a complete callback. dmaengine\_synchronize() must be called before it
is safe to free the memory accessed by the DMA transfer or free resources
accessed from within the complete callback.

dmaengine\_terminate\_sync() will wait for the transfer and any running
complete callbacks to finish before it returns. But the function must not be
called from atomic context or from within a complete callback.

dmaengine\_terminate\_all() is deprecated and should not be used in new code.

\item {} 
Pause API

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{dmaengine\PYGZus{}pause}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{dma\PYGZus{}chan} \PYG{o}{*}\PYG{n}{chan}\PYG{p}{)}
\end{Verbatim}

This pauses activity on the DMA channel without data loss.

\item {} 
Resume API

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{dmaengine\PYGZus{}resume}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{dma\PYGZus{}chan} \PYG{o}{*}\PYG{n}{chan}\PYG{p}{)}
\end{Verbatim}

Resume a previously paused DMA channel. It is invalid to resume a
channel which is not currently paused.

\item {} 
Check Txn complete

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{enum} \PYG{n}{dma\PYGZus{}status} \PYG{n}{dma\PYGZus{}async\PYGZus{}is\PYGZus{}tx\PYGZus{}complete}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{dma\PYGZus{}chan} \PYG{o}{*}\PYG{n}{chan}\PYG{p}{,}
          \PYG{n}{dma\PYGZus{}cookie\PYGZus{}t} \PYG{n}{cookie}\PYG{p}{,} \PYG{n}{dma\PYGZus{}cookie\PYGZus{}t} \PYG{o}{*}\PYG{n}{last}\PYG{p}{,} \PYG{n}{dma\PYGZus{}cookie\PYGZus{}t} \PYG{o}{*}\PYG{n}{used}\PYG{p}{)}
\end{Verbatim}

This can be used to check the status of the channel. Please see
the documentation in include/linux/dmaengine.h for a more complete
description of this API.

This can be used in conjunction with dma\_async\_is\_complete() and
the cookie returned from dmaengine\_submit() to check for
completion of a specific DMA transaction.

\begin{notice}{note}{Note:}
Not all DMA engine drivers can return reliable information for
a running DMA channel. It is recommended that DMA engine users
pause or stop (via dmaengine\_terminate\_all()) the channel before
using this API.
\end{notice}

\item {} 
Synchronize termination API

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n}{dmaengine\PYGZus{}synchronize}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{dma\PYGZus{}chan} \PYG{o}{*}\PYG{n}{chan}\PYG{p}{)}
\end{Verbatim}

Synchronize the termination of the DMA channel to the current context.

This function should be used after dmaengine\_terminate\_async() to synchronize
the termination of the DMA channel to the current context. The function will
wait for the transfer and any running complete callbacks to finish before it
returns.

If dmaengine\_terminate\_async() is used to stop the DMA channel this function
must be called before it is safe to free memory accessed by previously
submitted descriptors or to free any resources accessed within the complete
callback of previously submitted descriptors.

The behavior of this function is undefined if dma\_async\_issue\_pending() has
been called between dmaengine\_terminate\_async() and this function.

\end{enumerate}


\section{DMA Test documentation}
\label{driver-api/dmaengine/index:dma-test-documentation}
This book introduces how to test DMA drivers using dmatest module.


\subsection{DMA Test Guide}
\label{driver-api/dmaengine/dmatest:dma-test-guide}\label{driver-api/dmaengine/dmatest::doc}
Andy Shevchenko \textless{}\href{mailto:andriy.shevchenko@linux.intel.com}{andriy.shevchenko@linux.intel.com}\textgreater{}

This small document introduces how to test DMA drivers using dmatest module.


\subsubsection{Part 1 - How to build the test module}
\label{driver-api/dmaengine/dmatest:part-1-how-to-build-the-test-module}\begin{description}
\item[{The menuconfig contains an option that could be found by following path:}] \leavevmode
Device Drivers -\textgreater{} DMA Engine support -\textgreater{} DMA Test client

\end{description}

In the configuration file the option called CONFIG\_DMATEST. The dmatest could
be built as module or inside kernel. Let's consider those cases.


\subsubsection{Part 2 - When dmatest is built as a module}
\label{driver-api/dmaengine/dmatest:part-2-when-dmatest-is-built-as-a-module}
Example of usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} modprobe dmatest channel=dma0chan0 timeout=2000 iterations=1 run=1
\end{Verbatim}

...or:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} modprobe dmatest
\PYGZpc{} echo dma0chan0 \PYGZgt{} /sys/module/dmatest/parameters/channel
\PYGZpc{} echo 2000 \PYGZgt{} /sys/module/dmatest/parameters/timeout
\PYGZpc{} echo 1 \PYGZgt{} /sys/module/dmatest/parameters/iterations
\PYGZpc{} echo 1 \PYGZgt{} /sys/module/dmatest/parameters/run
\end{Verbatim}

...or on the kernel command line:

\begin{Verbatim}[commandchars=\\\{\}]
dmatest.channel=dma0chan0 dmatest.timeout=2000 dmatest.iterations=1 dmatest.run=1
\end{Verbatim}
\begin{description}
\item[{..hint:: available channel list could be extracted by running the following}] \leavevmode
command:

\end{description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} ls \PYGZhy{}1 /sys/class/dma/
\end{Verbatim}

Once started a message like ``dmatest: Started 1 threads using dma0chan0'' is
emitted. After that only test failure messages are reported until the test
stops.

Note that running a new test will not stop any in progress test.

The following command returns the state of the test.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} cat /sys/module/dmatest/parameters/run
\end{Verbatim}

To wait for test completion userpace can poll `run' until it is false, or use
the wait parameter. Specifying `wait=1' when loading the module causes module
initialization to pause until a test run has completed, while reading
/sys/module/dmatest/parameters/wait waits for any running test to complete
before returning. For example, the following scripts wait for 42 tests
to complete before exiting. Note that if `iterations' is set to `infinite' then
waiting is disabled.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} modprobe dmatest run=1 iterations=42 wait=1
\PYGZpc{} modprobe \PYGZhy{}r dmatest
\end{Verbatim}

...or:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} modprobe dmatest run=1 iterations=42
\PYGZpc{} cat /sys/module/dmatest/parameters/wait
\PYGZpc{} modprobe \PYGZhy{}r dmatest
\end{Verbatim}


\subsubsection{Part 3 - When built-in in the kernel}
\label{driver-api/dmaengine/dmatest:part-3-when-built-in-in-the-kernel}
The module parameters that is supplied to the kernel command line will be used
for the first performed test. After user gets a control, the test could be
re-run with the same or different parameters. For the details see the above
section ``Part 2 - When dmatest is built as a module...''

In both cases the module parameters are used as the actual values for the test
case. You always could check them at run-time by running

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} grep \PYGZhy{}H . /sys/module/dmatest/parameters/*
\end{Verbatim}


\subsubsection{Part 4 - Gathering the test results}
\label{driver-api/dmaengine/dmatest:part-4-gathering-the-test-results}
Test results are printed to the kernel log buffer with the format:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdq{}dmatest: result \PYGZlt{}channel\PYGZgt{}: \PYGZlt{}test id\PYGZgt{}: \PYGZsq{}\PYGZlt{}error msg\PYGZgt{}\PYGZsq{} with src\PYGZus{}off=\PYGZlt{}val\PYGZgt{} dst\PYGZus{}off=\PYGZlt{}val\PYGZgt{} len=\PYGZlt{}val\PYGZgt{} (\PYGZlt{}err code\PYGZgt{})\PYGZdq{}
\end{Verbatim}

Example of output:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} dmesg \textbar{} tail \PYGZhy{}n 1
dmatest: result dma0chan0\PYGZhy{}copy0: \PYGZsh{}1: No errors with src\PYGZus{}off=0x7bf dst\PYGZus{}off=0x8ad len=0x3fea (0)
\end{Verbatim}

The message format is unified across the different types of errors. A number in
the parens represents additional information, e.g. error code, error counter,
or status. A test thread also emits a summary line at completion listing the
number of tests executed, number that failed, and a result code.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} dmesg \textbar{} tail \PYGZhy{}n 1
dmatest: dma0chan0\PYGZhy{}copy0: summary 1 test, 0 failures 1000 iops 100000 KB/s (0)
\end{Verbatim}

The details of a data miscompare error are also emitted, but do not follow the
above format.


\section{PXA DMA documentation}
\label{driver-api/dmaengine/index:pxa-dma-documentation}
This book adds some notes about PXA DMA


\subsection{PXA/MMP - DMA Slave controller}
\label{driver-api/dmaengine/pxa_dma:pxa-mmp-dma-slave-controller}\label{driver-api/dmaengine/pxa_dma::doc}

\subsubsection{Constraints}
\label{driver-api/dmaengine/pxa_dma:constraints}
a) Transfers hot queuing
A driver submitting a transfer and issuing it should be granted the transfer
is queued even on a running DMA channel.
This implies that the queuing doesn't wait for the previous transfer end,
and that the descriptor chaining is not only done in the irq/tasklet code
triggered by the end of the transfer.
A transfer which is submitted and issued on a phy doesn't wait for a phy to
stop and restart, but is submitted on a ``running channel''. The other
drivers, especially mmp\_pdma waited for the phy to stop before relaunching
a new transfer.

b) All transfers having asked for confirmation should be signaled
Any issued transfer with DMA\_PREP\_INTERRUPT should trigger a callback call.
This implies that even if an irq/tasklet is triggered by end of tx1, but
at the time of irq/dma tx2 is already finished, tx1-\textgreater{}complete() and
tx2-\textgreater{}complete() should be called.

c) Channel running state
A driver should be able to query if a channel is running or not. For the
multimedia case, such as video capture, if a transfer is submitted and then
a check of the DMA channel reports a ``stopped channel'', the transfer should
not be issued until the next ``start of frame interrupt'', hence the need to
know if a channel is in running or stopped state.

d) Bandwidth guarantee
The PXA architecture has 4 levels of DMAs priorities : high, normal, low.
The high priorities get twice as much bandwidth as the normal, which get twice
as much as the low priorities.
A driver should be able to request a priority, especially the real-time
ones such as pxa\_camera with (big) throughputs.


\subsubsection{Design}
\label{driver-api/dmaengine/pxa_dma:design}
a) Virtual channels
Same concept as in sa11x0 driver, ie. a driver was assigned a ``virtual
channel'' linked to the requestor line, and the physical DMA channel is
assigned on the fly when the transfer is issued.
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Transfer anatomy for a scatter-gather transfer

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\textbar{} desc\PYGZhy{}sg[0] \textbar{} ... \textbar{} desc\PYGZhy{}sg[last] \textbar{} status updater \textbar{} finisher/linker \textbar{}
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{Verbatim}

This structure is pointed by dma-\textgreater{}sg\_cpu.
The descriptors are used as follows :
\begin{itemize}
\item {} 
desc-sg{[}i{]}: i-th descriptor, transferring the i-th sg
element to the video buffer scatter gather

\item {} 
status updater
Transfers a single u32 to a well known dma coherent memory to leave
a trace that this transfer is done. The ``well known'' is unique per
physical channel, meaning that a read of this value will tell which
is the last finished transfer at that point in time.

\item {} 
finisher: has ddadr=DADDR\_STOP, dcmd=ENDIRQEN

\item {} 
linker: has ddadr= desc-sg{[}0{]} of next transfer, dcmd=0

\end{itemize}

c) Transfers hot-chaining
Suppose the running chain is:

\begin{Verbatim}[commandchars=\\\{\}]
Buffer 1              Buffer 2
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\textbar{} d0 \textbar{} .. \textbar{} dN \textbar{} l \textbar{}  \textbar{} d0 \textbar{} .. \textbar{} dN \textbar{} f \textbar{}
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\textbar{}\PYGZhy{}+  \PYGZca{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+
                 \textbar{}    \textbar{}
                 +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{Verbatim}

After a call to dmaengine\_submit(b3), the chain will look like:

\begin{Verbatim}[commandchars=\\\{\}]
Buffer 1              Buffer 2              Buffer 3
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\textbar{} d0 \textbar{} .. \textbar{} dN \textbar{} l \textbar{}  \textbar{} d0 \textbar{} .. \textbar{} dN \textbar{} l \textbar{}  \textbar{} d0 \textbar{} .. \textbar{} dN \textbar{} f \textbar{}
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\textbar{}\PYGZhy{}+  \PYGZca{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\textbar{}\PYGZhy{}+  \PYGZca{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+
                 \textbar{}    \textbar{}                \textbar{}    \textbar{}
                 +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+                +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
                                      new\PYGZus{}link
\end{Verbatim}

If while new\_link was created the DMA channel stopped, it is \_not\_
restarted. Hot-chaining doesn't break the assumption that
dma\_async\_issue\_pending() is to be used to ensure the transfer is actually started.

One exception to this rule :
\begin{itemize}
\item {} 
if Buffer1 and Buffer2 had all their addresses 8 bytes aligned

\item {} 
and if Buffer3 has at least one address not 4 bytes aligned

\item {} 
then hot-chaining cannot happen, as the channel must be stopped, the
``align bit'' must be set, and the channel restarted As a consequence,
such a transfer tx\_submit() will be queued on the submitted queue, and
this specific case if the DMA is already running in aligned mode.

\end{itemize}

d) Transfers completion updater
Each time a transfer is completed on a channel, an interrupt might be
generated or not, up to the client's request. But in each case, the last
descriptor of a transfer, the ``status updater'', will write the latest
transfer being completed into the physical channel's completion mark.

This will speed up residue calculation, for large transfers such as video
buffers which hold around 6k descriptors or more. This also allows without
any lock to find out what is the latest completed transfer in a running
DMA chain.

e) Transfers completion, irq and tasklet
When a transfer flagged as ``DMA\_PREP\_INTERRUPT'' is finished, the dma irq
is raised. Upon this interrupt, a tasklet is scheduled for the physical
channel.

The tasklet is responsible for :
\begin{itemize}
\item {} 
reading the physical channel last updater mark

\item {} 
calling all the transfer callbacks of finished transfers, based on
that mark, and each transfer flags.

\end{itemize}

If a transfer is completed while this handling is done, a dma irq will
be raised, and the tasklet will be scheduled once again, having a new
updater mark.

f) Residue
Residue granularity will be descriptor based. The issued but not completed
transfers will be scanned for all of their descriptors against the
currently running descriptor.

g) Most complicated case of driver's tx queues
The most tricky situation is when :
\begin{quote}
\begin{itemize}
\item {} 
there are not ``acked'' transfers (tx0)

\item {} 
a driver submitted an aligned tx1, not chained

\item {} 
a driver submitted an aligned tx2 =\textgreater{} tx2 is cold chained to tx1

\item {} 
a driver issued tx1+tx2 =\textgreater{} channel is running in aligned mode

\item {} 
a driver submitted an aligned tx3 =\textgreater{} tx3 is hot-chained

\item {} 
a driver submitted an unaligned tx4 =\textgreater{} tx4 is put in submitted queue,
not chained

\item {} 
a driver issued tx4 =\textgreater{} tx4 is put in issued queue, not chained

\item {} 
a driver submitted an aligned tx5 =\textgreater{} tx5 is put in submitted queue, not
chained

\item {} 
a driver submitted an aligned tx6 =\textgreater{} tx6 is put in submitted queue,
cold chained to tx5

\end{itemize}

This translates into (after tx4 is issued) :
\begin{itemize}
\item {} 
issued queue

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+ +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+ +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+ +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\textbar{} tx1 \textbar{} \textbar{} tx2 \textbar{} \textbar{} tx3 \textbar{} \textbar{} tx4 \textbar{}
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}+ \PYGZca{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}+ \PYGZca{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+ +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
    \textbar{}   \textbar{}   \textbar{}   \textbar{}
    +\PYGZhy{}\PYGZhy{}\PYGZhy{}+   +\PYGZhy{}\PYGZhy{}\PYGZhy{}+
  \PYGZhy{} submitted queue
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+ +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\textbar{} tx5 \textbar{} \textbar{} tx6 \textbar{}
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}+ \PYGZca{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
    \textbar{}   \textbar{}
    +\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{Verbatim}
\end{quote}
\begin{itemize}
\item {} 
completed queue : empty

\item {} 
allocated queue : tx0

\end{itemize}

It should be noted that after tx3 is completed, the channel is stopped, and
restarted in ``unaligned mode'' to handle tx4.

Author: Robert Jarzmik \textless{}\href{mailto:robert.jarzmik@free.fr}{robert.jarzmik@free.fr}\textgreater{}


\chapter{Linux kernel SLIMbus support}
\label{driver-api/slimbus:linux-kernel-slimbus-support}\label{driver-api/slimbus::doc}

\section{Overview}
\label{driver-api/slimbus:overview}

\subsection{What is SLIMbus?}
\label{driver-api/slimbus:what-is-slimbus}
SLIMbus (Serial Low Power Interchip Media Bus) is a specification developed by
MIPI (Mobile Industry Processor Interface) alliance. The bus uses master/slave
configuration, and is a 2-wire multi-drop implementation (clock, and data).

Currently, SLIMbus is used to interface between application processors of SoCs
(System-on-Chip) and peripheral components (typically codec). SLIMbus uses
Time-Division-Multiplexing to accommodate multiple data channels, and
a control channel.

The control channel is used for various control functions such as bus
management, configuration and status updates. These messages can be unicast (e.g.
reading/writing device specific values), or multicast (e.g. data channel
reconfiguration sequence is a broadcast message announced to all devices)

A data channel is used for data-transfer between 2 SLIMbus devices. Data
channel uses dedicated ports on the device.


\subsection{Hardware description:}
\label{driver-api/slimbus:hardware-description}
SLIMbus specification has different types of device classifications based on
their capabilities.
A manager device is responsible for enumeration, configuration, and dynamic
channel allocation. Every bus has 1 active manager.

A generic device is a device providing application functionality (e.g. codec).

Framer device is responsible for clocking the bus, and transmitting frame-sync
and framing information on the bus.

Each SLIMbus component has an interface device for monitoring physical layer.

Typically each SoC contains SLIMbus component having 1 manager, 1 framer device,
1 generic device (for data channel support), and 1 interface device.
External peripheral SLIMbus component usually has 1 generic device (for
functionality/data channel support), and an associated interface device.
The generic device's registers are mapped as `value elements' so that they can
be written/read using SLIMbus control channel exchanging control/status type of
information.
In case there are multiple framer devices on the same bus, manager device is
responsible to select the active-framer for clocking the bus.

Per specification, SLIMbus uses ``clock gears'' to do power management based on
current frequency and bandwidth requirements. There are 10 clock gears and each
gear changes the SLIMbus frequency to be twice its previous gear.

Each device has a 6-byte enumeration-address and the manager assigns every
device with a 1-byte logical address after the devices report presence on the
bus.


\subsection{Software description:}
\label{driver-api/slimbus:software-description}
There are 2 types of SLIMbus drivers:

slim\_controller represents a `controller' for SLIMbus. This driver should
implement duties needed by the SoC (manager device, associated
interface device for monitoring the layers and reporting errors, default
framer device).

slim\_device represents the `generic device/component' for SLIMbus, and a
slim\_driver should implement driver for that slim\_device.


\subsection{Device notifications to the driver:}
\label{driver-api/slimbus:device-notifications-to-the-driver}
Since SLIMbus devices have mechanisms for reporting their presence, the
framework allows drivers to bind when corresponding devices report their
presence on the bus.
However, it is possible that the driver needs to be probed
first so that it can enable corresponding SLIMbus device (e.g. power it up and/or
take it out of reset). To support that behavior, the framework allows drivers
to probe first as well  (e.g. using standard DeviceTree compatibility field).
This creates the necessity for the driver to know when the device is functional
(i.e. reported present). device\_up callback is used for that reason when the
device reports present and is assigned a logical address by the controller.

Similarly, SLIMbus devices `report absent' when they go down. A `device\_down'
callback notifies the driver when the device reports absent and its logical
address assignment is invalidated by the controller.

Another notification ``boot\_device'' is used to notify the slim\_driver when
controller resets the bus. This notification allows the driver to take necessary
steps to boot the device so that it's functional after the bus has been reset.


\subsection{Driver and Controller APIs:}
\label{driver-api/slimbus:driver-and-controller-apis}\index{slim\_eaddr (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_eaddr}\pysigline{struct \bfcode{slim\_eaddr}}
Enumeration address for a SLIMbus device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct slim\PYGZus{}eaddr \PYGZob{}
  u16 manf\PYGZus{}id;
  u16 prod\PYGZus{}code;
  u8 dev\PYGZus{}index;
  u8 instance;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{manf\_id}}] \leavevmode
Manufacturer Id for the device

\item[{\code{prod\_code}}] \leavevmode
Product code

\item[{\code{dev\_index}}] \leavevmode
Device index

\item[{\code{instance}}] \leavevmode
Instance value

\end{description}
\index{slim\_device\_status (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_device_status}\pysigline{enum \bfcode{slim\_device\_status}}
slim device status

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{SLIM\_DEVICE\_STATUS\_DOWN}}] \leavevmode
Slim device is absent or not reported yet.

\item[{\code{SLIM\_DEVICE\_STATUS\_UP}}] \leavevmode
Slim device is announced on the bus.

\item[{\code{SLIM\_DEVICE\_STATUS\_RESERVED}}] \leavevmode
Reserved for future use.

\end{description}
\index{slim\_device (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_device}\pysigline{struct \bfcode{slim\_device}}
Slim device handle.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct slim\PYGZus{}device \PYGZob{}
  struct device           dev;
  struct slim\PYGZus{}eaddr       e\PYGZus{}addr;
  struct slim\PYGZus{}controller  *ctrl;
  enum slim\PYGZus{}device\PYGZus{}status status;
  u8 laddr;
  bool is\PYGZus{}laddr\PYGZus{}valid;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev}}] \leavevmode
Driver model representation of the device.

\item[{\code{e\_addr}}] \leavevmode
Enumeration address of this device.

\item[{\code{ctrl}}] \leavevmode
slim controller instance.

\item[{\code{status}}] \leavevmode
slim device status

\item[{\code{laddr}}] \leavevmode
1-byte Logical address of this device.

\item[{\code{is\_laddr\_valid}}] \leavevmode
indicates if the laddr is valid or not

\end{description}

\textbf{Description}

This is the client/device handle returned when a SLIMbus
device is registered with a controller.
Pointer to this structure is used by client-driver as a handle.
\index{slim\_driver (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_driver}\pysigline{struct \bfcode{slim\_driver}}
SLIMbus `generic device' (slave) device driver (similar to `spi\_device' on SPI)

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct slim\PYGZus{}driver \PYGZob{}
  int (*probe)(struct slim\PYGZus{}device *sl);
  void (*remove)(struct slim\PYGZus{}device *sl);
  void (*shutdown)(struct slim\PYGZus{}device *sl);
  int (*device\PYGZus{}status)(struct slim\PYGZus{}device *sl, enum slim\PYGZus{}device\PYGZus{}status s);
  struct device\PYGZus{}driver            driver;
  const struct slim\PYGZus{}device\PYGZus{}id     *id\PYGZus{}table;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{probe}}] \leavevmode
Binds this driver to a SLIMbus device.

\item[{\code{remove}}] \leavevmode
Unbinds this driver from the SLIMbus device.

\item[{\code{shutdown}}] \leavevmode
Standard shutdown callback used during powerdown/halt.

\item[{\code{device\_status}}] \leavevmode
This callback is called when
- The device reports present and gets a laddr assigned
- The device reports absent, or the bus goes down.

\item[{\code{driver}}] \leavevmode
SLIMbus device drivers should initialize name and owner field of
this structure

\item[{\code{id\_table}}] \leavevmode
List of SLIMbus devices supported by this driver

\end{description}
\index{slim\_val\_inf (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_val_inf}\pysigline{struct \bfcode{slim\_val\_inf}}
Slimbus value or information element

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct slim\PYGZus{}val\PYGZus{}inf \PYGZob{}
  u16 start\PYGZus{}offset;
  u8 num\PYGZus{}bytes;
  u8 *rbuf;
  const u8                *wbuf;
  struct completion      *comp;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{start\_offset}}] \leavevmode
Specifies starting offset in information/value element map

\item[{\code{num\_bytes}}] \leavevmode
upto 16. This ensures that the message will fit the slicesize
per SLIMbus spec

\item[{\code{rbuf}}] \leavevmode
buffer to read the values

\item[{\code{wbuf}}] \leavevmode
buffer to write

\item[{\code{comp}}] \leavevmode
completion for asynchronous operations, valid only if TID is
required for transaction, like REQUEST operations.
Rest of the transactions are synchronous anyway.

\end{description}
\index{module\_slim\_driver (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.module_slim_driver}\pysiglinewithargsret{\bfcode{module\_slim\_driver}}{\emph{\_\_slim\_driver}}{}
Helper macro for registering a SLIMbus driver

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_slim\_driver}}] \leavevmode
slimbus\_driver struct

\end{description}

\textbf{Description}

Helper macro for SLIMbus drivers which do not do anything special in module
init/exit. This eliminates a lot of boilerplate. Each module may only
use this macro once, and calling it replaces {\hyperref[driver\string-api/basics:c.module_init]{\emph{\code{module\_init()}}}} and {\hyperref[driver\string-api/basics:c.module_exit]{\emph{\code{module\_exit()}}}}
\index{slim\_framer (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_framer}\pysigline{struct \bfcode{slim\_framer}}
Represents SLIMbus framer. Every controller may have multiple framers. There is 1 active framer device responsible for clocking the bus. Manager is responsible for framer hand-over.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct slim\PYGZus{}framer \PYGZob{}
  struct device           dev;
  struct slim\PYGZus{}eaddr       e\PYGZus{}addr;
  int rootfreq;
  int superfreq;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev}}] \leavevmode
Driver model representation of the device.

\item[{\code{e\_addr}}] \leavevmode
Enumeration address of the framer.

\item[{\code{rootfreq}}] \leavevmode
Root Frequency at which the framer can run. This is maximum
frequency (`clock gear 10') at which the bus can operate.

\item[{\code{superfreq}}] \leavevmode
Superframes per root frequency. Every frame is 6144 bits.

\end{description}
\index{slim\_msg\_txn (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_msg_txn}\pysigline{struct \bfcode{slim\_msg\_txn}}
Message to be sent by the controller. This structure has packet header, payload and buffer to be filled (if any)

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct slim\PYGZus{}msg\PYGZus{}txn \PYGZob{}
  u8 rl;
  u8 mt;
  u8 mc;
  u8 dt;
  u16 ec;
  u8 tid;
  u8 la;
  struct slim\PYGZus{}val\PYGZus{}inf     *msg;
  struct completion      *comp;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{rl}}] \leavevmode
Header field. remaining length.

\item[{\code{mt}}] \leavevmode
Header field. Message type.

\item[{\code{mc}}] \leavevmode
Header field. LSB is message code for type mt.

\item[{\code{dt}}] \leavevmode
Header field. Destination type.

\item[{\code{ec}}] \leavevmode
Element code. Used for elemental access APIs.

\item[{\code{tid}}] \leavevmode
Transaction ID. Used for messages expecting response.
(relevant for message-codes involving read operation)

\item[{\code{la}}] \leavevmode
Logical address of the device this message is going to.
(Not used when destination type is broadcast.)

\item[{\code{msg}}] \leavevmode
Elemental access message to be read/written

\item[{\code{comp}}] \leavevmode
completion if read/write is synchronous, used internally
for tid based transactions.

\end{description}
\index{slim\_clk\_state (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_clk_state}\pysigline{enum \bfcode{slim\_clk\_state}}
\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{SLIM\_CLK\_ACTIVE}}] \leavevmode
SLIMbus clock is active

\item[{\code{SLIM\_CLK\_ENTERING\_PAUSE}}] \leavevmode
SLIMbus clock pause sequence is being sent on the
bus. If this succeeds, state changes to SLIM\_CLK\_PAUSED. If the
transition fails, state changes back to SLIM\_CLK\_ACTIVE

\item[{\code{SLIM\_CLK\_PAUSED}}] \leavevmode
SLIMbus controller clock has paused.

\end{description}

\textbf{Description}
\begin{quote}

maintaining current clock state.
\end{quote}
\index{slim\_sched (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_sched}\pysigline{struct \bfcode{slim\_sched}}
\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct slim\PYGZus{}sched \PYGZob{}
  enum slim\PYGZus{}clk\PYGZus{}state     clk\PYGZus{}state;
  struct completion       pause\PYGZus{}comp;
  struct mutex            m\PYGZus{}reconf;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{clk\_state}}] \leavevmode
Controller's clock state from enum slim\_clk\_state

\item[{\code{pause\_comp}}] \leavevmode
Signals completion of clock pause sequence. This is useful when
client tries to call SLIMbus transaction when controller is entering
clock pause.

\item[{\code{m\_reconf}}] \leavevmode
This mutex is held until current reconfiguration (data channel
scheduling, message bandwidth reservation) is done. Message APIs can
use the bus concurrently when this mutex is held since elemental access
messages can be sent on the bus when reconfiguration is in progress.

\end{description}
\index{slim\_controller (C type)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_controller}\pysigline{struct \bfcode{slim\_controller}}
Controls every instance of SLIMbus (similar to `master' on SPI)

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct slim\PYGZus{}controller \PYGZob{}
  struct device           *dev;
  unsigned int            id;
  char name[SLIMBUS\PYGZus{}NAME\PYGZus{}SIZE];
  int min\PYGZus{}cg;
  int max\PYGZus{}cg;
  int clkgear;
  struct ida              laddr\PYGZus{}ida;
  struct slim\PYGZus{}framer      *a\PYGZus{}framer;
  struct mutex            lock;
  struct list\PYGZus{}head        devices;
  struct idr              tid\PYGZus{}idr;
  spinlock\PYGZus{}t txn\PYGZus{}lock;
  struct slim\PYGZus{}sched       sched;
  int (*xfer\PYGZus{}msg)(struct slim\PYGZus{}controller *ctrl, struct slim\PYGZus{}msg\PYGZus{}txn *tx);
  int (*set\PYGZus{}laddr)(struct slim\PYGZus{}controller *ctrl, struct slim\PYGZus{}eaddr *ea, u8 laddr);
  int (*get\PYGZus{}laddr)(struct slim\PYGZus{}controller *ctrl, struct slim\PYGZus{}eaddr *ea, u8 *laddr);
  int (*wakeup)(struct slim\PYGZus{}controller *ctrl);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{dev}}] \leavevmode
Device interface to this driver

\item[{\code{id}}] \leavevmode
Board-specific number identifier for this controller/bus

\item[{\code{name}}] \leavevmode
Name for this controller

\item[{\code{min\_cg}}] \leavevmode
Minimum clock gear supported by this controller (default value: 1)

\item[{\code{max\_cg}}] \leavevmode
Maximum clock gear supported by this controller (default value: 10)

\item[{\code{clkgear}}] \leavevmode
Current clock gear in which this bus is running

\item[{\code{laddr\_ida}}] \leavevmode
logical address id allocator

\item[{\code{a\_framer}}] \leavevmode
Active framer which is clocking the bus managed by this controller

\item[{\code{lock}}] \leavevmode
Mutex protecting controller data structures

\item[{\code{devices}}] \leavevmode
Slim device list

\item[{\code{tid\_idr}}] \leavevmode
tid id allocator

\item[{\code{txn\_lock}}] \leavevmode
Lock to protect table of transactions

\item[{\code{sched}}] \leavevmode
scheduler structure used by the controller

\item[{\code{xfer\_msg}}] \leavevmode
Transfer a message on this controller (this can be a broadcast
control/status message like data channel setup, or a unicast message
like value element read/write.

\item[{\code{set\_laddr}}] \leavevmode
Setup logical address at laddr for the slave with elemental
address e\_addr. Drivers implementing controller will be expected to
send unicast message to this device with its logical address.

\item[{\code{get\_laddr}}] \leavevmode
It is possible that controller needs to set fixed logical
address table and get\_laddr can be used in that case so that controller
can do this assignment. Use case is when the master is on the remote
processor side, who is resposible for allocating laddr.

\item[{\code{wakeup}}] \leavevmode
This function pointer implements controller-specific procedure
to wake it up from clock-pause. Framework will call this to bring
the controller out of clock pause.

\end{description}

\textbf{Description}
\begin{quote}

`Manager device' is responsible for  device management, bandwidth
allocation, channel setup, and port associations per channel.
Device management means Logical address assignment/removal based on
enumeration (report-present, report-absent) of a device.
Bandwidth allocation is done dynamically by the manager based on active
channels on the bus, message-bandwidth requests made by SLIMbus devices.
Based on current bandwidth usage, manager chooses a frequency to run
the bus at (in steps of `clock-gear', 1 through 10, each clock gear
representing twice the frequency than the previous gear).
Manager is also responsible for entering (and exiting) low-power-mode
(known as `clock pause').
Manager can do handover of framer if there are multiple framers on the
bus and a certain usecase warrants using certain framer to avoid keeping
previous framer being powered-on.

Controller here performs duties of the manager device, and `interface
device'. Interface device is responsible for monitoring the bus and
reporting information such as loss-of-synchronization, data
slot-collision.
\end{quote}
\index{slim\_unregister\_controller (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_unregister_controller}\pysiglinewithargsret{int \bfcode{slim\_unregister\_controller}}{struct {\hyperref[driver\string-api/slimbus:c.slim_controller]{\emph{slim\_controller}}} *\emph{ ctrl}}{}
Controller tear-down.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct slim\_controller * ctrl}}] \leavevmode
Controller to tear-down.

\end{description}
\index{slim\_report\_absent (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_report_absent}\pysiglinewithargsret{void \bfcode{slim\_report\_absent}}{struct {\hyperref[driver\string-api/slimbus:c.slim_device]{\emph{slim\_device}}} *\emph{ sbdev}}{}
Controller calls this function when a device reports absent, OR when the device cannot be communicated with

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct slim\_device * sbdev}}] \leavevmode
Device that cannot be reached, or sent report absent

\end{description}
\index{slim\_get\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_get_device}\pysiglinewithargsret{struct {\hyperref[driver\string-api/slimbus:c.slim_device]{\emph{slim\_device}}} * \bfcode{slim\_get\_device}}{struct {\hyperref[driver\string-api/slimbus:c.slim_controller]{\emph{slim\_controller}}} *\emph{ ctrl}, struct {\hyperref[driver\string-api/slimbus:c.slim_eaddr]{\emph{slim\_eaddr}}} *\emph{ e\_addr}}{}
get handle to a device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct slim\_controller * ctrl}}] \leavevmode
Controller on which this device will be added/queried

\item[{\code{struct slim\_eaddr * e\_addr}}] \leavevmode
Enumeration address of the device to be queried

\end{description}

\textbf{Return}

pointer to a device if it has already reported. Creates a new
device and returns pointer to it if the device has not yet enumerated.
\index{slim\_device\_report\_present (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_device_report_present}\pysiglinewithargsret{int \bfcode{slim\_device\_report\_present}}{struct {\hyperref[driver\string-api/slimbus:c.slim_controller]{\emph{slim\_controller}}} *\emph{ ctrl}, struct {\hyperref[driver\string-api/slimbus:c.slim_eaddr]{\emph{slim\_eaddr}}} *\emph{ e\_addr}, u8 *\emph{ laddr}}{}
Report enumerated device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct slim\_controller * ctrl}}] \leavevmode
Controller with which device is enumerated.

\item[{\code{struct slim\_eaddr * e\_addr}}] \leavevmode
Enumeration address of the device.

\item[{\code{u8 * laddr}}] \leavevmode
Return logical address (if valid flag is false)

\end{description}

\textbf{Description}

Called by controller in response to REPORT\_PRESENT. Framework will assign
a logical address to this enumeration address.
Function returns -EXFULL to indicate that all logical addresses are already
taken.
\index{slim\_get\_logical\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_get_logical_addr}\pysiglinewithargsret{int \bfcode{slim\_get\_logical\_addr}}{struct {\hyperref[driver\string-api/slimbus:c.slim_device]{\emph{slim\_device}}} *\emph{ sbdev}}{}
get/allocate logical address of a SLIMbus device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct slim\_device * sbdev}}] \leavevmode
client handle requesting the address.

\end{description}

\textbf{Return}

zero if a logical address is valid or a new logical address
has been assigned. error code in case of error.


\subsection{Clock-pause:}
\label{driver-api/slimbus:clock-pause}
SLIMbus mandates that a reconfiguration sequence (known as clock-pause) be
broadcast to all active devices on the bus before the bus can enter low-power
mode. Controller uses this sequence when it decides to enter low-power mode so
that corresponding clocks and/or power-rails can be turned off to save power.
Clock-pause is exited by waking up framer device (if controller driver initiates
exiting low power mode), or by toggling the data line (if a slave device wants
to initiate it).


\subsubsection{Clock-pause APIs:}
\label{driver-api/slimbus:clock-pause-apis}\index{slim\_ctrl\_clk\_pause (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_ctrl_clk_pause}\pysiglinewithargsret{int \bfcode{slim\_ctrl\_clk\_pause}}{struct {\hyperref[driver\string-api/slimbus:c.slim_controller]{\emph{slim\_controller}}} *\emph{ ctrl}, bool\emph{ wakeup}, u8\emph{ restart}}{}
Called by slimbus controller to enter/exit `clock pause'

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct slim\_controller * ctrl}}] \leavevmode
controller requesting bus to be paused or woken up

\item[{\code{bool wakeup}}] \leavevmode
Wakeup this controller from clock pause.

\item[{\code{u8 restart}}] \leavevmode
Restart time value per spec used for clock pause. This value
isn't used when controller is to be woken up.

\end{description}

\textbf{Description}

Slimbus specification needs this sequence to turn-off clocks for the bus.
The sequence involves sending 3 broadcast messages (reconfiguration
sequence) to inform all devices on the bus.
To exit clock-pause, controller typically wakes up active framer device.
This API executes clock pause reconfiguration sequence if wakeup is false.
If wakeup is true, controller's wakeup is called.
For entering clock-pause, -EBUSY is returned if a message txn in pending.


\subsection{Messaging:}
\label{driver-api/slimbus:messaging}
The framework supports regmap and read/write apis to exchange control-information
with a SLIMbus device. APIs can be synchronous or asynchronous.
The header file \textless{}linux/slimbus.h\textgreater{} has more documentation about messaging APIs.


\subsubsection{Messaging APIs:}
\label{driver-api/slimbus:messaging-apis}\index{slim\_msg\_response (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_msg_response}\pysiglinewithargsret{void \bfcode{slim\_msg\_response}}{struct {\hyperref[driver\string-api/slimbus:c.slim_controller]{\emph{slim\_controller}}} *\emph{ ctrl}, u8 *\emph{ reply}, u8\emph{ tid}, u8\emph{ len}}{}
Deliver Message response received from a device to the framework.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct slim\_controller * ctrl}}] \leavevmode
Controller handle

\item[{\code{u8 * reply}}] \leavevmode
Reply received from the device

\item[{\code{u8 tid}}] \leavevmode
Transaction ID received with which framework can associate reply.

\item[{\code{u8 len}}] \leavevmode
Length of the reply

\end{description}

\textbf{Description}

Called by controller to inform framework about the response received.
This helps in making the API asynchronous, and controller-driver doesn't need
to manage 1 more table other than the one managed by framework mapping TID
with buffers
\index{slim\_do\_transfer (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_do_transfer}\pysiglinewithargsret{int \bfcode{slim\_do\_transfer}}{struct {\hyperref[driver\string-api/slimbus:c.slim_controller]{\emph{slim\_controller}}} *\emph{ ctrl}, struct {\hyperref[driver\string-api/slimbus:c.slim_msg_txn]{\emph{slim\_msg\_txn}}} *\emph{ txn}}{}
Process a SLIMbus-messaging transaction

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct slim\_controller * ctrl}}] \leavevmode
Controller handle

\item[{\code{struct slim\_msg\_txn * txn}}] \leavevmode
Transaction to be sent over SLIMbus

\end{description}

\textbf{Description}

Called by controller to transmit messaging transactions not dealing with
Interface/Value elements. (e.g. transmittting a message to assign logical
address to a slave device

\textbf{Return}
\begin{description}
\item[{-ETIMEDOUT: If transmission of this message timed out}] \leavevmode
(e.g. due to bus lines not being clocked or driven by controller)

\end{description}
\index{slim\_xfer\_msg (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_xfer_msg}\pysiglinewithargsret{int \bfcode{slim\_xfer\_msg}}{struct {\hyperref[driver\string-api/slimbus:c.slim_device]{\emph{slim\_device}}} *\emph{ sbdev}, struct {\hyperref[driver\string-api/slimbus:c.slim_val_inf]{\emph{slim\_val\_inf}}} *\emph{ msg}, u8\emph{ mc}}{}
Transfer a value info message on slim device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct slim\_device * sbdev}}] \leavevmode
slim device to which this msg has to be transfered

\item[{\code{struct slim\_val\_inf * msg}}] \leavevmode
value info message pointer

\item[{\code{u8 mc}}] \leavevmode
message code of the message

\end{description}

\textbf{Description}

Called by drivers which want to transfer a vlaue or info elements.

\textbf{Return}

-ETIMEDOUT: If transmission of this message timed out
\index{slim\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_read}\pysiglinewithargsret{int \bfcode{slim\_read}}{struct {\hyperref[driver\string-api/slimbus:c.slim_device]{\emph{slim\_device}}} *\emph{ sdev}, u32\emph{ addr}, size\_t\emph{ count}, u8 *\emph{ val}}{}
Read SLIMbus value element

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct slim\_device * sdev}}] \leavevmode
client handle.

\item[{\code{u32 addr}}] \leavevmode
address of value element to read.

\item[{\code{size\_t count}}] \leavevmode
number of bytes to read. Maximum bytes allowed are 16.

\item[{\code{u8 * val}}] \leavevmode
will return what the value element value was

\end{description}

\textbf{Return}

-EINVAL for Invalid parameters, -ETIMEDOUT If transmission of
this message timed out (e.g. due to bus lines not being clocked
or driven by controller)
\index{slim\_readb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_readb}\pysiglinewithargsret{int \bfcode{slim\_readb}}{struct {\hyperref[driver\string-api/slimbus:c.slim_device]{\emph{slim\_device}}} *\emph{ sdev}, u32\emph{ addr}}{}
Read byte from SLIMbus value element

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct slim\_device * sdev}}] \leavevmode
client handle.

\item[{\code{u32 addr}}] \leavevmode
address in the value element to read.

\end{description}

\textbf{Return}

byte value of value element.
\index{slim\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_write}\pysiglinewithargsret{int \bfcode{slim\_write}}{struct {\hyperref[driver\string-api/slimbus:c.slim_device]{\emph{slim\_device}}} *\emph{ sdev}, u32\emph{ addr}, size\_t\emph{ count}, u8 *\emph{ val}}{}
Write SLIMbus value element

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct slim\_device * sdev}}] \leavevmode
client handle.

\item[{\code{u32 addr}}] \leavevmode
address in the value element to write.

\item[{\code{size\_t count}}] \leavevmode
number of bytes to write. Maximum bytes allowed are 16.

\item[{\code{u8 * val}}] \leavevmode
value to write to value element

\end{description}

\textbf{Return}

-EINVAL for Invalid parameters, -ETIMEDOUT If transmission of
this message timed out (e.g. due to bus lines not being clocked
or driven by controller)
\index{slim\_writeb (C function)}

\begin{fulllineitems}
\phantomsection\label{driver-api/slimbus:c.slim_writeb}\pysiglinewithargsret{int \bfcode{slim\_writeb}}{struct {\hyperref[driver\string-api/slimbus:c.slim_device]{\emph{slim\_device}}} *\emph{ sdev}, u32\emph{ addr}, u8\emph{ value}}{}
Write byte to SLIMbus value element

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct slim\_device * sdev}}] \leavevmode
client handle.

\item[{\code{u32 addr}}] \leavevmode
address of value element to write.

\item[{\code{u8 value}}] \leavevmode
value to write to value element

\end{description}

\textbf{Return}

-EINVAL for Invalid parameters, -ETIMEDOUT If transmission of
this message timed out (e.g. due to bus lines not being clocked
or driven by controller)


\chapter{SoundWire Documentation}
\label{driver-api/soundwire/index:soundwire-documentation}\label{driver-api/soundwire/index::doc}

\section{SoundWire Subsystem Summary}
\label{driver-api/soundwire/summary:soundwire-subsystem-summary}\label{driver-api/soundwire/summary::doc}
SoundWire is a new interface ratified in 2015 by the MIPI Alliance.
SoundWire is used for transporting data typically related to audio
functions. SoundWire interface is optimized to integrate audio devices in
mobile or mobile inspired systems.

SoundWire is a 2-pin multi-drop interface with data and clock line. It
facilitates development of low cost, efficient, high performance systems.
Broad level key features of SoundWire interface include:
\begin{enumerate}
\item {} 
Transporting all of payload data channels, control information, and setup
commands over a single two-pin interface.

\item {} 
Lower clock frequency, and hence lower power consumption, by use of DDR
(Dual Data Rate) data transmission.

\item {} 
Clock scaling and optional multiple data lanes to give wide flexibility
in data rate to match system requirements.

\item {} 
Device status monitoring, including interrupt-style alerts to the Master.

\end{enumerate}

The SoundWire protocol supports up to eleven Slave interfaces. All the
interfaces share the common Bus containing data and clock line. Each of the
Slaves can support up to 14 Data Ports. 13 Data Ports are dedicated to audio
transport. Data Port0 is dedicated to transport of Bulk control information,
each of the audio Data Ports (1..14) can support up to 8 Channels in
transmit or receiving mode (typically fixed direction but configurable
direction is enabled by the specification).  Bandwidth restrictions to
\textasciitilde{}19.2..24.576Mbits/s don't however allow for 11*13*8 channels to be
transmitted simultaneously.

Below figure shows an example of connectivity between a SoundWire Master and
two Slave devices.

\begin{Verbatim}[commandchars=\\\{\}]
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+                                       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\textbar{}               \textbar{}                       Clock Signal    \textbar{}               \textbar{}
\textbar{}    Master     \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    Slave      \textbar{}
\textbar{}   Interface   \textbar{}       \textbar{}               Data Signal     \textbar{}  Interface 1  \textbar{}
\textbar{}               \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}               \textbar{}
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+       \textbar{}       \textbar{}                       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
                        \textbar{}       \textbar{}
                        \textbar{}       \textbar{}
                        \textbar{}       \textbar{}
                     +\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}+
                     \textbar{}             \textbar{}
                     \textbar{}   Slave     \textbar{}
                     \textbar{} Interface 2 \textbar{}
                     \textbar{}             \textbar{}
                     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{Verbatim}


\subsection{Terminology}
\label{driver-api/soundwire/summary:terminology}
The MIPI SoundWire specification uses the term `device' to refer to a Master
or Slave interface, which of course can be confusing. In this summary and
code we use the term interface only to refer to the hardware. We follow the
Linux device model by mapping each Slave interface connected on the bus as a
device managed by a specific driver. The Linux SoundWire subsystem provides
a framework to implement a SoundWire Slave driver with an API allowing
3rd-party vendors to enable implementation-defined functionality while
common setup/configuration tasks are handled by the bus.

Bus:
Implements SoundWire Linux Bus which handles the SoundWire protocol.
Programs all the MIPI-defined Slave registers. Represents a SoundWire
Master. Multiple instances of Bus may be present in a system.

Slave:
Registers as SoundWire Slave device (Linux Device). Multiple Slave devices
can register to a Bus instance.

Slave driver:
Driver controlling the Slave device. MIPI-specified registers are controlled
directly by the Bus (and transmitted through the Master driver/interface).
Any implementation-defined Slave register is controlled by Slave driver. In
practice, it is expected that the Slave driver relies on regmap and does not
request direct register access.


\subsection{Programming interfaces (SoundWire Master interface Driver)}
\label{driver-api/soundwire/summary:programming-interfaces-soundwire-master-interface-driver}
SoundWire Bus supports programming interfaces for the SoundWire Master
implementation and SoundWire Slave devices. All the code uses the ``sdw''
prefix commonly used by SoC designers and 3rd party vendors.

Each of the SoundWire Master interfaces needs to be registered to the Bus.
Bus implements API to read standard Master MIPI properties and also provides
callback in Master ops for Master driver to implement its own functions that
provides capabilities information. DT support is not implemented at this
time but should be trivial to add since capabilities are enabled with the
\code{device\_property\_} API.

The Master interface along with the Master interface capabilities are
registered based on board file, DT or ACPI.

Following is the Bus API to register the SoundWire Bus:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{sdw\PYGZus{}add\PYGZus{}bus\PYGZus{}master}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{sdw\PYGZus{}bus} \PYG{o}{*}\PYG{n}{bus}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{bus}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{dev}\PYG{p}{)}
                \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{n}{ENODEV}\PYG{p}{;}

        \PYG{n}{mutex\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{bus}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lock}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{INIT\PYGZus{}LIST\PYGZus{}HEAD}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{bus}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{slaves}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+cm}{/* Check ACPI for Slave devices */}
        \PYG{n}{sdw\PYGZus{}acpi\PYGZus{}find\PYGZus{}slaves}\PYG{p}{(}\PYG{n}{bus}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+cm}{/* Check DT for Slave devices */}
        \PYG{n}{sdw\PYGZus{}of\PYGZus{}find\PYGZus{}slaves}\PYG{p}{(}\PYG{n}{bus}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This will initialize sdw\_bus object for Master device. ``sdw\_master\_ops'' and
``sdw\_master\_port\_ops'' callback functions are provided to the Bus.

``sdw\_master\_ops'' is used by Bus to control the Bus in the hardware specific
way. It includes Bus control functions such as sending the SoundWire
read/write messages on Bus, setting up clock frequency \& Stream
Synchronization Point (SSP). The ``sdw\_master\_ops'' structure abstracts the
hardware details of the Master from the Bus.

``sdw\_master\_port\_ops'' is used by Bus to setup the Port parameters of the
Master interface Port. Master interface Port register map is not defined by
MIPI specification, so Bus calls the ``sdw\_master\_port\_ops'' callback
function to do Port operations like ``Port Prepare'', ``Port Transport params
set'', ``Port enable and disable''. The implementation of the Master driver can
then perform hardware-specific configurations.


\subsection{Programming interfaces (SoundWire Slave Driver)}
\label{driver-api/soundwire/summary:programming-interfaces-soundwire-slave-driver}
The MIPI specification requires each Slave interface to expose a unique
48-bit identifier, stored in 6 read-only dev\_id registers. This dev\_id
identifier contains vendor and part information, as well as a field enabling
to differentiate between identical components. An additional class field is
currently unused. Slave driver is written for a specific vendor and part
identifier, Bus enumerates the Slave device based on these two ids.
Slave device and driver match is done based on these two ids . Probe
of the Slave driver is called by Bus on successful match between device and
driver id. A parent/child relationship is enforced between Master and Slave
devices (the logical representation is aligned with the physical
connectivity).

The information on Master/Slave dependencies is stored in platform data,
board-file, ACPI or DT. The MIPI Software specification defines additional
link\_id parameters for controllers that have multiple Master interfaces. The
dev\_id registers are only unique in the scope of a link, and the link\_id
unique in the scope of a controller. Both dev\_id and link\_id are not
necessarily unique at the system level but the parent/child information is
used to avoid ambiguity.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k}{const} \PYG{k}{struct} \PYG{n}{sdw\PYGZus{}device\PYGZus{}id} \PYG{n}{slave\PYGZus{}id}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}
        \PYG{n}{SDW\PYGZus{}SLAVE\PYGZus{}ENTRY}\PYG{p}{(}\PYG{l+m+mh}{0x025d}\PYG{p}{,} \PYG{l+m+mh}{0x700}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{MODULE\PYGZus{}DEVICE\PYGZus{}TABLE}\PYG{p}{(}\PYG{n}{sdw}\PYG{p}{,} \PYG{n}{slave\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{static} \PYG{k}{struct} \PYG{n}{sdw\PYGZus{}driver} \PYG{n}{slave\PYGZus{}sdw\PYGZus{}driver} \PYG{o}{=} \PYG{p}{\PYGZob{}}
        \PYG{p}{.}\PYG{n}{driver} \PYG{o}{=} \PYG{p}{\PYGZob{}}
                   \PYG{p}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{slave\PYGZus{}xxx}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
                   \PYG{p}{.}\PYG{n}{pm} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{slave\PYGZus{}runtime\PYGZus{}pm}\PYG{p}{,}
                   \PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{probe} \PYG{o}{=} \PYG{n}{slave\PYGZus{}sdw\PYGZus{}probe}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{remove} \PYG{o}{=} \PYG{n}{slave\PYGZus{}sdw\PYGZus{}remove}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{ops} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{slave\PYGZus{}slave\PYGZus{}ops}\PYG{p}{,}
        \PYG{p}{.}\PYG{n}{id\PYGZus{}table} \PYG{o}{=} \PYG{n}{slave\PYGZus{}id}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

For capabilities, Bus implements API to read standard Slave MIPI properties
and also provides callback in Slave ops for Slave driver to implement own
function that provides capabilities information. Bus needs to know a set of
Slave capabilities to program Slave registers and to control the Bus
reconfigurations.


\subsection{Future enhancements to be done}
\label{driver-api/soundwire/summary:future-enhancements-to-be-done}\begin{enumerate}
\item {} 
Bulk Register Access (BRA) transfers.

\item {} 
Multiple data lane support.

\end{enumerate}


\subsection{Links}
\label{driver-api/soundwire/summary:links}
SoundWire MIPI specification 1.1 is available at:
\href{https://members.mipi.org/wg/All-Members/document/70290}{https://members.mipi.org/wg/All-Members/document/70290}

SoundWire MIPI DisCo (Discovery and Configuration) specification is
available at:
\href{https://www.mipi.org/specifications/mipi-disco-soundwire}{https://www.mipi.org/specifications/mipi-disco-soundwire}

(publicly accessible with registration or directly accessible to MIPI
members)

MIPI Alliance Manufacturer ID Page: mid.mipi.org



\renewcommand{\indexname}{Index}
\printindex
\end{document}
