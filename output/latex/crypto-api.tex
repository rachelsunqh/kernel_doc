% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,8pt,english]{sphinxmanual}


\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }


	% Use some font with UTF-8 support with XeLaTeX
        \usepackage{fontspec}
        \setsansfont{DejaVu Serif}
        \setromanfont{DejaVu Sans}
        \setmonofont{DejaVu Sans Mono}

     \usepackage[margin=0.5in, top=1in, bottom=1in]{geometry}
        \usepackage{ifthen}

        % Put notes in color and let them be inside a table
	\definecolor{NoteColor}{RGB}{204,255,255}
	\definecolor{WarningColor}{RGB}{255,204,204}
	\definecolor{AttentionColor}{RGB}{255,255,204}
	\definecolor{ImportantColor}{RGB}{192,255,204}
	\definecolor{OtherColor}{RGB}{204,204,204}
        \newlength{\mynoticelength}
        \makeatletter\newenvironment{coloredbox}[1]{%
	   \setlength{\fboxrule}{1pt}
	   \setlength{\fboxsep}{7pt}
	   \setlength{\mynoticelength}{\linewidth}
	   \addtolength{\mynoticelength}{-2\fboxsep}
	   \addtolength{\mynoticelength}{-2\fboxrule}
           \begin{lrbox}{\@tempboxa}\begin{minipage}{\mynoticelength}}{\end{minipage}\end{lrbox}%
	   \ifthenelse%
	      {\equal{\py@noticetype}{note}}%
	      {\colorbox{NoteColor}{\usebox{\@tempboxa}}}%
	      {%
	         \ifthenelse%
	         {\equal{\py@noticetype}{warning}}%
	         {\colorbox{WarningColor}{\usebox{\@tempboxa}}}%
		 {%
	            \ifthenelse%
	            {\equal{\py@noticetype}{attention}}%
	            {\colorbox{AttentionColor}{\usebox{\@tempboxa}}}%
		    {%
	               \ifthenelse%
	               {\equal{\py@noticetype}{important}}%
	               {\colorbox{ImportantColor}{\usebox{\@tempboxa}}}%
	               {\colorbox{OtherColor}{\usebox{\@tempboxa}}}%
		    }%
		 }%
	      }%
        }\makeatother

        \makeatletter
        \renewenvironment{notice}[2]{%
          \def\py@noticetype{#1}
          \begin{coloredbox}{#1}
          \bf\it
          \par\strong{#2}
          \csname py@noticestart@#1\endcsname
        }
	{
          \csname py@noticeend@\py@noticetype\endcsname
          \end{coloredbox}
        }
	\makeatother

     

\title{Linux Kernel Crypto API manual}
\date{March 08, 2018}
\release{4.16.0-rc4+}
\author{The kernel development community}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\setcounter{tocdepth}{1}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{crypto/index::doc}

\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Stephan Mueller

\item[{Author}] \leavevmode
Marek Vasut

\end{description}\end{quote}

This documentation outlines the Linux kernel crypto API with its
concepts, details about developing cipher implementations, employment of the API
for cryptographic use cases, as well as programming examples.

Table of contents


\chapter{Kernel Crypto API Interface Specification}
\label{crypto/intro:linux-kernel-crypto-api}\label{crypto/intro::doc}\label{crypto/intro:kernel-crypto-api-interface-specification}

\section{Introduction}
\label{crypto/intro:introduction}
The kernel crypto API offers a rich set of cryptographic ciphers as well
as other data transformation mechanisms and methods to invoke these.
This document contains a description of the API and provides example
code.

To understand and properly use the kernel crypto API a brief explanation
of its structure is given. Based on the architecture, the API can be
separated into different components. Following the architecture
specification, hints to developers of ciphers are provided. Pointers to
the API function call documentation are given at the end.

The kernel crypto API refers to all algorithms as ``transformations''.
Therefore, a cipher handle variable usually has the name ``tfm''. Besides
cryptographic operations, the kernel crypto API also knows compression
transformations and handles them the same way as ciphers.

The kernel crypto API serves the following entity types:
\begin{itemize}
\item {} 
consumers requesting cryptographic services

\item {} 
data transformation implementations (typically ciphers) that can be
called by consumers using the kernel crypto API

\end{itemize}

This specification is intended for consumers of the kernel crypto API as
well as for developers implementing ciphers. This API specification,
however, does not discuss all API calls available to data transformation
implementations (i.e. implementations of ciphers and other
transformations (such as CRC or even compression algorithms) that can
register with the kernel crypto API).

Note: The terms ``transformation'' and cipher algorithm are used
interchangeably.


\section{Terminology}
\label{crypto/intro:terminology}
The transformation implementation is an actual code or interface to
hardware which implements a certain transformation with precisely
defined behavior.

The transformation object (TFM) is an instance of a transformation
implementation. There can be multiple transformation objects associated
with a single transformation implementation. Each of those
transformation objects is held by a crypto API consumer or another
transformation. Transformation object is allocated when a crypto API
consumer requests a transformation implementation. The consumer is then
provided with a structure, which contains a transformation object (TFM).

The structure that contains transformation objects may also be referred
to as a ``cipher handle''. Such a cipher handle is always subject to the
following phases that are reflected in the API calls applicable to such
a cipher handle:
\begin{enumerate}
\item {} 
Initialization of a cipher handle.

\item {} 
Execution of all intended cipher operations applicable for the handle
where the cipher handle must be furnished to every API call.

\item {} 
Destruction of a cipher handle.

\end{enumerate}

When using the initialization API calls, a cipher handle is created and
returned to the consumer. Therefore, please refer to all initialization
API calls that refer to the data structure type a consumer is expected
to receive and subsequently to use. The initialization API calls have
all the same naming conventions of crypto\_alloc*.

The transformation context is private data associated with the
transformation object.


\chapter{Kernel Crypto API Architecture}
\label{crypto/architecture::doc}\label{crypto/architecture:kernel-crypto-api-architecture}

\section{Cipher algorithm types}
\label{crypto/architecture:cipher-algorithm-types}
The kernel crypto API provides different API calls for the following
cipher types:
\begin{itemize}
\item {} 
Symmetric ciphers

\item {} 
AEAD ciphers

\item {} 
Message digest, including keyed message digest

\item {} 
Random number generation

\item {} 
User space interface

\end{itemize}


\section{Ciphers And Templates}
\label{crypto/architecture:ciphers-and-templates}
The kernel crypto API provides implementations of single block ciphers
and message digests. In addition, the kernel crypto API provides
numerous ``templates'' that can be used in conjunction with the single
block ciphers and message digests. Templates include all types of block
chaining mode, the HMAC mechanism, etc.

Single block ciphers and message digests can either be directly used by
a caller or invoked together with a template to form multi-block ciphers
or keyed message digests.

A single block cipher may even be called with multiple templates.
However, templates cannot be used without a single cipher.

See /proc/crypto and search for ``name''. For example:
\begin{itemize}
\item {} 
aes

\item {} 
ecb(aes)

\item {} 
cmac(aes)

\item {} 
ccm(aes)

\item {} 
rfc4106(gcm(aes))

\item {} 
sha1

\item {} 
hmac(sha1)

\item {} 
authenc(hmac(sha1),cbc(aes))

\end{itemize}

In these examples, ``aes'' and ``sha1'' are the ciphers and all others are
the templates.


\section{Synchronous And Asynchronous Operation}
\label{crypto/architecture:synchronous-and-asynchronous-operation}
The kernel crypto API provides synchronous and asynchronous API
operations.

When using the synchronous API operation, the caller invokes a cipher
operation which is performed synchronously by the kernel crypto API.
That means, the caller waits until the cipher operation completes.
Therefore, the kernel crypto API calls work like regular function calls.
For synchronous operation, the set of API calls is small and
conceptually similar to any other crypto library.

Asynchronous operation is provided by the kernel crypto API which
implies that the invocation of a cipher operation will complete almost
instantly. That invocation triggers the cipher operation but it does not
signal its completion. Before invoking a cipher operation, the caller
must provide a callback function the kernel crypto API can invoke to
signal the completion of the cipher operation. Furthermore, the caller
must ensure it can handle such asynchronous events by applying
appropriate locking around its data. The kernel crypto API does not
perform any special serialization operation to protect the caller's data
integrity.


\section{Crypto API Cipher References And Priority}
\label{crypto/architecture:crypto-api-cipher-references-and-priority}
A cipher is referenced by the caller with a string. That string has the
following semantics:

\begin{Verbatim}[commandchars=\\\{\}]
template(single block cipher)
\end{Verbatim}

where ``template'' and ``single block cipher'' is the aforementioned
template and single block cipher, respectively. If applicable,
additional templates may enclose other templates, such as

\begin{Verbatim}[commandchars=\\\{\}]
template1(template2(single block cipher)))
\end{Verbatim}

The kernel crypto API may provide multiple implementations of a template
or a single block cipher. For example, AES on newer Intel hardware has
the following implementations: AES-NI, assembler implementation, or
straight C. Now, when using the string ``aes'' with the kernel crypto API,
which cipher implementation is used? The answer to that question is the
priority number assigned to each cipher implementation by the kernel
crypto API. When a caller uses the string to refer to a cipher during
initialization of a cipher handle, the kernel crypto API looks up all
implementations providing an implementation with that name and selects
the implementation with the highest priority.

Now, a caller may have the need to refer to a specific cipher
implementation and thus does not want to rely on the priority-based
selection. To accommodate this scenario, the kernel crypto API allows
the cipher implementation to register a unique name in addition to
common names. When using that unique name, a caller is therefore always
sure to refer to the intended cipher implementation.

The list of available ciphers is given in /proc/crypto. However, that
list does not specify all possible permutations of templates and
ciphers. Each block listed in /proc/crypto may contain the following
information -- if one of the components listed as follows are not
applicable to a cipher, it is not displayed:
\begin{itemize}
\item {} 
name: the generic name of the cipher that is subject to the
priority-based selection -- this name can be used by the cipher
allocation API calls (all names listed above are examples for such
generic names)

\item {} 
driver: the unique name of the cipher -- this name can be used by the
cipher allocation API calls

\item {} 
module: the kernel module providing the cipher implementation (or
``kernel'' for statically linked ciphers)

\item {} 
priority: the priority value of the cipher implementation

\item {} 
refcnt: the reference count of the respective cipher (i.e. the number
of current consumers of this cipher)

\item {} 
selftest: specification whether the self test for the cipher passed

\item {} 
type:
\begin{itemize}
\item {} 
skcipher for symmetric key ciphers

\item {} 
cipher for single block ciphers that may be used with an
additional template

\item {} 
shash for synchronous message digest

\item {} 
ahash for asynchronous message digest

\item {} 
aead for AEAD cipher type

\item {} 
compression for compression type transformations

\item {} 
rng for random number generator

\item {} 
givcipher for cipher with associated IV generator (see the geniv
entry below for the specification of the IV generator type used by
the cipher implementation)

\item {} 
kpp for a Key-agreement Protocol Primitive (KPP) cipher such as
an ECDH or DH implementation

\end{itemize}

\item {} 
blocksize: blocksize of cipher in bytes

\item {} 
keysize: key size in bytes

\item {} 
ivsize: IV size in bytes

\item {} 
seedsize: required size of seed data for random number generator

\item {} 
digestsize: output size of the message digest

\item {} 
geniv: IV generation type:
\begin{itemize}
\item {} 
eseqiv for encrypted sequence number based IV generation

\item {} 
seqiv for sequence number based IV generation

\item {} 
chainiv for chain iv generation

\item {} 
\textless{}builtin\textgreater{} is a marker that the cipher implements IV generation and
handling as it is specific to the given cipher

\end{itemize}

\end{itemize}


\section{Key Sizes}
\label{crypto/architecture:key-sizes}
When allocating a cipher handle, the caller only specifies the cipher
type. Symmetric ciphers, however, typically support multiple key sizes
(e.g. AES-128 vs. AES-192 vs. AES-256). These key sizes are determined
with the length of the provided key. Thus, the kernel crypto API does
not provide a separate way to select the particular symmetric cipher key
size.


\section{Cipher Allocation Type And Masks}
\label{crypto/architecture:cipher-allocation-type-and-masks}
The different cipher handle allocation functions allow the specification
of a type and mask flag. Both parameters have the following meaning (and
are therefore not covered in the subsequent sections).

The type flag specifies the type of the cipher algorithm. The caller
usually provides a 0 when the caller wants the default handling.
Otherwise, the caller may provide the following selections which match
the aforementioned cipher types:
\begin{itemize}
\item {} 
CRYPTO\_ALG\_TYPE\_CIPHER Single block cipher

\item {} 
CRYPTO\_ALG\_TYPE\_COMPRESS Compression

\item {} 
CRYPTO\_ALG\_TYPE\_AEAD Authenticated Encryption with Associated Data
(MAC)

\item {} 
CRYPTO\_ALG\_TYPE\_BLKCIPHER Synchronous multi-block cipher

\item {} 
CRYPTO\_ALG\_TYPE\_ABLKCIPHER Asynchronous multi-block cipher

\item {} 
CRYPTO\_ALG\_TYPE\_GIVCIPHER Asynchronous multi-block cipher packed
together with an IV generator (see geniv field in the /proc/crypto
listing for the known IV generators)

\item {} 
CRYPTO\_ALG\_TYPE\_KPP Key-agreement Protocol Primitive (KPP) such as
an ECDH or DH implementation

\item {} 
CRYPTO\_ALG\_TYPE\_DIGEST Raw message digest

\item {} 
CRYPTO\_ALG\_TYPE\_HASH Alias for CRYPTO\_ALG\_TYPE\_DIGEST

\item {} 
CRYPTO\_ALG\_TYPE\_SHASH Synchronous multi-block hash

\item {} 
CRYPTO\_ALG\_TYPE\_AHASH Asynchronous multi-block hash

\item {} 
CRYPTO\_ALG\_TYPE\_RNG Random Number Generation

\item {} 
CRYPTO\_ALG\_TYPE\_AKCIPHER Asymmetric cipher

\item {} 
CRYPTO\_ALG\_TYPE\_PCOMPRESS Enhanced version of
CRYPTO\_ALG\_TYPE\_COMPRESS allowing for segmented compression /
decompression instead of performing the operation on one segment
only. CRYPTO\_ALG\_TYPE\_PCOMPRESS is intended to replace
CRYPTO\_ALG\_TYPE\_COMPRESS once existing consumers are converted.

\end{itemize}

The mask flag restricts the type of cipher. The only allowed flag is
CRYPTO\_ALG\_ASYNC to restrict the cipher lookup function to
asynchronous ciphers. Usually, a caller provides a 0 for the mask flag.

When the caller provides a mask and type specification, the caller
limits the search the kernel crypto API can perform for a suitable
cipher implementation for the given cipher name. That means, even when a
caller uses a cipher name that exists during its initialization call,
the kernel crypto API may not select it due to the used type and mask
field.


\section{Internal Structure of Kernel Crypto API}
\label{crypto/architecture:internal-structure-of-kernel-crypto-api}
The kernel crypto API has an internal structure where a cipher
implementation may use many layers and indirections. This section shall
help to clarify how the kernel crypto API uses various components to
implement the complete cipher.

The following subsections explain the internal structure based on
existing cipher implementations. The first section addresses the most
complex scenario where all other scenarios form a logical subset.


\subsection{Generic AEAD Cipher Structure}
\label{crypto/architecture:generic-aead-cipher-structure}
The following ASCII art decomposes the kernel crypto API layers when
using the AEAD cipher with the automated IV generation. The shown
example is used by the IPSEC layer.

For other use cases of AEAD ciphers, the ASCII art applies as well, but
the caller may not use the AEAD cipher with a separate IV generator. In
this case, the caller must generate the IV.

The depicted example decomposes the AEAD cipher of GCM(AES) based on the
generic C implementations (gcm.c, aes-generic.c, ctr.c, ghash-generic.c,
seqiv.c). The generic implementation serves as an example showing the
complete logic of the kernel crypto API.

It is possible that some streamlined cipher implementations (like
AES-NI) provide implementations merging aspects which in the view of the
kernel crypto API cannot be decomposed into layers any more. In case of
the AES-NI implementation, the CTR mode, the GHASH implementation and
the AES cipher are all merged into one cipher implementation registered
with the kernel crypto API. In this case, the concept described by the
following ASCII art applies too. However, the decomposition of GCM into
the individual sub-components by the kernel crypto API is not done any
more.

Each block in the following ASCII art is an independent cipher instance
obtained from the kernel crypto API. Each block is accessed by the
caller or by other blocks using the API functions defined by the kernel
crypto API for the cipher implementation type.

The blocks below indicate the cipher type as well as the specific logic
implemented in the cipher.

The ASCII art picture also indicates the call structure, i.e. who calls
which component. The arrows point to the invoked block where the caller
uses the API applicable to the cipher type specified for the block.

\begin{Verbatim}[commandchars=\\\{\}]
kernel crypto API                                \textbar{}   IPSEC Layer
                                                 \textbar{}
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+                                    \textbar{}
\textbar{}           \textbar{}            (1)
\textbar{}   aead    \textbar{} \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  esp\PYGZus{}output
\textbar{}  (seqiv)  \textbar{} \PYGZhy{}\PYGZhy{}\PYGZhy{}+
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+    \textbar{}
                 \textbar{} (2)
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+    \textbar{}
\textbar{}           \textbar{} \PYGZlt{}\PYGZhy{}\PYGZhy{}+                (2)
\textbar{}   aead    \textbar{} \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  esp\PYGZus{}input
\textbar{}   (gcm)   \textbar{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+             \textbar{}
      \textbar{} (3)               \textbar{} (5)
      v                   v
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\textbar{}           \textbar{}       \textbar{}           \textbar{}
\textbar{}  skcipher \textbar{}       \textbar{}   ahash   \textbar{}
\textbar{}   (ctr)   \textbar{} \PYGZhy{}\PYGZhy{}\PYGZhy{}+  \textbar{}  (ghash)  \textbar{}
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+    \textbar{}  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
                 \textbar{}
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+    \textbar{} (4)
\textbar{}           \textbar{} \PYGZlt{}\PYGZhy{}\PYGZhy{}+
\textbar{}   cipher  \textbar{}
\textbar{}   (aes)   \textbar{}
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{Verbatim}

The following call sequence is applicable when the IPSEC layer triggers
an encryption operation with the esp\_output function. During
configuration, the administrator set up the use of rfc4106(gcm(aes)) as
the cipher for ESP. The following call sequence is now depicted in the
ASCII art above:
\begin{enumerate}
\item {} 
esp\_output() invokes crypto\_aead\_encrypt() to trigger an
encryption operation of the AEAD cipher with IV generator.

In case of GCM, the SEQIV implementation is registered as GIVCIPHER
in crypto\_rfc4106\_alloc().

The SEQIV performs its operation to generate an IV where the core
function is seqiv\_geniv().

\item {} 
Now, SEQIV uses the AEAD API function calls to invoke the associated
AEAD cipher. In our case, during the instantiation of SEQIV, the
cipher handle for GCM is provided to SEQIV. This means that SEQIV
invokes AEAD cipher operations with the GCM cipher handle.

During instantiation of the GCM handle, the CTR(AES) and GHASH
ciphers are instantiated. The cipher handles for CTR(AES) and GHASH
are retained for later use.

The GCM implementation is responsible to invoke the CTR mode AES and
the GHASH cipher in the right manner to implement the GCM
specification.

\item {} 
The GCM AEAD cipher type implementation now invokes the SKCIPHER API
with the instantiated CTR(AES) cipher handle.

During instantiation of the CTR(AES) cipher, the CIPHER type
implementation of AES is instantiated. The cipher handle for AES is
retained.

That means that the SKCIPHER implementation of CTR(AES) only
implements the CTR block chaining mode. After performing the block
chaining operation, the CIPHER implementation of AES is invoked.

\item {} 
The SKCIPHER of CTR(AES) now invokes the CIPHER API with the AES
cipher handle to encrypt one block.

\item {} 
The GCM AEAD implementation also invokes the GHASH cipher
implementation via the AHASH API.

\end{enumerate}

When the IPSEC layer triggers the esp\_input() function, the same call
sequence is followed with the only difference that the operation starts
with step (2).


\subsection{Generic Block Cipher Structure}
\label{crypto/architecture:generic-block-cipher-structure}
Generic block ciphers follow the same concept as depicted with the ASCII
art picture above.

For example, CBC(AES) is implemented with cbc.c, and aes-generic.c. The
ASCII art picture above applies as well with the difference that only
step (4) is used and the SKCIPHER block chaining mode is CBC.


\subsection{Generic Keyed Message Digest Structure}
\label{crypto/architecture:generic-keyed-message-digest-structure}
Keyed message digest implementations again follow the same concept as
depicted in the ASCII art picture above.

For example, HMAC(SHA256) is implemented with hmac.c and
sha256\_generic.c. The following ASCII art illustrates the
implementation:

\begin{Verbatim}[commandchars=\\\{\}]
kernel crypto API            \textbar{}       Caller
                             \textbar{}
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+         (1)    \textbar{}
\textbar{}           \textbar{} \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}  some\PYGZus{}function
\textbar{}   ahash   \textbar{}
\textbar{}   (hmac)  \textbar{} \PYGZhy{}\PYGZhy{}\PYGZhy{}+
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+    \textbar{}
                 \textbar{} (2)
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+    \textbar{}
\textbar{}           \textbar{} \PYGZlt{}\PYGZhy{}\PYGZhy{}+
\textbar{}   shash   \textbar{}
\textbar{}  (sha256) \textbar{}
+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{Verbatim}

The following call sequence is applicable when a caller triggers an HMAC
operation:
\begin{enumerate}
\item {} 
The AHASH API functions are invoked by the caller. The HMAC
implementation performs its operation as needed.

During initialization of the HMAC cipher, the SHASH cipher type of
SHA256 is instantiated. The cipher handle for the SHA256 instance is
retained.

At one time, the HMAC implementation requires a SHA256 operation
where the SHA256 cipher handle is used.

\item {} 
The HMAC instance now invokes the SHASH API with the SHA256 cipher
handle to calculate the message digest.

\end{enumerate}


\chapter{Developing Cipher Algorithms}
\label{crypto/devel-algos:developing-cipher-algorithms}\label{crypto/devel-algos::doc}

\section{Registering And Unregistering Transformation}
\label{crypto/devel-algos:registering-and-unregistering-transformation}
There are three distinct types of registration functions in the Crypto
API. One is used to register a generic cryptographic transformation,
while the other two are specific to HASH transformations and
COMPRESSion. We will discuss the latter two in a separate chapter, here
we will only look at the generic ones.

Before discussing the register functions, the data structure to be
filled with each, struct crypto\_alg, must be considered -- see below
for a description of this data structure.

The generic registration functions can be found in
include/linux/crypto.h and their definition can be seen below. The
former function registers a single transformation, while the latter
works on an array of transformation descriptions. The latter is useful
when registering transformations in bulk, for example when a driver
implements multiple transformations.

\begin{Verbatim}[commandchars=\\\{\}]
int crypto\PYGZus{}register\PYGZus{}alg(struct crypto\PYGZus{}alg *alg);
int crypto\PYGZus{}register\PYGZus{}algs(struct crypto\PYGZus{}alg *algs, int count);
\end{Verbatim}

The counterparts to those functions are listed below.

\begin{Verbatim}[commandchars=\\\{\}]
int crypto\PYGZus{}unregister\PYGZus{}alg(struct crypto\PYGZus{}alg *alg);
int crypto\PYGZus{}unregister\PYGZus{}algs(struct crypto\PYGZus{}alg *algs, int count);
\end{Verbatim}

Notice that both registration and unregistration functions do return a
value, so make sure to handle errors. A return code of zero implies
success. Any return code \textless{} 0 implies an error.

The bulk registration/unregistration functions register/unregister each
transformation in the given array of length count. They handle errors as
follows:
\begin{itemize}
\item {} 
crypto\_register\_algs() succeeds if and only if it successfully
registers all the given transformations. If an error occurs partway
through, then it rolls back successful registrations before returning
the error code. Note that if a driver needs to handle registration
errors for individual transformations, then it will need to use the
non-bulk function crypto\_register\_alg() instead.

\item {} 
crypto\_unregister\_algs() tries to unregister all the given
transformations, continuing on error. It logs errors and always
returns zero.

\end{itemize}


\section{Single-Block Symmetric Ciphers {[}CIPHER{]}}
\label{crypto/devel-algos:single-block-symmetric-ciphers-cipher}
Example of transformations: aes, arc4, ...

This section describes the simplest of all transformation
implementations, that being the CIPHER type used for symmetric ciphers.
The CIPHER type is used for transformations which operate on exactly one
block at a time and there are no dependencies between blocks at all.


\subsection{Registration specifics}
\label{crypto/devel-algos:registration-specifics}
The registration of {[}CIPHER{]} algorithm is specific in that struct
crypto\_alg field .cra\_type is empty. The .cra\_u.cipher has to be
filled in with proper callbacks to implement this transformation.

See struct cipher\_alg below.


\subsection{Cipher Definition With struct cipher\_alg}
\label{crypto/devel-algos:cipher-definition-with-struct-cipher-alg}
Struct cipher\_alg defines a single block cipher.

Here are schematics of how these functions are called when operated from
other part of the kernel. Note that the .cia\_setkey() call might happen
before or after any of these schematics happen, but must not happen
during any of these are in-flight.

\begin{Verbatim}[commandchars=\\\{\}]
KEY \PYGZhy{}\PYGZhy{}\PYGZhy{}.    PLAINTEXT \PYGZhy{}\PYGZhy{}\PYGZhy{}.
       v                 v
 .cia\PYGZus{}setkey() \PYGZhy{}\PYGZgt{} .cia\PYGZus{}encrypt()
                         \textbar{}
                         \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} CIPHERTEXT
\end{Verbatim}

Please note that a pattern where .cia\_setkey() is called multiple times
is also valid:

\begin{Verbatim}[commandchars=\\\{\}]
KEY1 \PYGZhy{}\PYGZhy{}.    PLAINTEXT1 \PYGZhy{}\PYGZhy{}.         KEY2 \PYGZhy{}\PYGZhy{}.    PLAINTEXT2 \PYGZhy{}\PYGZhy{}.
       v                 v                v                 v
 .cia\PYGZus{}setkey() \PYGZhy{}\PYGZgt{} .cia\PYGZus{}encrypt() \PYGZhy{}\PYGZgt{} .cia\PYGZus{}setkey() \PYGZhy{}\PYGZgt{} .cia\PYGZus{}encrypt()
                         \textbar{}                                  \textbar{}
                         \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} CIPHERTEXT1                  \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} CIPHERTEXT2
\end{Verbatim}


\section{Multi-Block Ciphers}
\label{crypto/devel-algos:multi-block-ciphers}
Example of transformations: cbc(aes), ecb(arc4), ...

This section describes the multi-block cipher transformation
implementations. The multi-block ciphers are used for transformations
which operate on scatterlists of data supplied to the transformation
functions. They output the result into a scatterlist of data as well.


\subsection{Registration Specifics}
\label{crypto/devel-algos:id1}
The registration of multi-block cipher algorithms is one of the most
standard procedures throughout the crypto API.

Note, if a cipher implementation requires a proper alignment of data,
the caller should use the functions of crypto\_skcipher\_alignmask() to
identify a memory alignment mask. The kernel crypto API is able to
process requests that are unaligned. This implies, however, additional
overhead as the kernel crypto API needs to perform the realignment of
the data which may imply moving of data.


\subsection{Cipher Definition With struct blkcipher\_alg and ablkcipher\_alg}
\label{crypto/devel-algos:cipher-definition-with-struct-blkcipher-alg-and-ablkcipher-alg}
Struct blkcipher\_alg defines a synchronous block cipher whereas struct
ablkcipher\_alg defines an asynchronous block cipher.

Please refer to the single block cipher description for schematics of
the block cipher usage.


\subsection{Specifics Of Asynchronous Multi-Block Cipher}
\label{crypto/devel-algos:specifics-of-asynchronous-multi-block-cipher}
There are a couple of specifics to the asynchronous interface.

First of all, some of the drivers will want to use the Generic
ScatterWalk in case the hardware needs to be fed separate chunks of the
scatterlist which contains the plaintext and will contain the
ciphertext. Please refer to the ScatterWalk interface offered by the
Linux kernel scatter / gather list implementation.


\section{Hashing {[}HASH{]}}
\label{crypto/devel-algos:hashing-hash}
Example of transformations: crc32, md5, sha1, sha256,...


\subsection{Registering And Unregistering The Transformation}
\label{crypto/devel-algos:registering-and-unregistering-the-transformation}
There are multiple ways to register a HASH transformation, depending on
whether the transformation is synchronous {[}SHASH{]} or asynchronous
{[}AHASH{]} and the amount of HASH transformations we are registering. You
can find the prototypes defined in include/crypto/internal/hash.h:

\begin{Verbatim}[commandchars=\\\{\}]
int crypto\PYGZus{}register\PYGZus{}ahash(struct ahash\PYGZus{}alg *alg);

int crypto\PYGZus{}register\PYGZus{}shash(struct shash\PYGZus{}alg *alg);
int crypto\PYGZus{}register\PYGZus{}shashes(struct shash\PYGZus{}alg *algs, int count);
\end{Verbatim}

The respective counterparts for unregistering the HASH transformation
are as follows:

\begin{Verbatim}[commandchars=\\\{\}]
int crypto\PYGZus{}unregister\PYGZus{}ahash(struct ahash\PYGZus{}alg *alg);

int crypto\PYGZus{}unregister\PYGZus{}shash(struct shash\PYGZus{}alg *alg);
int crypto\PYGZus{}unregister\PYGZus{}shashes(struct shash\PYGZus{}alg *algs, int count);
\end{Verbatim}


\subsection{Cipher Definition With struct shash\_alg and ahash\_alg}
\label{crypto/devel-algos:cipher-definition-with-struct-shash-alg-and-ahash-alg}
Here are schematics of how these functions are called when operated from
other part of the kernel. Note that the .setkey() call might happen
before or after any of these schematics happen, but must not happen
during any of these are in-flight. Please note that calling .init()
followed immediately by .finish() is also a perfectly valid
transformation.

\begin{Verbatim}[commandchars=\\\{\}]
I)   DATA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}.
                     v
      .init() \PYGZhy{}\PYGZgt{} .update() \PYGZhy{}\PYGZgt{} .final()      ! .update() might not be called
                  \PYGZca{}    \textbar{}         \textbar{}            at all in this scenario.
                  \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{}         \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} HASH

II)  DATA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}.\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}.
                     v           v
      .init() \PYGZhy{}\PYGZgt{} .update() \PYGZhy{}\PYGZgt{} .finup()      ! .update() may not be called
                  \PYGZca{}    \textbar{}         \textbar{}            at all in this scenario.
                  \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{}         \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} HASH

III) DATA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}.
                     v
                 .digest()                  ! The entire process is handled
                     \textbar{}                        by the .digest() call.
                     \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} HASH
\end{Verbatim}

Here is a schematic of how the .export()/.import() functions are called
when used from another part of the kernel.

\begin{Verbatim}[commandchars=\\\{\}]
KEY\PYGZhy{}\PYGZhy{}.                 DATA\PYGZhy{}\PYGZhy{}.
     v                       v                  ! .update() may not be called
 .setkey() \PYGZhy{}\PYGZgt{} .init() \PYGZhy{}\PYGZgt{} .update() \PYGZhy{}\PYGZgt{} .export()   at all in this scenario.
                          \PYGZca{}     \textbar{}         \textbar{}
                          \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{}         \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZgt{} PARTIAL\PYGZus{}HASH

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} other transformations happen here \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}

PARTIAL\PYGZus{}HASH\PYGZhy{}\PYGZhy{}.   DATA1\PYGZhy{}\PYGZhy{}.
              v          v
          .import \PYGZhy{}\PYGZgt{} .update() \PYGZhy{}\PYGZgt{} .final()     ! .update() may not be called
                      \PYGZca{}    \textbar{}         \textbar{}           at all in this scenario.
                      \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{}         \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZgt{} HASH1

PARTIAL\PYGZus{}HASH\PYGZhy{}\PYGZhy{}.   DATA2\PYGZhy{}.
              v         v
          .import \PYGZhy{}\PYGZgt{} .finup()
                        \textbar{}
                        \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} HASH2
\end{Verbatim}


\subsection{Specifics Of Asynchronous HASH Transformation}
\label{crypto/devel-algos:specifics-of-asynchronous-hash-transformation}
Some of the drivers will want to use the Generic ScatterWalk in case the
implementation needs to be fed separate chunks of the scatterlist which
contains the input data. The buffer containing the resulting hash will
always be properly aligned to .cra\_alignmask so there is no need to
worry about this.


\chapter{User Space Interface}
\label{crypto/userspace-if:user-space-interface}\label{crypto/userspace-if::doc}

\section{Introduction}
\label{crypto/userspace-if:introduction}
The concepts of the kernel crypto API visible to kernel space is fully
applicable to the user space interface as well. Therefore, the kernel
crypto API high level discussion for the in-kernel use cases applies
here as well.

The major difference, however, is that user space can only act as a
consumer and never as a provider of a transformation or cipher
algorithm.

The following covers the user space interface exported by the kernel
crypto API. A working example of this description is libkcapi that can
be obtained from {[}1{]}. That library can be used by user space
applications that require cryptographic services from the kernel.

Some details of the in-kernel kernel crypto API aspects do not apply to
user space, however. This includes the difference between synchronous
and asynchronous invocations. The user space API call is fully
synchronous.

{[}1{]} \href{http://www.chronox.de/libkcapi.html}{http://www.chronox.de/libkcapi.html}


\section{User Space API General Remarks}
\label{crypto/userspace-if:user-space-api-general-remarks}
The kernel crypto API is accessible from user space. Currently, the
following ciphers are accessible:
\begin{itemize}
\item {} 
Message digest including keyed message digest (HMAC, CMAC)

\item {} 
Symmetric ciphers

\item {} 
AEAD ciphers

\item {} 
Random Number Generators

\end{itemize}

The interface is provided via socket type using the type AF\_ALG. In
addition, the setsockopt option type is SOL\_ALG. In case the user space
header files do not export these flags yet, use the following macros:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}ifndef AF\PYGZus{}ALG
\PYGZsh{}define AF\PYGZus{}ALG 38
\PYGZsh{}endif
\PYGZsh{}ifndef SOL\PYGZus{}ALG
\PYGZsh{}define SOL\PYGZus{}ALG 279
\PYGZsh{}endif
\end{Verbatim}

A cipher is accessed with the same name as done for the in-kernel API
calls. This includes the generic vs. unique naming schema for ciphers as
well as the enforcement of priorities for generic names.

To interact with the kernel crypto API, a socket must be created by the
user space application. User space invokes the cipher operation with the
send()/write() system call family. The result of the cipher operation is
obtained with the read()/recv() system call family.

The following API calls assume that the socket descriptor is already
opened by the user space application and discusses only the kernel
crypto API specific invocations.

To initialize the socket interface, the following sequence has to be
performed by the consumer:
\begin{enumerate}
\item {} 
Create a socket of type AF\_ALG with the struct sockaddr\_alg
parameter specified below for the different cipher types.

\item {} 
Invoke bind with the socket descriptor

\item {} 
Invoke accept with the socket descriptor. The accept system call
returns a new file descriptor that is to be used to interact with the
particular cipher instance. When invoking send/write or recv/read
system calls to send data to the kernel or obtain data from the
kernel, the file descriptor returned by accept must be used.

\end{enumerate}


\section{In-place Cipher operation}
\label{crypto/userspace-if:in-place-cipher-operation}
Just like the in-kernel operation of the kernel crypto API, the user
space interface allows the cipher operation in-place. That means that
the input buffer used for the send/write system call and the output
buffer used by the read/recv system call may be one and the same. This
is of particular interest for symmetric cipher operations where a
copying of the output data to its final destination can be avoided.

If a consumer on the other hand wants to maintain the plaintext and the
ciphertext in different memory locations, all a consumer needs to do is
to provide different memory pointers for the encryption and decryption
operation.


\section{Message Digest API}
\label{crypto/userspace-if:message-digest-api}
The message digest type to be used for the cipher operation is selected
when invoking the bind syscall. bind requires the caller to provide a
filled struct sockaddr data structure. This data structure must be
filled as follows:

\begin{Verbatim}[commandchars=\\\{\}]
struct sockaddr\PYGZus{}alg sa = \PYGZob{}
    .salg\PYGZus{}family = AF\PYGZus{}ALG,
    .salg\PYGZus{}type = \PYGZdq{}hash\PYGZdq{}, /* this selects the hash logic in the kernel */
    .salg\PYGZus{}name = \PYGZdq{}sha1\PYGZdq{} /* this is the cipher name */
\PYGZcb{};
\end{Verbatim}

The salg\_type value ``hash'' applies to message digests and keyed message
digests. Though, a keyed message digest is referenced by the appropriate
salg\_name. Please see below for the setsockopt interface that explains
how the key can be set for a keyed message digest.

Using the send() system call, the application provides the data that
should be processed with the message digest. The send system call allows
the following flags to be specified:
\begin{itemize}
\item {} 
MSG\_MORE: If this flag is set, the send system call acts like a
message digest update function where the final hash is not yet
calculated. If the flag is not set, the send system call calculates
the final message digest immediately.

\end{itemize}

With the recv() system call, the application can read the message digest
from the kernel crypto API. If the buffer is too small for the message
digest, the flag MSG\_TRUNC is set by the kernel.

In order to set a message digest key, the calling application must use
the setsockopt() option of ALG\_SET\_KEY. If the key is not set the HMAC
operation is performed without the initial HMAC state change caused by
the key.


\section{Symmetric Cipher API}
\label{crypto/userspace-if:symmetric-cipher-api}
The operation is very similar to the message digest discussion. During
initialization, the struct sockaddr data structure must be filled as
follows:

\begin{Verbatim}[commandchars=\\\{\}]
struct sockaddr\PYGZus{}alg sa = \PYGZob{}
    .salg\PYGZus{}family = AF\PYGZus{}ALG,
    .salg\PYGZus{}type = \PYGZdq{}skcipher\PYGZdq{}, /* this selects the symmetric cipher */
    .salg\PYGZus{}name = \PYGZdq{}cbc(aes)\PYGZdq{} /* this is the cipher name */
\PYGZcb{};
\end{Verbatim}

Before data can be sent to the kernel using the write/send system call
family, the consumer must set the key. The key setting is described with
the setsockopt invocation below.

Using the sendmsg() system call, the application provides the data that
should be processed for encryption or decryption. In addition, the IV is
specified with the data structure provided by the sendmsg() system call.

The sendmsg system call parameter of struct msghdr is embedded into the
struct cmsghdr data structure. See recv(2) and cmsg(3) for more
information on how the cmsghdr data structure is used together with the
send/recv system call family. That cmsghdr data structure holds the
following information specified with a separate header instances:
\begin{itemize}
\item {} 
specification of the cipher operation type with one of these flags:
\begin{itemize}
\item {} 
ALG\_OP\_ENCRYPT - encryption of data

\item {} 
ALG\_OP\_DECRYPT - decryption of data

\end{itemize}

\item {} 
specification of the IV information marked with the flag ALG\_SET\_IV

\end{itemize}

The send system call family allows the following flag to be specified:
\begin{itemize}
\item {} 
MSG\_MORE: If this flag is set, the send system call acts like a
cipher update function where more input data is expected with a
subsequent invocation of the send system call.

\end{itemize}

Note: The kernel reports -EINVAL for any unexpected data. The caller
must make sure that all data matches the constraints given in
/proc/crypto for the selected cipher.

With the recv() system call, the application can read the result of the
cipher operation from the kernel crypto API. The output buffer must be
at least as large as to hold all blocks of the encrypted or decrypted
data. If the output data size is smaller, only as many blocks are
returned that fit into that output buffer size.


\section{AEAD Cipher API}
\label{crypto/userspace-if:aead-cipher-api}
The operation is very similar to the symmetric cipher discussion. During
initialization, the struct sockaddr data structure must be filled as
follows:

\begin{Verbatim}[commandchars=\\\{\}]
struct sockaddr\PYGZus{}alg sa = \PYGZob{}
    .salg\PYGZus{}family = AF\PYGZus{}ALG,
    .salg\PYGZus{}type = \PYGZdq{}aead\PYGZdq{}, /* this selects the symmetric cipher */
    .salg\PYGZus{}name = \PYGZdq{}gcm(aes)\PYGZdq{} /* this is the cipher name */
\PYGZcb{};
\end{Verbatim}

Before data can be sent to the kernel using the write/send system call
family, the consumer must set the key. The key setting is described with
the setsockopt invocation below.

In addition, before data can be sent to the kernel using the write/send
system call family, the consumer must set the authentication tag size.
To set the authentication tag size, the caller must use the setsockopt
invocation described below.

Using the sendmsg() system call, the application provides the data that
should be processed for encryption or decryption. In addition, the IV is
specified with the data structure provided by the sendmsg() system call.

The sendmsg system call parameter of struct msghdr is embedded into the
struct cmsghdr data structure. See recv(2) and cmsg(3) for more
information on how the cmsghdr data structure is used together with the
send/recv system call family. That cmsghdr data structure holds the
following information specified with a separate header instances:
\begin{itemize}
\item {} 
specification of the cipher operation type with one of these flags:
\begin{itemize}
\item {} 
ALG\_OP\_ENCRYPT - encryption of data

\item {} 
ALG\_OP\_DECRYPT - decryption of data

\end{itemize}

\item {} 
specification of the IV information marked with the flag ALG\_SET\_IV

\item {} 
specification of the associated authentication data (AAD) with the
flag ALG\_SET\_AEAD\_ASSOCLEN. The AAD is sent to the kernel together
with the plaintext / ciphertext. See below for the memory structure.

\end{itemize}

The send system call family allows the following flag to be specified:
\begin{itemize}
\item {} 
MSG\_MORE: If this flag is set, the send system call acts like a
cipher update function where more input data is expected with a
subsequent invocation of the send system call.

\end{itemize}

Note: The kernel reports -EINVAL for any unexpected data. The caller
must make sure that all data matches the constraints given in
/proc/crypto for the selected cipher.

With the recv() system call, the application can read the result of the
cipher operation from the kernel crypto API. The output buffer must be
at least as large as defined with the memory structure below. If the
output data size is smaller, the cipher operation is not performed.

The authenticated decryption operation may indicate an integrity error.
Such breach in integrity is marked with the -EBADMSG error code.


\subsection{AEAD Memory Structure}
\label{crypto/userspace-if:aead-memory-structure}
The AEAD cipher operates with the following information that is
communicated between user and kernel space as one data stream:
\begin{itemize}
\item {} 
plaintext or ciphertext

\item {} 
associated authentication data (AAD)

\item {} 
authentication tag

\end{itemize}

The sizes of the AAD and the authentication tag are provided with the
sendmsg and setsockopt calls (see there). As the kernel knows the size
of the entire data stream, the kernel is now able to calculate the right
offsets of the data components in the data stream.

The user space caller must arrange the aforementioned information in the
following order:
\begin{itemize}
\item {} 
AEAD encryption input: AAD \textbar{}\textbar{} plaintext

\item {} 
AEAD decryption input: AAD \textbar{}\textbar{} ciphertext \textbar{}\textbar{} authentication tag

\end{itemize}

The output buffer the user space caller provides must be at least as
large to hold the following data:
\begin{itemize}
\item {} 
AEAD encryption output: ciphertext \textbar{}\textbar{} authentication tag

\item {} 
AEAD decryption output: plaintext

\end{itemize}


\section{Random Number Generator API}
\label{crypto/userspace-if:random-number-generator-api}
Again, the operation is very similar to the other APIs. During
initialization, the struct sockaddr data structure must be filled as
follows:

\begin{Verbatim}[commandchars=\\\{\}]
struct sockaddr\PYGZus{}alg sa = \PYGZob{}
    .salg\PYGZus{}family = AF\PYGZus{}ALG,
    .salg\PYGZus{}type = \PYGZdq{}rng\PYGZdq{}, /* this selects the symmetric cipher */
    .salg\PYGZus{}name = \PYGZdq{}drbg\PYGZus{}nopr\PYGZus{}sha256\PYGZdq{} /* this is the cipher name */
\PYGZcb{};
\end{Verbatim}

Depending on the RNG type, the RNG must be seeded. The seed is provided
using the setsockopt interface to set the key. For example, the
ansi\_cprng requires a seed. The DRBGs do not require a seed, but may be
seeded.

Using the read()/recvmsg() system calls, random numbers can be obtained.
The kernel generates at most 128 bytes in one call. If user space
requires more data, multiple calls to read()/recvmsg() must be made.

WARNING: The user space caller may invoke the initially mentioned accept
system call multiple times. In this case, the returned file descriptors
have the same state.


\section{Zero-Copy Interface}
\label{crypto/userspace-if:zero-copy-interface}
In addition to the send/write/read/recv system call family, the AF\_ALG
interface can be accessed with the zero-copy interface of
splice/vmsplice. As the name indicates, the kernel tries to avoid a copy
operation into kernel space.

The zero-copy operation requires data to be aligned at the page
boundary. Non-aligned data can be used as well, but may require more
operations of the kernel which would defeat the speed gains obtained
from the zero-copy interface.

The system-inherent limit for the size of one zero-copy operation is 16
pages. If more data is to be sent to AF\_ALG, user space must slice the
input into segments with a maximum size of 16 pages.

Zero-copy can be used with the following code example (a complete
working example is provided with libkcapi):

\begin{Verbatim}[commandchars=\\\{\}]
int pipes[2];

pipe(pipes);
/* input data in iov */
vmsplice(pipes[1], iov, iovlen, SPLICE\PYGZus{}F\PYGZus{}GIFT);
/* opfd is the file descriptor returned from accept() system call */
splice(pipes[0], NULL, opfd, NULL, ret, 0);
read(opfd, out, outlen);
\end{Verbatim}


\section{Setsockopt Interface}
\label{crypto/userspace-if:setsockopt-interface}
In addition to the read/recv and send/write system call handling to send
and retrieve data subject to the cipher operation, a consumer also needs
to set the additional information for the cipher operation. This
additional information is set using the setsockopt system call that must
be invoked with the file descriptor of the open cipher (i.e. the file
descriptor returned by the accept system call).

Each setsockopt invocation must use the level SOL\_ALG.

The setsockopt interface allows setting the following data using the
mentioned optname:
\begin{itemize}
\item {} 
ALG\_SET\_KEY -- Setting the key. Key setting is applicable to:
\begin{itemize}
\item {} 
the skcipher cipher type (symmetric ciphers)

\item {} 
the hash cipher type (keyed message digests)

\item {} 
the AEAD cipher type

\item {} 
the RNG cipher type to provide the seed

\end{itemize}

\item {} 
ALG\_SET\_AEAD\_AUTHSIZE -- Setting the authentication tag size for
AEAD ciphers. For a encryption operation, the authentication tag of
the given size will be generated. For a decryption operation, the
provided ciphertext is assumed to contain an authentication tag of
the given size (see section about AEAD memory layout below).

\end{itemize}


\section{User space API example}
\label{crypto/userspace-if:user-space-api-example}
Please see {[}1{]} for libkcapi which provides an easy-to-use wrapper around
the aforementioned Netlink kernel interface. {[}1{]} also contains a test
application that invokes all libkcapi API calls.

{[}1{]} \href{http://www.chronox.de/libkcapi.html}{http://www.chronox.de/libkcapi.html}


\chapter{Programming Interface}
\label{crypto/api:programming-interface}\label{crypto/api::doc}
Please note that the kernel crypto API contains the AEAD givcrypt API
(crypto\_aead\_giv* and aead\_givcrypt* function calls in
include/crypto/aead.h). This API is obsolete and will be removed in the
future. To obtain the functionality of an AEAD cipher with internal IV
generation, use the IV generator as a regular cipher. For example,
rfc4106(gcm(aes)) is the AEAD cipher with external IV generation and
seqniv(rfc4106(gcm(aes))) implies that the kernel crypto API generates
the IV. Different IV generators are available.

Table of contents


\section{Block Cipher Algorithm Definitions}
\label{crypto/api-skcipher::doc}\label{crypto/api-skcipher:block-cipher-algorithm-definitions}
These data structures define modular crypto algorithm implementations,
managed via \code{crypto\_register\_alg()} and \code{crypto\_unregister\_alg()}.
\index{ablkcipher\_alg (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.ablkcipher_alg}\pysigline{struct \bfcode{ablkcipher\_alg}}
asynchronous block cipher definition

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ablkcipher\PYGZus{}alg \PYGZob{}
  int (*setkey)(struct crypto\PYGZus{}ablkcipher *tfm, const u8 *key, unsigned int keylen);
  int (*encrypt)(struct ablkcipher\PYGZus{}request *req);
  int (*decrypt)(struct ablkcipher\PYGZus{}request *req);
  int (*givencrypt)(struct skcipher\PYGZus{}givcrypt\PYGZus{}request *req);
  int (*givdecrypt)(struct skcipher\PYGZus{}givcrypt\PYGZus{}request *req);
  const char *geniv;
  unsigned int min\PYGZus{}keysize;
  unsigned int max\PYGZus{}keysize;
  unsigned int ivsize;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{setkey}}] \leavevmode
Set key for the transformation. This function is used to either
program a supplied key into the hardware or store the key in the
transformation context for programming it later. Note that this
function does modify the transformation context. This function can
be called multiple times during the existence of the transformation
object, so one must make sure the key is properly reprogrammed into
the hardware. This function is also responsible for checking the key
length for validity. In case a software fallback was put in place in
the \textbf{cra\_init} call, this function might need to use the fallback if
the algorithm doesn't support all of the key sizes.

\item[{\code{encrypt}}] \leavevmode
Encrypt a scatterlist of blocks. This function is used to encrypt
the supplied scatterlist containing the blocks of data. The crypto
API consumer is responsible for aligning the entries of the
scatterlist properly and making sure the chunks are correctly
sized. In case a software fallback was put in place in the
\textbf{cra\_init} call, this function might need to use the fallback if
the algorithm doesn't support all of the key sizes. In case the
key was stored in transformation context, the key might need to be
re-programmed into the hardware in this function. This function
shall not modify the transformation context, as this function may
be called in parallel with the same transformation object.

\item[{\code{decrypt}}] \leavevmode
Decrypt a single block. This is a reverse counterpart to \textbf{encrypt}
and the conditions are exactly the same.

\item[{\code{givencrypt}}] \leavevmode
Update the IV for encryption. With this function, a cipher
implementation may provide the function on how to update the IV
for encryption.

\item[{\code{givdecrypt}}] \leavevmode
Update the IV for decryption. This is the reverse of
\textbf{givencrypt} .

\item[{\code{geniv}}] \leavevmode
The transformation implementation may use an ``IV generator'' provided
by the kernel crypto API. Several use cases have a predefined
approach how IVs are to be updated. For such use cases, the kernel
crypto API provides ready-to-use implementations that can be
referenced with this variable.

\item[{\code{min\_keysize}}] \leavevmode
Minimum key size supported by the transformation. This is the
smallest key length supported by this transformation algorithm.
This must be set to one of the pre-defined values as this is
not hardware specific. Possible values for this field can be
found via git grep ``\_MIN\_KEY\_SIZE'' include/crypto/

\item[{\code{max\_keysize}}] \leavevmode
Maximum key size supported by the transformation. This is the
largest key length supported by this transformation algorithm.
This must be set to one of the pre-defined values as this is
not hardware specific. Possible values for this field can be
found via git grep ``\_MAX\_KEY\_SIZE'' include/crypto/

\item[{\code{ivsize}}] \leavevmode
IV size applicable for transformation. The consumer must provide an
IV of exactly that size to perform the encrypt or decrypt operation.

\end{description}

\textbf{Description}

All fields except \textbf{givencrypt} , \textbf{givdecrypt} , \textbf{geniv} and \textbf{ivsize} are
mandatory and must be filled.
\index{blkcipher\_alg (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.blkcipher_alg}\pysigline{struct \bfcode{blkcipher\_alg}}
synchronous block cipher definition

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct blkcipher\PYGZus{}alg \PYGZob{}
  int (*setkey)(struct crypto\PYGZus{}tfm *tfm, const u8 *key, unsigned int keylen);
  int (*encrypt)(struct blkcipher\PYGZus{}desc *desc,struct scatterlist *dst, struct scatterlist *src, unsigned int nbytes);
  int (*decrypt)(struct blkcipher\PYGZus{}desc *desc,struct scatterlist *dst, struct scatterlist *src, unsigned int nbytes);
  const char *geniv;
  unsigned int min\PYGZus{}keysize;
  unsigned int max\PYGZus{}keysize;
  unsigned int ivsize;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{setkey}}] \leavevmode
see struct ablkcipher\_alg

\item[{\code{encrypt}}] \leavevmode
see struct ablkcipher\_alg

\item[{\code{decrypt}}] \leavevmode
see struct ablkcipher\_alg

\item[{\code{geniv}}] \leavevmode
see struct ablkcipher\_alg

\item[{\code{min\_keysize}}] \leavevmode
see struct ablkcipher\_alg

\item[{\code{max\_keysize}}] \leavevmode
see struct ablkcipher\_alg

\item[{\code{ivsize}}] \leavevmode
see struct ablkcipher\_alg

\end{description}

\textbf{Description}

All fields except \textbf{geniv} and \textbf{ivsize} are mandatory and must be filled.
\index{cipher\_alg (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.cipher_alg}\pysigline{struct \bfcode{cipher\_alg}}
single-block symmetric ciphers definition

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct cipher\PYGZus{}alg \PYGZob{}
  unsigned int cia\PYGZus{}min\PYGZus{}keysize;
  unsigned int cia\PYGZus{}max\PYGZus{}keysize;
  int (*cia\PYGZus{}setkey)(struct crypto\PYGZus{}tfm *tfm, const u8 *key, unsigned int keylen);
  void (*cia\PYGZus{}encrypt)(struct crypto\PYGZus{}tfm *tfm, u8 *dst, const u8 *src);
  void (*cia\PYGZus{}decrypt)(struct crypto\PYGZus{}tfm *tfm, u8 *dst, const u8 *src);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{cia\_min\_keysize}}] \leavevmode
Minimum key size supported by the transformation. This is
the smallest key length supported by this transformation
algorithm. This must be set to one of the pre-defined
values as this is not hardware specific. Possible values
for this field can be found via git grep ``\_MIN\_KEY\_SIZE''
include/crypto/

\item[{\code{cia\_max\_keysize}}] \leavevmode
Maximum key size supported by the transformation. This is
the largest key length supported by this transformation
algorithm. This must be set to one of the pre-defined values
as this is not hardware specific. Possible values for this
field can be found via git grep ``\_MAX\_KEY\_SIZE''
include/crypto/

\item[{\code{cia\_setkey}}] \leavevmode
Set key for the transformation. This function is used to either
program a supplied key into the hardware or store the key in the
transformation context for programming it later. Note that this
function does modify the transformation context. This function
can be called multiple times during the existence of the
transformation object, so one must make sure the key is properly
reprogrammed into the hardware. This function is also
responsible for checking the key length for validity.

\item[{\code{cia\_encrypt}}] \leavevmode
Encrypt a single block. This function is used to encrypt a
single block of data, which must be \textbf{cra\_blocksize} big. This
always operates on a full \textbf{cra\_blocksize} and it is not possible
to encrypt a block of smaller size. The supplied buffers must
therefore also be at least of \textbf{cra\_blocksize} size. Both the
input and output buffers are always aligned to \textbf{cra\_alignmask}.
In case either of the input or output buffer supplied by user
of the crypto API is not aligned to \textbf{cra\_alignmask}, the crypto
API will re-align the buffers. The re-alignment means that a
new buffer will be allocated, the data will be copied into the
new buffer, then the processing will happen on the new buffer,
then the data will be copied back into the original buffer and
finally the new buffer will be freed. In case a software
fallback was put in place in the \textbf{cra\_init} call, this function
might need to use the fallback if the algorithm doesn't support
all of the key sizes. In case the key was stored in
transformation context, the key might need to be re-programmed
into the hardware in this function. This function shall not
modify the transformation context, as this function may be
called in parallel with the same transformation object.

\item[{\code{cia\_decrypt}}] \leavevmode
Decrypt a single block. This is a reverse counterpart to
\textbf{cia\_encrypt}, and the conditions are exactly the same.

\end{description}

\textbf{Description}

All fields are mandatory and must be filled.
\index{crypto\_alg (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_alg}\pysigline{struct \bfcode{crypto\_alg}}
definition of a cryptograpic cipher algorithm

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct crypto\PYGZus{}alg \PYGZob{}
  struct list\PYGZus{}head cra\PYGZus{}list;
  struct list\PYGZus{}head cra\PYGZus{}users;
  u32 cra\PYGZus{}flags;
  unsigned int cra\PYGZus{}blocksize;
  unsigned int cra\PYGZus{}ctxsize;
  unsigned int cra\PYGZus{}alignmask;
  int cra\PYGZus{}priority;
  refcount\PYGZus{}t cra\PYGZus{}refcnt;
  char cra\PYGZus{}name[CRYPTO\PYGZus{}MAX\PYGZus{}ALG\PYGZus{}NAME];
  char cra\PYGZus{}driver\PYGZus{}name[CRYPTO\PYGZus{}MAX\PYGZus{}ALG\PYGZus{}NAME];
  const struct crypto\PYGZus{}type *cra\PYGZus{}type;
  union \PYGZob{}
    struct ablkcipher\PYGZus{}alg ablkcipher;
    struct blkcipher\PYGZus{}alg blkcipher;
    struct cipher\PYGZus{}alg cipher;
    struct compress\PYGZus{}alg compress;
  \PYGZcb{} cra\PYGZus{}u;
  int (*cra\PYGZus{}init)(struct crypto\PYGZus{}tfm *tfm);
  void (*cra\PYGZus{}exit)(struct crypto\PYGZus{}tfm *tfm);
  void (*cra\PYGZus{}destroy)(struct crypto\PYGZus{}alg *alg);
  struct module *cra\PYGZus{}module;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{cra\_list}}] \leavevmode
internally used

\item[{\code{cra\_users}}] \leavevmode
internally used

\item[{\code{cra\_flags}}] \leavevmode
Flags describing this transformation. See include/linux/crypto.h
CRYPTO\_ALG\_* flags for the flags which go in here. Those are
used for fine-tuning the description of the transformation
algorithm.

\item[{\code{cra\_blocksize}}] \leavevmode
Minimum block size of this transformation. The size in bytes
of the smallest possible unit which can be transformed with
this algorithm. The users must respect this value.
In case of HASH transformation, it is possible for a smaller
block than \textbf{cra\_blocksize} to be passed to the crypto API for
transformation, in case of any other transformation type, an
error will be returned upon any attempt to transform smaller
than \textbf{cra\_blocksize} chunks.

\item[{\code{cra\_ctxsize}}] \leavevmode
Size of the operational context of the transformation. This
value informs the kernel crypto API about the memory size
needed to be allocated for the transformation context.

\item[{\code{cra\_alignmask}}] \leavevmode
Alignment mask for the input and output data buffer. The data
buffer containing the input data for the algorithm must be
aligned to this alignment mask. The data buffer for the
output data must be aligned to this alignment mask. Note that
the Crypto API will do the re-alignment in software, but
only under special conditions and there is a performance hit.
The re-alignment happens at these occasions for different
\textbf{cra\_u} types: cipher -- For both input data and output data
buffer; ahash -- For output hash destination buf; shash --
For output hash destination buf.
This is needed on hardware which is flawed by design and
cannot pick data from arbitrary addresses.

\item[{\code{cra\_priority}}] \leavevmode
Priority of this transformation implementation. In case
multiple transformations with same \textbf{cra\_name} are available to
the Crypto API, the kernel will use the one with highest
\textbf{cra\_priority}.

\item[{\code{cra\_refcnt}}] \leavevmode
internally used

\item[{\code{cra\_name}}] \leavevmode
Generic name (usable by multiple implementations) of the
transformation algorithm. This is the name of the transformation
itself. This field is used by the kernel when looking up the
providers of particular transformation.

\item[{\code{cra\_driver\_name}}] \leavevmode
Unique name of the transformation provider. This is the
name of the provider of the transformation. This can be any
arbitrary value, but in the usual case, this contains the
name of the chip or provider and the name of the
transformation algorithm.

\item[{\code{cra\_type}}] \leavevmode
Type of the cryptographic transformation. This is a pointer to
struct crypto\_type, which implements callbacks common for all
transformation types. There are multiple options:
\code{crypto\_blkcipher\_type}, \code{crypto\_ablkcipher\_type},
\code{crypto\_ahash\_type}, \code{crypto\_rng\_type}.
This field might be empty. In that case, there are no common
callbacks. This is the case for: cipher, compress, shash.

\item[{\code{cra\_u}}] \leavevmode
Callbacks implementing the transformation. This is a union of
multiple structures. Depending on the type of transformation selected
by \textbf{cra\_type} and \textbf{cra\_flags} above, the associated structure must be
filled with callbacks. This field might be empty. This is the case
for ahash, shash.

\item[{\code{cra\_init}}] \leavevmode
Initialize the cryptographic transformation object. This function
is used to initialize the cryptographic transformation object.
This function is called only once at the instantiation time, right
after the transformation context was allocated. In case the
cryptographic hardware has some special requirements which need to
be handled by software, this function shall check for the precise
requirement of the transformation and put any software fallbacks
in place.

\item[{\code{cra\_exit}}] \leavevmode
Deinitialize the cryptographic transformation object. This is a
counterpart to \textbf{cra\_init}, used to remove various changes set in
\textbf{cra\_init}.

\item[{\code{cra\_destroy}}] \leavevmode
internally used

\item[{\code{cra\_module}}] \leavevmode
Owner of this transformation implementation. Set to THIS\_MODULE

\end{description}

\textbf{Description}

The struct crypto\_alg describes a generic Crypto API algorithm and is common
for all of the transformations. Any variable not documented here shall not
be used by a cipher implementation as it is internal to the Crypto API.


\section{Symmetric Key Cipher API}
\label{crypto/api-skcipher:symmetric-key-cipher-api}
Symmetric key cipher API is used with the ciphers of type
CRYPTO\_ALG\_TYPE\_SKCIPHER (listed as type ``skcipher'' in /proc/crypto).

Asynchronous cipher operations imply that the function invocation for a
cipher request returns immediately before the completion of the operation.
The cipher request is scheduled as a separate kernel thread and therefore
load-balanced on the different CPUs via the process scheduler. To allow
the kernel crypto API to inform the caller about the completion of a cipher
request, the caller must provide a callback function. That function is
invoked with the cipher handle when the request completes.

To support the asynchronous operation, additional information than just the
cipher handle must be supplied to the kernel crypto API. That additional
information is given by filling in the skcipher\_request data structure.

For the symmetric key cipher API, the state is maintained with the tfm
cipher handle. A single tfm can be used across multiple calls and in
parallel. For asynchronous block cipher calls, context data supplied and
only used by the caller can be referenced the request data structure in
addition to the IV used for the cipher request. The maintenance of such
state information would be important for a crypto driver implementer to
have, because when calling the callback function upon completion of the
cipher operation, that callback function may need some information about
which operation just finished if it invoked multiple in parallel. This
state information is unused by the kernel crypto API.
\index{crypto\_alloc\_skcipher (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_alloc_skcipher}\pysiglinewithargsret{struct crypto\_skcipher * \bfcode{crypto\_alloc\_skcipher}}{const char *\emph{ alg\_name}, u32\emph{ type}, u32\emph{ mask}}{}
allocate symmetric key cipher handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * alg\_name}}] \leavevmode
is the cra\_name / name or cra\_driver\_name / driver name of the
skcipher cipher

\item[{\code{u32 type}}] \leavevmode
specifies the type of the cipher

\item[{\code{u32 mask}}] \leavevmode
specifies the mask for the cipher

\end{description}

\textbf{Description}

Allocate a cipher handle for an skcipher. The returned struct
crypto\_skcipher is the cipher handle that is required for any subsequent
API invocation for that skcipher.

\textbf{Return}
\begin{description}
\item[{allocated cipher handle in case of success; \code{IS\_ERR()} is true in case}] \leavevmode
of an error, \code{PTR\_ERR()} returns the error code.

\end{description}
\index{crypto\_free\_skcipher (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_free_skcipher}\pysiglinewithargsret{void \bfcode{crypto\_free\_skcipher}}{struct crypto\_skcipher *\emph{ tfm}}{}
zeroize and free cipher handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_skcipher * tfm}}] \leavevmode
cipher handle to be freed

\end{description}
\index{crypto\_has\_skcipher (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_has_skcipher}\pysiglinewithargsret{int \bfcode{crypto\_has\_skcipher}}{const char *\emph{ alg\_name}, u32\emph{ type}, u32\emph{ mask}}{}
Search for the availability of an skcipher.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * alg\_name}}] \leavevmode
is the cra\_name / name or cra\_driver\_name / driver name of the
skcipher

\item[{\code{u32 type}}] \leavevmode
specifies the type of the cipher

\item[{\code{u32 mask}}] \leavevmode
specifies the mask for the cipher

\end{description}

\textbf{Return}
\begin{description}
\item[{true when the skcipher is known to the kernel crypto API; false}] \leavevmode
otherwise

\end{description}
\index{crypto\_skcipher\_ivsize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_skcipher_ivsize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_skcipher\_ivsize}}{struct crypto\_skcipher *\emph{ tfm}}{}
obtain IV size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_skcipher * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Description}

The size of the IV for the skcipher referenced by the cipher handle is
returned. This IV size may be zero if the cipher does not need an IV.

\textbf{Return}

IV size in bytes
\index{crypto\_skcipher\_blocksize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_skcipher_blocksize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_skcipher\_blocksize}}{struct crypto\_skcipher *\emph{ tfm}}{}
obtain block size of cipher

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_skcipher * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Description}

The block size for the skcipher referenced with the cipher handle is
returned. The caller may use that information to allocate appropriate
memory for the data returned by the encryption or decryption operation

\textbf{Return}

block size of cipher
\index{crypto\_skcipher\_setkey (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_skcipher_setkey}\pysiglinewithargsret{int \bfcode{crypto\_skcipher\_setkey}}{struct crypto\_skcipher *\emph{ tfm}, const u8 *\emph{ key}, unsigned int\emph{ keylen}}{}
set key for cipher

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_skcipher * tfm}}] \leavevmode
cipher handle

\item[{\code{const u8 * key}}] \leavevmode
buffer holding the key

\item[{\code{unsigned int keylen}}] \leavevmode
length of the key in bytes

\end{description}

\textbf{Description}

The caller provided key is set for the skcipher referenced by the cipher
handle.

Note, the key length determines the cipher type. Many block ciphers implement
different cipher modes depending on the key size, such as AES-128 vs AES-192
vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128
is performed.

\textbf{Return}

0 if the setting of the key was successful; \textless{} 0 if an error occurred
\index{crypto\_skcipher\_reqtfm (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_skcipher_reqtfm}\pysiglinewithargsret{struct crypto\_skcipher * \bfcode{crypto\_skcipher\_reqtfm}}{struct skcipher\_request *\emph{ req}}{}
obtain cipher handle from request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct skcipher\_request * req}}] \leavevmode
skcipher\_request out of which the cipher handle is to be obtained

\end{description}

\textbf{Description}

Return the crypto\_skcipher handle when furnishing an skcipher\_request
data structure.

\textbf{Return}

crypto\_skcipher handle
\index{crypto\_skcipher\_encrypt (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_skcipher_encrypt}\pysiglinewithargsret{int \bfcode{crypto\_skcipher\_encrypt}}{struct skcipher\_request *\emph{ req}}{}
encrypt plaintext

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct skcipher\_request * req}}] \leavevmode
reference to the skcipher\_request handle that holds all information
needed to perform the cipher operation

\end{description}

\textbf{Description}

Encrypt plaintext data using the skcipher\_request handle. That data
structure and how it is filled with data is discussed with the
skcipher\_request\_* functions.

\textbf{Return}

0 if the cipher operation was successful; \textless{} 0 if an error occurred
\index{crypto\_skcipher\_decrypt (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_skcipher_decrypt}\pysiglinewithargsret{int \bfcode{crypto\_skcipher\_decrypt}}{struct skcipher\_request *\emph{ req}}{}
decrypt ciphertext

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct skcipher\_request * req}}] \leavevmode
reference to the skcipher\_request handle that holds all information
needed to perform the cipher operation

\end{description}

\textbf{Description}

Decrypt ciphertext data using the skcipher\_request handle. That data
structure and how it is filled with data is discussed with the
skcipher\_request\_* functions.

\textbf{Return}

0 if the cipher operation was successful; \textless{} 0 if an error occurred


\section{Symmetric Key Cipher Request Handle}
\label{crypto/api-skcipher:symmetric-key-cipher-request-handle}
The skcipher\_request data structure contains all pointers to data
required for the symmetric key cipher operation. This includes the cipher
handle (which can be used by multiple skcipher\_request instances), pointer
to plaintext and ciphertext, asynchronous callback function, etc. It acts
as a handle to the skcipher\_request\_* API calls in a similar way as
skcipher handle to the crypto\_skcipher\_* API calls.
\index{crypto\_skcipher\_reqsize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_skcipher_reqsize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_skcipher\_reqsize}}{struct crypto\_skcipher *\emph{ tfm}}{}
obtain size of the request data structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_skcipher * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Return}

number of bytes
\index{skcipher\_request\_set\_tfm (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.skcipher_request_set_tfm}\pysiglinewithargsret{void \bfcode{skcipher\_request\_set\_tfm}}{struct skcipher\_request *\emph{ req}, struct crypto\_skcipher *\emph{ tfm}}{}
update cipher handle reference in request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct skcipher\_request * req}}] \leavevmode
request handle to be modified

\item[{\code{struct crypto\_skcipher * tfm}}] \leavevmode
cipher handle that shall be added to the request handle

\end{description}

\textbf{Description}

Allow the caller to replace the existing skcipher handle in the request
data structure with a different one.
\index{skcipher\_request\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.skcipher_request_alloc}\pysiglinewithargsret{struct skcipher\_request * \bfcode{skcipher\_request\_alloc}}{struct crypto\_skcipher *\emph{ tfm}, gfp\_t\emph{ gfp}}{}
allocate request data structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_skcipher * tfm}}] \leavevmode
cipher handle to be registered with the request

\item[{\code{gfp\_t gfp}}] \leavevmode
memory allocation flag that is handed to kmalloc by the API call.

\end{description}

\textbf{Description}

Allocate the request data structure that must be used with the skcipher
encrypt and decrypt API calls. During the allocation, the provided skcipher
handle is registered in the request data structure.

\textbf{Return}

allocated request handle in case of success, or NULL if out of memory
\index{skcipher\_request\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.skcipher_request_free}\pysiglinewithargsret{void \bfcode{skcipher\_request\_free}}{struct skcipher\_request *\emph{ req}}{}
zeroize and free request data structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct skcipher\_request * req}}] \leavevmode
request data structure cipher handle to be freed

\end{description}
\index{skcipher\_request\_set\_callback (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.skcipher_request_set_callback}\pysiglinewithargsret{void \bfcode{skcipher\_request\_set\_callback}}{struct skcipher\_request *\emph{ req}, u32\emph{ flags}, crypto\_completion\_t\emph{ compl}, void *\emph{ data}}{}
set asynchronous callback function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct skcipher\_request * req}}] \leavevmode
request handle

\item[{\code{u32 flags}}] \leavevmode
specify zero or an ORing of the flags
CRYPTO\_TFM\_REQ\_MAY\_BACKLOG the request queue may back log and
increase the wait queue beyond the initial maximum size;
CRYPTO\_TFM\_REQ\_MAY\_SLEEP the request processing may sleep

\item[{\code{crypto\_completion\_t compl}}] \leavevmode
callback function pointer to be registered with the request handle

\item[{\code{void * data}}] \leavevmode
The data pointer refers to memory that is not used by the kernel
crypto API, but provided to the callback function for it to use. Here,
the caller can provide a reference to memory the callback function can
operate on. As the callback function is invoked asynchronously to the
related functionality, it may need to access data structures of the
related functionality which can be referenced using this pointer. The
callback function can access the memory via the ``data'' field in the
crypto\_async\_request data structure provided to the callback function.

\end{description}

\textbf{Description}

This function allows setting the callback function that is triggered once the
cipher operation completes.

The callback function is registered with the skcipher\_request handle and
must comply with the following template:

\begin{Verbatim}[commandchars=\\\{\}]
void callback\PYGZus{}function(struct crypto\PYGZus{}async\PYGZus{}request *req, int error)
\end{Verbatim}
\index{skcipher\_request\_set\_crypt (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.skcipher_request_set_crypt}\pysiglinewithargsret{void \bfcode{skcipher\_request\_set\_crypt}}{struct skcipher\_request *\emph{ req}, struct scatterlist *\emph{ src}, struct scatterlist *\emph{ dst}, unsigned int\emph{ cryptlen}, void *\emph{ iv}}{}
set data buffers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct skcipher\_request * req}}] \leavevmode
request handle

\item[{\code{struct scatterlist * src}}] \leavevmode
source scatter / gather list

\item[{\code{struct scatterlist * dst}}] \leavevmode
destination scatter / gather list

\item[{\code{unsigned int cryptlen}}] \leavevmode
number of bytes to process from \textbf{src}

\item[{\code{void * iv}}] \leavevmode
IV for the cipher operation which must comply with the IV size defined
by crypto\_skcipher\_ivsize

\end{description}

\textbf{Description}

This function allows setting of the source data and destination data
scatter / gather lists.

For encryption, the source is treated as the plaintext and the
destination is the ciphertext. For a decryption operation, the use is
reversed - the source is the ciphertext and the destination is the plaintext.


\section{Single Block Cipher API}
\label{crypto/api-skcipher:single-block-cipher-api}
The single block cipher API is used with the ciphers of type
CRYPTO\_ALG\_TYPE\_CIPHER (listed as type ``cipher'' in /proc/crypto).

Using the single block cipher API calls, operations with the basic cipher
primitive can be implemented. These cipher primitives exclude any block
chaining operations including IV handling.

The purpose of this single block cipher API is to support the implementation
of templates or other concepts that only need to perform the cipher operation
on one block at a time. Templates invoke the underlying cipher primitive
block-wise and process either the input or the output data of these cipher
operations.
\index{crypto\_alloc\_cipher (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_alloc_cipher}\pysiglinewithargsret{struct crypto\_cipher * \bfcode{crypto\_alloc\_cipher}}{const char *\emph{ alg\_name}, u32\emph{ type}, u32\emph{ mask}}{}
allocate single block cipher handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * alg\_name}}] \leavevmode
is the cra\_name / name or cra\_driver\_name / driver name of the
single block cipher

\item[{\code{u32 type}}] \leavevmode
specifies the type of the cipher

\item[{\code{u32 mask}}] \leavevmode
specifies the mask for the cipher

\end{description}

\textbf{Description}

Allocate a cipher handle for a single block cipher. The returned struct
crypto\_cipher is the cipher handle that is required for any subsequent API
invocation for that single block cipher.

\textbf{Return}
\begin{description}
\item[{allocated cipher handle in case of success; \code{IS\_ERR()} is true in case}] \leavevmode
of an error, \code{PTR\_ERR()} returns the error code.

\end{description}
\index{crypto\_free\_cipher (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_free_cipher}\pysiglinewithargsret{void \bfcode{crypto\_free\_cipher}}{struct crypto\_cipher *\emph{ tfm}}{}
zeroize and free the single block cipher handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_cipher * tfm}}] \leavevmode
cipher handle to be freed

\end{description}
\index{crypto\_has\_cipher (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_has_cipher}\pysiglinewithargsret{int \bfcode{crypto\_has\_cipher}}{const char *\emph{ alg\_name}, u32\emph{ type}, u32\emph{ mask}}{}
Search for the availability of a single block cipher

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * alg\_name}}] \leavevmode
is the cra\_name / name or cra\_driver\_name / driver name of the
single block cipher

\item[{\code{u32 type}}] \leavevmode
specifies the type of the cipher

\item[{\code{u32 mask}}] \leavevmode
specifies the mask for the cipher

\end{description}

\textbf{Return}
\begin{description}
\item[{true when the single block cipher is known to the kernel crypto API;}] \leavevmode
false otherwise

\end{description}
\index{crypto\_cipher\_blocksize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_cipher_blocksize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_cipher\_blocksize}}{struct crypto\_cipher *\emph{ tfm}}{}
obtain block size for cipher

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_cipher * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Description}

The block size for the single block cipher referenced with the cipher handle
tfm is returned. The caller may use that information to allocate appropriate
memory for the data returned by the encryption or decryption operation

\textbf{Return}

block size of cipher
\index{crypto\_cipher\_setkey (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_cipher_setkey}\pysiglinewithargsret{int \bfcode{crypto\_cipher\_setkey}}{struct crypto\_cipher *\emph{ tfm}, const u8 *\emph{ key}, unsigned int\emph{ keylen}}{}
set key for cipher

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_cipher * tfm}}] \leavevmode
cipher handle

\item[{\code{const u8 * key}}] \leavevmode
buffer holding the key

\item[{\code{unsigned int keylen}}] \leavevmode
length of the key in bytes

\end{description}

\textbf{Description}

The caller provided key is set for the single block cipher referenced by the
cipher handle.

Note, the key length determines the cipher type. Many block ciphers implement
different cipher modes depending on the key size, such as AES-128 vs AES-192
vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128
is performed.

\textbf{Return}

0 if the setting of the key was successful; \textless{} 0 if an error occurred
\index{crypto\_cipher\_encrypt\_one (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_cipher_encrypt_one}\pysiglinewithargsret{void \bfcode{crypto\_cipher\_encrypt\_one}}{struct crypto\_cipher *\emph{ tfm}, u8 *\emph{ dst}, const u8 *\emph{ src}}{}
encrypt one block of plaintext

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_cipher * tfm}}] \leavevmode
cipher handle

\item[{\code{u8 * dst}}] \leavevmode
points to the buffer that will be filled with the ciphertext

\item[{\code{const u8 * src}}] \leavevmode
buffer holding the plaintext to be encrypted

\end{description}

\textbf{Description}

Invoke the encryption operation of one block. The caller must ensure that
the plaintext and ciphertext buffers are at least one block in size.
\index{crypto\_cipher\_decrypt\_one (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_cipher_decrypt_one}\pysiglinewithargsret{void \bfcode{crypto\_cipher\_decrypt\_one}}{struct crypto\_cipher *\emph{ tfm}, u8 *\emph{ dst}, const u8 *\emph{ src}}{}
decrypt one block of ciphertext

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_cipher * tfm}}] \leavevmode
cipher handle

\item[{\code{u8 * dst}}] \leavevmode
points to the buffer that will be filled with the plaintext

\item[{\code{const u8 * src}}] \leavevmode
buffer holding the ciphertext to be decrypted

\end{description}

\textbf{Description}

Invoke the decryption operation of one block. The caller must ensure that
the plaintext and ciphertext buffers are at least one block in size.


\section{Asynchronous Block Cipher API - Deprecated}
\label{crypto/api-skcipher:asynchronous-block-cipher-api-deprecated}
Asynchronous block cipher API is used with the ciphers of type
CRYPTO\_ALG\_TYPE\_ABLKCIPHER (listed as type ``ablkcipher'' in /proc/crypto).

Asynchronous cipher operations imply that the function invocation for a
cipher request returns immediately before the completion of the operation.
The cipher request is scheduled as a separate kernel thread and therefore
load-balanced on the different CPUs via the process scheduler. To allow
the kernel crypto API to inform the caller about the completion of a cipher
request, the caller must provide a callback function. That function is
invoked with the cipher handle when the request completes.

To support the asynchronous operation, additional information than just the
cipher handle must be supplied to the kernel crypto API. That additional
information is given by filling in the ablkcipher\_request data structure.

For the asynchronous block cipher API, the state is maintained with the tfm
cipher handle. A single tfm can be used across multiple calls and in
parallel. For asynchronous block cipher calls, context data supplied and
only used by the caller can be referenced the request data structure in
addition to the IV used for the cipher request. The maintenance of such
state information would be important for a crypto driver implementer to
have, because when calling the callback function upon completion of the
cipher operation, that callback function may need some information about
which operation just finished if it invoked multiple in parallel. This
state information is unused by the kernel crypto API.
\index{crypto\_free\_ablkcipher (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_free_ablkcipher}\pysiglinewithargsret{void \bfcode{crypto\_free\_ablkcipher}}{struct crypto\_ablkcipher *\emph{ tfm}}{}
zeroize and free cipher handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_ablkcipher * tfm}}] \leavevmode
cipher handle to be freed

\end{description}
\index{crypto\_has\_ablkcipher (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_has_ablkcipher}\pysiglinewithargsret{int \bfcode{crypto\_has\_ablkcipher}}{const char *\emph{ alg\_name}, u32\emph{ type}, u32\emph{ mask}}{}
Search for the availability of an ablkcipher.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * alg\_name}}] \leavevmode
is the cra\_name / name or cra\_driver\_name / driver name of the
ablkcipher

\item[{\code{u32 type}}] \leavevmode
specifies the type of the cipher

\item[{\code{u32 mask}}] \leavevmode
specifies the mask for the cipher

\end{description}

\textbf{Return}
\begin{description}
\item[{true when the ablkcipher is known to the kernel crypto API; false}] \leavevmode
otherwise

\end{description}
\index{crypto\_ablkcipher\_ivsize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_ablkcipher_ivsize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_ablkcipher\_ivsize}}{struct crypto\_ablkcipher *\emph{ tfm}}{}
obtain IV size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_ablkcipher * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Description}

The size of the IV for the ablkcipher referenced by the cipher handle is
returned. This IV size may be zero if the cipher does not need an IV.

\textbf{Return}

IV size in bytes
\index{crypto\_ablkcipher\_blocksize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_ablkcipher_blocksize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_ablkcipher\_blocksize}}{struct crypto\_ablkcipher *\emph{ tfm}}{}
obtain block size of cipher

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_ablkcipher * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Description}

The block size for the ablkcipher referenced with the cipher handle is
returned. The caller may use that information to allocate appropriate
memory for the data returned by the encryption or decryption operation

\textbf{Return}

block size of cipher
\index{crypto\_ablkcipher\_setkey (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_ablkcipher_setkey}\pysiglinewithargsret{int \bfcode{crypto\_ablkcipher\_setkey}}{struct crypto\_ablkcipher *\emph{ tfm}, const u8 *\emph{ key}, unsigned int\emph{ keylen}}{}
set key for cipher

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_ablkcipher * tfm}}] \leavevmode
cipher handle

\item[{\code{const u8 * key}}] \leavevmode
buffer holding the key

\item[{\code{unsigned int keylen}}] \leavevmode
length of the key in bytes

\end{description}

\textbf{Description}

The caller provided key is set for the ablkcipher referenced by the cipher
handle.

Note, the key length determines the cipher type. Many block ciphers implement
different cipher modes depending on the key size, such as AES-128 vs AES-192
vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128
is performed.

\textbf{Return}

0 if the setting of the key was successful; \textless{} 0 if an error occurred
\index{crypto\_ablkcipher\_reqtfm (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_ablkcipher_reqtfm}\pysiglinewithargsret{struct crypto\_ablkcipher * \bfcode{crypto\_ablkcipher\_reqtfm}}{struct ablkcipher\_request *\emph{ req}}{}
obtain cipher handle from request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ablkcipher\_request * req}}] \leavevmode
ablkcipher\_request out of which the cipher handle is to be obtained

\end{description}

\textbf{Description}

Return the crypto\_ablkcipher handle when furnishing an ablkcipher\_request
data structure.

\textbf{Return}

crypto\_ablkcipher handle
\index{crypto\_ablkcipher\_encrypt (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_ablkcipher_encrypt}\pysiglinewithargsret{int \bfcode{crypto\_ablkcipher\_encrypt}}{struct ablkcipher\_request *\emph{ req}}{}
encrypt plaintext

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ablkcipher\_request * req}}] \leavevmode
reference to the ablkcipher\_request handle that holds all information
needed to perform the cipher operation

\end{description}

\textbf{Description}

Encrypt plaintext data using the ablkcipher\_request handle. That data
structure and how it is filled with data is discussed with the
ablkcipher\_request\_* functions.

\textbf{Return}

0 if the cipher operation was successful; \textless{} 0 if an error occurred
\index{crypto\_ablkcipher\_decrypt (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_ablkcipher_decrypt}\pysiglinewithargsret{int \bfcode{crypto\_ablkcipher\_decrypt}}{struct ablkcipher\_request *\emph{ req}}{}
decrypt ciphertext

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ablkcipher\_request * req}}] \leavevmode
reference to the ablkcipher\_request handle that holds all information
needed to perform the cipher operation

\end{description}

\textbf{Description}

Decrypt ciphertext data using the ablkcipher\_request handle. That data
structure and how it is filled with data is discussed with the
ablkcipher\_request\_* functions.

\textbf{Return}

0 if the cipher operation was successful; \textless{} 0 if an error occurred


\section{Asynchronous Cipher Request Handle - Deprecated}
\label{crypto/api-skcipher:asynchronous-cipher-request-handle-deprecated}
The ablkcipher\_request data structure contains all pointers to data
required for the asynchronous cipher operation. This includes the cipher
handle (which can be used by multiple ablkcipher\_request instances), pointer
to plaintext and ciphertext, asynchronous callback function, etc. It acts
as a handle to the ablkcipher\_request\_* API calls in a similar way as
ablkcipher handle to the crypto\_ablkcipher\_* API calls.
\index{crypto\_ablkcipher\_reqsize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_ablkcipher_reqsize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_ablkcipher\_reqsize}}{struct crypto\_ablkcipher *\emph{ tfm}}{}
obtain size of the request data structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_ablkcipher * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Return}

number of bytes
\index{ablkcipher\_request\_set\_tfm (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.ablkcipher_request_set_tfm}\pysiglinewithargsret{void \bfcode{ablkcipher\_request\_set\_tfm}}{struct ablkcipher\_request *\emph{ req}, struct crypto\_ablkcipher *\emph{ tfm}}{}
update cipher handle reference in request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ablkcipher\_request * req}}] \leavevmode
request handle to be modified

\item[{\code{struct crypto\_ablkcipher * tfm}}] \leavevmode
cipher handle that shall be added to the request handle

\end{description}

\textbf{Description}

Allow the caller to replace the existing ablkcipher handle in the request
data structure with a different one.
\index{ablkcipher\_request\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.ablkcipher_request_alloc}\pysiglinewithargsret{struct ablkcipher\_request * \bfcode{ablkcipher\_request\_alloc}}{struct crypto\_ablkcipher *\emph{ tfm}, gfp\_t\emph{ gfp}}{}
allocate request data structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_ablkcipher * tfm}}] \leavevmode
cipher handle to be registered with the request

\item[{\code{gfp\_t gfp}}] \leavevmode
memory allocation flag that is handed to kmalloc by the API call.

\end{description}

\textbf{Description}

Allocate the request data structure that must be used with the ablkcipher
encrypt and decrypt API calls. During the allocation, the provided ablkcipher
handle is registered in the request data structure.

\textbf{Return}

allocated request handle in case of success, or NULL if out of memory
\index{ablkcipher\_request\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.ablkcipher_request_free}\pysiglinewithargsret{void \bfcode{ablkcipher\_request\_free}}{struct ablkcipher\_request *\emph{ req}}{}
zeroize and free request data structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ablkcipher\_request * req}}] \leavevmode
request data structure cipher handle to be freed

\end{description}
\index{ablkcipher\_request\_set\_callback (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.ablkcipher_request_set_callback}\pysiglinewithargsret{void \bfcode{ablkcipher\_request\_set\_callback}}{struct ablkcipher\_request *\emph{ req}, u32\emph{ flags}, crypto\_completion\_t\emph{ compl}, void *\emph{ data}}{}
set asynchronous callback function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ablkcipher\_request * req}}] \leavevmode
request handle

\item[{\code{u32 flags}}] \leavevmode
specify zero or an ORing of the flags
CRYPTO\_TFM\_REQ\_MAY\_BACKLOG the request queue may back log and
increase the wait queue beyond the initial maximum size;
CRYPTO\_TFM\_REQ\_MAY\_SLEEP the request processing may sleep

\item[{\code{crypto\_completion\_t compl}}] \leavevmode
callback function pointer to be registered with the request handle

\item[{\code{void * data}}] \leavevmode
The data pointer refers to memory that is not used by the kernel
crypto API, but provided to the callback function for it to use. Here,
the caller can provide a reference to memory the callback function can
operate on. As the callback function is invoked asynchronously to the
related functionality, it may need to access data structures of the
related functionality which can be referenced using this pointer. The
callback function can access the memory via the ``data'' field in the
crypto\_async\_request data structure provided to the callback function.

\end{description}

\textbf{Description}

This function allows setting the callback function that is triggered once the
cipher operation completes.

The callback function is registered with the ablkcipher\_request handle and
must comply with the following template:

\begin{Verbatim}[commandchars=\\\{\}]
void callback\PYGZus{}function(struct crypto\PYGZus{}async\PYGZus{}request *req, int error)
\end{Verbatim}
\index{ablkcipher\_request\_set\_crypt (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.ablkcipher_request_set_crypt}\pysiglinewithargsret{void \bfcode{ablkcipher\_request\_set\_crypt}}{struct ablkcipher\_request *\emph{ req}, struct scatterlist *\emph{ src}, struct scatterlist *\emph{ dst}, unsigned int\emph{ nbytes}, void *\emph{ iv}}{}
set data buffers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ablkcipher\_request * req}}] \leavevmode
request handle

\item[{\code{struct scatterlist * src}}] \leavevmode
source scatter / gather list

\item[{\code{struct scatterlist * dst}}] \leavevmode
destination scatter / gather list

\item[{\code{unsigned int nbytes}}] \leavevmode
number of bytes to process from \textbf{src}

\item[{\code{void * iv}}] \leavevmode
IV for the cipher operation which must comply with the IV size defined
by crypto\_ablkcipher\_ivsize

\end{description}

\textbf{Description}

This function allows setting of the source data and destination data
scatter / gather lists.

For encryption, the source is treated as the plaintext and the
destination is the ciphertext. For a decryption operation, the use is
reversed - the source is the ciphertext and the destination is the plaintext.


\section{Synchronous Block Cipher API - Deprecated}
\label{crypto/api-skcipher:synchronous-block-cipher-api-deprecated}
The synchronous block cipher API is used with the ciphers of type
CRYPTO\_ALG\_TYPE\_BLKCIPHER (listed as type ``blkcipher'' in /proc/crypto)

Synchronous calls, have a context in the tfm. But since a single tfm can be
used in multiple calls and in parallel, this info should not be changeable
(unless a lock is used). This applies, for example, to the symmetric key.
However, the IV is changeable, so there is an iv field in blkcipher\_tfm
structure for synchronous blkcipher api. So, its the only state info that can
be kept for synchronous calls without using a big lock across a tfm.

The block cipher API allows the use of a complete cipher, i.e. a cipher
consisting of a template (a block chaining mode) and a single block cipher
primitive (e.g. AES).

The plaintext data buffer and the ciphertext data buffer are pointed to
by using scatter/gather lists. The cipher operation is performed
on all segments of the provided scatter/gather lists.

The kernel crypto API supports a cipher operation ``in-place'' which means that
the caller may provide the same scatter/gather list for the plaintext and
cipher text. After the completion of the cipher operation, the plaintext
data is replaced with the ciphertext data in case of an encryption and vice
versa for a decryption. The caller must ensure that the scatter/gather lists
for the output data point to sufficiently large buffers, i.e. multiples of
the block size of the cipher.
\index{crypto\_alloc\_blkcipher (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_alloc_blkcipher}\pysiglinewithargsret{struct crypto\_blkcipher * \bfcode{crypto\_alloc\_blkcipher}}{const char *\emph{ alg\_name}, u32\emph{ type}, u32\emph{ mask}}{}
allocate synchronous block cipher handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * alg\_name}}] \leavevmode
is the cra\_name / name or cra\_driver\_name / driver name of the
blkcipher cipher

\item[{\code{u32 type}}] \leavevmode
specifies the type of the cipher

\item[{\code{u32 mask}}] \leavevmode
specifies the mask for the cipher

\end{description}

\textbf{Description}

Allocate a cipher handle for a block cipher. The returned struct
crypto\_blkcipher is the cipher handle that is required for any subsequent
API invocation for that block cipher.

\textbf{Return}
\begin{description}
\item[{allocated cipher handle in case of success; \code{IS\_ERR()} is true in case}] \leavevmode
of an error, \code{PTR\_ERR()} returns the error code.

\end{description}
\index{crypto\_free\_blkcipher (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_free_blkcipher}\pysiglinewithargsret{void \bfcode{crypto\_free\_blkcipher}}{struct crypto\_blkcipher *\emph{ tfm}}{}
zeroize and free the block cipher handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_blkcipher * tfm}}] \leavevmode
cipher handle to be freed

\end{description}
\index{crypto\_has\_blkcipher (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_has_blkcipher}\pysiglinewithargsret{int \bfcode{crypto\_has\_blkcipher}}{const char *\emph{ alg\_name}, u32\emph{ type}, u32\emph{ mask}}{}
Search for the availability of a block cipher

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * alg\_name}}] \leavevmode
is the cra\_name / name or cra\_driver\_name / driver name of the
block cipher

\item[{\code{u32 type}}] \leavevmode
specifies the type of the cipher

\item[{\code{u32 mask}}] \leavevmode
specifies the mask for the cipher

\end{description}

\textbf{Return}
\begin{description}
\item[{true when the block cipher is known to the kernel crypto API; false}] \leavevmode
otherwise

\end{description}
\index{crypto\_blkcipher\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_blkcipher_name}\pysiglinewithargsret{const char * \bfcode{crypto\_blkcipher\_name}}{struct crypto\_blkcipher *\emph{ tfm}}{}
return the name / cra\_name from the cipher handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_blkcipher * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Return}

The character string holding the name of the cipher
\index{crypto\_blkcipher\_ivsize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_blkcipher_ivsize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_blkcipher\_ivsize}}{struct crypto\_blkcipher *\emph{ tfm}}{}
obtain IV size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_blkcipher * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Description}

The size of the IV for the block cipher referenced by the cipher handle is
returned. This IV size may be zero if the cipher does not need an IV.

\textbf{Return}

IV size in bytes
\index{crypto\_blkcipher\_blocksize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_blkcipher_blocksize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_blkcipher\_blocksize}}{struct crypto\_blkcipher *\emph{ tfm}}{}
obtain block size of cipher

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_blkcipher * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Description}

The block size for the block cipher referenced with the cipher handle is
returned. The caller may use that information to allocate appropriate
memory for the data returned by the encryption or decryption operation.

\textbf{Return}

block size of cipher
\index{crypto\_blkcipher\_setkey (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_blkcipher_setkey}\pysiglinewithargsret{int \bfcode{crypto\_blkcipher\_setkey}}{struct crypto\_blkcipher *\emph{ tfm}, const u8 *\emph{ key}, unsigned int\emph{ keylen}}{}
set key for cipher

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_blkcipher * tfm}}] \leavevmode
cipher handle

\item[{\code{const u8 * key}}] \leavevmode
buffer holding the key

\item[{\code{unsigned int keylen}}] \leavevmode
length of the key in bytes

\end{description}

\textbf{Description}

The caller provided key is set for the block cipher referenced by the cipher
handle.

Note, the key length determines the cipher type. Many block ciphers implement
different cipher modes depending on the key size, such as AES-128 vs AES-192
vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128
is performed.

\textbf{Return}

0 if the setting of the key was successful; \textless{} 0 if an error occurred
\index{crypto\_blkcipher\_encrypt (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_blkcipher_encrypt}\pysiglinewithargsret{int \bfcode{crypto\_blkcipher\_encrypt}}{struct blkcipher\_desc *\emph{ desc}, struct scatterlist *\emph{ dst}, struct scatterlist *\emph{ src}, unsigned int\emph{ nbytes}}{}
encrypt plaintext

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct blkcipher\_desc * desc}}] \leavevmode
reference to the block cipher handle with meta data

\item[{\code{struct scatterlist * dst}}] \leavevmode
scatter/gather list that is filled by the cipher operation with the
ciphertext

\item[{\code{struct scatterlist * src}}] \leavevmode
scatter/gather list that holds the plaintext

\item[{\code{unsigned int nbytes}}] \leavevmode
number of bytes of the plaintext to encrypt.

\end{description}

\textbf{Description}

Encrypt plaintext data using the IV set by the caller with a preceding
call of crypto\_blkcipher\_set\_iv.

The blkcipher\_desc data structure must be filled by the caller and can
reside on the stack. The caller must fill desc as follows: desc.tfm is filled
with the block cipher handle; desc.flags is filled with either
CRYPTO\_TFM\_REQ\_MAY\_SLEEP or 0.

\textbf{Return}

0 if the cipher operation was successful; \textless{} 0 if an error occurred
\index{crypto\_blkcipher\_encrypt\_iv (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_blkcipher_encrypt_iv}\pysiglinewithargsret{int \bfcode{crypto\_blkcipher\_encrypt\_iv}}{struct blkcipher\_desc *\emph{ desc}, struct scatterlist *\emph{ dst}, struct scatterlist *\emph{ src}, unsigned int\emph{ nbytes}}{}
encrypt plaintext with dedicated IV

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct blkcipher\_desc * desc}}] \leavevmode
reference to the block cipher handle with meta data

\item[{\code{struct scatterlist * dst}}] \leavevmode
scatter/gather list that is filled by the cipher operation with the
ciphertext

\item[{\code{struct scatterlist * src}}] \leavevmode
scatter/gather list that holds the plaintext

\item[{\code{unsigned int nbytes}}] \leavevmode
number of bytes of the plaintext to encrypt.

\end{description}

\textbf{Description}

Encrypt plaintext data with the use of an IV that is solely used for this
cipher operation. Any previously set IV is not used.

The blkcipher\_desc data structure must be filled by the caller and can
reside on the stack. The caller must fill desc as follows: desc.tfm is filled
with the block cipher handle; desc.info is filled with the IV to be used for
the current operation; desc.flags is filled with either
CRYPTO\_TFM\_REQ\_MAY\_SLEEP or 0.

\textbf{Return}

0 if the cipher operation was successful; \textless{} 0 if an error occurred
\index{crypto\_blkcipher\_decrypt (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_blkcipher_decrypt}\pysiglinewithargsret{int \bfcode{crypto\_blkcipher\_decrypt}}{struct blkcipher\_desc *\emph{ desc}, struct scatterlist *\emph{ dst}, struct scatterlist *\emph{ src}, unsigned int\emph{ nbytes}}{}
decrypt ciphertext

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct blkcipher\_desc * desc}}] \leavevmode
reference to the block cipher handle with meta data

\item[{\code{struct scatterlist * dst}}] \leavevmode
scatter/gather list that is filled by the cipher operation with the
plaintext

\item[{\code{struct scatterlist * src}}] \leavevmode
scatter/gather list that holds the ciphertext

\item[{\code{unsigned int nbytes}}] \leavevmode
number of bytes of the ciphertext to decrypt.

\end{description}

\textbf{Description}

Decrypt ciphertext data using the IV set by the caller with a preceding
call of crypto\_blkcipher\_set\_iv.

The blkcipher\_desc data structure must be filled by the caller as documented
for the crypto\_blkcipher\_encrypt call above.

\textbf{Return}

0 if the cipher operation was successful; \textless{} 0 if an error occurred
\index{crypto\_blkcipher\_decrypt\_iv (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_blkcipher_decrypt_iv}\pysiglinewithargsret{int \bfcode{crypto\_blkcipher\_decrypt\_iv}}{struct blkcipher\_desc *\emph{ desc}, struct scatterlist *\emph{ dst}, struct scatterlist *\emph{ src}, unsigned int\emph{ nbytes}}{}
decrypt ciphertext with dedicated IV

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct blkcipher\_desc * desc}}] \leavevmode
reference to the block cipher handle with meta data

\item[{\code{struct scatterlist * dst}}] \leavevmode
scatter/gather list that is filled by the cipher operation with the
plaintext

\item[{\code{struct scatterlist * src}}] \leavevmode
scatter/gather list that holds the ciphertext

\item[{\code{unsigned int nbytes}}] \leavevmode
number of bytes of the ciphertext to decrypt.

\end{description}

\textbf{Description}

Decrypt ciphertext data with the use of an IV that is solely used for this
cipher operation. Any previously set IV is not used.

The blkcipher\_desc data structure must be filled by the caller as documented
for the crypto\_blkcipher\_encrypt\_iv call above.

\textbf{Return}

0 if the cipher operation was successful; \textless{} 0 if an error occurred
\index{crypto\_blkcipher\_set\_iv (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_blkcipher_set_iv}\pysiglinewithargsret{void \bfcode{crypto\_blkcipher\_set\_iv}}{struct crypto\_blkcipher *\emph{ tfm}, const u8 *\emph{ src}, unsigned int\emph{ len}}{}
set IV for cipher

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_blkcipher * tfm}}] \leavevmode
cipher handle

\item[{\code{const u8 * src}}] \leavevmode
buffer holding the IV

\item[{\code{unsigned int len}}] \leavevmode
length of the IV in bytes

\end{description}

\textbf{Description}

The caller provided IV is set for the block cipher referenced by the cipher
handle.
\index{crypto\_blkcipher\_get\_iv (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-skcipher:c.crypto_blkcipher_get_iv}\pysiglinewithargsret{void \bfcode{crypto\_blkcipher\_get\_iv}}{struct crypto\_blkcipher *\emph{ tfm}, u8 *\emph{ dst}, unsigned int\emph{ len}}{}
obtain IV from cipher

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_blkcipher * tfm}}] \leavevmode
cipher handle

\item[{\code{u8 * dst}}] \leavevmode
buffer filled with the IV

\item[{\code{unsigned int len}}] \leavevmode
length of the buffer dst

\end{description}

\textbf{Description}

The caller can obtain the IV set for the block cipher referenced by the
cipher handle and store it into the user-provided buffer. If the buffer
has an insufficient space, the IV is truncated to fit the buffer.


\section{Authenticated Encryption With Associated Data (AEAD) Algorithm Definitions}
\label{crypto/api-aead::doc}\label{crypto/api-aead:authenticated-encryption-with-associated-data-aead-algorithm-definitions}
The AEAD cipher API is used with the ciphers of type CRYPTO\_ALG\_TYPE\_AEAD
(listed as type ``aead'' in /proc/crypto)

The most prominent examples for this type of encryption is GCM and CCM.
However, the kernel supports other types of AEAD ciphers which are defined
with the following cipher string:
\begin{quote}

authenc(keyed message digest, block cipher)
\end{quote}

For example: authenc(hmac(sha256), cbc(aes))

The example code provided for the symmetric key cipher operation
applies here as well. Naturally all \emph{skcipher} symbols must be exchanged
the \emph{aead} pendants discussed in the following. In addition, for the AEAD
operation, the aead\_request\_set\_ad function must be used to set the
pointer to the associated data memory location before performing the
encryption or decryption operation. In case of an encryption, the associated
data memory is filled during the encryption operation. For decryption, the
associated data memory must contain data that is used to verify the integrity
of the decrypted data. Another deviation from the asynchronous block cipher
operation is that the caller should explicitly check for -EBADMSG of the
crypto\_aead\_decrypt. That error indicates an authentication error, i.e.
a breach in the integrity of the message. In essence, that -EBADMSG error
code is the key bonus an AEAD cipher has over ``standard'' block chaining
modes.

Memory Structure:

To support the needs of the most prominent user of AEAD ciphers, namely
IPSEC, the AEAD ciphers have a special memory layout the caller must adhere
to.

The scatter list pointing to the input data must contain:
\begin{itemize}
\item {} 
for RFC4106 ciphers, the concatenation of
associated authentication data \textbar{}\textbar{} IV \textbar{}\textbar{} plaintext or ciphertext. Note, the
same IV (buffer) is also set with the aead\_request\_set\_crypt call. Note,
the API call of aead\_request\_set\_ad must provide the length of the AAD and
the IV. The API call of aead\_request\_set\_crypt only points to the size of
the input plaintext or ciphertext.

\item {} 
for ``normal'' AEAD ciphers, the concatenation of
associated authentication data \textbar{}\textbar{} plaintext or ciphertext.

\end{itemize}

It is important to note that if multiple scatter gather list entries form
the input data mentioned above, the first entry must not point to a NULL
buffer. If there is any potential where the AAD buffer can be NULL, the
calling code must contain a precaution to ensure that this does not result
in the first scatter gather list entry pointing to a NULL buffer.
\index{aead\_request (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.aead_request}\pysigline{struct \bfcode{aead\_request}}
AEAD request

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct aead\PYGZus{}request \PYGZob{}
  struct crypto\PYGZus{}async\PYGZus{}request base;
  unsigned int assoclen;
  unsigned int cryptlen;
  u8 *iv;
  struct scatterlist *src;
  struct scatterlist *dst;
  void *\PYGZus{}\PYGZus{}ctx[];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{base}}] \leavevmode
Common attributes for async crypto requests

\item[{\code{assoclen}}] \leavevmode
Length in bytes of associated data for authentication

\item[{\code{cryptlen}}] \leavevmode
Length of data to be encrypted or decrypted

\item[{\code{iv}}] \leavevmode
Initialisation vector

\item[{\code{src}}] \leavevmode
Source data

\item[{\code{dst}}] \leavevmode
Destination data

\item[{\code{\_\_ctx}}] \leavevmode
Start of private context data

\end{description}
\index{aead\_alg (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.aead_alg}\pysigline{struct \bfcode{aead\_alg}}
AEAD cipher definition

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct aead\PYGZus{}alg \PYGZob{}
  int (*setkey)(struct crypto\PYGZus{}aead *tfm, const u8 *key, unsigned int keylen);
  int (*setauthsize)(struct crypto\PYGZus{}aead *tfm, unsigned int authsize);
  int (*encrypt)(struct aead\PYGZus{}request *req);
  int (*decrypt)(struct aead\PYGZus{}request *req);
  int (*init)(struct crypto\PYGZus{}aead *tfm);
  void (*exit)(struct crypto\PYGZus{}aead *tfm);
  const char *geniv;
  unsigned int ivsize;
  unsigned int maxauthsize;
  unsigned int chunksize;
  struct crypto\PYGZus{}alg base;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{setkey}}] \leavevmode
see struct skcipher\_alg

\item[{\code{setauthsize}}] \leavevmode
Set authentication size for the AEAD transformation. This
function is used to specify the consumer requested size of the
authentication tag to be either generated by the transformation
during encryption or the size of the authentication tag to be
supplied during the decryption operation. This function is also
responsible for checking the authentication tag size for
validity.

\item[{\code{encrypt}}] \leavevmode
see struct skcipher\_alg

\item[{\code{decrypt}}] \leavevmode
see struct skcipher\_alg

\item[{\code{init}}] \leavevmode
Initialize the cryptographic transformation object. This function
is used to initialize the cryptographic transformation object.
This function is called only once at the instantiation time, right
after the transformation context was allocated. In case the
cryptographic hardware has some special requirements which need to
be handled by software, this function shall check for the precise
requirement of the transformation and put any software fallbacks
in place.

\item[{\code{exit}}] \leavevmode
Deinitialize the cryptographic transformation object. This is a
counterpart to \textbf{init}, used to remove various changes set in
\textbf{init}.

\item[{\code{geniv}}] \leavevmode
see struct skcipher\_alg

\item[{\code{ivsize}}] \leavevmode
see struct skcipher\_alg

\item[{\code{maxauthsize}}] \leavevmode
Set the maximum authentication tag size supported by the
transformation. A transformation may support smaller tag sizes.
As the authentication tag is a message digest to ensure the
integrity of the encrypted data, a consumer typically wants the
largest authentication tag possible as defined by this
variable.

\item[{\code{chunksize}}] \leavevmode
see struct skcipher\_alg

\item[{\code{base}}] \leavevmode
Definition of a generic crypto cipher algorithm.

\end{description}

\textbf{Description}

All fields except \textbf{ivsize} is mandatory and must be filled.


\section{Authenticated Encryption With Associated Data (AEAD) Cipher API}
\label{crypto/api-aead:authenticated-encryption-with-associated-data-aead-cipher-api}\index{crypto\_alloc\_aead (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.crypto_alloc_aead}\pysiglinewithargsret{struct crypto\_aead * \bfcode{crypto\_alloc\_aead}}{const char *\emph{ alg\_name}, u32\emph{ type}, u32\emph{ mask}}{}
allocate AEAD cipher handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * alg\_name}}] \leavevmode
is the cra\_name / name or cra\_driver\_name / driver name of the
AEAD cipher

\item[{\code{u32 type}}] \leavevmode
specifies the type of the cipher

\item[{\code{u32 mask}}] \leavevmode
specifies the mask for the cipher

\end{description}

\textbf{Description}

Allocate a cipher handle for an AEAD. The returned struct
crypto\_aead is the cipher handle that is required for any subsequent
API invocation for that AEAD.

\textbf{Return}
\begin{description}
\item[{allocated cipher handle in case of success; \code{IS\_ERR()} is true in case}] \leavevmode
of an error, \code{PTR\_ERR()} returns the error code.

\end{description}
\index{crypto\_free\_aead (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.crypto_free_aead}\pysiglinewithargsret{void \bfcode{crypto\_free\_aead}}{struct crypto\_aead *\emph{ tfm}}{}
zeroize and free aead handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_aead * tfm}}] \leavevmode
cipher handle to be freed

\end{description}
\index{crypto\_aead\_ivsize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.crypto_aead_ivsize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_aead\_ivsize}}{struct crypto\_aead *\emph{ tfm}}{}
obtain IV size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_aead * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Description}

The size of the IV for the aead referenced by the cipher handle is
returned. This IV size may be zero if the cipher does not need an IV.

\textbf{Return}

IV size in bytes
\index{crypto\_aead\_authsize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.crypto_aead_authsize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_aead\_authsize}}{struct crypto\_aead *\emph{ tfm}}{}
obtain maximum authentication data size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_aead * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Description}

The maximum size of the authentication data for the AEAD cipher referenced
by the AEAD cipher handle is returned. The authentication data size may be
zero if the cipher implements a hard-coded maximum.

The authentication data may also be known as ``tag value''.

\textbf{Return}

authentication data size / tag size in bytes
\index{crypto\_aead\_blocksize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.crypto_aead_blocksize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_aead\_blocksize}}{struct crypto\_aead *\emph{ tfm}}{}
obtain block size of cipher

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_aead * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Description}

The block size for the AEAD referenced with the cipher handle is returned.
The caller may use that information to allocate appropriate memory for the
data returned by the encryption or decryption operation

\textbf{Return}

block size of cipher
\index{crypto\_aead\_setkey (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.crypto_aead_setkey}\pysiglinewithargsret{int \bfcode{crypto\_aead\_setkey}}{struct crypto\_aead *\emph{ tfm}, const u8 *\emph{ key}, unsigned int\emph{ keylen}}{}
set key for cipher

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_aead * tfm}}] \leavevmode
cipher handle

\item[{\code{const u8 * key}}] \leavevmode
buffer holding the key

\item[{\code{unsigned int keylen}}] \leavevmode
length of the key in bytes

\end{description}

\textbf{Description}

The caller provided key is set for the AEAD referenced by the cipher
handle.

Note, the key length determines the cipher type. Many block ciphers implement
different cipher modes depending on the key size, such as AES-128 vs AES-192
vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128
is performed.

\textbf{Return}

0 if the setting of the key was successful; \textless{} 0 if an error occurred
\index{crypto\_aead\_setauthsize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.crypto_aead_setauthsize}\pysiglinewithargsret{int \bfcode{crypto\_aead\_setauthsize}}{struct crypto\_aead *\emph{ tfm}, unsigned int\emph{ authsize}}{}
set authentication data size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_aead * tfm}}] \leavevmode
cipher handle

\item[{\code{unsigned int authsize}}] \leavevmode
size of the authentication data / tag in bytes

\end{description}

\textbf{Description}

Set the authentication data size / tag size. AEAD requires an authentication
tag (or MAC) in addition to the associated data.

\textbf{Return}

0 if the setting of the key was successful; \textless{} 0 if an error occurred
\index{crypto\_aead\_encrypt (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.crypto_aead_encrypt}\pysiglinewithargsret{int \bfcode{crypto\_aead\_encrypt}}{struct {\hyperref[crypto/api\string-aead:c.aead_request]{\emph{aead\_request}}} *\emph{ req}}{}
encrypt plaintext

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct aead\_request * req}}] \leavevmode
reference to the aead\_request handle that holds all information
needed to perform the cipher operation

\end{description}

\textbf{Description}

Encrypt plaintext data using the aead\_request handle. That data structure
and how it is filled with data is discussed with the aead\_request\_*
functions.
\begin{description}
\item[{IMPORTANT NOTE The encryption operation creates the authentication data /}] \leavevmode
tag. That data is concatenated with the created ciphertext.
The ciphertext memory size is therefore the given number of
block cipher blocks + the size defined by the
crypto\_aead\_setauthsize invocation. The caller must ensure
that sufficient memory is available for the ciphertext and
the authentication tag.

\end{description}

\textbf{Return}

0 if the cipher operation was successful; \textless{} 0 if an error occurred
\index{crypto\_aead\_decrypt (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.crypto_aead_decrypt}\pysiglinewithargsret{int \bfcode{crypto\_aead\_decrypt}}{struct {\hyperref[crypto/api\string-aead:c.aead_request]{\emph{aead\_request}}} *\emph{ req}}{}
decrypt ciphertext

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct aead\_request * req}}] \leavevmode
reference to the ablkcipher\_request handle that holds all information
needed to perform the cipher operation

\end{description}

\textbf{Description}

Decrypt ciphertext data using the aead\_request handle. That data structure
and how it is filled with data is discussed with the aead\_request\_*
functions.
\begin{description}
\item[{IMPORTANT NOTE The caller must concatenate the ciphertext followed by the}] \leavevmode
authentication data / tag. That authentication data / tag
must have the size defined by the crypto\_aead\_setauthsize
invocation.

\end{description}

\textbf{Return}
\begin{description}
\item[{0 if the cipher operation was successful; -EBADMSG: The AEAD}] \leavevmode
cipher operation performs the authentication of the data during the
decryption operation. Therefore, the function returns this error if
the authentication of the ciphertext was unsuccessful (i.e. the
integrity of the ciphertext or the associated data was violated);
\textless{} 0 if an error occurred.

\end{description}


\section{Asynchronous AEAD Request Handle}
\label{crypto/api-aead:asynchronous-aead-request-handle}
The aead\_request data structure contains all pointers to data required for
the AEAD cipher operation. This includes the cipher handle (which can be
used by multiple aead\_request instances), pointer to plaintext and
ciphertext, asynchronous callback function, etc. It acts as a handle to the
aead\_request\_* API calls in a similar way as AEAD handle to the
crypto\_aead\_* API calls.
\index{crypto\_aead\_reqsize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.crypto_aead_reqsize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_aead\_reqsize}}{struct crypto\_aead *\emph{ tfm}}{}
obtain size of the request data structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_aead * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Return}

number of bytes
\index{aead\_request\_set\_tfm (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.aead_request_set_tfm}\pysiglinewithargsret{void \bfcode{aead\_request\_set\_tfm}}{struct {\hyperref[crypto/api\string-aead:c.aead_request]{\emph{aead\_request}}} *\emph{ req}, struct crypto\_aead *\emph{ tfm}}{}
update cipher handle reference in request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct aead\_request * req}}] \leavevmode
request handle to be modified

\item[{\code{struct crypto\_aead * tfm}}] \leavevmode
cipher handle that shall be added to the request handle

\end{description}

\textbf{Description}

Allow the caller to replace the existing aead handle in the request
data structure with a different one.
\index{aead\_request\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.aead_request_alloc}\pysiglinewithargsret{struct {\hyperref[crypto/api\string-aead:c.aead_request]{\emph{aead\_request}}} * \bfcode{aead\_request\_alloc}}{struct crypto\_aead *\emph{ tfm}, gfp\_t\emph{ gfp}}{}
allocate request data structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_aead * tfm}}] \leavevmode
cipher handle to be registered with the request

\item[{\code{gfp\_t gfp}}] \leavevmode
memory allocation flag that is handed to kmalloc by the API call.

\end{description}

\textbf{Description}

Allocate the request data structure that must be used with the AEAD
encrypt and decrypt API calls. During the allocation, the provided aead
handle is registered in the request data structure.

\textbf{Return}

allocated request handle in case of success, or NULL if out of memory
\index{aead\_request\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.aead_request_free}\pysiglinewithargsret{void \bfcode{aead\_request\_free}}{struct {\hyperref[crypto/api\string-aead:c.aead_request]{\emph{aead\_request}}} *\emph{ req}}{}
zeroize and free request data structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct aead\_request * req}}] \leavevmode
request data structure cipher handle to be freed

\end{description}
\index{aead\_request\_set\_callback (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.aead_request_set_callback}\pysiglinewithargsret{void \bfcode{aead\_request\_set\_callback}}{struct {\hyperref[crypto/api\string-aead:c.aead_request]{\emph{aead\_request}}} *\emph{ req}, u32\emph{ flags}, crypto\_completion\_t\emph{ compl}, void *\emph{ data}}{}
set asynchronous callback function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct aead\_request * req}}] \leavevmode
request handle

\item[{\code{u32 flags}}] \leavevmode
specify zero or an ORing of the flags
CRYPTO\_TFM\_REQ\_MAY\_BACKLOG the request queue may back log and
increase the wait queue beyond the initial maximum size;
CRYPTO\_TFM\_REQ\_MAY\_SLEEP the request processing may sleep

\item[{\code{crypto\_completion\_t compl}}] \leavevmode
callback function pointer to be registered with the request handle

\item[{\code{void * data}}] \leavevmode
The data pointer refers to memory that is not used by the kernel
crypto API, but provided to the callback function for it to use. Here,
the caller can provide a reference to memory the callback function can
operate on. As the callback function is invoked asynchronously to the
related functionality, it may need to access data structures of the
related functionality which can be referenced using this pointer. The
callback function can access the memory via the ``data'' field in the
crypto\_async\_request data structure provided to the callback function.

\end{description}

\textbf{Description}

Setting the callback function that is triggered once the cipher operation
completes

The callback function is registered with the aead\_request handle and
must comply with the following template:

\begin{Verbatim}[commandchars=\\\{\}]
void callback\PYGZus{}function(struct crypto\PYGZus{}async\PYGZus{}request *req, int error)
\end{Verbatim}
\index{aead\_request\_set\_crypt (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.aead_request_set_crypt}\pysiglinewithargsret{void \bfcode{aead\_request\_set\_crypt}}{struct {\hyperref[crypto/api\string-aead:c.aead_request]{\emph{aead\_request}}} *\emph{ req}, struct scatterlist *\emph{ src}, struct scatterlist *\emph{ dst}, unsigned int\emph{ cryptlen}, u8 *\emph{ iv}}{}
set data buffers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct aead\_request * req}}] \leavevmode
request handle

\item[{\code{struct scatterlist * src}}] \leavevmode
source scatter / gather list

\item[{\code{struct scatterlist * dst}}] \leavevmode
destination scatter / gather list

\item[{\code{unsigned int cryptlen}}] \leavevmode
number of bytes to process from \textbf{src}

\item[{\code{u8 * iv}}] \leavevmode
IV for the cipher operation which must comply with the IV size defined
by {\hyperref[crypto/api\string-aead:c.crypto_aead_ivsize]{\emph{\code{crypto\_aead\_ivsize()}}}}

\end{description}

\textbf{Description}

Setting the source data and destination data scatter / gather lists which
hold the associated data concatenated with the plaintext or ciphertext. See
below for the authentication tag.

For encryption, the source is treated as the plaintext and the
destination is the ciphertext. For a decryption operation, the use is
reversed - the source is the ciphertext and the destination is the plaintext.

The memory structure for cipher operation has the following structure:
\begin{itemize}
\item {} 
AEAD encryption input:  assoc data \textbar{}\textbar{} plaintext

\item {} 
AEAD encryption output: assoc data \textbar{}\textbar{} cipherntext \textbar{}\textbar{} auth tag

\item {} 
AEAD decryption input:  assoc data \textbar{}\textbar{} ciphertext \textbar{}\textbar{} auth tag

\item {} 
AEAD decryption output: assoc data \textbar{}\textbar{} plaintext

\end{itemize}

Albeit the kernel requires the presence of the AAD buffer, however,
the kernel does not fill the AAD buffer in the output case. If the
caller wants to have that data buffer filled, the caller must either
use an in-place cipher operation (i.e. same memory location for
input/output memory location).
\index{aead\_request\_set\_ad (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-aead:c.aead_request_set_ad}\pysiglinewithargsret{void \bfcode{aead\_request\_set\_ad}}{struct {\hyperref[crypto/api\string-aead:c.aead_request]{\emph{aead\_request}}} *\emph{ req}, unsigned int\emph{ assoclen}}{}
set associated data information

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct aead\_request * req}}] \leavevmode
request handle

\item[{\code{unsigned int assoclen}}] \leavevmode
number of bytes in associated data

\end{description}

\textbf{Description}

Setting the AD information.  This function sets the length of
the associated data.


\section{Message Digest Algorithm Definitions}
\label{crypto/api-digest:message-digest-algorithm-definitions}\label{crypto/api-digest::doc}
These data structures define modular message digest algorithm
implementations, managed via \code{crypto\_register\_ahash()},
\code{crypto\_register\_shash()}, \code{crypto\_unregister\_ahash()} and
\code{crypto\_unregister\_shash()}.
\index{hash\_alg\_common (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.hash_alg_common}\pysigline{struct \bfcode{hash\_alg\_common}}
define properties of message digest

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct hash\PYGZus{}alg\PYGZus{}common \PYGZob{}
  unsigned int digestsize;
  unsigned int statesize;
  struct crypto\PYGZus{}alg base;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{digestsize}}] \leavevmode
Size of the result of the transformation. A buffer of this size
must be available to the \textbf{final} and \textbf{finup} calls, so they can
store the resulting hash into it. For various predefined sizes,
search include/crypto/ using
git grep \_DIGEST\_SIZE include/crypto.

\item[{\code{statesize}}] \leavevmode
Size of the block for partial state of the transformation. A
buffer of this size must be passed to the \textbf{export} function as it
will save the partial state of the transformation into it. On the
other side, the \textbf{import} function will load the state from a
buffer of this size as well.

\item[{\code{base}}] \leavevmode
Start of data structure of cipher algorithm. The common data
structure of crypto\_alg contains information common to all ciphers.
The hash\_alg\_common data structure now adds the hash-specific
information.

\end{description}
\index{ahash\_alg (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.ahash_alg}\pysigline{struct \bfcode{ahash\_alg}}
asynchronous message digest definition

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ahash\PYGZus{}alg \PYGZob{}
  int (*init)(struct ahash\PYGZus{}request *req);
  int (*update)(struct ahash\PYGZus{}request *req);
  int (*final)(struct ahash\PYGZus{}request *req);
  int (*finup)(struct ahash\PYGZus{}request *req);
  int (*digest)(struct ahash\PYGZus{}request *req);
  int (*export)(struct ahash\PYGZus{}request *req, void *out);
  int (*import)(struct ahash\PYGZus{}request *req, const void *in);
  int (*setkey)(struct crypto\PYGZus{}ahash *tfm, const u8 *key, unsigned int keylen);
  struct hash\PYGZus{}alg\PYGZus{}common halg;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{init}}] \leavevmode
\textbf{{[}mandatory{]}} Initialize the transformation context. Intended only to initialize the
state of the HASH transformation at the beginning. This shall fill in
the internal structures used during the entire duration of the whole
transformation. No data processing happens at this point.

\item[{\code{update}}] \leavevmode
\textbf{{[}mandatory{]}} Push a chunk of data into the driver for transformation. This
function actually pushes blocks of data from upper layers into the
driver, which then passes those to the hardware as seen fit. This
function must not finalize the HASH transformation by calculating the
final message digest as this only adds more data into the
transformation. This function shall not modify the transformation
context, as this function may be called in parallel with the same
transformation object. Data processing can happen synchronously
{[}SHASH{]} or asynchronously {[}AHASH{]} at this point.

\item[{\code{final}}] \leavevmode
\textbf{{[}mandatory{]}} Retrieve result from the driver. This function finalizes the
transformation and retrieves the resulting hash from the driver and
pushes it back to upper layers. No data processing happens at this
point unless hardware requires it to finish the transformation
(then the data buffered by the device driver is processed).

\item[{\code{finup}}] \leavevmode
\textbf{{[}optional{]}} Combination of \textbf{update} and \textbf{final}. This function is effectively a
combination of \textbf{update} and \textbf{final} calls issued in sequence. As some
hardware cannot do \textbf{update} and \textbf{final} separately, this callback was
added to allow such hardware to be used at least by IPsec. Data
processing can happen synchronously {[}SHASH{]} or asynchronously {[}AHASH{]}
at this point.

\item[{\code{digest}}] \leavevmode
Combination of \textbf{init} and \textbf{update} and \textbf{final}. This function
effectively behaves as the entire chain of operations, \textbf{init},
\textbf{update} and \textbf{final} issued in sequence. Just like \textbf{finup}, this was
added for hardware which cannot do even the \textbf{finup}, but can only do
the whole transformation in one run. Data processing can happen
synchronously {[}SHASH{]} or asynchronously {[}AHASH{]} at this point.

\item[{\code{export}}] \leavevmode
Export partial state of the transformation. This function dumps the
entire state of the ongoing transformation into a provided block of
data so it can be \textbf{import} `ed back later on. This is useful in case
you want to save partial result of the transformation after
processing certain amount of data and reload this partial result
multiple times later on for multiple re-use. No data processing
happens at this point.

\item[{\code{import}}] \leavevmode
Import partial state of the transformation. This function loads the
entire state of the ongoing transformation from a provided block of
data so the transformation can continue from this point onward. No
data processing happens at this point.

\item[{\code{setkey}}] \leavevmode
Set optional key used by the hashing algorithm. Intended to push
optional key used by the hashing algorithm from upper layers into
the driver. This function can store the key in the transformation
context or can outright program it into the hardware. In the former
case, one must be careful to program the key into the hardware at
appropriate time and one must be careful that .:c:func:\emph{setkey()} can be
called multiple times during the existence of the transformation
object. Not  all hashing algorithms do implement this function as it
is only needed for keyed message digests. SHAx/MDx/CRCx do NOT
implement this function. HMAC(MDx)/HMAC(SHAx)/CMAC(AES) do implement
this function. This function must be called before any other of the
\textbf{init}, \textbf{update}, \textbf{final}, \textbf{finup}, \textbf{digest} is called. No data
processing happens at this point.

\item[{\code{halg}}] \leavevmode
see struct hash\_alg\_common

\end{description}
\index{shash\_alg (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.shash_alg}\pysigline{struct \bfcode{shash\_alg}}
synchronous message digest definition

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct shash\PYGZus{}alg \PYGZob{}
  int (*init)(struct shash\PYGZus{}desc *desc);
  int (*update)(struct shash\PYGZus{}desc *desc, const u8 *data, unsigned int len);
  int (*final)(struct shash\PYGZus{}desc *desc, u8 *out);
  int (*finup)(struct shash\PYGZus{}desc *desc, const u8 *data, unsigned int len, u8 *out);
  int (*digest)(struct shash\PYGZus{}desc *desc, const u8 *data, unsigned int len, u8 *out);
  int (*export)(struct shash\PYGZus{}desc *desc, void *out);
  int (*import)(struct shash\PYGZus{}desc *desc, const void *in);
  int (*setkey)(struct crypto\PYGZus{}shash *tfm, const u8 *key, unsigned int keylen);
  unsigned int descsize;
  unsigned int digestsize ;
  unsigned int statesize;
  struct crypto\PYGZus{}alg base;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{init}}] \leavevmode
see struct ahash\_alg

\item[{\code{update}}] \leavevmode
see struct ahash\_alg

\item[{\code{final}}] \leavevmode
see struct ahash\_alg

\item[{\code{finup}}] \leavevmode
see struct ahash\_alg

\item[{\code{digest}}] \leavevmode
see struct ahash\_alg

\item[{\code{export}}] \leavevmode
see struct ahash\_alg

\item[{\code{import}}] \leavevmode
see struct ahash\_alg

\item[{\code{setkey}}] \leavevmode
see struct ahash\_alg

\item[{\code{descsize}}] \leavevmode
Size of the operational state for the message digest. This state
size is the memory size that needs to be allocated for
shash\_desc.\_\_ctx

\item[{\code{digestsize}}] \leavevmode
see struct ahash\_alg

\item[{\code{statesize}}] \leavevmode
see struct ahash\_alg

\item[{\code{base}}] \leavevmode
internally used

\end{description}


\section{Asynchronous Message Digest API}
\label{crypto/api-digest:asynchronous-message-digest-api}
The asynchronous message digest API is used with the ciphers of type
CRYPTO\_ALG\_TYPE\_AHASH (listed as type ``ahash'' in /proc/crypto)

The asynchronous cipher operation discussion provided for the
CRYPTO\_ALG\_TYPE\_ABLKCIPHER API applies here as well.
\index{crypto\_alloc\_ahash (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_alloc_ahash}\pysiglinewithargsret{struct crypto\_ahash * \bfcode{crypto\_alloc\_ahash}}{const char *\emph{ alg\_name}, u32\emph{ type}, u32\emph{ mask}}{}
allocate ahash cipher handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * alg\_name}}] \leavevmode
is the cra\_name / name or cra\_driver\_name / driver name of the
ahash cipher

\item[{\code{u32 type}}] \leavevmode
specifies the type of the cipher

\item[{\code{u32 mask}}] \leavevmode
specifies the mask for the cipher

\end{description}

\textbf{Description}

Allocate a cipher handle for an ahash. The returned struct
crypto\_ahash is the cipher handle that is required for any subsequent
API invocation for that ahash.

\textbf{Return}
\begin{description}
\item[{allocated cipher handle in case of success; \code{IS\_ERR()} is true in case}] \leavevmode
of an error, \code{PTR\_ERR()} returns the error code.

\end{description}
\index{crypto\_free\_ahash (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_free_ahash}\pysiglinewithargsret{void \bfcode{crypto\_free\_ahash}}{struct crypto\_ahash *\emph{ tfm}}{}
zeroize and free the ahash handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_ahash * tfm}}] \leavevmode
cipher handle to be freed

\end{description}
\index{crypto\_ahash\_digestsize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_ahash_digestsize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_ahash\_digestsize}}{struct crypto\_ahash *\emph{ tfm}}{}
obtain message digest size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_ahash * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Description}

The size for the message digest created by the message digest cipher
referenced with the cipher handle is returned.

\textbf{Return}

message digest size of cipher
\index{crypto\_ahash\_statesize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_ahash_statesize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_ahash\_statesize}}{struct crypto\_ahash *\emph{ tfm}}{}
obtain size of the ahash state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_ahash * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Description}

Return the size of the ahash state. With the {\hyperref[crypto/api\string-digest:c.crypto_ahash_export]{\emph{\code{crypto\_ahash\_export()}}}}
function, the caller can export the state into a buffer whose size is
defined with this function.

\textbf{Return}

size of the ahash state
\index{crypto\_ahash\_reqtfm (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_ahash_reqtfm}\pysiglinewithargsret{struct crypto\_ahash * \bfcode{crypto\_ahash\_reqtfm}}{struct ahash\_request *\emph{ req}}{}
obtain cipher handle from request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ahash\_request * req}}] \leavevmode
asynchronous request handle that contains the reference to the ahash
cipher handle

\end{description}

\textbf{Description}

Return the ahash cipher handle that is registered with the asynchronous
request handle ahash\_request.

\textbf{Return}

ahash cipher handle
\index{crypto\_ahash\_reqsize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_ahash_reqsize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_ahash\_reqsize}}{struct crypto\_ahash *\emph{ tfm}}{}
obtain size of the request data structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_ahash * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Return}

size of the request data
\index{crypto\_ahash\_setkey (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_ahash_setkey}\pysiglinewithargsret{int \bfcode{crypto\_ahash\_setkey}}{struct crypto\_ahash *\emph{ tfm}, const u8 *\emph{ key}, unsigned int\emph{ keylen}}{}
set key for cipher handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_ahash * tfm}}] \leavevmode
cipher handle

\item[{\code{const u8 * key}}] \leavevmode
buffer holding the key

\item[{\code{unsigned int keylen}}] \leavevmode
length of the key in bytes

\end{description}

\textbf{Description}

The caller provided key is set for the ahash cipher. The cipher
handle must point to a keyed hash in order for this function to succeed.

\textbf{Return}

0 if the setting of the key was successful; \textless{} 0 if an error occurred
\index{crypto\_ahash\_finup (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_ahash_finup}\pysiglinewithargsret{int \bfcode{crypto\_ahash\_finup}}{struct ahash\_request *\emph{ req}}{}
update and finalize message digest

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ahash\_request * req}}] \leavevmode
reference to the ahash\_request handle that holds all information
needed to perform the cipher operation

\end{description}

\textbf{Description}

This function is a ``short-hand'' for the function calls of
crypto\_ahash\_update and crypto\_ahash\_final. The parameters have the same
meaning as discussed for those separate functions.

\textbf{Return}

see {\hyperref[crypto/api\string-digest:c.crypto_ahash_final]{\emph{\code{crypto\_ahash\_final()}}}}
\index{crypto\_ahash\_final (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_ahash_final}\pysiglinewithargsret{int \bfcode{crypto\_ahash\_final}}{struct ahash\_request *\emph{ req}}{}
calculate message digest

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ahash\_request * req}}] \leavevmode
reference to the ahash\_request handle that holds all information
needed to perform the cipher operation

\end{description}

\textbf{Description}

Finalize the message digest operation and create the message digest
based on all data added to the cipher handle. The message digest is placed
into the output buffer registered with the ahash\_request handle.

\textbf{Return}

0            if the message digest was successfully calculated;
-EINPROGRESS if data is feeded into hardware (DMA) or queued for later;
-EBUSY       if queue is full and request should be resubmitted later;
other \textless{} 0    if an error occurred
\index{crypto\_ahash\_digest (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_ahash_digest}\pysiglinewithargsret{int \bfcode{crypto\_ahash\_digest}}{struct ahash\_request *\emph{ req}}{}
calculate message digest for a buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ahash\_request * req}}] \leavevmode
reference to the ahash\_request handle that holds all information
needed to perform the cipher operation

\end{description}

\textbf{Description}

This function is a ``short-hand'' for the function calls of crypto\_ahash\_init,
crypto\_ahash\_update and crypto\_ahash\_final. The parameters have the same
meaning as discussed for those separate three functions.

\textbf{Return}

see {\hyperref[crypto/api\string-digest:c.crypto_ahash_final]{\emph{\code{crypto\_ahash\_final()}}}}
\index{crypto\_ahash\_export (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_ahash_export}\pysiglinewithargsret{int \bfcode{crypto\_ahash\_export}}{struct ahash\_request *\emph{ req}, void *\emph{ out}}{}
extract current message digest state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ahash\_request * req}}] \leavevmode
reference to the ahash\_request handle whose state is exported

\item[{\code{void * out}}] \leavevmode
output buffer of sufficient size that can hold the hash state

\end{description}

\textbf{Description}

This function exports the hash state of the ahash\_request handle into the
caller-allocated output buffer out which must have sufficient size (e.g. by
calling {\hyperref[crypto/api\string-digest:c.crypto_ahash_statesize]{\emph{\code{crypto\_ahash\_statesize()}}}}).

\textbf{Return}

0 if the export was successful; \textless{} 0 if an error occurred
\index{crypto\_ahash\_import (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_ahash_import}\pysiglinewithargsret{int \bfcode{crypto\_ahash\_import}}{struct ahash\_request *\emph{ req}, const void *\emph{ in}}{}
import message digest state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ahash\_request * req}}] \leavevmode
reference to ahash\_request handle the state is imported into

\item[{\code{const void * in}}] \leavevmode
buffer holding the state

\end{description}

\textbf{Description}

This function imports the hash state into the ahash\_request handle from the
input buffer. That buffer should have been generated with the
crypto\_ahash\_export function.

\textbf{Return}

0 if the import was successful; \textless{} 0 if an error occurred
\index{crypto\_ahash\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_ahash_init}\pysiglinewithargsret{int \bfcode{crypto\_ahash\_init}}{struct ahash\_request *\emph{ req}}{}
(re)initialize message digest handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ahash\_request * req}}] \leavevmode
ahash\_request handle that already is initialized with all necessary
data using the ahash\_request\_* API functions

\end{description}

\textbf{Description}

The call (re-)initializes the message digest referenced by the ahash\_request
handle. Any potentially existing state created by previous operations is
discarded.

\textbf{Return}

see {\hyperref[crypto/api\string-digest:c.crypto_ahash_final]{\emph{\code{crypto\_ahash\_final()}}}}


\section{Asynchronous Hash Request Handle}
\label{crypto/api-digest:asynchronous-hash-request-handle}
The \code{ahash\_request} data structure contains all pointers to data
required for the asynchronous cipher operation. This includes the cipher
handle (which can be used by multiple \code{ahash\_request} instances), pointer
to plaintext and the message digest output buffer, asynchronous callback
function, etc. It acts as a handle to the ahash\_request\_* API calls in a
similar way as ahash handle to the crypto\_ahash\_* API calls.
\index{ahash\_request\_set\_tfm (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.ahash_request_set_tfm}\pysiglinewithargsret{void \bfcode{ahash\_request\_set\_tfm}}{struct ahash\_request *\emph{ req}, struct crypto\_ahash *\emph{ tfm}}{}
update cipher handle reference in request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ahash\_request * req}}] \leavevmode
request handle to be modified

\item[{\code{struct crypto\_ahash * tfm}}] \leavevmode
cipher handle that shall be added to the request handle

\end{description}

\textbf{Description}

Allow the caller to replace the existing ahash handle in the request
data structure with a different one.
\index{ahash\_request\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.ahash_request_alloc}\pysiglinewithargsret{struct ahash\_request * \bfcode{ahash\_request\_alloc}}{struct crypto\_ahash *\emph{ tfm}, gfp\_t\emph{ gfp}}{}
allocate request data structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_ahash * tfm}}] \leavevmode
cipher handle to be registered with the request

\item[{\code{gfp\_t gfp}}] \leavevmode
memory allocation flag that is handed to kmalloc by the API call.

\end{description}

\textbf{Description}

Allocate the request data structure that must be used with the ahash
message digest API calls. During
the allocation, the provided ahash handle
is registered in the request data structure.

\textbf{Return}

allocated request handle in case of success, or NULL if out of memory
\index{ahash\_request\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.ahash_request_free}\pysiglinewithargsret{void \bfcode{ahash\_request\_free}}{struct ahash\_request *\emph{ req}}{}
zeroize and free the request data structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ahash\_request * req}}] \leavevmode
request data structure cipher handle to be freed

\end{description}
\index{ahash\_request\_set\_callback (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.ahash_request_set_callback}\pysiglinewithargsret{void \bfcode{ahash\_request\_set\_callback}}{struct ahash\_request *\emph{ req}, u32\emph{ flags}, crypto\_completion\_t\emph{ compl}, void *\emph{ data}}{}
set asynchronous callback function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ahash\_request * req}}] \leavevmode
request handle

\item[{\code{u32 flags}}] \leavevmode
specify zero or an ORing of the flags
CRYPTO\_TFM\_REQ\_MAY\_BACKLOG the request queue may back log and
increase the wait queue beyond the initial maximum size;
CRYPTO\_TFM\_REQ\_MAY\_SLEEP the request processing may sleep

\item[{\code{crypto\_completion\_t compl}}] \leavevmode
callback function pointer to be registered with the request handle

\item[{\code{void * data}}] \leavevmode
The data pointer refers to memory that is not used by the kernel
crypto API, but provided to the callback function for it to use. Here,
the caller can provide a reference to memory the callback function can
operate on. As the callback function is invoked asynchronously to the
related functionality, it may need to access data structures of the
related functionality which can be referenced using this pointer. The
callback function can access the memory via the ``data'' field in the
\code{crypto\_async\_request} data structure provided to the callback function.

\end{description}

\textbf{Description}

This function allows setting the callback function that is triggered once
the cipher operation completes.

The callback function is registered with the \code{ahash\_request} handle and
must comply with the following template:

\begin{Verbatim}[commandchars=\\\{\}]
void callback\PYGZus{}function(struct crypto\PYGZus{}async\PYGZus{}request *req, int error)
\end{Verbatim}
\index{ahash\_request\_set\_crypt (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.ahash_request_set_crypt}\pysiglinewithargsret{void \bfcode{ahash\_request\_set\_crypt}}{struct ahash\_request *\emph{ req}, struct scatterlist *\emph{ src}, u8 *\emph{ result}, unsigned int\emph{ nbytes}}{}
set data buffers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ahash\_request * req}}] \leavevmode
ahash\_request handle to be updated

\item[{\code{struct scatterlist * src}}] \leavevmode
source scatter/gather list

\item[{\code{u8 * result}}] \leavevmode
buffer that is filled with the message digest -- the caller must
ensure that the buffer has sufficient space by, for example, calling
{\hyperref[crypto/api\string-digest:c.crypto_ahash_digestsize]{\emph{\code{crypto\_ahash\_digestsize()}}}}

\item[{\code{unsigned int nbytes}}] \leavevmode
number of bytes to process from the source scatter/gather list

\end{description}

\textbf{Description}

By using this call, the caller references the source scatter/gather list.
The source scatter/gather list points to the data the message digest is to
be calculated for.


\section{Synchronous Message Digest API}
\label{crypto/api-digest:synchronous-message-digest-api}
The synchronous message digest API is used with the ciphers of type
CRYPTO\_ALG\_TYPE\_SHASH (listed as type ``shash'' in /proc/crypto)

The message digest API is able to maintain state information for the
caller.

The synchronous message digest API can store user-related context in in its
shash\_desc request data structure.
\index{crypto\_alloc\_shash (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_alloc_shash}\pysiglinewithargsret{struct crypto\_shash * \bfcode{crypto\_alloc\_shash}}{const char *\emph{ alg\_name}, u32\emph{ type}, u32\emph{ mask}}{}
allocate message digest handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * alg\_name}}] \leavevmode
is the cra\_name / name or cra\_driver\_name / driver name of the
message digest cipher

\item[{\code{u32 type}}] \leavevmode
specifies the type of the cipher

\item[{\code{u32 mask}}] \leavevmode
specifies the mask for the cipher

\end{description}

\textbf{Description}

Allocate a cipher handle for a message digest. The returned \code{struct
crypto\_shash} is the cipher handle that is required for any subsequent
API invocation for that message digest.

\textbf{Return}
\begin{description}
\item[{allocated cipher handle in case of success; \code{IS\_ERR()} is true in case}] \leavevmode
of an error, \code{PTR\_ERR()} returns the error code.

\end{description}
\index{crypto\_free\_shash (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_free_shash}\pysiglinewithargsret{void \bfcode{crypto\_free\_shash}}{struct crypto\_shash *\emph{ tfm}}{}
zeroize and free the message digest handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_shash * tfm}}] \leavevmode
cipher handle to be freed

\end{description}
\index{crypto\_shash\_blocksize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_shash_blocksize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_shash\_blocksize}}{struct crypto\_shash *\emph{ tfm}}{}
obtain block size for cipher

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_shash * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Description}

The block size for the message digest cipher referenced with the cipher
handle is returned.

\textbf{Return}

block size of cipher
\index{crypto\_shash\_digestsize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_shash_digestsize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_shash\_digestsize}}{struct crypto\_shash *\emph{ tfm}}{}
obtain message digest size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_shash * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Description}

The size for the message digest created by the message digest cipher
referenced with the cipher handle is returned.

\textbf{Return}

digest size of cipher
\index{crypto\_shash\_descsize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_shash_descsize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_shash\_descsize}}{struct crypto\_shash *\emph{ tfm}}{}
obtain the operational state size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_shash * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Description}

The size of the operational state the cipher needs during operation is
returned for the hash referenced with the cipher handle. This size is
required to calculate the memory requirements to allow the caller allocating
sufficient memory for operational state.

The operational state is defined with struct shash\_desc where the size of
that data structure is to be calculated as
sizeof(struct shash\_desc) + crypto\_shash\_descsize(alg)

\textbf{Return}

size of the operational state
\index{crypto\_shash\_setkey (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_shash_setkey}\pysiglinewithargsret{int \bfcode{crypto\_shash\_setkey}}{struct crypto\_shash *\emph{ tfm}, const u8 *\emph{ key}, unsigned int\emph{ keylen}}{}
set key for message digest

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_shash * tfm}}] \leavevmode
cipher handle

\item[{\code{const u8 * key}}] \leavevmode
buffer holding the key

\item[{\code{unsigned int keylen}}] \leavevmode
length of the key in bytes

\end{description}

\textbf{Description}

The caller provided key is set for the keyed message digest cipher. The
cipher handle must point to a keyed message digest cipher in order for this
function to succeed.

\textbf{Return}

0 if the setting of the key was successful; \textless{} 0 if an error occurred
\index{crypto\_shash\_digest (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_shash_digest}\pysiglinewithargsret{int \bfcode{crypto\_shash\_digest}}{struct shash\_desc *\emph{ desc}, const u8 *\emph{ data}, unsigned int\emph{ len}, u8 *\emph{ out}}{}
calculate message digest for buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct shash\_desc * desc}}] \leavevmode
see {\hyperref[crypto/api\string-digest:c.crypto_shash_final]{\emph{\code{crypto\_shash\_final()}}}}

\item[{\code{const u8 * data}}] \leavevmode
see {\hyperref[crypto/api\string-digest:c.crypto_shash_update]{\emph{\code{crypto\_shash\_update()}}}}

\item[{\code{unsigned int len}}] \leavevmode
see {\hyperref[crypto/api\string-digest:c.crypto_shash_update]{\emph{\code{crypto\_shash\_update()}}}}

\item[{\code{u8 * out}}] \leavevmode
see {\hyperref[crypto/api\string-digest:c.crypto_shash_final]{\emph{\code{crypto\_shash\_final()}}}}

\end{description}

\textbf{Description}

This function is a ``short-hand'' for the function calls of crypto\_shash\_init,
crypto\_shash\_update and crypto\_shash\_final. The parameters have the same
meaning as discussed for those separate three functions.

\textbf{Return}
\begin{description}
\item[{0 if the message digest creation was successful; \textless{} 0 if an error}] \leavevmode
occurred

\end{description}
\index{crypto\_shash\_export (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_shash_export}\pysiglinewithargsret{int \bfcode{crypto\_shash\_export}}{struct shash\_desc *\emph{ desc}, void *\emph{ out}}{}
extract operational state for message digest

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct shash\_desc * desc}}] \leavevmode
reference to the operational state handle whose state is exported

\item[{\code{void * out}}] \leavevmode
output buffer of sufficient size that can hold the hash state

\end{description}

\textbf{Description}

This function exports the hash state of the operational state handle into the
caller-allocated output buffer out which must have sufficient size (e.g. by
calling crypto\_shash\_descsize).

\textbf{Return}

0 if the export creation was successful; \textless{} 0 if an error occurred
\index{crypto\_shash\_import (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_shash_import}\pysiglinewithargsret{int \bfcode{crypto\_shash\_import}}{struct shash\_desc *\emph{ desc}, const void *\emph{ in}}{}
import operational state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct shash\_desc * desc}}] \leavevmode
reference to the operational state handle the state imported into

\item[{\code{const void * in}}] \leavevmode
buffer holding the state

\end{description}

\textbf{Description}

This function imports the hash state into the operational state handle from
the input buffer. That buffer should have been generated with the
crypto\_ahash\_export function.

\textbf{Return}

0 if the import was successful; \textless{} 0 if an error occurred
\index{crypto\_shash\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_shash_init}\pysiglinewithargsret{int \bfcode{crypto\_shash\_init}}{struct shash\_desc *\emph{ desc}}{}
(re)initialize message digest

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct shash\_desc * desc}}] \leavevmode
operational state handle that is already filled

\end{description}

\textbf{Description}

The call (re-)initializes the message digest referenced by the
operational state handle. Any potentially existing state created by
previous operations is discarded.

\textbf{Return}
\begin{description}
\item[{0 if the message digest initialization was successful; \textless{} 0 if an}] \leavevmode
error occurred

\end{description}
\index{crypto\_shash\_update (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_shash_update}\pysiglinewithargsret{int \bfcode{crypto\_shash\_update}}{struct shash\_desc *\emph{ desc}, const u8 *\emph{ data}, unsigned int\emph{ len}}{}
add data to message digest for processing

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct shash\_desc * desc}}] \leavevmode
operational state handle that is already initialized

\item[{\code{const u8 * data}}] \leavevmode
input data to be added to the message digest

\item[{\code{unsigned int len}}] \leavevmode
length of the input data

\end{description}

\textbf{Description}

Updates the message digest state of the operational state handle.

\textbf{Return}
\begin{description}
\item[{0 if the message digest update was successful; \textless{} 0 if an error}] \leavevmode
occurred

\end{description}
\index{crypto\_shash\_final (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_shash_final}\pysiglinewithargsret{int \bfcode{crypto\_shash\_final}}{struct shash\_desc *\emph{ desc}, u8 *\emph{ out}}{}
calculate message digest

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct shash\_desc * desc}}] \leavevmode
operational state handle that is already filled with data

\item[{\code{u8 * out}}] \leavevmode
output buffer filled with the message digest

\end{description}

\textbf{Description}

Finalize the message digest operation and create the message digest
based on all data added to the cipher handle. The message digest is placed
into the output buffer. The caller must ensure that the output buffer is
large enough by using crypto\_shash\_digestsize.

\textbf{Return}
\begin{description}
\item[{0 if the message digest creation was successful; \textless{} 0 if an error}] \leavevmode
occurred

\end{description}
\index{crypto\_shash\_finup (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-digest:c.crypto_shash_finup}\pysiglinewithargsret{int \bfcode{crypto\_shash\_finup}}{struct shash\_desc *\emph{ desc}, const u8 *\emph{ data}, unsigned int\emph{ len}, u8 *\emph{ out}}{}
calculate message digest of buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct shash\_desc * desc}}] \leavevmode
see {\hyperref[crypto/api\string-digest:c.crypto_shash_final]{\emph{\code{crypto\_shash\_final()}}}}

\item[{\code{const u8 * data}}] \leavevmode
see {\hyperref[crypto/api\string-digest:c.crypto_shash_update]{\emph{\code{crypto\_shash\_update()}}}}

\item[{\code{unsigned int len}}] \leavevmode
see {\hyperref[crypto/api\string-digest:c.crypto_shash_update]{\emph{\code{crypto\_shash\_update()}}}}

\item[{\code{u8 * out}}] \leavevmode
see {\hyperref[crypto/api\string-digest:c.crypto_shash_final]{\emph{\code{crypto\_shash\_final()}}}}

\end{description}

\textbf{Description}

This function is a ``short-hand'' for the function calls of
crypto\_shash\_update and crypto\_shash\_final. The parameters have the same
meaning as discussed for those separate functions.

\textbf{Return}
\begin{description}
\item[{0 if the message digest creation was successful; \textless{} 0 if an error}] \leavevmode
occurred

\end{description}


\section{Random Number Algorithm Definitions}
\label{crypto/api-rng::doc}\label{crypto/api-rng:random-number-algorithm-definitions}\index{rng\_alg (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-rng:c.rng_alg}\pysigline{struct \bfcode{rng\_alg}}
random number generator definition

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct rng\PYGZus{}alg \PYGZob{}
  int (*generate)(struct crypto\PYGZus{}rng *tfm,const u8 *src, unsigned int slen, u8 *dst, unsigned int dlen);
  int (*seed)(struct crypto\PYGZus{}rng *tfm, const u8 *seed, unsigned int slen);
  void (*set\PYGZus{}ent)(struct crypto\PYGZus{}rng *tfm, const u8 *data, unsigned int len);
  unsigned int seedsize;
  struct crypto\PYGZus{}alg base;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{generate}}] \leavevmode
The function defined by this variable obtains a
random number. The random number generator transform
must generate the random number out of the context
provided with this call, plus any additional data
if provided to the call.

\item[{\code{seed}}] \leavevmode
Seed or reseed the random number generator.  With the
invocation of this function call, the random number
generator shall become ready for generation.  If the
random number generator requires a seed for setting
up a new state, the seed must be provided by the
consumer while invoking this function. The required
size of the seed is defined with \textbf{seedsize} .

\item[{\code{set\_ent}}] \leavevmode
Set entropy that would otherwise be obtained from
entropy source.  Internal use only.

\item[{\code{seedsize}}] \leavevmode
The seed size required for a random number generator
initialization defined with this variable. Some
random number generators does not require a seed
as the seeding is implemented internally without
the need of support by the consumer. In this case,
the seed size is set to zero.

\item[{\code{base}}] \leavevmode
Common crypto API algorithm data structure.

\end{description}


\section{Crypto API Random Number API}
\label{crypto/api-rng:crypto-api-random-number-api}
The random number generator API is used with the ciphers of type
CRYPTO\_ALG\_TYPE\_RNG (listed as type ``rng'' in /proc/crypto)
\index{crypto\_alloc\_rng (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-rng:c.crypto_alloc_rng}\pysiglinewithargsret{struct crypto\_rng * \bfcode{crypto\_alloc\_rng}}{const char *\emph{ alg\_name}, u32\emph{ type}, u32\emph{ mask}}{}~\begin{itemize}
\item {} 
allocate RNG handle

\end{itemize}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * alg\_name}}] \leavevmode
is the cra\_name / name or cra\_driver\_name / driver name of the
message digest cipher

\item[{\code{u32 type}}] \leavevmode
specifies the type of the cipher

\item[{\code{u32 mask}}] \leavevmode
specifies the mask for the cipher

\end{description}

\textbf{Description}

Allocate a cipher handle for a random number generator. The returned struct
crypto\_rng is the cipher handle that is required for any subsequent
API invocation for that random number generator.

For all random number generators, this call creates a new private copy of
the random number generator that does not share a state with other
instances. The only exception is the ``krng'' random number generator which
is a kernel crypto API use case for the \code{get\_random\_bytes()} function of the
/dev/random driver.

\textbf{Return}
\begin{description}
\item[{allocated cipher handle in case of success; \code{IS\_ERR()} is true in case}] \leavevmode
of an error, \code{PTR\_ERR()} returns the error code.

\end{description}
\index{crypto\_rng\_alg (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-rng:c.crypto_rng_alg}\pysiglinewithargsret{struct {\hyperref[crypto/api\string-rng:c.rng_alg]{\emph{rng\_alg}}} * \bfcode{crypto\_rng\_alg}}{struct crypto\_rng *\emph{ tfm}}{}
obtain name of RNG

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_rng * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Description}

Return the generic name (cra\_name) of the initialized random number generator

\textbf{Return}

generic name string
\index{crypto\_free\_rng (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-rng:c.crypto_free_rng}\pysiglinewithargsret{void \bfcode{crypto\_free\_rng}}{struct crypto\_rng *\emph{ tfm}}{}
zeroize and free RNG handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_rng * tfm}}] \leavevmode
cipher handle to be freed

\end{description}
\index{crypto\_rng\_generate (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-rng:c.crypto_rng_generate}\pysiglinewithargsret{int \bfcode{crypto\_rng\_generate}}{struct crypto\_rng *\emph{ tfm}, const u8 *\emph{ src}, unsigned int\emph{ slen}, u8 *\emph{ dst}, unsigned int\emph{ dlen}}{}
get random number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_rng * tfm}}] \leavevmode
cipher handle

\item[{\code{const u8 * src}}] \leavevmode
Input buffer holding additional data, may be NULL

\item[{\code{unsigned int slen}}] \leavevmode
Length of additional data

\item[{\code{u8 * dst}}] \leavevmode
output buffer holding the random numbers

\item[{\code{unsigned int dlen}}] \leavevmode
length of the output buffer

\end{description}

\textbf{Description}

This function fills the caller-allocated buffer with random
numbers using the random number generator referenced by the
cipher handle.

\textbf{Return}

0 function was successful; \textless{} 0 if an error occurred
\index{crypto\_rng\_get\_bytes (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-rng:c.crypto_rng_get_bytes}\pysiglinewithargsret{int \bfcode{crypto\_rng\_get\_bytes}}{struct crypto\_rng *\emph{ tfm}, u8 *\emph{ rdata}, unsigned int\emph{ dlen}}{}
get random number

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_rng * tfm}}] \leavevmode
cipher handle

\item[{\code{u8 * rdata}}] \leavevmode
output buffer holding the random numbers

\item[{\code{unsigned int dlen}}] \leavevmode
length of the output buffer

\end{description}

\textbf{Description}

This function fills the caller-allocated buffer with random numbers using the
random number generator referenced by the cipher handle.

\textbf{Return}

0 function was successful; \textless{} 0 if an error occurred
\index{crypto\_rng\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-rng:c.crypto_rng_reset}\pysiglinewithargsret{int \bfcode{crypto\_rng\_reset}}{struct crypto\_rng *\emph{ tfm}, const u8 *\emph{ seed}, unsigned int\emph{ slen}}{}
re-initialize the RNG

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_rng * tfm}}] \leavevmode
cipher handle

\item[{\code{const u8 * seed}}] \leavevmode
seed input data

\item[{\code{unsigned int slen}}] \leavevmode
length of the seed input data

\end{description}

\textbf{Description}

The reset function completely re-initializes the random number generator
referenced by the cipher handle by clearing the current state. The new state
is initialized with the caller provided seed or automatically, depending
on the random number generator type (the ANSI X9.31 RNG requires
caller-provided seed, the SP800-90A DRBGs perform an automatic seeding).
The seed is provided as a parameter to this function call. The provided seed
should have the length of the seed size defined for the random number
generator as defined by crypto\_rng\_seedsize.

\textbf{Return}

0 if the setting of the key was successful; \textless{} 0 if an error occurred
\index{crypto\_rng\_seedsize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-rng:c.crypto_rng_seedsize}\pysiglinewithargsret{int \bfcode{crypto\_rng\_seedsize}}{struct crypto\_rng *\emph{ tfm}}{}
obtain seed size of RNG

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_rng * tfm}}] \leavevmode
cipher handle

\end{description}

\textbf{Description}

The function returns the seed size for the random number generator
referenced by the cipher handle. This value may be zero if the random
number generator does not implement or require a reseeding. For example,
the SP800-90A DRBGs implement an automated reseeding after reaching a
pre-defined threshold.

\textbf{Return}

seed size for the random number generator


\section{Asymmetric Cipher Algorithm Definitions}
\label{crypto/api-akcipher:asymmetric-cipher-algorithm-definitions}\label{crypto/api-akcipher::doc}\index{akcipher\_request (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-akcipher:c.akcipher_request}\pysigline{struct \bfcode{akcipher\_request}}
public key request

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct akcipher\PYGZus{}request \PYGZob{}
  struct crypto\PYGZus{}async\PYGZus{}request base;
  struct scatterlist *src;
  struct scatterlist *dst;
  unsigned int src\PYGZus{}len;
  unsigned int dst\PYGZus{}len;
  void *\PYGZus{}\PYGZus{}ctx[];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{base}}] \leavevmode
Common attributes for async crypto requests

\item[{\code{src}}] \leavevmode
Source data

\item[{\code{dst}}] \leavevmode
Destination data

\item[{\code{src\_len}}] \leavevmode
Size of the input buffer

\item[{\code{dst\_len}}] \leavevmode
Size of the output buffer. It needs to be at least
as big as the expected result depending on the operation
After operation it will be updated with the actual size of the
result.
In case of error where the dst sgl size was insufficient,
it will be updated to the size required for the operation.

\item[{\code{\_\_ctx}}] \leavevmode
Start of private context data

\end{description}
\index{akcipher\_alg (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-akcipher:c.akcipher_alg}\pysigline{struct \bfcode{akcipher\_alg}}
generic public key algorithm

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct akcipher\PYGZus{}alg \PYGZob{}
  int (*sign)(struct akcipher\PYGZus{}request *req);
  int (*verify)(struct akcipher\PYGZus{}request *req);
  int (*encrypt)(struct akcipher\PYGZus{}request *req);
  int (*decrypt)(struct akcipher\PYGZus{}request *req);
  int (*set\PYGZus{}pub\PYGZus{}key)(struct crypto\PYGZus{}akcipher *tfm, const void *key, unsigned int keylen);
  int (*set\PYGZus{}priv\PYGZus{}key)(struct crypto\PYGZus{}akcipher *tfm, const void *key, unsigned int keylen);
  unsigned int (*max\PYGZus{}size)(struct crypto\PYGZus{}akcipher *tfm);
  int (*init)(struct crypto\PYGZus{}akcipher *tfm);
  void (*exit)(struct crypto\PYGZus{}akcipher *tfm);
  unsigned int reqsize;
  struct crypto\PYGZus{}alg base;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{sign}}] \leavevmode
Function performs a sign operation as defined by public key
algorithm. In case of error, where the dst\_len was insufficient,
the req-\textgreater{}dst\_len will be updated to the size required for the
operation

\item[{\code{verify}}] \leavevmode
Function performs a sign operation as defined by public key
algorithm. In case of error, where the dst\_len was insufficient,
the req-\textgreater{}dst\_len will be updated to the size required for the
operation

\item[{\code{encrypt}}] \leavevmode
Function performs an encrypt operation as defined by public key
algorithm. In case of error, where the dst\_len was insufficient,
the req-\textgreater{}dst\_len will be updated to the size required for the
operation

\item[{\code{decrypt}}] \leavevmode
Function performs a decrypt operation as defined by public key
algorithm. In case of error, where the dst\_len was insufficient,
the req-\textgreater{}dst\_len will be updated to the size required for the
operation

\item[{\code{set\_pub\_key}}] \leavevmode
Function invokes the algorithm specific set public key
function, which knows how to decode and interpret
the BER encoded public key

\item[{\code{set\_priv\_key}}] \leavevmode
Function invokes the algorithm specific set private key
function, which knows how to decode and interpret
the BER encoded private key

\item[{\code{max\_size}}] \leavevmode
Function returns dest buffer size required for a given key.

\item[{\code{init}}] \leavevmode
Initialize the cryptographic transformation object.
This function is used to initialize the cryptographic
transformation object. This function is called only once at
the instantiation time, right after the transformation context
was allocated. In case the cryptographic hardware has some
special requirements which need to be handled by software, this
function shall check for the precise requirement of the
transformation and put any software fallbacks in place.

\item[{\code{exit}}] \leavevmode
Deinitialize the cryptographic transformation object. This is a
counterpart to \textbf{init}, used to remove various changes set in
\textbf{init}.

\item[{\code{reqsize}}] \leavevmode
Request context size required by algorithm implementation

\item[{\code{base}}] \leavevmode
Common crypto API algorithm data structure

\end{description}


\section{Asymmetric Cipher API}
\label{crypto/api-akcipher:asymmetric-cipher-api}
The Public Key API is used with the algorithms of type
CRYPTO\_ALG\_TYPE\_AKCIPHER (listed as type ``akcipher'' in /proc/crypto)
\index{crypto\_alloc\_akcipher (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-akcipher:c.crypto_alloc_akcipher}\pysiglinewithargsret{struct crypto\_akcipher * \bfcode{crypto\_alloc\_akcipher}}{const char *\emph{ alg\_name}, u32\emph{ type}, u32\emph{ mask}}{}
allocate AKCIPHER tfm handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * alg\_name}}] \leavevmode
is the cra\_name / name or cra\_driver\_name / driver name of the
public key algorithm e.g. ``rsa''

\item[{\code{u32 type}}] \leavevmode
specifies the type of the algorithm

\item[{\code{u32 mask}}] \leavevmode
specifies the mask for the algorithm

\end{description}

\textbf{Description}

Allocate a handle for public key algorithm. The returned struct
crypto\_akcipher is the handle that is required for any subsequent
API invocation for the public key operations.

\textbf{Return}
\begin{description}
\item[{allocated handle in case of success; \code{IS\_ERR()} is true in case}] \leavevmode
of an error, \code{PTR\_ERR()} returns the error code.

\end{description}
\index{crypto\_free\_akcipher (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-akcipher:c.crypto_free_akcipher}\pysiglinewithargsret{void \bfcode{crypto\_free\_akcipher}}{struct crypto\_akcipher *\emph{ tfm}}{}
free AKCIPHER tfm handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_akcipher * tfm}}] \leavevmode
AKCIPHER tfm handle allocated with {\hyperref[crypto/api\string-akcipher:c.crypto_alloc_akcipher]{\emph{\code{crypto\_alloc\_akcipher()}}}}

\end{description}
\index{crypto\_akcipher\_maxsize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-akcipher:c.crypto_akcipher_maxsize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_akcipher\_maxsize}}{struct crypto\_akcipher *\emph{ tfm}}{}
Get len for output buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_akcipher * tfm}}] \leavevmode
AKCIPHER tfm handle allocated with {\hyperref[crypto/api\string-akcipher:c.crypto_alloc_akcipher]{\emph{\code{crypto\_alloc\_akcipher()}}}}

\end{description}

\textbf{Description}

Function returns the dest buffer size required for a given key.
Function assumes that the key is already set in the transformation. If this
function is called without a setkey or with a failed setkey, you will end up
in a NULL dereference.
\index{crypto\_akcipher\_encrypt (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-akcipher:c.crypto_akcipher_encrypt}\pysiglinewithargsret{int \bfcode{crypto\_akcipher\_encrypt}}{struct {\hyperref[crypto/api\string-akcipher:c.akcipher_request]{\emph{akcipher\_request}}} *\emph{ req}}{}
Invoke public key encrypt operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct akcipher\_request * req}}] \leavevmode
asymmetric key request

\end{description}

\textbf{Description}

Function invokes the specific public key encrypt operation for a given
public key algorithm

\textbf{Return}

zero on success; error code in case of error
\index{crypto\_akcipher\_decrypt (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-akcipher:c.crypto_akcipher_decrypt}\pysiglinewithargsret{int \bfcode{crypto\_akcipher\_decrypt}}{struct {\hyperref[crypto/api\string-akcipher:c.akcipher_request]{\emph{akcipher\_request}}} *\emph{ req}}{}
Invoke public key decrypt operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct akcipher\_request * req}}] \leavevmode
asymmetric key request

\end{description}

\textbf{Description}

Function invokes the specific public key decrypt operation for a given
public key algorithm

\textbf{Return}

zero on success; error code in case of error
\index{crypto\_akcipher\_sign (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-akcipher:c.crypto_akcipher_sign}\pysiglinewithargsret{int \bfcode{crypto\_akcipher\_sign}}{struct {\hyperref[crypto/api\string-akcipher:c.akcipher_request]{\emph{akcipher\_request}}} *\emph{ req}}{}
Invoke public key sign operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct akcipher\_request * req}}] \leavevmode
asymmetric key request

\end{description}

\textbf{Description}

Function invokes the specific public key sign operation for a given
public key algorithm

\textbf{Return}

zero on success; error code in case of error
\index{crypto\_akcipher\_verify (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-akcipher:c.crypto_akcipher_verify}\pysiglinewithargsret{int \bfcode{crypto\_akcipher\_verify}}{struct {\hyperref[crypto/api\string-akcipher:c.akcipher_request]{\emph{akcipher\_request}}} *\emph{ req}}{}
Invoke public key verify operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct akcipher\_request * req}}] \leavevmode
asymmetric key request

\end{description}

\textbf{Description}

Function invokes the specific public key verify operation for a given
public key algorithm

\textbf{Return}

zero on success; error code in case of error
\index{crypto\_akcipher\_set\_pub\_key (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-akcipher:c.crypto_akcipher_set_pub_key}\pysiglinewithargsret{int \bfcode{crypto\_akcipher\_set\_pub\_key}}{struct crypto\_akcipher *\emph{ tfm}, const void *\emph{ key}, unsigned int\emph{ keylen}}{}
Invoke set public key operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_akcipher * tfm}}] \leavevmode
tfm handle

\item[{\code{const void * key}}] \leavevmode
BER encoded public key

\item[{\code{unsigned int keylen}}] \leavevmode
length of the key

\end{description}

\textbf{Description}

Function invokes the algorithm specific set key function, which knows
how to decode and interpret the encoded key

\textbf{Return}

zero on success; error code in case of error
\index{crypto\_akcipher\_set\_priv\_key (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-akcipher:c.crypto_akcipher_set_priv_key}\pysiglinewithargsret{int \bfcode{crypto\_akcipher\_set\_priv\_key}}{struct crypto\_akcipher *\emph{ tfm}, const void *\emph{ key}, unsigned int\emph{ keylen}}{}
Invoke set private key operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_akcipher * tfm}}] \leavevmode
tfm handle

\item[{\code{const void * key}}] \leavevmode
BER encoded private key

\item[{\code{unsigned int keylen}}] \leavevmode
length of the key

\end{description}

\textbf{Description}

Function invokes the algorithm specific set key function, which knows
how to decode and interpret the encoded key

\textbf{Return}

zero on success; error code in case of error


\section{Asymmetric Cipher Request Handle}
\label{crypto/api-akcipher:asymmetric-cipher-request-handle}\index{akcipher\_request\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-akcipher:c.akcipher_request_alloc}\pysiglinewithargsret{struct {\hyperref[crypto/api\string-akcipher:c.akcipher_request]{\emph{akcipher\_request}}} * \bfcode{akcipher\_request\_alloc}}{struct crypto\_akcipher *\emph{ tfm}, gfp\_t\emph{ gfp}}{}
allocates public key request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_akcipher * tfm}}] \leavevmode
AKCIPHER tfm handle allocated with {\hyperref[crypto/api\string-akcipher:c.crypto_alloc_akcipher]{\emph{\code{crypto\_alloc\_akcipher()}}}}

\item[{\code{gfp\_t gfp}}] \leavevmode
allocation flags

\end{description}

\textbf{Return}

allocated handle in case of success or NULL in case of an error.
\index{akcipher\_request\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-akcipher:c.akcipher_request_free}\pysiglinewithargsret{void \bfcode{akcipher\_request\_free}}{struct {\hyperref[crypto/api\string-akcipher:c.akcipher_request]{\emph{akcipher\_request}}} *\emph{ req}}{}
zeroize and free public key request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct akcipher\_request * req}}] \leavevmode
request to free

\end{description}
\index{akcipher\_request\_set\_callback (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-akcipher:c.akcipher_request_set_callback}\pysiglinewithargsret{void \bfcode{akcipher\_request\_set\_callback}}{struct {\hyperref[crypto/api\string-akcipher:c.akcipher_request]{\emph{akcipher\_request}}} *\emph{ req}, u32\emph{ flgs}, crypto\_completion\_t\emph{ cmpl}, void *\emph{ data}}{}
Sets an asynchronous callback.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct akcipher\_request * req}}] \leavevmode
request that the callback will be set for

\item[{\code{u32 flgs}}] \leavevmode
specify for instance if the operation may backlog

\item[{\code{crypto\_completion\_t cmpl}}] \leavevmode
callback which will be called

\item[{\code{void * data}}] \leavevmode
private data used by the caller

\end{description}

\textbf{Description}

Callback will be called when an asynchronous operation on a given
request is finished.
\index{akcipher\_request\_set\_crypt (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-akcipher:c.akcipher_request_set_crypt}\pysiglinewithargsret{void \bfcode{akcipher\_request\_set\_crypt}}{struct {\hyperref[crypto/api\string-akcipher:c.akcipher_request]{\emph{akcipher\_request}}} *\emph{ req}, struct scatterlist *\emph{ src}, struct scatterlist *\emph{ dst}, unsigned int\emph{ src\_len}, unsigned int\emph{ dst\_len}}{}
Sets request parameters

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct akcipher\_request * req}}] \leavevmode
public key request

\item[{\code{struct scatterlist * src}}] \leavevmode
ptr to input scatter list

\item[{\code{struct scatterlist * dst}}] \leavevmode
ptr to output scatter list

\item[{\code{unsigned int src\_len}}] \leavevmode
size of the src input scatter list to be processed

\item[{\code{unsigned int dst\_len}}] \leavevmode
size of the dst output scatter list

\end{description}

\textbf{Description}

Sets parameters required by crypto operation


\section{Key-agreement Protocol Primitives (KPP) Cipher Algorithm Definitions}
\label{crypto/api-kpp::doc}\label{crypto/api-kpp:key-agreement-protocol-primitives-kpp-cipher-algorithm-definitions}\index{kpp\_request (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.kpp_request}\pysigline{struct \bfcode{kpp\_request}}
\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct kpp\PYGZus{}request \PYGZob{}
  struct crypto\PYGZus{}async\PYGZus{}request base;
  struct scatterlist *src;
  struct scatterlist *dst;
  unsigned int src\PYGZus{}len;
  unsigned int dst\PYGZus{}len;
  void *\PYGZus{}\PYGZus{}ctx[];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{base}}] \leavevmode
Common attributes for async crypto requests

\item[{\code{src}}] \leavevmode
Source data

\item[{\code{dst}}] \leavevmode
Destination data

\item[{\code{src\_len}}] \leavevmode
Size of the input buffer

\item[{\code{dst\_len}}] \leavevmode
Size of the output buffer. It needs to be at least
as big as the expected result depending on the operation
After operation it will be updated with the actual size of the
result. In case of error where the dst sgl size was insufficient,
it will be updated to the size required for the operation.

\item[{\code{\_\_ctx}}] \leavevmode
Start of private context data

\end{description}
\index{crypto\_kpp (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.crypto_kpp}\pysigline{struct \bfcode{crypto\_kpp}}
user-instantiated object which encapsulate algorithms and core processing logic

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct crypto\PYGZus{}kpp \PYGZob{}
  struct crypto\PYGZus{}tfm base;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{base}}] \leavevmode
Common crypto API algorithm data structure

\end{description}
\index{kpp\_alg (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.kpp_alg}\pysigline{struct \bfcode{kpp\_alg}}
generic key-agreement protocol primitives

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct kpp\PYGZus{}alg \PYGZob{}
  int (*set\PYGZus{}secret)(struct crypto\PYGZus{}kpp *tfm, const void *buffer, unsigned int len);
  int (*generate\PYGZus{}public\PYGZus{}key)(struct kpp\PYGZus{}request *req);
  int (*compute\PYGZus{}shared\PYGZus{}secret)(struct kpp\PYGZus{}request *req);
  unsigned int (*max\PYGZus{}size)(struct crypto\PYGZus{}kpp *tfm);
  int (*init)(struct crypto\PYGZus{}kpp *tfm);
  void (*exit)(struct crypto\PYGZus{}kpp *tfm);
  unsigned int reqsize;
  struct crypto\PYGZus{}alg base;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{set\_secret}}] \leavevmode
Function invokes the protocol specific function to
store the secret private key along with parameters.
The implementation knows how to decode the buffer

\item[{\code{generate\_public\_key}}] \leavevmode
Function generate the public key to be sent to the
counterpart. In case of error, where output is not big
enough req-\textgreater{}dst\_len will be updated to the size
required

\item[{\code{compute\_shared\_secret}}] \leavevmode
Function compute the shared secret as defined by
the algorithm. The result is given back to the user.
In case of error, where output is not big enough,
req-\textgreater{}dst\_len will be updated to the size required

\item[{\code{max\_size}}] \leavevmode
Function returns the size of the output buffer

\item[{\code{init}}] \leavevmode
Initialize the object. This is called only once at
instantiation time. In case the cryptographic hardware
needs to be initialized. Software fallback should be
put in place here.

\item[{\code{exit}}] \leavevmode
Undo everything \textbf{init} did.

\item[{\code{reqsize}}] \leavevmode
Request context size required by algorithm
implementation

\item[{\code{base}}] \leavevmode
Common crypto API algorithm data structure

\end{description}
\index{kpp\_secret (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.kpp_secret}\pysigline{struct \bfcode{kpp\_secret}}
small header for packing secret buffer

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct kpp\PYGZus{}secret \PYGZob{}
  unsigned short type;
  unsigned short len;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{type}}] \leavevmode
define type of secret. Each kpp type will define its own

\item[{\code{len}}] \leavevmode
specify the len of the secret, include the header, that
follows the struct

\end{description}


\section{Key-agreement Protocol Primitives (KPP) Cipher API}
\label{crypto/api-kpp:key-agreement-protocol-primitives-kpp-cipher-api}
The KPP API is used with the algorithm type
CRYPTO\_ALG\_TYPE\_KPP (listed as type ``kpp'' in /proc/crypto)
\index{crypto\_alloc\_kpp (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.crypto_alloc_kpp}\pysiglinewithargsret{struct {\hyperref[crypto/api\string-kpp:c.crypto_kpp]{\emph{crypto\_kpp}}} * \bfcode{crypto\_alloc\_kpp}}{const char *\emph{ alg\_name}, u32\emph{ type}, u32\emph{ mask}}{}
allocate KPP tfm handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * alg\_name}}] \leavevmode
is the name of the kpp algorithm (e.g. ``dh'', ``ecdh'')

\item[{\code{u32 type}}] \leavevmode
specifies the type of the algorithm

\item[{\code{u32 mask}}] \leavevmode
specifies the mask for the algorithm

\end{description}

\textbf{Description}

Allocate a handle for kpp algorithm. The returned struct crypto\_kpp
is required for any following API invocation

\textbf{Return}
\begin{description}
\item[{allocated handle in case of success; \code{IS\_ERR()} is true in case of}] \leavevmode
an error, \code{PTR\_ERR()} returns the error code.

\end{description}
\index{crypto\_free\_kpp (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.crypto_free_kpp}\pysiglinewithargsret{void \bfcode{crypto\_free\_kpp}}{struct {\hyperref[crypto/api\string-kpp:c.crypto_kpp]{\emph{crypto\_kpp}}} *\emph{ tfm}}{}
free KPP tfm handle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_kpp * tfm}}] \leavevmode
KPP tfm handle allocated with {\hyperref[crypto/api\string-kpp:c.crypto_alloc_kpp]{\emph{\code{crypto\_alloc\_kpp()}}}}

\end{description}
\index{crypto\_kpp\_set\_secret (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.crypto_kpp_set_secret}\pysiglinewithargsret{int \bfcode{crypto\_kpp\_set\_secret}}{struct {\hyperref[crypto/api\string-kpp:c.crypto_kpp]{\emph{crypto\_kpp}}} *\emph{ tfm}, const void *\emph{ buffer}, unsigned int\emph{ len}}{}
Invoke kpp operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_kpp * tfm}}] \leavevmode
tfm handle

\item[{\code{const void * buffer}}] \leavevmode
Buffer holding the packet representation of the private
key. The structure of the packet key depends on the particular
KPP implementation. Packing and unpacking helpers are provided
for ECDH and DH (see the respective header files for those
implementations).

\item[{\code{unsigned int len}}] \leavevmode
Length of the packet private key buffer.

\end{description}

\textbf{Description}

Function invokes the specific kpp operation for a given alg.

\textbf{Return}

zero on success; error code in case of error
\index{crypto\_kpp\_generate\_public\_key (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.crypto_kpp_generate_public_key}\pysiglinewithargsret{int \bfcode{crypto\_kpp\_generate\_public\_key}}{struct {\hyperref[crypto/api\string-kpp:c.kpp_request]{\emph{kpp\_request}}} *\emph{ req}}{}
Invoke kpp operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kpp\_request * req}}] \leavevmode
kpp key request

\end{description}

\textbf{Description}

Function invokes the specific kpp operation for generating the public part
for a given kpp algorithm.

To generate a private key, the caller should use a random number generator.
The output of the requested length serves as the private key.

\textbf{Return}

zero on success; error code in case of error
\index{crypto\_kpp\_compute\_shared\_secret (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.crypto_kpp_compute_shared_secret}\pysiglinewithargsret{int \bfcode{crypto\_kpp\_compute\_shared\_secret}}{struct {\hyperref[crypto/api\string-kpp:c.kpp_request]{\emph{kpp\_request}}} *\emph{ req}}{}
Invoke kpp operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kpp\_request * req}}] \leavevmode
kpp key request

\end{description}

\textbf{Description}

Function invokes the specific kpp operation for computing the shared secret
for a given kpp algorithm.

\textbf{Return}

zero on success; error code in case of error
\index{crypto\_kpp\_maxsize (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.crypto_kpp_maxsize}\pysiglinewithargsret{unsigned int \bfcode{crypto\_kpp\_maxsize}}{struct {\hyperref[crypto/api\string-kpp:c.crypto_kpp]{\emph{crypto\_kpp}}} *\emph{ tfm}}{}
Get len for output buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_kpp * tfm}}] \leavevmode
KPP tfm handle allocated with {\hyperref[crypto/api\string-kpp:c.crypto_alloc_kpp]{\emph{\code{crypto\_alloc\_kpp()}}}}

\end{description}

\textbf{Description}

Function returns the output buffer size required for a given key.
Function assumes that the key is already set in the transformation. If this
function is called without a setkey or with a failed setkey, you will end up
in a NULL dereference.


\section{Key-agreement Protocol Primitives (KPP) Cipher Request Handle}
\label{crypto/api-kpp:key-agreement-protocol-primitives-kpp-cipher-request-handle}\index{kpp\_request\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.kpp_request_alloc}\pysiglinewithargsret{struct {\hyperref[crypto/api\string-kpp:c.kpp_request]{\emph{kpp\_request}}} * \bfcode{kpp\_request\_alloc}}{struct {\hyperref[crypto/api\string-kpp:c.crypto_kpp]{\emph{crypto\_kpp}}} *\emph{ tfm}, gfp\_t\emph{ gfp}}{}
allocates kpp request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct crypto\_kpp * tfm}}] \leavevmode
KPP tfm handle allocated with {\hyperref[crypto/api\string-kpp:c.crypto_alloc_kpp]{\emph{\code{crypto\_alloc\_kpp()}}}}

\item[{\code{gfp\_t gfp}}] \leavevmode
allocation flags

\end{description}

\textbf{Return}

allocated handle in case of success or NULL in case of an error.
\index{kpp\_request\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.kpp_request_free}\pysiglinewithargsret{void \bfcode{kpp\_request\_free}}{struct {\hyperref[crypto/api\string-kpp:c.kpp_request]{\emph{kpp\_request}}} *\emph{ req}}{}
zeroize and free kpp request

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kpp\_request * req}}] \leavevmode
request to free

\end{description}
\index{kpp\_request\_set\_callback (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.kpp_request_set_callback}\pysiglinewithargsret{void \bfcode{kpp\_request\_set\_callback}}{struct {\hyperref[crypto/api\string-kpp:c.kpp_request]{\emph{kpp\_request}}} *\emph{ req}, u32\emph{ flgs}, crypto\_completion\_t\emph{ cmpl}, void *\emph{ data}}{}
Sets an asynchronous callback.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kpp\_request * req}}] \leavevmode
request that the callback will be set for

\item[{\code{u32 flgs}}] \leavevmode
specify for instance if the operation may backlog

\item[{\code{crypto\_completion\_t cmpl}}] \leavevmode
callback which will be called

\item[{\code{void * data}}] \leavevmode
private data used by the caller

\end{description}

\textbf{Description}

Callback will be called when an asynchronous operation on a given
request is finished.
\index{kpp\_request\_set\_input (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.kpp_request_set_input}\pysiglinewithargsret{void \bfcode{kpp\_request\_set\_input}}{struct {\hyperref[crypto/api\string-kpp:c.kpp_request]{\emph{kpp\_request}}} *\emph{ req}, struct scatterlist *\emph{ input}, unsigned int\emph{ input\_len}}{}
Sets input buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kpp\_request * req}}] \leavevmode
kpp request

\item[{\code{struct scatterlist * input}}] \leavevmode
ptr to input scatter list

\item[{\code{unsigned int input\_len}}] \leavevmode
size of the input scatter list

\end{description}

\textbf{Description}

Sets parameters required by generate\_public\_key
\index{kpp\_request\_set\_output (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.kpp_request_set_output}\pysiglinewithargsret{void \bfcode{kpp\_request\_set\_output}}{struct {\hyperref[crypto/api\string-kpp:c.kpp_request]{\emph{kpp\_request}}} *\emph{ req}, struct scatterlist *\emph{ output}, unsigned int\emph{ output\_len}}{}
Sets output buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct kpp\_request * req}}] \leavevmode
kpp request

\item[{\code{struct scatterlist * output}}] \leavevmode
ptr to output scatter list

\item[{\code{unsigned int output\_len}}] \leavevmode
size of the output scatter list

\end{description}

\textbf{Description}

Sets parameters required by kpp operation


\section{ECDH Helper Functions}
\label{crypto/api-kpp:ecdh-helper-functions}
To use ECDH with the KPP cipher API, the following data structure and
functions should be used.

The ECC curves known to the ECDH implementation are specified in this
header file.

To use ECDH with KPP, the following functions should be used to operate on
an ECDH private key. The packet private key that can be set with
the KPP API function call of crypto\_kpp\_set\_secret.
\index{ecdh (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.ecdh}\pysigline{struct \bfcode{ecdh}}
define an ECDH private key

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct ecdh \PYGZob{}
  unsigned short curve\PYGZus{}id;
  char *key;
  unsigned short key\PYGZus{}size;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{curve\_id}}] \leavevmode
ECC curve the key is based on.

\item[{\code{key}}] \leavevmode
Private ECDH key

\item[{\code{key\_size}}] \leavevmode
Size of the private ECDH key

\end{description}
\index{crypto\_ecdh\_key\_len (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.crypto_ecdh_key_len}\pysiglinewithargsret{unsigned int \bfcode{crypto\_ecdh\_key\_len}}{const struct {\hyperref[crypto/api\string-kpp:c.ecdh]{\emph{ecdh}}} *\emph{ params}}{}
Obtain the size of the private ECDH key

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct ecdh * params}}] \leavevmode
private ECDH key

\end{description}

\textbf{Description}

This function returns the packet ECDH key size. A caller can use that
with the provided ECDH private key reference to obtain the required
memory size to hold a packet key.

\textbf{Return}

size of the key in bytes
\index{crypto\_ecdh\_encode\_key (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.crypto_ecdh_encode_key}\pysiglinewithargsret{int \bfcode{crypto\_ecdh\_encode\_key}}{char *\emph{ buf}, unsigned int\emph{ len}, const struct {\hyperref[crypto/api\string-kpp:c.ecdh]{\emph{ecdh}}} *\emph{ p}}{}
encode the private key

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{char * buf}}] \leavevmode
Buffer allocated by the caller to hold the packet ECDH
private key. The buffer should be at least crypto\_ecdh\_key\_len
bytes in size.

\item[{\code{unsigned int len}}] \leavevmode
Length of the packet private key buffer

\item[{\code{const struct ecdh * p}}] \leavevmode
Buffer with the caller-specified private key

\end{description}

\textbf{Description}

The ECDH implementations operate on a packet representation of the private
key.

\textbf{Return}

-EINVAL if buffer has insufficient size, 0 on success
\index{crypto\_ecdh\_decode\_key (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.crypto_ecdh_decode_key}\pysiglinewithargsret{int \bfcode{crypto\_ecdh\_decode\_key}}{const char *\emph{ buf}, unsigned int\emph{ len}, struct {\hyperref[crypto/api\string-kpp:c.ecdh]{\emph{ecdh}}} *\emph{ p}}{}
decode a private key

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * buf}}] \leavevmode
Buffer holding a packet key that should be decoded

\item[{\code{unsigned int len}}] \leavevmode
Length of the packet private key buffer

\item[{\code{struct ecdh * p}}] \leavevmode
Buffer allocated by the caller that is filled with the
unpacked ECDH private key.

\end{description}

\textbf{Description}

The unpacking obtains the private key by pointing \textbf{p} to the correct location
in \textbf{buf}. Thus, both pointers refer to the same memory.

\textbf{Return}

-EINVAL if buffer has insufficient size, 0 on success


\section{DH Helper Functions}
\label{crypto/api-kpp:dh-helper-functions}
To use DH with the KPP cipher API, the following data structure and
functions should be used.

To use DH with KPP, the following functions should be used to operate on
a DH private key. The packet private key that can be set with
the KPP API function call of crypto\_kpp\_set\_secret.
\index{dh (C type)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.dh}\pysigline{struct \bfcode{dh}}
define a DH private key

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct dh \PYGZob{}
  void *key;
  void *p;
  void *g;
  unsigned int key\PYGZus{}size;
  unsigned int p\PYGZus{}size;
  unsigned int g\PYGZus{}size;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{key}}] \leavevmode
Private DH key

\item[{\code{p}}] \leavevmode
Diffie-Hellman parameter P

\item[{\code{g}}] \leavevmode
Diffie-Hellman generator G

\item[{\code{key\_size}}] \leavevmode
Size of the private DH key

\item[{\code{p\_size}}] \leavevmode
Size of DH parameter P

\item[{\code{g\_size}}] \leavevmode
Size of DH generator G

\end{description}
\index{crypto\_dh\_key\_len (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.crypto_dh_key_len}\pysiglinewithargsret{unsigned int \bfcode{crypto\_dh\_key\_len}}{const struct {\hyperref[crypto/api\string-kpp:c.dh]{\emph{dh}}} *\emph{ params}}{}
Obtain the size of the private DH key

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct dh * params}}] \leavevmode
private DH key

\end{description}

\textbf{Description}

This function returns the packet DH key size. A caller can use that
with the provided DH private key reference to obtain the required
memory size to hold a packet key.

\textbf{Return}

size of the key in bytes
\index{crypto\_dh\_encode\_key (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.crypto_dh_encode_key}\pysiglinewithargsret{int \bfcode{crypto\_dh\_encode\_key}}{char *\emph{ buf}, unsigned int\emph{ len}, const struct {\hyperref[crypto/api\string-kpp:c.dh]{\emph{dh}}} *\emph{ params}}{}
encode the private key

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{char * buf}}] \leavevmode
Buffer allocated by the caller to hold the packet DH
private key. The buffer should be at least crypto\_dh\_key\_len
bytes in size.

\item[{\code{unsigned int len}}] \leavevmode
Length of the packet private key buffer

\item[{\code{const struct dh * params}}] \leavevmode
Buffer with the caller-specified private key

\end{description}

\textbf{Description}

The DH implementations operate on a packet representation of the private
key.

\textbf{Return}

-EINVAL if buffer has insufficient size, 0 on success
\index{crypto\_dh\_decode\_key (C function)}

\begin{fulllineitems}
\phantomsection\label{crypto/api-kpp:c.crypto_dh_decode_key}\pysiglinewithargsret{int \bfcode{crypto\_dh\_decode\_key}}{const char *\emph{ buf}, unsigned int\emph{ len}, struct {\hyperref[crypto/api\string-kpp:c.dh]{\emph{dh}}} *\emph{ params}}{}
decode a private key

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * buf}}] \leavevmode
Buffer holding a packet key that should be decoded

\item[{\code{unsigned int len}}] \leavevmode
Length of the packet private key buffer

\item[{\code{struct dh * params}}] \leavevmode
Buffer allocated by the caller that is filled with the
unpacked DH private key.

\end{description}

\textbf{Description}

The unpacking obtains the private key by pointing \textbf{p} to the correct location
in \textbf{buf}. Thus, both pointers refer to the same memory.

\textbf{Return}

-EINVAL if buffer has insufficient size, 0 on success


\chapter{Code Examples}
\label{crypto/api-samples:code-examples}\label{crypto/api-samples::doc}

\section{Code Example For Symmetric Key Cipher Operation}
\label{crypto/api-samples:code-example-for-symmetric-key-cipher-operation}
\begin{Verbatim}[commandchars=\\\{\}]
/* tie all data structures together */
struct skcipher\PYGZus{}def \PYGZob{}
    struct scatterlist sg;
    struct crypto\PYGZus{}skcipher *tfm;
    struct skcipher\PYGZus{}request *req;
    struct crypto\PYGZus{}wait wait;
\PYGZcb{};

/* Perform cipher operation */
static unsigned int test\PYGZus{}skcipher\PYGZus{}encdec(struct skcipher\PYGZus{}def *sk,
                     int enc)
\PYGZob{}
    int rc;

    if (enc)
        rc = crypto\PYGZus{}wait\PYGZus{}req(crypto\PYGZus{}skcipher\PYGZus{}encrypt(sk\PYGZhy{}\PYGZgt{}req), \PYGZam{}sk\PYGZhy{}\PYGZgt{}wait);
    else
        rc = crypto\PYGZus{}wait\PYGZus{}req(crypto\PYGZus{}skcipher\PYGZus{}decrypt(sk\PYGZhy{}\PYGZgt{}req), \PYGZam{}sk\PYGZhy{}\PYGZgt{}wait);

    if (rc)
            pr\PYGZus{}info(\PYGZdq{}skcipher encrypt returned with result \PYGZpc{}d\PYGZbs{}n\PYGZdq{}, rc);

    return rc;
\PYGZcb{}

/* Initialize and trigger cipher operation */
static int test\PYGZus{}skcipher(void)
\PYGZob{}
    struct skcipher\PYGZus{}def sk;
    struct crypto\PYGZus{}skcipher *skcipher = NULL;
    struct skcipher\PYGZus{}request *req = NULL;
    char *scratchpad = NULL;
    char *ivdata = NULL;
    unsigned char key[32];
    int ret = \PYGZhy{}EFAULT;

    skcipher = crypto\PYGZus{}alloc\PYGZus{}skcipher(\PYGZdq{}cbc\PYGZhy{}aes\PYGZhy{}aesni\PYGZdq{}, 0, 0);
    if (IS\PYGZus{}ERR(skcipher)) \PYGZob{}
        pr\PYGZus{}info(\PYGZdq{}could not allocate skcipher handle\PYGZbs{}n\PYGZdq{});
        return PTR\PYGZus{}ERR(skcipher);
    \PYGZcb{}

    req = skcipher\PYGZus{}request\PYGZus{}alloc(skcipher, GFP\PYGZus{}KERNEL);
    if (!req) \PYGZob{}
        pr\PYGZus{}info(\PYGZdq{}could not allocate skcipher request\PYGZbs{}n\PYGZdq{});
        ret = \PYGZhy{}ENOMEM;
        goto out;
    \PYGZcb{}

    skcipher\PYGZus{}request\PYGZus{}set\PYGZus{}callback(req, CRYPTO\PYGZus{}TFM\PYGZus{}REQ\PYGZus{}MAY\PYGZus{}BACKLOG,
                      crypto\PYGZus{}req\PYGZus{}done,
                      \PYGZam{}sk.wait);

    /* AES 256 with random key */
    get\PYGZus{}random\PYGZus{}bytes(\PYGZam{}key, 32);
    if (crypto\PYGZus{}skcipher\PYGZus{}setkey(skcipher, key, 32)) \PYGZob{}
        pr\PYGZus{}info(\PYGZdq{}key could not be set\PYGZbs{}n\PYGZdq{});
        ret = \PYGZhy{}EAGAIN;
        goto out;
    \PYGZcb{}

    /* IV will be random */
    ivdata = kmalloc(16, GFP\PYGZus{}KERNEL);
    if (!ivdata) \PYGZob{}
        pr\PYGZus{}info(\PYGZdq{}could not allocate ivdata\PYGZbs{}n\PYGZdq{});
        goto out;
    \PYGZcb{}
    get\PYGZus{}random\PYGZus{}bytes(ivdata, 16);

    /* Input data will be random */
    scratchpad = kmalloc(16, GFP\PYGZus{}KERNEL);
    if (!scratchpad) \PYGZob{}
        pr\PYGZus{}info(\PYGZdq{}could not allocate scratchpad\PYGZbs{}n\PYGZdq{});
        goto out;
    \PYGZcb{}
    get\PYGZus{}random\PYGZus{}bytes(scratchpad, 16);

    sk.tfm = skcipher;
    sk.req = req;

    /* We encrypt one block */
    sg\PYGZus{}init\PYGZus{}one(\PYGZam{}sk.sg, scratchpad, 16);
    skcipher\PYGZus{}request\PYGZus{}set\PYGZus{}crypt(req, \PYGZam{}sk.sg, \PYGZam{}sk.sg, 16, ivdata);
    crypto\PYGZus{}init\PYGZus{}wait(\PYGZam{}sk.wait);

    /* encrypt data */
    ret = test\PYGZus{}skcipher\PYGZus{}encdec(\PYGZam{}sk, 1);
    if (ret)
        goto out;

    pr\PYGZus{}info(\PYGZdq{}Encryption triggered successfully\PYGZbs{}n\PYGZdq{});

out:
    if (skcipher)
        crypto\PYGZus{}free\PYGZus{}skcipher(skcipher);
    if (req)
        skcipher\PYGZus{}request\PYGZus{}free(req);
    if (ivdata)
        kfree(ivdata);
    if (scratchpad)
        kfree(scratchpad);
    return ret;
\PYGZcb{}
\end{Verbatim}


\section{Code Example For Use of Operational State Memory With SHASH}
\label{crypto/api-samples:code-example-for-use-of-operational-state-memory-with-shash}
\begin{Verbatim}[commandchars=\\\{\}]
struct sdesc \PYGZob{}
    struct shash\PYGZus{}desc shash;
    char ctx[];
\PYGZcb{};

static struct sdesc *init\PYGZus{}sdesc(struct crypto\PYGZus{}shash *alg)
\PYGZob{}
    struct sdesc *sdesc;
    int size;

    size = sizeof(struct shash\PYGZus{}desc) + crypto\PYGZus{}shash\PYGZus{}descsize(alg);
    sdesc = kmalloc(size, GFP\PYGZus{}KERNEL);
    if (!sdesc)
        return ERR\PYGZus{}PTR(\PYGZhy{}ENOMEM);
    sdesc\PYGZhy{}\PYGZgt{}shash.tfm = alg;
    sdesc\PYGZhy{}\PYGZgt{}shash.flags = 0x0;
    return sdesc;
\PYGZcb{}

static int calc\PYGZus{}hash(struct crypto\PYGZus{}shash *alg,
             const unsigned char *data, unsigned int datalen,
             unsigned char *digest)
\PYGZob{}
    struct sdesc *sdesc;
    int ret;

    sdesc = init\PYGZus{}sdesc(alg);
    if (IS\PYGZus{}ERR(sdesc)) \PYGZob{}
        pr\PYGZus{}info(\PYGZdq{}can\PYGZsq{}t alloc sdesc\PYGZbs{}n\PYGZdq{});
        return PTR\PYGZus{}ERR(sdesc);
    \PYGZcb{}

    ret = crypto\PYGZus{}shash\PYGZus{}digest(\PYGZam{}sdesc\PYGZhy{}\PYGZgt{}shash, data, datalen, digest);
    kfree(sdesc);
    return ret;
\PYGZcb{}

static int test\PYGZus{}hash(const unsigned char *data, unsigned int datalen,
             unsigned char *digest)
\PYGZob{}
    struct crypto\PYGZus{}shash *alg;
    char *hash\PYGZus{}alg\PYGZus{}name = \PYGZdq{}sha1\PYGZhy{}padlock\PYGZhy{}nano\PYGZdq{};
    int ret;

    alg = crypto\PYGZus{}alloc\PYGZus{}shash(hash\PYGZus{}alg\PYGZus{}name, CRYPTO\PYGZus{}ALG\PYGZus{}TYPE\PYGZus{}SHASH, 0);
    if (IS\PYGZus{}ERR(alg)) \PYGZob{}
            pr\PYGZus{}info(\PYGZdq{}can\PYGZsq{}t alloc alg \PYGZpc{}s\PYGZbs{}n\PYGZdq{}, hash\PYGZus{}alg\PYGZus{}name);
            return PTR\PYGZus{}ERR(alg);
    \PYGZcb{}
    ret = calc\PYGZus{}hash(alg, data, datalen, digest);
    crypto\PYGZus{}free\PYGZus{}shash(alg);
    return ret;
\PYGZcb{}
\end{Verbatim}


\section{Code Example For Random Number Generator Usage}
\label{crypto/api-samples:code-example-for-random-number-generator-usage}
\begin{Verbatim}[commandchars=\\\{\}]
static int get\PYGZus{}random\PYGZus{}numbers(u8 *buf, unsigned int len)
\PYGZob{}
    struct crypto\PYGZus{}rng *rng = NULL;
    char *drbg = \PYGZdq{}drbg\PYGZus{}nopr\PYGZus{}sha256\PYGZdq{}; /* Hash DRBG with SHA\PYGZhy{}256, no PR */
    int ret;

    if (!buf \textbar{}\textbar{} !len) \PYGZob{}
        pr\PYGZus{}debug(\PYGZdq{}No output buffer provided\PYGZbs{}n\PYGZdq{});
        return \PYGZhy{}EINVAL;
    \PYGZcb{}

    rng = crypto\PYGZus{}alloc\PYGZus{}rng(drbg, 0, 0);
    if (IS\PYGZus{}ERR(rng)) \PYGZob{}
        pr\PYGZus{}debug(\PYGZdq{}could not allocate RNG handle for \PYGZpc{}s\PYGZbs{}n\PYGZdq{}, drbg);
        return PTR\PYGZus{}ERR(rng);
    \PYGZcb{}

    ret = crypto\PYGZus{}rng\PYGZus{}get\PYGZus{}bytes(rng, buf, len);
    if (ret \PYGZlt{} 0)
        pr\PYGZus{}debug(\PYGZdq{}generation of random numbers failed\PYGZbs{}n\PYGZdq{});
    else if (ret == 0)
        pr\PYGZus{}debug(\PYGZdq{}RNG returned no data\PYGZdq{});
    else
        pr\PYGZus{}debug(\PYGZdq{}RNG returned \PYGZpc{}d bytes of data\PYGZbs{}n\PYGZdq{}, ret);

out:
    crypto\PYGZus{}free\PYGZus{}rng(rng);
    return ret;
\PYGZcb{}
\end{Verbatim}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
