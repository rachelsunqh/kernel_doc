% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,8pt,english]{sphinxmanual}


\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }


	% Use some font with UTF-8 support with XeLaTeX
        \usepackage{fontspec}
        \setsansfont{DejaVu Serif}
        \setromanfont{DejaVu Sans}
        \setmonofont{DejaVu Sans Mono}

     \usepackage[margin=0.5in, top=1in, bottom=1in]{geometry}
        \usepackage{ifthen}

        % Put notes in color and let them be inside a table
	\definecolor{NoteColor}{RGB}{204,255,255}
	\definecolor{WarningColor}{RGB}{255,204,204}
	\definecolor{AttentionColor}{RGB}{255,255,204}
	\definecolor{ImportantColor}{RGB}{192,255,204}
	\definecolor{OtherColor}{RGB}{204,204,204}
        \newlength{\mynoticelength}
        \makeatletter\newenvironment{coloredbox}[1]{%
	   \setlength{\fboxrule}{1pt}
	   \setlength{\fboxsep}{7pt}
	   \setlength{\mynoticelength}{\linewidth}
	   \addtolength{\mynoticelength}{-2\fboxsep}
	   \addtolength{\mynoticelength}{-2\fboxrule}
           \begin{lrbox}{\@tempboxa}\begin{minipage}{\mynoticelength}}{\end{minipage}\end{lrbox}%
	   \ifthenelse%
	      {\equal{\py@noticetype}{note}}%
	      {\colorbox{NoteColor}{\usebox{\@tempboxa}}}%
	      {%
	         \ifthenelse%
	         {\equal{\py@noticetype}{warning}}%
	         {\colorbox{WarningColor}{\usebox{\@tempboxa}}}%
		 {%
	            \ifthenelse%
	            {\equal{\py@noticetype}{attention}}%
	            {\colorbox{AttentionColor}{\usebox{\@tempboxa}}}%
		    {%
	               \ifthenelse%
	               {\equal{\py@noticetype}{important}}%
	               {\colorbox{ImportantColor}{\usebox{\@tempboxa}}}%
	               {\colorbox{OtherColor}{\usebox{\@tempboxa}}}%
		    }%
		 }%
	      }%
        }\makeatother

        \makeatletter
        \renewenvironment{notice}[2]{%
          \def\py@noticetype{#1}
          \begin{coloredbox}{#1}
          \bf\it
          \par\strong{#2}
          \csname py@noticestart@#1\endcsname
        }
	{
          \csname py@noticeend@\py@noticetype\endcsname
          \end{coloredbox}
        }
	\makeatother

     

\title{Linux Networking Documentation}
\date{March 08, 2018}
\release{4.16.0-rc4+}
\author{The kernel development community}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\setcounter{tocdepth}{1}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{networking/index::doc}


Contents:


\chapter{batman-adv}
\label{networking/batman-adv:batman-adv}\label{networking/batman-adv::doc}\label{networking/batman-adv:linux-networking-documentation}
Batman advanced is a new approach to wireless networking which does no longer
operate on the IP basis. Unlike the batman daemon, which exchanges information
using UDP packets and sets routing tables, batman-advanced operates on ISO/OSI
Layer 2 only and uses and routes (or better: bridges) Ethernet Frames. It
emulates a virtual network switch of all nodes participating. Therefore all
nodes appear to be link local, thus all higher operating protocols won't be
affected by any changes within the network. You can run almost any protocol
above batman advanced, prominent examples are: IPv4, IPv6, DHCP, IPX.

Batman advanced was implemented as a Linux kernel driver to reduce the overhead
to a minimum. It does not depend on any (other) network driver, and can be used
on wifi as well as ethernet lan, vpn, etc ... (anything with ethernet-style
layer 2).


\section{Configuration}
\label{networking/batman-adv:configuration}
Load the batman-adv module into your kernel:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} insmod batman\PYGZhy{}adv.ko
\end{Verbatim}

The module is now waiting for activation. You must add some interfaces on which
batman can operate. After loading the module batman advanced will scan your
systems interfaces to search for compatible interfaces. Once found, it will
create subfolders in the \code{/sys} directories of each supported interface,
e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ls /sys/class/net/eth0/batman\PYGZus{}adv/
elp\PYGZus{}interval iface\PYGZus{}status mesh\PYGZus{}iface throughput\PYGZus{}override
\end{Verbatim}

If an interface does not have the \code{batman\_adv} subfolder, it probably is not
supported. Not supported interfaces are: loopback, non-ethernet and batman's
own interfaces.

Note: After the module was loaded it will continuously watch for new
interfaces to verify the compatibility. There is no need to reload the module
if you plug your USB wifi adapter into your machine after batman advanced was
initially loaded.

The batman-adv soft-interface can be created using the iproute2 tool \code{ip}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ip link add name bat0 type batadv
\end{Verbatim}

To activate a given interface simply attach it to the \code{bat0} interface:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ip link set dev eth0 master bat0
\end{Verbatim}

Repeat this step for all interfaces you wish to add. Now batman starts
using/broadcasting on this/these interface(s).

By reading the ``iface\_status'' file you can check its status:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} cat /sys/class/net/eth0/batman\PYGZus{}adv/iface\PYGZus{}status
active
\end{Verbatim}

To deactivate an interface you have to detach it from the ``bat0'' interface:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ip link set dev eth0 nomaster
\end{Verbatim}

All mesh wide settings can be found in batman's own interface folder:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ls /sys/class/net/bat0/mesh/
aggregated\PYGZus{}ogms       fragmentation isolation\PYGZus{}mark routing\PYGZus{}algo
ap\PYGZus{}isolation          gw\PYGZus{}bandwidth  log\PYGZus{}level      vlan0
bonding               gw\PYGZus{}mode       multicast\PYGZus{}mode
bridge\PYGZus{}loop\PYGZus{}avoidance gw\PYGZus{}sel\PYGZus{}class  network\PYGZus{}coding
distributed\PYGZus{}arp\PYGZus{}table hop\PYGZus{}penalty   orig\PYGZus{}interval
\end{Verbatim}

There is a special folder for debugging information:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ls /sys/kernel/debug/batman\PYGZus{}adv/bat0/
bla\PYGZus{}backbone\PYGZus{}table log         neighbors         transtable\PYGZus{}local
bla\PYGZus{}claim\PYGZus{}table    mcast\PYGZus{}flags originators
dat\PYGZus{}cache          nc          socket
gateways           nc\PYGZus{}nodes    transtable\PYGZus{}global
\end{Verbatim}

Some of the files contain all sort of status information regarding the mesh
network. For example, you can view the table of originators (mesh
participants) with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} cat /sys/kernel/debug/batman\PYGZus{}adv/bat0/originators
\end{Verbatim}

Other files allow to change batman's behaviour to better fit your requirements.
For instance, you can check the current originator interval (value in
milliseconds which determines how often batman sends its broadcast packets):

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} cat /sys/class/net/bat0/mesh/orig\PYGZus{}interval
1000
\end{Verbatim}

and also change its value:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} echo 3000 \PYGZgt{} /sys/class/net/bat0/mesh/orig\PYGZus{}interval
\end{Verbatim}

In very mobile scenarios, you might want to adjust the originator interval to a
lower value. This will make the mesh more responsive to topology changes, but
will also increase the overhead.


\section{Usage}
\label{networking/batman-adv:usage}
To make use of your newly created mesh, batman advanced provides a new
interface ``bat0'' which you should use from this point on. All interfaces added
to batman advanced are not relevant any longer because batman handles them for
you. Basically, one ``hands over'' the data by using the batman interface and
batman will make sure it reaches its destination.

The ``bat0'' interface can be used like any other regular interface. It needs an
IP address which can be either statically configured or dynamically (by using
DHCP or similar services):

\begin{Verbatim}[commandchars=\\\{\}]
NodeA: ip link set up dev bat0
NodeA: ip addr add 192.168.0.1/24 dev bat0

NodeB: ip link set up dev bat0
NodeB: ip addr add 192.168.0.2/24 dev bat0
NodeB: ping 192.168.0.1
\end{Verbatim}

Note: In order to avoid problems remove all IP addresses previously assigned to
interfaces now used by batman advanced, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ip addr flush dev eth0
\end{Verbatim}


\section{Logging/Debugging}
\label{networking/batman-adv:logging-debugging}
All error messages, warnings and information messages are sent to the kernel
log. Depending on your operating system distribution this can be read in one of
a number of ways. Try using the commands: \code{dmesg}, \code{logread}, or looking in
the files \code{/var/log/kern.log} or \code{/var/log/syslog}. All batman-adv messages
are prefixed with ``batman-adv:'' So to see just these messages try:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} dmesg \textbar{} grep batman\PYGZhy{}adv
\end{Verbatim}

When investigating problems with your mesh network, it is sometimes necessary to
see more detail debug messages. This must be enabled when compiling the
batman-adv module. When building batman-adv as part of kernel, use ``make
menuconfig'' and enable the option \code{B.A.T.M.A.N. debugging}
(\code{CONFIG\_BATMAN\_ADV\_DEBUG=y}).

Those additional debug messages can be accessed using a special file in
debugfs:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} cat /sys/kernel/debug/batman\PYGZus{}adv/bat0/log
\end{Verbatim}

The additional debug output is by default disabled. It can be enabled during
run time. Following log\_levels are defined:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

0
 & 
All debug output disabled
\\
\hline
1
 & 
Enable messages related to routing / flooding / broadcasting
\\
\hline
2
 & 
Enable messages related to route added / changed / deleted
\\
\hline
4
 & 
Enable messages related to translation table operations
\\
\hline
8
 & 
Enable messages related to bridge loop avoidance
\\
\hline
16
 & 
Enable messages related to DAT, ARP snooping and parsing
\\
\hline
32
 & 
Enable messages related to network coding
\\
\hline
64
 & 
Enable messages related to multicast
\\
\hline
128
 & 
Enable messages related to throughput meter
\\
\hline
255
 & 
Enable all messages
\\
\hline\end{tabulary}


The debug output can be changed at runtime using the file
\code{/sys/class/net/bat0/mesh/log\_level}. e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} echo 6 \PYGZgt{} /sys/class/net/bat0/mesh/log\PYGZus{}level
\end{Verbatim}

will enable debug messages for when routes change.

Counters for different types of packets entering and leaving the batman-adv
module are available through ethtool:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ethtool \PYGZhy{}\PYGZhy{}statistics bat0
\end{Verbatim}


\section{batctl}
\label{networking/batman-adv:batctl}
As batman advanced operates on layer 2, all hosts participating in the virtual
switch are completely transparent for all protocols above layer 2. Therefore
the common diagnosis tools do not work as expected. To overcome these problems,
batctl was created. At the moment the batctl contains ping, traceroute, tcpdump
and interfaces to the kernel module settings.

For more information, please see the manpage (\code{man batctl}).

batctl is available on \href{https://www.open-mesh.org/}{https://www.open-mesh.org/}


\section{Contact}
\label{networking/batman-adv:contact}
Please send us comments, experiences, questions, anything :)
\begin{description}
\item[{IRC:}] \leavevmode
\#batman on irc.freenode.org

\item[{Mailing-list:}] \leavevmode
\href{mailto:b.a.t.m.a.n@open-mesh.org}{b.a.t.m.a.n@open-mesh.org} (optional subscription at
\href{https://lists.open-mesh.org/mm/listinfo/b.a.t.m.a.n}{https://lists.open-mesh.org/mm/listinfo/b.a.t.m.a.n})

\end{description}

You can also contact the Authors:
\begin{itemize}
\item {} 
Marek Lindner \textless{}\href{mailto:mareklindner@neomailbox.ch}{mareklindner@neomailbox.ch}\textgreater{}

\item {} 
Simon Wunderlich \textless{}\href{mailto:sw@simonwunderlich.de}{sw@simonwunderlich.de}\textgreater{}

\end{itemize}


\chapter{SocketCAN - Controller Area Network}
\label{networking/can:socketcan-controller-area-network}\label{networking/can::doc}

\section{Overview / What is SocketCAN}
\label{networking/can:overview-what-is-socketcan}
The socketcan package is an implementation of CAN protocols
(Controller Area Network) for Linux.  CAN is a networking technology
which has widespread use in automation, embedded devices, and
automotive fields.  While there have been other CAN implementations
for Linux based on character devices, SocketCAN uses the Berkeley
socket API, the Linux network stack and implements the CAN device
drivers as network interfaces.  The CAN socket API has been designed
as similar as possible to the TCP/IP protocols to allow programmers,
familiar with network programming, to easily learn how to use CAN
sockets.


\section{Motivation / Why Using the Socket API}
\label{networking/can:socketcan-motivation}\label{networking/can:motivation-why-using-the-socket-api}
There have been CAN implementations for Linux before SocketCAN so the
question arises, why we have started another project.  Most existing
implementations come as a device driver for some CAN hardware, they
are based on character devices and provide comparatively little
functionality.  Usually, there is only a hardware-specific device
driver which provides a character device interface to send and
receive raw CAN frames, directly to/from the controller hardware.
Queueing of frames and higher-level transport protocols like ISO-TP
have to be implemented in user space applications.  Also, most
character-device implementations support only one single process to
open the device at a time, similar to a serial interface.  Exchanging
the CAN controller requires employment of another device driver and
often the need for adaption of large parts of the application to the
new driver's API.

SocketCAN was designed to overcome all of these limitations.  A new
protocol family has been implemented which provides a socket interface
to user space applications and which builds upon the Linux network
layer, enabling use all of the provided queueing functionality.  A device
driver for CAN controller hardware registers itself with the Linux
network layer as a network device, so that CAN frames from the
controller can be passed up to the network layer and on to the CAN
protocol family module and also vice-versa.  Also, the protocol family
module provides an API for transport protocol modules to register, so
that any number of transport protocols can be loaded or unloaded
dynamically.  In fact, the can core module alone does not provide any
protocol and cannot be used without loading at least one additional
protocol module.  Multiple sockets can be opened at the same time,
on different or the same protocol module and they can listen/send
frames on different or the same CAN IDs.  Several sockets listening on
the same interface for frames with the same CAN ID are all passed the
same received matching CAN frames.  An application wishing to
communicate using a specific transport protocol, e.g. ISO-TP, just
selects that protocol when opening the socket, and then can read and
write application data byte streams, without having to deal with
CAN-IDs, frames, etc.

Similar functionality visible from user-space could be provided by a
character device, too, but this would lead to a technically inelegant
solution for a couple of reasons:
\begin{itemize}
\item {} 
\textbf{Intricate usage:}  Instead of passing a protocol argument to
socket(2) and using bind(2) to select a CAN interface and CAN ID, an
application would have to do all these operations using ioctl(2)s.

\item {} 
\textbf{Code duplication:}  A character device cannot make use of the Linux
network queueing code, so all that code would have to be duplicated
for CAN networking.

\item {} 
\textbf{Abstraction:}  In most existing character-device implementations, the
hardware-specific device driver for a CAN controller directly
provides the character device for the application to work with.
This is at least very unusual in Unix systems for both, char and
block devices.  For example you don't have a character device for a
certain UART of a serial interface, a certain sound chip in your
computer, a SCSI or IDE controller providing access to your hard
disk or tape streamer device.  Instead, you have abstraction layers
which provide a unified character or block device interface to the
application on the one hand, and a interface for hardware-specific
device drivers on the other hand.  These abstractions are provided
by subsystems like the tty layer, the audio subsystem or the SCSI
and IDE subsystems for the devices mentioned above.

The easiest way to implement a CAN device driver is as a character
device without such a (complete) abstraction layer, as is done by most
existing drivers.  The right way, however, would be to add such a
layer with all the functionality like registering for certain CAN
IDs, supporting several open file descriptors and (de)multiplexing
CAN frames between them, (sophisticated) queueing of CAN frames, and
providing an API for device drivers to register with.  However, then
it would be no more difficult, or may be even easier, to use the
networking framework provided by the Linux kernel, and this is what
SocketCAN does.

\end{itemize}

The use of the networking framework of the Linux kernel is just the
natural and most appropriate way to implement CAN for Linux.


\section{SocketCAN Concept}
\label{networking/can:socketcan-concept}\label{networking/can:id1}
As described in {\hyperref[networking/can:socketcan\string-motivation]{\emph{Motivation / Why Using the Socket API}}} the main goal of SocketCAN is to
provide a socket interface to user space applications which builds
upon the Linux network layer. In contrast to the commonly known
TCP/IP and ethernet networking, the CAN bus is a broadcast-only(!)
medium that has no MAC-layer addressing like ethernet. The CAN-identifier
(can\_id) is used for arbitration on the CAN-bus. Therefore the CAN-IDs
have to be chosen uniquely on the bus. When designing a CAN-ECU
network the CAN-IDs are mapped to be sent by a specific ECU.
For this reason a CAN-ID can be treated best as a kind of source address.


\subsection{Receive Lists}
\label{networking/can:socketcan-receive-lists}\label{networking/can:receive-lists}
The network transparent access of multiple applications leads to the
problem that different applications may be interested in the same
CAN-IDs from the same CAN network interface. The SocketCAN core
module - which implements the protocol family CAN - provides several
high efficient receive lists for this reason. If e.g. a user space
application opens a CAN RAW socket, the raw protocol module itself
requests the (range of) CAN-IDs from the SocketCAN core that are
requested by the user. The subscription and unsubscription of
CAN-IDs can be done for specific CAN interfaces or for all(!) known
CAN interfaces with the can\_rx\_(un)register() functions provided to
CAN protocol modules by the SocketCAN core (see {\hyperref[networking/can:socketcan\string-core\string-module]{\emph{SocketCAN Core Module}}}).
To optimize the CPU usage at runtime the receive lists are split up
into several specific lists per device that match the requested
filter complexity for a given use-case.


\subsection{Local Loopback of Sent Frames}
\label{networking/can:local-loopback-of-sent-frames}\label{networking/can:socketcan-local-loopback1}
As known from other networking concepts the data exchanging
applications may run on the same or different nodes without any
change (except for the according addressing information):

\begin{Verbatim}[commandchars=\\\{\}]
 \PYGZus{}\PYGZus{}\PYGZus{}   \PYGZus{}\PYGZus{}\PYGZus{}   \PYGZus{}\PYGZus{}\PYGZus{}                   \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}   \PYGZus{}\PYGZus{}\PYGZus{}
\textbar{} \PYGZus{} \textbar{} \textbar{} \PYGZus{} \textbar{} \textbar{} \PYGZus{} \textbar{}                 \textbar{} \PYGZus{}   \PYGZus{} \textbar{} \textbar{} \PYGZus{} \textbar{}
\textbar{}\textbar{}A\textbar{}\textbar{} \textbar{}\textbar{}B\textbar{}\textbar{} \textbar{}\textbar{}C\textbar{}\textbar{}                 \textbar{}\textbar{}A\textbar{} \textbar{}B\textbar{}\textbar{} \textbar{}\textbar{}C\textbar{}\textbar{}
\textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{} \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{} \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}                 \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{} \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}
  \textbar{}     \textbar{}     \textbar{}                       \textbar{}       \textbar{}
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}(1)\PYGZhy{} CAN bus \PYGZhy{}(2)\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\end{Verbatim}

To ensure that application A receives the same information in the
example (2) as it would receive in example (1) there is need for
some kind of local loopback of the sent CAN frames on the appropriate
node.

The Linux network devices (by default) just can handle the
transmission and reception of media dependent frames. Due to the
arbitration on the CAN bus the transmission of a low prio CAN-ID
may be delayed by the reception of a high prio CAN frame. To
reflect the correct \footnote[*]{
you really like to have this when you're running analyser
tools like `candump' or `cansniffer' on the (same) node.
} traffic on the node the loopback of the sent
data has to be performed right after a successful transmission. If
the CAN network interface is not capable of performing the loopback for
some reason the SocketCAN core can do this task as a fallback solution.
See {\hyperref[networking/can:socketcan\string-local\string-loopback1]{\emph{Local Loopback of Sent Frames}}} for details (recommended).

The loopback functionality is enabled by default to reflect standard
networking behaviour for CAN applications. Due to some requests from
the RT-SocketCAN group the loopback optionally may be disabled for each
separate socket. See sockopts from the CAN RAW sockets in {\hyperref[networking/can:socketcan\string-raw\string-sockets]{\emph{RAW Protocol Sockets with can\_filters (SOCK\_RAW)}}}.


\subsection{Network Problem Notifications}
\label{networking/can:socketcan-network-problem-notifications}\label{networking/can:network-problem-notifications}
The use of the CAN bus may lead to several problems on the physical
and media access control layer. Detecting and logging of these lower
layer problems is a vital requirement for CAN users to identify
hardware issues on the physical transceiver layer as well as
arbitration problems and error frames caused by the different
ECUs. The occurrence of detected errors are important for diagnosis
and have to be logged together with the exact timestamp. For this
reason the CAN interface driver can generate so called Error Message
Frames that can optionally be passed to the user application in the
same way as other CAN frames. Whenever an error on the physical layer
or the MAC layer is detected (e.g. by the CAN controller) the driver
creates an appropriate error message frame. Error messages frames can
be requested by the user application using the common CAN filter
mechanisms. Inside this filter definition the (interested) type of
errors may be selected. The reception of error messages is disabled
by default. The format of the CAN error message frame is briefly
described in the Linux header file ``include/uapi/linux/can/error.h''.


\section{How to use SocketCAN}
\label{networking/can:how-to-use-socketcan}
Like TCP/IP, you first need to open a socket for communicating over a
CAN network. Since SocketCAN implements a new protocol family, you
need to pass PF\_CAN as the first argument to the socket(2) system
call. Currently, there are two CAN protocols to choose from, the raw
socket protocol and the broadcast manager (BCM). So to open a socket,
you would write:

\begin{Verbatim}[commandchars=\\\{\}]
s = socket(PF\PYGZus{}CAN, SOCK\PYGZus{}RAW, CAN\PYGZus{}RAW);
\end{Verbatim}

and:

\begin{Verbatim}[commandchars=\\\{\}]
s = socket(PF\PYGZus{}CAN, SOCK\PYGZus{}DGRAM, CAN\PYGZus{}BCM);
\end{Verbatim}

respectively.  After the successful creation of the socket, you would
normally use the bind(2) system call to bind the socket to a CAN
interface (which is different from TCP/IP due to different addressing
- see {\hyperref[networking/can:socketcan\string-concept]{\emph{SocketCAN Concept}}}). After binding (CAN\_RAW) or connecting (CAN\_BCM)
the socket, you can read(2) and write(2) from/to the socket or use
send(2), sendto(2), sendmsg(2) and the recv* counterpart operations
on the socket as usual. There are also CAN specific socket options
described below.

The basic CAN frame structure and the sockaddr structure are defined
in include/linux/can.h:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{can\PYGZus{}frame} \PYG{p}{\PYGZob{}}
        \PYG{n}{canid\PYGZus{}t} \PYG{n}{can\PYGZus{}id}\PYG{p}{;}  \PYG{c+cm}{/* 32 bit CAN\PYGZus{}ID + EFF/RTR/ERR flags */}
        \PYG{n}{\PYGZus{}\PYGZus{}u8}    \PYG{n}{can\PYGZus{}dlc}\PYG{p}{;} \PYG{c+cm}{/* frame payload length in byte (0 .. 8) */}
        \PYG{n}{\PYGZus{}\PYGZus{}u8}    \PYG{n}{\PYGZus{}\PYGZus{}pad}\PYG{p}{;}   \PYG{c+cm}{/* padding */}
        \PYG{n}{\PYGZus{}\PYGZus{}u8}    \PYG{n}{\PYGZus{}\PYGZus{}res0}\PYG{p}{;}  \PYG{c+cm}{/* reserved / padding */}
        \PYG{n}{\PYGZus{}\PYGZus{}u8}    \PYG{n}{\PYGZus{}\PYGZus{}res1}\PYG{p}{;}  \PYG{c+cm}{/* reserved / padding */}
        \PYG{n}{\PYGZus{}\PYGZus{}u8}    \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]} \PYG{n}{\PYGZus{}\PYGZus{}attribute\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{(}\PYG{n}{aligned}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

The alignment of the (linear) payload data{[}{]} to a 64bit boundary
allows the user to define their own structs and unions to easily access
the CAN payload. There is no given byteorder on the CAN bus by
default. A read(2) system call on a CAN\_RAW socket transfers a
struct can\_frame to the user space.

The sockaddr\_can structure has an interface index like the
PF\_PACKET socket, that also binds to a specific interface:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{sockaddr\PYGZus{}can} \PYG{p}{\PYGZob{}}
        \PYG{n}{sa\PYGZus{}family\PYGZus{}t} \PYG{n}{can\PYGZus{}family}\PYG{p}{;}
        \PYG{k+kt}{int}         \PYG{n}{can\PYGZus{}ifindex}\PYG{p}{;}
        \PYG{k}{union} \PYG{p}{\PYGZob{}}
                \PYG{c+cm}{/* transport protocol class address info (e.g. ISOTP) */}
                \PYG{k}{struct} \PYG{p}{\PYGZob{}} \PYG{n}{canid\PYGZus{}t} \PYG{n}{rx\PYGZus{}id}\PYG{p}{,} \PYG{n}{tx\PYGZus{}id}\PYG{p}{;} \PYG{p}{\PYGZcb{}} \PYG{n}{tp}\PYG{p}{;}

                \PYG{c+cm}{/* reserved for future CAN protocols address information */}
        \PYG{p}{\PYGZcb{}} \PYG{n}{can\PYGZus{}addr}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

To determine the interface index an appropriate ioctl() has to
be used (example for CAN\_RAW sockets without error checking):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{s}\PYG{p}{;}
\PYG{k}{struct} \PYG{n}{sockaddr\PYGZus{}can} \PYG{n}{addr}\PYG{p}{;}
\PYG{k}{struct} \PYG{n}{ifreq} \PYG{n}{ifr}\PYG{p}{;}

\PYG{n}{s} \PYG{o}{=} \PYG{n}{socket}\PYG{p}{(}\PYG{n}{PF\PYGZus{}CAN}\PYG{p}{,} \PYG{n}{SOCK\PYGZus{}RAW}\PYG{p}{,} \PYG{n}{CAN\PYGZus{}RAW}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{ifr}\PYG{p}{.}\PYG{n}{ifr\PYGZus{}name}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{can0}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{SIOCGIFINDEX}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{ifr}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{addr}\PYG{p}{.}\PYG{n}{can\PYGZus{}family} \PYG{o}{=} \PYG{n}{AF\PYGZus{}CAN}\PYG{p}{;}
\PYG{n}{addr}\PYG{p}{.}\PYG{n}{can\PYGZus{}ifindex} \PYG{o}{=} \PYG{n}{ifr}\PYG{p}{.}\PYG{n}{ifr\PYGZus{}ifindex}\PYG{p}{;}

\PYG{n}{bind}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{p}{(}\PYG{k}{struct} \PYG{n}{sockaddr} \PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{addr}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{addr}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\end{Verbatim}

To bind a socket to all(!) CAN interfaces the interface index must
be 0 (zero). In this case the socket receives CAN frames from every
enabled CAN interface. To determine the originating CAN interface
the system call recvfrom(2) may be used instead of read(2). To send
on a socket that is bound to `any' interface sendto(2) is needed to
specify the outgoing interface.

Reading CAN frames from a bound CAN\_RAW socket (see above) consists
of reading a struct can\_frame:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{can\PYGZus{}frame} \PYG{n}{frame}\PYG{p}{;}

\PYG{n}{nbytes} \PYG{o}{=} \PYG{n}{read}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{frame}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{can\PYGZus{}frame}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{nbytes} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{perror}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{can raw socket read}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/* paranoid check ... */}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{nbytes} \PYG{o}{\PYGZlt{}} \PYG{k}{sizeof}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{can\PYGZus{}frame}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{fprintf}\PYG{p}{(}\PYG{n}{stderr}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{read: incomplete CAN frame}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/* do something with the received CAN frame */}
\end{Verbatim}

Writing CAN frames can be done similarly, with the write(2) system call:

\begin{Verbatim}[commandchars=\\\{\}]
nbytes = write(s, \PYGZam{}frame, sizeof(struct can\PYGZus{}frame));
\end{Verbatim}

When the CAN interface is bound to `any' existing CAN interface
(addr.can\_ifindex = 0) it is recommended to use recvfrom(2) if the
information about the originating CAN interface is needed:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{sockaddr\PYGZus{}can} \PYG{n}{addr}\PYG{p}{;}
\PYG{k}{struct} \PYG{n}{ifreq} \PYG{n}{ifr}\PYG{p}{;}
\PYG{k+kt}{socklen\PYGZus{}t} \PYG{n}{len} \PYG{o}{=} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{addr}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{struct} \PYG{n}{can\PYGZus{}frame} \PYG{n}{frame}\PYG{p}{;}

\PYG{n}{nbytes} \PYG{o}{=} \PYG{n}{recvfrom}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{frame}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{can\PYGZus{}frame}\PYG{p}{)}\PYG{p}{,}
                  \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{(}\PYG{k}{struct} \PYG{n}{sockaddr}\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{addr}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{len}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cm}{/* get interface name of the received CAN frame */}
\PYG{n}{ifr}\PYG{p}{.}\PYG{n}{ifr\PYGZus{}ifindex} \PYG{o}{=} \PYG{n}{addr}\PYG{p}{.}\PYG{n}{can\PYGZus{}ifindex}\PYG{p}{;}
\PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{SIOCGIFNAME}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{ifr}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Received a CAN frame from interface \PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ifr}\PYG{p}{.}\PYG{n}{ifr\PYGZus{}name}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

To write CAN frames on sockets bound to `any' CAN interface the
outgoing interface has to be defined certainly:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{ifr}\PYG{p}{.}\PYG{n}{ifr\PYGZus{}name}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{can0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{SIOCGIFINDEX}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{ifr}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{addr}\PYG{p}{.}\PYG{n}{can\PYGZus{}ifindex} \PYG{o}{=} \PYG{n}{ifr}\PYG{p}{.}\PYG{n}{ifr\PYGZus{}ifindex}\PYG{p}{;}
\PYG{n}{addr}\PYG{p}{.}\PYG{n}{can\PYGZus{}family}  \PYG{o}{=} \PYG{n}{AF\PYGZus{}CAN}\PYG{p}{;}

\PYG{n}{nbytes} \PYG{o}{=} \PYG{n}{sendto}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{frame}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{can\PYGZus{}frame}\PYG{p}{)}\PYG{p}{,}
                \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{(}\PYG{k}{struct} \PYG{n}{sockaddr}\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{addr}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{addr}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

An accurate timestamp can be obtained with an ioctl(2) call after reading
a message from the socket:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{timeval} \PYG{n}{tv}\PYG{p}{;}
\PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{SIOCGSTAMP}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{tv}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

The timestamp has a resolution of one microsecond and is set automatically
at the reception of a CAN frame.

Remark about CAN FD (flexible data rate) support:

Generally the handling of CAN FD is very similar to the formerly described
examples. The new CAN FD capable CAN controllers support two different
bitrates for the arbitration phase and the payload phase of the CAN FD frame
and up to 64 bytes of payload. This extended payload length breaks all the
kernel interfaces (ABI) which heavily rely on the CAN frame with fixed eight
bytes of payload (struct can\_frame) like the CAN\_RAW socket. Therefore e.g.
the CAN\_RAW socket supports a new socket option CAN\_RAW\_FD\_FRAMES that
switches the socket into a mode that allows the handling of CAN FD frames
and (legacy) CAN frames simultaneously (see {\hyperref[networking/can:socketcan\string-rawfd]{\emph{RAW Socket Option CAN\_RAW\_FD\_FRAMES}}}).

The struct canfd\_frame is defined in include/linux/can.h:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{canfd\PYGZus{}frame} \PYG{p}{\PYGZob{}}
        \PYG{n}{canid\PYGZus{}t} \PYG{n}{can\PYGZus{}id}\PYG{p}{;}  \PYG{c+cm}{/* 32 bit CAN\PYGZus{}ID + EFF/RTR/ERR flags */}
        \PYG{n}{\PYGZus{}\PYGZus{}u8}    \PYG{n}{len}\PYG{p}{;}     \PYG{c+cm}{/* frame payload length in byte (0 .. 64) */}
        \PYG{n}{\PYGZus{}\PYGZus{}u8}    \PYG{n}{flags}\PYG{p}{;}   \PYG{c+cm}{/* additional flags for CAN FD */}
        \PYG{n}{\PYGZus{}\PYGZus{}u8}    \PYG{n}{\PYGZus{}\PYGZus{}res0}\PYG{p}{;}  \PYG{c+cm}{/* reserved / padding */}
        \PYG{n}{\PYGZus{}\PYGZus{}u8}    \PYG{n}{\PYGZus{}\PYGZus{}res1}\PYG{p}{;}  \PYG{c+cm}{/* reserved / padding */}
        \PYG{n}{\PYGZus{}\PYGZus{}u8}    \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{64}\PYG{p}{]} \PYG{n}{\PYGZus{}\PYGZus{}attribute\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{(}\PYG{n}{aligned}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

The struct canfd\_frame and the existing struct can\_frame have the can\_id,
the payload length and the payload data at the same offset inside their
structures. This allows to handle the different structures very similar.
When the content of a struct can\_frame is copied into a struct canfd\_frame
all structure elements can be used as-is - only the data{[}{]} becomes extended.

When introducing the struct canfd\_frame it turned out that the data length
code (DLC) of the struct can\_frame was used as a length information as the
length and the DLC has a 1:1 mapping in the range of 0 .. 8. To preserve
the easy handling of the length information the canfd\_frame.len element
contains a plain length value from 0 .. 64. So both canfd\_frame.len and
can\_frame.can\_dlc are equal and contain a length information and no DLC.
For details about the distinction of CAN and CAN FD capable devices and
the mapping to the bus-relevant data length code (DLC), see {\hyperref[networking/can:socketcan\string-can\string-fd\string-driver]{\emph{CAN FD (Flexible Data Rate) Driver Support}}}.

The length of the two CAN(FD) frame structures define the maximum transfer
unit (MTU) of the CAN(FD) network interface and skbuff data length. Two
definitions are specified for CAN specific MTUs in include/linux/can.h:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define CAN\PYGZus{}MTU   (sizeof(struct can\PYGZus{}frame))   == 16  =\PYGZgt{} \PYGZsq{}legacy\PYGZsq{} CAN frame}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define CANFD\PYGZus{}MTU (sizeof(struct canfd\PYGZus{}frame)) == 72  =\PYGZgt{} CAN FD frame}
\end{Verbatim}


\subsection{RAW Protocol Sockets with can\_filters (SOCK\_RAW)}
\label{networking/can:socketcan-raw-sockets}\label{networking/can:raw-protocol-sockets-with-can-filters-sock-raw}
Using CAN\_RAW sockets is extensively comparable to the commonly
known access to CAN character devices. To meet the new possibilities
provided by the multi user SocketCAN approach, some reasonable
defaults are set at RAW socket binding time:
\begin{itemize}
\item {} 
The filters are set to exactly one filter receiving everything

\item {} 
The socket only receives valid data frames (=\textgreater{} no error message frames)

\item {} 
The loopback of sent CAN frames is enabled (see {\hyperref[networking/can:socketcan\string-local\string-loopback2]{\emph{Local Loopback of Sent Frames}}})

\item {} 
The socket does not receive its own sent frames (in loopback mode)

\end{itemize}

These default settings may be changed before or after binding the socket.
To use the referenced definitions of the socket options for CAN\_RAW
sockets, include \textless{}linux/can/raw.h\textgreater{}.


\subsubsection{RAW socket option CAN\_RAW\_FILTER}
\label{networking/can:raw-socket-option-can-raw-filter}\label{networking/can:socketcan-rawfilter}
The reception of CAN frames using CAN\_RAW sockets can be controlled
by defining 0 .. n filters with the CAN\_RAW\_FILTER socket option.

The CAN filter structure is defined in include/linux/can.h:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{can\PYGZus{}filter} \PYG{p}{\PYGZob{}}
        \PYG{n}{canid\PYGZus{}t} \PYG{n}{can\PYGZus{}id}\PYG{p}{;}
        \PYG{n}{canid\PYGZus{}t} \PYG{n}{can\PYGZus{}mask}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

A filter matches, when:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{received\PYGZus{}can\PYGZus{}id}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}} \PYG{n}{mask} \PYG{o}{=}\PYG{o}{=} \PYG{n}{can\PYGZus{}id} \PYG{o}{\PYGZam{}} \PYG{n}{mask}
\end{Verbatim}

which is analogous to known CAN controllers hardware filter semantics.
The filter can be inverted in this semantic, when the CAN\_INV\_FILTER
bit is set in can\_id element of the can\_filter structure. In
contrast to CAN controller hardware filters the user may set 0 .. n
receive filters for each open socket separately:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{can\PYGZus{}filter} \PYG{n}{rfilter}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}

\PYG{n}{rfilter}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{can\PYGZus{}id}   \PYG{o}{=} \PYG{l+m+mh}{0x123}\PYG{p}{;}
\PYG{n}{rfilter}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{can\PYGZus{}mask} \PYG{o}{=} \PYG{n}{CAN\PYGZus{}SFF\PYGZus{}MASK}\PYG{p}{;}
\PYG{n}{rfilter}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{.}\PYG{n}{can\PYGZus{}id}   \PYG{o}{=} \PYG{l+m+mh}{0x200}\PYG{p}{;}
\PYG{n}{rfilter}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{.}\PYG{n}{can\PYGZus{}mask} \PYG{o}{=} \PYG{l+m+mh}{0x700}\PYG{p}{;}

\PYG{n}{setsockopt}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{SOL\PYGZus{}CAN\PYGZus{}RAW}\PYG{p}{,} \PYG{n}{CAN\PYGZus{}RAW\PYGZus{}FILTER}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{rfilter}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{rfilter}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

To disable the reception of CAN frames on the selected CAN\_RAW socket:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{setsockopt}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{SOL\PYGZus{}CAN\PYGZus{}RAW}\PYG{p}{,} \PYG{n}{CAN\PYGZus{}RAW\PYGZus{}FILTER}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

To set the filters to zero filters is quite obsolete as to not read
data causes the raw socket to discard the received CAN frames. But
having this `send only' use-case we may remove the receive list in the
Kernel to save a little (really a very little!) CPU usage.


\paragraph{CAN Filter Usage Optimisation}
\label{networking/can:can-filter-usage-optimisation}
The CAN filters are processed in per-device filter lists at CAN frame
reception time. To reduce the number of checks that need to be performed
while walking through the filter lists the CAN core provides an optimized
filter handling when the filter subscription focusses on a single CAN ID.

For the possible 2048 SFF CAN identifiers the identifier is used as an index
to access the corresponding subscription list without any further checks.
For the 2\textasciicircum{}29 possible EFF CAN identifiers a 10 bit XOR folding is used as
hash function to retrieve the EFF table index.

To benefit from the optimized filters for single CAN identifiers the
CAN\_SFF\_MASK or CAN\_EFF\_MASK have to be set into can\_filter.mask together
with set CAN\_EFF\_FLAG and CAN\_RTR\_FLAG bits. A set CAN\_EFF\_FLAG bit in the
can\_filter.mask makes clear that it matters whether a SFF or EFF CAN ID is
subscribed. E.g. in the example from above:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{rfilter}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{can\PYGZus{}id}   \PYG{o}{=} \PYG{l+m+mh}{0x123}\PYG{p}{;}
\PYG{n}{rfilter}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{can\PYGZus{}mask} \PYG{o}{=} \PYG{n}{CAN\PYGZus{}SFF\PYGZus{}MASK}\PYG{p}{;}
\end{Verbatim}

both SFF frames with CAN ID 0x123 and EFF frames with 0xXXXXX123 can pass.

To filter for only 0x123 (SFF) and 0x12345678 (EFF) CAN identifiers the
filter has to be defined in this way to benefit from the optimized filters:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{can\PYGZus{}filter} \PYG{n}{rfilter}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}

\PYG{n}{rfilter}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{can\PYGZus{}id}   \PYG{o}{=} \PYG{l+m+mh}{0x123}\PYG{p}{;}
\PYG{n}{rfilter}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{can\PYGZus{}mask} \PYG{o}{=} \PYG{p}{(}\PYG{n}{CAN\PYGZus{}EFF\PYGZus{}FLAG} \PYG{o}{\textbar{}} \PYG{n}{CAN\PYGZus{}RTR\PYGZus{}FLAG} \PYG{o}{\textbar{}} \PYG{n}{CAN\PYGZus{}SFF\PYGZus{}MASK}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{rfilter}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{.}\PYG{n}{can\PYGZus{}id}   \PYG{o}{=} \PYG{l+m+mh}{0x12345678} \PYG{o}{\textbar{}} \PYG{n}{CAN\PYGZus{}EFF\PYGZus{}FLAG}\PYG{p}{;}
\PYG{n}{rfilter}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{.}\PYG{n}{can\PYGZus{}mask} \PYG{o}{=} \PYG{p}{(}\PYG{n}{CAN\PYGZus{}EFF\PYGZus{}FLAG} \PYG{o}{\textbar{}} \PYG{n}{CAN\PYGZus{}RTR\PYGZus{}FLAG} \PYG{o}{\textbar{}} \PYG{n}{CAN\PYGZus{}EFF\PYGZus{}MASK}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{setsockopt}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{SOL\PYGZus{}CAN\PYGZus{}RAW}\PYG{p}{,} \PYG{n}{CAN\PYGZus{}RAW\PYGZus{}FILTER}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{rfilter}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{rfilter}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}


\subsubsection{RAW Socket Option CAN\_RAW\_ERR\_FILTER}
\label{networking/can:raw-socket-option-can-raw-err-filter}
As described in {\hyperref[networking/can:socketcan\string-network\string-problem\string-notifications]{\emph{Network Problem Notifications}}} the CAN interface driver can generate so
called Error Message Frames that can optionally be passed to the user
application in the same way as other CAN frames. The possible
errors are divided into different error classes that may be filtered
using the appropriate error mask. To register for every possible
error condition CAN\_ERR\_MASK can be used as value for the error mask.
The values for the error mask are defined in linux/can/error.h:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{can\PYGZus{}err\PYGZus{}mask\PYGZus{}t} \PYG{n}{err\PYGZus{}mask} \PYG{o}{=} \PYG{p}{(} \PYG{n}{CAN\PYGZus{}ERR\PYGZus{}TX\PYGZus{}TIMEOUT} \PYG{o}{\textbar{}} \PYG{n}{CAN\PYGZus{}ERR\PYGZus{}BUSOFF} \PYG{p}{)}\PYG{p}{;}

\PYG{n}{setsockopt}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{SOL\PYGZus{}CAN\PYGZus{}RAW}\PYG{p}{,} \PYG{n}{CAN\PYGZus{}RAW\PYGZus{}ERR\PYGZus{}FILTER}\PYG{p}{,}
           \PYG{o}{\PYGZam{}}\PYG{n}{err\PYGZus{}mask}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{err\PYGZus{}mask}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}


\subsubsection{RAW Socket Option CAN\_RAW\_LOOPBACK}
\label{networking/can:raw-socket-option-can-raw-loopback}
To meet multi user needs the local loopback is enabled by default
(see {\hyperref[networking/can:socketcan\string-local\string-loopback1]{\emph{Local Loopback of Sent Frames}}} for details). But in some embedded use-cases
(e.g. when only one application uses the CAN bus) this loopback
functionality can be disabled (separately for each socket):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{loopback} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+cm}{/* 0 = disabled, 1 = enabled (default) */}

\PYG{n}{setsockopt}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{SOL\PYGZus{}CAN\PYGZus{}RAW}\PYG{p}{,} \PYG{n}{CAN\PYGZus{}RAW\PYGZus{}LOOPBACK}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{loopback}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{loopback}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}


\subsubsection{RAW socket option CAN\_RAW\_RECV\_OWN\_MSGS}
\label{networking/can:raw-socket-option-can-raw-recv-own-msgs}
When the local loopback is enabled, all the sent CAN frames are
looped back to the open CAN sockets that registered for the CAN
frames' CAN-ID on this given interface to meet the multi user
needs. The reception of the CAN frames on the same socket that was
sending the CAN frame is assumed to be unwanted and therefore
disabled by default. This default behaviour may be changed on
demand:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{recv\PYGZus{}own\PYGZus{}msgs} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+cm}{/* 0 = disabled (default), 1 = enabled */}

\PYG{n}{setsockopt}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{SOL\PYGZus{}CAN\PYGZus{}RAW}\PYG{p}{,} \PYG{n}{CAN\PYGZus{}RAW\PYGZus{}RECV\PYGZus{}OWN\PYGZus{}MSGS}\PYG{p}{,}
           \PYG{o}{\PYGZam{}}\PYG{n}{recv\PYGZus{}own\PYGZus{}msgs}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{recv\PYGZus{}own\PYGZus{}msgs}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}


\subsubsection{RAW Socket Option CAN\_RAW\_FD\_FRAMES}
\label{networking/can:raw-socket-option-can-raw-fd-frames}\label{networking/can:socketcan-rawfd}
CAN FD support in CAN\_RAW sockets can be enabled with a new socket option
CAN\_RAW\_FD\_FRAMES which is off by default. When the new socket option is
not supported by the CAN\_RAW socket (e.g. on older kernels), switching the
CAN\_RAW\_FD\_FRAMES option returns the error -ENOPROTOOPT.

Once CAN\_RAW\_FD\_FRAMES is enabled the application can send both CAN frames
and CAN FD frames. OTOH the application has to handle CAN and CAN FD frames
when reading from the socket:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{CAN\PYGZus{}RAW\PYGZus{}FD\PYGZus{}FRAMES} \PYG{n+nl}{enabled}\PYG{p}{:}  \PYG{n}{CAN\PYGZus{}MTU} \PYG{n}{and} \PYG{n}{CANFD\PYGZus{}MTU} \PYG{n}{are} \PYG{n}{allowed}
\PYG{n}{CAN\PYGZus{}RAW\PYGZus{}FD\PYGZus{}FRAMES} \PYG{n+nl}{disabled}\PYG{p}{:} \PYG{n}{only} \PYG{n}{CAN\PYGZus{}MTU} \PYG{n}{is} \PYG{n}{allowed} \PYG{p}{(}\PYG{k}{default}\PYG{p}{)}
\end{Verbatim}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[} \PYG{n+nl}{remember}\PYG{p}{:} \PYG{n}{CANFD\PYGZus{}MTU} \PYG{o}{=}\PYG{o}{=} \PYG{k}{sizeof}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{canfd\PYGZus{}frame}\PYG{p}{)} \PYG{p}{]}

\PYG{k}{struct} \PYG{n}{canfd\PYGZus{}frame} \PYG{n}{cfd}\PYG{p}{;}

\PYG{n}{nbytes} \PYG{o}{=} \PYG{n}{read}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{cfd}\PYG{p}{,} \PYG{n}{CANFD\PYGZus{}MTU}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{nbytes} \PYG{o}{=}\PYG{o}{=} \PYG{n}{CANFD\PYGZus{}MTU}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{got CAN FD frame with length \PYGZpc{}d}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{cfd}\PYG{p}{.}\PYG{n}{len}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+cm}{/* cfd.flags contains valid data */}
\PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{nbytes} \PYG{o}{=}\PYG{o}{=} \PYG{n}{CAN\PYGZus{}MTU}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{got legacy CAN frame with length \PYGZpc{}d}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{cfd}\PYG{p}{.}\PYG{n}{len}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+cm}{/* cfd.flags is undefined */}
\PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
        \PYG{n}{fprintf}\PYG{p}{(}\PYG{n}{stderr}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{read: invalid CAN(FD) frame}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/* the content can be handled independently from the received MTU size */}

\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{can\PYGZus{}id: \PYGZpc{}X data length: \PYGZpc{}d data: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{cfd}\PYG{p}{.}\PYG{n}{can\PYGZus{}id}\PYG{p}{,} \PYG{n}{cfd}\PYG{p}{.}\PYG{n}{len}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{cfd}\PYG{p}{.}\PYG{n}{len}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}02X }\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{cfd}\PYG{p}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

When reading with size CANFD\_MTU only returns CAN\_MTU bytes that have
been received from the socket a legacy CAN frame has been read into the
provided CAN FD structure. Note that the canfd\_frame.flags data field is
not specified in the struct can\_frame and therefore it is only valid in
CANFD\_MTU sized CAN FD frames.

Implementation hint for new CAN applications:

To build a CAN FD aware application use struct canfd\_frame as basic CAN
data structure for CAN\_RAW based applications. When the application is
executed on an older Linux kernel and switching the CAN\_RAW\_FD\_FRAMES
socket option returns an error: No problem. You'll get legacy CAN frames
or CAN FD frames and can process them the same way.

When sending to CAN devices make sure that the device is capable to handle
CAN FD frames by checking if the device maximum transfer unit is CANFD\_MTU.
The CAN device MTU can be retrieved e.g. with a SIOCGIFMTU ioctl() syscall.


\subsubsection{RAW socket option CAN\_RAW\_JOIN\_FILTERS}
\label{networking/can:raw-socket-option-can-raw-join-filters}
The CAN\_RAW socket can set multiple CAN identifier specific filters that
lead to multiple filters in the af\_can.c filter processing. These filters
are indenpendent from each other which leads to logical OR'ed filters when
applied (see {\hyperref[networking/can:socketcan\string-rawfilter]{\emph{RAW socket option CAN\_RAW\_FILTER}}}).

This socket option joines the given CAN filters in the way that only CAN
frames are passed to user space that matched \emph{all} given CAN filters. The
semantic for the applied filters is therefore changed to a logical AND.

This is useful especially when the filterset is a combination of filters
where the CAN\_INV\_FILTER flag is set in order to notch single CAN IDs or
CAN ID ranges from the incoming traffic.


\subsubsection{RAW Socket Returned Message Flags}
\label{networking/can:raw-socket-returned-message-flags}
When using recvmsg() call, the msg-\textgreater{}msg\_flags may contain following flags:
\begin{description}
\item[{MSG\_DONTROUTE:}] \leavevmode
set when the received frame was created on the local host.

\item[{MSG\_CONFIRM:}] \leavevmode
set when the frame was sent via the socket it is received on.
This flag can be interpreted as a `transmission confirmation' when the
CAN driver supports the echo of frames on driver level, see
{\hyperref[networking/can:socketcan\string-local\string-loopback1]{\emph{Local Loopback of Sent Frames}}} and {\hyperref[networking/can:socketcan\string-local\string-loopback2]{\emph{Local Loopback of Sent Frames}}}.
In order to receive such messages, CAN\_RAW\_RECV\_OWN\_MSGS must be set.

\end{description}


\subsection{Broadcast Manager Protocol Sockets (SOCK\_DGRAM)}
\label{networking/can:broadcast-manager-protocol-sockets-sock-dgram}
The Broadcast Manager protocol provides a command based configuration
interface to filter and send (e.g. cyclic) CAN messages in kernel space.

Receive filters can be used to down sample frequent messages; detect events
such as message contents changes, packet length changes, and do time-out
monitoring of received messages.

Periodic transmission tasks of CAN frames or a sequence of CAN frames can be
created and modified at runtime; both the message content and the two
possible transmit intervals can be altered.

A BCM socket is not intended for sending individual CAN frames using the
struct can\_frame as known from the CAN\_RAW socket. Instead a special BCM
configuration message is defined. The basic BCM configuration message used
to communicate with the broadcast manager and the available operations are
defined in the linux/can/bcm.h include. The BCM message consists of a
message header with a command (`opcode') followed by zero or more CAN frames.
The broadcast manager sends responses to user space in the same form:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{bcm\PYGZus{}msg\PYGZus{}head} \PYG{p}{\PYGZob{}}
        \PYG{n}{\PYGZus{}\PYGZus{}u32} \PYG{n}{opcode}\PYG{p}{;}                   \PYG{c+cm}{/* command */}
        \PYG{n}{\PYGZus{}\PYGZus{}u32} \PYG{n}{flags}\PYG{p}{;}                    \PYG{c+cm}{/* special flags */}
        \PYG{n}{\PYGZus{}\PYGZus{}u32} \PYG{n}{count}\PYG{p}{;}                    \PYG{c+cm}{/* run \PYGZsq{}count\PYGZsq{} times with ival1 */}
        \PYG{k}{struct} \PYG{n}{timeval} \PYG{n}{ival1}\PYG{p}{,} \PYG{n}{ival2}\PYG{p}{;}    \PYG{c+cm}{/* count and subsequent interval */}
        \PYG{n}{canid\PYGZus{}t} \PYG{n}{can\PYGZus{}id}\PYG{p}{;}                 \PYG{c+cm}{/* unique can\PYGZus{}id for task */}
        \PYG{n}{\PYGZus{}\PYGZus{}u32} \PYG{n}{nframes}\PYG{p}{;}                  \PYG{c+cm}{/* number of can\PYGZus{}frames following */}
        \PYG{k}{struct} \PYG{n}{can\PYGZus{}frame} \PYG{n}{frames}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

The aligned payload `frames' uses the same basic CAN frame structure defined
at the beginning of {\hyperref[networking/can:socketcan\string-rawfd]{\emph{RAW Socket Option CAN\_RAW\_FD\_FRAMES}}} and in the include/linux/can.h include. All
messages to the broadcast manager from user space have this structure.

Note a CAN\_BCM socket must be connected instead of bound after socket
creation (example without error checking):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{s}\PYG{p}{;}
\PYG{k}{struct} \PYG{n}{sockaddr\PYGZus{}can} \PYG{n}{addr}\PYG{p}{;}
\PYG{k}{struct} \PYG{n}{ifreq} \PYG{n}{ifr}\PYG{p}{;}

\PYG{n}{s} \PYG{o}{=} \PYG{n}{socket}\PYG{p}{(}\PYG{n}{PF\PYGZus{}CAN}\PYG{p}{,} \PYG{n}{SOCK\PYGZus{}DGRAM}\PYG{p}{,} \PYG{n}{CAN\PYGZus{}BCM}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{ifr}\PYG{p}{.}\PYG{n}{ifr\PYGZus{}name}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{can0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{SIOCGIFINDEX}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{ifr}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{addr}\PYG{p}{.}\PYG{n}{can\PYGZus{}family} \PYG{o}{=} \PYG{n}{AF\PYGZus{}CAN}\PYG{p}{;}
\PYG{n}{addr}\PYG{p}{.}\PYG{n}{can\PYGZus{}ifindex} \PYG{o}{=} \PYG{n}{ifr}\PYG{p}{.}\PYG{n}{ifr\PYGZus{}ifindex}\PYG{p}{;}

\PYG{n}{connect}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{p}{(}\PYG{k}{struct} \PYG{n}{sockaddr} \PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{addr}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{addr}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\end{Verbatim}

The broadcast manager socket is able to handle any number of in flight
transmissions or receive filters concurrently. The different RX/TX jobs are
distinguished by the unique can\_id in each BCM message. However additional
CAN\_BCM sockets are recommended to communicate on multiple CAN interfaces.
When the broadcast manager socket is bound to `any' CAN interface (=\textgreater{} the
interface index is set to zero) the configured receive filters apply to any
CAN interface unless the sendto() syscall is used to overrule the `any' CAN
interface index. When using recvfrom() instead of read() to retrieve BCM
socket messages the originating CAN interface is provided in can\_ifindex.


\subsubsection{Broadcast Manager Operations}
\label{networking/can:broadcast-manager-operations}
The opcode defines the operation for the broadcast manager to carry out,
or details the broadcast managers response to several events, including
user requests.

Transmit Operations (user space to broadcast manager):
\begin{description}
\item[{TX\_SETUP:}] \leavevmode
Create (cyclic) transmission task.

\item[{TX\_DELETE:}] \leavevmode
Remove (cyclic) transmission task, requires only can\_id.

\item[{TX\_READ:}] \leavevmode
Read properties of (cyclic) transmission task for can\_id.

\item[{TX\_SEND:}] \leavevmode
Send one CAN frame.

\end{description}

Transmit Responses (broadcast manager to user space):
\begin{description}
\item[{TX\_STATUS:}] \leavevmode
Reply to TX\_READ request (transmission task configuration).

\item[{TX\_EXPIRED:}] \leavevmode
Notification when counter finishes sending at initial interval
`ival1'. Requires the TX\_COUNTEVT flag to be set at TX\_SETUP.

\end{description}

Receive Operations (user space to broadcast manager):
\begin{description}
\item[{RX\_SETUP:}] \leavevmode
Create RX content filter subscription.

\item[{RX\_DELETE:}] \leavevmode
Remove RX content filter subscription, requires only can\_id.

\item[{RX\_READ:}] \leavevmode
Read properties of RX content filter subscription for can\_id.

\end{description}

Receive Responses (broadcast manager to user space):
\begin{description}
\item[{RX\_STATUS:}] \leavevmode
Reply to RX\_READ request (filter task configuration).

\item[{RX\_TIMEOUT:}] \leavevmode
Cyclic message is detected to be absent (timer ival1 expired).

\item[{RX\_CHANGED:}] \leavevmode
BCM message with updated CAN frame (detected content change).
Sent on first message received or on receipt of revised CAN messages.

\end{description}


\subsubsection{Broadcast Manager Message Flags}
\label{networking/can:broadcast-manager-message-flags}
When sending a message to the broadcast manager the `flags' element may
contain the following flag definitions which influence the behaviour:
\begin{description}
\item[{SETTIMER:}] \leavevmode
Set the values of ival1, ival2 and count

\item[{STARTTIMER:}] \leavevmode
Start the timer with the actual values of ival1, ival2
and count. Starting the timer leads simultaneously to emit a CAN frame.

\item[{TX\_COUNTEVT:}] \leavevmode
Create the message TX\_EXPIRED when count expires

\item[{TX\_ANNOUNCE:}] \leavevmode
A change of data by the process is emitted immediately.

\item[{TX\_CP\_CAN\_ID:}] \leavevmode
Copies the can\_id from the message header to each
subsequent frame in frames. This is intended as usage simplification. For
TX tasks the unique can\_id from the message header may differ from the
can\_id(s) stored for transmission in the subsequent struct can\_frame(s).

\item[{RX\_FILTER\_ID:}] \leavevmode
Filter by can\_id alone, no frames required (nframes=0).

\item[{RX\_CHECK\_DLC:}] \leavevmode
A change of the DLC leads to an RX\_CHANGED.

\item[{RX\_NO\_AUTOTIMER:}] \leavevmode
Prevent automatically starting the timeout monitor.

\item[{RX\_ANNOUNCE\_RESUME:}] \leavevmode
If passed at RX\_SETUP and a receive timeout occurred, a
RX\_CHANGED message will be generated when the (cyclic) receive restarts.

\item[{TX\_RESET\_MULTI\_IDX:}] \leavevmode
Reset the index for the multiple frame transmission.

\item[{RX\_RTR\_FRAME:}] \leavevmode
Send reply for RTR-request (placed in op-\textgreater{}frames{[}0{]}).

\end{description}


\subsubsection{Broadcast Manager Transmission Timers}
\label{networking/can:broadcast-manager-transmission-timers}
Periodic transmission configurations may use up to two interval timers.
In this case the BCM sends a number of messages (`count') at an interval
`ival1', then continuing to send at another given interval `ival2'. When
only one timer is needed `count' is set to zero and only `ival2' is used.
When SET\_TIMER and START\_TIMER flag were set the timers are activated.
The timer values can be altered at runtime when only SET\_TIMER is set.


\subsubsection{Broadcast Manager message sequence transmission}
\label{networking/can:broadcast-manager-message-sequence-transmission}
Up to 256 CAN frames can be transmitted in a sequence in the case of a cyclic
TX task configuration. The number of CAN frames is provided in the `nframes'
element of the BCM message head. The defined number of CAN frames are added
as array to the TX\_SETUP BCM configuration message:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* create a struct to set up a sequence of four CAN frames */}
\PYG{k}{struct} \PYG{p}{\PYGZob{}}
        \PYG{k}{struct} \PYG{n}{bcm\PYGZus{}msg\PYGZus{}head} \PYG{n}{msg\PYGZus{}head}\PYG{p}{;}
        \PYG{k}{struct} \PYG{n}{can\PYGZus{}frame} \PYG{n}{frame}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{n}{mytxmsg}\PYG{p}{;}

\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\PYG{n}{mytxmsg}\PYG{p}{.}\PYG{n}{msg\PYGZus{}head}\PYG{p}{.}\PYG{n}{nframes} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}

\PYG{n}{write}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{mytxmsg}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{mytxmsg}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

With every transmission the index in the array of CAN frames is increased
and set to zero at index overflow.


\subsubsection{Broadcast Manager Receive Filter Timers}
\label{networking/can:broadcast-manager-receive-filter-timers}
The timer values ival1 or ival2 may be set to non-zero values at RX\_SETUP.
When the SET\_TIMER flag is set the timers are enabled:
\begin{description}
\item[{ival1:}] \leavevmode
Send RX\_TIMEOUT when a received message is not received again within
the given time. When START\_TIMER is set at RX\_SETUP the timeout detection
is activated directly - even without a former CAN frame reception.

\item[{ival2:}] \leavevmode
Throttle the received message rate down to the value of ival2. This
is useful to reduce messages for the application when the signal inside the
CAN frame is stateless as state changes within the ival2 periode may get
lost.

\end{description}


\subsubsection{Broadcast Manager Multiplex Message Receive Filter}
\label{networking/can:broadcast-manager-multiplex-message-receive-filter}
To filter for content changes in multiplex message sequences an array of more
than one CAN frames can be passed in a RX\_SETUP configuration message. The
data bytes of the first CAN frame contain the mask of relevant bits that
have to match in the subsequent CAN frames with the received CAN frame.
If one of the subsequent CAN frames is matching the bits in that frame data
mark the relevant content to be compared with the previous received content.
Up to 257 CAN frames (multiplex filter bit mask CAN frame plus 256 CAN
filters) can be added as array to the TX\_SETUP BCM configuration message:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* usually used to clear CAN frame data[] \PYGZhy{} beware of endian problems! */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define U64\PYGZus{}DATA(p) (*(unsigned long long*)(p)\PYGZhy{}\PYGZgt{}data)}

\PYG{k}{struct} \PYG{p}{\PYGZob{}}
        \PYG{k}{struct} \PYG{n}{bcm\PYGZus{}msg\PYGZus{}head} \PYG{n}{msg\PYGZus{}head}\PYG{p}{;}
        \PYG{k}{struct} \PYG{n}{can\PYGZus{}frame} \PYG{n}{frame}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{n}{msg}\PYG{p}{;}

\PYG{n}{msg}\PYG{p}{.}\PYG{n}{msg\PYGZus{}head}\PYG{p}{.}\PYG{n}{opcode}  \PYG{o}{=} \PYG{n}{RX\PYGZus{}SETUP}\PYG{p}{;}
\PYG{n}{msg}\PYG{p}{.}\PYG{n}{msg\PYGZus{}head}\PYG{p}{.}\PYG{n}{can\PYGZus{}id}  \PYG{o}{=} \PYG{l+m+mh}{0x42}\PYG{p}{;}
\PYG{n}{msg}\PYG{p}{.}\PYG{n}{msg\PYGZus{}head}\PYG{p}{.}\PYG{n}{flags}   \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{msg}\PYG{p}{.}\PYG{n}{msg\PYGZus{}head}\PYG{p}{.}\PYG{n}{nframes} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{n}{U64\PYGZus{}DATA}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{msg}\PYG{p}{.}\PYG{n}{frame}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mh}{0xFF00000000000000ULL}\PYG{p}{;} \PYG{c+cm}{/* MUX mask */}
\PYG{n}{U64\PYGZus{}DATA}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{msg}\PYG{p}{.}\PYG{n}{frame}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mh}{0x01000000000000FFULL}\PYG{p}{;} \PYG{c+cm}{/* data mask (MUX 0x01) */}
\PYG{n}{U64\PYGZus{}DATA}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{msg}\PYG{p}{.}\PYG{n}{frame}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mh}{0x0200FFFF000000FFULL}\PYG{p}{;} \PYG{c+cm}{/* data mask (MUX 0x02) */}
\PYG{n}{U64\PYGZus{}DATA}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{msg}\PYG{p}{.}\PYG{n}{frame}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mh}{0x330000FFFFFF0003ULL}\PYG{p}{;} \PYG{c+cm}{/* data mask (MUX 0x33) */}
\PYG{n}{U64\PYGZus{}DATA}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{msg}\PYG{p}{.}\PYG{n}{frame}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mh}{0x4F07FC0FF0000000ULL}\PYG{p}{;} \PYG{c+cm}{/* data mask (MUX 0x4F) */}

\PYG{n}{write}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{msg}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}


\subsubsection{Broadcast Manager CAN FD Support}
\label{networking/can:broadcast-manager-can-fd-support}
The programming API of the CAN\_BCM depends on struct can\_frame which is
given as array directly behind the bcm\_msg\_head structure. To follow this
schema for the CAN FD frames a new flag `CAN\_FD\_FRAME' in the bcm\_msg\_head
flags indicates that the concatenated CAN frame structures behind the
bcm\_msg\_head are defined as struct canfd\_frame:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{p}{\PYGZob{}}
        \PYG{k}{struct} \PYG{n}{bcm\PYGZus{}msg\PYGZus{}head} \PYG{n}{msg\PYGZus{}head}\PYG{p}{;}
        \PYG{k}{struct} \PYG{n}{canfd\PYGZus{}frame} \PYG{n}{frame}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{n}{msg}\PYG{p}{;}

\PYG{n}{msg}\PYG{p}{.}\PYG{n}{msg\PYGZus{}head}\PYG{p}{.}\PYG{n}{opcode}  \PYG{o}{=} \PYG{n}{RX\PYGZus{}SETUP}\PYG{p}{;}
\PYG{n}{msg}\PYG{p}{.}\PYG{n}{msg\PYGZus{}head}\PYG{p}{.}\PYG{n}{can\PYGZus{}id}  \PYG{o}{=} \PYG{l+m+mh}{0x42}\PYG{p}{;}
\PYG{n}{msg}\PYG{p}{.}\PYG{n}{msg\PYGZus{}head}\PYG{p}{.}\PYG{n}{flags}   \PYG{o}{=} \PYG{n}{CAN\PYGZus{}FD\PYGZus{}FRAME}\PYG{p}{;}
\PYG{n}{msg}\PYG{p}{.}\PYG{n}{msg\PYGZus{}head}\PYG{p}{.}\PYG{n}{nframes} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\end{Verbatim}

When using CAN FD frames for multiplex filtering the MUX mask is still
expected in the first 64 bit of the struct canfd\_frame data section.


\subsection{Connected Transport Protocols (SOCK\_SEQPACKET)}
\label{networking/can:connected-transport-protocols-sock-seqpacket}
(to be written)


\subsection{Unconnected Transport Protocols (SOCK\_DGRAM)}
\label{networking/can:unconnected-transport-protocols-sock-dgram}
(to be written)


\section{SocketCAN Core Module}
\label{networking/can:id4}\label{networking/can:socketcan-core-module}
The SocketCAN core module implements the protocol family
PF\_CAN. CAN protocol modules are loaded by the core module at
runtime. The core module provides an interface for CAN protocol
modules to subscribe needed CAN IDs (see {\hyperref[networking/can:socketcan\string-receive\string-lists]{\emph{Receive Lists}}}).


\subsection{can.ko Module Params}
\label{networking/can:can-ko-module-params}\begin{itemize}
\item {} 
\textbf{stats\_timer}:
To calculate the SocketCAN core statistics
(e.g. current/maximum frames per second) this 1 second timer is
invoked at can.ko module start time by default. This timer can be
disabled by using stattimer=0 on the module commandline.

\item {} 
\textbf{debug}:
(removed since SocketCAN SVN r546)

\end{itemize}


\subsection{procfs content}
\label{networking/can:procfs-content}
As described in {\hyperref[networking/can:socketcan\string-receive\string-lists]{\emph{Receive Lists}}} the SocketCAN core uses several filter
lists to deliver received CAN frames to CAN protocol modules. These
receive lists, their filters and the count of filter matches can be
checked in the appropriate receive list. All entries contain the
device and a protocol module identifier:

\begin{Verbatim}[commandchars=\\\{\}]
foo@bar:\PYGZti{}\PYGZdl{} cat /proc/net/can/rcvlist\PYGZus{}all

receive list \PYGZsq{}rx\PYGZus{}all\PYGZsq{}:
  (vcan3: no entry)
  (vcan2: no entry)
  (vcan1: no entry)
  device   can\PYGZus{}id   can\PYGZus{}mask  function  userdata   matches  ident
   vcan0     000    00000000  f88e6370  f6c6f400         0  raw
  (any: no entry)
\end{Verbatim}

In this example an application requests any CAN traffic from vcan0:

\begin{Verbatim}[commandchars=\\\{\}]
rcvlist\PYGZus{}all \PYGZhy{} list for unfiltered entries (no filter operations)
rcvlist\PYGZus{}eff \PYGZhy{} list for single extended frame (EFF) entries
rcvlist\PYGZus{}err \PYGZhy{} list for error message frames masks
rcvlist\PYGZus{}fil \PYGZhy{} list for mask/value filters
rcvlist\PYGZus{}inv \PYGZhy{} list for mask/value filters (inverse semantic)
rcvlist\PYGZus{}sff \PYGZhy{} list for single standard frame (SFF) entries
\end{Verbatim}

Additional procfs files in /proc/net/can:

\begin{Verbatim}[commandchars=\\\{\}]
stats       \PYGZhy{} SocketCAN core statistics (rx/tx frames, match ratios, ...)
reset\PYGZus{}stats \PYGZhy{} manual statistic reset
version     \PYGZhy{} prints the SocketCAN core version and the ABI version
\end{Verbatim}


\subsection{Writing Own CAN Protocol Modules}
\label{networking/can:writing-own-can-protocol-modules}
To implement a new protocol in the protocol family PF\_CAN a new
protocol has to be defined in include/linux/can.h .
The prototypes and definitions to use the SocketCAN core can be
accessed by including include/linux/can/core.h .
In addition to functions that register the CAN protocol and the
CAN device notifier chain there are functions to subscribe CAN
frames received by CAN interfaces and to send CAN frames:

\begin{Verbatim}[commandchars=\\\{\}]
can\PYGZus{}rx\PYGZus{}register   \PYGZhy{} subscribe CAN frames from a specific interface
can\PYGZus{}rx\PYGZus{}unregister \PYGZhy{} unsubscribe CAN frames from a specific interface
can\PYGZus{}send          \PYGZhy{} transmit a CAN frame (optional with local loopback)
\end{Verbatim}

For details see the kerneldoc documentation in net/can/af\_can.c or
the source code of net/can/raw.c or net/can/bcm.c .


\section{CAN Network Drivers}
\label{networking/can:can-network-drivers}
Writing a CAN network device driver is much easier than writing a
CAN character device driver. Similar to other known network device
drivers you mainly have to deal with:
\begin{itemize}
\item {} 
TX: Put the CAN frame from the socket buffer to the CAN controller.

\item {} 
RX: Put the CAN frame from the CAN controller to the socket buffer.

\end{itemize}

See e.g. at Documentation/networking/netdevices.txt . The differences
for writing CAN network device driver are described below:


\subsection{General Settings}
\label{networking/can:general-settings}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{dev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{type}  \PYG{o}{=} \PYG{n}{ARPHRD\PYGZus{}CAN}\PYG{p}{;} \PYG{c+cm}{/* the netdevice hardware type */}
\PYG{n}{dev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{flags} \PYG{o}{=} \PYG{n}{IFF\PYGZus{}NOARP}\PYG{p}{;}  \PYG{c+cm}{/* CAN has no arp */}

\PYG{n}{dev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mtu} \PYG{o}{=} \PYG{n}{CAN\PYGZus{}MTU}\PYG{p}{;} \PYG{c+cm}{/* sizeof(struct can\PYGZus{}frame) \PYGZhy{}\PYGZgt{} legacy CAN interface */}

\PYG{n}{or} \PYG{n}{alternative}\PYG{p}{,} \PYG{n}{when} \PYG{n}{the} \PYG{n}{controller} \PYG{n}{supports} \PYG{n}{CAN} \PYG{n}{with} \PYG{n}{flexible} \PYG{n}{data} \PYG{n+nl}{rate}\PYG{p}{:}
\PYG{n}{dev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{mtu} \PYG{o}{=} \PYG{n}{CANFD\PYGZus{}MTU}\PYG{p}{;} \PYG{c+cm}{/* sizeof(struct canfd\PYGZus{}frame) \PYGZhy{}\PYGZgt{} CAN FD interface */}
\end{Verbatim}

The struct can\_frame or struct canfd\_frame is the payload of each socket
buffer (skbuff) in the protocol family PF\_CAN.


\subsection{Local Loopback of Sent Frames}
\label{networking/can:id5}\label{networking/can:socketcan-local-loopback2}
As described in {\hyperref[networking/can:socketcan\string-local\string-loopback1]{\emph{Local Loopback of Sent Frames}}} the CAN network device driver should
support a local loopback functionality similar to the local echo
e.g. of tty devices. In this case the driver flag IFF\_ECHO has to be
set to prevent the PF\_CAN core from locally echoing sent frames
(aka loopback) as fallback solution:

\begin{Verbatim}[commandchars=\\\{\}]
dev\PYGZhy{}\PYGZgt{}flags = (IFF\PYGZus{}NOARP \textbar{} IFF\PYGZus{}ECHO);
\end{Verbatim}


\subsection{CAN Controller Hardware Filters}
\label{networking/can:can-controller-hardware-filters}
To reduce the interrupt load on deep embedded systems some CAN
controllers support the filtering of CAN IDs or ranges of CAN IDs.
These hardware filter capabilities vary from controller to
controller and have to be identified as not feasible in a multi-user
networking approach. The use of the very controller specific
hardware filters could make sense in a very dedicated use-case, as a
filter on driver level would affect all users in the multi-user
system. The high efficient filter sets inside the PF\_CAN core allow
to set different multiple filters for each socket separately.
Therefore the use of hardware filters goes to the category `handmade
tuning on deep embedded systems'. The author is running a MPC603e
@133MHz with four SJA1000 CAN controllers from 2002 under heavy bus
load without any problems ...


\subsection{The Virtual CAN Driver (vcan)}
\label{networking/can:the-virtual-can-driver-vcan}
Similar to the network loopback devices, vcan offers a virtual local
CAN interface. A full qualified address on CAN consists of
\begin{itemize}
\item {} 
a unique CAN Identifier (CAN ID)

\item {} 
the CAN bus this CAN ID is transmitted on (e.g. can0)

\end{itemize}

so in common use cases more than one virtual CAN interface is needed.

The virtual CAN interfaces allow the transmission and reception of CAN
frames without real CAN controller hardware. Virtual CAN network
devices are usually named `vcanX', like vcan0 vcan1 vcan2 ...
When compiled as a module the virtual CAN driver module is called vcan.ko

Since Linux Kernel version 2.6.24 the vcan driver supports the Kernel
netlink interface to create vcan network devices. The creation and
removal of vcan network devices can be managed with the ip(8) tool:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{} Create a virtual CAN network interface:
     \PYGZdl{} ip link add type vcan

\PYGZhy{} Create a virtual CAN network interface with a specific name \PYGZsq{}vcan42\PYGZsq{}:
     \PYGZdl{} ip link add dev vcan42 type vcan

\PYGZhy{} Remove a (virtual CAN) network interface \PYGZsq{}vcan42\PYGZsq{}:
     \PYGZdl{} ip link del vcan42
\end{Verbatim}


\subsection{The CAN Network Device Driver Interface}
\label{networking/can:the-can-network-device-driver-interface}
The CAN network device driver interface provides a generic interface
to setup, configure and monitor CAN network devices. The user can then
configure the CAN device, like setting the bit-timing parameters, via
the netlink interface using the program ``ip'' from the ``IPROUTE2''
utility suite. The following chapter describes briefly how to use it.
Furthermore, the interface uses a common data structure and exports a
set of common functions, which all real CAN network device drivers
should use. Please have a look to the SJA1000 or MSCAN driver to
understand how to use them. The name of the module is can-dev.ko.


\subsubsection{Netlink interface to set/get devices properties}
\label{networking/can:netlink-interface-to-set-get-devices-properties}
The CAN device must be configured via netlink interface. The supported
netlink message types are defined and briefly described in
``include/linux/can/netlink.h''. CAN link support for the program ``ip''
of the IPROUTE2 utility suite is available and it can be used as shown
below:

Setting CAN device properties:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ip link set can0 type can help
Usage: ip link set DEVICE type can
    [ bitrate BITRATE [ sample\PYGZhy{}point SAMPLE\PYGZhy{}POINT] ] \textbar{}
    [ tq TQ prop\PYGZhy{}seg PROP\PYGZus{}SEG phase\PYGZhy{}seg1 PHASE\PYGZhy{}SEG1
      phase\PYGZhy{}seg2 PHASE\PYGZhy{}SEG2 [ sjw SJW ] ]

    [ dbitrate BITRATE [ dsample\PYGZhy{}point SAMPLE\PYGZhy{}POINT] ] \textbar{}
    [ dtq TQ dprop\PYGZhy{}seg PROP\PYGZus{}SEG dphase\PYGZhy{}seg1 PHASE\PYGZhy{}SEG1
      dphase\PYGZhy{}seg2 PHASE\PYGZhy{}SEG2 [ dsjw SJW ] ]

    [ loopback \PYGZob{} on \textbar{} off \PYGZcb{} ]
    [ listen\PYGZhy{}only \PYGZob{} on \textbar{} off \PYGZcb{} ]
    [ triple\PYGZhy{}sampling \PYGZob{} on \textbar{} off \PYGZcb{} ]
    [ one\PYGZhy{}shot \PYGZob{} on \textbar{} off \PYGZcb{} ]
    [ berr\PYGZhy{}reporting \PYGZob{} on \textbar{} off \PYGZcb{} ]
    [ fd \PYGZob{} on \textbar{} off \PYGZcb{} ]
    [ fd\PYGZhy{}non\PYGZhy{}iso \PYGZob{} on \textbar{} off \PYGZcb{} ]
    [ presume\PYGZhy{}ack \PYGZob{} on \textbar{} off \PYGZcb{} ]

    [ restart\PYGZhy{}ms TIME\PYGZhy{}MS ]
    [ restart ]

    Where: BITRATE       := \PYGZob{} 1..1000000 \PYGZcb{}
           SAMPLE\PYGZhy{}POINT  := \PYGZob{} 0.000..0.999 \PYGZcb{}
           TQ            := \PYGZob{} NUMBER \PYGZcb{}
           PROP\PYGZhy{}SEG      := \PYGZob{} 1..8 \PYGZcb{}
           PHASE\PYGZhy{}SEG1    := \PYGZob{} 1..8 \PYGZcb{}
           PHASE\PYGZhy{}SEG2    := \PYGZob{} 1..8 \PYGZcb{}
           SJW           := \PYGZob{} 1..4 \PYGZcb{}
           RESTART\PYGZhy{}MS    := \PYGZob{} 0 \textbar{} NUMBER \PYGZcb{}
\end{Verbatim}

Display CAN device details and statistics:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ip \PYGZhy{}details \PYGZhy{}statistics link show can0
2: can0: \PYGZlt{}NOARP,UP,LOWER\PYGZus{}UP,ECHO\PYGZgt{} mtu 16 qdisc pfifo\PYGZus{}fast state UP qlen 10
  link/can
  can \PYGZlt{}TRIPLE\PYGZhy{}SAMPLING\PYGZgt{} state ERROR\PYGZhy{}ACTIVE restart\PYGZhy{}ms 100
  bitrate 125000 sample\PYGZus{}point 0.875
  tq 125 prop\PYGZhy{}seg 6 phase\PYGZhy{}seg1 7 phase\PYGZhy{}seg2 2 sjw 1
  sja1000: tseg1 1..16 tseg2 1..8 sjw 1..4 brp 1..64 brp\PYGZhy{}inc 1
  clock 8000000
  re\PYGZhy{}started bus\PYGZhy{}errors arbit\PYGZhy{}lost error\PYGZhy{}warn error\PYGZhy{}pass bus\PYGZhy{}off
  41         17457      0          41         42         41
  RX: bytes  packets  errors  dropped overrun mcast
  140859     17608    17457   0       0       0
  TX: bytes  packets  errors  dropped carrier collsns
  861        112      0       41      0       0
\end{Verbatim}

More info to the above output:
\begin{description}
\item[{``\textless{}TRIPLE-SAMPLING\textgreater{}''}] \leavevmode
Shows the list of selected CAN controller modes: LOOPBACK,
LISTEN-ONLY, or TRIPLE-SAMPLING.

\item[{``state ERROR-ACTIVE''}] \leavevmode
The current state of the CAN controller: ``ERROR-ACTIVE'',
``ERROR-WARNING'', ``ERROR-PASSIVE'', ``BUS-OFF'' or ``STOPPED''

\item[{``restart-ms 100''}] \leavevmode
Automatic restart delay time. If set to a non-zero value, a
restart of the CAN controller will be triggered automatically
in case of a bus-off condition after the specified delay time
in milliseconds. By default it's off.

\item[{``bitrate 125000 sample-point 0.875''}] \leavevmode
Shows the real bit-rate in bits/sec and the sample-point in the
range 0.000..0.999. If the calculation of bit-timing parameters
is enabled in the kernel (CONFIG\_CAN\_CALC\_BITTIMING=y), the
bit-timing can be defined by setting the ``bitrate'' argument.
Optionally the ``sample-point'' can be specified. By default it's
0.000 assuming CIA-recommended sample-points.

\item[{``tq 125 prop-seg 6 phase-seg1 7 phase-seg2 2 sjw 1''}] \leavevmode
Shows the time quanta in ns, propagation segment, phase buffer
segment 1 and 2 and the synchronisation jump width in units of
tq. They allow to define the CAN bit-timing in a hardware
independent format as proposed by the Bosch CAN 2.0 spec (see
chapter 8 of \href{http://www.semiconductors.bosch.de/pdf/can2spec.pdf}{http://www.semiconductors.bosch.de/pdf/can2spec.pdf}).

\item[{``sja1000: tseg1 1..16 tseg2 1..8 sjw 1..4 brp 1..64 brp-inc 1 clock 8000000''}] \leavevmode
Shows the bit-timing constants of the CAN controller, here the
``sja1000''. The minimum and maximum values of the time segment 1
and 2, the synchronisation jump width in units of tq, the
bitrate pre-scaler and the CAN system clock frequency in Hz.
These constants could be used for user-defined (non-standard)
bit-timing calculation algorithms in user-space.

\item[{``re-started bus-errors arbit-lost error-warn error-pass bus-off''}] \leavevmode
Shows the number of restarts, bus and arbitration lost errors,
and the state changes to the error-warning, error-passive and
bus-off state. RX overrun errors are listed in the ``overrun''
field of the standard network statistics.

\end{description}


\subsubsection{Setting the CAN Bit-Timing}
\label{networking/can:setting-the-can-bit-timing}
The CAN bit-timing parameters can always be defined in a hardware
independent format as proposed in the Bosch CAN 2.0 specification
specifying the arguments ``tq'', ``prop\_seg'', ``phase\_seg1'', ``phase\_seg2''
and ``sjw'':

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ip link set canX type can tq 125 prop\PYGZhy{}seg 6 \PYGZbs{}
                            phase\PYGZhy{}seg1 7 phase\PYGZhy{}seg2 2 sjw 1
\end{Verbatim}

If the kernel option CONFIG\_CAN\_CALC\_BITTIMING is enabled, CIA
recommended CAN bit-timing parameters will be calculated if the bit-
rate is specified with the argument ``bitrate'':

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ip link set canX type can bitrate 125000
\end{Verbatim}

Note that this works fine for the most common CAN controllers with
standard bit-rates but may \emph{fail} for exotic bit-rates or CAN system
clock frequencies. Disabling CONFIG\_CAN\_CALC\_BITTIMING saves some
space and allows user-space tools to solely determine and set the
bit-timing parameters. The CAN controller specific bit-timing
constants can be used for that purpose. They are listed by the
following command:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ip \PYGZhy{}details link show can0
...
  sja1000: clock 8000000 tseg1 1..16 tseg2 1..8 sjw 1..4 brp 1..64 brp\PYGZhy{}inc 1
\end{Verbatim}


\subsubsection{Starting and Stopping the CAN Network Device}
\label{networking/can:starting-and-stopping-the-can-network-device}
A CAN network device is started or stopped as usual with the command
``ifconfig canX up/down'' or ``ip link set canX up/down''. Be aware that
you \emph{must} define proper bit-timing parameters for real CAN devices
before you can start it to avoid error-prone default settings:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ip link set canX up type can bitrate 125000
\end{Verbatim}

A device may enter the ``bus-off'' state if too many errors occurred on
the CAN bus. Then no more messages are received or sent. An automatic
bus-off recovery can be enabled by setting the ``restart-ms'' to a
non-zero value, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ip link set canX type can restart\PYGZhy{}ms 100
\end{Verbatim}

Alternatively, the application may realize the ``bus-off'' condition
by monitoring CAN error message frames and do a restart when
appropriate with the command:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ip link set canX type can restart
\end{Verbatim}

Note that a restart will also create a CAN error message frame (see
also {\hyperref[networking/can:socketcan\string-network\string-problem\string-notifications]{\emph{Network Problem Notifications}}}).


\subsection{CAN FD (Flexible Data Rate) Driver Support}
\label{networking/can:can-fd-flexible-data-rate-driver-support}\label{networking/can:socketcan-can-fd-driver}
CAN FD capable CAN controllers support two different bitrates for the
arbitration phase and the payload phase of the CAN FD frame. Therefore a
second bit timing has to be specified in order to enable the CAN FD bitrate.

Additionally CAN FD capable CAN controllers support up to 64 bytes of
payload. The representation of this length in can\_frame.can\_dlc and
canfd\_frame.len for userspace applications and inside the Linux network
layer is a plain value from 0 .. 64 instead of the CAN `data length code'.
The data length code was a 1:1 mapping to the payload length in the legacy
CAN frames anyway. The payload length to the bus-relevant DLC mapping is
only performed inside the CAN drivers, preferably with the helper
functions can\_dlc2len() and can\_len2dlc().

The CAN netdevice driver capabilities can be distinguished by the network
devices maximum transfer unit (MTU):

\begin{Verbatim}[commandchars=\\\{\}]
MTU = 16 (CAN\PYGZus{}MTU)   =\PYGZgt{} sizeof(struct can\PYGZus{}frame)   =\PYGZgt{} \PYGZsq{}legacy\PYGZsq{} CAN device
MTU = 72 (CANFD\PYGZus{}MTU) =\PYGZgt{} sizeof(struct canfd\PYGZus{}frame) =\PYGZgt{} CAN FD capable device
\end{Verbatim}

The CAN device MTU can be retrieved e.g. with a SIOCGIFMTU ioctl() syscall.
N.B. CAN FD capable devices can also handle and send legacy CAN frames.

When configuring CAN FD capable CAN controllers an additional `data' bitrate
has to be set. This bitrate for the data phase of the CAN FD frame has to be
at least the bitrate which was configured for the arbitration phase. This
second bitrate is specified analogue to the first bitrate but the bitrate
setting keywords for the `data' bitrate start with `d' e.g. dbitrate,
dsample-point, dsjw or dtq and similar settings. When a data bitrate is set
within the configuration process the controller option ``fd on'' can be
specified to enable the CAN FD mode in the CAN controller. This controller
option also switches the device MTU to 72 (CANFD\_MTU).

The first CAN FD specification presented as whitepaper at the International
CAN Conference 2012 needed to be improved for data integrity reasons.
Therefore two CAN FD implementations have to be distinguished today:
\begin{itemize}
\item {} 
ISO compliant:     The ISO 11898-1:2015 CAN FD implementation (default)

\item {} 
non-ISO compliant: The CAN FD implementation following the 2012 whitepaper

\end{itemize}

Finally there are three types of CAN FD controllers:
\begin{enumerate}
\item {} 
ISO compliant (fixed)

\item {} 
non-ISO compliant (fixed, like the M\_CAN IP core v3.0.1 in m\_can.c)

\item {} 
ISO/non-ISO CAN FD controllers (switchable, like the PEAK PCAN-USB FD)

\end{enumerate}

The current ISO/non-ISO mode is announced by the CAN controller driver via
netlink and displayed by the `ip' tool (controller option FD-NON-ISO).
The ISO/non-ISO-mode can be altered by setting `fd-non-iso \{on\textbar{}off\}' for
switchable CAN FD controllers only.

Example configuring 500 kbit/s arbitration bitrate and 4 Mbit/s data bitrate:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ip link set can0 up type can bitrate 500000 sample\PYGZhy{}point 0.75 \PYGZbs{}
                               dbitrate 4000000 dsample\PYGZhy{}point 0.8 fd on
\PYGZdl{} ip \PYGZhy{}details link show can0
5: can0: \PYGZlt{}NOARP,UP,LOWER\PYGZus{}UP,ECHO\PYGZgt{} mtu 72 qdisc pfifo\PYGZus{}fast state UNKNOWN \PYGZbs{}
         mode DEFAULT group default qlen 10
link/can  promiscuity 0
can \PYGZlt{}FD\PYGZgt{} state ERROR\PYGZhy{}ACTIVE (berr\PYGZhy{}counter tx 0 rx 0) restart\PYGZhy{}ms 0
      bitrate 500000 sample\PYGZhy{}point 0.750
      tq 50 prop\PYGZhy{}seg 14 phase\PYGZhy{}seg1 15 phase\PYGZhy{}seg2 10 sjw 1
      pcan\PYGZus{}usb\PYGZus{}pro\PYGZus{}fd: tseg1 1..64 tseg2 1..16 sjw 1..16 brp 1..1024 \PYGZbs{}
      brp\PYGZhy{}inc 1
      dbitrate 4000000 dsample\PYGZhy{}point 0.800
      dtq 12 dprop\PYGZhy{}seg 7 dphase\PYGZhy{}seg1 8 dphase\PYGZhy{}seg2 4 dsjw 1
      pcan\PYGZus{}usb\PYGZus{}pro\PYGZus{}fd: dtseg1 1..16 dtseg2 1..8 dsjw 1..4 dbrp 1..1024 \PYGZbs{}
      dbrp\PYGZhy{}inc 1
      clock 80000000
\end{Verbatim}

Example when `fd-non-iso on' is added on this switchable CAN FD adapter:

\begin{Verbatim}[commandchars=\\\{\}]
can \PYGZlt{}FD,FD\PYGZhy{}NON\PYGZhy{}ISO\PYGZgt{} state ERROR\PYGZhy{}ACTIVE (berr\PYGZhy{}counter tx 0 rx 0) restart\PYGZhy{}ms 0
\end{Verbatim}


\subsection{Supported CAN Hardware}
\label{networking/can:supported-can-hardware}
Please check the ``Kconfig'' file in ``drivers/net/can'' to get an actual
list of the support CAN hardware. On the SocketCAN project website
(see {\hyperref[networking/can:socketcan\string-resources]{\emph{SocketCAN Resources}}}) there might be further drivers available, also for
older kernel versions.


\section{SocketCAN Resources}
\label{networking/can:socketcan-resources}\label{networking/can:id6}
The Linux CAN / SocketCAN project resources (project site / mailing list)
are referenced in the MAINTAINERS file in the Linux source tree.
Search for CAN NETWORK {[}LAYERS\textbar{}DRIVERS{]}.


\section{Credits}
\label{networking/can:credits}\begin{itemize}
\item {} 
Oliver Hartkopp (PF\_CAN core, filters, drivers, bcm, SJA1000 driver)

\item {} 
Urs Thuermann (PF\_CAN core, kernel integration, socket interfaces, raw, vcan)

\item {} 
Jan Kizka (RT-SocketCAN core, Socket-API reconciliation)

\item {} 
Wolfgang Grandegger (RT-SocketCAN core \& drivers, Raw Socket-API reviews, CAN device driver interface, MSCAN driver)

\item {} 
Robert Schwebel (design reviews, PTXdist integration)

\item {} 
Marc Kleine-Budde (design reviews, Kernel 2.6 cleanups, drivers)

\item {} 
Benedikt Spranger (reviews)

\item {} 
Thomas Gleixner (LKML reviews, coding style, posting hints)

\item {} 
Andrey Volkov (kernel subtree structure, ioctls, MSCAN driver)

\item {} 
Matthias Brukner (first SJA1000 CAN netdevice implementation Q2/2003)

\item {} 
Klaus Hitschler (PEAK driver integration)

\item {} 
Uwe Koppe (CAN netdevices with PF\_PACKET approach)

\item {} 
Michael Schulze (driver layer loopback requirement, RT CAN drivers review)

\item {} 
Pavel Pisa (Bit-timing calculation)

\item {} 
Sascha Hauer (SJA1000 platform driver)

\item {} 
Sebastian Haas (SJA1000 EMS PCI driver)

\item {} 
Markus Plessing (SJA1000 EMS PCI driver)

\item {} 
Per Dalen (SJA1000 Kvaser PCI driver)

\item {} 
Sam Ravnborg (reviews, coding style, kbuild help)

\end{itemize}


\chapter{Linux Networking and Network Devices APIs}
\label{networking/kapi:linux-networking-and-network-devices-apis}\label{networking/kapi::doc}

\section{Linux Networking}
\label{networking/kapi:linux-networking}

\subsection{Networking Base Types}
\label{networking/kapi:networking-base-types}\index{sock\_type (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sock_type}\pysigline{enum \bfcode{sock\_type}}
Socket types

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{SOCK\_STREAM}}] \leavevmode
stream (connection) socket

\item[{\code{SOCK\_DGRAM}}] \leavevmode
datagram (conn.less) socket

\item[{\code{SOCK\_RAW}}] \leavevmode
raw socket

\item[{\code{SOCK\_RDM}}] \leavevmode
reliably-delivered message

\item[{\code{SOCK\_SEQPACKET}}] \leavevmode
sequential packet socket

\item[{\code{SOCK\_DCCP}}] \leavevmode
Datagram Congestion Control Protocol socket

\item[{\code{SOCK\_PACKET}}] \leavevmode
linux specific way of getting packets at the dev level.
For writing rarp and other similar things on the user level.

\end{description}

\textbf{Description}

When adding some new socket type please
grep ARCH\_HAS\_SOCKET\_TYPE include/asm-* /socket.h, at least MIPS
overrides this enum for binary compat reasons.
\index{socket (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.socket}\pysigline{struct \bfcode{socket}}
general BSD socket

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct socket \PYGZob{}
  socket\PYGZus{}state state;
  short type;
  unsigned long           flags;
  struct socket\PYGZus{}wq \PYGZus{}\PYGZus{}rcu  *wq;
  struct file             *file;
  struct sock             *sk;
  const struct proto\PYGZus{}ops  *ops;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{state}}] \leavevmode
socket state (\code{SS\_CONNECTED}, etc)

\item[{\code{type}}] \leavevmode
socket type (\code{SOCK\_STREAM}, etc)

\item[{\code{flags}}] \leavevmode
socket flags (\code{SOCK\_NOSPACE}, etc)

\item[{\code{wq}}] \leavevmode
wait queue for several uses

\item[{\code{file}}] \leavevmode
File back pointer for gc

\item[{\code{sk}}] \leavevmode
internal networking protocol agnostic socket representation

\item[{\code{ops}}] \leavevmode
protocol specific socket operations

\end{description}


\subsection{Socket Buffer Functions}
\label{networking/kapi:socket-buffer-functions}\index{skb\_frag\_foreach\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_frag_foreach_page}\pysiglinewithargsret{\bfcode{skb\_frag\_foreach\_page}}{\emph{f}, \emph{f\_off}, \emph{f\_len}, \emph{p}, \emph{p\_off}, \emph{p\_len}, \emph{copied}}{}
loop over pages in a fragment

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{f}}] \leavevmode
skb frag to operate on

\item[{\code{f\_off}}] \leavevmode
offset from start of f-\textgreater{}page.p

\item[{\code{f\_len}}] \leavevmode
length from f\_off to loop over

\item[{\code{p}}] \leavevmode
(temp var) current page

\item[{\code{p\_off}}] \leavevmode
(temp var) offset from start of current page,
non-zero only on first page.

\item[{\code{p\_len}}] \leavevmode
(temp var) length in current page,
\textless{} PAGE\_SIZE only on first and last page.

\item[{\code{copied}}] \leavevmode
(temp var) length so far, excluding current p\_len.

\end{description}

\textbf{Description}
\begin{quote}

A fragment can hold a compound page, in which case per-page
operations, notably kmap\_atomic, must be called for each
regular page.
\end{quote}
\index{skb\_shared\_hwtstamps (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_shared_hwtstamps}\pysigline{struct \bfcode{skb\_shared\_hwtstamps}}
hardware time stamps

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct skb\PYGZus{}shared\PYGZus{}hwtstamps \PYGZob{}
  ktime\PYGZus{}t hwtstamp;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{hwtstamp}}] \leavevmode
hardware time stamp transformed into duration
since arbitrary point in time

\end{description}

\textbf{Description}

Software time stamps generated by \code{ktime\_get\_real()} are stored in
skb-\textgreater{}tstamp.

hwtstamps can only be compared against other hwtstamps from
the same device.

This structure is attached to packets as part of the
\code{skb\_shared\_info}. Use \code{skb\_hwtstamps()} to get a pointer.
\index{sk\_buff (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_buff}\pysigline{struct \bfcode{sk\_buff}}
socket buffer

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct sk\PYGZus{}buff \PYGZob{}
  union \PYGZob{}
    struct \PYGZob{}
      struct sk\PYGZus{}buff          *next;
      struct sk\PYGZus{}buff          *prev;
      union \PYGZob{}
        struct net\PYGZus{}device       *dev;
        unsigned long           dev\PYGZus{}scratch;
      \PYGZcb{};
    \PYGZcb{};
    struct rb\PYGZus{}node  rbnode;
  \PYGZcb{};
  struct sock             *sk;
  union \PYGZob{}
    ktime\PYGZus{}t tstamp;
    u64 skb\PYGZus{}mstamp;
  \PYGZcb{};
  char cb[48] ;
  union \PYGZob{}
    struct \PYGZob{}
      unsigned long   \PYGZus{}skb\PYGZus{}refdst;
      void (*destructor)(struct sk\PYGZus{}buff *skb);
    \PYGZcb{};
    struct list\PYGZus{}head        tcp\PYGZus{}tsorted\PYGZus{}anchor;
  \PYGZcb{};
\PYGZsh{}ifdef CONFIG\PYGZus{}XFRM;
  struct sec\PYGZus{}path        *sp;
\PYGZsh{}endif;
\PYGZsh{}if defined(CONFIG\PYGZus{}NF\PYGZus{}CONNTRACK) \textbar{}\textbar{} defined(CONFIG\PYGZus{}NF\PYGZus{}CONNTRACK\PYGZus{}MODULE);
  unsigned long            \PYGZus{}nfct;
\PYGZsh{}endif;
\PYGZsh{}if IS\PYGZus{}ENABLED(CONFIG\PYGZus{}BRIDGE\PYGZus{}NETFILTER);
  struct nf\PYGZus{}bridge\PYGZus{}info   *nf\PYGZus{}bridge;
\PYGZsh{}endif;
  unsigned int            len, data\PYGZus{}len;
  \PYGZus{}\PYGZus{}u16 mac\PYGZus{}len, hdr\PYGZus{}len;
  \PYGZus{}\PYGZus{}u16 queue\PYGZus{}mapping;
\PYGZsh{}ifdef \PYGZus{}\PYGZus{}BIG\PYGZus{}ENDIAN\PYGZus{}BITFIELD;
\PYGZsh{}define CLONED\PYGZus{}MASK     (1 \PYGZlt{}\PYGZlt{} 7);
\PYGZsh{}else;
\PYGZsh{}define CLONED\PYGZus{}MASK     1;
\PYGZsh{}endif;
\PYGZsh{}define CLONED\PYGZus{}OFFSET()         offsetof(struct sk\PYGZus{}buff, \PYGZus{}\PYGZus{}cloned\PYGZus{}offset);
  \PYGZus{}\PYGZus{}u8 \PYGZus{}\PYGZus{}cloned\PYGZus{}offset[0];
  \PYGZus{}\PYGZus{}u8 cloned:1,nohdr:1,fclone:2,peeked:1,head\PYGZus{}frag:1,xmit\PYGZus{}more:1, \PYGZus{}\PYGZus{}unused:1;
\PYGZsh{}ifdef \PYGZus{}\PYGZus{}BIG\PYGZus{}ENDIAN\PYGZus{}BITFIELD;
\PYGZsh{}define PKT\PYGZus{}TYPE\PYGZus{}MAX    (7 \PYGZlt{}\PYGZlt{} 5);
\PYGZsh{}else;
\PYGZsh{}define PKT\PYGZus{}TYPE\PYGZus{}MAX    7;
\PYGZsh{}endif;
\PYGZsh{}define PKT\PYGZus{}TYPE\PYGZus{}OFFSET()       offsetof(struct sk\PYGZus{}buff, \PYGZus{}\PYGZus{}pkt\PYGZus{}type\PYGZus{}offset);
  \PYGZus{}\PYGZus{}u8 \PYGZus{}\PYGZus{}pkt\PYGZus{}type\PYGZus{}offset[0];
  \PYGZus{}\PYGZus{}u8 pkt\PYGZus{}type:3;
  \PYGZus{}\PYGZus{}u8 pfmemalloc:1;
  \PYGZus{}\PYGZus{}u8 ignore\PYGZus{}df:1;
  \PYGZus{}\PYGZus{}u8 nf\PYGZus{}trace:1;
  \PYGZus{}\PYGZus{}u8 ip\PYGZus{}summed:2;
  \PYGZus{}\PYGZus{}u8 ooo\PYGZus{}okay:1;
  \PYGZus{}\PYGZus{}u8 l4\PYGZus{}hash:1;
  \PYGZus{}\PYGZus{}u8 sw\PYGZus{}hash:1;
  \PYGZus{}\PYGZus{}u8 wifi\PYGZus{}acked\PYGZus{}valid:1;
  \PYGZus{}\PYGZus{}u8 wifi\PYGZus{}acked:1;
  \PYGZus{}\PYGZus{}u8 no\PYGZus{}fcs:1;
  \PYGZus{}\PYGZus{}u8 encapsulation:1;
  \PYGZus{}\PYGZus{}u8 encap\PYGZus{}hdr\PYGZus{}csum:1;
  \PYGZus{}\PYGZus{}u8 csum\PYGZus{}valid:1;
  \PYGZus{}\PYGZus{}u8 csum\PYGZus{}complete\PYGZus{}sw:1;
  \PYGZus{}\PYGZus{}u8 csum\PYGZus{}level:2;
  \PYGZus{}\PYGZus{}u8 csum\PYGZus{}not\PYGZus{}inet:1;
  \PYGZus{}\PYGZus{}u8 dst\PYGZus{}pending\PYGZus{}confirm:1;
\PYGZsh{}ifdef CONFIG\PYGZus{}IPV6\PYGZus{}NDISC\PYGZus{}NODETYPE;
  \PYGZus{}\PYGZus{}u8 ndisc\PYGZus{}nodetype:2;
\PYGZsh{}endif;
  \PYGZus{}\PYGZus{}u8 ipvs\PYGZus{}property:1;
  \PYGZus{}\PYGZus{}u8 inner\PYGZus{}protocol\PYGZus{}type:1;
  \PYGZus{}\PYGZus{}u8 remcsum\PYGZus{}offload:1;
\PYGZsh{}ifdef CONFIG\PYGZus{}NET\PYGZus{}SWITCHDEV;
  \PYGZus{}\PYGZus{}u8 offload\PYGZus{}fwd\PYGZus{}mark:1;
  \PYGZus{}\PYGZus{}u8 offload\PYGZus{}mr\PYGZus{}fwd\PYGZus{}mark:1;
\PYGZsh{}endif;
\PYGZsh{}ifdef CONFIG\PYGZus{}NET\PYGZus{}CLS\PYGZus{}ACT;
  \PYGZus{}\PYGZus{}u8 tc\PYGZus{}skip\PYGZus{}classify:1;
  \PYGZus{}\PYGZus{}u8 tc\PYGZus{}at\PYGZus{}ingress:1;
  \PYGZus{}\PYGZus{}u8 tc\PYGZus{}redirected:1;
  \PYGZus{}\PYGZus{}u8 tc\PYGZus{}from\PYGZus{}ingress:1;
\PYGZsh{}endif;
\PYGZsh{}ifdef CONFIG\PYGZus{}NET\PYGZus{}SCHED;
  \PYGZus{}\PYGZus{}u16 tc\PYGZus{}index;
\PYGZsh{}endif;
  union \PYGZob{}
    \PYGZus{}\PYGZus{}wsum csum;
    struct \PYGZob{}
      \PYGZus{}\PYGZus{}u16 csum\PYGZus{}start;
      \PYGZus{}\PYGZus{}u16 csum\PYGZus{}offset;
    \PYGZcb{};
  \PYGZcb{};
  \PYGZus{}\PYGZus{}u32 priority;
  int skb\PYGZus{}iif;
  \PYGZus{}\PYGZus{}u32 hash;
  \PYGZus{}\PYGZus{}be16 vlan\PYGZus{}proto;
  \PYGZus{}\PYGZus{}u16 vlan\PYGZus{}tci;
\PYGZsh{}if defined(CONFIG\PYGZus{}NET\PYGZus{}RX\PYGZus{}BUSY\PYGZus{}POLL) \textbar{}\textbar{} defined(CONFIG\PYGZus{}XPS);
  union \PYGZob{}
    unsigned int    napi\PYGZus{}id;
    unsigned int    sender\PYGZus{}cpu;
  \PYGZcb{};
\PYGZsh{}endif;
\PYGZsh{}ifdef CONFIG\PYGZus{}NETWORK\PYGZus{}SECMARK;
  \PYGZus{}\PYGZus{}u32 secmark;
\PYGZsh{}endif;
  union \PYGZob{}
    \PYGZus{}\PYGZus{}u32 mark;
    \PYGZus{}\PYGZus{}u32 reserved\PYGZus{}tailroom;
  \PYGZcb{};
  union \PYGZob{}
    \PYGZus{}\PYGZus{}be16 inner\PYGZus{}protocol;
    \PYGZus{}\PYGZus{}u8 inner\PYGZus{}ipproto;
  \PYGZcb{};
  \PYGZus{}\PYGZus{}u16 inner\PYGZus{}transport\PYGZus{}header;
  \PYGZus{}\PYGZus{}u16 inner\PYGZus{}network\PYGZus{}header;
  \PYGZus{}\PYGZus{}u16 inner\PYGZus{}mac\PYGZus{}header;
  \PYGZus{}\PYGZus{}be16 protocol;
  \PYGZus{}\PYGZus{}u16 transport\PYGZus{}header;
  \PYGZus{}\PYGZus{}u16 network\PYGZus{}header;
  \PYGZus{}\PYGZus{}u16 mac\PYGZus{}header;
  sk\PYGZus{}buff\PYGZus{}data\PYGZus{}t tail;
  sk\PYGZus{}buff\PYGZus{}data\PYGZus{}t end;
  unsigned char           *head, *data;
  unsigned int            truesize;
  refcount\PYGZus{}t users;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{\{unnamed\_struct\}}}] \leavevmode
anonymous

\item[{\code{next}}] \leavevmode
Next buffer in list

\item[{\code{prev}}] \leavevmode
Previous buffer in list

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{dev}}] \leavevmode
Device we arrived on/are leaving by

\item[{\code{rbnode}}] \leavevmode
RB tree node, alternative to next/prev for netem/tcp

\item[{\code{sk}}] \leavevmode
Socket we are owned by

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{tstamp}}] \leavevmode
Time we arrived/left

\item[{\code{cb}}] \leavevmode
Control buffer. Free for use by every layer. Put private vars here

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{\{unnamed\_struct\}}}] \leavevmode
anonymous

\item[{\code{\_skb\_refdst}}] \leavevmode
destination entry (with norefcount bit)

\item[{\code{destructor}}] \leavevmode
Destruct function

\item[{\code{tcp\_tsorted\_anchor}}] \leavevmode
list structure for TCP (tp-\textgreater{}tsorted\_sent\_queue)

\item[{\code{sp}}] \leavevmode
the security path, used for xfrm

\item[{\code{\_nfct}}] \leavevmode
Associated connection, if any (with nfctinfo bits)

\item[{\code{nf\_bridge}}] \leavevmode
Saved data about a bridged frame - see br\_netfilter.c

\item[{\code{len}}] \leavevmode
Length of actual data

\item[{\code{data\_len}}] \leavevmode
Data length

\item[{\code{mac\_len}}] \leavevmode
Length of link layer header

\item[{\code{hdr\_len}}] \leavevmode
writable header length of cloned skb

\item[{\code{queue\_mapping}}] \leavevmode
Queue mapping for multiqueue devices

\item[{\code{cloned}}] \leavevmode
Head may be cloned (check refcnt to be sure)

\item[{\code{nohdr}}] \leavevmode
Payload reference only, must not modify header

\item[{\code{fclone}}] \leavevmode
skbuff clone status

\item[{\code{peeked}}] \leavevmode
this packet has been seen already, so stats have been
done for it, don't do them again

\item[{\code{xmit\_more}}] \leavevmode
More SKBs are pending for this queue

\item[{\code{pkt\_type}}] \leavevmode
Packet class

\item[{\code{ignore\_df}}] \leavevmode
allow local fragmentation

\item[{\code{nf\_trace}}] \leavevmode
netfilter packet trace flag

\item[{\code{ip\_summed}}] \leavevmode
Driver fed us an IP checksum

\item[{\code{ooo\_okay}}] \leavevmode
allow the mapping of a socket to a queue to be changed

\item[{\code{l4\_hash}}] \leavevmode
indicate hash is a canonical 4-tuple hash over transport
ports.

\item[{\code{sw\_hash}}] \leavevmode
indicates hash was computed in software stack

\item[{\code{wifi\_acked\_valid}}] \leavevmode
wifi\_acked was set

\item[{\code{wifi\_acked}}] \leavevmode
whether frame was acked on wifi or not

\item[{\code{no\_fcs}}] \leavevmode
Request NIC to treat last 4 bytes as Ethernet FCS

\item[{\code{csum\_not\_inet}}] \leavevmode
use CRC32c to resolve CHECKSUM\_PARTIAL

\item[{\code{dst\_pending\_confirm}}] \leavevmode
need to confirm neighbour

\item[{\code{ndisc\_nodetype}}] \leavevmode
router type (from link layer)

\item[{\code{ipvs\_property}}] \leavevmode
skbuff is owned by ipvs

\item[{\code{tc\_skip\_classify}}] \leavevmode
do not classify packet. set by IFB device

\item[{\code{tc\_at\_ingress}}] \leavevmode
used within tc\_classify to distinguish in/egress

\item[{\code{tc\_redirected}}] \leavevmode
packet was redirected by a tc action

\item[{\code{tc\_from\_ingress}}] \leavevmode
if tc\_redirected, tc\_at\_ingress at time of redirect

\item[{\code{tc\_index}}] \leavevmode
Traffic control index

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{csum}}] \leavevmode
Checksum (must include start/offset pair)

\item[{\code{\{unnamed\_struct\}}}] \leavevmode
anonymous

\item[{\code{csum\_start}}] \leavevmode
Offset from skb-\textgreater{}head where checksumming should start

\item[{\code{csum\_offset}}] \leavevmode
Offset from csum\_start where checksum should be stored

\item[{\code{priority}}] \leavevmode
Packet queueing priority

\item[{\code{skb\_iif}}] \leavevmode
ifindex of device we arrived on

\item[{\code{hash}}] \leavevmode
the packet hash

\item[{\code{vlan\_proto}}] \leavevmode
vlan encapsulation protocol

\item[{\code{vlan\_tci}}] \leavevmode
vlan tag control information

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{napi\_id}}] \leavevmode
id of the NAPI struct this skb came from

\item[{\code{secmark}}] \leavevmode
security marking

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{mark}}] \leavevmode
Generic packet mark

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{inner\_protocol}}] \leavevmode
Protocol (encapsulation)

\item[{\code{inner\_transport\_header}}] \leavevmode
Inner transport layer header (encapsulation)

\item[{\code{inner\_network\_header}}] \leavevmode
Network layer header (encapsulation)

\item[{\code{inner\_mac\_header}}] \leavevmode
Link layer header (encapsulation)

\item[{\code{protocol}}] \leavevmode
Packet protocol from driver

\item[{\code{transport\_header}}] \leavevmode
Transport layer header

\item[{\code{network\_header}}] \leavevmode
Network layer header

\item[{\code{mac\_header}}] \leavevmode
Link layer header

\item[{\code{tail}}] \leavevmode
Tail pointer

\item[{\code{end}}] \leavevmode
End pointer

\item[{\code{head}}] \leavevmode
Head of buffer

\item[{\code{data}}] \leavevmode
Data head pointer

\item[{\code{truesize}}] \leavevmode
Buffer size

\item[{\code{users}}] \leavevmode
User count - see \{datagram,tcp\}.c

\end{description}
\index{skb\_dst (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_dst}\pysiglinewithargsret{struct dst\_entry * \bfcode{skb\_dst}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
returns skb dst\_entry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
buffer

\end{description}

\textbf{Description}

Returns skb dst\_entry, regardless of reference taken or not.
\index{skb\_dst\_set (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_dst_set}\pysiglinewithargsret{void \bfcode{skb\_dst\_set}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, struct dst\_entry *\emph{dst}}{}
sets skb dst

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer

\item[{\code{struct dst\_entry * dst}}] \leavevmode
dst entry

\end{description}

\textbf{Description}

Sets skb dst, assuming a reference was taken on dst and should
be released by \code{skb\_dst\_drop()}
\index{skb\_dst\_set\_noref (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_dst_set_noref}\pysiglinewithargsret{void \bfcode{skb\_dst\_set\_noref}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, struct dst\_entry *\emph{dst}}{}
sets skb dst, hopefully, without taking reference

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer

\item[{\code{struct dst\_entry * dst}}] \leavevmode
dst entry

\end{description}

\textbf{Description}

Sets skb dst, assuming a reference was not taken on dst.
If dst entry is cached, we do not take reference and dst\_release
will be avoided by refdst\_drop. If dst entry is not cached, we take
reference, so that last dst\_release can destroy the dst immediately.
\index{skb\_dst\_is\_noref (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_dst_is_noref}\pysiglinewithargsret{bool \bfcode{skb\_dst\_is\_noref}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
Test if skb dst isn't refcounted

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
buffer

\end{description}
\index{skb\_fclone\_busy (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_fclone_busy}\pysiglinewithargsret{bool \bfcode{skb\_fclone\_busy}}{const struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
check if fclone is busy

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sock * sk}}] \leavevmode
socket

\item[{\code{const struct sk\_buff * skb}}] \leavevmode
buffer

\end{description}

\textbf{Description}

Returns true if skb is a fast clone, and its clone is not freed.
Some drivers call {\hyperref[networking/kapi:c.skb_orphan]{\emph{\code{skb\_orphan()}}}} in their \code{ndo\_start\_xmit()},
so we also check that this didnt happen.
\index{skb\_pad (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_pad}\pysiglinewithargsret{int \bfcode{skb\_pad}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{pad}}{}
zero pad the tail of an skb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to pad

\item[{\code{int pad}}] \leavevmode
space to pad

\end{description}

\textbf{Description}
\begin{quote}

Ensure that a buffer is followed by a padding area that is zero
filled. Used by network drivers which may DMA or transfer data
beyond the buffer end onto the wire.

May return error in out of memory cases. The skb is freed on error.
\end{quote}
\index{skb\_queue\_empty (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_queue_empty}\pysiglinewithargsret{int \bfcode{skb\_queue\_empty}}{const struct sk\_buff\_head *\emph{list}}{}
check if a queue is empty

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff\_head * list}}] \leavevmode
queue head

\end{description}

\textbf{Description}
\begin{quote}

Returns true if the queue is empty, false otherwise.
\end{quote}
\index{skb\_queue\_is\_last (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_queue_is_last}\pysiglinewithargsret{bool \bfcode{skb\_queue\_is\_last}}{const struct sk\_buff\_head *\emph{list}, const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
check if skb is the last entry in the queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff\_head * list}}] \leavevmode
queue head

\item[{\code{const struct sk\_buff * skb}}] \leavevmode
buffer

\end{description}

\textbf{Description}
\begin{quote}

Returns true if \textbf{skb} is the last buffer on the list.
\end{quote}
\index{skb\_queue\_is\_first (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_queue_is_first}\pysiglinewithargsret{bool \bfcode{skb\_queue\_is\_first}}{const struct sk\_buff\_head *\emph{list}, const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
check if skb is the first entry in the queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff\_head * list}}] \leavevmode
queue head

\item[{\code{const struct sk\_buff * skb}}] \leavevmode
buffer

\end{description}

\textbf{Description}
\begin{quote}

Returns true if \textbf{skb} is the first buffer on the list.
\end{quote}
\index{skb\_queue\_next (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_queue_next}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_queue\_next}}{const struct sk\_buff\_head *\emph{list}, const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
return the next packet in the queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff\_head * list}}] \leavevmode
queue head

\item[{\code{const struct sk\_buff * skb}}] \leavevmode
current buffer

\end{description}

\textbf{Description}
\begin{quote}

Return the next packet in \textbf{list} after \textbf{skb}.  It is only valid to
call this if {\hyperref[networking/kapi:c.skb_queue_is_last]{\emph{\code{skb\_queue\_is\_last()}}}} evaluates to false.
\end{quote}
\index{skb\_queue\_prev (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_queue_prev}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_queue\_prev}}{const struct sk\_buff\_head *\emph{list}, const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
return the prev packet in the queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff\_head * list}}] \leavevmode
queue head

\item[{\code{const struct sk\_buff * skb}}] \leavevmode
current buffer

\end{description}

\textbf{Description}
\begin{quote}

Return the prev packet in \textbf{list} before \textbf{skb}.  It is only valid to
call this if {\hyperref[networking/kapi:c.skb_queue_is_first]{\emph{\code{skb\_queue\_is\_first()}}}} evaluates to false.
\end{quote}
\index{skb\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_get}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_get}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
reference buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to reference

\end{description}

\textbf{Description}
\begin{quote}

Makes another reference to a socket buffer and returns a pointer
to the buffer.
\end{quote}
\index{skb\_cloned (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_cloned}\pysiglinewithargsret{int \bfcode{skb\_cloned}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
is the buffer a clone

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
buffer to check

\end{description}

\textbf{Description}
\begin{quote}

Returns true if the buffer was generated with {\hyperref[networking/kapi:c.skb_clone]{\emph{\code{skb\_clone()}}}} and is
one of multiple shared copies of the buffer. Cloned buffers are
shared data so must not be written to under normal circumstances.
\end{quote}
\index{skb\_header\_cloned (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_header_cloned}\pysiglinewithargsret{int \bfcode{skb\_header\_cloned}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
is the header a clone

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
buffer to check

\end{description}

\textbf{Description}
\begin{quote}

Returns true if modifying the header part of the buffer requires
the data to be copied.
\end{quote}
\index{\_\_skb\_header\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__skb_header_release}\pysiglinewithargsret{void \bfcode{\_\_skb\_header\_release}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
release reference to header

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to operate on

\end{description}
\index{skb\_shared (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_shared}\pysiglinewithargsret{int \bfcode{skb\_shared}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
is the buffer shared

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
buffer to check

\end{description}

\textbf{Description}
\begin{quote}

Returns true if more than one person has a reference to this
buffer.
\end{quote}
\index{skb\_share\_check (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_share_check}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_share\_check}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, gfp\_t\emph{pri}}{}
check if buffer is shared and if so clone it

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to check

\item[{\code{gfp\_t pri}}] \leavevmode
priority for memory allocation

\end{description}

\textbf{Description}
\begin{quote}

If the buffer is shared the buffer is cloned and the old copy
drops a reference. A new clone with a single reference is returned.
If the buffer is not shared the original buffer is returned. When
being called from interrupt status or with spinlocks held pri must
be GFP\_ATOMIC.

NULL is returned on a memory allocation failure.
\end{quote}
\index{skb\_unshare (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_unshare}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_unshare}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, gfp\_t\emph{pri}}{}
make a copy of a shared buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to check

\item[{\code{gfp\_t pri}}] \leavevmode
priority for memory allocation

\end{description}

\textbf{Description}
\begin{quote}

If the socket buffer is a clone then this function creates a new
copy of the data, drops a reference count on the old copy and returns
the new copy with the reference count at 1. If the buffer is not a clone
the original buffer is returned. When called with a spinlock held or
from interrupt state \textbf{pri} must be \code{GFP\_ATOMIC}

\code{NULL} is returned on a memory allocation failure.
\end{quote}
\index{skb\_peek (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_peek}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_peek}}{const struct sk\_buff\_head *\emph{list\_}}{}
peek at the head of an \code{sk\_buff\_head}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff\_head * list\_}}] \leavevmode
list to peek at

\end{description}

\textbf{Description}
\begin{quote}

Peek an {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}}. Unlike most other operations you \_MUST\_
be careful with this one. A peek leaves the buffer on the
list and someone else may run off with it. You must hold
the appropriate locks or have a private queue to do this.

Returns \code{NULL} for an empty list or a pointer to the head element.
The reference count is not incremented and the reference is therefore
volatile. Use with caution.
\end{quote}
\index{skb\_peek\_next (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_peek_next}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_peek\_next}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, const struct sk\_buff\_head *\emph{list\_}}{}
peek skb following the given one from a queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
skb to start from

\item[{\code{const struct sk\_buff\_head * list\_}}] \leavevmode
list to peek at

\end{description}

\textbf{Description}
\begin{quote}

Returns \code{NULL} when the end of the list is met or a pointer to the
next element. The reference count is not incremented and the
reference is therefore volatile. Use with caution.
\end{quote}
\index{skb\_peek\_tail (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_peek_tail}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_peek\_tail}}{const struct sk\_buff\_head *\emph{list\_}}{}
peek at the tail of an \code{sk\_buff\_head}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff\_head * list\_}}] \leavevmode
list to peek at

\end{description}

\textbf{Description}
\begin{quote}

Peek an {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}}. Unlike most other operations you \_MUST\_
be careful with this one. A peek leaves the buffer on the
list and someone else may run off with it. You must hold
the appropriate locks or have a private queue to do this.

Returns \code{NULL} for an empty list or a pointer to the tail element.
The reference count is not incremented and the reference is therefore
volatile. Use with caution.
\end{quote}
\index{skb\_queue\_len (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_queue_len}\pysiglinewithargsret{\_\_u32 \bfcode{skb\_queue\_len}}{const struct sk\_buff\_head *\emph{list\_}}{}
get queue length

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff\_head * list\_}}] \leavevmode
list to measure

\end{description}

\textbf{Description}
\begin{quote}

Return the length of an {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} queue.
\end{quote}
\index{\_\_skb\_queue\_head\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__skb_queue_head_init}\pysiglinewithargsret{void \bfcode{\_\_skb\_queue\_head\_init}}{struct sk\_buff\_head *\emph{list}}{}
initialize non-spinlock portions of sk\_buff\_head

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
queue to initialize

\end{description}

\textbf{Description}
\begin{quote}

This initializes only the list and queue length aspects of
an sk\_buff\_head object.  This allows to initialize the list
aspects of an sk\_buff\_head without reinitializing things like
the spinlock.  It can also be used for on-stack sk\_buff\_head
objects where the spinlock is known to not be used.
\end{quote}
\index{skb\_queue\_splice (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_queue_splice}\pysiglinewithargsret{void \bfcode{skb\_queue\_splice}}{const struct sk\_buff\_head *\emph{list}, struct sk\_buff\_head *\emph{head}}{}
join two skb lists, this is designed for stacks

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff\_head * list}}] \leavevmode
the new list to add

\item[{\code{struct sk\_buff\_head * head}}] \leavevmode
the place to add it in the first list

\end{description}
\index{skb\_queue\_splice\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_queue_splice_init}\pysiglinewithargsret{void \bfcode{skb\_queue\_splice\_init}}{struct sk\_buff\_head *\emph{list}, struct sk\_buff\_head *\emph{head}}{}
join two skb lists and reinitialise the emptied list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
the new list to add

\item[{\code{struct sk\_buff\_head * head}}] \leavevmode
the place to add it in the first list

\end{description}

\textbf{Description}
\begin{quote}

The list at \textbf{list} is reinitialised
\end{quote}
\index{skb\_queue\_splice\_tail (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_queue_splice_tail}\pysiglinewithargsret{void \bfcode{skb\_queue\_splice\_tail}}{const struct sk\_buff\_head *\emph{list}, struct sk\_buff\_head *\emph{head}}{}
join two skb lists, each list being a queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff\_head * list}}] \leavevmode
the new list to add

\item[{\code{struct sk\_buff\_head * head}}] \leavevmode
the place to add it in the first list

\end{description}
\index{skb\_queue\_splice\_tail\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_queue_splice_tail_init}\pysiglinewithargsret{void \bfcode{skb\_queue\_splice\_tail\_init}}{struct sk\_buff\_head *\emph{list}, struct sk\_buff\_head *\emph{head}}{}
join two skb lists and reinitialise the emptied list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
the new list to add

\item[{\code{struct sk\_buff\_head * head}}] \leavevmode
the place to add it in the first list

\end{description}

\textbf{Description}
\begin{quote}

Each of the lists is a queue.
The list at \textbf{list} is reinitialised
\end{quote}
\index{\_\_skb\_queue\_after (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__skb_queue_after}\pysiglinewithargsret{void \bfcode{\_\_skb\_queue\_after}}{struct sk\_buff\_head *\emph{list}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{prev}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{newsk}}{}
queue a buffer at the list head

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
list to use

\item[{\code{struct sk\_buff * prev}}] \leavevmode
place after this buffer

\item[{\code{struct sk\_buff * newsk}}] \leavevmode
buffer to queue

\end{description}

\textbf{Description}
\begin{quote}

Queue a buffer int the middle of a list. This function takes no locks
and you must therefore hold required locks before calling it.

A buffer cannot be placed on two lists at the same time.
\end{quote}
\index{skb\_queue\_head (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_queue_head}\pysiglinewithargsret{void \bfcode{skb\_queue\_head}}{struct sk\_buff\_head *\emph{list}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{newsk}}{}
queue a buffer at the list head

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
list to use

\item[{\code{struct sk\_buff * newsk}}] \leavevmode
buffer to queue

\end{description}

\textbf{Description}
\begin{quote}

Queue a buffer at the start of a list. This function takes no locks
and you must therefore hold required locks before calling it.

A buffer cannot be placed on two lists at the same time.
\end{quote}
\index{skb\_queue\_tail (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_queue_tail}\pysiglinewithargsret{void \bfcode{skb\_queue\_tail}}{struct sk\_buff\_head *\emph{list}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{newsk}}{}
queue a buffer at the list tail

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
list to use

\item[{\code{struct sk\_buff * newsk}}] \leavevmode
buffer to queue

\end{description}

\textbf{Description}
\begin{quote}

Queue a buffer at the end of a list. This function takes no locks
and you must therefore hold required locks before calling it.

A buffer cannot be placed on two lists at the same time.
\end{quote}
\index{skb\_dequeue (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_dequeue}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_dequeue}}{struct sk\_buff\_head *\emph{list}}{}
remove from the head of the queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
list to dequeue from

\end{description}

\textbf{Description}
\begin{quote}

Remove the head of the list. This function does not take any locks
so must be used with appropriate locks held only. The head item is
returned or \code{NULL} if the list is empty.
\end{quote}
\index{skb\_dequeue\_tail (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_dequeue_tail}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_dequeue\_tail}}{struct sk\_buff\_head *\emph{list}}{}
remove from the tail of the queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
list to dequeue from

\end{description}

\textbf{Description}
\begin{quote}

Remove the tail of the list. This function does not take any locks
so must be used with appropriate locks held only. The tail item is
returned or \code{NULL} if the list is empty.
\end{quote}
\index{\_\_skb\_fill\_page\_desc (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__skb_fill_page_desc}\pysiglinewithargsret{void \bfcode{\_\_skb\_fill\_page\_desc}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{i}, struct page *\emph{page}, int\emph{off}, int\emph{size}}{}
initialise a paged fragment in an skb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer containing fragment to be initialised

\item[{\code{int i}}] \leavevmode
paged fragment index to initialise

\item[{\code{struct page * page}}] \leavevmode
the page to use for this fragment

\item[{\code{int off}}] \leavevmode
the offset to the data with \textbf{page}

\item[{\code{int size}}] \leavevmode
the length of the data

\end{description}

\textbf{Description}

Initialises the \textbf{i}`th fragment of \textbf{skb} to point to \code{size} bytes at
offset \textbf{off} within \textbf{page}.

Does not take any additional reference on the fragment.
\index{skb\_fill\_page\_desc (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_fill_page_desc}\pysiglinewithargsret{void \bfcode{skb\_fill\_page\_desc}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{i}, struct page *\emph{page}, int\emph{off}, int\emph{size}}{}
initialise a paged fragment in an skb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer containing fragment to be initialised

\item[{\code{int i}}] \leavevmode
paged fragment index to initialise

\item[{\code{struct page * page}}] \leavevmode
the page to use for this fragment

\item[{\code{int off}}] \leavevmode
the offset to the data with \textbf{page}

\item[{\code{int size}}] \leavevmode
the length of the data

\end{description}

\textbf{Description}

As per {\hyperref[networking/kapi:c.__skb_fill_page_desc]{\emph{\code{\_\_skb\_fill\_page\_desc()}}}} -- initialises the \textbf{i}`th fragment of
\textbf{skb} to point to \textbf{size} bytes at offset \textbf{off} within \textbf{page}. In
addition updates \textbf{skb} such that \textbf{i} is the last fragment.

Does not take any additional reference on the fragment.
\index{skb\_headroom (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_headroom}\pysiglinewithargsret{unsigned int \bfcode{skb\_headroom}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
bytes at buffer head

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
buffer to check

\end{description}

\textbf{Description}
\begin{quote}

Return the number of bytes of free space at the head of an {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}}.
\end{quote}
\index{skb\_tailroom (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_tailroom}\pysiglinewithargsret{int \bfcode{skb\_tailroom}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
bytes at buffer end

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
buffer to check

\end{description}

\textbf{Description}
\begin{quote}

Return the number of bytes of free space at the tail of an sk\_buff
\end{quote}
\index{skb\_availroom (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_availroom}\pysiglinewithargsret{int \bfcode{skb\_availroom}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
bytes at buffer end

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
buffer to check

\end{description}

\textbf{Description}
\begin{quote}

Return the number of bytes of free space at the tail of an sk\_buff
allocated by \code{sk\_stream\_alloc()}
\end{quote}
\index{skb\_reserve (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_reserve}\pysiglinewithargsret{void \bfcode{skb\_reserve}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{len}}{}
adjust headroom

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to alter

\item[{\code{int len}}] \leavevmode
bytes to move

\end{description}

\textbf{Description}
\begin{quote}

Increase the headroom of an empty {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} by reducing the tail
room. This is only allowed for an empty buffer.
\end{quote}
\index{skb\_tailroom\_reserve (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_tailroom_reserve}\pysiglinewithargsret{void \bfcode{skb\_tailroom\_reserve}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{mtu}, unsigned int\emph{needed\_tailroom}}{}
adjust reserved\_tailroom

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to alter

\item[{\code{unsigned int mtu}}] \leavevmode
maximum amount of headlen permitted

\item[{\code{unsigned int needed\_tailroom}}] \leavevmode
minimum amount of reserved\_tailroom

\end{description}

\textbf{Description}
\begin{quote}

Set reserved\_tailroom so that headlen can be as large as possible but
not larger than mtu and tailroom cannot be smaller than
needed\_tailroom.
The required headroom should already have been reserved before using
this function.
\end{quote}
\index{pskb\_trim\_unique (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.pskb_trim_unique}\pysiglinewithargsret{void \bfcode{pskb\_trim\_unique}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{len}}{}
remove end from a paged unique (not cloned) buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to alter

\item[{\code{unsigned int len}}] \leavevmode
new length

\end{description}

\textbf{Description}
\begin{quote}

This is identical to pskb\_trim except that the caller knows that
the skb is not cloned so we should never get an error due to out-
of-memory.
\end{quote}
\index{skb\_orphan (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_orphan}\pysiglinewithargsret{void \bfcode{skb\_orphan}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
orphan a buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to orphan

\end{description}

\textbf{Description}
\begin{quote}

If a buffer currently has an owner then we call the owner's
destructor function and make the \textbf{skb} unowned. The buffer continues
to exist but is no longer charged to its former owner.
\end{quote}
\index{skb\_orphan\_frags (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_orphan_frags}\pysiglinewithargsret{int \bfcode{skb\_orphan\_frags}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, gfp\_t\emph{gfp\_mask}}{}
orphan the frags contained in a buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to orphan frags from

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
allocation mask for replacement pages

\end{description}

\textbf{Description}
\begin{quote}

For each frag in the SKB which needs a destructor (i.e. has an
owner) create a copy of that frag and release the original
page by calling the destructor.
\end{quote}
\index{skb\_queue\_purge (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_queue_purge}\pysiglinewithargsret{void \bfcode{skb\_queue\_purge}}{struct sk\_buff\_head *\emph{list}}{}
empty a list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
list to empty

\end{description}

\textbf{Description}
\begin{quote}

Delete all buffers on an {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} list. Each buffer is removed from
the list and one reference dropped. This function does not take the
list lock and the caller must hold the relevant locks to use it.
\end{quote}
\index{netdev\_alloc\_skb (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_alloc_skb}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{netdev\_alloc\_skb}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, unsigned int\emph{length}}{}
allocate an skbuff for rx on a specific device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device to receive on

\item[{\code{unsigned int length}}] \leavevmode
length to allocate

\end{description}

\textbf{Description}
\begin{quote}

Allocate a new {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} and assign it a usage count of one. The
buffer has unspecified headroom built in. Users should allocate
the headroom they think they need without accounting for the
built in space. The built in space is used for optimisations.

\code{NULL} is returned if there is no free memory. Although this function
allocates memory it can be called from an interrupt.
\end{quote}
\index{\_\_dev\_alloc\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__dev_alloc_pages}\pysiglinewithargsret{struct page * \bfcode{\_\_dev\_alloc\_pages}}{gfp\_t\emph{gfp\_mask}, unsigned int\emph{order}}{}
allocate page for network Rx

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
allocation priority. Set \_\_GFP\_NOMEMALLOC if not for network Rx

\item[{\code{unsigned int order}}] \leavevmode
size of the allocation

\end{description}

\textbf{Description}

Allocate a new page.

\code{NULL} is returned if there is no free memory.
\index{\_\_dev\_alloc\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__dev_alloc_page}\pysiglinewithargsret{struct page * \bfcode{\_\_dev\_alloc\_page}}{gfp\_t\emph{gfp\_mask}}{}
allocate a page for network Rx

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
allocation priority. Set \_\_GFP\_NOMEMALLOC if not for network Rx

\end{description}

\textbf{Description}

Allocate a new page.

\code{NULL} is returned if there is no free memory.
\index{skb\_propagate\_pfmemalloc (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_propagate_pfmemalloc}\pysiglinewithargsret{void \bfcode{skb\_propagate\_pfmemalloc}}{struct page *\emph{page}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
Propagate pfmemalloc if skb is allocated after RX page

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct page * page}}] \leavevmode
The page that was allocated from skb\_alloc\_page

\item[{\code{struct sk\_buff * skb}}] \leavevmode
The skb that may need pfmemalloc set

\end{description}
\index{skb\_frag\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_frag_page}\pysiglinewithargsret{struct page * \bfcode{skb\_frag\_page}}{const skb\_frag\_t *\emph{frag}}{}
retrieve the page referred to by a paged fragment

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const skb\_frag\_t * frag}}] \leavevmode
the paged fragment

\end{description}

\textbf{Description}

Returns the \code{struct page} associated with \textbf{frag}.
\index{\_\_skb\_frag\_ref (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__skb_frag_ref}\pysiglinewithargsret{void \bfcode{\_\_skb\_frag\_ref}}{skb\_frag\_t *\emph{frag}}{}
take an addition reference on a paged fragment.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{skb\_frag\_t * frag}}] \leavevmode
the paged fragment

\end{description}

\textbf{Description}

Takes an additional reference on the paged fragment \textbf{frag}.
\index{skb\_frag\_ref (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_frag_ref}\pysiglinewithargsret{void \bfcode{skb\_frag\_ref}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{f}}{}
take an addition reference on a paged fragment of an skb.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
the buffer

\item[{\code{int f}}] \leavevmode
the fragment offset.

\end{description}

\textbf{Description}

Takes an additional reference on the \textbf{f}`th paged fragment of \textbf{skb}.
\index{\_\_skb\_frag\_unref (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__skb_frag_unref}\pysiglinewithargsret{void \bfcode{\_\_skb\_frag\_unref}}{skb\_frag\_t *\emph{frag}}{}
release a reference on a paged fragment.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{skb\_frag\_t * frag}}] \leavevmode
the paged fragment

\end{description}

\textbf{Description}

Releases a reference on the paged fragment \textbf{frag}.
\index{skb\_frag\_unref (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_frag_unref}\pysiglinewithargsret{void \bfcode{skb\_frag\_unref}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{f}}{}
release a reference on a paged fragment of an skb.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
the buffer

\item[{\code{int f}}] \leavevmode
the fragment offset

\end{description}

\textbf{Description}

Releases a reference on the \textbf{f}`th paged fragment of \textbf{skb}.
\index{skb\_frag\_address (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_frag_address}\pysiglinewithargsret{void * \bfcode{skb\_frag\_address}}{const skb\_frag\_t *\emph{frag}}{}
gets the address of the data contained in a paged fragment

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const skb\_frag\_t * frag}}] \leavevmode
the paged fragment buffer

\end{description}

\textbf{Description}

Returns the address of the data within \textbf{frag}. The page must already
be mapped.
\index{skb\_frag\_address\_safe (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_frag_address_safe}\pysiglinewithargsret{void * \bfcode{skb\_frag\_address\_safe}}{const skb\_frag\_t *\emph{frag}}{}
gets the address of the data contained in a paged fragment

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const skb\_frag\_t * frag}}] \leavevmode
the paged fragment buffer

\end{description}

\textbf{Description}

Returns the address of the data within \textbf{frag}. Checks that the page
is mapped and returns \code{NULL} otherwise.
\index{\_\_skb\_frag\_set\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__skb_frag_set_page}\pysiglinewithargsret{void \bfcode{\_\_skb\_frag\_set\_page}}{skb\_frag\_t *\emph{frag}, struct page *\emph{page}}{}
sets the page contained in a paged fragment

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{skb\_frag\_t * frag}}] \leavevmode
the paged fragment

\item[{\code{struct page * page}}] \leavevmode
the page to set

\end{description}

\textbf{Description}

Sets the fragment \textbf{frag} to contain \textbf{page}.
\index{skb\_frag\_set\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_frag_set_page}\pysiglinewithargsret{void \bfcode{skb\_frag\_set\_page}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{f}, struct page *\emph{page}}{}
sets the page contained in a paged fragment of an skb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
the buffer

\item[{\code{int f}}] \leavevmode
the fragment offset

\item[{\code{struct page * page}}] \leavevmode
the page to set

\end{description}

\textbf{Description}

Sets the \textbf{f}`th fragment of \textbf{skb} to contain \textbf{page}.
\index{skb\_frag\_dma\_map (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_frag_dma_map}\pysiglinewithargsret{dma\_addr\_t \bfcode{skb\_frag\_dma\_map}}{struct device *\emph{dev}, const skb\_frag\_t *\emph{frag}, size\_t\emph{offset}, size\_t\emph{size}, enum dma\_data\_direction\emph{dir}}{}
maps a paged fragment via the DMA API

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
the device to map the fragment to

\item[{\code{const skb\_frag\_t * frag}}] \leavevmode
the paged fragment to map

\item[{\code{size\_t offset}}] \leavevmode
the offset within the fragment (starting at the
fragment's own offset)

\item[{\code{size\_t size}}] \leavevmode
the number of bytes to map

\item[{\code{enum dma\_data\_direction dir}}] \leavevmode
the direction of the mapping (\code{PCI\_DMA\_*})

\end{description}

\textbf{Description}

Maps the page associated with \textbf{frag} to \textbf{device}.
\index{skb\_clone\_writable (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_clone_writable}\pysiglinewithargsret{int \bfcode{skb\_clone\_writable}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{len}}{}
is the header of a clone writable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
buffer to check

\item[{\code{unsigned int len}}] \leavevmode
length up to which to write

\end{description}

\textbf{Description}
\begin{quote}

Returns true if modifying the header part of the cloned buffer
does not requires the data to be copied.
\end{quote}
\index{skb\_cow (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_cow}\pysiglinewithargsret{int \bfcode{skb\_cow}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{headroom}}{}
copy header of skb when it is required

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to cow

\item[{\code{unsigned int headroom}}] \leavevmode
needed headroom

\end{description}

\textbf{Description}
\begin{quote}

If the skb passed lacks sufficient headroom or its data part
is shared, data is reallocated. If reallocation fails, an error
is returned and original skb is not changed.

The result is skb with writable area skb-\textgreater{}head...skb-\textgreater{}tail
and at least \textbf{headroom} of space at head.
\end{quote}
\index{skb\_cow\_head (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_cow_head}\pysiglinewithargsret{int \bfcode{skb\_cow\_head}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{headroom}}{}
skb\_cow but only making the head writable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to cow

\item[{\code{unsigned int headroom}}] \leavevmode
needed headroom

\end{description}

\textbf{Description}
\begin{quote}

This function is identical to skb\_cow except that we replace the
skb\_cloned check by skb\_header\_cloned.  It should be used when
you only need to push on some header and do not need to modify
the data.
\end{quote}
\index{skb\_padto (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_padto}\pysiglinewithargsret{int \bfcode{skb\_padto}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{len}}{}
pad an skbuff up to a minimal size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to pad

\item[{\code{unsigned int len}}] \leavevmode
minimal length

\end{description}

\textbf{Description}
\begin{quote}

Pads up a buffer to ensure the trailing bytes exist and are
blanked. If the buffer already contains sufficient data it
is untouched. Otherwise it is extended. Returns zero on
success. The skb is freed on error.
\end{quote}
\index{\_\_skb\_put\_padto (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__skb_put_padto}\pysiglinewithargsret{int \bfcode{\_\_skb\_put\_padto}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{len}, bool\emph{free\_on\_error}}{}
increase size and pad an skbuff up to a minimal size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to pad

\item[{\code{unsigned int len}}] \leavevmode
minimal length

\item[{\code{bool free\_on\_error}}] \leavevmode
free buffer on error

\end{description}

\textbf{Description}
\begin{quote}

Pads up a buffer to ensure the trailing bytes exist and are
blanked. If the buffer already contains sufficient data it
is untouched. Otherwise it is extended. Returns zero on
success. The skb is freed on error if \textbf{free\_on\_error} is true.
\end{quote}
\index{skb\_put\_padto (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_put_padto}\pysiglinewithargsret{int \bfcode{skb\_put\_padto}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{len}}{}
increase size and pad an skbuff up to a minimal size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to pad

\item[{\code{unsigned int len}}] \leavevmode
minimal length

\end{description}

\textbf{Description}
\begin{quote}

Pads up a buffer to ensure the trailing bytes exist and are
blanked. If the buffer already contains sufficient data it
is untouched. Otherwise it is extended. Returns zero on
success. The skb is freed on error.
\end{quote}
\index{skb\_linearize (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_linearize}\pysiglinewithargsret{int \bfcode{skb\_linearize}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
convert paged skb to linear one

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to linarize

\end{description}

\textbf{Description}
\begin{quote}

If there is no free memory -ENOMEM is returned, otherwise zero
is returned and the old skb data released.
\end{quote}
\index{skb\_has\_shared\_frag (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_has_shared_frag}\pysiglinewithargsret{bool \bfcode{skb\_has\_shared\_frag}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
can any frag be overwritten

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
buffer to test

\end{description}

\textbf{Description}

Return true if the skb has at least one frag that might be modified
by an external entity (as in \code{vmsplice()}/\code{sendfile()})
\index{skb\_linearize\_cow (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_linearize_cow}\pysiglinewithargsret{int \bfcode{skb\_linearize\_cow}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
make sure skb is linear and writable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to process

\end{description}

\textbf{Description}
\begin{quote}

If there is no free memory -ENOMEM is returned, otherwise zero
is returned and the old skb data released.
\end{quote}
\index{skb\_postpull\_rcsum (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_postpull_rcsum}\pysiglinewithargsret{void \bfcode{skb\_postpull\_rcsum}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, const void *\emph{start}, unsigned int\emph{len}}{}
update checksum for received skb after pull

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to update

\item[{\code{const void * start}}] \leavevmode
start of data before pull

\item[{\code{unsigned int len}}] \leavevmode
length of data pulled

\end{description}

\textbf{Description}
\begin{quote}

After doing a pull on a received packet, you need to call this to
update the CHECKSUM\_COMPLETE checksum, or set ip\_summed to
CHECKSUM\_NONE so that it can be recomputed from scratch.
\end{quote}
\index{skb\_postpush\_rcsum (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_postpush_rcsum}\pysiglinewithargsret{void \bfcode{skb\_postpush\_rcsum}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, const void *\emph{start}, unsigned int\emph{len}}{}
update checksum for received skb after push

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to update

\item[{\code{const void * start}}] \leavevmode
start of data after push

\item[{\code{unsigned int len}}] \leavevmode
length of data pushed

\end{description}

\textbf{Description}
\begin{quote}

After doing a push on a received packet, you need to call this to
update the CHECKSUM\_COMPLETE checksum.
\end{quote}
\index{skb\_push\_rcsum (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_push_rcsum}\pysiglinewithargsret{void * \bfcode{skb\_push\_rcsum}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{len}}{}
push skb and update receive checksum

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to update

\item[{\code{unsigned int len}}] \leavevmode
length of data pulled

\end{description}

\textbf{Description}
\begin{quote}

This function performs an skb\_push on the packet and updates
the CHECKSUM\_COMPLETE checksum.  It should be used on
receive path processing instead of skb\_push unless you know
that the checksum difference is zero (e.g., a valid IP header)
or you are setting ip\_summed to CHECKSUM\_NONE.
\end{quote}
\index{pskb\_trim\_rcsum (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.pskb_trim_rcsum}\pysiglinewithargsret{int \bfcode{pskb\_trim\_rcsum}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{len}}{}
trim received skb and update checksum

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to trim

\item[{\code{unsigned int len}}] \leavevmode
new length

\end{description}

\textbf{Description}
\begin{quote}

This is exactly the same as pskb\_trim except that it ensures the
checksum of received packets are still valid after the operation.
\end{quote}
\index{skb\_needs\_linearize (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_needs_linearize}\pysiglinewithargsret{bool \bfcode{skb\_needs\_linearize}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, netdev\_features\_t\emph{features}}{}
check if we need to linearize a given skb depending on the given device features.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
socket buffer to check

\item[{\code{netdev\_features\_t features}}] \leavevmode
net device features

\end{description}

\textbf{Description}
\begin{quote}

Returns true if either:
1. skb has frag\_list and the device doesn't support FRAGLIST, or
2. skb is fragmented and the device does not support SG.
\end{quote}
\index{skb\_get\_timestamp (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_get_timestamp}\pysiglinewithargsret{void \bfcode{skb\_get\_timestamp}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, struct timeval *\emph{stamp}}{}
get timestamp from a skb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
skb to get stamp from

\item[{\code{struct timeval * stamp}}] \leavevmode
pointer to struct timeval to store stamp in

\end{description}

\textbf{Description}
\begin{quote}

Timestamps are stored in the skb as offsets to a base timestamp.
This function converts the offset back to a struct timeval and stores
it in stamp.
\end{quote}
\index{skb\_complete\_tx\_timestamp (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_complete_tx_timestamp}\pysiglinewithargsret{void \bfcode{skb\_complete\_tx\_timestamp}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, struct {\hyperref[networking/kapi:c.skb_shared_hwtstamps]{\emph{skb\_shared\_hwtstamps}}} *\emph{hwtstamps}}{}
deliver cloned skb with tx timestamps

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
clone of the the original outgoing packet

\item[{\code{struct skb\_shared\_hwtstamps * hwtstamps}}] \leavevmode
hardware time stamps

\end{description}

\textbf{Description}

PHY drivers may accept clones of transmitted packets for
timestamping via their phy\_driver.txtstamp method. These drivers
must call this function to return the skb back to the stack with a
timestamp.
\index{skb\_tstamp\_tx (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_tstamp_tx}\pysiglinewithargsret{void \bfcode{skb\_tstamp\_tx}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{orig\_skb}, struct {\hyperref[networking/kapi:c.skb_shared_hwtstamps]{\emph{skb\_shared\_hwtstamps}}} *\emph{hwtstamps}}{}
queue clone of skb with send time stamps

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * orig\_skb}}] \leavevmode
the original outgoing packet

\item[{\code{struct skb\_shared\_hwtstamps * hwtstamps}}] \leavevmode
hardware time stamps, may be NULL if not available

\end{description}

\textbf{Description}

If the skb has a socket associated, then this function clones the
skb (thus sharing the actual data and optional structures), stores
the optional hardware time stamping information (if non NULL) or
generates a software time stamp (otherwise), then queues the clone
to the error queue of the socket.  Errors are silently ignored.
\index{skb\_tx\_timestamp (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_tx_timestamp}\pysiglinewithargsret{void \bfcode{skb\_tx\_timestamp}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
Driver hook for transmit timestamping

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
A socket buffer.

\end{description}

\textbf{Description}

Ethernet MAC Drivers should call this function in their \code{hard\_xmit()}
function immediately before giving the sk\_buff to the MAC hardware.

Specifically, one should make absolutely sure that this function is
called before TX completion of this packet can trigger.  Otherwise
the packet could potentially already be freed.
\index{skb\_complete\_wifi\_ack (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_complete_wifi_ack}\pysiglinewithargsret{void \bfcode{skb\_complete\_wifi\_ack}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, bool\emph{acked}}{}
deliver skb with wifi status

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
the original outgoing packet

\item[{\code{bool acked}}] \leavevmode
ack status

\end{description}
\index{skb\_checksum\_complete (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_checksum_complete}\pysiglinewithargsret{\_\_sum16 \bfcode{skb\_checksum\_complete}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
Calculate checksum of an entire packet

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
packet to process

\end{description}

\textbf{Description}
\begin{quote}

This function calculates the checksum over the entire packet plus
the value of skb-\textgreater{}csum.  The latter can be used to supply the
checksum of a pseudo header as used by TCP/UDP.  It returns the
checksum.

For protocols that contain complete checksums such as ICMP/TCP/UDP,
this function can be used to verify that checksum on received
packets.  In that case the function should return zero if the
checksum is correct.  In particular, this function will return zero
if skb-\textgreater{}ip\_summed is CHECKSUM\_UNNECESSARY which indicates that the
hardware has already verified the correctness of the checksum.
\end{quote}
\index{skb\_checksum\_none\_assert (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_checksum_none_assert}\pysiglinewithargsret{void \bfcode{skb\_checksum\_none\_assert}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
make sure skb ip\_summed is CHECKSUM\_NONE

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
skb to check

\end{description}

\textbf{Description}

fresh skbs have their ip\_summed set to CHECKSUM\_NONE.
Instead of forcing ip\_summed to CHECKSUM\_NONE, we can
use this helper, to document places where we make this assertion.
\index{skb\_head\_is\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_head_is_locked}\pysiglinewithargsret{bool \bfcode{skb\_head\_is\_locked}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
Determine if the skb-\textgreater{}head is locked down

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
skb to check

\end{description}

\textbf{Description}

The head on skbs build around a head frag can be removed if they are
not cloned.  This function returns true if the skb head is locked down
due to either being allocated via kmalloc, or by being a clone with
multiple references to the head.
\index{sock\_common (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sock_common}\pysigline{struct \bfcode{sock\_common}}
minimal network layer representation of sockets

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct sock\PYGZus{}common \PYGZob{}
  union \PYGZob{}
    \PYGZus{}\PYGZus{}addrpair skc\PYGZus{}addrpair;
    struct \PYGZob{}
      \PYGZus{}\PYGZus{}be32 skc\PYGZus{}daddr;
      \PYGZus{}\PYGZus{}be32 skc\PYGZus{}rcv\PYGZus{}saddr;
    \PYGZcb{};
  \PYGZcb{};
  union \PYGZob{}
    unsigned int    skc\PYGZus{}hash;
    \PYGZus{}\PYGZus{}u16 skc\PYGZus{}u16hashes[2];
  \PYGZcb{};
  union \PYGZob{}
    \PYGZus{}\PYGZus{}portpair skc\PYGZus{}portpair;
    struct \PYGZob{}
      \PYGZus{}\PYGZus{}be16 skc\PYGZus{}dport;
      \PYGZus{}\PYGZus{}u16 skc\PYGZus{}num;
    \PYGZcb{};
  \PYGZcb{};
  unsigned short          skc\PYGZus{}family;
  volatile unsigned char  skc\PYGZus{}state;
  unsigned char           skc\PYGZus{}reuse:4;
  unsigned char           skc\PYGZus{}reuseport:1;
  unsigned char           skc\PYGZus{}ipv6only:1;
  unsigned char           skc\PYGZus{}net\PYGZus{}refcnt:1;
  int skc\PYGZus{}bound\PYGZus{}dev\PYGZus{}if;
  union \PYGZob{}
    struct hlist\PYGZus{}node       skc\PYGZus{}bind\PYGZus{}node;
    struct hlist\PYGZus{}node       skc\PYGZus{}portaddr\PYGZus{}node;
  \PYGZcb{};
  struct proto            *skc\PYGZus{}prot;
  possible\PYGZus{}net\PYGZus{}t skc\PYGZus{}net;
\PYGZsh{}if IS\PYGZus{}ENABLED(CONFIG\PYGZus{}IPV6);
  struct in6\PYGZus{}addr         skc\PYGZus{}v6\PYGZus{}daddr;
  struct in6\PYGZus{}addr         skc\PYGZus{}v6\PYGZus{}rcv\PYGZus{}saddr;
\PYGZsh{}endif;
  atomic64\PYGZus{}t skc\PYGZus{}cookie;
  union \PYGZob{}
    unsigned long   skc\PYGZus{}flags;
    struct sock     *skc\PYGZus{}listener;
    struct inet\PYGZus{}timewait\PYGZus{}death\PYGZus{}row *skc\PYGZus{}tw\PYGZus{}dr;
  \PYGZcb{};
  union \PYGZob{}
    struct hlist\PYGZus{}node       skc\PYGZus{}node;
    struct hlist\PYGZus{}nulls\PYGZus{}node skc\PYGZus{}nulls\PYGZus{}node;
  \PYGZcb{};
  int skc\PYGZus{}tx\PYGZus{}queue\PYGZus{}mapping;
  union \PYGZob{}
    int skc\PYGZus{}incoming\PYGZus{}cpu;
    u32 skc\PYGZus{}rcv\PYGZus{}wnd;
    u32 skc\PYGZus{}tw\PYGZus{}rcv\PYGZus{}nxt;
  \PYGZcb{};
  refcount\PYGZus{}t skc\PYGZus{}refcnt;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{\{unnamed\_struct\}}}] \leavevmode
anonymous

\item[{\code{skc\_daddr}}] \leavevmode
Foreign IPv4 addr

\item[{\code{skc\_rcv\_saddr}}] \leavevmode
Bound local IPv4 addr

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{skc\_hash}}] \leavevmode
hash value used with various protocol lookup tables

\item[{\code{skc\_u16hashes}}] \leavevmode
two u16 hash values used by UDP lookup tables

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{\{unnamed\_struct\}}}] \leavevmode
anonymous

\item[{\code{skc\_dport}}] \leavevmode
placeholder for inet\_dport/tw\_dport

\item[{\code{skc\_num}}] \leavevmode
placeholder for inet\_num/tw\_num

\item[{\code{skc\_family}}] \leavevmode
network address family

\item[{\code{skc\_state}}] \leavevmode
Connection state

\item[{\code{skc\_reuse}}] \leavevmode
\code{SO\_REUSEADDR} setting

\item[{\code{skc\_reuseport}}] \leavevmode
\code{SO\_REUSEPORT} setting

\item[{\code{skc\_bound\_dev\_if}}] \leavevmode
bound device index if != 0

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{skc\_bind\_node}}] \leavevmode
bind hash linkage for various protocol lookup tables

\item[{\code{skc\_portaddr\_node}}] \leavevmode
second hash linkage for UDP/UDP-Lite protocol

\item[{\code{skc\_prot}}] \leavevmode
protocol handlers inside a network family

\item[{\code{skc\_net}}] \leavevmode
reference to the network namespace of this socket

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{skc\_flags}}] \leavevmode
place holder for sk\_flags
\code{SO\_LINGER} (l\_onoff), \code{SO\_BROADCAST}, \code{SO\_KEEPALIVE},
\code{SO\_OOBINLINE} settings, \code{SO\_TIMESTAMPING} settings

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{skc\_node}}] \leavevmode
main hash linkage for various protocol lookup tables

\item[{\code{skc\_nulls\_node}}] \leavevmode
main hash linkage for TCP/UDP/UDP-Lite protocol

\item[{\code{skc\_tx\_queue\_mapping}}] \leavevmode
tx queue number for this connection

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{skc\_incoming\_cpu}}] \leavevmode
record/match cpu processing incoming packets

\item[{\code{skc\_refcnt}}] \leavevmode
reference count

\end{description}

\textbf{Description}
\begin{quote}

This is the minimal network layer representation of sockets, the header
for struct sock and struct inet\_timewait\_sock.
\end{quote}
\index{sock (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sock}\pysigline{struct \bfcode{sock}}
network layer representation of sockets

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct sock \PYGZob{}
  struct sock\PYGZus{}common      \PYGZus{}\PYGZus{}sk\PYGZus{}common;
\PYGZsh{}define sk\PYGZus{}node                 \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}node;
\PYGZsh{}define sk\PYGZus{}nulls\PYGZus{}node           \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}nulls\PYGZus{}node;
\PYGZsh{}define sk\PYGZus{}refcnt               \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}refcnt;
\PYGZsh{}define sk\PYGZus{}tx\PYGZus{}queue\PYGZus{}mapping     \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}tx\PYGZus{}queue\PYGZus{}mapping;
\PYGZsh{}define sk\PYGZus{}dontcopy\PYGZus{}begin       \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}dontcopy\PYGZus{}begin;
\PYGZsh{}define sk\PYGZus{}dontcopy\PYGZus{}end         \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}dontcopy\PYGZus{}end;
\PYGZsh{}define sk\PYGZus{}hash                 \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}hash;
\PYGZsh{}define sk\PYGZus{}portpair             \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}portpair;
\PYGZsh{}define sk\PYGZus{}num                  \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}num;
\PYGZsh{}define sk\PYGZus{}dport                \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}dport;
\PYGZsh{}define sk\PYGZus{}addrpair             \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}addrpair;
\PYGZsh{}define sk\PYGZus{}daddr                \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}daddr;
\PYGZsh{}define sk\PYGZus{}rcv\PYGZus{}saddr            \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}rcv\PYGZus{}saddr;
\PYGZsh{}define sk\PYGZus{}family               \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}family;
\PYGZsh{}define sk\PYGZus{}state                \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}state;
\PYGZsh{}define sk\PYGZus{}reuse                \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}reuse;
\PYGZsh{}define sk\PYGZus{}reuseport            \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}reuseport;
\PYGZsh{}define sk\PYGZus{}ipv6only             \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}ipv6only;
\PYGZsh{}define sk\PYGZus{}net\PYGZus{}refcnt           \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}net\PYGZus{}refcnt;
\PYGZsh{}define sk\PYGZus{}bound\PYGZus{}dev\PYGZus{}if         \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}bound\PYGZus{}dev\PYGZus{}if;
\PYGZsh{}define sk\PYGZus{}bind\PYGZus{}node            \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}bind\PYGZus{}node;
\PYGZsh{}define sk\PYGZus{}prot                 \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}prot;
\PYGZsh{}define sk\PYGZus{}net                  \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}net;
\PYGZsh{}define sk\PYGZus{}v6\PYGZus{}daddr             \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}v6\PYGZus{}daddr;
\PYGZsh{}define sk\PYGZus{}v6\PYGZus{}rcv\PYGZus{}saddr \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}v6\PYGZus{}rcv\PYGZus{}saddr;
\PYGZsh{}define sk\PYGZus{}cookie               \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}cookie;
\PYGZsh{}define sk\PYGZus{}incoming\PYGZus{}cpu         \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}incoming\PYGZus{}cpu;
\PYGZsh{}define sk\PYGZus{}flags                \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}flags;
\PYGZsh{}define sk\PYGZus{}rxhash               \PYGZus{}\PYGZus{}sk\PYGZus{}common.skc\PYGZus{}rxhash;
  socket\PYGZus{}lock\PYGZus{}t sk\PYGZus{}lock;
  atomic\PYGZus{}t sk\PYGZus{}drops;
  int sk\PYGZus{}rcvlowat;
  struct sk\PYGZus{}buff\PYGZus{}head     sk\PYGZus{}error\PYGZus{}queue;
  struct sk\PYGZus{}buff\PYGZus{}head     sk\PYGZus{}receive\PYGZus{}queue;
  struct \PYGZob{}
    atomic\PYGZus{}t rmem\PYGZus{}alloc;
    int len;
    struct sk\PYGZus{}buff  *head;
    struct sk\PYGZus{}buff  *tail;
  \PYGZcb{} sk\PYGZus{}backlog;
\PYGZsh{}define sk\PYGZus{}rmem\PYGZus{}alloc sk\PYGZus{}backlog.rmem\PYGZus{}alloc;
  int sk\PYGZus{}forward\PYGZus{}alloc;
\PYGZsh{}ifdef CONFIG\PYGZus{}NET\PYGZus{}RX\PYGZus{}BUSY\PYGZus{}POLL;
  unsigned int            sk\PYGZus{}ll\PYGZus{}usec;
  unsigned int            sk\PYGZus{}napi\PYGZus{}id;
\PYGZsh{}endif;
  int sk\PYGZus{}rcvbuf;
  struct sk\PYGZus{}filter \PYGZus{}\PYGZus{}rcu  *sk\PYGZus{}filter;
  union \PYGZob{}
    struct socket\PYGZus{}wq \PYGZus{}\PYGZus{}rcu  *sk\PYGZus{}wq;
    struct socket\PYGZus{}wq        *sk\PYGZus{}wq\PYGZus{}raw;
  \PYGZcb{};
\PYGZsh{}ifdef CONFIG\PYGZus{}XFRM;
  struct xfrm\PYGZus{}policy \PYGZus{}\PYGZus{}rcu *sk\PYGZus{}policy[2];
\PYGZsh{}endif;
  struct dst\PYGZus{}entry        *sk\PYGZus{}rx\PYGZus{}dst;
  struct dst\PYGZus{}entry \PYGZus{}\PYGZus{}rcu  *sk\PYGZus{}dst\PYGZus{}cache;
  atomic\PYGZus{}t sk\PYGZus{}omem\PYGZus{}alloc;
  int sk\PYGZus{}sndbuf;
  int sk\PYGZus{}wmem\PYGZus{}queued;
  refcount\PYGZus{}t sk\PYGZus{}wmem\PYGZus{}alloc;
  unsigned long           sk\PYGZus{}tsq\PYGZus{}flags;
  union \PYGZob{}
    struct sk\PYGZus{}buff  *sk\PYGZus{}send\PYGZus{}head;
    struct rb\PYGZus{}root  tcp\PYGZus{}rtx\PYGZus{}queue;
  \PYGZcb{};
  struct sk\PYGZus{}buff\PYGZus{}head     sk\PYGZus{}write\PYGZus{}queue;
  \PYGZus{}\PYGZus{}s32 sk\PYGZus{}peek\PYGZus{}off;
  int sk\PYGZus{}write\PYGZus{}pending;
  \PYGZus{}\PYGZus{}u32 sk\PYGZus{}dst\PYGZus{}pending\PYGZus{}confirm;
  u32 sk\PYGZus{}pacing\PYGZus{}status;
  long sk\PYGZus{}sndtimeo;
  struct timer\PYGZus{}list       sk\PYGZus{}timer;
  \PYGZus{}\PYGZus{}u32 sk\PYGZus{}priority;
  \PYGZus{}\PYGZus{}u32 sk\PYGZus{}mark;
  u32 sk\PYGZus{}pacing\PYGZus{}rate;
  u32 sk\PYGZus{}max\PYGZus{}pacing\PYGZus{}rate;
  struct page\PYGZus{}frag        sk\PYGZus{}frag;
  netdev\PYGZus{}features\PYGZus{}t sk\PYGZus{}route\PYGZus{}caps;
  netdev\PYGZus{}features\PYGZus{}t sk\PYGZus{}route\PYGZus{}nocaps;
  int sk\PYGZus{}gso\PYGZus{}type;
  unsigned int            sk\PYGZus{}gso\PYGZus{}max\PYGZus{}size;
  gfp\PYGZus{}t sk\PYGZus{}allocation;
  \PYGZus{}\PYGZus{}u32 sk\PYGZus{}txhash;
  unsigned int            \PYGZus{}\PYGZus{}sk\PYGZus{}flags\PYGZus{}offset[0];
\PYGZsh{}ifdef \PYGZus{}\PYGZus{}BIG\PYGZus{}ENDIAN\PYGZus{}BITFIELD;
\PYGZsh{}define SK\PYGZus{}FL\PYGZus{}PROTO\PYGZus{}SHIFT  16;
\PYGZsh{}define SK\PYGZus{}FL\PYGZus{}PROTO\PYGZus{}MASK   0x00ff0000;
\PYGZsh{}define SK\PYGZus{}FL\PYGZus{}TYPE\PYGZus{}SHIFT   0;
\PYGZsh{}define SK\PYGZus{}FL\PYGZus{}TYPE\PYGZus{}MASK    0x0000ffff;
\PYGZsh{}else;
\PYGZsh{}define SK\PYGZus{}FL\PYGZus{}PROTO\PYGZus{}SHIFT  8;
\PYGZsh{}define SK\PYGZus{}FL\PYGZus{}PROTO\PYGZus{}MASK   0x0000ff00;
\PYGZsh{}define SK\PYGZus{}FL\PYGZus{}TYPE\PYGZus{}SHIFT   16;
\PYGZsh{}define SK\PYGZus{}FL\PYGZus{}TYPE\PYGZus{}MASK    0xffff0000;
\PYGZsh{}endif;
  unsigned int            sk\PYGZus{}padding : 1,sk\PYGZus{}kern\PYGZus{}sock : 1,sk\PYGZus{}no\PYGZus{}check\PYGZus{}tx : 1,sk\PYGZus{}no\PYGZus{}check\PYGZus{}rx : 1,sk\PYGZus{}userlocks : 4,sk\PYGZus{}protocol  : 8, sk\PYGZus{}type      : 16;
\PYGZsh{}define SK\PYGZus{}PROTOCOL\PYGZus{}MAX U8\PYGZus{}MAX;
  u16 sk\PYGZus{}gso\PYGZus{}max\PYGZus{}segs;
  u8 sk\PYGZus{}pacing\PYGZus{}shift;
  unsigned long           sk\PYGZus{}lingertime;
  struct proto            *sk\PYGZus{}prot\PYGZus{}creator;
  rwlock\PYGZus{}t sk\PYGZus{}callback\PYGZus{}lock;
  int sk\PYGZus{}err, sk\PYGZus{}err\PYGZus{}soft;
  u32 sk\PYGZus{}ack\PYGZus{}backlog;
  u32 sk\PYGZus{}max\PYGZus{}ack\PYGZus{}backlog;
  kuid\PYGZus{}t sk\PYGZus{}uid;
  struct pid              *sk\PYGZus{}peer\PYGZus{}pid;
  const struct cred       *sk\PYGZus{}peer\PYGZus{}cred;
  long sk\PYGZus{}rcvtimeo;
  ktime\PYGZus{}t sk\PYGZus{}stamp;
  u16 sk\PYGZus{}tsflags;
  u8 sk\PYGZus{}shutdown;
  u32 sk\PYGZus{}tskey;
  atomic\PYGZus{}t sk\PYGZus{}zckey;
  struct socket           *sk\PYGZus{}socket;
  void *sk\PYGZus{}user\PYGZus{}data;
\PYGZsh{}ifdef CONFIG\PYGZus{}SECURITY;
  void *sk\PYGZus{}security;
\PYGZsh{}endif;
  struct sock\PYGZus{}cgroup\PYGZus{}data sk\PYGZus{}cgrp\PYGZus{}data;
  struct mem\PYGZus{}cgroup       *sk\PYGZus{}memcg;
  void (*sk\PYGZus{}state\PYGZus{}change)(struct sock *sk);
  void (*sk\PYGZus{}data\PYGZus{}ready)(struct sock *sk);
  void (*sk\PYGZus{}write\PYGZus{}space)(struct sock *sk);
  void (*sk\PYGZus{}error\PYGZus{}report)(struct sock *sk);
  int (*sk\PYGZus{}backlog\PYGZus{}rcv)(struct sock *sk, struct sk\PYGZus{}buff *skb);
  void (*sk\PYGZus{}destruct)(struct sock *sk);
  struct sock\PYGZus{}reuseport \PYGZus{}\PYGZus{}rcu     *sk\PYGZus{}reuseport\PYGZus{}cb;
  struct rcu\PYGZus{}head         sk\PYGZus{}rcu;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{\_\_sk\_common}}] \leavevmode
shared layout with inet\_timewait\_sock

\item[{\code{sk\_lock}}] \leavevmode
synchronizer

\item[{\code{sk\_drops}}] \leavevmode
raw/udp drops counter

\item[{\code{sk\_rcvlowat}}] \leavevmode
\code{SO\_RCVLOWAT} setting

\item[{\code{sk\_error\_queue}}] \leavevmode
rarely used

\item[{\code{sk\_receive\_queue}}] \leavevmode
incoming packets

\item[{\code{sk\_backlog}}] \leavevmode
always used with the per-socket spinlock held

\item[{\code{sk\_forward\_alloc}}] \leavevmode
space allocated forward

\item[{\code{sk\_ll\_usec}}] \leavevmode
usecs to busypoll when there is no data

\item[{\code{sk\_napi\_id}}] \leavevmode
id of the last napi context to receive data for sk

\item[{\code{sk\_rcvbuf}}] \leavevmode
size of receive buffer in bytes

\item[{\code{sk\_filter}}] \leavevmode
socket filtering instructions

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{sk\_wq}}] \leavevmode
sock wait queue and async head

\item[{\code{sk\_policy}}] \leavevmode
flow policy

\item[{\code{sk\_rx\_dst}}] \leavevmode
receive input route used by early demux

\item[{\code{sk\_dst\_cache}}] \leavevmode
destination cache

\item[{\code{sk\_omem\_alloc}}] \leavevmode
``o'' is ``option'' or ``other''

\item[{\code{sk\_sndbuf}}] \leavevmode
size of send buffer in bytes

\item[{\code{sk\_wmem\_queued}}] \leavevmode
persistent queue size

\item[{\code{sk\_wmem\_alloc}}] \leavevmode
transmit queue bytes committed

\item[{\code{sk\_tsq\_flags}}] \leavevmode
TCP Small Queues flags

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{sk\_send\_head}}] \leavevmode
front of stuff to transmit

\item[{\code{sk\_write\_queue}}] \leavevmode
Packet sending queue

\item[{\code{sk\_peek\_off}}] \leavevmode
current peek\_offset value

\item[{\code{sk\_write\_pending}}] \leavevmode
a write to stream socket waits to start

\item[{\code{sk\_dst\_pending\_confirm}}] \leavevmode
need to confirm neighbour

\item[{\code{sk\_pacing\_status}}] \leavevmode
Pacing status (requested, handled by sch\_fq)

\item[{\code{sk\_sndtimeo}}] \leavevmode
\code{SO\_SNDTIMEO} setting

\item[{\code{sk\_timer}}] \leavevmode
sock cleanup timer

\item[{\code{sk\_priority}}] \leavevmode
\code{SO\_PRIORITY} setting

\item[{\code{sk\_mark}}] \leavevmode
generic packet mark

\item[{\code{sk\_pacing\_rate}}] \leavevmode
Pacing rate (if supported by transport/packet scheduler)

\item[{\code{sk\_max\_pacing\_rate}}] \leavevmode
Maximum pacing rate (\code{SO\_MAX\_PACING\_RATE})

\item[{\code{sk\_frag}}] \leavevmode
cached page frag

\item[{\code{sk\_route\_caps}}] \leavevmode
route capabilities (e.g. \code{NETIF\_F\_TSO})

\item[{\code{sk\_route\_nocaps}}] \leavevmode
forbidden route capabilities (e.g NETIF\_F\_GSO\_MASK)

\item[{\code{sk\_gso\_type}}] \leavevmode
GSO type (e.g. \code{SKB\_GSO\_TCPV4})

\item[{\code{sk\_gso\_max\_size}}] \leavevmode
Maximum GSO segment size to build

\item[{\code{sk\_allocation}}] \leavevmode
allocation mode

\item[{\code{sk\_txhash}}] \leavevmode
computed flow hash for use on transmit

\item[{\code{\_\_sk\_flags\_offset}}] \leavevmode
empty field used to determine location of bitfield

\item[{\code{sk\_padding}}] \leavevmode
unused element for alignment

\item[{\code{sk\_kern\_sock}}] \leavevmode
True if sock is using kernel lock classes

\item[{\code{sk\_no\_check\_tx}}] \leavevmode
\code{SO\_NO\_CHECK} setting, set checksum in TX packets

\item[{\code{sk\_no\_check\_rx}}] \leavevmode
allow zero checksum in RX packets

\item[{\code{sk\_userlocks}}] \leavevmode
\code{SO\_SNDBUF} and \code{SO\_RCVBUF} settings

\item[{\code{sk\_protocol}}] \leavevmode
which protocol this socket belongs in this network family

\item[{\code{sk\_type}}] \leavevmode
socket type (\code{SOCK\_STREAM}, etc)

\item[{\code{sk\_gso\_max\_segs}}] \leavevmode
Maximum number of GSO segments

\item[{\code{sk\_pacing\_shift}}] \leavevmode
scaling factor for TCP Small Queues

\item[{\code{sk\_lingertime}}] \leavevmode
\code{SO\_LINGER} l\_linger setting

\item[{\code{sk\_prot\_creator}}] \leavevmode
sk\_prot of original sock creator (see ipv6\_setsockopt,
IPV6\_ADDRFORM for instance)

\item[{\code{sk\_callback\_lock}}] \leavevmode
used with the callbacks in the end of this struct

\item[{\code{sk\_err}}] \leavevmode
last error

\item[{\code{sk\_err\_soft}}] \leavevmode
errors that don't cause failure but are the cause of a
persistent failure not just `timed out'

\item[{\code{sk\_ack\_backlog}}] \leavevmode
current listen backlog

\item[{\code{sk\_max\_ack\_backlog}}] \leavevmode
listen backlog set in \code{listen()}

\item[{\code{sk\_uid}}] \leavevmode
user id of owner

\item[{\code{sk\_peer\_pid}}] \leavevmode
\code{struct pid} for this socket's peer

\item[{\code{sk\_peer\_cred}}] \leavevmode
\code{SO\_PEERCRED} setting

\item[{\code{sk\_rcvtimeo}}] \leavevmode
\code{SO\_RCVTIMEO} setting

\item[{\code{sk\_stamp}}] \leavevmode
time stamp of last packet received

\item[{\code{sk\_tsflags}}] \leavevmode
SO\_TIMESTAMPING socket options

\item[{\code{sk\_shutdown}}] \leavevmode
mask of \code{SEND\_SHUTDOWN} and/or \code{RCV\_SHUTDOWN}

\item[{\code{sk\_tskey}}] \leavevmode
counter to disambiguate concurrent tstamp requests

\item[{\code{sk\_zckey}}] \leavevmode
counter to order MSG\_ZEROCOPY notifications

\item[{\code{sk\_socket}}] \leavevmode
Identd and reporting IO signals

\item[{\code{sk\_user\_data}}] \leavevmode
RPC layer private data

\item[{\code{sk\_security}}] \leavevmode
used by security modules

\item[{\code{sk\_cgrp\_data}}] \leavevmode
cgroup data for this cgroup

\item[{\code{sk\_memcg}}] \leavevmode
this socket's memory cgroup association

\item[{\code{sk\_state\_change}}] \leavevmode
callback to indicate change in the state of the sock

\item[{\code{sk\_data\_ready}}] \leavevmode
callback to indicate there is data to be processed

\item[{\code{sk\_write\_space}}] \leavevmode
callback to indicate there is bf sending space available

\item[{\code{sk\_error\_report}}] \leavevmode
callback to indicate errors (e.g. \code{MSG\_ERRQUEUE})

\item[{\code{sk\_backlog\_rcv}}] \leavevmode
callback to process the backlog

\item[{\code{sk\_destruct}}] \leavevmode
called at sock freeing time, i.e. when all refcnt == 0

\item[{\code{sk\_reuseport\_cb}}] \leavevmode
reuseport group container

\item[{\code{sk\_rcu}}] \leavevmode
used during RCU grace period

\end{description}
\index{sk\_for\_each\_entry\_offset\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_for_each_entry_offset_rcu}\pysiglinewithargsret{\bfcode{sk\_for\_each\_entry\_offset\_rcu}}{\emph{tpos}, \emph{pos}, \emph{head}, \emph{offset}}{}
iterate over a list at a given struct offset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{tpos}}] \leavevmode
the type * to use as a loop cursor.

\item[{\code{pos}}] \leavevmode
the \code{struct hlist\_node} to use as a loop cursor.

\item[{\code{head}}] \leavevmode
the head for your list.

\item[{\code{offset}}] \leavevmode
offset of hlist\_node within the struct.

\end{description}
\index{unlock\_sock\_fast (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.unlock_sock_fast}\pysiglinewithargsret{void \bfcode{unlock\_sock\_fast}}{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, bool\emph{slow}}{}
complement of lock\_sock\_fast

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sock * sk}}] \leavevmode
socket

\item[{\code{bool slow}}] \leavevmode
slow mode

\end{description}

\textbf{Description}

fast unlock socket for user context.
If slow mode is on, we call regular \code{release\_sock()}
\index{sk\_wmem\_alloc\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_wmem_alloc_get}\pysiglinewithargsret{int \bfcode{sk\_wmem\_alloc\_get}}{const struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}}{}
returns write allocations

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sock * sk}}] \leavevmode
socket

\end{description}

\textbf{Description}

Returns sk\_wmem\_alloc minus initial offset of one
\index{sk\_rmem\_alloc\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_rmem_alloc_get}\pysiglinewithargsret{int \bfcode{sk\_rmem\_alloc\_get}}{const struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}}{}
returns read allocations

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sock * sk}}] \leavevmode
socket

\end{description}

\textbf{Description}

Returns sk\_rmem\_alloc
\index{sk\_has\_allocations (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_has_allocations}\pysiglinewithargsret{bool \bfcode{sk\_has\_allocations}}{const struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}}{}
check if allocations are outstanding

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sock * sk}}] \leavevmode
socket

\end{description}

\textbf{Description}

Returns true if socket has write or read allocations
\index{skwq\_has\_sleeper (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skwq_has_sleeper}\pysiglinewithargsret{bool \bfcode{skwq\_has\_sleeper}}{struct socket\_wq *\emph{wq}}{}
check if there are any waiting processes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct socket\_wq * wq}}] \leavevmode
struct socket\_wq

\end{description}

\textbf{Description}

Returns true if socket\_wq has waiting processes

The purpose of the skwq\_has\_sleeper and sock\_poll\_wait is to wrap the memory
barrier call. They were added due to the race found within the tcp code.

Consider following tcp code paths:

\begin{Verbatim}[commandchars=\\\{\}]
CPU1                CPU2
sys\PYGZus{}select          receive packet
...                 ...
\PYGZus{}\PYGZus{}add\PYGZus{}wait\PYGZus{}queue    update tp\PYGZhy{}\PYGZgt{}rcv\PYGZus{}nxt
...                 ...
tp\PYGZhy{}\PYGZgt{}rcv\PYGZus{}nxt check   sock\PYGZus{}def\PYGZus{}readable
...                 \PYGZob{}
schedule               :c:func:{}`rcu\PYGZus{}read\PYGZus{}lock(){}`;
                       wq = rcu\PYGZus{}dereference(sk\PYGZhy{}\PYGZgt{}sk\PYGZus{}wq);
                       if (wq \PYGZam{}\PYGZam{} waitqueue\PYGZus{}active(:c:type:{}`wq\PYGZhy{}\PYGZgt{}wait \PYGZlt{}wq\PYGZgt{}{}`))
                           wake\PYGZus{}up\PYGZus{}interruptible(:c:type:{}`wq\PYGZhy{}\PYGZgt{}wait \PYGZlt{}wq\PYGZgt{}{}`)
                       ...
                    \PYGZcb{}
\end{Verbatim}

The race for tcp fires when the \_\_add\_wait\_queue changes done by CPU1 stay
in its cache, and so does the tp-\textgreater{}rcv\_nxt update on CPU2 side.  The CPU1
could then endup calling schedule and sleep forever if there are no more
data on the socket.
\index{sock\_poll\_wait (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sock_poll_wait}\pysiglinewithargsret{void \bfcode{sock\_poll\_wait}}{struct file *\emph{filp}, wait\_queue\_head\_t *\emph{wait\_address}, poll\_table *\emph{p}}{}
place memory barrier behind the poll\_wait call.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * filp}}] \leavevmode
file

\item[{\code{wait\_queue\_head\_t * wait\_address}}] \leavevmode
socket wait queue

\item[{\code{poll\_table * p}}] \leavevmode
poll\_table

\end{description}

\textbf{Description}

See the comments in the wq\_has\_sleeper function.
\index{sk\_page\_frag (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_page_frag}\pysiglinewithargsret{struct page\_frag * \bfcode{sk\_page\_frag}}{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}}{}
return an appropriate page\_frag

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sock * sk}}] \leavevmode
socket

\end{description}

\textbf{Description}

If socket allocation mode allows current thread to sleep, it means its
safe to use the per task page\_frag instead of the per socket one.
\index{sock\_tx\_timestamp (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sock_tx_timestamp}\pysiglinewithargsret{void \bfcode{sock\_tx\_timestamp}}{const struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, \_\_u16\emph{tsflags}, \_\_u8 *\emph{tx\_flags}}{}
checks whether the outgoing packet is to be time stamped

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sock * sk}}] \leavevmode
socket sending this packet

\item[{\code{\_\_u16 tsflags}}] \leavevmode
timestamping flags to use

\item[{\code{\_\_u8 * tx\_flags}}] \leavevmode
completed with instructions for time stamping

\end{description}

\textbf{Note}

callers should take care of initial \code{*tx\_flags} value (usually 0)
\index{sk\_eat\_skb (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_eat_skb}\pysiglinewithargsret{void \bfcode{sk\_eat\_skb}}{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
Release a skb if it is no longer needed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sock * sk}}] \leavevmode
socket to eat this skb from

\item[{\code{struct sk\_buff * skb}}] \leavevmode
socket buffer to eat

\end{description}

\textbf{Description}

This routine must be called with interrupts disabled or with the socket
locked so that the sk\_buff queue operation is ok.
\index{sockfd\_lookup (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sockfd_lookup}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.socket]{\emph{socket}}} * \bfcode{sockfd\_lookup}}{int\emph{fd}, int *\emph{err}}{}
Go from a file number to its socket slot

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int fd}}] \leavevmode
file handle

\item[{\code{int * err}}] \leavevmode
pointer to an error code return

\end{description}

\textbf{Description}
\begin{quote}

The file handle passed in is locked and the socket it is bound
to is returned. If an error occurs the err pointer is overwritten
with a negative errno code and NULL is returned. The function checks
for both invalid handles and passing a handle which is not a socket.

On a success the socket object pointer is returned.
\end{quote}
\index{sock\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sock_alloc}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.socket]{\emph{socket}}} * \bfcode{sock\_alloc}}{void}{}
allocate a socket

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}
\begin{quote}

Allocate a new inode and socket object. The two are bound together
and initialised. The socket is then returned. If we are out of inodes
NULL is returned.
\end{quote}
\index{sock\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sock_release}\pysiglinewithargsret{void \bfcode{sock\_release}}{struct {\hyperref[networking/kapi:c.socket]{\emph{socket}}} *\emph{sock}}{}
close a socket

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct socket * sock}}] \leavevmode
socket to close

\end{description}

\textbf{Description}
\begin{quote}

The socket is released from the protocol stack if it has a release
callback, and the inode is then released if the socket is bound to
an inode not a file.
\end{quote}
\index{kernel\_recvmsg (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.kernel_recvmsg}\pysiglinewithargsret{int \bfcode{kernel\_recvmsg}}{struct {\hyperref[networking/kapi:c.socket]{\emph{socket}}} *\emph{sock}, struct msghdr *\emph{msg}, struct kvec *\emph{vec}, size\_t\emph{num}, size\_t\emph{size}, int\emph{flags}}{}
Receive a message from a socket (kernel space)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct socket * sock}}] \leavevmode
The socket to receive the message from

\item[{\code{struct msghdr * msg}}] \leavevmode
Received message

\item[{\code{struct kvec * vec}}] \leavevmode
Input s/g array for message data

\item[{\code{size\_t num}}] \leavevmode
Size of input s/g array

\item[{\code{size\_t size}}] \leavevmode
Number of bytes to read

\item[{\code{int flags}}] \leavevmode
Message flags (MSG\_DONTWAIT, etc...)

\end{description}

\textbf{Description}

On return the msg structure contains the scatter/gather array passed in the
vec argument. The array is modified so that it consists of the unfilled
portion of the original array.

The returned value is the total number of bytes received, or an error.
\index{sock\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sock_register}\pysiglinewithargsret{int \bfcode{sock\_register}}{const struct net\_proto\_family *\emph{ops}}{}
add a socket protocol handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct net\_proto\_family * ops}}] \leavevmode
description of protocol

\end{description}

\textbf{Description}
\begin{quote}

This function is called by a protocol handler that wants to
advertise its address family, and have it linked into the
socket interface. The value ops-\textgreater{}family corresponds to the
socket system call protocol family.
\end{quote}
\index{sock\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sock_unregister}\pysiglinewithargsret{void \bfcode{sock\_unregister}}{int\emph{family}}{}
remove a protocol handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int family}}] \leavevmode
protocol family to remove

\end{description}

\textbf{Description}
\begin{quote}

This function is called by a protocol handler that wants to
remove its address family, and have it unlinked from the
new socket creation.

If protocol handler is a module, then it can use module reference
counts to protect against new references. If protocol handler is not
a module then it needs to provide its own protection in
the ops-\textgreater{}create routine.
\end{quote}
\index{\_\_alloc\_skb (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__alloc_skb}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{\_\_alloc\_skb}}{unsigned int\emph{size}, gfp\_t\emph{gfp\_mask}, int\emph{flags}, int\emph{node}}{}
allocate a network buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int size}}] \leavevmode
size to allocate

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
allocation mask

\item[{\code{int flags}}] \leavevmode
If SKB\_ALLOC\_FCLONE is set, allocate from fclone cache
instead of head cache and allocate a cloned (child) skb.
If SKB\_ALLOC\_RX is set, \_\_GFP\_MEMALLOC will be used for
allocations in case the data is required for writeback

\item[{\code{int node}}] \leavevmode
numa node to allocate memory on

\end{description}

\textbf{Description}
\begin{quote}

Allocate a new {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}}. The returned buffer has no headroom and a
tail room of at least size bytes. The object has a reference count
of one. The return is the buffer. On a failure the return is \code{NULL}.

Buffers may only be allocated from interrupts using a \textbf{gfp\_mask} of
\code{GFP\_ATOMIC}.
\end{quote}
\index{netdev\_alloc\_frag (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_alloc_frag}\pysiglinewithargsret{void * \bfcode{netdev\_alloc\_frag}}{unsigned int\emph{fragsz}}{}
allocate a page fragment

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int fragsz}}] \leavevmode
fragment size

\end{description}

\textbf{Description}

Allocates a frag from a page for receive buffer.
Uses GFP\_ATOMIC allocations.
\index{\_\_netdev\_alloc\_skb (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__netdev_alloc_skb}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{\_\_netdev\_alloc\_skb}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, unsigned int\emph{len}, gfp\_t\emph{gfp\_mask}}{}
allocate an skbuff for rx on a specific device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device to receive on

\item[{\code{unsigned int len}}] \leavevmode
length to allocate

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
get\_free\_pages mask, passed to alloc\_skb

\end{description}

\textbf{Description}
\begin{quote}

Allocate a new {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} and assign it a usage count of one. The
buffer has NET\_SKB\_PAD headroom built in. Users should allocate
the headroom they think they need without accounting for the
built in space. The built in space is used for optimisations.

\code{NULL} is returned if there is no free memory.
\end{quote}
\index{\_\_napi\_alloc\_skb (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__napi_alloc_skb}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{\_\_napi\_alloc\_skb}}{struct napi\_struct *\emph{napi}, unsigned int\emph{len}, gfp\_t\emph{gfp\_mask}}{}
allocate skbuff for rx in a specific NAPI instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct napi\_struct * napi}}] \leavevmode
napi instance this buffer was allocated for

\item[{\code{unsigned int len}}] \leavevmode
length to allocate

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
get\_free\_pages mask, passed to alloc\_skb and alloc\_pages

\end{description}

\textbf{Description}
\begin{quote}

Allocate a new sk\_buff for use in NAPI receive.  This buffer will
attempt to allocate the head from a special reserved region used
only for NAPI Rx allocation.  By doing this we can save several
CPU cycles by avoiding having to disable and re-enable IRQs.

\code{NULL} is returned if there is no free memory.
\end{quote}
\index{\_\_kfree\_skb (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__kfree_skb}\pysiglinewithargsret{void \bfcode{\_\_kfree\_skb}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
private function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer

\end{description}

\textbf{Description}
\begin{quote}

Free an sk\_buff. Release anything attached to the buffer.
Clean the state. This is an internal helper function. Users should
always call kfree\_skb
\end{quote}
\index{kfree\_skb (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.kfree_skb}\pysiglinewithargsret{void \bfcode{kfree\_skb}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
free an sk\_buff

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to free

\end{description}

\textbf{Description}
\begin{quote}

Drop a reference to the buffer and free it if the usage count has
hit zero.
\end{quote}
\index{skb\_tx\_error (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_tx_error}\pysiglinewithargsret{void \bfcode{skb\_tx\_error}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
report an sk\_buff xmit error

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer that triggered an error

\end{description}

\textbf{Description}
\begin{quote}

Report xmit error if a device callback is tracking this skb.
skb must be freed afterwards.
\end{quote}
\index{consume\_skb (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.consume_skb}\pysiglinewithargsret{void \bfcode{consume\_skb}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
free an skbuff

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to free

\end{description}

\textbf{Description}
\begin{quote}

Drop a ref to the buffer and free it if the usage count has hit zero
Functions identically to kfree\_skb, but kfree\_skb assumes that the frame
is being dropped after a failure and notes that
\end{quote}
\index{skb\_morph (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_morph}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_morph}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{dst}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{src}}{}
morph one skb into another

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * dst}}] \leavevmode
the skb to receive the contents

\item[{\code{struct sk\_buff * src}}] \leavevmode
the skb to supply the contents

\end{description}

\textbf{Description}
\begin{quote}

This is identical to skb\_clone except that the target skb is
supplied by the user.

The target skb is returned upon exit.
\end{quote}
\index{skb\_copy\_ubufs (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_copy_ubufs}\pysiglinewithargsret{int \bfcode{skb\_copy\_ubufs}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, gfp\_t\emph{gfp\_mask}}{}
copy userspace skb frags buffers to kernel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
the skb to modify

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
allocation priority

\end{description}

\textbf{Description}
\begin{quote}

This must be called on SKBTX\_DEV\_ZEROCOPY skb.
It will copy all frags into kernel and drop the reference
to userspace pages.

If this function is called from an interrupt \code{gfp\_mask()} must be
\code{GFP\_ATOMIC}.

Returns 0 on success or a negative error code on failure
to allocate kernel memory to copy to.
\end{quote}
\index{skb\_clone (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_clone}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_clone}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, gfp\_t\emph{gfp\_mask}}{}
duplicate an sk\_buff

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to clone

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
allocation priority

\end{description}

\textbf{Description}
\begin{quote}

Duplicate an {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}}. The new one is not owned by a socket. Both
copies share the same packet data but not structure. The new
buffer has a reference count of 1. If the allocation fails the
function returns \code{NULL} otherwise the new buffer is returned.

If this function is called from an interrupt \code{gfp\_mask()} must be
\code{GFP\_ATOMIC}.
\end{quote}
\index{skb\_copy (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_copy}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_copy}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, gfp\_t\emph{gfp\_mask}}{}
create private copy of an sk\_buff

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
buffer to copy

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
allocation priority

\end{description}

\textbf{Description}
\begin{quote}

Make a copy of both an {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} and its data. This is used when the
caller wishes to modify the data and needs a private copy of the
data to alter. Returns \code{NULL} on failure or the pointer to the buffer
on success. The returned buffer has a reference count of 1.

As by-product this function converts non-linear {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} to linear
one, so that {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} becomes completely private and caller is allowed
to modify all the data of returned buffer. This means that this
function is not recommended for use in circumstances when only
header is going to be modified. Use \code{pskb\_copy()} instead.
\end{quote}
\index{\_\_pskb\_copy\_fclone (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__pskb_copy_fclone}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{\_\_pskb\_copy\_fclone}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{headroom}, gfp\_t\emph{gfp\_mask}, bool\emph{fclone}}{}
create copy of an sk\_buff with private head.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to copy

\item[{\code{int headroom}}] \leavevmode
headroom of new skb

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
allocation priority

\item[{\code{bool fclone}}] \leavevmode
if true allocate the copy of the skb from the fclone
cache instead of the head cache; it is recommended to set this
to true for the cases where the copy will likely be cloned

\end{description}

\textbf{Description}
\begin{quote}

Make a copy of both an {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} and part of its data, located
in header. Fragmented data remain shared. This is used when
the caller wishes to modify only header of {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} and needs
private copy of the header to alter. Returns \code{NULL} on failure
or the pointer to the buffer on success.
The returned buffer has a reference count of 1.
\end{quote}
\index{pskb\_expand\_head (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.pskb_expand_head}\pysiglinewithargsret{int \bfcode{pskb\_expand\_head}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{nhead}, int\emph{ntail}, gfp\_t\emph{gfp\_mask}}{}
reallocate header of {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to reallocate

\item[{\code{int nhead}}] \leavevmode
room to add at head

\item[{\code{int ntail}}] \leavevmode
room to add at tail

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
allocation priority

\end{description}

\textbf{Description}
\begin{quote}

Expands (or creates identical copy, if \textbf{nhead} and \textbf{ntail} are zero)
header of \textbf{skb}. {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} itself is not changed. {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} MUST have
reference count of 1. Returns zero in the case of success or error,
if expansion failed. In the last case, {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} is not changed.

All the pointers pointing into skb header may change and must be
reloaded after call to this function.
\end{quote}
\index{skb\_copy\_expand (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_copy_expand}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_copy\_expand}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{newheadroom}, int\emph{newtailroom}, gfp\_t\emph{gfp\_mask}}{}
copy and expand sk\_buff

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
buffer to copy

\item[{\code{int newheadroom}}] \leavevmode
new free bytes at head

\item[{\code{int newtailroom}}] \leavevmode
new free bytes at tail

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
allocation priority

\end{description}

\textbf{Description}
\begin{quote}

Make a copy of both an {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} and its data and while doing so
allocate additional space.

This is used when the caller wishes to modify the data and needs a
private copy of the data to alter as well as more space for new fields.
Returns \code{NULL} on failure or the pointer to the buffer
on success. The returned buffer has a reference count of 1.

You must pass \code{GFP\_ATOMIC} as the allocation priority if this function
is called from an interrupt.
\end{quote}
\index{\_\_skb\_pad (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__skb_pad}\pysiglinewithargsret{int \bfcode{\_\_skb\_pad}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{pad}, bool\emph{free\_on\_error}}{}
zero pad the tail of an skb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to pad

\item[{\code{int pad}}] \leavevmode
space to pad

\item[{\code{bool free\_on\_error}}] \leavevmode
free buffer on error

\end{description}

\textbf{Description}
\begin{quote}

Ensure that a buffer is followed by a padding area that is zero
filled. Used by network drivers which may DMA or transfer data
beyond the buffer end onto the wire.

May return error in out of memory cases. The skb is freed on error
if \textbf{free\_on\_error} is true.
\end{quote}
\index{pskb\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.pskb_put}\pysiglinewithargsret{void * \bfcode{pskb\_put}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{tail}, int\emph{len}}{}
add data to the tail of a potentially fragmented buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
start of the buffer to use

\item[{\code{struct sk\_buff * tail}}] \leavevmode
tail fragment of the buffer to use

\item[{\code{int len}}] \leavevmode
amount of data to add

\end{description}

\textbf{Description}
\begin{quote}

This function extends the used data area of the potentially
fragmented buffer. \textbf{tail} must be the last fragment of \textbf{skb} -- or
\textbf{skb} itself. If this would exceed the total buffer size the kernel
will panic. A pointer to the first byte of the extra data is
returned.
\end{quote}
\index{skb\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_put}\pysiglinewithargsret{void * \bfcode{skb\_put}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{len}}{}
add data to a buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to use

\item[{\code{unsigned int len}}] \leavevmode
amount of data to add

\end{description}

\textbf{Description}
\begin{quote}

This function extends the used data area of the buffer. If this would
exceed the total buffer size the kernel will panic. A pointer to the
first byte of the extra data is returned.
\end{quote}
\index{skb\_push (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_push}\pysiglinewithargsret{void * \bfcode{skb\_push}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{len}}{}
add data to the start of a buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to use

\item[{\code{unsigned int len}}] \leavevmode
amount of data to add

\end{description}

\textbf{Description}
\begin{quote}

This function extends the used data area of the buffer at the buffer
start. If this would exceed the total buffer headroom the kernel will
panic. A pointer to the first byte of the extra data is returned.
\end{quote}
\index{skb\_pull (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_pull}\pysiglinewithargsret{void * \bfcode{skb\_pull}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{len}}{}
remove data from the start of a buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to use

\item[{\code{unsigned int len}}] \leavevmode
amount of data to remove

\end{description}

\textbf{Description}
\begin{quote}

This function removes data from the start of a buffer, returning
the memory to the headroom. A pointer to the next data in the buffer
is returned. Once the data has been pulled future pushes will overwrite
the old data.
\end{quote}
\index{skb\_trim (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_trim}\pysiglinewithargsret{void \bfcode{skb\_trim}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{len}}{}
remove end from a buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to alter

\item[{\code{unsigned int len}}] \leavevmode
new length

\end{description}

\textbf{Description}
\begin{quote}

Cut the length of a buffer down by removing data from the tail. If
the buffer is already under the length specified it is not modified.
The skb must be linear.
\end{quote}
\index{\_\_pskb\_pull\_tail (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__pskb_pull_tail}\pysiglinewithargsret{void * \bfcode{\_\_pskb\_pull\_tail}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{delta}}{}
advance tail of skb header

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to reallocate

\item[{\code{int delta}}] \leavevmode
number of bytes to advance tail

\end{description}

\textbf{Description}
\begin{quote}

The function makes a sense only on a fragmented {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}},
it expands header moving its tail forward and copying necessary
data from fragmented part.

{\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} MUST have reference count of 1.

Returns \code{NULL} (and {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} does not change) if pull failed
or value of new tail of skb in the case of success.

All the pointers pointing into skb header may change and must be
reloaded after call to this function.
\end{quote}
\index{skb\_copy\_bits (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_copy_bits}\pysiglinewithargsret{int \bfcode{skb\_copy\_bits}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{offset}, void *\emph{to}, int\emph{len}}{}
copy bits from skb to kernel buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
source skb

\item[{\code{int offset}}] \leavevmode
offset in source

\item[{\code{void * to}}] \leavevmode
destination buffer

\item[{\code{int len}}] \leavevmode
number of bytes to copy

\end{description}

\textbf{Description}
\begin{quote}

Copy the specified number of bytes from the source skb to the
destination buffer.
\begin{description}
\item[{CAUTION ! :}] \leavevmode
If its prototype is ever changed,
check arch/\{*\}/net/\{*\}.S files,
since it is called from BPF assembly code.

\end{description}
\end{quote}
\index{skb\_store\_bits (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_store_bits}\pysiglinewithargsret{int \bfcode{skb\_store\_bits}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{offset}, const void *\emph{from}, int\emph{len}}{}
store bits from kernel buffer to skb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
destination buffer

\item[{\code{int offset}}] \leavevmode
offset in destination

\item[{\code{const void * from}}] \leavevmode
source buffer

\item[{\code{int len}}] \leavevmode
number of bytes to copy

\end{description}

\textbf{Description}
\begin{quote}

Copy the specified number of bytes from the source buffer to the
destination skb.  This function handles all the messy bits of
traversing fragment lists and such.
\end{quote}
\index{skb\_zerocopy (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_zerocopy}\pysiglinewithargsret{int \bfcode{skb\_zerocopy}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{to}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{from}, int\emph{len}, int\emph{hlen}}{}
Zero copy skb to skb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * to}}] \leavevmode
destination buffer

\item[{\code{struct sk\_buff * from}}] \leavevmode
source buffer

\item[{\code{int len}}] \leavevmode
number of bytes to copy from source buffer

\item[{\code{int hlen}}] \leavevmode
size of linear headroom in destination buffer

\end{description}

\textbf{Description}
\begin{quote}

Copies up to \emph{len} bytes from \emph{from} to \emph{to} by creating references
to the frags in the source buffer.

The \emph{hlen} as calculated by \code{skb\_zerocopy\_headlen()} specifies the
headroom in the \emph{to} buffer.

Return value:
0: everything is OK
-ENOMEM: couldn't orphan frags of \textbf{from} due to lack of memory
-EFAULT: {\hyperref[networking/kapi:c.skb_copy_bits]{\emph{\code{skb\_copy\_bits()}}}} found some problem with skb geometry
\end{quote}
\index{skb\_dequeue (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_dequeue}}{struct sk\_buff\_head *\emph{list}}{}
remove from the head of the queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
list to dequeue from

\end{description}

\textbf{Description}
\begin{quote}

Remove the head of the list. The list lock is taken so the function
may be used safely with other locking list functions. The head item is
returned or \code{NULL} if the list is empty.
\end{quote}
\index{skb\_dequeue\_tail (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_dequeue\_tail}}{struct sk\_buff\_head *\emph{list}}{}
remove from the tail of the queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
list to dequeue from

\end{description}

\textbf{Description}
\begin{quote}

Remove the tail of the list. The list lock is taken so the function
may be used safely with other locking list functions. The tail item is
returned or \code{NULL} if the list is empty.
\end{quote}
\index{skb\_queue\_purge (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{void \bfcode{skb\_queue\_purge}}{struct sk\_buff\_head *\emph{list}}{}
empty a list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
list to empty

\end{description}

\textbf{Description}
\begin{quote}

Delete all buffers on an {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} list. Each buffer is removed from
the list and one reference dropped. This function takes the list
lock and is atomic with respect to other list locking functions.
\end{quote}
\index{skb\_queue\_head (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{void \bfcode{skb\_queue\_head}}{struct sk\_buff\_head *\emph{list}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{newsk}}{}
queue a buffer at the list head

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
list to use

\item[{\code{struct sk\_buff * newsk}}] \leavevmode
buffer to queue

\end{description}

\textbf{Description}
\begin{quote}

Queue a buffer at the start of the list. This function takes the
list lock and can be used safely with other locking {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} functions
safely.

A buffer cannot be placed on two lists at the same time.
\end{quote}
\index{skb\_queue\_tail (C function)}

\begin{fulllineitems}
\pysiglinewithargsret{void \bfcode{skb\_queue\_tail}}{struct sk\_buff\_head *\emph{list}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{newsk}}{}
queue a buffer at the list tail

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
list to use

\item[{\code{struct sk\_buff * newsk}}] \leavevmode
buffer to queue

\end{description}

\textbf{Description}
\begin{quote}

Queue a buffer at the tail of the list. This function takes the
list lock and can be used safely with other locking {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}} functions
safely.

A buffer cannot be placed on two lists at the same time.
\end{quote}
\index{skb\_unlink (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_unlink}\pysiglinewithargsret{void \bfcode{skb\_unlink}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, struct sk\_buff\_head *\emph{list}}{}
remove a buffer from a list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to remove

\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
list to use

\end{description}

\textbf{Description}
\begin{quote}

Remove a packet from a list. The list locks are taken and this
function is atomic with respect to other list locked calls

You must know what list the SKB is on.
\end{quote}
\index{skb\_append (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_append}\pysiglinewithargsret{void \bfcode{skb\_append}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{old}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{newsk}, struct sk\_buff\_head *\emph{list}}{}
append a buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * old}}] \leavevmode
buffer to insert after

\item[{\code{struct sk\_buff * newsk}}] \leavevmode
buffer to insert

\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
list to use

\end{description}

\textbf{Description}
\begin{quote}

Place a packet after a given packet in a list. The list locks are taken
and this function is atomic with respect to other list locked calls.
A buffer cannot be placed on two lists at the same time.
\end{quote}
\index{skb\_insert (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_insert}\pysiglinewithargsret{void \bfcode{skb\_insert}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{old}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{newsk}, struct sk\_buff\_head *\emph{list}}{}
insert a buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * old}}] \leavevmode
buffer to insert before

\item[{\code{struct sk\_buff * newsk}}] \leavevmode
buffer to insert

\item[{\code{struct sk\_buff\_head * list}}] \leavevmode
list to use

\end{description}

\textbf{Description}
\begin{quote}

Place a packet before a given packet in a list. The list locks are
taken and this function is atomic with respect to other list locked
calls.

A buffer cannot be placed on two lists at the same time.
\end{quote}
\index{skb\_split (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_split}\pysiglinewithargsret{void \bfcode{skb\_split}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb1}, const u32\emph{len}}{}
Split fragmented skb to two parts at length len.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
the buffer to split

\item[{\code{struct sk\_buff * skb1}}] \leavevmode
the buffer to receive the second part

\item[{\code{const u32 len}}] \leavevmode
new length for skb

\end{description}
\index{skb\_prepare\_seq\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_prepare_seq_read}\pysiglinewithargsret{void \bfcode{skb\_prepare\_seq\_read}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{from}, unsigned int\emph{to}, struct skb\_seq\_state *\emph{st}}{}
Prepare a sequential read of skb data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
the buffer to read

\item[{\code{unsigned int from}}] \leavevmode
lower offset of data to be read

\item[{\code{unsigned int to}}] \leavevmode
upper offset of data to be read

\item[{\code{struct skb\_seq\_state * st}}] \leavevmode
state variable

\end{description}

\textbf{Description}

Initializes the specified state variable. Must be called before
invoking {\hyperref[networking/kapi:c.skb_seq_read]{\emph{\code{skb\_seq\_read()}}}} for the first time.
\index{skb\_seq\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_seq_read}\pysiglinewithargsret{unsigned int \bfcode{skb\_seq\_read}}{unsigned int\emph{consumed}, const u8 **\emph{data}, struct skb\_seq\_state *\emph{st}}{}
Sequentially read skb data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int consumed}}] \leavevmode
number of bytes consumed by the caller so far

\item[{\code{const u8 ** data}}] \leavevmode
destination pointer for data to be returned

\item[{\code{struct skb\_seq\_state * st}}] \leavevmode
state variable

\end{description}

\textbf{Description}

Reads a block of skb data at \textbf{consumed} relative to the
lower offset specified to {\hyperref[networking/kapi:c.skb_prepare_seq_read]{\emph{\code{skb\_prepare\_seq\_read()}}}}. Assigns
the head of the data block to \textbf{data} and returns the length
of the block or 0 if the end of the skb data or the upper
offset has been reached.

The caller is not required to consume all of the data
returned, i.e. \textbf{consumed} is typically set to the number
of bytes already consumed and the next call to
{\hyperref[networking/kapi:c.skb_seq_read]{\emph{\code{skb\_seq\_read()}}}} will return the remaining part of the block.
\begin{description}
\item[{Note 1: The size of each block of data returned can be arbitrary,}] \leavevmode
this limitation is the cost for zerocopy sequential
reads of potentially non linear data.

\item[{Note 2: Fragment lists within fragments are not implemented}] \leavevmode
at the moment, state-\textgreater{}root\_skb could be replaced with
a stack for this purpose.

\end{description}
\index{skb\_abort\_seq\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_abort_seq_read}\pysiglinewithargsret{void \bfcode{skb\_abort\_seq\_read}}{struct skb\_seq\_state *\emph{st}}{}
Abort a sequential read of skb data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct skb\_seq\_state * st}}] \leavevmode
state variable

\end{description}

\textbf{Description}

Must be called if {\hyperref[networking/kapi:c.skb_seq_read]{\emph{\code{skb\_seq\_read()}}}} was not called until it
returned 0.
\index{skb\_find\_text (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_find_text}\pysiglinewithargsret{unsigned int \bfcode{skb\_find\_text}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{from}, unsigned int\emph{to}, struct ts\_config *\emph{config}}{}
Find a text pattern in skb data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
the buffer to look in

\item[{\code{unsigned int from}}] \leavevmode
search offset

\item[{\code{unsigned int to}}] \leavevmode
search limit

\item[{\code{struct ts\_config * config}}] \leavevmode
textsearch configuration

\end{description}

\textbf{Description}

Finds a pattern in the skb data according to the specified
textsearch configuration. Use \code{textsearch\_next()} to retrieve
subsequent occurrences of the pattern. Returns the offset
to the first occurrence or UINT\_MAX if no match was found.
\index{skb\_append\_datato\_frags (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_append_datato_frags}\pysiglinewithargsret{int \bfcode{skb\_append\_datato\_frags}}{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int (*getfrag) (void\emph{*from}, char\emph{*to}, int\emph{offset}, int\emph{len}, int\emph{odd}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}}\emph{*skb}, void *\emph{from}, int\emph{length}}{}
append the user data to a skb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sock * sk}}] \leavevmode
sock  structure

\item[{\code{struct sk\_buff * skb}}] \leavevmode
skb structure to be appended with user data.

\item[{\code{int (*)(void *from, char *to, int offset, int len, int odd, struct sk\_buff *skb) getfrag}}] \leavevmode
call back function to be used for getting the user data

\item[{\code{void * from}}] \leavevmode
pointer to user message iov

\item[{\code{int length}}] \leavevmode
length of the iov message

\end{description}

\textbf{Description}

This procedure append the user data in the fragment part
of the skb if any page alloc fails user this procedure returns  -ENOMEM
\index{skb\_pull\_rcsum (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_pull_rcsum}\pysiglinewithargsret{void * \bfcode{skb\_pull\_rcsum}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{len}}{}
pull skb and update receive checksum

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to update

\item[{\code{unsigned int len}}] \leavevmode
length of data pulled

\end{description}

\textbf{Description}
\begin{quote}

This function performs an skb\_pull on the packet and updates
the CHECKSUM\_COMPLETE checksum.  It should be used on
receive path processing instead of skb\_pull unless you know
that the checksum difference is zero (e.g., a valid IP header)
or you are setting ip\_summed to CHECKSUM\_NONE.
\end{quote}
\index{skb\_segment (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_segment}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_segment}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{head\_skb}, netdev\_features\_t\emph{features}}{}
Perform protocol segmentation on skb.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * head\_skb}}] \leavevmode
buffer to segment

\item[{\code{netdev\_features\_t features}}] \leavevmode
features for the output path (see dev-\textgreater{}features)

\end{description}

\textbf{Description}
\begin{quote}

This function performs segmentation on the given skb.  It returns
a pointer to the first in a list of new skbs for the segments.
In case of error it returns ERR\_PTR(err).
\end{quote}
\index{skb\_to\_sgvec (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_to_sgvec}\pysiglinewithargsret{int \bfcode{skb\_to\_sgvec}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, struct scatterlist *\emph{sg}, int\emph{offset}, int\emph{len}}{}
Fill a scatter-gather list from a socket buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
Socket buffer containing the buffers to be mapped

\item[{\code{struct scatterlist * sg}}] \leavevmode
The scatter-gather list to map into

\item[{\code{int offset}}] \leavevmode
The offset into the buffer's contents to start mapping

\item[{\code{int len}}] \leavevmode
Length of buffer space to be mapped

\end{description}

\textbf{Description}
\begin{quote}

Fill the specified scatter-gather list with mappings/pointers into a
region of the buffer space attached to a socket buffer. Returns either
the number of scatterlist items used, or -EMSGSIZE if the contents
could not fit.
\end{quote}
\index{skb\_cow\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_cow_data}\pysiglinewithargsret{int \bfcode{skb\_cow\_data}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{tailbits}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} **\emph{trailer}}{}
Check that a socket buffer's data buffers are writable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
The socket buffer to check.

\item[{\code{int tailbits}}] \leavevmode
Amount of trailing space to be added

\item[{\code{struct sk\_buff ** trailer}}] \leavevmode
Returned pointer to the skb where the \textbf{tailbits} space begins

\end{description}

\textbf{Description}
\begin{quote}

Make sure that the data buffers attached to a socket buffer are
writable. If they are not, private copies are made of the data buffers
and the socket buffer is set to use these instead.

If \textbf{tailbits} is given, make sure that there is space to write \textbf{tailbits}
bytes of data beyond current end of socket buffer.  \textbf{trailer} will be
set to point to the skb in which this space begins.

The number of scatterlist elements required to completely map the
COW'd and extended socket buffer will be returned.
\end{quote}
\index{skb\_clone\_sk (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_clone_sk}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_clone\_sk}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
create clone of skb, and take reference to socket

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
the skb to clone

\end{description}

\textbf{Description}

This function creates a clone of a buffer that holds a reference on
sk\_refcnt.  Buffers created via this function are meant to be
returned using sock\_queue\_err\_skb, or free via kfree\_skb.

When passing buffers allocated with this function to sock\_queue\_err\_skb
it is necessary to wrap the call with sock\_hold/sock\_put in order to
prevent the socket from being released prior to being enqueued on
the sk\_error\_queue.
\index{skb\_partial\_csum\_set (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_partial_csum_set}\pysiglinewithargsret{bool \bfcode{skb\_partial\_csum\_set}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, u16\emph{start}, u16\emph{off}}{}
set up and verify partial csum values for packet

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
the skb to set

\item[{\code{u16 start}}] \leavevmode
the number of bytes after skb-\textgreater{}data to start checksumming.

\item[{\code{u16 off}}] \leavevmode
the offset from start to place the checksum.

\end{description}

\textbf{Description}

For untrusted partially-checksummed packets, we need to make sure the values
for skb-\textgreater{}csum\_start and skb-\textgreater{}csum\_offset are valid so we don't oops.

This function checks and sets those values and skb-\textgreater{}ip\_summed: if this
returns false you should drop the packet.
\index{skb\_checksum\_setup (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_checksum_setup}\pysiglinewithargsret{int \bfcode{skb\_checksum\_setup}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, bool\emph{recalculate}}{}
set up partial checksum offset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
the skb to set up

\item[{\code{bool recalculate}}] \leavevmode
if true the pseudo-header checksum will be recalculated

\end{description}
\index{skb\_checksum\_trimmed (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_checksum_trimmed}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_checksum\_trimmed}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{transport\_len}, \_\_sum16(*skb\_chkf) (struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}}\emph{*skb}}{}
validate checksum of an skb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
the skb to check

\item[{\code{unsigned int transport\_len}}] \leavevmode
the data length beyond the network header

\item[{\code{\_\_sum16(*)(struct sk\_buff *skb) skb\_chkf}}] \leavevmode
checksum function to use

\end{description}

\textbf{Description}

Applies the given checksum function skb\_chkf to the provided skb.
Returns a checked and maybe trimmed skb. Returns NULL on error.

If the skb has data beyond the given transport length, then a
trimmed \& cloned skb is checked and returned.

Caller needs to set the skb transport header and free any returned skb if it
differs from the provided skb.
\index{skb\_try\_coalesce (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_try_coalesce}\pysiglinewithargsret{bool \bfcode{skb\_try\_coalesce}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{to}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{from}, bool *\emph{fragstolen}, int *\emph{delta\_truesize}}{}
try to merge skb to prior one

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * to}}] \leavevmode
prior buffer

\item[{\code{struct sk\_buff * from}}] \leavevmode
buffer to add

\item[{\code{bool * fragstolen}}] \leavevmode
pointer to boolean

\item[{\code{int * delta\_truesize}}] \leavevmode
how much more was allocated than was requested

\end{description}
\index{skb\_scrub\_packet (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_scrub_packet}\pysiglinewithargsret{void \bfcode{skb\_scrub\_packet}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, bool\emph{xnet}}{}
scrub an skb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to clean

\item[{\code{bool xnet}}] \leavevmode
packet is crossing netns

\end{description}

\textbf{Description}

skb\_scrub\_packet can be used after encapsulating or decapsulting a packet
into/from a tunnel. Some information have to be cleared during these
operations.
skb\_scrub\_packet can also be used to clean a skb before injecting it in
another namespace (\textbf{xnet} == true). We have to clear all information in the
skb that could impact namespace isolation.
\index{skb\_gso\_validate\_network\_len (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_gso_validate_network_len}\pysiglinewithargsret{bool \bfcode{skb\_gso\_validate\_network\_len}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{mtu}}{}
Will a split GSO skb fit into a given MTU?

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
GSO skb

\item[{\code{unsigned int mtu}}] \leavevmode
MTU to validate against

\end{description}

\textbf{Description}

skb\_gso\_validate\_network\_len validates if a given skb will fit a
wanted MTU once split. It considers L3 headers, L4 headers, and the
payload.
\index{skb\_gso\_validate\_mac\_len (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_gso_validate_mac_len}\pysiglinewithargsret{bool \bfcode{skb\_gso\_validate\_mac\_len}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{len}}{}
Will a split GSO skb fit in a given length?

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
GSO skb

\item[{\code{unsigned int len}}] \leavevmode
length to validate against

\end{description}

\textbf{Description}

skb\_gso\_validate\_mac\_len validates if a given skb will fit a wanted
length once split, including L2, L3 and L4 headers and the payload.
\index{alloc\_skb\_with\_frags (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.alloc_skb_with_frags}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{alloc\_skb\_with\_frags}}{unsigned long\emph{header\_len}, unsigned long\emph{data\_len}, int\emph{max\_page\_order}, int *\emph{errcode}, gfp\_t\emph{gfp\_mask}}{}
allocate skb with page frags

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long header\_len}}] \leavevmode
size of linear part

\item[{\code{unsigned long data\_len}}] \leavevmode
needed length in frags

\item[{\code{int max\_page\_order}}] \leavevmode
max page order desired.

\item[{\code{int * errcode}}] \leavevmode
pointer to error code if any

\item[{\code{gfp\_t gfp\_mask}}] \leavevmode
allocation mask

\end{description}

\textbf{Description}

This can be used to allocate a paged skb, given a maximal order for frags.
\index{sk\_ns\_capable (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_ns_capable}\pysiglinewithargsret{bool \bfcode{sk\_ns\_capable}}{const struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, struct user\_namespace *\emph{user\_ns}, int\emph{cap}}{}
General socket capability test

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sock * sk}}] \leavevmode
Socket to use a capability on or through

\item[{\code{struct user\_namespace * user\_ns}}] \leavevmode
The user namespace of the capability to use

\item[{\code{int cap}}] \leavevmode
The capability to use

\end{description}

\textbf{Description}

Test to see if the opener of the socket had when the socket was
created and the current process has the capability \textbf{cap} in the user
namespace \textbf{user\_ns}.
\index{sk\_capable (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_capable}\pysiglinewithargsret{bool \bfcode{sk\_capable}}{const struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, int\emph{cap}}{}
Socket global capability test

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sock * sk}}] \leavevmode
Socket to use a capability on or through

\item[{\code{int cap}}] \leavevmode
The global capability to use

\end{description}

\textbf{Description}

Test to see if the opener of the socket had when the socket was
created and the current process has the capability \textbf{cap} in all user
namespaces.
\index{sk\_net\_capable (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_net_capable}\pysiglinewithargsret{bool \bfcode{sk\_net\_capable}}{const struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, int\emph{cap}}{}
Network namespace socket capability test

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sock * sk}}] \leavevmode
Socket to use a capability on or through

\item[{\code{int cap}}] \leavevmode
The capability to use

\end{description}

\textbf{Description}

Test to see if the opener of the socket had when the socket was created
and the current process has the capability \textbf{cap} over the network namespace
the socket is a member of.
\index{sk\_set\_memalloc (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_set_memalloc}\pysiglinewithargsret{void \bfcode{sk\_set\_memalloc}}{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}}{}
sets \code{SOCK\_MEMALLOC}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sock * sk}}] \leavevmode
socket to set it on

\end{description}

\textbf{Description}

Set \code{SOCK\_MEMALLOC} on a socket for access to emergency reserves.
It's the responsibility of the admin to adjust min\_free\_kbytes
to meet the requirements
\index{sk\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_alloc}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} * \bfcode{sk\_alloc}}{struct net *\emph{net}, int\emph{family}, gfp\_t\emph{priority}, struct proto *\emph{prot}, int\emph{kern}}{}
All socket objects are allocated here

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net * net}}] \leavevmode
the applicable net namespace

\item[{\code{int family}}] \leavevmode
protocol family

\item[{\code{gfp\_t priority}}] \leavevmode
for allocation (\code{GFP\_KERNEL}, \code{GFP\_ATOMIC}, etc)

\item[{\code{struct proto * prot}}] \leavevmode
struct proto associated with this new sock instance

\item[{\code{int kern}}] \leavevmode
is this to be a kernel socket?

\end{description}
\index{sk\_clone\_lock (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_clone_lock}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} * \bfcode{sk\_clone\_lock}}{const struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, const gfp\_t\emph{priority}}{}
clone a socket, and lock its clone

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sock * sk}}] \leavevmode
the socket to clone

\item[{\code{const gfp\_t priority}}] \leavevmode
for allocation (\code{GFP\_KERNEL}, \code{GFP\_ATOMIC}, etc)

\end{description}

\textbf{Description}
\begin{quote}

Caller must unlock socket even in error path (bh\_unlock\_sock(newsk))
\end{quote}
\index{skb\_page\_frag\_refill (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_page_frag_refill}\pysiglinewithargsret{bool \bfcode{skb\_page\_frag\_refill}}{unsigned int\emph{sz}, struct page\_frag *\emph{pfrag}, gfp\_t\emph{gfp}}{}
check that a page\_frag contains enough room

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int sz}}] \leavevmode
minimum size of the fragment we want to get

\item[{\code{struct page\_frag * pfrag}}] \leavevmode
pointer to page\_frag

\item[{\code{gfp\_t gfp}}] \leavevmode
priority for memory allocation

\end{description}

\textbf{Note}

While this allocator tries to use high order pages, there is
no guarantee that allocations succeed. Therefore, \textbf{sz} MUST be
less or equal than PAGE\_SIZE.
\index{sk\_wait\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_wait_data}\pysiglinewithargsret{int \bfcode{sk\_wait\_data}}{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, long *\emph{timeo}, const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
wait for data to arrive at sk\_receive\_queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sock * sk}}] \leavevmode
sock to wait on

\item[{\code{long * timeo}}] \leavevmode
for how long

\item[{\code{const struct sk\_buff * skb}}] \leavevmode
last skb seen on sk\_receive\_queue

\end{description}

\textbf{Description}

Now socket state including sk-\textgreater{}sk\_err is changed only under lock,
hence we may omit checks after joining wait queue.
We check receive queue before \code{schedule()} only as optimization;
it is very likely that \code{release\_sock()} added new data.
\index{\_\_sk\_mem\_raise\_allocated (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__sk_mem_raise_allocated}\pysiglinewithargsret{int \bfcode{\_\_sk\_mem\_raise\_allocated}}{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, int\emph{size}, int\emph{amt}, int\emph{kind}}{}
increase memory\_allocated

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sock * sk}}] \leavevmode
socket

\item[{\code{int size}}] \leavevmode
memory size to allocate

\item[{\code{int amt}}] \leavevmode
pages to allocate

\item[{\code{int kind}}] \leavevmode
allocation type

\end{description}

\textbf{Description}
\begin{quote}

Similar to {\hyperref[networking/kapi:c.__sk_mem_schedule]{\emph{\code{\_\_sk\_mem\_schedule()}}}}, but does not update sk\_forward\_alloc
\end{quote}
\index{\_\_sk\_mem\_schedule (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__sk_mem_schedule}\pysiglinewithargsret{int \bfcode{\_\_sk\_mem\_schedule}}{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, int\emph{size}, int\emph{kind}}{}
increase sk\_forward\_alloc and memory\_allocated

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sock * sk}}] \leavevmode
socket

\item[{\code{int size}}] \leavevmode
memory size to allocate

\item[{\code{int kind}}] \leavevmode
allocation type

\end{description}

\textbf{Description}
\begin{quote}

If kind is SK\_MEM\_SEND, it means wmem allocation. Otherwise it means
rmem allocation. This function assumes that protocols which have
memory\_pressure use sk\_wmem\_queued as write buffer accounting.
\end{quote}
\index{\_\_sk\_mem\_reduce\_allocated (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__sk_mem_reduce_allocated}\pysiglinewithargsret{void \bfcode{\_\_sk\_mem\_reduce\_allocated}}{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, int\emph{amount}}{}
reclaim memory\_allocated

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sock * sk}}] \leavevmode
socket

\item[{\code{int amount}}] \leavevmode
number of quanta

\end{description}

\textbf{Description}
\begin{quote}

Similar to {\hyperref[networking/kapi:c.__sk_mem_reclaim]{\emph{\code{\_\_sk\_mem\_reclaim()}}}}, but does not update sk\_forward\_alloc
\end{quote}
\index{\_\_sk\_mem\_reclaim (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__sk_mem_reclaim}\pysiglinewithargsret{void \bfcode{\_\_sk\_mem\_reclaim}}{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, int\emph{amount}}{}
reclaim sk\_forward\_alloc and memory\_allocated

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sock * sk}}] \leavevmode
socket

\item[{\code{int amount}}] \leavevmode
number of bytes (rounded down to a SK\_MEM\_QUANTUM multiple)

\end{description}
\index{lock\_sock\_fast (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.lock_sock_fast}\pysiglinewithargsret{bool \bfcode{lock\_sock\_fast}}{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}}{}
fast version of lock\_sock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sock * sk}}] \leavevmode
socket

\end{description}

\textbf{Description}

This version should be used for very small section, where process wont block
return false if fast path is taken:
\begin{quote}

sk\_lock.slock locked, owned = 0, BH disabled
\end{quote}

return true if slow path is taken:
\begin{quote}

sk\_lock.slock unlocked, owned = 1, BH enabled
\end{quote}
\index{\_\_skb\_try\_recv\_datagram (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__skb_try_recv_datagram}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{\_\_skb\_try\_recv\_datagram}}{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, unsigned int\emph{flags}, void (*destructor) (struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}}\emph{*sk}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}}\emph{*skb}, int *\emph{peeked}, int *\emph{off}, int *\emph{err}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} **\emph{last}}{}
Receive a datagram skbuff

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sock * sk}}] \leavevmode
socket

\item[{\code{unsigned int flags}}] \leavevmode
MSG\_ flags

\item[{\code{void (*)(struct sock *sk, struct sk\_buff *skb) destructor}}] \leavevmode
invoked under the receive lock on successful dequeue

\item[{\code{int * peeked}}] \leavevmode
returns non-zero if this packet has been seen before

\item[{\code{int * off}}] \leavevmode
an offset in bytes to peek skb from. Returns an offset
within an skb where data actually starts

\item[{\code{int * err}}] \leavevmode
error code returned

\item[{\code{struct sk\_buff ** last}}] \leavevmode
set to last peeked message to inform the wait function
what to look for when peeking

\end{description}

\textbf{Description}
\begin{quote}

Get a datagram skbuff, understands the peeking, nonblocking wakeups
and possible races. This replaces identical code in packet, raw and
udp, as well as the IPX AX.25 and Appletalk. It also finally fixes
the long standing peek and read race for datagram sockets. If you
alter this routine remember it must be re-entrant.

This function will lock the socket if a skb is returned, so
the caller needs to unlock the socket in that case (usually by
calling skb\_free\_datagram). Returns NULL with \textbf{err} set to
-EAGAIN if no data was available or to some other value if an
error was detected.
\begin{itemize}
\item {} 
It does not lock socket since today. This function is

\item {} 
free of race conditions. This measure should/can improve

\item {} 
significantly datagram socket latencies at high loads,

\item {} 
when data copying to user space takes lots of time.

\item {} 
(BTW I've just killed the last \code{cli()} in IP/IPv6/core/netlink/packet

\item {} \begin{enumerate}
\setcounter{enumi}{7}
\item {} 
Great win.)

\end{enumerate}

\item {} 
--ANK (980729)

\end{itemize}

The order of the tests when we find no data waiting are specified
quite explicitly by POSIX 1003.1g, don't change them without having
the standard around please.
\end{quote}
\index{skb\_kill\_datagram (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_kill_datagram}\pysiglinewithargsret{int \bfcode{skb\_kill\_datagram}}{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{flags}}{}
Free a datagram skbuff forcibly

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sock * sk}}] \leavevmode
socket

\item[{\code{struct sk\_buff * skb}}] \leavevmode
datagram skbuff

\item[{\code{unsigned int flags}}] \leavevmode
MSG\_ flags

\end{description}

\textbf{Description}
\begin{quote}

This function frees a datagram skbuff that was received by
skb\_recv\_datagram.  The flags argument must match the one
used for skb\_recv\_datagram.

If the MSG\_PEEK flag is set, and the packet is still on the
receive queue of the socket, it will be taken off the queue
before it is freed.

This function currently only disables BH when acquiring the
sk\_receive\_queue lock.  Therefore it must not be used in a
context where that lock is acquired in an IRQ context.

It returns 0 if the packet was removed by us.
\end{quote}
\index{skb\_copy\_datagram\_iter (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_copy_datagram_iter}\pysiglinewithargsret{int \bfcode{skb\_copy\_datagram\_iter}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{offset}, struct iov\_iter *\emph{to}, int\emph{len}}{}
Copy a datagram to an iovec iterator.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
buffer to copy

\item[{\code{int offset}}] \leavevmode
offset in the buffer to start copying from

\item[{\code{struct iov\_iter * to}}] \leavevmode
iovec iterator to copy to

\item[{\code{int len}}] \leavevmode
amount of data to copy from buffer to iovec

\end{description}
\index{skb\_copy\_datagram\_from\_iter (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_copy_datagram_from_iter}\pysiglinewithargsret{int \bfcode{skb\_copy\_datagram\_from\_iter}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{offset}, struct iov\_iter *\emph{from}, int\emph{len}}{}
Copy a datagram from an iov\_iter.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to copy

\item[{\code{int offset}}] \leavevmode
offset in the buffer to start copying to

\item[{\code{struct iov\_iter * from}}] \leavevmode
the copy source

\item[{\code{int len}}] \leavevmode
amount of data to copy to buffer from iovec

\end{description}

\textbf{Description}
\begin{quote}

Returns 0 or -EFAULT.
\end{quote}
\index{zerocopy\_sg\_from\_iter (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.zerocopy_sg_from_iter}\pysiglinewithargsret{int \bfcode{zerocopy\_sg\_from\_iter}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, struct iov\_iter *\emph{from}}{}
Build a zerocopy datagram from an iov\_iter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to copy

\item[{\code{struct iov\_iter * from}}] \leavevmode
the source to copy from

\end{description}

\textbf{Description}
\begin{quote}

The function will first copy up to headlen, and then pin the userspace
pages and build frags through them.

Returns 0, -EFAULT or -EMSGSIZE.
\end{quote}
\index{skb\_copy\_and\_csum\_datagram\_msg (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_copy_and_csum_datagram_msg}\pysiglinewithargsret{int \bfcode{skb\_copy\_and\_csum\_datagram\_msg}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{hlen}, struct msghdr *\emph{msg}}{}
Copy and checksum skb to user iovec.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
skbuff

\item[{\code{int hlen}}] \leavevmode
hardware length

\item[{\code{struct msghdr * msg}}] \leavevmode
destination

\end{description}

\textbf{Description}
\begin{quote}

Caller \_must\_ check that skb will fit to this iovec.
\end{quote}

\textbf{Return}
\begin{description}
\item[{0       - success.}] \leavevmode
-EINVAL - checksum failure.
-EFAULT - fault during copy.

\end{description}
\index{datagram\_poll (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.datagram_poll}\pysiglinewithargsret{\_\_poll\_t \bfcode{datagram\_poll}}{struct file *\emph{file}, struct {\hyperref[networking/kapi:c.socket]{\emph{socket}}} *\emph{sock}, poll\_table *\emph{wait}}{}
generic datagram poll

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct file * file}}] \leavevmode
file struct

\item[{\code{struct socket * sock}}] \leavevmode
socket

\item[{\code{poll\_table * wait}}] \leavevmode
poll table

\end{description}

\textbf{Description}
\begin{quote}

Datagram poll: Again totally generic. This also handles
sequenced packet sockets providing the socket receive queue
is only ever holding data ready to receive.
\end{quote}

\textbf{Note}
\begin{description}
\item[{when you \emph{don't} use this routine for this protocol,}] \leavevmode
and you use a different write policy from \code{sock\_writeable()}
then please supply your own write\_space callback.

\end{description}
\index{sk\_stream\_wait\_connect (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_stream_wait_connect}\pysiglinewithargsret{int \bfcode{sk\_stream\_wait\_connect}}{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, long *\emph{timeo\_p}}{}
Wait for a socket to get into the connected state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sock * sk}}] \leavevmode
sock to wait on

\item[{\code{long * timeo\_p}}] \leavevmode
for how long to wait

\end{description}

\textbf{Description}

Must be called with the socket locked.
\index{sk\_stream\_wait\_memory (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_stream_wait_memory}\pysiglinewithargsret{int \bfcode{sk\_stream\_wait\_memory}}{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, long *\emph{timeo\_p}}{}
Wait for more memory for a socket

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sock * sk}}] \leavevmode
socket to wait for memory

\item[{\code{long * timeo\_p}}] \leavevmode
for how long

\end{description}


\subsection{Socket Filter}
\label{networking/kapi:socket-filter}\index{sk\_filter\_trim\_cap (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_filter_trim_cap}\pysiglinewithargsret{int \bfcode{sk\_filter\_trim\_cap}}{struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned int\emph{cap}}{}
run a packet through a socket filter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sock * sk}}] \leavevmode
sock associated with {\hyperref[networking/kapi:c.sk_buff]{\emph{\code{sk\_buff}}}}

\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to filter

\item[{\code{unsigned int cap}}] \leavevmode
limit on how short the eBPF program may trim the packet

\end{description}

\textbf{Description}

Run the eBPF program and then cut skb-\textgreater{}data to correct size returned by
the program. If pkt\_len is 0 we toss packet. If skb-\textgreater{}len is smaller
than pkt\_len we keep whole skb-\textgreater{}data. This is the socket level
wrapper to BPF\_PROG\_RUN. It returns 0 if the packet should
be accepted or -EPERM if the packet should be tossed.
\index{bpf\_prog\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.bpf_prog_create}\pysiglinewithargsret{int \bfcode{bpf\_prog\_create}}{struct bpf\_prog **\emph{pfp}, struct sock\_fprog\_kern *\emph{fprog}}{}
create an unattached filter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bpf\_prog ** pfp}}] \leavevmode
the unattached filter that is created

\item[{\code{struct sock\_fprog\_kern * fprog}}] \leavevmode
the filter program

\end{description}

\textbf{Description}

Create a filter independent of any socket. We first run some
sanity checks on it to make sure it does not explode on us later.
If an error occurs or there is insufficient memory for the filter
a negative errno code is returned. On success the return is zero.
\index{bpf\_prog\_create\_from\_user (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.bpf_prog_create_from_user}\pysiglinewithargsret{int \bfcode{bpf\_prog\_create\_from\_user}}{struct bpf\_prog **\emph{pfp}, struct sock\_fprog *\emph{fprog}, bpf\_aux\_classic\_check\_t\emph{trans}, bool\emph{save\_orig}}{}
create an unattached filter from user buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct bpf\_prog ** pfp}}] \leavevmode
the unattached filter that is created

\item[{\code{struct sock\_fprog * fprog}}] \leavevmode
the filter program

\item[{\code{bpf\_aux\_classic\_check\_t trans}}] \leavevmode
post-classic verifier transformation handler

\item[{\code{bool save\_orig}}] \leavevmode
save classic BPF program

\end{description}

\textbf{Description}

This function effectively does the same as {\hyperref[networking/kapi:c.bpf_prog_create]{\emph{\code{bpf\_prog\_create()}}}}, only
that it builds up its insns buffer from user space provided buffer.
It also allows for passing a bpf\_aux\_classic\_check\_t handler.
\index{sk\_attach\_filter (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sk_attach_filter}\pysiglinewithargsret{int \bfcode{sk\_attach\_filter}}{struct sock\_fprog *\emph{fprog}, struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}}{}
attach a socket filter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sock\_fprog * fprog}}] \leavevmode
the filter program

\item[{\code{struct sock * sk}}] \leavevmode
the socket to use

\end{description}

\textbf{Description}

Attach the user's filter code. We first run some sanity checks on
it to make sure it does not explode on us later. If an error
occurs or there is insufficient memory for the filter a negative
errno code is returned. On success the return is zero.


\subsection{Generic Network Statistics}
\label{networking/kapi:generic-network-statistics}\index{gnet\_stats\_basic (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.gnet_stats_basic}\pysigline{struct \bfcode{gnet\_stats\_basic}}
byte/packet throughput statistics

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct gnet\PYGZus{}stats\PYGZus{}basic \PYGZob{}
  \PYGZus{}\PYGZus{}u64 bytes;
  \PYGZus{}\PYGZus{}u32 packets;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{bytes}}] \leavevmode
number of seen bytes

\item[{\code{packets}}] \leavevmode
number of seen packets

\end{description}
\index{gnet\_stats\_rate\_est (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.gnet_stats_rate_est}\pysigline{struct \bfcode{gnet\_stats\_rate\_est}}
rate estimator

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct gnet\PYGZus{}stats\PYGZus{}rate\PYGZus{}est \PYGZob{}
  \PYGZus{}\PYGZus{}u32 bps;
  \PYGZus{}\PYGZus{}u32 pps;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{bps}}] \leavevmode
current byte rate

\item[{\code{pps}}] \leavevmode
current packet rate

\end{description}
\index{gnet\_stats\_rate\_est64 (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.gnet_stats_rate_est64}\pysigline{struct \bfcode{gnet\_stats\_rate\_est64}}
rate estimator

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct gnet\PYGZus{}stats\PYGZus{}rate\PYGZus{}est64 \PYGZob{}
  \PYGZus{}\PYGZus{}u64 bps;
  \PYGZus{}\PYGZus{}u64 pps;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{bps}}] \leavevmode
current byte rate

\item[{\code{pps}}] \leavevmode
current packet rate

\end{description}
\index{gnet\_stats\_queue (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.gnet_stats_queue}\pysigline{struct \bfcode{gnet\_stats\_queue}}
queuing statistics

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct gnet\PYGZus{}stats\PYGZus{}queue \PYGZob{}
  \PYGZus{}\PYGZus{}u32 qlen;
  \PYGZus{}\PYGZus{}u32 backlog;
  \PYGZus{}\PYGZus{}u32 drops;
  \PYGZus{}\PYGZus{}u32 requeues;
  \PYGZus{}\PYGZus{}u32 overlimits;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{qlen}}] \leavevmode
queue length

\item[{\code{backlog}}] \leavevmode
backlog size of queue

\item[{\code{drops}}] \leavevmode
number of dropped packets

\item[{\code{requeues}}] \leavevmode
number of requeues

\item[{\code{overlimits}}] \leavevmode
number of enqueues over the limit

\end{description}
\index{gnet\_estimator (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.gnet_estimator}\pysigline{struct \bfcode{gnet\_estimator}}
rate estimator configuration

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct gnet\PYGZus{}estimator \PYGZob{}
  signed char     interval;
  unsigned char   ewma\PYGZus{}log;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{interval}}] \leavevmode
sampling period

\item[{\code{ewma\_log}}] \leavevmode
the log of measurement window weight

\end{description}
\index{gnet\_stats\_start\_copy\_compat (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.gnet_stats_start_copy_compat}\pysiglinewithargsret{int \bfcode{gnet\_stats\_start\_copy\_compat}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{type}, int\emph{tc\_stats\_type}, int\emph{xstats\_type}, spinlock\_t *\emph{lock}, struct gnet\_dump *\emph{d}, int\emph{padattr}}{}
start dumping procedure in compatibility mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
socket buffer to put statistics TLVs into

\item[{\code{int type}}] \leavevmode
TLV type for top level statistic TLV

\item[{\code{int tc\_stats\_type}}] \leavevmode
TLV type for backward compatibility struct tc\_stats TLV

\item[{\code{int xstats\_type}}] \leavevmode
TLV type for backward compatibility xstats TLV

\item[{\code{spinlock\_t * lock}}] \leavevmode
statistics lock

\item[{\code{struct gnet\_dump * d}}] \leavevmode
dumping handle

\item[{\code{int padattr}}] \leavevmode
padding attribute

\end{description}

\textbf{Description}

Initializes the dumping handle, grabs the statistic lock and appends
an empty TLV header to the socket buffer for use a container for all
other statistic TLVS.

The dumping handle is marked to be in backward compatibility mode telling
all \code{gnet\_stats\_copy\_XXX()} functions to fill a local copy of struct tc\_stats.

Returns 0 on success or -1 if the room in the socket buffer was not sufficient.
\index{gnet\_stats\_start\_copy (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.gnet_stats_start_copy}\pysiglinewithargsret{int \bfcode{gnet\_stats\_start\_copy}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, int\emph{type}, spinlock\_t *\emph{lock}, struct gnet\_dump *\emph{d}, int\emph{padattr}}{}
start dumping procedure in compatibility mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
socket buffer to put statistics TLVs into

\item[{\code{int type}}] \leavevmode
TLV type for top level statistic TLV

\item[{\code{spinlock\_t * lock}}] \leavevmode
statistics lock

\item[{\code{struct gnet\_dump * d}}] \leavevmode
dumping handle

\item[{\code{int padattr}}] \leavevmode
padding attribute

\end{description}

\textbf{Description}

Initializes the dumping handle, grabs the statistic lock and appends
an empty TLV header to the socket buffer for use a container for all
other statistic TLVS.

Returns 0 on success or -1 if the room in the socket buffer was not sufficient.
\index{gnet\_stats\_copy\_basic (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.gnet_stats_copy_basic}\pysiglinewithargsret{int \bfcode{gnet\_stats\_copy\_basic}}{const seqcount\_t *\emph{running}, struct gnet\_dump *\emph{d}, struct gnet\_stats\_basic\_cpu \_\_percpu *\emph{cpu}, struct gnet\_stats\_basic\_packed *\emph{b}}{}
copy basic statistics into statistic TLV

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const seqcount\_t * running}}] \leavevmode
seqcount\_t pointer

\item[{\code{struct gnet\_dump * d}}] \leavevmode
dumping handle

\item[{\code{struct gnet\_stats\_basic\_cpu \_\_percpu * cpu}}] \leavevmode
copy statistic per cpu

\item[{\code{struct gnet\_stats\_basic\_packed * b}}] \leavevmode
basic statistics

\end{description}

\textbf{Description}

Appends the basic statistics to the top level TLV created by
{\hyperref[networking/kapi:c.gnet_stats_start_copy]{\emph{\code{gnet\_stats\_start\_copy()}}}}.

Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.
\index{gnet\_stats\_copy\_rate\_est (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.gnet_stats_copy_rate_est}\pysiglinewithargsret{int \bfcode{gnet\_stats\_copy\_rate\_est}}{struct gnet\_dump *\emph{d}, struct net\_rate\_estimator \_\_rcu **\emph{rate\_est}}{}
copy rate estimator statistics into statistics TLV

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gnet\_dump * d}}] \leavevmode
dumping handle

\item[{\code{struct net\_rate\_estimator \_\_rcu ** rate\_est}}] \leavevmode
rate estimator

\end{description}

\textbf{Description}

Appends the rate estimator statistics to the top level TLV created by
{\hyperref[networking/kapi:c.gnet_stats_start_copy]{\emph{\code{gnet\_stats\_start\_copy()}}}}.

Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.
\index{gnet\_stats\_copy\_queue (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.gnet_stats_copy_queue}\pysiglinewithargsret{int \bfcode{gnet\_stats\_copy\_queue}}{struct gnet\_dump *\emph{d}, struct {\hyperref[networking/kapi:c.gnet_stats_queue]{\emph{gnet\_stats\_queue}}} \_\_percpu *\emph{cpu\_q}, struct {\hyperref[networking/kapi:c.gnet_stats_queue]{\emph{gnet\_stats\_queue}}} *\emph{q}, \_\_u32\emph{qlen}}{}
copy queue statistics into statistics TLV

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gnet\_dump * d}}] \leavevmode
dumping handle

\item[{\code{struct gnet\_stats\_queue \_\_percpu * cpu\_q}}] \leavevmode
per cpu queue statistics

\item[{\code{struct gnet\_stats\_queue * q}}] \leavevmode
queue statistics

\item[{\code{\_\_u32 qlen}}] \leavevmode
queue length statistics

\end{description}

\textbf{Description}

Appends the queue statistics to the top level TLV created by
{\hyperref[networking/kapi:c.gnet_stats_start_copy]{\emph{\code{gnet\_stats\_start\_copy()}}}}. Using per cpu queue statistics if
they are available.

Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.
\index{gnet\_stats\_copy\_app (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.gnet_stats_copy_app}\pysiglinewithargsret{int \bfcode{gnet\_stats\_copy\_app}}{struct gnet\_dump *\emph{d}, void *\emph{st}, int\emph{len}}{}
copy application specific statistics into statistics TLV

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gnet\_dump * d}}] \leavevmode
dumping handle

\item[{\code{void * st}}] \leavevmode
application specific statistics data

\item[{\code{int len}}] \leavevmode
length of data

\end{description}

\textbf{Description}

Appends the application specific statistics to the top level TLV created by
{\hyperref[networking/kapi:c.gnet_stats_start_copy]{\emph{\code{gnet\_stats\_start\_copy()}}}} and remembers the data for XSTATS if the dumping
handle is in backward compatibility mode.

Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.
\index{gnet\_stats\_finish\_copy (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.gnet_stats_finish_copy}\pysiglinewithargsret{int \bfcode{gnet\_stats\_finish\_copy}}{struct gnet\_dump *\emph{d}}{}
finish dumping procedure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gnet\_dump * d}}] \leavevmode
dumping handle

\end{description}

\textbf{Description}

Corrects the length of the top level TLV to include all TLVs added
by \code{gnet\_stats\_copy\_XXX()} calls. Adds the backward compatibility TLVs
if {\hyperref[networking/kapi:c.gnet_stats_start_copy_compat]{\emph{\code{gnet\_stats\_start\_copy\_compat()}}}} was used and releases the statistics
lock.

Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.
\index{gen\_new\_estimator (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.gen_new_estimator}\pysiglinewithargsret{int \bfcode{gen\_new\_estimator}}{struct gnet\_stats\_basic\_packed *\emph{bstats}, struct gnet\_stats\_basic\_cpu \_\_percpu *\emph{cpu\_bstats}, struct net\_rate\_estimator \_\_rcu **\emph{rate\_est}, spinlock\_t *\emph{stats\_lock}, seqcount\_t *\emph{running}, struct nlattr *\emph{opt}}{}
create a new rate estimator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gnet\_stats\_basic\_packed * bstats}}] \leavevmode
basic statistics

\item[{\code{struct gnet\_stats\_basic\_cpu \_\_percpu * cpu\_bstats}}] \leavevmode
bstats per cpu

\item[{\code{struct net\_rate\_estimator \_\_rcu ** rate\_est}}] \leavevmode
rate estimator statistics

\item[{\code{spinlock\_t * stats\_lock}}] \leavevmode
statistics lock

\item[{\code{seqcount\_t * running}}] \leavevmode
qdisc running seqcount

\item[{\code{struct nlattr * opt}}] \leavevmode
rate estimator configuration TLV

\end{description}

\textbf{Description}

Creates a new rate estimator with \code{bstats} as source and \code{rate\_est}
as destination. A new timer with the interval specified in the
configuration TLV is created. Upon each interval, the latest statistics
will be read from \code{bstats} and the estimated rate will be stored in
\code{rate\_est} with the statistics lock grabbed during this period.

Returns 0 on success or a negative error code.
\index{gen\_kill\_estimator (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.gen_kill_estimator}\pysiglinewithargsret{void \bfcode{gen\_kill\_estimator}}{struct net\_rate\_estimator \_\_rcu **\emph{rate\_est}}{}
remove a rate estimator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_rate\_estimator \_\_rcu ** rate\_est}}] \leavevmode
rate estimator

\end{description}

\textbf{Description}

Removes the rate estimator.
\index{gen\_replace\_estimator (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.gen_replace_estimator}\pysiglinewithargsret{int \bfcode{gen\_replace\_estimator}}{struct gnet\_stats\_basic\_packed *\emph{bstats}, struct gnet\_stats\_basic\_cpu \_\_percpu *\emph{cpu\_bstats}, struct net\_rate\_estimator \_\_rcu **\emph{rate\_est}, spinlock\_t *\emph{stats\_lock}, seqcount\_t *\emph{running}, struct nlattr *\emph{opt}}{}
replace rate estimator configuration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct gnet\_stats\_basic\_packed * bstats}}] \leavevmode
basic statistics

\item[{\code{struct gnet\_stats\_basic\_cpu \_\_percpu * cpu\_bstats}}] \leavevmode
bstats per cpu

\item[{\code{struct net\_rate\_estimator \_\_rcu ** rate\_est}}] \leavevmode
rate estimator statistics

\item[{\code{spinlock\_t * stats\_lock}}] \leavevmode
statistics lock

\item[{\code{seqcount\_t * running}}] \leavevmode
qdisc running seqcount (might be NULL)

\item[{\code{struct nlattr * opt}}] \leavevmode
rate estimator configuration TLV

\end{description}

\textbf{Description}

Replaces the configuration of a rate estimator by calling
{\hyperref[networking/kapi:c.gen_kill_estimator]{\emph{\code{gen\_kill\_estimator()}}}} and {\hyperref[networking/kapi:c.gen_new_estimator]{\emph{\code{gen\_new\_estimator()}}}}.

Returns 0 on success or a negative error code.
\index{gen\_estimator\_active (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.gen_estimator_active}\pysiglinewithargsret{bool \bfcode{gen\_estimator\_active}}{struct net\_rate\_estimator \_\_rcu **\emph{rate\_est}}{}
test if estimator is currently in use

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_rate\_estimator \_\_rcu ** rate\_est}}] \leavevmode
rate estimator

\end{description}

\textbf{Description}

Returns true if estimator is active, and false if not.


\subsection{SUN RPC subsystem}
\label{networking/kapi:sun-rpc-subsystem}\index{xdr\_encode\_opaque\_fixed (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_encode_opaque_fixed}\pysiglinewithargsret{\_\_be32 * \bfcode{xdr\_encode\_opaque\_fixed}}{\_\_be32 *\emph{p}, const void *\emph{ptr}, unsigned int\emph{nbytes}}{}
Encode fixed length opaque data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_be32 * p}}] \leavevmode
pointer to current position in XDR buffer.

\item[{\code{const void * ptr}}] \leavevmode
pointer to data to encode (or NULL)

\item[{\code{unsigned int nbytes}}] \leavevmode
size of data.

\end{description}

\textbf{Description}

Copy the array of data of length nbytes at ptr to the XDR buffer
at position p, then align to the next 32-bit boundary by padding
with zero bytes (see RFC1832).

\textbf{Note}

if ptr is NULL, only the padding is performed.

Returns the updated current XDR buffer position
\index{xdr\_encode\_opaque (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_encode_opaque}\pysiglinewithargsret{\_\_be32 * \bfcode{xdr\_encode\_opaque}}{\_\_be32 *\emph{p}, const void *\emph{ptr}, unsigned int\emph{nbytes}}{}
Encode variable length opaque data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_be32 * p}}] \leavevmode
pointer to current position in XDR buffer.

\item[{\code{const void * ptr}}] \leavevmode
pointer to data to encode (or NULL)

\item[{\code{unsigned int nbytes}}] \leavevmode
size of data.

\end{description}

\textbf{Description}

Returns the updated current XDR buffer position
\index{xdr\_terminate\_string (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_terminate_string}\pysiglinewithargsret{void \bfcode{xdr\_terminate\_string}}{struct xdr\_buf *\emph{buf}, const u32\emph{len}}{}
`0'-terminate a string residing in an xdr\_buf

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_buf * buf}}] \leavevmode
XDR buffer where string resides

\item[{\code{const u32 len}}] \leavevmode
length of string, in bytes

\end{description}
\index{\_copy\_from\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c._copy_from_pages}\pysiglinewithargsret{void \bfcode{\_copy\_from\_pages}}{char *\emph{p}, struct page **\emph{pages}, size\_t\emph{pgbase}, size\_t\emph{len}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{char * p}}] \leavevmode
pointer to destination

\item[{\code{struct page ** pages}}] \leavevmode
array of pages

\item[{\code{size\_t pgbase}}] \leavevmode
offset of source data

\item[{\code{size\_t len}}] \leavevmode
length

\end{description}

\textbf{Description}

Copies data into an arbitrary memory location from an array of pages
The copy is assumed to be non-overlapping.
\index{xdr\_stream\_pos (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_stream_pos}\pysiglinewithargsret{unsigned int \bfcode{xdr\_stream\_pos}}{const struct xdr\_stream *\emph{xdr}}{}
Return the current offset from the start of the xdr\_stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct xdr\_stream * xdr}}] \leavevmode
pointer to struct xdr\_stream

\end{description}
\index{xdr\_init\_encode (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_init_encode}\pysiglinewithargsret{void \bfcode{xdr\_init\_encode}}{struct xdr\_stream *\emph{xdr}, struct xdr\_buf *\emph{buf}, \_\_be32 *\emph{p}}{}
Initialize a struct xdr\_stream for sending data.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_stream * xdr}}] \leavevmode
pointer to xdr\_stream struct

\item[{\code{struct xdr\_buf * buf}}] \leavevmode
pointer to XDR buffer in which to encode data

\item[{\code{\_\_be32 * p}}] \leavevmode
current pointer inside XDR buffer

\end{description}

\textbf{Note}
\begin{description}
\item[{at the moment the RPC client only passes the length of our}] \leavevmode
scratch buffer in the xdr\_buf's header kvec. Previously this
meant we needed to call \code{xdr\_adjust\_iovec()} after encoding the
data. With the new scheme, the xdr\_stream manages the details
of the buffer length, and takes care of adjusting the kvec
length for us.

\end{description}
\index{xdr\_commit\_encode (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_commit_encode}\pysiglinewithargsret{void \bfcode{xdr\_commit\_encode}}{struct xdr\_stream *\emph{xdr}}{}
Ensure all data is written to buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_stream * xdr}}] \leavevmode
pointer to xdr\_stream

\end{description}

\textbf{Description}

We handle encoding across page boundaries by giving the caller a
temporary location to write to, then later copying the data into
place; xdr\_commit\_encode does that copying.

Normally the caller doesn't need to call this directly, as the
following xdr\_reserve\_space will do it.  But an explicit call may be
required at the end of encoding, or any other time when the xdr\_buf
data might be read.
\index{xdr\_reserve\_space (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_reserve_space}\pysiglinewithargsret{\_\_be32 * \bfcode{xdr\_reserve\_space}}{struct xdr\_stream *\emph{xdr}, size\_t\emph{nbytes}}{}
Reserve buffer space for sending

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_stream * xdr}}] \leavevmode
pointer to xdr\_stream

\item[{\code{size\_t nbytes}}] \leavevmode
number of bytes to reserve

\end{description}

\textbf{Description}

Checks that we have enough buffer space to encode `nbytes' more
bytes of data. If so, update the total xdr\_buf length, and
adjust the length of the current kvec.
\index{xdr\_truncate\_encode (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_truncate_encode}\pysiglinewithargsret{void \bfcode{xdr\_truncate\_encode}}{struct xdr\_stream *\emph{xdr}, size\_t\emph{len}}{}
truncate an encode buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_stream * xdr}}] \leavevmode
pointer to xdr\_stream

\item[{\code{size\_t len}}] \leavevmode
new length of buffer

\end{description}

\textbf{Description}

Truncates the xdr stream, so that xdr-\textgreater{}buf-\textgreater{}len == len,
and xdr-\textgreater{}p points at offset len from the start of the buffer, and
head, tail, and page lengths are adjusted to correspond.

If this means moving xdr-\textgreater{}p to a different buffer, we assume that
that the end pointer should be set to the end of the current page,
except in the case of the head buffer when we assume the head
buffer's current length represents the end of the available buffer.

This is \emph{not} safe to use on a buffer that already has inlined page
cache pages (as in a zero-copy server read reply), except for the
simple case of truncating from one position in the tail to another.
\index{xdr\_restrict\_buflen (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_restrict_buflen}\pysiglinewithargsret{int \bfcode{xdr\_restrict\_buflen}}{struct xdr\_stream *\emph{xdr}, int\emph{newbuflen}}{}
decrease available buffer space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_stream * xdr}}] \leavevmode
pointer to xdr\_stream

\item[{\code{int newbuflen}}] \leavevmode
new maximum number of bytes available

\end{description}

\textbf{Description}

Adjust our idea of how much space is available in the buffer.
If we've already used too much space in the buffer, returns -1.
If the available space is already smaller than newbuflen, returns 0
and does nothing.  Otherwise, adjusts xdr-\textgreater{}buf-\textgreater{}buflen to newbuflen
and ensures xdr-\textgreater{}end is set at most offset newbuflen from the start
of the buffer.
\index{xdr\_write\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_write_pages}\pysiglinewithargsret{void \bfcode{xdr\_write\_pages}}{struct xdr\_stream *\emph{xdr}, struct page **\emph{pages}, unsigned int\emph{base}, unsigned int\emph{len}}{}
Insert a list of pages into an XDR buffer for sending

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_stream * xdr}}] \leavevmode
pointer to xdr\_stream

\item[{\code{struct page ** pages}}] \leavevmode
list of pages

\item[{\code{unsigned int base}}] \leavevmode
offset of first byte

\item[{\code{unsigned int len}}] \leavevmode
length of data in bytes

\end{description}
\index{xdr\_init\_decode (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_init_decode}\pysiglinewithargsret{void \bfcode{xdr\_init\_decode}}{struct xdr\_stream *\emph{xdr}, struct xdr\_buf *\emph{buf}, \_\_be32 *\emph{p}}{}
Initialize an xdr\_stream for decoding data.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_stream * xdr}}] \leavevmode
pointer to xdr\_stream struct

\item[{\code{struct xdr\_buf * buf}}] \leavevmode
pointer to XDR buffer from which to decode data

\item[{\code{\_\_be32 * p}}] \leavevmode
current pointer inside XDR buffer

\end{description}
\index{xdr\_init\_decode\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_init_decode_pages}\pysiglinewithargsret{void \bfcode{xdr\_init\_decode\_pages}}{struct xdr\_stream *\emph{xdr}, struct xdr\_buf *\emph{buf}, struct page **\emph{pages}, unsigned int\emph{len}}{}
Initialize an xdr\_stream for decoding into pages

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_stream * xdr}}] \leavevmode
pointer to xdr\_stream struct

\item[{\code{struct xdr\_buf * buf}}] \leavevmode
pointer to XDR buffer from which to decode data

\item[{\code{struct page ** pages}}] \leavevmode
list of pages to decode into

\item[{\code{unsigned int len}}] \leavevmode
length in bytes of buffer in pages

\end{description}
\index{xdr\_set\_scratch\_buffer (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_set_scratch_buffer}\pysiglinewithargsret{void \bfcode{xdr\_set\_scratch\_buffer}}{struct xdr\_stream *\emph{xdr}, void *\emph{buf}, size\_t\emph{buflen}}{}
Attach a scratch buffer for decoding data.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_stream * xdr}}] \leavevmode
pointer to xdr\_stream struct

\item[{\code{void * buf}}] \leavevmode
pointer to an empty buffer

\item[{\code{size\_t buflen}}] \leavevmode
size of `buf'

\end{description}

\textbf{Description}

The scratch buffer is used when decoding from an array of pages.
If an {\hyperref[networking/kapi:c.xdr_inline_decode]{\emph{\code{xdr\_inline\_decode()}}}} call spans across page boundaries, then
we copy the data into the scratch buffer in order to allow linear
access.
\index{xdr\_inline\_decode (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_inline_decode}\pysiglinewithargsret{\_\_be32 * \bfcode{xdr\_inline\_decode}}{struct xdr\_stream *\emph{xdr}, size\_t\emph{nbytes}}{}
Retrieve XDR data to decode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_stream * xdr}}] \leavevmode
pointer to xdr\_stream struct

\item[{\code{size\_t nbytes}}] \leavevmode
number of bytes of data to decode

\end{description}

\textbf{Description}

Check if the input buffer is long enough to enable us to decode
`nbytes' more bytes of data starting at the current position.
If so return the current pointer, then update the current
pointer position.
\index{xdr\_read\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_read_pages}\pysiglinewithargsret{unsigned int \bfcode{xdr\_read\_pages}}{struct xdr\_stream *\emph{xdr}, unsigned int\emph{len}}{}
Ensure page-based XDR data to decode is aligned at current pointer position

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_stream * xdr}}] \leavevmode
pointer to xdr\_stream struct

\item[{\code{unsigned int len}}] \leavevmode
number of bytes of page data

\end{description}

\textbf{Description}

Moves data beyond the current pointer position from the XDR head{[}{]} buffer
into the page list. Any data that lies beyond current position + ``len''
bytes is moved into the XDR tail{[}{]}.

Returns the number of XDR encoded bytes now contained in the pages
\index{xdr\_enter\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_enter_page}\pysiglinewithargsret{void \bfcode{xdr\_enter\_page}}{struct xdr\_stream *\emph{xdr}, unsigned int\emph{len}}{}
decode data from the XDR page

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_stream * xdr}}] \leavevmode
pointer to xdr\_stream struct

\item[{\code{unsigned int len}}] \leavevmode
number of bytes of page data

\end{description}

\textbf{Description}

Moves data beyond the current pointer position from the XDR head{[}{]} buffer
into the page list. Any data that lies beyond current position + ``len''
bytes is moved into the XDR tail{[}{]}. The current pointer is then
repositioned at the beginning of the first XDR page.
\index{xdr\_buf\_subsegment (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_buf_subsegment}\pysiglinewithargsret{int \bfcode{xdr\_buf\_subsegment}}{struct xdr\_buf *\emph{buf}, struct xdr\_buf *\emph{subbuf}, unsigned int\emph{base}, unsigned int\emph{len}}{}
set subbuf to a portion of buf

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_buf * buf}}] \leavevmode
an xdr buffer

\item[{\code{struct xdr\_buf * subbuf}}] \leavevmode
the result buffer

\item[{\code{unsigned int base}}] \leavevmode
beginning of range in bytes

\item[{\code{unsigned int len}}] \leavevmode
length of range in bytes

\end{description}

\textbf{Description}

sets \textbf{subbuf} to an xdr buffer representing the portion of \textbf{buf} of
length \textbf{len} starting at offset \textbf{base}.

\textbf{buf} and \textbf{subbuf} may be pointers to the same struct xdr\_buf.

Returns -1 if base of length are out of bounds.
\index{xdr\_buf\_trim (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_buf_trim}\pysiglinewithargsret{void \bfcode{xdr\_buf\_trim}}{struct xdr\_buf *\emph{buf}, unsigned int\emph{len}}{}
lop at most ``len'' bytes off the end of ``buf''

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_buf * buf}}] \leavevmode
buf to be trimmed

\item[{\code{unsigned int len}}] \leavevmode
number of bytes to reduce ``buf'' by

\end{description}

\textbf{Description}

Trim an xdr\_buf by the given number of bytes by fixing up the lengths. Note
that it's possible that we'll trim less than that amount if the xdr\_buf is
too small, or if (for instance) it's all in the head and the parser has
already read too far into it.
\index{xdr\_stream\_decode\_string\_dup (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_stream_decode_string_dup}\pysiglinewithargsret{ssize\_t \bfcode{xdr\_stream\_decode\_string\_dup}}{struct xdr\_stream *\emph{xdr}, char **\emph{str}, size\_t\emph{maxlen}, gfp\_t\emph{gfp\_flags}}{}
Decode and duplicate variable length string

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_stream * xdr}}] \leavevmode
pointer to xdr\_stream

\item[{\code{char ** str}}] \leavevmode
location to store pointer to string

\item[{\code{size\_t maxlen}}] \leavevmode
maximum acceptable string length

\item[{\code{gfp\_t gfp\_flags}}] \leavevmode
GFP mask to use

\end{description}

\textbf{Description}
\begin{description}
\item[{Return values:}] \leavevmode
On success, returns length of NUL-terminated string stored in \textbf{*ptr}
\code{-EBADMSG} on XDR buffer overflow
\code{-EMSGSIZE} if the size of the string would exceed \textbf{maxlen}
\code{-ENOMEM} on memory allocation failure

\end{description}
\index{svc\_print\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.svc_print_addr}\pysiglinewithargsret{char * \bfcode{svc\_print\_addr}}{struct svc\_rqst *\emph{rqstp}, char *\emph{buf}, size\_t\emph{len}}{}
Format rq\_addr field for printing

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct svc\_rqst * rqstp}}] \leavevmode
svc\_rqst struct containing address to print

\item[{\code{char * buf}}] \leavevmode
target buffer for formatted address

\item[{\code{size\_t len}}] \leavevmode
length of target buffer

\end{description}
\index{svc\_reserve (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.svc_reserve}\pysiglinewithargsret{void \bfcode{svc\_reserve}}{struct svc\_rqst *\emph{rqstp}, int\emph{space}}{}
change the space reserved for the reply to a request.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct svc\_rqst * rqstp}}] \leavevmode
The request in question

\item[{\code{int space}}] \leavevmode
new max space to reserve

\end{description}

\textbf{Description}

Each request reserves some space on the output queue of the transport
to make sure the reply fits.  This function reduces that reserved
space to be the amount of space used already, plus \textbf{space}.
\index{svc\_find\_xprt (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.svc_find_xprt}\pysiglinewithargsret{struct svc\_xprt * \bfcode{svc\_find\_xprt}}{struct svc\_serv *\emph{serv}, const char *\emph{xcl\_name}, struct net *\emph{net}, const sa\_family\_t\emph{af}, const unsigned short\emph{port}}{}
find an RPC transport instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct svc\_serv * serv}}] \leavevmode
pointer to svc\_serv to search

\item[{\code{const char * xcl\_name}}] \leavevmode
C string containing transport's class name

\item[{\code{struct net * net}}] \leavevmode
owner net pointer

\item[{\code{const sa\_family\_t af}}] \leavevmode
Address family of transport's local address

\item[{\code{const unsigned short port}}] \leavevmode
transport's IP port number

\end{description}

\textbf{Description}

Return the transport instance pointer for the endpoint accepting
connections/peer traffic from the specified transport class,
address family and port.

Specifying 0 for the address family or port is effectively a
wild-card, and will result in matching the first transport in the
service's list that has a matching class name.
\index{svc\_xprt\_names (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.svc_xprt_names}\pysiglinewithargsret{int \bfcode{svc\_xprt\_names}}{struct svc\_serv *\emph{serv}, char *\emph{buf}, const int\emph{buflen}}{}
format a buffer with a list of transport names

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct svc\_serv * serv}}] \leavevmode
pointer to an RPC service

\item[{\code{char * buf}}] \leavevmode
pointer to a buffer to be filled in

\item[{\code{const int buflen}}] \leavevmode
length of buffer to be filled in

\end{description}

\textbf{Description}

Fills in \textbf{buf} with a string containing a list of transport names,
each name terminated with `n'.

Returns positive length of the filled-in string on success; otherwise
a negative errno value is returned if an error occurs.
\index{xprt\_register\_transport (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_register_transport}\pysiglinewithargsret{int \bfcode{xprt\_register\_transport}}{struct xprt\_class *\emph{transport}}{}
register a transport implementation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xprt\_class * transport}}] \leavevmode
transport to register

\end{description}

\textbf{Description}

If a transport implementation is loaded as a kernel module, it can
call this interface to make itself known to the RPC client.

\textbf{Return}

0:           transport successfully registered
-EEXIST:     transport already registered
-EINVAL:     transport module being unloaded
\index{xprt\_unregister\_transport (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_unregister_transport}\pysiglinewithargsret{int \bfcode{xprt\_unregister\_transport}}{struct xprt\_class *\emph{transport}}{}
unregister a transport implementation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xprt\_class * transport}}] \leavevmode
transport to unregister

\end{description}

\textbf{Return}

0:           transport successfully unregistered
-ENOENT:     transport never registered
\index{xprt\_load\_transport (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_load_transport}\pysiglinewithargsret{int \bfcode{xprt\_load\_transport}}{const char *\emph{transport\_name}}{}
load a transport implementation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * transport\_name}}] \leavevmode
transport to load

\end{description}

\textbf{Return}

0:           transport successfully loaded
-ENOENT:     transport module not available
\index{xprt\_reserve\_xprt (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_reserve_xprt}\pysiglinewithargsret{int \bfcode{xprt\_reserve\_xprt}}{struct rpc\_xprt *\emph{xprt}, struct rpc\_task *\emph{task}}{}
serialize write access to transports

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_xprt * xprt}}] \leavevmode
pointer to the target transport

\item[{\code{struct rpc\_task * task}}] \leavevmode
task that is requesting access to the transport

\end{description}

\textbf{Description}

This prevents mixing the payload of separate requests, and prevents
transport connects from colliding with writes.  No congestion control
is provided.
\index{xprt\_release\_xprt (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_release_xprt}\pysiglinewithargsret{void \bfcode{xprt\_release\_xprt}}{struct rpc\_xprt *\emph{xprt}, struct rpc\_task *\emph{task}}{}
allow other requests to use a transport

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_xprt * xprt}}] \leavevmode
transport with other tasks potentially waiting

\item[{\code{struct rpc\_task * task}}] \leavevmode
task that is releasing access to the transport

\end{description}

\textbf{Description}

Note that ``task'' can be NULL.  No congestion control is provided.
\index{xprt\_release\_xprt\_cong (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_release_xprt_cong}\pysiglinewithargsret{void \bfcode{xprt\_release\_xprt\_cong}}{struct rpc\_xprt *\emph{xprt}, struct rpc\_task *\emph{task}}{}
allow other requests to use a transport

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_xprt * xprt}}] \leavevmode
transport with other tasks potentially waiting

\item[{\code{struct rpc\_task * task}}] \leavevmode
task that is releasing access to the transport

\end{description}

\textbf{Description}

Note that ``task'' can be NULL.  Another task is awoken to use the
transport if the transport's congestion window allows it.
\index{xprt\_release\_rqst\_cong (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_release_rqst_cong}\pysiglinewithargsret{void \bfcode{xprt\_release\_rqst\_cong}}{struct rpc\_task *\emph{task}}{}
housekeeping when request is complete

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_task * task}}] \leavevmode
RPC request that recently completed

\end{description}

\textbf{Description}

Useful for transports that require congestion control.
\index{xprt\_adjust\_cwnd (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_adjust_cwnd}\pysiglinewithargsret{void \bfcode{xprt\_adjust\_cwnd}}{struct rpc\_xprt *\emph{xprt}, struct rpc\_task *\emph{task}, int\emph{result}}{}
adjust transport congestion window

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_xprt * xprt}}] \leavevmode
pointer to xprt

\item[{\code{struct rpc\_task * task}}] \leavevmode
recently completed RPC request used to adjust window

\item[{\code{int result}}] \leavevmode
result code of completed RPC request

\end{description}

\textbf{Description}

The transport code maintains an estimate on the maximum number of out-
standing RPC requests, using a smoothed version of the congestion
avoidance implemented in 44BSD. This is basically the Van Jacobson
congestion algorithm: If a retransmit occurs, the congestion window is
halved; otherwise, it is incremented by 1/cwnd when
\begin{itemize}
\item {} 
a reply is received and

\item {} 
a full number of requests are outstanding and

\item {} 
the congestion window hasn't been updated recently.

\end{itemize}
\index{xprt\_wake\_pending\_tasks (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_wake_pending_tasks}\pysiglinewithargsret{void \bfcode{xprt\_wake\_pending\_tasks}}{struct rpc\_xprt *\emph{xprt}, int\emph{status}}{}
wake all tasks on a transport's pending queue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_xprt * xprt}}] \leavevmode
transport with waiting tasks

\item[{\code{int status}}] \leavevmode
result code to plant in each task before waking it

\end{description}
\index{xprt\_wait\_for\_buffer\_space (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_wait_for_buffer_space}\pysiglinewithargsret{void \bfcode{xprt\_wait\_for\_buffer\_space}}{struct rpc\_task *\emph{task}, rpc\_action\emph{action}}{}
wait for transport output buffer to clear

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_task * task}}] \leavevmode
task to be put to sleep

\item[{\code{rpc\_action action}}] \leavevmode
function pointer to be executed after wait

\end{description}

\textbf{Description}

Note that we only set the timer for the case of \code{RPC\_IS\_SOFT()}, since
we don't in general want to force a socket disconnection due to
an incomplete RPC call transmission.
\index{xprt\_write\_space (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_write_space}\pysiglinewithargsret{void \bfcode{xprt\_write\_space}}{struct rpc\_xprt *\emph{xprt}}{}
wake the task waiting for transport output buffer space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_xprt * xprt}}] \leavevmode
transport with waiting tasks

\end{description}

\textbf{Description}

Can be called in a soft IRQ context, so xprt\_write\_space never sleeps.
\index{xprt\_set\_retrans\_timeout\_def (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_set_retrans_timeout_def}\pysiglinewithargsret{void \bfcode{xprt\_set\_retrans\_timeout\_def}}{struct rpc\_task *\emph{task}}{}
set a request's retransmit timeout

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_task * task}}] \leavevmode
task whose timeout is to be set

\end{description}

\textbf{Description}

Set a request's retransmit timeout based on the transport's
default timeout parameters.  Used by transports that don't adjust
the retransmit timeout based on round-trip time estimation.
\index{xprt\_set\_retrans\_timeout\_rtt (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_set_retrans_timeout_rtt}\pysiglinewithargsret{void \bfcode{xprt\_set\_retrans\_timeout\_rtt}}{struct rpc\_task *\emph{task}}{}
set a request's retransmit timeout

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_task * task}}] \leavevmode
task whose timeout is to be set

\end{description}

\textbf{Description}

Set a request's retransmit timeout using the RTT estimator.
\index{xprt\_disconnect\_done (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_disconnect_done}\pysiglinewithargsret{void \bfcode{xprt\_disconnect\_done}}{struct rpc\_xprt *\emph{xprt}}{}
mark a transport as disconnected

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_xprt * xprt}}] \leavevmode
transport to flag for disconnect

\end{description}
\index{xprt\_force\_disconnect (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_force_disconnect}\pysiglinewithargsret{void \bfcode{xprt\_force\_disconnect}}{struct rpc\_xprt *\emph{xprt}}{}
force a transport to disconnect

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_xprt * xprt}}] \leavevmode
transport to disconnect

\end{description}
\index{xprt\_lookup\_rqst (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_lookup_rqst}\pysiglinewithargsret{struct rpc\_rqst * \bfcode{xprt\_lookup\_rqst}}{struct rpc\_xprt *\emph{xprt}, \_\_be32\emph{xid}}{}
find an RPC request corresponding to an XID

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_xprt * xprt}}] \leavevmode
transport on which the original request was transmitted

\item[{\code{\_\_be32 xid}}] \leavevmode
RPC XID of incoming reply

\end{description}
\index{xprt\_pin\_rqst (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_pin_rqst}\pysiglinewithargsret{void \bfcode{xprt\_pin\_rqst}}{struct rpc\_rqst *\emph{req}}{}
Pin a request on the transport receive list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_rqst * req}}] \leavevmode
Request to pin

\end{description}

\textbf{Description}

Caller must ensure this is atomic with the call to {\hyperref[networking/kapi:c.xprt_lookup_rqst]{\emph{\code{xprt\_lookup\_rqst()}}}}
so should be holding the xprt transport lock.
\index{xprt\_unpin\_rqst (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_unpin_rqst}\pysiglinewithargsret{void \bfcode{xprt\_unpin\_rqst}}{struct rpc\_rqst *\emph{req}}{}
Unpin a request on the transport receive list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_rqst * req}}] \leavevmode
Request to pin

\end{description}

\textbf{Description}

Caller should be holding the xprt transport lock.
\index{xprt\_complete\_rqst (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_complete_rqst}\pysiglinewithargsret{void \bfcode{xprt\_complete\_rqst}}{struct rpc\_task *\emph{task}, int\emph{copied}}{}
called when reply processing is complete

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_task * task}}] \leavevmode
RPC request that recently completed

\item[{\code{int copied}}] \leavevmode
actual number of bytes received from the transport

\end{description}

\textbf{Description}

Caller holds transport lock.
\index{xprt\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_get}\pysiglinewithargsret{struct rpc\_xprt * \bfcode{xprt\_get}}{struct rpc\_xprt *\emph{xprt}}{}
return a reference to an RPC transport.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_xprt * xprt}}] \leavevmode
pointer to the transport

\end{description}
\index{xprt\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xprt_put}\pysiglinewithargsret{void \bfcode{xprt\_put}}{struct rpc\_xprt *\emph{xprt}}{}
release a reference to an RPC transport.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_xprt * xprt}}] \leavevmode
pointer to the transport

\end{description}
\index{rpc\_wake\_up (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_wake_up}\pysiglinewithargsret{void \bfcode{rpc\_wake\_up}}{struct rpc\_wait\_queue *\emph{queue}}{}
wake up all rpc\_tasks

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_wait\_queue * queue}}] \leavevmode
rpc\_wait\_queue on which the tasks are sleeping

\end{description}

\textbf{Description}

Grabs queue-\textgreater{}lock
\index{rpc\_wake\_up\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_wake_up_status}\pysiglinewithargsret{void \bfcode{rpc\_wake\_up\_status}}{struct rpc\_wait\_queue *\emph{queue}, int\emph{status}}{}
wake up all rpc\_tasks and set their status value.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_wait\_queue * queue}}] \leavevmode
rpc\_wait\_queue on which the tasks are sleeping

\item[{\code{int status}}] \leavevmode
status value to set

\end{description}

\textbf{Description}

Grabs queue-\textgreater{}lock
\index{rpc\_malloc (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_malloc}\pysiglinewithargsret{int \bfcode{rpc\_malloc}}{struct rpc\_task *\emph{task}}{}
allocate RPC buffer resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_task * task}}] \leavevmode
RPC task

\end{description}

\textbf{Description}

A single memory region is allocated, which is split between the
RPC call and RPC reply that this task is being used for. When
this RPC is retired, the memory is released by calling rpc\_free.

To prevent rpciod from hanging, this allocator never sleeps,
returning -ENOMEM and suppressing warning if the request cannot
be serviced immediately. The caller can arrange to sleep in a
way that is safe for rpciod.

Most requests are `small' (under 2KiB) and can be serviced from a
mempool, ensuring that NFS reads and writes can always proceed,
and that there is good locality of reference for these buffers.

In order to avoid memory starvation triggering more writebacks of
NFS requests, we avoid using GFP\_KERNEL.
\index{rpc\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_free}\pysiglinewithargsret{void \bfcode{rpc\_free}}{struct rpc\_task *\emph{task}}{}
free RPC buffer resources allocated via rpc\_malloc

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_task * task}}] \leavevmode
RPC task

\end{description}
\index{xdr\_skb\_read\_bits (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_skb_read_bits}\pysiglinewithargsret{size\_t \bfcode{xdr\_skb\_read\_bits}}{struct xdr\_skb\_reader *\emph{desc}, void *\emph{to}, size\_t\emph{len}}{}
copy some data bits from skb to internal buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_skb\_reader * desc}}] \leavevmode
sk\_buff copy helper

\item[{\code{void * to}}] \leavevmode
copy destination

\item[{\code{size\_t len}}] \leavevmode
number of bytes to copy

\end{description}

\textbf{Description}

Possibly called several times to iterate over an sk\_buff and copy
data out of it.
\index{xdr\_partial\_copy\_from\_skb (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.xdr_partial_copy_from_skb}\pysiglinewithargsret{ssize\_t \bfcode{xdr\_partial\_copy\_from\_skb}}{struct xdr\_buf *\emph{xdr}, unsigned int\emph{base}, struct xdr\_skb\_reader *\emph{desc}, xdr\_skb\_read\_actor\emph{copy\_actor}}{}
copy data out of an skb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_buf * xdr}}] \leavevmode
target XDR buffer

\item[{\code{unsigned int base}}] \leavevmode
starting offset

\item[{\code{struct xdr\_skb\_reader * desc}}] \leavevmode
sk\_buff copy helper

\item[{\code{xdr\_skb\_read\_actor copy\_actor}}] \leavevmode
virtual method for copying data

\end{description}
\index{csum\_partial\_copy\_to\_xdr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.csum_partial_copy_to_xdr}\pysiglinewithargsret{int \bfcode{csum\_partial\_copy\_to\_xdr}}{struct xdr\_buf *\emph{xdr}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
checksum and copy data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct xdr\_buf * xdr}}] \leavevmode
target XDR buffer

\item[{\code{struct sk\_buff * skb}}] \leavevmode
source skb

\end{description}

\textbf{Description}

We have set things up such that we perform the checksum of the UDP
packet in parallel with the copies into the RPC client iovec.  -DaveM
\index{rpc\_alloc\_iostats (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_alloc_iostats}\pysiglinewithargsret{struct rpc\_iostats * \bfcode{rpc\_alloc\_iostats}}{struct rpc\_clnt *\emph{clnt}}{}
allocate an rpc\_iostats structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * clnt}}] \leavevmode
RPC program, version, and xprt

\end{description}
\index{rpc\_free\_iostats (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_free_iostats}\pysiglinewithargsret{void \bfcode{rpc\_free\_iostats}}{struct rpc\_iostats *\emph{stats}}{}
release an rpc\_iostats structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_iostats * stats}}] \leavevmode
doomed rpc\_iostats structure

\end{description}
\index{rpc\_count\_iostats\_metrics (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_count_iostats_metrics}\pysiglinewithargsret{void \bfcode{rpc\_count\_iostats\_metrics}}{const struct rpc\_task *\emph{task}, struct rpc\_iostats *\emph{op\_metrics}}{}
tally up per-task stats

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct rpc\_task * task}}] \leavevmode
completed rpc\_task

\item[{\code{struct rpc\_iostats * op\_metrics}}] \leavevmode
stat structure for OP that will accumulate stats from \textbf{task}

\end{description}
\index{rpc\_count\_iostats (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_count_iostats}\pysiglinewithargsret{void \bfcode{rpc\_count\_iostats}}{const struct rpc\_task *\emph{task}, struct rpc\_iostats *\emph{stats}}{}
tally up per-task stats

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct rpc\_task * task}}] \leavevmode
completed rpc\_task

\item[{\code{struct rpc\_iostats * stats}}] \leavevmode
array of stat structures

\end{description}

\textbf{Description}

Uses the statidx from \textbf{task}
\index{rpc\_queue\_upcall (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_queue_upcall}\pysiglinewithargsret{int \bfcode{rpc\_queue\_upcall}}{struct rpc\_pipe *\emph{pipe}, struct rpc\_pipe\_msg *\emph{msg}}{}
queue an upcall message to userspace

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_pipe * pipe}}] \leavevmode
upcall pipe on which to queue given message

\item[{\code{struct rpc\_pipe\_msg * msg}}] \leavevmode
message to queue

\end{description}

\textbf{Description}

Call with an \textbf{inode} created by \code{rpc\_mkpipe()} to queue an upcall.
A userspace process may then later read the upcall by performing a
read on an open file for this inode.  It is up to the caller to
initialize the fields of \textbf{msg} (other than \textbf{msg}-\textgreater{}list) appropriately.
\index{rpc\_mkpipe\_dentry (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_mkpipe_dentry}\pysiglinewithargsret{struct dentry * \bfcode{rpc\_mkpipe\_dentry}}{struct dentry *\emph{parent}, const char *\emph{name}, void *\emph{private}, struct rpc\_pipe *\emph{pipe}}{}
make an rpc\_pipefs file for kernel\textless{}-\textgreater{}userspace communication

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * parent}}] \leavevmode
dentry of directory to create new ``pipe'' in

\item[{\code{const char * name}}] \leavevmode
name of pipe

\item[{\code{void * private}}] \leavevmode
private data to associate with the pipe, for the caller's use

\item[{\code{struct rpc\_pipe * pipe}}] \leavevmode
\code{rpc\_pipe} containing input parameters

\end{description}

\textbf{Description}

Data is made available for userspace to read by calls to
{\hyperref[networking/kapi:c.rpc_queue_upcall]{\emph{\code{rpc\_queue\_upcall()}}}}.  The actual reads will result in calls to
\textbf{ops}-\textgreater{}upcall, which will be called with the file pointer,
message, and userspace buffer to copy to.

Writes can come at any time, and do not necessarily have to be
responses to upcalls.  They will result in calls to \textbf{msg}-\textgreater{}downcall.

The \textbf{private} argument passed here will be available to all these methods
from the file pointer, via RPC\_I(file\_inode(file))-\textgreater{}private.
\index{rpc\_unlink (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_unlink}\pysiglinewithargsret{int \bfcode{rpc\_unlink}}{struct dentry *\emph{dentry}}{}
remove a pipe

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct dentry * dentry}}] \leavevmode
dentry for the pipe, as returned from rpc\_mkpipe

\end{description}

\textbf{Description}

After this call, lookups will no longer find the pipe, and any
attempts to read or write using preexisting opens of the pipe will
return -EPIPE.
\index{rpc\_init\_pipe\_dir\_head (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_init_pipe_dir_head}\pysiglinewithargsret{void \bfcode{rpc\_init\_pipe\_dir\_head}}{struct rpc\_pipe\_dir\_head *\emph{pdh}}{}
initialise a struct rpc\_pipe\_dir\_head

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_pipe\_dir\_head * pdh}}] \leavevmode
pointer to struct rpc\_pipe\_dir\_head

\end{description}
\index{rpc\_init\_pipe\_dir\_object (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_init_pipe_dir_object}\pysiglinewithargsret{void \bfcode{rpc\_init\_pipe\_dir\_object}}{struct rpc\_pipe\_dir\_object *\emph{pdo}, const struct rpc\_pipe\_dir\_object\_ops *\emph{pdo\_ops}, void *\emph{pdo\_data}}{}
initialise a struct rpc\_pipe\_dir\_object

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_pipe\_dir\_object * pdo}}] \leavevmode
pointer to struct rpc\_pipe\_dir\_object

\item[{\code{const struct rpc\_pipe\_dir\_object\_ops * pdo\_ops}}] \leavevmode
pointer to const struct rpc\_pipe\_dir\_object\_ops

\item[{\code{void * pdo\_data}}] \leavevmode
pointer to caller-defined data

\end{description}
\index{rpc\_add\_pipe\_dir\_object (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_add_pipe_dir_object}\pysiglinewithargsret{int \bfcode{rpc\_add\_pipe\_dir\_object}}{struct net *\emph{net}, struct rpc\_pipe\_dir\_head *\emph{pdh}, struct rpc\_pipe\_dir\_object *\emph{pdo}}{}
associate a rpc\_pipe\_dir\_object to a directory

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net * net}}] \leavevmode
pointer to struct net

\item[{\code{struct rpc\_pipe\_dir\_head * pdh}}] \leavevmode
pointer to struct rpc\_pipe\_dir\_head

\item[{\code{struct rpc\_pipe\_dir\_object * pdo}}] \leavevmode
pointer to struct rpc\_pipe\_dir\_object

\end{description}
\index{rpc\_remove\_pipe\_dir\_object (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_remove_pipe_dir_object}\pysiglinewithargsret{void \bfcode{rpc\_remove\_pipe\_dir\_object}}{struct net *\emph{net}, struct rpc\_pipe\_dir\_head *\emph{pdh}, struct rpc\_pipe\_dir\_object *\emph{pdo}}{}
remove a rpc\_pipe\_dir\_object from a directory

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net * net}}] \leavevmode
pointer to struct net

\item[{\code{struct rpc\_pipe\_dir\_head * pdh}}] \leavevmode
pointer to struct rpc\_pipe\_dir\_head

\item[{\code{struct rpc\_pipe\_dir\_object * pdo}}] \leavevmode
pointer to struct rpc\_pipe\_dir\_object

\end{description}
\index{rpc\_find\_or\_alloc\_pipe\_dir\_object (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_find_or_alloc_pipe_dir_object}\pysiglinewithargsret{struct rpc\_pipe\_dir\_object * \bfcode{rpc\_find\_or\_alloc\_pipe\_dir\_object}}{struct net *\emph{net}, struct rpc\_pipe\_dir\_head *\emph{pdh}, int (*match) (struct rpc\_pipe\_dir\_object\emph{*}, void\emph{*}, struct rpc\_pipe\_dir\_object *(*alloc) (void\emph{*}, void *\emph{data}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net * net}}] \leavevmode
pointer to struct net

\item[{\code{struct rpc\_pipe\_dir\_head * pdh}}] \leavevmode
pointer to struct rpc\_pipe\_dir\_head

\item[{\code{int (*)(struct rpc\_pipe\_dir\_object *, void *) match}}] \leavevmode
match struct rpc\_pipe\_dir\_object to data

\item[{\code{struct rpc\_pipe\_dir\_object *(*)(void *) alloc}}] \leavevmode
allocate a new struct rpc\_pipe\_dir\_object

\item[{\code{void * data}}] \leavevmode
user defined data for \code{match()} and \code{alloc()}

\end{description}
\index{rpcb\_getport\_async (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpcb_getport_async}\pysiglinewithargsret{void \bfcode{rpcb\_getport\_async}}{struct rpc\_task *\emph{task}}{}
obtain the port for a given RPC service on a given host

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_task * task}}] \leavevmode
task that is waiting for portmapper request

\end{description}

\textbf{Description}

This one can be called for an ongoing RPC request, and can be used in
an async (rpciod) context.
\index{rpc\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_create}\pysiglinewithargsret{struct rpc\_clnt * \bfcode{rpc\_create}}{struct rpc\_create\_args *\emph{args}}{}
create an RPC client and transport with one call

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_create\_args * args}}] \leavevmode
rpc\_clnt create argument structure

\end{description}

\textbf{Description}

Creates and initializes an RPC transport and an RPC client.

It can ping the server in order to determine if it is up, and to see if
it supports this program and version.  RPC\_CLNT\_CREATE\_NOPING disables
this behavior so asynchronous tasks can also use rpc\_create.
\index{rpc\_clone\_client (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_clone_client}\pysiglinewithargsret{struct rpc\_clnt * \bfcode{rpc\_clone\_client}}{struct rpc\_clnt *\emph{clnt}}{}
Clone an RPC client structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * clnt}}] \leavevmode
RPC client whose parameters are copied

\end{description}

\textbf{Description}

Returns a fresh RPC client or an ERR\_PTR.
\index{rpc\_clone\_client\_set\_auth (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_clone_client_set_auth}\pysiglinewithargsret{struct rpc\_clnt * \bfcode{rpc\_clone\_client\_set\_auth}}{struct rpc\_clnt *\emph{clnt}, rpc\_authflavor\_t\emph{flavor}}{}
Clone an RPC client structure and set its auth

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * clnt}}] \leavevmode
RPC client whose parameters are copied

\item[{\code{rpc\_authflavor\_t flavor}}] \leavevmode
security flavor for new client

\end{description}

\textbf{Description}

Returns a fresh RPC client or an ERR\_PTR.
\index{rpc\_switch\_client\_transport (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_switch_client_transport}\pysiglinewithargsret{int \bfcode{rpc\_switch\_client\_transport}}{struct rpc\_clnt *\emph{clnt}, struct xprt\_create *\emph{args}, const struct rpc\_timeout *\emph{timeout}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * clnt}}] \leavevmode
pointer to a struct rpc\_clnt

\item[{\code{struct xprt\_create * args}}] \leavevmode
pointer to the new transport arguments

\item[{\code{const struct rpc\_timeout * timeout}}] \leavevmode
pointer to the new timeout parameters

\end{description}

\textbf{Description}

This function allows the caller to switch the RPC transport for the
rpc\_clnt structure `clnt' to allow it to connect to a mirrored NFS
server, for instance.  It assumes that the caller has ensured that
there are no active RPC tasks by using some form of locking.

Returns zero if ``clnt'' is now using the new xprt.  Otherwise a
negative errno is returned, and ``clnt'' continues to use the old
xprt.
\index{rpc\_clnt\_iterate\_for\_each\_xprt (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_clnt_iterate_for_each_xprt}\pysiglinewithargsret{int \bfcode{rpc\_clnt\_iterate\_for\_each\_xprt}}{struct rpc\_clnt *\emph{clnt}, int (*fn) (struct rpc\_clnt\emph{*}, struct rpc\_xprt\emph{*}, void\emph{*}, void *\emph{data}}{}
Apply a function to all transports

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * clnt}}] \leavevmode
pointer to client

\item[{\code{int (*)(struct rpc\_clnt *, struct rpc\_xprt *, void *) fn}}] \leavevmode
function to apply

\item[{\code{void * data}}] \leavevmode
void pointer to function data

\end{description}

\textbf{Description}

Iterates through the list of RPC transports currently attached to the
client and applies the function fn(clnt, xprt, data).

On error, the iteration stops, and the function returns the error value.
\index{rpc\_bind\_new\_program (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_bind_new_program}\pysiglinewithargsret{struct rpc\_clnt * \bfcode{rpc\_bind\_new\_program}}{struct rpc\_clnt *\emph{old}, const struct rpc\_program *\emph{program}, u32\emph{vers}}{}
bind a new RPC program to an existing client

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * old}}] \leavevmode
old rpc\_client

\item[{\code{const struct rpc\_program * program}}] \leavevmode
rpc program to set

\item[{\code{u32 vers}}] \leavevmode
rpc program version

\end{description}

\textbf{Description}

Clones the rpc client and sets up a new RPC program. This is mainly
of use for enabling different RPC programs to share the same transport.
The Sun NFSv2/v3 ACL protocol can do this.
\index{rpc\_run\_task (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_run_task}\pysiglinewithargsret{struct rpc\_task * \bfcode{rpc\_run\_task}}{const struct rpc\_task\_setup *\emph{task\_setup\_data}}{}
Allocate a new RPC task, then run rpc\_execute against it

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct rpc\_task\_setup * task\_setup\_data}}] \leavevmode
pointer to task initialisation data

\end{description}
\index{rpc\_call\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_call_sync}\pysiglinewithargsret{int \bfcode{rpc\_call\_sync}}{struct rpc\_clnt *\emph{clnt}, const struct rpc\_message *\emph{msg}, int\emph{flags}}{}
Perform a synchronous RPC call

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * clnt}}] \leavevmode
pointer to RPC client

\item[{\code{const struct rpc\_message * msg}}] \leavevmode
RPC call parameters

\item[{\code{int flags}}] \leavevmode
RPC call flags

\end{description}
\index{rpc\_call\_async (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_call_async}\pysiglinewithargsret{int \bfcode{rpc\_call\_async}}{struct rpc\_clnt *\emph{clnt}, const struct rpc\_message *\emph{msg}, int\emph{flags}, const struct rpc\_call\_ops *\emph{tk\_ops}, void *\emph{data}}{}
Perform an asynchronous RPC call

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * clnt}}] \leavevmode
pointer to RPC client

\item[{\code{const struct rpc\_message * msg}}] \leavevmode
RPC call parameters

\item[{\code{int flags}}] \leavevmode
RPC call flags

\item[{\code{const struct rpc\_call\_ops * tk\_ops}}] \leavevmode
RPC call ops

\item[{\code{void * data}}] \leavevmode
user call data

\end{description}
\index{rpc\_peeraddr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_peeraddr}\pysiglinewithargsret{size\_t \bfcode{rpc\_peeraddr}}{struct rpc\_clnt *\emph{clnt}, struct sockaddr *\emph{buf}, size\_t\emph{bufsize}}{}
extract remote peer address from clnt's xprt

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * clnt}}] \leavevmode
RPC client structure

\item[{\code{struct sockaddr * buf}}] \leavevmode
target buffer

\item[{\code{size\_t bufsize}}] \leavevmode
length of target buffer

\end{description}

\textbf{Description}

Returns the number of bytes that are actually in the stored address.
\index{rpc\_peeraddr2str (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_peeraddr2str}\pysiglinewithargsret{const char * \bfcode{rpc\_peeraddr2str}}{struct rpc\_clnt *\emph{clnt}, enum rpc\_display\_format\_t\emph{format}}{}
return remote peer address in printable format

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * clnt}}] \leavevmode
RPC client structure

\item[{\code{enum rpc\_display\_format\_t format}}] \leavevmode
address format

\end{description}

\textbf{Description}

NB: the lifetime of the memory referenced by the returned pointer is
the same as the rpc\_xprt itself.  As long as the caller uses this
pointer, it must hold the RCU read lock.
\index{rpc\_localaddr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_localaddr}\pysiglinewithargsret{int \bfcode{rpc\_localaddr}}{struct rpc\_clnt *\emph{clnt}, struct sockaddr *\emph{buf}, size\_t\emph{buflen}}{}
discover local endpoint address for an RPC client

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * clnt}}] \leavevmode
RPC client structure

\item[{\code{struct sockaddr * buf}}] \leavevmode
target buffer

\item[{\code{size\_t buflen}}] \leavevmode
size of target buffer, in bytes

\end{description}

\textbf{Description}

Returns zero and fills in ``buf'' and ``buflen'' if successful;
otherwise, a negative errno is returned.

This works even if the underlying transport is not currently connected,
or if the upper layer never previously provided a source address.

The result of this function call is transient: multiple calls in
succession may give different results, depending on how local
networking configuration changes over time.
\index{rpc\_net\_ns (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_net_ns}\pysiglinewithargsret{struct net * \bfcode{rpc\_net\_ns}}{struct rpc\_clnt *\emph{clnt}}{}
Get the network namespace for this RPC client

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * clnt}}] \leavevmode
RPC client to query

\end{description}
\index{rpc\_max\_payload (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_max_payload}\pysiglinewithargsret{size\_t \bfcode{rpc\_max\_payload}}{struct rpc\_clnt *\emph{clnt}}{}
Get maximum payload size for a transport, in bytes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * clnt}}] \leavevmode
RPC client to query

\end{description}

\textbf{Description}

For stream transports, this is one RPC record fragment (see RFC
1831), as we don't support multi-record requests yet.  For datagram
transports, this is the size of an IP packet minus the IP, UDP, and
RPC header sizes.
\index{rpc\_max\_bc\_payload (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_max_bc_payload}\pysiglinewithargsret{size\_t \bfcode{rpc\_max\_bc\_payload}}{struct rpc\_clnt *\emph{clnt}}{}
Get maximum backchannel payload size, in bytes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * clnt}}] \leavevmode
RPC client to query

\end{description}
\index{rpc\_force\_rebind (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_force_rebind}\pysiglinewithargsret{void \bfcode{rpc\_force\_rebind}}{struct rpc\_clnt *\emph{clnt}}{}
force transport to check that remote port is unchanged

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * clnt}}] \leavevmode
client to rebind

\end{description}
\index{rpc\_clnt\_test\_and\_add\_xprt (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_clnt_test_and_add_xprt}\pysiglinewithargsret{int \bfcode{rpc\_clnt\_test\_and\_add\_xprt}}{struct rpc\_clnt *\emph{clnt}, struct rpc\_xprt\_switch *\emph{xps}, struct rpc\_xprt *\emph{xprt}, void *\emph{dummy}}{}
Test and add a new transport to a rpc\_clnt

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * clnt}}] \leavevmode
pointer to struct rpc\_clnt

\item[{\code{struct rpc\_xprt\_switch * xps}}] \leavevmode
pointer to struct rpc\_xprt\_switch,

\item[{\code{struct rpc\_xprt * xprt}}] \leavevmode
pointer struct rpc\_xprt

\item[{\code{void * dummy}}] \leavevmode
unused

\end{description}
\index{rpc\_clnt\_setup\_test\_and\_add\_xprt (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_clnt_setup_test_and_add_xprt}\pysiglinewithargsret{int \bfcode{rpc\_clnt\_setup\_test\_and\_add\_xprt}}{struct rpc\_clnt *\emph{clnt}, struct rpc\_xprt\_switch *\emph{xps}, struct rpc\_xprt *\emph{xprt}, void *\emph{data}}{}
\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * clnt}}] \leavevmode
struct rpc\_clnt to get the new transport

\item[{\code{struct rpc\_xprt\_switch * xps}}] \leavevmode
the rpc\_xprt\_switch to hold the new transport

\item[{\code{struct rpc\_xprt * xprt}}] \leavevmode
the rpc\_xprt to test

\item[{\code{void * data}}] \leavevmode
a struct rpc\_add\_xprt\_test pointer that holds the test function
and test function call data

\end{description}

\textbf{Description}
\begin{description}
\item[{This is an rpc\_clnt\_add\_xprt \code{setup()} function which returns 1 so:}] \leavevmode
1) caller of the test function must dereference the rpc\_xprt\_switch
and the rpc\_xprt.
2) test function must call rpc\_xprt\_switch\_add\_xprt, usually in
the rpc\_call\_done routine.

\end{description}

Upon success (return of 1), the test function adds the new
transport to the rpc\_clnt xprt switch
\index{rpc\_clnt\_add\_xprt (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rpc_clnt_add_xprt}\pysiglinewithargsret{int \bfcode{rpc\_clnt\_add\_xprt}}{struct rpc\_clnt *\emph{clnt}, struct xprt\_create *\emph{xprtargs}, int (*setup) (struct rpc\_clnt\emph{*}, struct rpc\_xprt\_switch\emph{*}, struct rpc\_xprt\emph{*}, void\emph{*}, void *\emph{data}}{}
Add a new transport to a rpc\_clnt

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct rpc\_clnt * clnt}}] \leavevmode
pointer to struct rpc\_clnt

\item[{\code{struct xprt\_create * xprtargs}}] \leavevmode
pointer to struct xprt\_create

\item[{\code{int (*)(struct rpc\_clnt *, struct rpc\_xprt\_switch *, struct rpc\_xprt *, void *) setup}}] \leavevmode
callback to test and/or set up the connection

\item[{\code{void * data}}] \leavevmode
pointer to setup function data

\end{description}

\textbf{Description}

Creates a new transport using the parameters set in args and
adds it to clnt.
If ping is set, then test that connectivity succeeds before
adding the new transport.


\subsection{WiMAX}
\label{networking/kapi:wimax}\index{wimax\_msg\_alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.wimax_msg_alloc}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{wimax\_msg\_alloc}}{struct {\hyperref[networking/kapi:c.wimax_dev]{\emph{wimax\_dev}}} *\emph{wimax\_dev}, const char *\emph{pipe\_name}, const void *\emph{msg}, size\_t\emph{size}, gfp\_t\emph{gfp\_flags}}{}
Create a new skb for sending a message to userspace

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wimax\_dev * wimax\_dev}}] \leavevmode
WiMAX device descriptor

\item[{\code{const char * pipe\_name}}] \leavevmode
``named pipe'' the message will be sent to

\item[{\code{const void * msg}}] \leavevmode
pointer to the message data to send

\item[{\code{size\_t size}}] \leavevmode
size of the message to send (in bytes), including the header.

\item[{\code{gfp\_t gfp\_flags}}] \leavevmode
flags for memory allocation.

\end{description}

\textbf{Return}

\code{0} if ok, negative errno code on error

\textbf{Description}

Allocates an skb that will contain the message to send to user
space over the messaging pipe and initializes it, copying the
payload.

Once this call is done, you can deliver it with
{\hyperref[networking/kapi:c.wimax_msg_send]{\emph{\code{wimax\_msg\_send()}}}}.

IMPORTANT:

Don't use {\hyperref[networking/kapi:c.skb_push]{\emph{\code{skb\_push()}}}}/{\hyperref[networking/kapi:c.skb_pull]{\emph{\code{skb\_pull()}}}}/{\hyperref[networking/kapi:c.skb_reserve]{\emph{\code{skb\_reserve()}}}} on the skb, as
{\hyperref[networking/kapi:c.wimax_msg_send]{\emph{\code{wimax\_msg\_send()}}}} depends on skb-\textgreater{}data being placed at the
beginning of the user message.

Unlike other WiMAX stack calls, this call can be used way early,
even before {\hyperref[networking/kapi:c.wimax_dev_add]{\emph{\code{wimax\_dev\_add()}}}} is called, as long as the
wimax\_dev-\textgreater{}net\_dev pointer is set to point to a proper
net\_dev. This is so that drivers can use it early in case they need
to send stuff around or communicate with user space.
\index{wimax\_msg\_data\_len (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.wimax_msg_data_len}\pysiglinewithargsret{const void * \bfcode{wimax\_msg\_data\_len}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{msg}, size\_t *\emph{size}}{}
Return a pointer and size of a message's payload

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * msg}}] \leavevmode
Pointer to a message created with {\hyperref[networking/kapi:c.wimax_msg_alloc]{\emph{\code{wimax\_msg\_alloc()}}}}

\item[{\code{size\_t * size}}] \leavevmode
Pointer to where to store the message's size

\end{description}

\textbf{Description}

Returns the pointer to the message data.
\index{wimax\_msg\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.wimax_msg_data}\pysiglinewithargsret{const void * \bfcode{wimax\_msg\_data}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{msg}}{}
Return a pointer to a message's payload

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * msg}}] \leavevmode
Pointer to a message created with {\hyperref[networking/kapi:c.wimax_msg_alloc]{\emph{\code{wimax\_msg\_alloc()}}}}

\end{description}
\index{wimax\_msg\_len (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.wimax_msg_len}\pysiglinewithargsret{ssize\_t \bfcode{wimax\_msg\_len}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{msg}}{}
Return a message's payload length

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * msg}}] \leavevmode
Pointer to a message created with {\hyperref[networking/kapi:c.wimax_msg_alloc]{\emph{\code{wimax\_msg\_alloc()}}}}

\end{description}
\index{wimax\_msg\_send (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.wimax_msg_send}\pysiglinewithargsret{int \bfcode{wimax\_msg\_send}}{struct {\hyperref[networking/kapi:c.wimax_dev]{\emph{wimax\_dev}}} *\emph{wimax\_dev}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
Send a pre-allocated message to user space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wimax\_dev * wimax\_dev}}] \leavevmode
WiMAX device descriptor

\item[{\code{struct sk\_buff * skb}}] \leavevmode
{\hyperref[networking/kapi:c.sk_buff]{\emph{\code{struct sk\_buff}}}} returned by {\hyperref[networking/kapi:c.wimax_msg_alloc]{\emph{\code{wimax\_msg\_alloc()}}}}. Note the
ownership of \textbf{skb} is transferred to this function.

\end{description}

\textbf{Return}

0 if ok, \textless{} 0 errno code on error

\textbf{Description}

Sends a free-form message that was preallocated with
{\hyperref[networking/kapi:c.wimax_msg_alloc]{\emph{\code{wimax\_msg\_alloc()}}}} and filled up.

Assumes that once you pass an skb to this function for sending, it
owns it and will release it when done (on success).

IMPORTANT:

Don't use {\hyperref[networking/kapi:c.skb_push]{\emph{\code{skb\_push()}}}}/{\hyperref[networking/kapi:c.skb_pull]{\emph{\code{skb\_pull()}}}}/{\hyperref[networking/kapi:c.skb_reserve]{\emph{\code{skb\_reserve()}}}} on the skb, as
{\hyperref[networking/kapi:c.wimax_msg_send]{\emph{\code{wimax\_msg\_send()}}}} depends on skb-\textgreater{}data being placed at the
beginning of the user message.

Unlike other WiMAX stack calls, this call can be used way early,
even before {\hyperref[networking/kapi:c.wimax_dev_add]{\emph{\code{wimax\_dev\_add()}}}} is called, as long as the
wimax\_dev-\textgreater{}net\_dev pointer is set to point to a proper
net\_dev. This is so that drivers can use it early in case they need
to send stuff around or communicate with user space.
\index{wimax\_msg (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.wimax_msg}\pysiglinewithargsret{int \bfcode{wimax\_msg}}{struct {\hyperref[networking/kapi:c.wimax_dev]{\emph{wimax\_dev}}} *\emph{wimax\_dev}, const char *\emph{pipe\_name}, const void *\emph{buf}, size\_t\emph{size}, gfp\_t\emph{gfp\_flags}}{}
Send a message to user space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wimax\_dev * wimax\_dev}}] \leavevmode
WiMAX device descriptor (properly referenced)

\item[{\code{const char * pipe\_name}}] \leavevmode
``named pipe'' the message will be sent to

\item[{\code{const void * buf}}] \leavevmode
pointer to the message to send.

\item[{\code{size\_t size}}] \leavevmode
size of the buffer pointed to by \textbf{buf} (in bytes).

\item[{\code{gfp\_t gfp\_flags}}] \leavevmode
flags for memory allocation.

\end{description}

\textbf{Return}

\code{0} if ok, negative errno code on error.

\textbf{Description}

Sends a free-form message to user space on the device \textbf{wimax\_dev}.

\textbf{NOTES}

Once the \textbf{skb} is given to this function, who will own it and will
release it when done (unless it returns error).
\index{wimax\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.wimax_reset}\pysiglinewithargsret{int \bfcode{wimax\_reset}}{struct {\hyperref[networking/kapi:c.wimax_dev]{\emph{wimax\_dev}}} *\emph{wimax\_dev}}{}
Reset a WiMAX device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wimax\_dev * wimax\_dev}}] \leavevmode
WiMAX device descriptor

\end{description}

\textbf{Return}

\code{0} if ok and a warm reset was done (the device still exists in
the system).

-\code{ENODEV} if a cold/bus reset had to be done (device has
disconnected and reconnected, so current handle is not valid
any more).

-\code{EINVAL} if the device is not even registered.

Any other negative error code shall be considered as
non-recoverable.

\textbf{Description}

Called when wanting to reset the device for any reason. Device is
taken back to power on status.

This call blocks; on successful return, the device has completed the
reset process and is ready to operate.
\index{wimax\_report\_rfkill\_hw (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.wimax_report_rfkill_hw}\pysiglinewithargsret{void \bfcode{wimax\_report\_rfkill\_hw}}{struct {\hyperref[networking/kapi:c.wimax_dev]{\emph{wimax\_dev}}} *\emph{wimax\_dev}, enum wimax\_rf\_state\emph{state}}{}
Reports changes in the hardware RF switch

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wimax\_dev * wimax\_dev}}] \leavevmode
WiMAX device descriptor

\item[{\code{enum wimax\_rf\_state state}}] \leavevmode
New state of the RF Kill switch. \code{WIMAX\_RF\_ON} radio on,
\code{WIMAX\_RF\_OFF} radio off.

\end{description}

\textbf{Description}

When the device detects a change in the state of thehardware RF
switch, it must call this function to let the WiMAX kernel stack
know that the state has changed so it can be properly propagated.

The WiMAX stack caches the state (the driver doesn't need to). As
well, as the change is propagated it will come back as a request to
change the software state to mirror the hardware state.

If the device doesn't have a hardware kill switch, just report
it on initialization as always on (\code{WIMAX\_RF\_ON}, radio on).
\index{wimax\_report\_rfkill\_sw (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.wimax_report_rfkill_sw}\pysiglinewithargsret{void \bfcode{wimax\_report\_rfkill\_sw}}{struct {\hyperref[networking/kapi:c.wimax_dev]{\emph{wimax\_dev}}} *\emph{wimax\_dev}, enum wimax\_rf\_state\emph{state}}{}
Reports changes in the software RF switch

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wimax\_dev * wimax\_dev}}] \leavevmode
WiMAX device descriptor

\item[{\code{enum wimax\_rf\_state state}}] \leavevmode
New state of the RF kill switch. \code{WIMAX\_RF\_ON} radio on,
\code{WIMAX\_RF\_OFF} radio off.

\end{description}

\textbf{Description}

Reports changes in the software RF switch state to the WiMAX stack.

The main use is during initialization, so the driver can query the
device for its current software radio kill switch state and feed it
to the system.

On the side, the device does not change the software state by
itself. In practice, this can happen, as the device might decide to
switch (in software) the radio off for different reasons.
\index{wimax\_rfkill (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.wimax_rfkill}\pysiglinewithargsret{int \bfcode{wimax\_rfkill}}{struct {\hyperref[networking/kapi:c.wimax_dev]{\emph{wimax\_dev}}} *\emph{wimax\_dev}, enum wimax\_rf\_state\emph{state}}{}
Set the software RF switch state for a WiMAX device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wimax\_dev * wimax\_dev}}] \leavevmode
WiMAX device descriptor

\item[{\code{enum wimax\_rf\_state state}}] \leavevmode
New RF state.

\end{description}

\textbf{Return}

\textgreater{}= 0 toggle state if ok, \textless{} 0 errno code on error. The toggle state
is returned as a bitmap, bit 0 being the hardware RF state, bit 1
the software RF state.

0 means disabled (\code{WIMAX\_RF\_ON}, radio on), 1 means enabled radio
off (\code{WIMAX\_RF\_OFF}).

\textbf{Description}

Called by the user when he wants to request the WiMAX radio to be
switched on (\code{WIMAX\_RF\_ON}) or off (\code{WIMAX\_RF\_OFF}). With
\code{WIMAX\_RF\_QUERY}, just the current state is returned.

\textbf{NOTE}

This call will block until the operation is complete.
\index{wimax\_state\_change (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.wimax_state_change}\pysiglinewithargsret{void \bfcode{wimax\_state\_change}}{struct {\hyperref[networking/kapi:c.wimax_dev]{\emph{wimax\_dev}}} *\emph{wimax\_dev}, enum {\hyperref[networking/kapi:c.wimax_st]{\emph{wimax\_st}}}\emph{new\_state}}{}
Set the current state of a WiMAX device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wimax\_dev * wimax\_dev}}] \leavevmode
WiMAX device descriptor (properly referenced)

\item[{\code{enum wimax\_st new\_state}}] \leavevmode
New state to switch to

\end{description}

\textbf{Description}

This implements the state changes for the wimax devices. It will
\begin{itemize}
\item {} 
verify that the state transition is legal (for now it'll just
print a warning if not) according to the table in
linux/wimax.h's documentation for `enum wimax\_st'.

\item {} 
perform the actions needed for leaving the current state and
whichever are needed for entering the new state.

\item {} 
issue a report to user space indicating the new state (and an
optional payload with information about the new state).

\end{itemize}

\textbf{NOTE}

\textbf{wimax\_dev} must be locked
\index{wimax\_state\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.wimax_state_get}\pysiglinewithargsret{enum {\hyperref[networking/kapi:c.wimax_st]{\emph{wimax\_st}}} \bfcode{wimax\_state\_get}}{struct {\hyperref[networking/kapi:c.wimax_dev]{\emph{wimax\_dev}}} *\emph{wimax\_dev}}{}
Return the current state of a WiMAX device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wimax\_dev * wimax\_dev}}] \leavevmode
WiMAX device descriptor

\end{description}

\textbf{Return}

Current state of the device according to its driver.
\index{wimax\_dev\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.wimax_dev_init}\pysiglinewithargsret{void \bfcode{wimax\_dev\_init}}{struct {\hyperref[networking/kapi:c.wimax_dev]{\emph{wimax\_dev}}} *\emph{wimax\_dev}}{}
initialize a newly allocated instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wimax\_dev * wimax\_dev}}] \leavevmode
WiMAX device descriptor to initialize.

\end{description}

\textbf{Description}

Initializes fields of a freshly allocated \textbf{wimax\_dev} instance. This
function assumes that after allocation, the memory occupied by
\textbf{wimax\_dev} was zeroed.
\index{wimax\_dev\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.wimax_dev_add}\pysiglinewithargsret{int \bfcode{wimax\_dev\_add}}{struct {\hyperref[networking/kapi:c.wimax_dev]{\emph{wimax\_dev}}} *\emph{wimax\_dev}, struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{net\_dev}}{}
Register a new WiMAX device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wimax\_dev * wimax\_dev}}] \leavevmode
WiMAX device descriptor (as embedded in your \textbf{net\_dev}`s
priv data). You must have called {\hyperref[networking/kapi:c.wimax_dev_init]{\emph{\code{wimax\_dev\_init()}}}} on it before.

\item[{\code{struct net\_device * net\_dev}}] \leavevmode
net device the \textbf{wimax\_dev} is associated with. The
function expects \code{SET\_NETDEV\_DEV()} and {\hyperref[networking/kapi:c.register_netdev]{\emph{\code{register\_netdev()}}}} were
already called on it.

\end{description}

\textbf{Description}

Registers the new WiMAX device, sets up the user-kernel control
interface (generic netlink) and common WiMAX infrastructure.

Note that the parts that will allow interaction with user space are
setup at the very end, when the rest is in place, as once that
happens, the driver might get user space control requests via
netlink or from debugfs that might translate into calls into
wimax\_dev-\textgreater{}op\_*().
\index{wimax\_dev\_rm (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.wimax_dev_rm}\pysiglinewithargsret{void \bfcode{wimax\_dev\_rm}}{struct {\hyperref[networking/kapi:c.wimax_dev]{\emph{wimax\_dev}}} *\emph{wimax\_dev}}{}
Unregister an existing WiMAX device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct wimax\_dev * wimax\_dev}}] \leavevmode
WiMAX device descriptor

\end{description}

\textbf{Description}

Unregisters a WiMAX device previously registered for use with
\code{wimax\_add\_rm()}.

IMPORTANT! Must call before calling {\hyperref[networking/kapi:c.unregister_netdev]{\emph{\code{unregister\_netdev()}}}}.

After this function returns, you will not get any more user space
control requests (via netlink or debugfs) and thus to wimax\_dev-\textgreater{}ops.

Reentrancy control is ensured by setting the state to
\code{\_\_WIMAX\_ST\_QUIESCING}. rfkill operations coming through
wimax\_*rfkill*() will be stopped by the quiescing state; ops coming
from the rfkill subsystem will be stopped by the support being
removed by \code{wimax\_rfkill\_rm()}.
\index{wimax\_dev (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.wimax_dev}\pysigline{struct \bfcode{wimax\_dev}}
Generic WiMAX device

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct wimax\PYGZus{}dev \PYGZob{}
  struct net\PYGZus{}device *net\PYGZus{}dev;
  struct list\PYGZus{}head id\PYGZus{}table\PYGZus{}node;
  struct mutex mutex;
  struct mutex mutex\PYGZus{}reset;
  enum wimax\PYGZus{}st state;
  int (*op\PYGZus{}msg\PYGZus{}from\PYGZus{}user)(struct wimax\PYGZus{}dev *wimax\PYGZus{}dev,const char *,const void *, size\PYGZus{}t, const struct genl\PYGZus{}info *info);
  int (*op\PYGZus{}rfkill\PYGZus{}sw\PYGZus{}toggle)(struct wimax\PYGZus{}dev *wimax\PYGZus{}dev, enum wimax\PYGZus{}rf\PYGZus{}state);
  int (*op\PYGZus{}reset)(struct wimax\PYGZus{}dev *wimax\PYGZus{}dev);
  struct rfkill *rfkill;
  unsigned int rf\PYGZus{}hw;
  unsigned int rf\PYGZus{}sw;
  char name[32];
  struct dentry *debugfs\PYGZus{}dentry;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{net\_dev}}] \leavevmode
{[}fill{]} Pointer to the {\hyperref[networking/kapi:c.net_device]{\emph{\code{struct net\_device}}}} this WiMAX
device implements.

\item[{\code{id\_table\_node}}] \leavevmode
{[}private{]} link to the list of wimax devices kept by
id-table.c. Protected by it's own spinlock.

\item[{\code{mutex}}] \leavevmode
{[}private{]} Serializes all concurrent access and execution of
operations.

\item[{\code{mutex\_reset}}] \leavevmode
{[}private{]} Serializes reset operations. Needs to be a
different mutex because as part of the reset operation, the
driver has to call back into the stack to do things such as
state change, that require wimax\_dev-\textgreater{}mutex.

\item[{\code{state}}] \leavevmode
{[}private{]} Current state of the WiMAX device.

\item[{\code{op\_msg\_from\_user}}] \leavevmode
{[}fill{]} Driver-specific operation to
handle a raw message from user space to the driver. The
driver can send messages to user space using with
\code{wimax\_msg\_to\_user()}.

\item[{\code{op\_rfkill\_sw\_toggle}}] \leavevmode
{[}fill{]} Driver-specific operation to act on
userspace (or any other agent) requesting the WiMAX device to
change the RF Kill software switch (WIMAX\_RF\_ON or
WIMAX\_RF\_OFF).
If such hardware support is not present, it is assumed the
radio cannot be switched off and it is always on (and the stack
will error out when trying to switch it off). In such case,
this function pointer can be left as NULL.

\item[{\code{op\_reset}}] \leavevmode
{[}fill{]} Driver specific operation to reset the
device.
This operation should always attempt first a warm reset that
does not disconnect the device from the bus and return 0.
If that fails, it should resort to some sort of cold or bus
reset (even if it implies a bus disconnection and device
disappearance). In that case, -ENODEV should be returned to
indicate the device is gone.
This operation has to be synchronous, and return only when the
reset is complete. In case of having had to resort to bus/cold
reset implying a device disconnection, the call is allowed to
return immediately.

\item[{\code{rfkill}}] \leavevmode
{[}private{]} integration into the RF-Kill infrastructure.

\item[{\code{rf\_hw}}] \leavevmode
{[}private{]} State of the hardware radio switch (OFF/ON)

\item[{\code{rf\_sw}}] \leavevmode
{[}private{]} State of the software radio switch (OFF/ON)

\item[{\code{name}}] \leavevmode
{[}fill{]} A way to identify this device. We need to register a
name with many subsystems (rfkill, workqueue creation, etc).
We can't use the network device name as that
might change and in some instances we don't know it yet (until
we don't call {\hyperref[networking/kapi:c.register_netdev]{\emph{\code{register\_netdev()}}}}). So we generate an unique one
using the driver name and device bus id, place it here and use
it across the board. Recommended naming:
DRIVERNAME-BUSNAME:BUSID (dev-\textgreater{}bus-\textgreater{}name, dev-\textgreater{}bus\_id).

\item[{\code{debugfs\_dentry}}] \leavevmode
{[}private{]} Used to hook up a debugfs entry. This
shows up in the debugfs root as wimax:DEVICENAME.

\end{description}

\textbf{NOTE}
\begin{description}
\item[{wimax\_dev-\textgreater{}mutex is NOT locked when this op is being}] \leavevmode
called; however, wimax\_dev-\textgreater{}mutex\_reset IS locked to ensure
serialization of calls to {\hyperref[networking/kapi:c.wimax_reset]{\emph{\code{wimax\_reset()}}}}.
See {\hyperref[networking/kapi:c.wimax_reset]{\emph{\code{wimax\_reset()}}}}`s documentation.

\end{description}

\textbf{Description}

This structure defines a common interface to access all WiMAX
devices from different vendors and provides a common API as well as
a free-form device-specific messaging channel.
\begin{description}
\item[{Usage:}] \leavevmode\begin{enumerate}
\item {} 
Embed a {\hyperref[networking/kapi:c.wimax_dev]{\emph{\code{struct wimax\_dev}}}} at \emph{the beginning} the network
device structure so that {\hyperref[networking/kapi:c.netdev_priv]{\emph{\code{netdev\_priv()}}}} points to it.

\item {} 
\code{memset()} it to zero

\item {} 
Initialize with {\hyperref[networking/kapi:c.wimax_dev_init]{\emph{\code{wimax\_dev\_init()}}}}. This will leave the WiMAX
device in the \code{\_\_WIMAX\_ST\_NULL} state.

\item {} 
Fill all the fields marked with {[}fill{]}; once called
{\hyperref[networking/kapi:c.wimax_dev_add]{\emph{\code{wimax\_dev\_add()}}}}, those fields CANNOT be modified.

\item {} 
Call {\hyperref[networking/kapi:c.wimax_dev_add]{\emph{\code{wimax\_dev\_add()}}}} \emph{after} registering the network
device. This will leave the WiMAX device in the \code{WIMAX\_ST\_DOWN}
state.
Protect the driver's net\_device-\textgreater{}:c:func:\emph{open()} against succeeding if
the wimax device state is lower than \code{WIMAX\_ST\_DOWN}.

\item {} 
Select when the device is going to be turned on/initialized;
for example, it could be initialized on `ifconfig up' (when the
netdev op `\code{open()}` is called on the driver).

\end{enumerate}

\end{description}

When the device is initialized (at \emph{ifconfig up} time, or right
after calling {\hyperref[networking/kapi:c.wimax_dev_add]{\emph{\code{wimax\_dev\_add()}}}} from \code{\_probe()}, make sure the
following steps are taken
\begin{enumerate}
\item {} 
Move the device to \code{WIMAX\_ST\_UNINITIALIZED}. This is needed so
some API calls that shouldn't work until the device is ready
can be blocked.

\item {} 
Initialize the device. Make sure to turn the SW radio switch
off and move the device to state \code{WIMAX\_ST\_RADIO\_OFF} when
done. When just initialized, a device should be left in RADIO
OFF state until user space devices to turn it on.

\item {} 
Query the device for the state of the hardware rfkill switch
and call \code{wimax\_rfkill\_report\_hw()} and \code{wimax\_rfkill\_report\_sw()}
as needed. See below.

\end{enumerate}

{\hyperref[networking/kapi:c.wimax_dev_rm]{\emph{\code{wimax\_dev\_rm()}}}} undoes before unregistering the network device. Once
{\hyperref[networking/kapi:c.wimax_dev_add]{\emph{\code{wimax\_dev\_add()}}}} is called, the driver can get called on the
wimax\_dev-\textgreater{}op\_* function pointers

CONCURRENCY:

The stack provides a mutex for each device that will disallow API
calls happening concurrently; thus, op calls into the driver
through the wimax\_dev-\textgreater{}op*() function pointers will always be
serialized and \emph{never} concurrent.

For locking, take wimax\_dev-\textgreater{}mutex is taken; (most) operations in
the API have to check for \code{wimax\_dev\_is\_ready()} to return 0 before
continuing (this is done internally).

REFERENCE COUNTING:

The WiMAX device is reference counted by the associated network
device. The only operation that can be used to reference the device
is \code{wimax\_dev\_get\_by\_genl\_info()}, and the reference it acquires has
to be released with dev\_put(wimax\_dev-\textgreater{}net\_dev).

RFKILL:

At startup, both HW and SW radio switchess are assumed to be off.

At initialization time {[}after calling {\hyperref[networking/kapi:c.wimax_dev_add]{\emph{\code{wimax\_dev\_add()}}}}{]}, have the
driver query the device for the status of the software and hardware
RF kill switches and call {\hyperref[networking/kapi:c.wimax_report_rfkill_hw]{\emph{\code{wimax\_report\_rfkill\_hw()}}}} and
\code{wimax\_rfkill\_report\_sw()} to indicate their state. If any is
missing, just call it to indicate it is ON (radio always on).

Whenever the driver detects a change in the state of the RF kill
switches, it should call {\hyperref[networking/kapi:c.wimax_report_rfkill_hw]{\emph{\code{wimax\_report\_rfkill\_hw()}}}} or
{\hyperref[networking/kapi:c.wimax_report_rfkill_sw]{\emph{\code{wimax\_report\_rfkill\_sw()}}}} to report it to the stack.
\index{wimax\_st (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.wimax_st}\pysigline{enum \bfcode{wimax\_st}}
The different states of a WiMAX device

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{\_\_WIMAX\_ST\_NULL}}] \leavevmode
The device structure has been allocated and zeroed,
but still {\hyperref[networking/kapi:c.wimax_dev_add]{\emph{\code{wimax\_dev\_add()}}}} hasn't been called. There is no state.

\item[{\code{WIMAX\_ST\_DOWN}}] \leavevmode
The device has been registered with the WiMAX and
networking stacks, but it is not initialized (normally that is
done with `ifconfig DEV up' {[}or equivalent{]}, which can upload
firmware and enable communications with the device).
In this state, the device is powered down and using as less
power as possible.
This state is the default after a call to {\hyperref[networking/kapi:c.wimax_dev_add]{\emph{\code{wimax\_dev\_add()}}}}. It
is ok to have drivers move directly to \code{WIMAX\_ST\_UNINITIALIZED}
or \code{WIMAX\_ST\_RADIO\_OFF} in \code{\_probe()} after the call to
{\hyperref[networking/kapi:c.wimax_dev_add]{\emph{\code{wimax\_dev\_add()}}}}.
It is recommended that the driver leaves this state when
calling `ifconfig DEV up' and enters it back on `ifconfig DEV
down'.

\item[{\code{\_\_WIMAX\_ST\_QUIESCING}}] \leavevmode
The device is being torn down, so no API
operations are allowed to proceed except the ones needed to
complete the device clean up process.

\item[{\code{WIMAX\_ST\_UNINITIALIZED}}] \leavevmode
{[}optional{]} Communication with the device
is setup, but the device still requires some configuration
before being operational.
Some WiMAX API calls might work.

\item[{\code{WIMAX\_ST\_RADIO\_OFF}}] \leavevmode
The device is fully up; radio is off (wether
by hardware or software switches).
It is recommended to always leave the device in this state
after initialization.

\item[{\code{WIMAX\_ST\_READY}}] \leavevmode
The device is fully up and radio is on.

\item[{\code{WIMAX\_ST\_SCANNING}}] \leavevmode
{[}optional{]} The device has been instructed to
scan. In this state, the device cannot be actively connected to
a network.

\item[{\code{WIMAX\_ST\_CONNECTING}}] \leavevmode
The device is connecting to a network. This
state exists because in some devices, the connect process can
include a number of negotiations between user space, kernel
space and the device. User space needs to know what the device
is doing. If the connect sequence in a device is atomic and
fast, the device can transition directly to CONNECTED

\item[{\code{WIMAX\_ST\_CONNECTED}}] \leavevmode
The device is connected to a network.

\item[{\code{\_\_WIMAX\_ST\_INVALID}}] \leavevmode
This is an invalid state used to mark the
maximum numeric value of states.

\end{description}

\textbf{Description}

Transitions from one state to another one are atomic and can only
be caused in kernel space with {\hyperref[networking/kapi:c.wimax_state_change]{\emph{\code{wimax\_state\_change()}}}}. To read the
state, use {\hyperref[networking/kapi:c.wimax_state_get]{\emph{\code{wimax\_state\_get()}}}}.

States starting with \_\_ are internal and shall not be used or
referred to by drivers or userspace. They look ugly, but that's the
point -- if any use is made non-internal to the stack, it is easier
to catch on review.

All API operations {[}with well defined exceptions{]} will take the
device mutex before starting and then check the state. If the state
is \code{\_\_WIMAX\_ST\_NULL}, \code{WIMAX\_ST\_DOWN}, \code{WIMAX\_ST\_UNINITIALIZED} or
\code{\_\_WIMAX\_ST\_QUIESCING}, it will drop the lock and quit with
-\code{EINVAL}, -\code{ENOMEDIUM}, -\code{ENOTCONN} or -\code{ESHUTDOWN}.

The order of the definitions is important, so we can do numerical
comparisons (eg: \textless{} \code{WIMAX\_ST\_RADIO\_OFF} means the device is not ready
to operate).


\section{Network device support}
\label{networking/kapi:network-device-support}

\subsection{Driver Support}
\label{networking/kapi:driver-support}\index{dev\_add\_pack (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_add_pack}\pysiglinewithargsret{void \bfcode{dev\_add\_pack}}{struct packet\_type *\emph{pt}}{}
add packet handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct packet\_type * pt}}] \leavevmode
packet type declaration

\end{description}

\textbf{Description}
\begin{quote}

Add a protocol handler to the networking stack. The passed \code{packet\_type}
is linked into kernel lists and may not be freed until it has been
removed from the kernel lists.

This call does not sleep therefore it can not
guarantee all CPU's that are in middle of receiving packets
will see the new packet type (until the next received packet).
\end{quote}
\index{\_\_dev\_remove\_pack (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__dev_remove_pack}\pysiglinewithargsret{void \bfcode{\_\_dev\_remove\_pack}}{struct packet\_type *\emph{pt}}{}
remove packet handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct packet\_type * pt}}] \leavevmode
packet type declaration

\end{description}

\textbf{Description}
\begin{quote}

Remove a protocol handler that was previously added to the kernel
protocol handlers by {\hyperref[networking/kapi:c.dev_add_pack]{\emph{\code{dev\_add\_pack()}}}}. The passed \code{packet\_type} is removed
from the kernel lists and can be freed or reused once this function
returns.

The packet type might still be in use by receivers
and must not be freed until after all the CPU's have gone
through a quiescent state.
\end{quote}
\index{dev\_remove\_pack (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_remove_pack}\pysiglinewithargsret{void \bfcode{dev\_remove\_pack}}{struct packet\_type *\emph{pt}}{}
remove packet handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct packet\_type * pt}}] \leavevmode
packet type declaration

\end{description}

\textbf{Description}
\begin{quote}

Remove a protocol handler that was previously added to the kernel
protocol handlers by {\hyperref[networking/kapi:c.dev_add_pack]{\emph{\code{dev\_add\_pack()}}}}. The passed \code{packet\_type} is removed
from the kernel lists and can be freed or reused once this function
returns.

This call sleeps to guarantee that no CPU is looking at the packet
type after return.
\end{quote}
\index{dev\_add\_offload (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_add_offload}\pysiglinewithargsret{void \bfcode{dev\_add\_offload}}{struct packet\_offload *\emph{po}}{}
register offload handlers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct packet\_offload * po}}] \leavevmode
protocol offload declaration

\end{description}

\textbf{Description}
\begin{quote}

Add protocol offload handlers to the networking stack. The passed
\code{proto\_offload} is linked into kernel lists and may not be freed until
it has been removed from the kernel lists.

This call does not sleep therefore it can not
guarantee all CPU's that are in middle of receiving packets
will see the new offload handlers (until the next received packet).
\end{quote}
\index{dev\_remove\_offload (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_remove_offload}\pysiglinewithargsret{void \bfcode{dev\_remove\_offload}}{struct packet\_offload *\emph{po}}{}
remove packet offload handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct packet\_offload * po}}] \leavevmode
packet offload declaration

\end{description}

\textbf{Description}
\begin{quote}

Remove a packet offload handler that was previously added to the kernel
offload handlers by {\hyperref[networking/kapi:c.dev_add_offload]{\emph{\code{dev\_add\_offload()}}}}. The passed \code{offload\_type} is
removed from the kernel lists and can be freed or reused once this
function returns.

This call sleeps to guarantee that no CPU is looking at the packet
type after return.
\end{quote}
\index{netdev\_boot\_setup\_check (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_boot_setup_check}\pysiglinewithargsret{int \bfcode{netdev\_boot\_setup\_check}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
check boot time settings

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
the netdevice

\end{description}

\textbf{Description}

Check boot time settings for the device.
The found settings are set for the device to be used
later in the device probing.
Returns 0 if no settings found, 1 if they are.
\index{dev\_get\_iflink (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_get_iflink}\pysiglinewithargsret{int \bfcode{dev\_get\_iflink}}{const struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
get `iflink' value of a interface

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct net\_device * dev}}] \leavevmode
targeted interface

\end{description}

\textbf{Description}
\begin{quote}

Indicates the ifindex the interface is linked to.
Physical interfaces have the same `ifindex' and `iflink' values.
\end{quote}
\index{dev\_fill\_metadata\_dst (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_fill_metadata_dst}\pysiglinewithargsret{int \bfcode{dev\_fill\_metadata\_dst}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
Retrieve tunnel egress information.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
targeted interface

\item[{\code{struct sk\_buff * skb}}] \leavevmode
The packet.

\end{description}

\textbf{Description}
\begin{quote}

For better visibility of tunnel traffic OVS needs to retrieve
egress tunnel information for a packet. Following API allows
user to get this info.
\end{quote}
\index{\_\_dev\_get\_by\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__dev_get_by_name}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} * \bfcode{\_\_dev\_get\_by\_name}}{struct net *\emph{net}, const char *\emph{name}}{}
find a device by its name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net * net}}] \leavevmode
the applicable net namespace

\item[{\code{const char * name}}] \leavevmode
name to find

\end{description}

\textbf{Description}
\begin{quote}

Find an interface by name. Must be called under RTNL semaphore
or \textbf{dev\_base\_lock}. If the name is found a pointer to the device
is returned. If the name is not found then \code{NULL} is returned. The
reference counters are not incremented so the caller must be
careful with locks.
\end{quote}
\index{dev\_get\_by\_name\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_get_by_name_rcu}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} * \bfcode{dev\_get\_by\_name\_rcu}}{struct net *\emph{net}, const char *\emph{name}}{}
find a device by its name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net * net}}] \leavevmode
the applicable net namespace

\item[{\code{const char * name}}] \leavevmode
name to find

\end{description}

\textbf{Description}

Find an interface by name.
If the name is found a pointer to the device is returned.
If the name is not found then \code{NULL} is returned.
The reference counters are not incremented so the caller must be
careful with locks. The caller must hold RCU lock.
\index{dev\_get\_by\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_get_by_name}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} * \bfcode{dev\_get\_by\_name}}{struct net *\emph{net}, const char *\emph{name}}{}
find a device by its name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net * net}}] \leavevmode
the applicable net namespace

\item[{\code{const char * name}}] \leavevmode
name to find

\end{description}

\textbf{Description}
\begin{quote}

Find an interface by name. This can be called from any
context and does its own locking. The returned handle has
the usage count incremented and the caller must use {\hyperref[networking/kapi:c.dev_put]{\emph{\code{dev\_put()}}}} to
release it when it is no longer needed. \code{NULL} is returned if no
matching device is found.
\end{quote}
\index{\_\_dev\_get\_by\_index (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__dev_get_by_index}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} * \bfcode{\_\_dev\_get\_by\_index}}{struct net *\emph{net}, int\emph{ifindex}}{}
find a device by its ifindex

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net * net}}] \leavevmode
the applicable net namespace

\item[{\code{int ifindex}}] \leavevmode
index of device

\end{description}

\textbf{Description}
\begin{quote}

Search for an interface by index. Returns \code{NULL} if the device
is not found or a pointer to the device. The device has not
had its reference counter increased so the caller must be careful
about locking. The caller must hold either the RTNL semaphore
or \textbf{dev\_base\_lock}.
\end{quote}
\index{dev\_get\_by\_index\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_get_by_index_rcu}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} * \bfcode{dev\_get\_by\_index\_rcu}}{struct net *\emph{net}, int\emph{ifindex}}{}
find a device by its ifindex

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net * net}}] \leavevmode
the applicable net namespace

\item[{\code{int ifindex}}] \leavevmode
index of device

\end{description}

\textbf{Description}
\begin{quote}

Search for an interface by index. Returns \code{NULL} if the device
is not found or a pointer to the device. The device has not
had its reference counter increased so the caller must be careful
about locking. The caller must hold RCU lock.
\end{quote}
\index{dev\_get\_by\_index (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_get_by_index}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} * \bfcode{dev\_get\_by\_index}}{struct net *\emph{net}, int\emph{ifindex}}{}
find a device by its ifindex

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net * net}}] \leavevmode
the applicable net namespace

\item[{\code{int ifindex}}] \leavevmode
index of device

\end{description}

\textbf{Description}
\begin{quote}

Search for an interface by index. Returns NULL if the device
is not found or a pointer to the device. The device returned has
had a reference added and the pointer is safe until the user calls
dev\_put to indicate they have finished with it.
\end{quote}
\index{dev\_get\_by\_napi\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_get_by_napi_id}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} * \bfcode{dev\_get\_by\_napi\_id}}{unsigned int\emph{napi\_id}}{}
find a device by napi\_id

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int napi\_id}}] \leavevmode
ID of the NAPI struct

\end{description}

\textbf{Description}
\begin{quote}

Search for an interface by NAPI ID. Returns \code{NULL} if the device
is not found or a pointer to the device. The device has not had
its reference counter increased so the caller must be careful
about locking. The caller must hold RCU lock.
\end{quote}
\index{dev\_getbyhwaddr\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_getbyhwaddr_rcu}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} * \bfcode{dev\_getbyhwaddr\_rcu}}{struct net *\emph{net}, unsigned short\emph{type}, const char *\emph{ha}}{}
find a device by its hardware address

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net * net}}] \leavevmode
the applicable net namespace

\item[{\code{unsigned short type}}] \leavevmode
media type of device

\item[{\code{const char * ha}}] \leavevmode
hardware address

\end{description}

\textbf{Description}
\begin{quote}

Search for an interface by MAC address. Returns NULL if the device
is not found or a pointer to the device.
The caller must hold RCU or RTNL.
The returned device has not had its ref count increased
and the caller must therefore be careful about locking
\end{quote}
\index{\_\_dev\_get\_by\_flags (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__dev_get_by_flags}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} * \bfcode{\_\_dev\_get\_by\_flags}}{struct net *\emph{net}, unsigned short\emph{if\_flags}, unsigned short\emph{mask}}{}
find any device with given flags

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net * net}}] \leavevmode
the applicable net namespace

\item[{\code{unsigned short if\_flags}}] \leavevmode
IFF\_* values

\item[{\code{unsigned short mask}}] \leavevmode
bitmask of bits in if\_flags to check

\end{description}

\textbf{Description}
\begin{quote}

Search for any interface with the given flags. Returns NULL if a device
is not found or a pointer to the device. Must be called inside
\code{rtnl\_lock()}, and result refcount is unchanged.
\end{quote}
\index{dev\_valid\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_valid_name}\pysiglinewithargsret{bool \bfcode{dev\_valid\_name}}{const char *\emph{name}}{}
check if name is okay for network device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * name}}] \leavevmode
name string

\end{description}

\textbf{Description}
\begin{quote}

Network device names need to be valid file names to
to allow sysfs to work.  We also disallow any kind of
whitespace.
\end{quote}
\index{dev\_alloc\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_alloc_name}\pysiglinewithargsret{int \bfcode{dev\_alloc\_name}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, const char *\emph{name}}{}
allocate a name for a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{const char * name}}] \leavevmode
name format string

\end{description}

\textbf{Description}
\begin{quote}

Passed a format string - eg ``lt{}`{}`d{}`{}`'' it will try and find a suitable
id. It scans list of devices to build up a free map, then chooses
the first empty slot. The caller must hold the dev\_base or rtnl lock
while allocating the name and adding the device in order to avoid
duplicates.
Limited to bits\_per\_byte * page size devices (ie 32K on most platforms).
Returns the number of the unit assigned or a negative errno code.
\end{quote}
\index{netdev\_features\_change (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_features_change}\pysiglinewithargsret{void \bfcode{netdev\_features\_change}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
device changes features

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device to cause notification

\end{description}

\textbf{Description}
\begin{quote}

Called to indicate a device has changed features.
\end{quote}
\index{netdev\_state\_change (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_state_change}\pysiglinewithargsret{void \bfcode{netdev\_state\_change}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
device changes state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device to cause notification

\end{description}

\textbf{Description}
\begin{quote}

Called to indicate a device has changed state. This function calls
the notifier chains for netdev\_chain and sends a NEWLINK message
to the routing socket.
\end{quote}
\index{netdev\_notify\_peers (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_notify_peers}\pysiglinewithargsret{void \bfcode{netdev\_notify\_peers}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
notify network peers about existence of \textbf{dev}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}

Generate traffic such that interested network peers are aware of
\textbf{dev}, such as by generating a gratuitous ARP. This may be used when
a device wants to inform the rest of the network about some sort of
reconfiguration such as a failover event or virtual machine
migration.
\index{dev\_open (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_open}\pysiglinewithargsret{int \bfcode{dev\_open}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
prepare an interface for use.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device to open

\end{description}

\textbf{Description}
\begin{quote}

Takes a device from down to up state. The device's private open
function is invoked and then the multicast lists are loaded. Finally
the device is moved into the up state and a \code{NETDEV\_UP} message is
sent to the netdev notifier chain.

Calling this function on an active interface is a nop. On a failure
a negative errno code is returned.
\end{quote}
\index{dev\_close (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_close}\pysiglinewithargsret{void \bfcode{dev\_close}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
shutdown an interface.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device to shutdown

\end{description}

\textbf{Description}
\begin{quote}

This function moves an active device into down state. A
\code{NETDEV\_GOING\_DOWN} is sent to the netdev notifier chain. The device
is then deactivated and finally a \code{NETDEV\_DOWN} is sent to the notifier
chain.
\end{quote}
\index{dev\_disable\_lro (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_disable_lro}\pysiglinewithargsret{void \bfcode{dev\_disable\_lro}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
disable Large Receive Offload on a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\end{description}

\textbf{Description}
\begin{quote}

Disable Large Receive Offload (LRO) on a net device.  Must be
called under RTNL.  This is needed if received packets may be
forwarded to another interface.
\end{quote}
\index{register\_netdevice\_notifier (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.register_netdevice_notifier}\pysiglinewithargsret{int \bfcode{register\_netdevice\_notifier}}{struct notifier\_block *\emph{nb}}{}
register a network notifier block

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct notifier\_block * nb}}] \leavevmode
notifier

\end{description}

\textbf{Description}

Register a notifier to be called when network device events occur.
The notifier passed is linked into the kernel structures and must
not be reused until it has been unregistered. A negative errno code
is returned on a failure.

When registered all registration and up events are replayed
to the new notifier to allow device to have a race free
view of the network device list.
\index{unregister\_netdevice\_notifier (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.unregister_netdevice_notifier}\pysiglinewithargsret{int \bfcode{unregister\_netdevice\_notifier}}{struct notifier\_block *\emph{nb}}{}
unregister a network notifier block

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct notifier\_block * nb}}] \leavevmode
notifier

\end{description}

\textbf{Description}

Unregister a notifier previously registered by
{\hyperref[networking/kapi:c.register_netdevice_notifier]{\emph{\code{register\_netdevice\_notifier()}}}}. The notifier is unlinked into the
kernel structures and may then be reused. A negative errno code
is returned on a failure.

After unregistering unregister and down device events are synthesized
for all devices on the device list to the removed notifier to remove
the need for special case cleanup code.
\index{call\_netdevice\_notifiers (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.call_netdevice_notifiers}\pysiglinewithargsret{int \bfcode{call\_netdevice\_notifiers}}{unsigned long\emph{val}, struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
call all network notifier blocks

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long val}}] \leavevmode
value passed unmodified to notifier function

\item[{\code{struct net\_device * dev}}] \leavevmode
net\_device pointer passed unmodified to notifier function

\end{description}

\textbf{Description}
\begin{quote}

Call all network notifier blocks.  Parameters and return value
are as for \code{raw\_notifier\_call\_chain()}.
\end{quote}
\index{dev\_forward\_skb (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_forward_skb}\pysiglinewithargsret{int \bfcode{dev\_forward\_skb}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
loopback an skb to another netif

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
destination network device

\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to forward

\end{description}

\textbf{Description}
\begin{description}
\item[{return values:}] \leavevmode
NET\_RX\_SUCCESS  (no congestion)
NET\_RX\_DROP     (packet was dropped, but freed)

\end{description}

dev\_forward\_skb can be used for injecting an skb from the
start\_xmit function of one device into the receive queue
of another device.

The receiving device may be in another namespace, so
we have to clear all information in the skb that could
impact namespace isolation.
\index{netif\_set\_real\_num\_rx\_queues (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_set_real_num_rx_queues}\pysiglinewithargsret{int \bfcode{netif\_set\_real\_num\_rx\_queues}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, unsigned int\emph{rxq}}{}
set actual number of RX queues used

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
Network device

\item[{\code{unsigned int rxq}}] \leavevmode
Actual number of RX queues

\end{description}

\textbf{Description}
\begin{quote}

This must be called either with the rtnl\_lock held or before
registration of the net device.  Returns 0 on success, or a
negative error code.  If called before registration, it always
succeeds.
\end{quote}
\index{netif\_get\_num\_default\_rss\_queues (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_get_num_default_rss_queues}\pysiglinewithargsret{int \bfcode{netif\_get\_num\_default\_rss\_queues}}{void}{}
default number of RSS queues

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}

This routine should set an upper limit on the number of RSS queues
used by default by multiqueue devices.
\index{netif\_device\_detach (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_device_detach}\pysiglinewithargsret{void \bfcode{netif\_device\_detach}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
mark device as removed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}

Mark device as removed from system and therefore no longer available.
\index{netif\_device\_attach (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_device_attach}\pysiglinewithargsret{void \bfcode{netif\_device\_attach}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
mark device as attached

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}

Mark device as attached from system and restart if needed.
\index{skb\_mac\_gso\_segment (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.skb_mac_gso_segment}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{skb\_mac\_gso\_segment}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, netdev\_features\_t\emph{features}}{}
mac layer segmentation handler.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to segment

\item[{\code{netdev\_features\_t features}}] \leavevmode
features for the output path (see dev-\textgreater{}features)

\end{description}
\index{\_\_skb\_gso\_segment (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__skb_gso_segment}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} * \bfcode{\_\_skb\_gso\_segment}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, netdev\_features\_t\emph{features}, bool\emph{tx\_path}}{}
Perform segmentation on skb.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to segment

\item[{\code{netdev\_features\_t features}}] \leavevmode
features for the output path (see dev-\textgreater{}features)

\item[{\code{bool tx\_path}}] \leavevmode
whether it is called in TX path

\end{description}

\textbf{Description}
\begin{quote}

This function segments the given skb and returns a list of segments.

It may return NULL if the skb requires no segmentation.  This is
only possible when GSO is used for verifying header integrity.

Segmentation preserves SKB\_SGO\_CB\_OFFSET bytes of previous skb cb.
\end{quote}
\index{dev\_loopback\_xmit (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_loopback_xmit}\pysiglinewithargsret{int \bfcode{dev\_loopback\_xmit}}{struct net *\emph{net}, struct {\hyperref[networking/kapi:c.sock]{\emph{sock}}} *\emph{sk}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
loop back \textbf{skb}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net * net}}] \leavevmode
network namespace this loopback is happening in

\item[{\code{struct sock * sk}}] \leavevmode
sk needed to be a netfilter okfn

\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to transmit

\end{description}
\index{rps\_may\_expire\_flow (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.rps_may_expire_flow}\pysiglinewithargsret{bool \bfcode{rps\_may\_expire\_flow}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, u16\emph{rxq\_index}, u32\emph{flow\_id}, u16\emph{filter\_id}}{}
check whether an RFS hardware filter may be removed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
Device on which the filter was set

\item[{\code{u16 rxq\_index}}] \leavevmode
RX queue index

\item[{\code{u32 flow\_id}}] \leavevmode
Flow ID passed to \code{ndo\_rx\_flow\_steer()}

\item[{\code{u16 filter\_id}}] \leavevmode
Filter ID returned by \code{ndo\_rx\_flow\_steer()}

\end{description}

\textbf{Description}

Drivers that implement \code{ndo\_rx\_flow\_steer()} should periodically call
this function for each installed filter and remove the filters for
which it returns \code{true}.
\index{netif\_rx (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_rx}\pysiglinewithargsret{int \bfcode{netif\_rx}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
post buffer to the network code

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to post

\end{description}

\textbf{Description}
\begin{quote}

This function receives a packet from a device driver and queues it for
the upper (protocol) levels to process.  It always succeeds. The buffer
may be dropped during processing for congestion control or by the
protocol layers.

return values:
NET\_RX\_SUCCESS  (no congestion)
NET\_RX\_DROP     (packet was dropped)
\end{quote}
\index{netdev\_is\_rx\_handler\_busy (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_is_rx_handler_busy}\pysiglinewithargsret{bool \bfcode{netdev\_is\_rx\_handler\_busy}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
check if receive handler is registered

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device to check

\end{description}

\textbf{Description}
\begin{quote}

Check if a receive handler is already registered for a given device.
Return true if there one.

The caller must hold the rtnl\_mutex.
\end{quote}
\index{netdev\_rx\_handler\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_rx_handler_register}\pysiglinewithargsret{int \bfcode{netdev\_rx\_handler\_register}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, rx\_handler\_func\_t *\emph{rx\_handler}, void *\emph{rx\_handler\_data}}{}
register receive handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device to register a handler for

\item[{\code{rx\_handler\_func\_t * rx\_handler}}] \leavevmode
receive handler to register

\item[{\code{void * rx\_handler\_data}}] \leavevmode
data pointer that is used by rx handler

\end{description}

\textbf{Description}
\begin{quote}

Register a receive handler for a device. This handler will then be
called from \_\_netif\_receive\_skb. A negative errno code is returned
on a failure.

The caller must hold the rtnl\_mutex.

For a general description of rx\_handler, see enum rx\_handler\_result.
\end{quote}
\index{netdev\_rx\_handler\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_rx_handler_unregister}\pysiglinewithargsret{void \bfcode{netdev\_rx\_handler\_unregister}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
unregister receive handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device to unregister a handler from

\end{description}

\textbf{Description}
\begin{quote}

Unregister a receive handler from a device.

The caller must hold the rtnl\_mutex.
\end{quote}
\index{netif\_receive\_skb\_core (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_receive_skb_core}\pysiglinewithargsret{int \bfcode{netif\_receive\_skb\_core}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
special purpose version of netif\_receive\_skb

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to process

\end{description}

\textbf{Description}
\begin{quote}

More direct receive version of {\hyperref[networking/kapi:c.netif_receive_skb]{\emph{\code{netif\_receive\_skb()}}}}.  It should
only be used by callers that have a need to skip RPS and Generic XDP.
Caller must also take care of handling if ({\color{red}\bfseries{}page\_is\_})pfmemalloc.

This function may only be called from softirq context and interrupts
should be enabled.

Return values (usually ignored):
NET\_RX\_SUCCESS: no congestion
NET\_RX\_DROP: packet was dropped
\end{quote}
\index{netif\_receive\_skb (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_receive_skb}\pysiglinewithargsret{int \bfcode{netif\_receive\_skb}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
process receive buffer from network

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to process

\end{description}

\textbf{Description}
\begin{quote}

{\hyperref[networking/kapi:c.netif_receive_skb]{\emph{\code{netif\_receive\_skb()}}}} is the main receive data processing function.
It always succeeds. The buffer may be dropped during processing
for congestion control or by the protocol layers.

This function may only be called from softirq context and interrupts
should be enabled.

Return values (usually ignored):
NET\_RX\_SUCCESS: no congestion
NET\_RX\_DROP: packet was dropped
\end{quote}
\index{\_\_napi\_schedule (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__napi_schedule}\pysiglinewithargsret{void \bfcode{\_\_napi\_schedule}}{struct napi\_struct *\emph{n}}{}
schedule for receive

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct napi\_struct * n}}] \leavevmode
entry to schedule

\end{description}

\textbf{Description}

The entry's receive function will be scheduled to run.
Consider using {\hyperref[networking/kapi:c.__napi_schedule_irqoff]{\emph{\code{\_\_napi\_schedule\_irqoff()}}}} if hard irqs are masked.
\index{napi\_schedule\_prep (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.napi_schedule_prep}\pysiglinewithargsret{bool \bfcode{napi\_schedule\_prep}}{struct napi\_struct *\emph{n}}{}
check if napi can be scheduled

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct napi\_struct * n}}] \leavevmode
napi context

\end{description}

\textbf{Description}

Test if NAPI routine is already running, and if not mark
it as running.  This is used as a condition variable
insure only one NAPI poll instance runs.  We also make
sure there is no pending NAPI disable.
\index{\_\_napi\_schedule\_irqoff (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__napi_schedule_irqoff}\pysiglinewithargsret{void \bfcode{\_\_napi\_schedule\_irqoff}}{struct napi\_struct *\emph{n}}{}
schedule for receive

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct napi\_struct * n}}] \leavevmode
entry to schedule

\end{description}

\textbf{Description}

Variant of {\hyperref[networking/kapi:c.__napi_schedule]{\emph{\code{\_\_napi\_schedule()}}}} assuming hard irqs are masked
\index{netdev\_has\_upper\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_has_upper_dev}\pysiglinewithargsret{bool \bfcode{netdev\_has\_upper\_dev}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{upper\_dev}}{}
Check if device is linked to an upper device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{struct net\_device * upper\_dev}}] \leavevmode
upper device to check

\end{description}

\textbf{Description}

Find out if a device is linked to specified upper device and return true
in case it is. Note that this checks only immediate upper device,
not through a complete stack of devices. The caller must hold the RTNL lock.
\index{netdev\_has\_upper\_dev\_all\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_has_upper_dev_all_rcu}\pysiglinewithargsret{bool \bfcode{netdev\_has\_upper\_dev\_all\_rcu}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{upper\_dev}}{}
Check if device is linked to an upper device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{struct net\_device * upper\_dev}}] \leavevmode
upper device to check

\end{description}

\textbf{Description}

Find out if a device is linked to specified upper device and return true
in case it is. Note that this checks the entire upper device chain.
The caller must hold rcu lock.
\index{netdev\_has\_any\_upper\_dev (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_has_any_upper_dev}\pysiglinewithargsret{bool \bfcode{netdev\_has\_any\_upper\_dev}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
Check if device is linked to some device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\end{description}

\textbf{Description}

Find out if a device is linked to an upper device and return true in case
it is. The caller must hold the RTNL lock.
\index{netdev\_master\_upper\_dev\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_master_upper_dev_get}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} * \bfcode{netdev\_master\_upper\_dev\_get}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
Get master upper device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\end{description}

\textbf{Description}

Find a master upper device and return pointer to it or NULL in case
it's not there. The caller must hold the RTNL lock.
\index{netdev\_upper\_get\_next\_dev\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_upper_get_next_dev_rcu}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} * \bfcode{netdev\_upper\_get\_next\_dev\_rcu}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct list\_head **\emph{iter}}{}
Get the next dev from upper list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{struct list\_head ** iter}}] \leavevmode
list\_head ** of the current position

\end{description}

\textbf{Description}

Gets the next device from the dev's upper list, starting from iter
position. The caller must hold RCU read lock.
\index{netdev\_lower\_get\_next\_private (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_lower_get_next_private}\pysiglinewithargsret{void * \bfcode{netdev\_lower\_get\_next\_private}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct list\_head **\emph{iter}}{}
Get the next -\textgreater{}private from the lower neighbour list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{struct list\_head ** iter}}] \leavevmode
list\_head ** of the current position

\end{description}

\textbf{Description}

Gets the next netdev\_adjacent-\textgreater{}private from the dev's lower neighbour
list, starting from iter position. The caller must hold either hold the
RTNL lock or its own locking that guarantees that the neighbour lower
list will remain unchanged.
\index{netdev\_lower\_get\_next\_private\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_lower_get_next_private_rcu}\pysiglinewithargsret{void * \bfcode{netdev\_lower\_get\_next\_private\_rcu}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct list\_head **\emph{iter}}{}
Get the next -\textgreater{}private from the lower neighbour list, RCU variant

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{struct list\_head ** iter}}] \leavevmode
list\_head ** of the current position

\end{description}

\textbf{Description}

Gets the next netdev\_adjacent-\textgreater{}private from the dev's lower neighbour
list, starting from iter position. The caller must hold RCU read lock.
\index{netdev\_lower\_get\_next (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_lower_get_next}\pysiglinewithargsret{void * \bfcode{netdev\_lower\_get\_next}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct list\_head **\emph{iter}}{}
Get the next device from the lower neighbour list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{struct list\_head ** iter}}] \leavevmode
list\_head ** of the current position

\end{description}

\textbf{Description}

Gets the next netdev\_adjacent from the dev's lower neighbour
list, starting from iter position. The caller must hold RTNL lock or
its own locking that guarantees that the neighbour lower
list will remain unchanged.
\index{netdev\_lower\_get\_first\_private\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_lower_get_first_private_rcu}\pysiglinewithargsret{void * \bfcode{netdev\_lower\_get\_first\_private\_rcu}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
Get the first -\textgreater{}private from the lower neighbour list, RCU variant

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\end{description}

\textbf{Description}

Gets the first netdev\_adjacent-\textgreater{}private from the dev's lower neighbour
list. The caller must hold RCU read lock.
\index{netdev\_master\_upper\_dev\_get\_rcu (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_master_upper_dev_get_rcu}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} * \bfcode{netdev\_master\_upper\_dev\_get\_rcu}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
Get master upper device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\end{description}

\textbf{Description}

Find a master upper device and return pointer to it or NULL in case
it's not there. The caller must hold the RCU read lock.
\index{netdev\_upper\_dev\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_upper_dev_link}\pysiglinewithargsret{int \bfcode{netdev\_upper\_dev\_link}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{upper\_dev}, struct netlink\_ext\_ack *\emph{extack}}{}
Add a link to the upper device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{struct net\_device * upper\_dev}}] \leavevmode
new upper device

\item[{\code{struct netlink\_ext\_ack * extack}}] \leavevmode
netlink extended ack

\end{description}

\textbf{Description}

Adds a link to device which is upper to this one. The caller must hold
the RTNL lock. On a failure a negative errno code is returned.
On success the reference counts are adjusted and the function
returns zero.
\index{netdev\_master\_upper\_dev\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_master_upper_dev_link}\pysiglinewithargsret{int \bfcode{netdev\_master\_upper\_dev\_link}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{upper\_dev}, void *\emph{upper\_priv}, void *\emph{upper\_info}, struct netlink\_ext\_ack *\emph{extack}}{}
Add a master link to the upper device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{struct net\_device * upper\_dev}}] \leavevmode
new upper device

\item[{\code{void * upper\_priv}}] \leavevmode
upper device private

\item[{\code{void * upper\_info}}] \leavevmode
upper info to be passed down via notifier

\item[{\code{struct netlink\_ext\_ack * extack}}] \leavevmode
netlink extended ack

\end{description}

\textbf{Description}

Adds a link to device which is upper to this one. In this case, only
one master upper device can be linked, although other non-master devices
might be linked as well. The caller must hold the RTNL lock.
On a failure a negative errno code is returned. On success the reference
counts are adjusted and the function returns zero.
\index{netdev\_upper\_dev\_unlink (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_upper_dev_unlink}\pysiglinewithargsret{void \bfcode{netdev\_upper\_dev\_unlink}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{upper\_dev}}{}
Removes a link to upper device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{struct net\_device * upper\_dev}}] \leavevmode
new upper device

\end{description}

\textbf{Description}

Removes a link to device which is upper to this one. The caller must hold
the RTNL lock.
\index{netdev\_bonding\_info\_change (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_bonding_info_change}\pysiglinewithargsret{void \bfcode{netdev\_bonding\_info\_change}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct netdev\_bonding\_info *\emph{bonding\_info}}{}
Dispatch event about slave change

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{struct netdev\_bonding\_info * bonding\_info}}] \leavevmode
info to dispatch

\end{description}

\textbf{Description}

Send NETDEV\_BONDING\_INFO to netdev notifiers with info.
The caller must hold the RTNL lock.
\index{netdev\_lower\_state\_changed (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_lower_state_changed}\pysiglinewithargsret{void \bfcode{netdev\_lower\_state\_changed}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{lower\_dev}, void *\emph{lower\_state\_info}}{}
Dispatch event about lower device state change

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * lower\_dev}}] \leavevmode
device

\item[{\code{void * lower\_state\_info}}] \leavevmode
state to dispatch

\end{description}

\textbf{Description}

Send NETDEV\_CHANGELOWERSTATE to netdev notifiers with info.
The caller must hold the RTNL lock.
\index{dev\_set\_promiscuity (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_set_promiscuity}\pysiglinewithargsret{int \bfcode{dev\_set\_promiscuity}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, int\emph{inc}}{}
update promiscuity count on a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{int inc}}] \leavevmode
modifier

\end{description}

\textbf{Description}
\begin{quote}

Add or remove promiscuity from a device. While the count in the device
remains above zero the interface remains promiscuous. Once it hits zero
the device reverts back to normal filtering operation. A negative inc
value is used to drop promiscuity on the device.
Return 0 if successful or a negative errno code on error.
\end{quote}
\index{dev\_set\_allmulti (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_set_allmulti}\pysiglinewithargsret{int \bfcode{dev\_set\_allmulti}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, int\emph{inc}}{}
update allmulti count on a device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{int inc}}] \leavevmode
modifier

\end{description}

\textbf{Description}
\begin{quote}

Add or remove reception of all multicast frames to a device. While the
count in the device remains above zero the interface remains listening
to all interfaces. Once it hits zero the device reverts back to normal
filtering operation. A negative \textbf{inc} value is used to drop the counter
when releasing a resource needing all multicasts.
Return 0 if successful or a negative errno code on error.
\end{quote}
\index{dev\_get\_flags (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_get_flags}\pysiglinewithargsret{unsigned int \bfcode{dev\_get\_flags}}{const struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
get flags reported to userspace

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct net\_device * dev}}] \leavevmode
device

\end{description}

\textbf{Description}
\begin{quote}

Get the combination of flag bits exported through APIs to userspace.
\end{quote}
\index{dev\_change\_flags (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_change_flags}\pysiglinewithargsret{int \bfcode{dev\_change\_flags}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, unsigned int\emph{flags}}{}
change device settings

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{unsigned int flags}}] \leavevmode
device state flags

\end{description}

\textbf{Description}
\begin{quote}

Change settings on device based state flags. The flags are
in the userspace exported format.
\end{quote}
\index{dev\_set\_mtu (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_set_mtu}\pysiglinewithargsret{int \bfcode{dev\_set\_mtu}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, int\emph{new\_mtu}}{}
Change maximum transfer unit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{int new\_mtu}}] \leavevmode
new transfer unit

\end{description}

\textbf{Description}
\begin{quote}

Change the maximum transfer size of the network device.
\end{quote}
\index{dev\_set\_group (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_set_group}\pysiglinewithargsret{void \bfcode{dev\_set\_group}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, int\emph{new\_group}}{}
Change group this device belongs to

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{int new\_group}}] \leavevmode
group this device should belong to

\end{description}
\index{dev\_set\_mac\_address (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_set_mac_address}\pysiglinewithargsret{int \bfcode{dev\_set\_mac\_address}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct sockaddr *\emph{sa}}{}
Change Media Access Control Address

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{struct sockaddr * sa}}] \leavevmode
new address

\end{description}

\textbf{Description}
\begin{quote}

Change the hardware (MAC) address of the device
\end{quote}
\index{dev\_change\_carrier (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_change_carrier}\pysiglinewithargsret{int \bfcode{dev\_change\_carrier}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, bool\emph{new\_carrier}}{}
Change device carrier

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{bool new\_carrier}}] \leavevmode
new value

\end{description}

\textbf{Description}
\begin{quote}

Change device carrier
\end{quote}
\index{dev\_get\_phys\_port\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_get_phys_port_id}\pysiglinewithargsret{int \bfcode{dev\_get\_phys\_port\_id}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct netdev\_phys\_item\_id *\emph{ppid}}{}
Get device physical port ID

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{struct netdev\_phys\_item\_id * ppid}}] \leavevmode
port ID

\end{description}

\textbf{Description}
\begin{quote}

Get device physical port ID
\end{quote}
\index{dev\_get\_phys\_port\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_get_phys_port_name}\pysiglinewithargsret{int \bfcode{dev\_get\_phys\_port\_name}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, char *\emph{name}, size\_t\emph{len}}{}
Get device physical port name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{char * name}}] \leavevmode
port name

\item[{\code{size\_t len}}] \leavevmode
limit of bytes to copy to name

\end{description}

\textbf{Description}
\begin{quote}

Get device physical port name
\end{quote}
\index{dev\_change\_proto\_down (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_change_proto_down}\pysiglinewithargsret{int \bfcode{dev\_change\_proto\_down}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, bool\emph{proto\_down}}{}
update protocol port state information

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{bool proto\_down}}] \leavevmode
new value

\end{description}

\textbf{Description}
\begin{quote}

This info can be used by switch drivers to set the phys state of the
port.
\end{quote}
\index{netdev\_update\_features (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_update_features}\pysiglinewithargsret{void \bfcode{netdev\_update\_features}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
recalculate device features

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
the device to check

\end{description}

\textbf{Description}
\begin{quote}

Recalculate dev-\textgreater{}features set and send notifications if it
has changed. Should be called after driver or hardware dependent
conditions might have changed that influence the features.
\end{quote}
\index{netdev\_change\_features (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_change_features}\pysiglinewithargsret{void \bfcode{netdev\_change\_features}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
recalculate device features

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
the device to check

\end{description}

\textbf{Description}
\begin{quote}

Recalculate dev-\textgreater{}features set and send notifications even
if they have not changed. Should be called instead of
{\hyperref[networking/kapi:c.netdev_update_features]{\emph{\code{netdev\_update\_features()}}}} if also dev-\textgreater{}vlan\_features might
have changed to allow the changes to be propagated to stacked
VLAN devices.
\end{quote}
\index{netif\_stacked\_transfer\_operstate (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_stacked_transfer_operstate}\pysiglinewithargsret{void \bfcode{netif\_stacked\_transfer\_operstate}}{const struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{rootdev}, struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
transfer operstate

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct net\_device * rootdev}}] \leavevmode
the root or lower level device to transfer state from

\item[{\code{struct net\_device * dev}}] \leavevmode
the device to transfer operstate to

\end{description}

\textbf{Description}
\begin{quote}

Transfer operational state from root to device. This is normally
called when a stacking relationship exists between the root
device and the device(a leaf device).
\end{quote}
\index{register\_netdevice (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.register_netdevice}\pysiglinewithargsret{int \bfcode{register\_netdevice}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
register a network device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device to register

\end{description}

\textbf{Description}
\begin{quote}

Take a completed network device structure and add it to the kernel
interfaces. A \code{NETDEV\_REGISTER} message is sent to the netdev notifier
chain. 0 is returned on success. A negative errno code is returned
on a failure to set up the device, or if the name is a duplicate.

Callers must hold the rtnl semaphore. You may want
{\hyperref[networking/kapi:c.register_netdev]{\emph{\code{register\_netdev()}}}} instead of this.

BUGS:
The locking appears insufficient to guarantee two parallel registers
will not get the same name.
\end{quote}
\index{init\_dummy\_netdev (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.init_dummy_netdev}\pysiglinewithargsret{int \bfcode{init\_dummy\_netdev}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
init a dummy network device for NAPI

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device to init

\end{description}

\textbf{Description}
\begin{quote}

This takes a network device structure and initialize the minimum
amount of fields so it can be used to schedule NAPI polls without
registering a full blown interface. This is to be used by drivers
that need to tie several hardware interfaces to a single NAPI
poll scheduler due to HW limitations.
\end{quote}
\index{register\_netdev (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.register_netdev}\pysiglinewithargsret{int \bfcode{register\_netdev}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
register a network device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device to register

\end{description}

\textbf{Description}
\begin{quote}

Take a completed network device structure and add it to the kernel
interfaces. A \code{NETDEV\_REGISTER} message is sent to the netdev notifier
chain. 0 is returned on success. A negative errno code is returned
on a failure to set up the device, or if the name is a duplicate.

This is a wrapper around register\_netdevice that takes the rtnl semaphore
and expands the device name if you passed a format string to
alloc\_netdev.
\end{quote}
\index{dev\_get\_stats (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_get_stats}\pysiglinewithargsret{struct rtnl\_link\_stats64 * \bfcode{dev\_get\_stats}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct rtnl\_link\_stats64 *\emph{storage}}{}
get network device statistics

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device to get statistics from

\item[{\code{struct rtnl\_link\_stats64 * storage}}] \leavevmode
place to store stats

\end{description}

\textbf{Description}
\begin{quote}

Get network statistics from device. Return \textbf{storage}.
The device driver may provide its own method by setting
dev-\textgreater{}netdev\_ops-\textgreater{}get\_stats64 or dev-\textgreater{}netdev\_ops-\textgreater{}get\_stats;
otherwise the internal statistics structure is used.
\end{quote}
\index{alloc\_netdev\_mqs (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.alloc_netdev_mqs}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} * \bfcode{alloc\_netdev\_mqs}}{int\emph{sizeof\_priv}, const char *\emph{name}, unsigned char\emph{name\_assign\_type}, void (*setup) (struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}}\emph{*}, unsigned int\emph{txqs}, unsigned int\emph{rxqs}}{}
allocate network device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int sizeof\_priv}}] \leavevmode
size of private data to allocate space for

\item[{\code{const char * name}}] \leavevmode
device name format string

\item[{\code{unsigned char name\_assign\_type}}] \leavevmode
origin of device name

\item[{\code{void (*)(struct net\_device *) setup}}] \leavevmode
callback to initialize device

\item[{\code{unsigned int txqs}}] \leavevmode
the number of TX subqueues to allocate

\item[{\code{unsigned int rxqs}}] \leavevmode
the number of RX subqueues to allocate

\end{description}

\textbf{Description}

Allocates a struct net\_device with private data area for driver use
and performs basic initialization.  Also allocates subqueue structs
for each queue on the device.
\index{free\_netdev (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.free_netdev}\pysiglinewithargsret{void \bfcode{free\_netdev}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
free network device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\end{description}

\textbf{Description}

This function does the last stage of destroying an allocated device
interface. The reference to the device object is released. If this
is the last reference then it will be freed.Must be called in process
context.
\index{synchronize\_net (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.synchronize_net}\pysiglinewithargsret{void \bfcode{synchronize\_net}}{void}{}
Synchronize with packet receive processing

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void}}] \leavevmode
no arguments

\end{description}

\textbf{Description}
\begin{quote}

Wait for packets currently being received to be done.
Does not block later packets from starting.
\end{quote}
\index{unregister\_netdevice\_queue (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.unregister_netdevice_queue}\pysiglinewithargsret{void \bfcode{unregister\_netdevice\_queue}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct list\_head *\emph{head}}{}
remove device from the kernel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{struct list\_head * head}}] \leavevmode
list

\end{description}

\textbf{Description}
\begin{quote}

This function shuts down a device interface and removes it
from the kernel tables.
If head not NULL, device is queued to be unregistered later.

Callers must hold the rtnl semaphore.  You may want
{\hyperref[networking/kapi:c.unregister_netdev]{\emph{\code{unregister\_netdev()}}}} instead of this.
\end{quote}
\index{unregister\_netdevice\_many (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.unregister_netdevice_many}\pysiglinewithargsret{void \bfcode{unregister\_netdevice\_many}}{struct list\_head *\emph{head}}{}
unregister many devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct list\_head * head}}] \leavevmode
list of devices

\end{description}

\textbf{Note}
\begin{description}
\item[{As most callers use a stack allocated list\_head,}] \leavevmode
we force a \code{list\_del()} to make sure stack wont be corrupted later.

\end{description}
\index{unregister\_netdev (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.unregister_netdev}\pysiglinewithargsret{void \bfcode{unregister\_netdev}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
remove device from the kernel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\end{description}

\textbf{Description}
\begin{quote}

This function shuts down a device interface and removes it
from the kernel tables.

This is just a wrapper for unregister\_netdevice that takes
the rtnl semaphore.  In general you want to use this and not
unregister\_netdevice.
\end{quote}
\index{dev\_change\_net\_namespace (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_change_net_namespace}\pysiglinewithargsret{int \bfcode{dev\_change\_net\_namespace}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct net *\emph{net}, const char *\emph{pat}}{}
move device to different nethost namespace

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device

\item[{\code{struct net * net}}] \leavevmode
network namespace

\item[{\code{const char * pat}}] \leavevmode
If not NULL name pattern to try if the current device name
is already taken in the destination network namespace.

\end{description}

\textbf{Description}
\begin{quote}

This function shuts down a device interface and moves it
to a new network namespace. On success 0 is returned, on
a failure a netagive errno code is returned.

Callers must hold the rtnl semaphore.
\end{quote}
\index{netdev\_increment\_features (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_increment_features}\pysiglinewithargsret{netdev\_features\_t \bfcode{netdev\_increment\_features}}{netdev\_features\_t\emph{all}, netdev\_features\_t\emph{one}, netdev\_features\_t\emph{mask}}{}
increment feature set by one

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{netdev\_features\_t all}}] \leavevmode
current feature set

\item[{\code{netdev\_features\_t one}}] \leavevmode
new feature set

\item[{\code{netdev\_features\_t mask}}] \leavevmode
mask feature set

\end{description}

\textbf{Description}
\begin{quote}

Computes a new feature set after adding a device with feature set
\textbf{one} to the master device with current feature set \textbf{all}.  Will not
enable anything that is off in \textbf{mask}. Returns the new feature set.
\end{quote}
\index{eth\_header (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_header}\pysiglinewithargsret{int \bfcode{eth\_header}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, unsigned short\emph{type}, const void *\emph{daddr}, const void *\emph{saddr}, unsigned int\emph{len}}{}
create the Ethernet header

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
buffer to alter

\item[{\code{struct net\_device * dev}}] \leavevmode
source device

\item[{\code{unsigned short type}}] \leavevmode
Ethernet type field

\item[{\code{const void * daddr}}] \leavevmode
destination address (NULL leave destination address)

\item[{\code{const void * saddr}}] \leavevmode
source address (NULL use device source address)

\item[{\code{unsigned int len}}] \leavevmode
packet length (\textless{}= skb-\textgreater{}len)

\end{description}

\textbf{Description}

Set the protocol type. For a packet of type ETH\_P\_802\_3/2 we put the length
in here instead.
\index{eth\_get\_headlen (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_get_headlen}\pysiglinewithargsret{u32 \bfcode{eth\_get\_headlen}}{void *\emph{data}, unsigned int\emph{len}}{}
determine the length of header for an ethernet frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * data}}] \leavevmode
pointer to start of frame

\item[{\code{unsigned int len}}] \leavevmode
total length of frame

\end{description}

\textbf{Description}

Make a best effort attempt to pull the length for all of the headers for
a given frame in a linear buffer.
\index{eth\_type\_trans (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_type_trans}\pysiglinewithargsret{\_\_be16 \bfcode{eth\_type\_trans}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
determine the packet's protocol ID.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
received socket data

\item[{\code{struct net\_device * dev}}] \leavevmode
receiving network device

\end{description}

\textbf{Description}

The rule here is that we
assume 802.3 if the type field is short enough to be a length.
This is normal practice and works for any `now in use' protocol.
\index{eth\_header\_parse (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_header_parse}\pysiglinewithargsret{int \bfcode{eth\_header\_parse}}{const struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}, unsigned char *\emph{haddr}}{}
extract hardware address from packet

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct sk\_buff * skb}}] \leavevmode
packet to extract header from

\item[{\code{unsigned char * haddr}}] \leavevmode
destination buffer

\end{description}
\index{eth\_header\_cache (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_header_cache}\pysiglinewithargsret{int \bfcode{eth\_header\_cache}}{const struct neighbour *\emph{neigh}, struct hh\_cache *\emph{hh}, \_\_be16\emph{type}}{}
fill cache entry from neighbour

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct neighbour * neigh}}] \leavevmode
source neighbour

\item[{\code{struct hh\_cache * hh}}] \leavevmode
destination cache entry

\item[{\code{\_\_be16 type}}] \leavevmode
Ethernet type field

\end{description}

\textbf{Description}

Create an Ethernet header template from the neighbour.
\index{eth\_header\_cache\_update (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_header_cache_update}\pysiglinewithargsret{void \bfcode{eth\_header\_cache\_update}}{struct hh\_cache *\emph{hh}, const struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, const unsigned char *\emph{haddr}}{}
update cache entry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct hh\_cache * hh}}] \leavevmode
destination cache entry

\item[{\code{const struct net\_device * dev}}] \leavevmode
network device

\item[{\code{const unsigned char * haddr}}] \leavevmode
new hardware address

\end{description}

\textbf{Description}

Called by Address Resolution module to notify changes in address.
\index{eth\_prepare\_mac\_addr\_change (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_prepare_mac_addr_change}\pysiglinewithargsret{int \bfcode{eth\_prepare\_mac\_addr\_change}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, void *\emph{p}}{}
prepare for mac change

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{void * p}}] \leavevmode
socket address

\end{description}
\index{eth\_commit\_mac\_addr\_change (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_commit_mac_addr_change}\pysiglinewithargsret{void \bfcode{eth\_commit\_mac\_addr\_change}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, void *\emph{p}}{}
commit mac change

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{void * p}}] \leavevmode
socket address

\end{description}
\index{eth\_mac\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_mac_addr}\pysiglinewithargsret{int \bfcode{eth\_mac\_addr}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, void *\emph{p}}{}
set new Ethernet hardware address

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{void * p}}] \leavevmode
socket address

\end{description}

\textbf{Description}

Change hardware address of device.

This doesn't change hardware matching, so needs to be overridden
for most real devices.
\index{eth\_change\_mtu (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_change_mtu}\pysiglinewithargsret{int \bfcode{eth\_change\_mtu}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, int\emph{new\_mtu}}{}
set new MTU size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{int new\_mtu}}] \leavevmode
new Maximum Transfer Unit

\end{description}

\textbf{Description}

Allow changing MTU size. Needs to be overridden for devices
supporting jumbo frames.
\index{ether\_setup (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.ether_setup}\pysiglinewithargsret{void \bfcode{ether\_setup}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
setup Ethernet network device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}

Fill in the fields of the device structure with Ethernet-generic values.
\index{alloc\_etherdev\_mqs (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.alloc_etherdev_mqs}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} * \bfcode{alloc\_etherdev\_mqs}}{int\emph{sizeof\_priv}, unsigned int\emph{txqs}, unsigned int\emph{rxqs}}{}
Allocates and sets up an Ethernet device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int sizeof\_priv}}] \leavevmode
Size of additional driver-private structure to be allocated
for this Ethernet device

\item[{\code{unsigned int txqs}}] \leavevmode
The number of TX queues this device has.

\item[{\code{unsigned int rxqs}}] \leavevmode
The number of RX queues this device has.

\end{description}

\textbf{Description}

Fill in the fields of the device structure with Ethernet-generic
values. Basically does everything except registering the device.

Constructs a new net device, complete with a private data area of
size (sizeof\_priv).  A 32-byte (not bit) alignment is enforced for
this private data area.
\index{netif\_carrier\_on (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_carrier_on}\pysiglinewithargsret{void \bfcode{netif\_carrier\_on}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
set carrier

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}

Device has detected that carrier.
\index{netif\_carrier\_off (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_carrier_off}\pysiglinewithargsret{void \bfcode{netif\_carrier\_off}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
clear carrier

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}

Device has detected loss of carrier.
\index{is\_link\_local\_ether\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.is_link_local_ether_addr}\pysiglinewithargsret{bool \bfcode{is\_link\_local\_ether\_addr}}{const u8 *\emph{addr}}{}
Determine if given Ethernet address is link-local

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * addr}}] \leavevmode
Pointer to a six-byte array containing the Ethernet address

\end{description}

\textbf{Description}

Return true if address is link local reserved addr (01:80:c2:00:00:0X) per
IEEE 802.1Q 8.6.3 Frame filtering.

Please note: addr must be aligned to u16.
\index{is\_zero\_ether\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.is_zero_ether_addr}\pysiglinewithargsret{bool \bfcode{is\_zero\_ether\_addr}}{const u8 *\emph{addr}}{}
Determine if give Ethernet address is all zeros.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * addr}}] \leavevmode
Pointer to a six-byte array containing the Ethernet address

\end{description}

\textbf{Description}

Return true if the address is all zeroes.

Please note: addr must be aligned to u16.
\index{is\_multicast\_ether\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.is_multicast_ether_addr}\pysiglinewithargsret{bool \bfcode{is\_multicast\_ether\_addr}}{const u8 *\emph{addr}}{}
Determine if the Ethernet address is a multicast.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * addr}}] \leavevmode
Pointer to a six-byte array containing the Ethernet address

\end{description}

\textbf{Description}

Return true if the address is a multicast address.
By definition the broadcast address is also a multicast address.
\index{is\_local\_ether\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.is_local_ether_addr}\pysiglinewithargsret{bool \bfcode{is\_local\_ether\_addr}}{const u8 *\emph{addr}}{}
Determine if the Ethernet address is locally-assigned one (IEEE 802).

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * addr}}] \leavevmode
Pointer to a six-byte array containing the Ethernet address

\end{description}

\textbf{Description}

Return true if the address is a local address.
\index{is\_broadcast\_ether\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.is_broadcast_ether_addr}\pysiglinewithargsret{bool \bfcode{is\_broadcast\_ether\_addr}}{const u8 *\emph{addr}}{}
Determine if the Ethernet address is broadcast

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * addr}}] \leavevmode
Pointer to a six-byte array containing the Ethernet address

\end{description}

\textbf{Description}

Return true if the address is the broadcast address.

Please note: addr must be aligned to u16.
\index{is\_unicast\_ether\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.is_unicast_ether_addr}\pysiglinewithargsret{bool \bfcode{is\_unicast\_ether\_addr}}{const u8 *\emph{addr}}{}
Determine if the Ethernet address is unicast

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * addr}}] \leavevmode
Pointer to a six-byte array containing the Ethernet address

\end{description}

\textbf{Description}

Return true if the address is a unicast address.
\index{is\_valid\_ether\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.is_valid_ether_addr}\pysiglinewithargsret{bool \bfcode{is\_valid\_ether\_addr}}{const u8 *\emph{addr}}{}
Determine if the given Ethernet address is valid

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * addr}}] \leavevmode
Pointer to a six-byte array containing the Ethernet address

\end{description}

\textbf{Description}

Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not
a multicast address, and is not FF:FF:FF:FF:FF:FF.

Return true if the address is valid.

Please note: addr must be aligned to u16.
\index{eth\_proto\_is\_802\_3 (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_proto_is_802_3}\pysiglinewithargsret{bool \bfcode{eth\_proto\_is\_802\_3}}{\_\_be16\emph{proto}}{}
Determine if a given Ethertype/length is a protocol

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{\_\_be16 proto}}] \leavevmode
Ethertype/length value to be tested

\end{description}

\textbf{Description}

Check that the value from the Ethertype/length field is a valid Ethertype.

Return true if the valid is an 802.3 supported Ethertype.
\index{eth\_random\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_random_addr}\pysiglinewithargsret{void \bfcode{eth\_random\_addr}}{u8 *\emph{addr}}{}
Generate software assigned random Ethernet address

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 * addr}}] \leavevmode
Pointer to a six-byte array containing the Ethernet address

\end{description}

\textbf{Description}

Generate a random Ethernet address (MAC) that is not multicast
and has the local assigned bit set.
\index{eth\_broadcast\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_broadcast_addr}\pysiglinewithargsret{void \bfcode{eth\_broadcast\_addr}}{u8 *\emph{addr}}{}
Assign broadcast address

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 * addr}}] \leavevmode
Pointer to a six-byte array containing the Ethernet address

\end{description}

\textbf{Description}

Assign the broadcast address to the given address array.
\index{eth\_zero\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_zero_addr}\pysiglinewithargsret{void \bfcode{eth\_zero\_addr}}{u8 *\emph{addr}}{}
Assign zero address

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 * addr}}] \leavevmode
Pointer to a six-byte array containing the Ethernet address

\end{description}

\textbf{Description}

Assign the zero address to the given address array.
\index{eth\_hw\_addr\_random (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_hw_addr_random}\pysiglinewithargsret{void \bfcode{eth\_hw\_addr\_random}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
Generate software assigned random Ethernet and set device flag

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
pointer to net\_device structure

\end{description}

\textbf{Description}

Generate a random Ethernet address (MAC) to be used by a net device
and set addr\_assign\_type so the state can be read by sysfs and be
used by userspace.
\index{ether\_addr\_copy (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.ether_addr_copy}\pysiglinewithargsret{void \bfcode{ether\_addr\_copy}}{u8 *\emph{dst}, const u8 *\emph{src}}{}
Copy an Ethernet address

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 * dst}}] \leavevmode
Pointer to a six-byte array Ethernet address destination

\item[{\code{const u8 * src}}] \leavevmode
Pointer to a six-byte array Ethernet address source

\end{description}

\textbf{Description}

Please note: dst \& src must both be aligned to u16.
\index{eth\_hw\_addr\_inherit (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_hw_addr_inherit}\pysiglinewithargsret{void \bfcode{eth\_hw\_addr\_inherit}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dst}, struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{src}}{}
Copy dev\_addr from another net\_device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dst}}] \leavevmode
pointer to net\_device to copy dev\_addr to

\item[{\code{struct net\_device * src}}] \leavevmode
pointer to net\_device to copy dev\_addr from

\end{description}

\textbf{Description}

Copy the Ethernet address from one net\_device to another along with
the address attributes (addr\_assign\_type).
\index{ether\_addr\_equal (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.ether_addr_equal}\pysiglinewithargsret{bool \bfcode{ether\_addr\_equal}}{const u8 *\emph{addr1}, const u8 *\emph{addr2}}{}
Compare two Ethernet addresses

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * addr1}}] \leavevmode
Pointer to a six-byte array containing the Ethernet address

\item[{\code{const u8 * addr2}}] \leavevmode
Pointer other six-byte array containing the Ethernet address

\end{description}

\textbf{Description}

Compare two Ethernet addresses, returns true if equal

Please note: addr1 \& addr2 must both be aligned to u16.
\index{ether\_addr\_equal\_64bits (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.ether_addr_equal_64bits}\pysiglinewithargsret{bool \bfcode{ether\_addr\_equal\_64bits}}{const u8\emph{addr1}, const u8\emph{addr2}}{}
Compare two Ethernet addresses

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 addr1}}] \leavevmode
Pointer to an array of 8 bytes

\item[{\code{const u8 addr2}}] \leavevmode
Pointer to an other array of 8 bytes

\end{description}

\textbf{Description}

Compare two Ethernet addresses, returns true if equal, false otherwise.

The function doesn't need any conditional branches and possibly uses
word memory accesses on CPU allowing cheap unaligned memory reads.
arrays = \{ byte1, byte2, byte3, byte4, byte5, byte6, pad1, pad2 \}

Please note that alignment of addr1 \& addr2 are only guaranteed to be 16 bits.
\index{ether\_addr\_equal\_unaligned (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.ether_addr_equal_unaligned}\pysiglinewithargsret{bool \bfcode{ether\_addr\_equal\_unaligned}}{const u8 *\emph{addr1}, const u8 *\emph{addr2}}{}
Compare two not u16 aligned Ethernet addresses

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * addr1}}] \leavevmode
Pointer to a six-byte array containing the Ethernet address

\item[{\code{const u8 * addr2}}] \leavevmode
Pointer other six-byte array containing the Ethernet address

\end{description}

\textbf{Description}

Compare two Ethernet addresses, returns true if equal

Please note: Use only when any Ethernet address may not be u16 aligned.
\index{ether\_addr\_equal\_masked (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.ether_addr_equal_masked}\pysiglinewithargsret{bool \bfcode{ether\_addr\_equal\_masked}}{const u8 *\emph{addr1}, const u8 *\emph{addr2}, const u8 *\emph{mask}}{}
Compare two Ethernet addresses with a mask

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * addr1}}] \leavevmode
Pointer to a six-byte array containing the 1st Ethernet address

\item[{\code{const u8 * addr2}}] \leavevmode
Pointer to a six-byte array containing the 2nd Ethernet address

\item[{\code{const u8 * mask}}] \leavevmode
Pointer to a six-byte array containing the Ethernet address bitmask

\end{description}

\textbf{Description}

Compare two Ethernet addresses with a mask, returns true if for every bit
set in the bitmask the equivalent bits in the ethernet addresses are equal.
Using a mask with all bits set is a slower ether\_addr\_equal.
\index{ether\_addr\_to\_u64 (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.ether_addr_to_u64}\pysiglinewithargsret{u64 \bfcode{ether\_addr\_to\_u64}}{const u8 *\emph{addr}}{}
Convert an Ethernet address into a u64 value.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const u8 * addr}}] \leavevmode
Pointer to a six-byte array containing the Ethernet address

\end{description}

\textbf{Description}

Return a u64 value of the address
\index{u64\_to\_ether\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.u64_to_ether_addr}\pysiglinewithargsret{void \bfcode{u64\_to\_ether\_addr}}{u64\emph{u}, u8 *\emph{addr}}{}
Convert a u64 to an Ethernet address.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u64 u}}] \leavevmode
u64 to convert to an Ethernet MAC address

\item[{\code{u8 * addr}}] \leavevmode
Pointer to a six-byte array to contain the Ethernet address

\end{description}
\index{eth\_addr\_dec (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_addr_dec}\pysiglinewithargsret{void \bfcode{eth\_addr\_dec}}{u8 *\emph{addr}}{}
Decrement the given MAC address

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u8 * addr}}] \leavevmode
Pointer to a six-byte array containing Ethernet address to decrement

\end{description}
\index{is\_etherdev\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.is_etherdev_addr}\pysiglinewithargsret{bool \bfcode{is\_etherdev\_addr}}{const struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, const u8\emph{addr}}{}
Tell if given Ethernet address belongs to the device.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct net\_device * dev}}] \leavevmode
Pointer to a device structure

\item[{\code{const u8 addr}}] \leavevmode
Pointer to a six-byte array containing the Ethernet address

\end{description}

\textbf{Description}

Compare passed address with all addresses of the device. Return true if the
address if one of the device addresses.

Note that this function calls {\hyperref[networking/kapi:c.ether_addr_equal_64bits]{\emph{\code{ether\_addr\_equal\_64bits()}}}} so take care of
the right padding.
\index{compare\_ether\_header (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.compare_ether_header}\pysiglinewithargsret{unsigned long \bfcode{compare\_ether\_header}}{const void *\emph{a}, const void *\emph{b}}{}
Compare two Ethernet headers

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const void * a}}] \leavevmode
Pointer to Ethernet header

\item[{\code{const void * b}}] \leavevmode
Pointer to Ethernet header

\end{description}

\textbf{Description}

Compare two Ethernet headers, returns 0 if equal.
This assumes that the network header (i.e., IP header) is 4-byte
aligned OR the platform can handle unaligned access.  This is the
case for all packets coming into netif\_receive\_skb or similar
entry points.
\index{eth\_skb\_pad (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.eth_skb_pad}\pysiglinewithargsret{int \bfcode{eth\_skb\_pad}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
Pad buffer to mininum number of octets for Ethernet frame

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
Buffer to pad

\end{description}

\textbf{Description}

An Ethernet frame should have a minimum size of 60 bytes.  This function
takes short frames and pads them with zeros up to the 60 byte limit.
\index{napi\_schedule (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.napi_schedule}\pysiglinewithargsret{void \bfcode{napi\_schedule}}{struct napi\_struct *\emph{n}}{}
schedule NAPI poll

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct napi\_struct * n}}] \leavevmode
NAPI context

\end{description}

\textbf{Description}

Schedule NAPI poll routine to be called if it is not already
running.
\index{napi\_schedule\_irqoff (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.napi_schedule_irqoff}\pysiglinewithargsret{void \bfcode{napi\_schedule\_irqoff}}{struct napi\_struct *\emph{n}}{}
schedule NAPI poll

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct napi\_struct * n}}] \leavevmode
NAPI context

\end{description}

\textbf{Description}

Variant of {\hyperref[networking/kapi:c.napi_schedule]{\emph{\code{napi\_schedule()}}}}, assuming hard irqs are masked.
\index{napi\_complete (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.napi_complete}\pysiglinewithargsret{bool \bfcode{napi\_complete}}{struct napi\_struct *\emph{n}}{}
NAPI processing complete

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct napi\_struct * n}}] \leavevmode
NAPI context

\end{description}

\textbf{Description}

Mark NAPI processing as complete.
Consider using \code{napi\_complete\_done()} instead.
Return false if device should avoid rearming interrupts.
\index{napi\_hash\_del (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.napi_hash_del}\pysiglinewithargsret{bool \bfcode{napi\_hash\_del}}{struct napi\_struct *\emph{napi}}{}
remove a NAPI from global table

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct napi\_struct * napi}}] \leavevmode
NAPI context

\end{description}

\textbf{Description}

Warning: caller must observe RCU grace period
before freeing memory containing \textbf{napi}, if
this function returns true.

\textbf{Note}

core networking stack automatically calls it
from {\hyperref[networking/kapi:c.netif_napi_del]{\emph{\code{netif\_napi\_del()}}}}.
Drivers might want to call this helper to combine all
the needed RCU grace periods into a single one.
\index{napi\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.napi_disable}\pysiglinewithargsret{void \bfcode{napi\_disable}}{struct napi\_struct *\emph{n}}{}
prevent NAPI from scheduling

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct napi\_struct * n}}] \leavevmode
NAPI context

\end{description}

\textbf{Description}

Stop NAPI from being scheduled on this context.
Waits till any outstanding processing completes.
\index{napi\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.napi_enable}\pysiglinewithargsret{void \bfcode{napi\_enable}}{struct napi\_struct *\emph{n}}{}
enable NAPI scheduling

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct napi\_struct * n}}] \leavevmode
NAPI context

\end{description}

\textbf{Description}

Resume NAPI from being scheduled on this context.
Must be paired with napi\_disable.
\index{napi\_synchronize (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.napi_synchronize}\pysiglinewithargsret{void \bfcode{napi\_synchronize}}{const struct napi\_struct *\emph{n}}{}
wait until NAPI is not running

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct napi\_struct * n}}] \leavevmode
NAPI context

\end{description}

\textbf{Description}

Wait until NAPI is done being scheduled on this context.
Waits till any outstanding processing completes but
does not disable future activations.
\index{netdev\_priv\_flags (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_priv_flags}\pysigline{enum \bfcode{netdev\_priv\_flags}}
{\hyperref[networking/kapi:c.net_device]{\emph{\code{struct net\_device}}}} priv\_flags

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{IFF\_802\_1Q\_VLAN}}] \leavevmode
802.1Q VLAN device

\item[{\code{IFF\_EBRIDGE}}] \leavevmode
Ethernet bridging device

\item[{\code{IFF\_BONDING}}] \leavevmode
bonding master or slave

\item[{\code{IFF\_ISATAP}}] \leavevmode
ISATAP interface (RFC4214)

\item[{\code{IFF\_WAN\_HDLC}}] \leavevmode
WAN HDLC device

\item[{\code{IFF\_XMIT\_DST\_RELEASE}}] \leavevmode
\code{dev\_hard\_start\_xmit()} is allowed to
release skb-\textgreater{}dst

\item[{\code{IFF\_DONT\_BRIDGE}}] \leavevmode
disallow bridging this ether dev

\item[{\code{IFF\_DISABLE\_NETPOLL}}] \leavevmode
disable netpoll at run-time

\item[{\code{IFF\_MACVLAN\_PORT}}] \leavevmode
device used as macvlan port

\item[{\code{IFF\_BRIDGE\_PORT}}] \leavevmode
device used as bridge port

\item[{\code{IFF\_OVS\_DATAPATH}}] \leavevmode
device used as Open vSwitch datapath port

\item[{\code{IFF\_TX\_SKB\_SHARING}}] \leavevmode
The interface supports sharing skbs on transmit

\item[{\code{IFF\_UNICAST\_FLT}}] \leavevmode
Supports unicast filtering

\item[{\code{IFF\_TEAM\_PORT}}] \leavevmode
device used as team port

\item[{\code{IFF\_SUPP\_NOFCS}}] \leavevmode
device supports sending custom FCS

\item[{\code{IFF\_LIVE\_ADDR\_CHANGE}}] \leavevmode
device supports hardware address
change when it's running

\item[{\code{IFF\_MACVLAN}}] \leavevmode
Macvlan device

\item[{\code{IFF\_XMIT\_DST\_RELEASE\_PERM}}] \leavevmode
IFF\_XMIT\_DST\_RELEASE not taking into account
underlying stacked devices

\item[{\code{IFF\_IPVLAN\_MASTER}}] \leavevmode
IPvlan master device

\item[{\code{IFF\_IPVLAN\_SLAVE}}] \leavevmode
IPvlan slave device

\item[{\code{IFF\_L3MDEV\_MASTER}}] \leavevmode
device is an L3 master device

\item[{\code{IFF\_NO\_QUEUE}}] \leavevmode
device can run without qdisc attached

\item[{\code{IFF\_OPENVSWITCH}}] \leavevmode
device is a Open vSwitch master

\item[{\code{IFF\_L3MDEV\_SLAVE}}] \leavevmode
device is enslaved to an L3 master device

\item[{\code{IFF\_TEAM}}] \leavevmode
device is a team device

\item[{\code{IFF\_RXFH\_CONFIGURED}}] \leavevmode
device has had Rx Flow indirection table configured

\item[{\code{IFF\_PHONY\_HEADROOM}}] \leavevmode
the headroom value is controlled by an external
entity (i.e. the master device for bridged veth)

\item[{\code{IFF\_MACSEC}}] \leavevmode
device is a MACsec device

\end{description}

\textbf{Description}

These are the {\hyperref[networking/kapi:c.net_device]{\emph{\code{struct net\_device}}}}, they are only set internally
by drivers and used in the kernel. These flags are invisible to
userspace; this means that the order of these flags can change
during any kernel release.

You should have a pretty good reason to be extending these flags.
\index{net\_device (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.net_device}\pysigline{struct \bfcode{net\_device}}
The DEVICE structure.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct net\PYGZus{}device \PYGZob{}
  char name[IFNAMSIZ];
  struct hlist\PYGZus{}node       name\PYGZus{}hlist;
  struct dev\PYGZus{}ifalias      \PYGZus{}\PYGZus{}rcu *ifalias;
  unsigned long           mem\PYGZus{}end;
  unsigned long           mem\PYGZus{}start;
  unsigned long           base\PYGZus{}addr;
  int irq;
  unsigned long           state;
  struct list\PYGZus{}head        dev\PYGZus{}list;
  struct list\PYGZus{}head        napi\PYGZus{}list;
  struct list\PYGZus{}head        unreg\PYGZus{}list;
  struct list\PYGZus{}head        close\PYGZus{}list;
  struct list\PYGZus{}head        ptype\PYGZus{}all;
  struct list\PYGZus{}head        ptype\PYGZus{}specific;
  struct \PYGZob{}
    struct list\PYGZus{}head upper;
    struct list\PYGZus{}head lower;
  \PYGZcb{} adj\PYGZus{}list;
  netdev\PYGZus{}features\PYGZus{}t features;
  netdev\PYGZus{}features\PYGZus{}t hw\PYGZus{}features;
  netdev\PYGZus{}features\PYGZus{}t wanted\PYGZus{}features;
  netdev\PYGZus{}features\PYGZus{}t vlan\PYGZus{}features;
  netdev\PYGZus{}features\PYGZus{}t hw\PYGZus{}enc\PYGZus{}features;
  netdev\PYGZus{}features\PYGZus{}t mpls\PYGZus{}features;
  netdev\PYGZus{}features\PYGZus{}t gso\PYGZus{}partial\PYGZus{}features;
  int ifindex;
  int group;
  struct net\PYGZus{}device\PYGZus{}stats stats;
  atomic\PYGZus{}long\PYGZus{}t rx\PYGZus{}dropped;
  atomic\PYGZus{}long\PYGZus{}t tx\PYGZus{}dropped;
  atomic\PYGZus{}long\PYGZus{}t rx\PYGZus{}nohandler;
  atomic\PYGZus{}t carrier\PYGZus{}up\PYGZus{}count;
  atomic\PYGZus{}t carrier\PYGZus{}down\PYGZus{}count;
\PYGZsh{}ifdef CONFIG\PYGZus{}WIRELESS\PYGZus{}EXT;
  const struct iw\PYGZus{}handler\PYGZus{}def *wireless\PYGZus{}handlers;
  struct iw\PYGZus{}public\PYGZus{}data   *wireless\PYGZus{}data;
\PYGZsh{}endif;
  const struct net\PYGZus{}device\PYGZus{}ops *netdev\PYGZus{}ops;
  const struct ethtool\PYGZus{}ops *ethtool\PYGZus{}ops;
\PYGZsh{}ifdef CONFIG\PYGZus{}NET\PYGZus{}SWITCHDEV;
  const struct switchdev\PYGZus{}ops *switchdev\PYGZus{}ops;
\PYGZsh{}endif;
\PYGZsh{}ifdef CONFIG\PYGZus{}NET\PYGZus{}L3\PYGZus{}MASTER\PYGZus{}DEV;
  const struct l3mdev\PYGZus{}ops *l3mdev\PYGZus{}ops;
\PYGZsh{}endif;
\PYGZsh{}if IS\PYGZus{}ENABLED(CONFIG\PYGZus{}IPV6);
  const struct ndisc\PYGZus{}ops *ndisc\PYGZus{}ops;
\PYGZsh{}endif;
\PYGZsh{}ifdef CONFIG\PYGZus{}XFRM\PYGZus{}OFFLOAD;
  const struct xfrmdev\PYGZus{}ops *xfrmdev\PYGZus{}ops;
\PYGZsh{}endif;
  const struct header\PYGZus{}ops *header\PYGZus{}ops;
  unsigned int            flags;
  unsigned int            priv\PYGZus{}flags;
  unsigned short          gflags;
  unsigned short          padded;
  unsigned char           operstate;
  unsigned char           link\PYGZus{}mode;
  unsigned char           if\PYGZus{}port;
  unsigned char           dma;
  unsigned int            mtu;
  unsigned int            min\PYGZus{}mtu;
  unsigned int            max\PYGZus{}mtu;
  unsigned short          type;
  unsigned short          hard\PYGZus{}header\PYGZus{}len;
  unsigned char           min\PYGZus{}header\PYGZus{}len;
  unsigned short          needed\PYGZus{}headroom;
  unsigned short          needed\PYGZus{}tailroom;
  unsigned char           perm\PYGZus{}addr[MAX\PYGZus{}ADDR\PYGZus{}LEN];
  unsigned char           addr\PYGZus{}assign\PYGZus{}type;
  unsigned char           addr\PYGZus{}len;
  unsigned short          neigh\PYGZus{}priv\PYGZus{}len;
  unsigned short          dev\PYGZus{}id;
  unsigned short          dev\PYGZus{}port;
  spinlock\PYGZus{}t addr\PYGZus{}list\PYGZus{}lock;
  unsigned char           name\PYGZus{}assign\PYGZus{}type;
  bool uc\PYGZus{}promisc;
  struct netdev\PYGZus{}hw\PYGZus{}addr\PYGZus{}list      uc;
  struct netdev\PYGZus{}hw\PYGZus{}addr\PYGZus{}list      mc;
  struct netdev\PYGZus{}hw\PYGZus{}addr\PYGZus{}list      dev\PYGZus{}addrs;
\PYGZsh{}ifdef CONFIG\PYGZus{}SYSFS;
  struct kset             *queues\PYGZus{}kset;
\PYGZsh{}endif;
  unsigned int            promiscuity;
  unsigned int            allmulti;
\PYGZsh{}if IS\PYGZus{}ENABLED(CONFIG\PYGZus{}VLAN\PYGZus{}8021Q);
  struct vlan\PYGZus{}info \PYGZus{}\PYGZus{}rcu  *vlan\PYGZus{}info;
\PYGZsh{}endif;
\PYGZsh{}if IS\PYGZus{}ENABLED(CONFIG\PYGZus{}NET\PYGZus{}DSA);
  struct dsa\PYGZus{}port         *dsa\PYGZus{}ptr;
\PYGZsh{}endif;
\PYGZsh{}if IS\PYGZus{}ENABLED(CONFIG\PYGZus{}TIPC);
  struct tipc\PYGZus{}bearer \PYGZus{}\PYGZus{}rcu *tipc\PYGZus{}ptr;
\PYGZsh{}endif;
  void *atalk\PYGZus{}ptr;
  struct in\PYGZus{}device \PYGZus{}\PYGZus{}rcu  *ip\PYGZus{}ptr;
  struct dn\PYGZus{}dev \PYGZus{}\PYGZus{}rcu     *dn\PYGZus{}ptr;
  struct inet6\PYGZus{}dev \PYGZus{}\PYGZus{}rcu  *ip6\PYGZus{}ptr;
  void *ax25\PYGZus{}ptr;
  struct wireless\PYGZus{}dev     *ieee80211\PYGZus{}ptr;
  struct wpan\PYGZus{}dev         *ieee802154\PYGZus{}ptr;
\PYGZsh{}if IS\PYGZus{}ENABLED(CONFIG\PYGZus{}MPLS\PYGZus{}ROUTING);
  struct mpls\PYGZus{}dev \PYGZus{}\PYGZus{}rcu   *mpls\PYGZus{}ptr;
\PYGZsh{}endif;
  unsigned char           *dev\PYGZus{}addr;
  struct netdev\PYGZus{}rx\PYGZus{}queue  *\PYGZus{}rx;
  unsigned int            num\PYGZus{}rx\PYGZus{}queues;
  unsigned int            real\PYGZus{}num\PYGZus{}rx\PYGZus{}queues;
  struct bpf\PYGZus{}prog \PYGZus{}\PYGZus{}rcu   *xdp\PYGZus{}prog;
  unsigned long           gro\PYGZus{}flush\PYGZus{}timeout;
  rx\PYGZus{}handler\PYGZus{}func\PYGZus{}t \PYGZus{}\PYGZus{}rcu *rx\PYGZus{}handler;
  void \PYGZus{}\PYGZus{}rcu              *rx\PYGZus{}handler\PYGZus{}data;
\PYGZsh{}ifdef CONFIG\PYGZus{}NET\PYGZus{}CLS\PYGZus{}ACT;
  struct mini\PYGZus{}Qdisc \PYGZus{}\PYGZus{}rcu *miniq\PYGZus{}ingress;
\PYGZsh{}endif;
  struct netdev\PYGZus{}queue \PYGZus{}\PYGZus{}rcu *ingress\PYGZus{}queue;
\PYGZsh{}ifdef CONFIG\PYGZus{}NETFILTER\PYGZus{}INGRESS;
  struct nf\PYGZus{}hook\PYGZus{}entries \PYGZus{}\PYGZus{}rcu *nf\PYGZus{}hooks\PYGZus{}ingress;
\PYGZsh{}endif;
  unsigned char           broadcast[MAX\PYGZus{}ADDR\PYGZus{}LEN];
\PYGZsh{}ifdef CONFIG\PYGZus{}RFS\PYGZus{}ACCEL;
  struct cpu\PYGZus{}rmap         *rx\PYGZus{}cpu\PYGZus{}rmap;
\PYGZsh{}endif;
  struct hlist\PYGZus{}node       index\PYGZus{}hlist;
  struct netdev\PYGZus{}queue     *\PYGZus{}tx \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}cacheline\PYGZus{}aligned\PYGZus{}in\PYGZus{}smp;
  unsigned int            num\PYGZus{}tx\PYGZus{}queues;
  unsigned int            real\PYGZus{}num\PYGZus{}tx\PYGZus{}queues;
  struct Qdisc            *qdisc;
\PYGZsh{}ifdef CONFIG\PYGZus{}NET\PYGZus{}SCHED;
  unsigned long qdisc\PYGZus{}hash[1 \PYGZlt{}\PYGZlt{} ((4) \PYGZhy{} 1)];
\PYGZsh{}endif;
  unsigned int            tx\PYGZus{}queue\PYGZus{}len;
  spinlock\PYGZus{}t tx\PYGZus{}global\PYGZus{}lock;
  int watchdog\PYGZus{}timeo;
\PYGZsh{}ifdef CONFIG\PYGZus{}XPS;
  struct xps\PYGZus{}dev\PYGZus{}maps \PYGZus{}\PYGZus{}rcu *xps\PYGZus{}maps;
\PYGZsh{}endif;
\PYGZsh{}ifdef CONFIG\PYGZus{}NET\PYGZus{}CLS\PYGZus{}ACT;
  struct mini\PYGZus{}Qdisc \PYGZus{}\PYGZus{}rcu *miniq\PYGZus{}egress;
\PYGZsh{}endif;
  struct timer\PYGZus{}list       watchdog\PYGZus{}timer;
  int \PYGZus{}\PYGZus{}percpu            *pcpu\PYGZus{}refcnt;
  struct list\PYGZus{}head        todo\PYGZus{}list;
  struct list\PYGZus{}head        link\PYGZus{}watch\PYGZus{}list;
  enum \PYGZob{}
    NETREG\PYGZus{}UNINITIALIZED=0,
    NETREG\PYGZus{}REGISTERED,
    NETREG\PYGZus{}UNREGISTERING,
    NETREG\PYGZus{}UNREGISTERED,
    NETREG\PYGZus{}RELEASED,
    NETREG\PYGZus{}DUMMY,
  \PYGZcb{} reg\PYGZus{}state:8;
  bool dismantle;
  enum \PYGZob{}
    RTNL\PYGZus{}LINK\PYGZus{}INITIALIZED,
    RTNL\PYGZus{}LINK\PYGZus{}INITIALIZING,
  \PYGZcb{} rtnl\PYGZus{}link\PYGZus{}state:16;
  bool needs\PYGZus{}free\PYGZus{}netdev;
  void (*priv\PYGZus{}destructor)(struct net\PYGZus{}device *dev);
\PYGZsh{}ifdef CONFIG\PYGZus{}NETPOLL;
  struct netpoll\PYGZus{}info \PYGZus{}\PYGZus{}rcu       *npinfo;
\PYGZsh{}endif;
  possible\PYGZus{}net\PYGZus{}t nd\PYGZus{}net;
  union \PYGZob{}
    void *ml\PYGZus{}priv;
    struct pcpu\PYGZus{}lstats \PYGZus{}\PYGZus{}percpu             *lstats;
    struct pcpu\PYGZus{}sw\PYGZus{}netstats \PYGZus{}\PYGZus{}percpu        *tstats;
    struct pcpu\PYGZus{}dstats \PYGZus{}\PYGZus{}percpu             *dstats;
    struct pcpu\PYGZus{}vstats \PYGZus{}\PYGZus{}percpu             *vstats;
  \PYGZcb{};
\PYGZsh{}if IS\PYGZus{}ENABLED(CONFIG\PYGZus{}GARP);
  struct garp\PYGZus{}port \PYGZus{}\PYGZus{}rcu  *garp\PYGZus{}port;
\PYGZsh{}endif;
\PYGZsh{}if IS\PYGZus{}ENABLED(CONFIG\PYGZus{}MRP);
  struct mrp\PYGZus{}port \PYGZus{}\PYGZus{}rcu   *mrp\PYGZus{}port;
\PYGZsh{}endif;
  struct device           dev;
  const struct attribute\PYGZus{}group *sysfs\PYGZus{}groups[4];
  const struct attribute\PYGZus{}group *sysfs\PYGZus{}rx\PYGZus{}queue\PYGZus{}group;
  const struct rtnl\PYGZus{}link\PYGZus{}ops *rtnl\PYGZus{}link\PYGZus{}ops;
\PYGZsh{}define GSO\PYGZus{}MAX\PYGZus{}SIZE            65536;
  unsigned int            gso\PYGZus{}max\PYGZus{}size;
\PYGZsh{}define GSO\PYGZus{}MAX\PYGZus{}SEGS            65535;
  u16 gso\PYGZus{}max\PYGZus{}segs;
\PYGZsh{}ifdef CONFIG\PYGZus{}DCB;
  const struct dcbnl\PYGZus{}rtnl\PYGZus{}ops *dcbnl\PYGZus{}ops;
\PYGZsh{}endif;
  u8 num\PYGZus{}tc;
  struct netdev\PYGZus{}tc\PYGZus{}txq    tc\PYGZus{}to\PYGZus{}txq[TC\PYGZus{}MAX\PYGZus{}QUEUE];
  u8 prio\PYGZus{}tc\PYGZus{}map[TC\PYGZus{}BITMASK + 1];
\PYGZsh{}if IS\PYGZus{}ENABLED(CONFIG\PYGZus{}FCOE);
  unsigned int            fcoe\PYGZus{}ddp\PYGZus{}xid;
\PYGZsh{}endif;
\PYGZsh{}if IS\PYGZus{}ENABLED(CONFIG\PYGZus{}CGROUP\PYGZus{}NET\PYGZus{}PRIO);
  struct netprio\PYGZus{}map \PYGZus{}\PYGZus{}rcu *priomap;
\PYGZsh{}endif;
  struct phy\PYGZus{}device       *phydev;
  struct lock\PYGZus{}class\PYGZus{}key   *qdisc\PYGZus{}tx\PYGZus{}busylock;
  struct lock\PYGZus{}class\PYGZus{}key   *qdisc\PYGZus{}running\PYGZus{}key;
  bool proto\PYGZus{}down;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
This is the first field of the ``visible'' part of this structure
(i.e. as seen by users in the ``Space.c'' file).  It is the name
of the interface.

\item[{\code{name\_hlist}}] \leavevmode
Device name hash chain, please keep it close to name{[}{]}

\item[{\code{ifalias}}] \leavevmode
SNMP alias

\item[{\code{mem\_end}}] \leavevmode
Shared memory end

\item[{\code{mem\_start}}] \leavevmode
Shared memory start

\item[{\code{base\_addr}}] \leavevmode
Device I/O address

\item[{\code{irq}}] \leavevmode
Device IRQ number

\item[{\code{state}}] \leavevmode
Generic network queuing layer state, see netdev\_state\_t

\item[{\code{dev\_list}}] \leavevmode
The global list of network devices

\item[{\code{napi\_list}}] \leavevmode
List entry used for polling NAPI devices

\item[{\code{unreg\_list}}] \leavevmode
List entry  when we are unregistering the
device; see the function unregister\_netdev

\item[{\code{close\_list}}] \leavevmode
List entry used when we are closing the device

\item[{\code{ptype\_all}}] \leavevmode
Device-specific packet handlers for all protocols

\item[{\code{ptype\_specific}}] \leavevmode
Device-specific, protocol-specific packet handlers

\item[{\code{adj\_list}}] \leavevmode
Directly linked devices, like slaves for bonding

\item[{\code{features}}] \leavevmode
Currently active device features

\item[{\code{hw\_features}}] \leavevmode
User-changeable features

\item[{\code{wanted\_features}}] \leavevmode
User-requested features

\item[{\code{vlan\_features}}] \leavevmode
Mask of features inheritable by VLAN devices

\item[{\code{hw\_enc\_features}}] \leavevmode
Mask of features inherited by encapsulating devices
This field indicates what encapsulation
offloads the hardware is capable of doing,
and drivers will need to set them appropriately.

\item[{\code{mpls\_features}}] \leavevmode
Mask of features inheritable by MPLS

\item[{\code{ifindex}}] \leavevmode
interface index

\item[{\code{group}}] \leavevmode
The group the device belongs to

\item[{\code{stats}}] \leavevmode
Statistics struct, which was left as a legacy, use
rtnl\_link\_stats64 instead

\item[{\code{rx\_dropped}}] \leavevmode
Dropped packets by core network,
do not use this in drivers

\item[{\code{tx\_dropped}}] \leavevmode
Dropped packets by core network,
do not use this in drivers

\item[{\code{rx\_nohandler}}] \leavevmode
nohandler dropped packets by core network on
inactive devices, do not use this in drivers

\item[{\code{carrier\_up\_count}}] \leavevmode
Number of times the carrier has been up

\item[{\code{carrier\_down\_count}}] \leavevmode
Number of times the carrier has been down

\item[{\code{wireless\_handlers}}] \leavevmode
List of functions to handle Wireless Extensions,
instead of ioctl,
see \textless{}net/iw\_handler.h\textgreater{} for details.

\item[{\code{wireless\_data}}] \leavevmode
Instance data managed by the core of wireless extensions

\item[{\code{netdev\_ops}}] \leavevmode
Includes several pointers to callbacks,
if one wants to override the ndo\_*() functions

\item[{\code{ethtool\_ops}}] \leavevmode
Management operations

\item[{\code{ndisc\_ops}}] \leavevmode
Includes callbacks for different IPv6 neighbour
discovery handling. Necessary for e.g. 6LoWPAN.

\item[{\code{header\_ops}}] \leavevmode
Includes callbacks for creating,parsing,caching,etc
of Layer 2 headers.

\item[{\code{flags}}] \leavevmode
Interface flags (a la BSD)

\item[{\code{priv\_flags}}] \leavevmode
Like `flags' but invisible to userspace,
see if.h for the definitions

\item[{\code{gflags}}] \leavevmode
Global flags ( kept as legacy )

\item[{\code{padded}}] \leavevmode
How much padding added by \code{alloc\_netdev()}

\item[{\code{operstate}}] \leavevmode
RFC2863 operstate

\item[{\code{link\_mode}}] \leavevmode
Mapping policy to operstate

\item[{\code{if\_port}}] \leavevmode
Selectable AUI, TP, ...

\item[{\code{dma}}] \leavevmode
DMA channel

\item[{\code{mtu}}] \leavevmode
Interface MTU value

\item[{\code{min\_mtu}}] \leavevmode
Interface Minimum MTU value

\item[{\code{max\_mtu}}] \leavevmode
Interface Maximum MTU value

\item[{\code{type}}] \leavevmode
Interface hardware type

\item[{\code{hard\_header\_len}}] \leavevmode
Maximum hardware header length.

\item[{\code{min\_header\_len}}] \leavevmode
Minimum hardware header length

\item[{\code{needed\_headroom}}] \leavevmode
Extra headroom the hardware may need, but not in all
cases can this be guaranteed

\item[{\code{needed\_tailroom}}] \leavevmode
Extra tailroom the hardware may need, but not in all
cases can this be guaranteed. Some cases also use
LL\_MAX\_HEADER instead to allocate the skb

\item[{\code{perm\_addr}}] \leavevmode
Permanent hw address

\item[{\code{addr\_assign\_type}}] \leavevmode
Hw address assignment type

\item[{\code{addr\_len}}] \leavevmode
Hardware address length

\item[{\code{neigh\_priv\_len}}] \leavevmode
Used in \code{neigh\_alloc()}

\item[{\code{dev\_id}}] \leavevmode
Used to differentiate devices that share
the same link layer address

\item[{\code{dev\_port}}] \leavevmode
Used to differentiate devices that share
the same function

\item[{\code{addr\_list\_lock}}] \leavevmode
XXX: need comments on this one

\item[{\code{uc\_promisc}}] \leavevmode
Counter that indicates promiscuous mode
has been enabled due to the need to listen to
additional unicast addresses in a device that
does not implement \code{ndo\_set\_rx\_mode()}

\item[{\code{uc}}] \leavevmode
unicast mac addresses

\item[{\code{mc}}] \leavevmode
multicast mac addresses

\item[{\code{dev\_addrs}}] \leavevmode
list of device hw addresses

\item[{\code{queues\_kset}}] \leavevmode
Group of all Kobjects in the Tx and RX queues

\item[{\code{promiscuity}}] \leavevmode
Number of times the NIC is told to work in
promiscuous mode; if it becomes 0 the NIC will
exit promiscuous mode

\item[{\code{allmulti}}] \leavevmode
Counter, enables or disables allmulticast mode

\item[{\code{vlan\_info}}] \leavevmode
VLAN info

\item[{\code{dsa\_ptr}}] \leavevmode
dsa specific data

\item[{\code{tipc\_ptr}}] \leavevmode
TIPC specific data

\item[{\code{atalk\_ptr}}] \leavevmode
AppleTalk link

\item[{\code{ip\_ptr}}] \leavevmode
IPv4 specific data

\item[{\code{dn\_ptr}}] \leavevmode
DECnet specific data

\item[{\code{ip6\_ptr}}] \leavevmode
IPv6 specific data

\item[{\code{ax25\_ptr}}] \leavevmode
AX.25 specific data

\item[{\code{ieee80211\_ptr}}] \leavevmode
IEEE 802.11 specific data, assign before registering

\item[{\code{dev\_addr}}] \leavevmode
Hw address (before bcast,
because most packets are unicast)

\item[{\code{\_rx}}] \leavevmode
Array of RX queues

\item[{\code{num\_rx\_queues}}] \leavevmode
Number of RX queues
allocated at {\hyperref[networking/kapi:c.register_netdev]{\emph{\code{register\_netdev()}}}} time

\item[{\code{real\_num\_rx\_queues}}] \leavevmode
Number of RX queues currently active in device

\item[{\code{rx\_handler}}] \leavevmode
handler for received packets

\item[{\code{rx\_handler\_data}}] \leavevmode
XXX: need comments on this one

\item[{\code{miniq\_ingress}}] \leavevmode
ingress/clsact qdisc specific data for
ingress processing

\item[{\code{ingress\_queue}}] \leavevmode
XXX: need comments on this one

\item[{\code{broadcast}}] \leavevmode
hw bcast address

\item[{\code{rx\_cpu\_rmap}}] \leavevmode
CPU reverse-mapping for RX completion interrupts,
indexed by RX queue number. Assigned by driver.
This must only be set if the ndo\_rx\_flow\_steer
operation is defined

\item[{\code{index\_hlist}}] \leavevmode
Device index hash chain

\item[{\code{num\_tx\_queues}}] \leavevmode
Number of TX queues allocated at \code{alloc\_netdev\_mq()} time

\item[{\code{real\_num\_tx\_queues}}] \leavevmode
Number of TX queues currently active in device

\item[{\code{qdisc}}] \leavevmode
Root qdisc from userspace point of view

\item[{\code{tx\_queue\_len}}] \leavevmode
Max frames per queue allowed

\item[{\code{tx\_global\_lock}}] \leavevmode
XXX: need comments on this one

\item[{\code{watchdog\_timeo}}] \leavevmode
Represents the timeout that is used by
the watchdog (see \code{dev\_watchdog()})

\item[{\code{xps\_maps}}] \leavevmode
XXX: need comments on this one

\item[{\code{miniq\_egress}}] \leavevmode
clsact qdisc specific data for
egress processing

\item[{\code{watchdog\_timer}}] \leavevmode
List of timers

\item[{\code{pcpu\_refcnt}}] \leavevmode
Number of references to this device

\item[{\code{todo\_list}}] \leavevmode
Delayed register/unregister

\item[{\code{link\_watch\_list}}] \leavevmode
XXX: need comments on this one

\item[{\code{reg\_state}}] \leavevmode
Register/unregister state machine

\item[{\code{dismantle}}] \leavevmode
Device is going to be freed

\item[{\code{rtnl\_link\_state}}] \leavevmode
This enum represents the phases of creating
a new link

\item[{\code{needs\_free\_netdev}}] \leavevmode
Should unregister perform free\_netdev?

\item[{\code{priv\_destructor}}] \leavevmode
Called from unregister

\item[{\code{npinfo}}] \leavevmode
XXX: need comments on this one

\item[{\code{nd\_net}}] \leavevmode
Network namespace this network device is inside

\item[{\code{\{unnamed\_union\}}}] \leavevmode
anonymous

\item[{\code{ml\_priv}}] \leavevmode
Mid-layer private

\item[{\code{lstats}}] \leavevmode
Loopback statistics

\item[{\code{tstats}}] \leavevmode
Tunnel statistics

\item[{\code{dstats}}] \leavevmode
Dummy statistics

\item[{\code{vstats}}] \leavevmode
Virtual ethernet statistics

\item[{\code{garp\_port}}] \leavevmode
GARP

\item[{\code{mrp\_port}}] \leavevmode
MRP

\item[{\code{dev}}] \leavevmode
Class/net/name entry

\item[{\code{sysfs\_groups}}] \leavevmode
Space for optional device, statistics and wireless
sysfs groups

\item[{\code{sysfs\_rx\_queue\_group}}] \leavevmode
Space for optional per-rx queue attributes

\item[{\code{rtnl\_link\_ops}}] \leavevmode
Rtnl\_link\_ops

\item[{\code{gso\_max\_size}}] \leavevmode
Maximum size of generic segmentation offload

\item[{\code{gso\_max\_segs}}] \leavevmode
Maximum number of segments that can be passed to the
NIC for GSO

\item[{\code{dcbnl\_ops}}] \leavevmode
Data Center Bridging netlink ops

\item[{\code{num\_tc}}] \leavevmode
Number of traffic classes in the net device

\item[{\code{tc\_to\_txq}}] \leavevmode
XXX: need comments on this one

\item[{\code{prio\_tc\_map}}] \leavevmode
XXX: need comments on this one

\item[{\code{fcoe\_ddp\_xid}}] \leavevmode
Max exchange id for FCoE LRO by ddp

\item[{\code{priomap}}] \leavevmode
XXX: need comments on this one

\item[{\code{phydev}}] \leavevmode
Physical device may attach itself
for hardware timestamping

\item[{\code{qdisc\_tx\_busylock}}] \leavevmode
lockdep class annotating Qdisc-\textgreater{}busylock spinlock

\item[{\code{qdisc\_running\_key}}] \leavevmode
lockdep class annotating Qdisc-\textgreater{}running seqcount

\item[{\code{proto\_down}}] \leavevmode
protocol port state information can be sent to the
switch driver and used to set the phys state of the
switch port.

\end{description}

\textbf{Description}
\begin{quote}

Actually, this whole structure is a big mistake.  It mixes I/O
data with strictly ``high-level'' data, and it has to know about
almost every data structure used in the INET module.

interface address info:

FIXME: cleanup struct net\_device such that network protocol info
moves out.
\end{quote}
\index{netdev\_priv (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_priv}\pysiglinewithargsret{void * \bfcode{netdev\_priv}}{const struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
access network device private data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}

Get network device private data
\index{netif\_napi\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_napi_add}\pysiglinewithargsret{void \bfcode{netif\_napi\_add}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct napi\_struct *\emph{napi}, int (*poll) (struct napi\_struct\emph{*}, int, int\emph{weight}}{}
initialize a NAPI context

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{struct napi\_struct * napi}}] \leavevmode
NAPI context

\item[{\code{int (*)(struct napi\_struct *, int) poll}}] \leavevmode
polling function

\item[{\code{int weight}}] \leavevmode
default weight

\end{description}

\textbf{Description}

{\hyperref[networking/kapi:c.netif_napi_add]{\emph{\code{netif\_napi\_add()}}}} must be used to initialize a NAPI context prior to calling
\emph{any} of the other NAPI-related functions.
\index{netif\_tx\_napi\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_tx_napi_add}\pysiglinewithargsret{void \bfcode{netif\_tx\_napi\_add}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct napi\_struct *\emph{napi}, int (*poll) (struct napi\_struct\emph{*}, int, int\emph{weight}}{}
initialize a NAPI context

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{struct napi\_struct * napi}}] \leavevmode
NAPI context

\item[{\code{int (*)(struct napi\_struct *, int) poll}}] \leavevmode
polling function

\item[{\code{int weight}}] \leavevmode
default weight

\end{description}

\textbf{Description}

This variant of {\hyperref[networking/kapi:c.netif_napi_add]{\emph{\code{netif\_napi\_add()}}}} should be used from drivers using NAPI
to exclusively poll a TX queue.
This will avoid we add it into napi\_hash{[}{]}, thus polluting this hash table.
\index{netif\_napi\_del (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_napi_del}\pysiglinewithargsret{void \bfcode{netif\_napi\_del}}{struct napi\_struct *\emph{napi}}{}
remove a NAPI context

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct napi\_struct * napi}}] \leavevmode
NAPI context

\end{description}

\textbf{Description}
\begin{quote}

{\hyperref[networking/kapi:c.netif_napi_del]{\emph{\code{netif\_napi\_del()}}}} removes a NAPI context from the network device NAPI list
\end{quote}
\index{netif\_start\_queue (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_start_queue}\pysiglinewithargsret{void \bfcode{netif\_start\_queue}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
allow transmit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}
\begin{quote}

Allow upper layers to call the device hard\_start\_xmit routine.
\end{quote}
\index{netif\_wake\_queue (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_wake_queue}\pysiglinewithargsret{void \bfcode{netif\_wake\_queue}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
restart transmit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}
\begin{quote}

Allow upper layers to call the device hard\_start\_xmit routine.
Used for flow control when transmit resources are available.
\end{quote}
\index{netif\_stop\_queue (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_stop_queue}\pysiglinewithargsret{void \bfcode{netif\_stop\_queue}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
stop transmitted packets

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}
\begin{quote}

Stop upper layers calling the device hard\_start\_xmit routine.
Used for flow control when transmit resources are unavailable.
\end{quote}
\index{netif\_queue\_stopped (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_queue_stopped}\pysiglinewithargsret{bool \bfcode{netif\_queue\_stopped}}{const struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
test if transmit queue is flowblocked

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}
\begin{quote}

Test if transmit queue on device is currently unable to send.
\end{quote}
\index{netdev\_txq\_bql\_enqueue\_prefetchw (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_txq_bql_enqueue_prefetchw}\pysiglinewithargsret{void \bfcode{netdev\_txq\_bql\_enqueue\_prefetchw}}{struct netdev\_queue *\emph{dev\_queue}}{}
prefetch bql data for write

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct netdev\_queue * dev\_queue}}] \leavevmode
pointer to transmit queue

\end{description}

\textbf{Description}

BQL enabled drivers might use this helper in their \code{ndo\_start\_xmit()},
to give appropriate hint to the CPU.
\index{netdev\_txq\_bql\_complete\_prefetchw (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_txq_bql_complete_prefetchw}\pysiglinewithargsret{void \bfcode{netdev\_txq\_bql\_complete\_prefetchw}}{struct netdev\_queue *\emph{dev\_queue}}{}
prefetch bql data for write

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct netdev\_queue * dev\_queue}}] \leavevmode
pointer to transmit queue

\end{description}

\textbf{Description}

BQL enabled drivers might use this helper in their TX completion path,
to give appropriate hint to the CPU.
\index{netdev\_sent\_queue (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_sent_queue}\pysiglinewithargsret{void \bfcode{netdev\_sent\_queue}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, unsigned int\emph{bytes}}{}
report the number of bytes queued to hardware

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{unsigned int bytes}}] \leavevmode
number of bytes queued to the hardware device queue

\end{description}

\textbf{Description}
\begin{quote}

Report the number of bytes queued for sending/completion to the network
device hardware queue. \textbf{bytes} should be a good approximation and should
exactly match {\hyperref[networking/kapi:c.netdev_completed_queue]{\emph{\code{netdev\_completed\_queue()}}}} \textbf{bytes}
\end{quote}
\index{netdev\_completed\_queue (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_completed_queue}\pysiglinewithargsret{void \bfcode{netdev\_completed\_queue}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, unsigned int\emph{pkts}, unsigned int\emph{bytes}}{}
report bytes and packets completed by device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{unsigned int pkts}}] \leavevmode
actual number of packets sent over the medium

\item[{\code{unsigned int bytes}}] \leavevmode
actual number of bytes sent over the medium

\end{description}

\textbf{Description}
\begin{quote}

Report the number of bytes and packets transmitted by the network device
hardware queue over the physical medium, \textbf{bytes} must exactly match the
\textbf{bytes} amount passed to {\hyperref[networking/kapi:c.netdev_sent_queue]{\emph{\code{netdev\_sent\_queue()}}}}
\end{quote}
\index{netdev\_reset\_queue (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_reset_queue}\pysiglinewithargsret{void \bfcode{netdev\_reset\_queue}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev\_queue}}{}
reset the packets and bytes count of a network device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev\_queue}}] \leavevmode
network device

\end{description}

\textbf{Description}
\begin{quote}

Reset the bytes and packet count of a network device and clear the
software flow control OFF bit for this network device
\end{quote}
\index{netdev\_cap\_txqueue (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netdev_cap_txqueue}\pysiglinewithargsret{u16 \bfcode{netdev\_cap\_txqueue}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, u16\emph{queue\_index}}{}
check if selected tx queue exceeds device queues

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{u16 queue\_index}}] \leavevmode
given tx queue index

\end{description}

\textbf{Description}
\begin{quote}

Returns 0 if given tx queue index \textgreater{}= number of device tx queues,
otherwise returns the originally passed tx queue index.
\end{quote}
\index{netif\_running (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_running}\pysiglinewithargsret{bool \bfcode{netif\_running}}{const struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
test if up

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}
\begin{quote}

Test if the device has been brought up.
\end{quote}
\index{netif\_start\_subqueue (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_start_subqueue}\pysiglinewithargsret{void \bfcode{netif\_start\_subqueue}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, u16\emph{queue\_index}}{}
allow sending packets on subqueue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{u16 queue\_index}}] \leavevmode
sub queue index

\end{description}

\textbf{Description}

Start individual transmit queue of a device with multiple transmit queues.
\index{netif\_stop\_subqueue (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_stop_subqueue}\pysiglinewithargsret{void \bfcode{netif\_stop\_subqueue}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, u16\emph{queue\_index}}{}
stop sending packets on subqueue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{u16 queue\_index}}] \leavevmode
sub queue index

\end{description}

\textbf{Description}

Stop individual transmit queue of a device with multiple transmit queues.
\index{\_\_netif\_subqueue\_stopped (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__netif_subqueue_stopped}\pysiglinewithargsret{bool \bfcode{\_\_netif\_subqueue\_stopped}}{const struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, u16\emph{queue\_index}}{}
test status of subqueue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct net\_device * dev}}] \leavevmode
network device

\item[{\code{u16 queue\_index}}] \leavevmode
sub queue index

\end{description}

\textbf{Description}

Check individual transmit queue of a device with multiple transmit queues.
\index{netif\_wake\_subqueue (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_wake_subqueue}\pysiglinewithargsret{void \bfcode{netif\_wake\_subqueue}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, u16\emph{queue\_index}}{}
allow sending packets on subqueue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\item[{\code{u16 queue\_index}}] \leavevmode
sub queue index

\end{description}

\textbf{Description}

Resume individual transmit queue of a device with multiple transmit queues.
\index{netif\_is\_multiqueue (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_is_multiqueue}\pysiglinewithargsret{bool \bfcode{netif\_is\_multiqueue}}{const struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
test if device has multiple transmit queues

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}

Check if device has multiple transmit queues
\index{dev\_put (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_put}\pysiglinewithargsret{void \bfcode{dev\_put}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
release reference to device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}

Release reference to device to allow it to be freed.
\index{dev\_hold (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.dev_hold}\pysiglinewithargsret{void \bfcode{dev\_hold}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
get reference to device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}

Hold reference to device to keep it from being freed.
\index{netif\_carrier\_ok (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_carrier_ok}\pysiglinewithargsret{bool \bfcode{netif\_carrier\_ok}}{const struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
test if carrier present

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}

Check if carrier is present on device
\index{netif\_dormant\_on (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_dormant_on}\pysiglinewithargsret{void \bfcode{netif\_dormant\_on}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
mark device as dormant.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}

Mark device as dormant (as per RFC2863).

The dormant state indicates that the relevant interface is not
actually in a condition to pass packets (i.e., it is not `up') but is
in a ``pending'' state, waiting for some external event.  For ``on-
demand'' interfaces, this new state identifies the situation where the
interface is waiting for events to place it in the up state.
\index{netif\_dormant\_off (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_dormant_off}\pysiglinewithargsret{void \bfcode{netif\_dormant\_off}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
set device as not dormant.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}

Device is not in dormant state.
\index{netif\_dormant (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_dormant}\pysiglinewithargsret{bool \bfcode{netif\_dormant}}{const struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
test if device is dormant

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}

Check if device is dormant.
\index{netif\_oper\_up (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_oper_up}\pysiglinewithargsret{bool \bfcode{netif\_oper\_up}}{const struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
test if device is operational

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}

Check if carrier is operational
\index{netif\_device\_present (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_device_present}\pysiglinewithargsret{bool \bfcode{netif\_device\_present}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
is device available or removed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}

Check if device has not been removed from system.
\index{netif\_tx\_lock (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.netif_tx_lock}\pysiglinewithargsret{void \bfcode{netif\_tx\_lock}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}}{}
grab network device transmit lock

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device

\end{description}

\textbf{Description}

Get network device transmit lock
\index{\_\_dev\_uc\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__dev_uc_sync}\pysiglinewithargsret{int \bfcode{\_\_dev\_uc\_sync}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, int (*sync) (struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}}\emph{*}, const unsigned char\emph{*}, int (*unsync) (struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}}\emph{*}, const unsigned char\emph{*}}{}
Synchonize device's unicast list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device to sync

\item[{\code{int (*)(struct net\_device *, const unsigned char *) sync}}] \leavevmode
function to call if address should be added

\item[{\code{int (*)(struct net\_device *, const unsigned char *) unsync}}] \leavevmode
function to call if address should be removed

\end{description}

\textbf{Description}
\begin{quote}

Add newly added addresses to the interface, and release
addresses that have been deleted.
\end{quote}
\index{\_\_dev\_uc\_unsync (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__dev_uc_unsync}\pysiglinewithargsret{void \bfcode{\_\_dev\_uc\_unsync}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, int (*unsync) (struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}}\emph{*}, const unsigned char\emph{*}}{}
Remove synchronized addresses from device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device to sync

\item[{\code{int (*)(struct net\_device *, const unsigned char *) unsync}}] \leavevmode
function to call if address should be removed

\end{description}

\textbf{Description}
\begin{quote}

Remove all addresses that were added to the device by \code{dev\_uc\_sync()}.
\end{quote}
\index{\_\_dev\_mc\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__dev_mc_sync}\pysiglinewithargsret{int \bfcode{\_\_dev\_mc\_sync}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, int (*sync) (struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}}\emph{*}, const unsigned char\emph{*}, int (*unsync) (struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}}\emph{*}, const unsigned char\emph{*}}{}
Synchonize device's multicast list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device to sync

\item[{\code{int (*)(struct net\_device *, const unsigned char *) sync}}] \leavevmode
function to call if address should be added

\item[{\code{int (*)(struct net\_device *, const unsigned char *) unsync}}] \leavevmode
function to call if address should be removed

\end{description}

\textbf{Description}
\begin{quote}

Add newly added addresses to the interface, and release
addresses that have been deleted.
\end{quote}
\index{\_\_dev\_mc\_unsync (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__dev_mc_unsync}\pysiglinewithargsret{void \bfcode{\_\_dev\_mc\_unsync}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, int (*unsync) (struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}}\emph{*}, const unsigned char\emph{*}}{}
Remove synchronized addresses from device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
device to sync

\item[{\code{int (*)(struct net\_device *, const unsigned char *) unsync}}] \leavevmode
function to call if address should be removed

\end{description}

\textbf{Description}
\begin{quote}

Remove all addresses that were added to the device by \code{dev\_mc\_sync()}.
\end{quote}


\subsection{PHY Support}
\label{networking/kapi:phy-support}\index{phy\_print\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_print_status}\pysiglinewithargsret{void \bfcode{phy\_print\_status}}{struct phy\_device *\emph{phydev}}{}
Convenience function to print out the current phy status

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
the phy\_device struct

\end{description}
\index{phy\_restart\_aneg (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_restart_aneg}\pysiglinewithargsret{int \bfcode{phy\_restart\_aneg}}{struct phy\_device *\emph{phydev}}{}
restart auto-negotiation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}

\textbf{Description}

Restart the autonegotiation on \textbf{phydev}.  Returns \textgreater{}= 0 on success or
negative errno on error.
\index{phy\_aneg\_done (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_aneg_done}\pysiglinewithargsret{int \bfcode{phy\_aneg\_done}}{struct phy\_device *\emph{phydev}}{}
return auto-negotiation status

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}

\textbf{Description}

Return the auto-negotiation status from this \textbf{phydev}
Returns \textgreater{} 0 on success or \textless{} 0 on error. 0 means that auto-negotiation
is still pending.
\index{phy\_ethtool\_sset (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_ethtool_sset}\pysiglinewithargsret{int \bfcode{phy\_ethtool\_sset}}{struct phy\_device *\emph{phydev}, struct ethtool\_cmd *\emph{cmd}}{}
generic ethtool sset function, handles all the details

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\item[{\code{struct ethtool\_cmd * cmd}}] \leavevmode
ethtool\_cmd

\end{description}

\textbf{Description}

A few notes about parameter checking:
\begin{itemize}
\item {} 
We don't set port or transceiver, so we don't care what they
were set to.

\item {} 
{\hyperref[networking/kapi:c.phy_start_aneg]{\emph{\code{phy\_start\_aneg()}}}} will make sure forced settings are sane, and
choose the next best ones from the ones selected, so we don't
care if ethtool tries to give us bad values.

\end{itemize}
\index{phy\_mii\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_mii_ioctl}\pysiglinewithargsret{int \bfcode{phy\_mii\_ioctl}}{struct phy\_device *\emph{phydev}, struct ifreq *\emph{ifr}, int\emph{cmd}}{}
generic PHY MII ioctl interface

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
the phy\_device struct

\item[{\code{struct ifreq * ifr}}] \leavevmode
\code{struct ifreq} for socket ioctl's

\item[{\code{int cmd}}] \leavevmode
ioctl cmd to execute

\end{description}

\textbf{Description}

Note that this function is currently incompatible with the
PHYCONTROL layer.  It changes registers without regard to
current state.  Use at own risk.
\index{phy\_start\_aneg (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_start_aneg}\pysiglinewithargsret{int \bfcode{phy\_start\_aneg}}{struct phy\_device *\emph{phydev}}{}
start auto-negotiation for this PHY device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
the phy\_device struct

\end{description}

\textbf{Description}
\begin{description}
\item[{Sanitizes the settings (if we're not autonegotiating}] \leavevmode
them), and then calls the driver's config\_aneg function.
If the PHYCONTROL Layer is operating, we change the state to
reflect the beginning of Auto-negotiation or forcing.

\end{description}
\index{phy\_start\_machine (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_start_machine}\pysiglinewithargsret{void \bfcode{phy\_start\_machine}}{struct phy\_device *\emph{phydev}}{}
start PHY state machine tracking

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
the phy\_device struct

\end{description}

\textbf{Description}
\begin{description}
\item[{The PHY infrastructure can run a state machine}] \leavevmode
which tracks whether the PHY is starting up, negotiating,
etc.  This function starts the delayed workqueue which tracks
the state of the PHY. If you want to maintain your own state machine,
do not call this function.

\end{description}
\index{phy\_start\_interrupts (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_start_interrupts}\pysiglinewithargsret{int \bfcode{phy\_start\_interrupts}}{struct phy\_device *\emph{phydev}}{}
request and enable interrupts for a PHY device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}

\textbf{Description}
\begin{description}
\item[{Request the interrupt for the given PHY.}] \leavevmode
If this fails, then we set irq to PHY\_POLL.
Otherwise, we enable the interrupts in the PHY.
This should only be called with a valid IRQ number.
Returns 0 on success or \textless{} 0 on error.

\end{description}
\index{phy\_stop\_interrupts (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_stop_interrupts}\pysiglinewithargsret{int \bfcode{phy\_stop\_interrupts}}{struct phy\_device *\emph{phydev}}{}
disable interrupts from a PHY device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}
\index{phy\_stop (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_stop}\pysiglinewithargsret{void \bfcode{phy\_stop}}{struct phy\_device *\emph{phydev}}{}
Bring down the PHY link, and stop checking the status

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}
\index{phy\_start (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_start}\pysiglinewithargsret{void \bfcode{phy\_start}}{struct phy\_device *\emph{phydev}}{}
start or restart a PHY device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}

\textbf{Description}
\begin{description}
\item[{Indicates the attached device's readiness to}] \leavevmode
handle PHY-related work.  Used during startup to start the
PHY, and after a call to {\hyperref[networking/kapi:c.phy_stop]{\emph{\code{phy\_stop()}}}} to resume operation.
Also used to indicate the MDIO bus has cleared an error
condition.

\end{description}
\index{phy\_mac\_interrupt (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_mac_interrupt}\pysiglinewithargsret{void \bfcode{phy\_mac\_interrupt}}{struct phy\_device *\emph{phydev}}{}
MAC says the link has changed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
phy\_device struct with changed link

\end{description}

\textbf{Description}

The MAC layer is able to indicate there has been a change in the PHY link
status. Trigger the state machine and work a work queue.
\index{phy\_init\_eee (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_init_eee}\pysiglinewithargsret{int \bfcode{phy\_init\_eee}}{struct phy\_device *\emph{phydev}, bool\emph{clk\_stop\_enable}}{}
init and check the EEE feature

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\item[{\code{bool clk\_stop\_enable}}] \leavevmode
PHY may stop the clock during LPI

\end{description}

\textbf{Description}

it checks if the Energy-Efficient Ethernet (EEE)
is supported by looking at the MMD registers 3.20 and 7.60/61
and it programs the MMD register 3.0 setting the ``Clock stop enable''
bit if required.
\index{phy\_get\_eee\_err (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_get_eee_err}\pysiglinewithargsret{int \bfcode{phy\_get\_eee\_err}}{struct phy\_device *\emph{phydev}}{}
report the EEE wake error count

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}

\textbf{Description}

it is to report the number of time where the PHY
failed to complete its normal wake sequence.
\index{phy\_ethtool\_get\_eee (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_ethtool_get_eee}\pysiglinewithargsret{int \bfcode{phy\_ethtool\_get\_eee}}{struct phy\_device *\emph{phydev}, struct ethtool\_eee *\emph{data}}{}
get EEE supported and status

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\item[{\code{struct ethtool\_eee * data}}] \leavevmode
ethtool\_eee data

\end{description}

\textbf{Description}

it reportes the Supported/Advertisement/LP Advertisement
capabilities.
\index{phy\_ethtool\_set\_eee (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_ethtool_set_eee}\pysiglinewithargsret{int \bfcode{phy\_ethtool\_set\_eee}}{struct phy\_device *\emph{phydev}, struct ethtool\_eee *\emph{data}}{}
set EEE supported and status

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\item[{\code{struct ethtool\_eee * data}}] \leavevmode
ethtool\_eee data

\end{description}

\textbf{Description}

it is to program the Advertisement EEE register.
\index{phy\_clear\_interrupt (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_clear_interrupt}\pysiglinewithargsret{int \bfcode{phy\_clear\_interrupt}}{struct phy\_device *\emph{phydev}}{}
Ack the phy device's interrupt

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
the phy\_device struct

\end{description}

\textbf{Description}

If the \textbf{phydev} driver has an ack\_interrupt function, call it to
ack and clear the phy device's interrupt.

Returns 0 on success or \textless{} 0 on error.
\index{phy\_config\_interrupt (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_config_interrupt}\pysiglinewithargsret{int \bfcode{phy\_config\_interrupt}}{struct phy\_device *\emph{phydev}, u32\emph{interrupts}}{}
configure the PHY device for the requested interrupts

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
the phy\_device struct

\item[{\code{u32 interrupts}}] \leavevmode
interrupt flags to configure for this \textbf{phydev}

\end{description}

\textbf{Description}

Returns 0 on success or \textless{} 0 on error.
\index{phy\_find\_valid (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_find_valid}\pysiglinewithargsret{const struct phy\_setting * \bfcode{phy\_find\_valid}}{int\emph{speed}, int\emph{duplex}, u32\emph{supported}}{}
find a PHY setting that matches the requested parameters

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int speed}}] \leavevmode
desired speed

\item[{\code{int duplex}}] \leavevmode
desired duplex

\item[{\code{u32 supported}}] \leavevmode
mask of supported link modes

\end{description}

\textbf{Description}

Locate a supported phy setting that is, in priority order:
- an exact match for the specified speed and duplex mode
- a match for the specified speed, or slower speed
- the slowest supported speed
Returns the matched phy\_setting entry, or \code{NULL} if no supported phy
settings were found.
\index{phy\_supported\_speeds (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_supported_speeds}\pysiglinewithargsret{unsigned int \bfcode{phy\_supported\_speeds}}{struct phy\_device *\emph{phy}, unsigned int *\emph{speeds}, unsigned int\emph{size}}{}
return all speeds currently supported by a phy device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phy}}] \leavevmode
The phy device to return supported speeds of.

\item[{\code{unsigned int * speeds}}] \leavevmode
buffer to store supported speeds in.

\item[{\code{unsigned int size}}] \leavevmode
size of speeds buffer.

\end{description}

\textbf{Description}

Returns the number of supported speeds, and fills the speeds
buffer with the supported speeds. If speeds buffer is too small to contain
all currently supported speeds, will return as many speeds as can fit.
\index{phy\_check\_valid (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_check_valid}\pysiglinewithargsret{bool \bfcode{phy\_check\_valid}}{int\emph{speed}, int\emph{duplex}, u32\emph{features}}{}
check if there is a valid PHY setting which matches speed, duplex, and feature mask

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int speed}}] \leavevmode
speed to match

\item[{\code{int duplex}}] \leavevmode
duplex to match

\item[{\code{u32 features}}] \leavevmode
A mask of the valid settings

\end{description}

\textbf{Description}

Returns true if there is a valid setting, false otherwise.
\index{phy\_sanitize\_settings (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_sanitize_settings}\pysiglinewithargsret{void \bfcode{phy\_sanitize\_settings}}{struct phy\_device *\emph{phydev}}{}
make sure the PHY is set to supported speed and duplex

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
the target phy\_device struct

\end{description}

\textbf{Description}
\begin{description}
\item[{Make sure the PHY is set to supported speeds and}] \leavevmode
duplexes.  Drop down by one in this order:  1000/FULL,
1000/HALF, 100/FULL, 100/HALF, 10/FULL, 10/HALF.

\end{description}
\index{phy\_start\_aneg\_priv (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_start_aneg_priv}\pysiglinewithargsret{int \bfcode{phy\_start\_aneg\_priv}}{struct phy\_device *\emph{phydev}, bool\emph{sync}}{}
start auto-negotiation for this PHY device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
the phy\_device struct

\item[{\code{bool sync}}] \leavevmode
indicate whether we should wait for the workqueue cancelation

\end{description}

\textbf{Description}
\begin{description}
\item[{Sanitizes the settings (if we're not autonegotiating}] \leavevmode
them), and then calls the driver's config\_aneg function.
If the PHYCONTROL Layer is operating, we change the state to
reflect the beginning of Auto-negotiation or forcing.

\end{description}
\index{phy\_trigger\_machine (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_trigger_machine}\pysiglinewithargsret{void \bfcode{phy\_trigger\_machine}}{struct phy\_device *\emph{phydev}, bool\emph{sync}}{}
trigger the state machine to run

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
the phy\_device struct

\item[{\code{bool sync}}] \leavevmode
indicate whether we should wait for the workqueue cancelation

\end{description}

\textbf{Description}
\begin{description}
\item[{There has been a change in state which requires that the}] \leavevmode
state machine runs.

\end{description}
\index{phy\_stop\_machine (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_stop_machine}\pysiglinewithargsret{void \bfcode{phy\_stop\_machine}}{struct phy\_device *\emph{phydev}}{}
stop the PHY state machine tracking

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}

\textbf{Description}
\begin{description}
\item[{Stops the state machine delayed workqueue, sets the}] \leavevmode
state to UP (unless it wasn't up yet). This function must be
called BEFORE phy\_detach.

\end{description}
\index{phy\_error (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_error}\pysiglinewithargsret{void \bfcode{phy\_error}}{struct phy\_device *\emph{phydev}}{}
enter HALTED state for this PHY device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}

\textbf{Description}

Moves the PHY to the HALTED state in response to a read
or write error, and tells the controller the link is down.
Must not be called from interrupt context, or while the
phydev-\textgreater{}lock is held.
\index{phy\_interrupt (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_interrupt}\pysiglinewithargsret{irqreturn\_t \bfcode{phy\_interrupt}}{int\emph{irq}, void *\emph{phy\_dat}}{}
PHY interrupt handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int irq}}] \leavevmode
interrupt line

\item[{\code{void * phy\_dat}}] \leavevmode
phy\_device pointer

\end{description}

\textbf{Description}

When a PHY interrupt occurs, the handler disables
interrupts, and uses phy\_change to handle the interrupt.
\index{phy\_enable\_interrupts (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_enable_interrupts}\pysiglinewithargsret{int \bfcode{phy\_enable\_interrupts}}{struct phy\_device *\emph{phydev}}{}
Enable the interrupts from the PHY side

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}
\index{phy\_disable\_interrupts (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_disable_interrupts}\pysiglinewithargsret{int \bfcode{phy\_disable\_interrupts}}{struct phy\_device *\emph{phydev}}{}
Disable the PHY interrupts from the PHY side

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}
\index{phy\_change (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_change}\pysiglinewithargsret{void \bfcode{phy\_change}}{struct phy\_device *\emph{phydev}}{}
Called by the phy\_interrupt to handle PHY changes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
phy\_device struct that interrupted

\end{description}
\index{phy\_change\_work (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_change_work}\pysiglinewithargsret{void \bfcode{phy\_change\_work}}{struct work\_struct *\emph{work}}{}
Scheduled by the phy\_mac\_interrupt to handle PHY changes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct work\_struct * work}}] \leavevmode
work\_struct that describes the work to be done

\end{description}
\index{phy\_state\_machine (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_state_machine}\pysiglinewithargsret{void \bfcode{phy\_state\_machine}}{struct work\_struct *\emph{work}}{}
Handle the state machine

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct work\_struct * work}}] \leavevmode
work\_struct that describes the work to be done

\end{description}
\index{phy\_register\_fixup (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_register_fixup}\pysiglinewithargsret{int \bfcode{phy\_register\_fixup}}{const char *\emph{bus\_id}, u32\emph{phy\_uid}, u32\emph{phy\_uid\_mask}, int (*run) (struct phy\_device\emph{*}}{}
creates a new phy\_fixup and adds it to the list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * bus\_id}}] \leavevmode
A string which matches phydev-\textgreater{}mdio.dev.bus\_id (or PHY\_ANY\_ID)

\item[{\code{u32 phy\_uid}}] \leavevmode
Used to match against phydev-\textgreater{}phy\_id (the UID of the PHY)
It can also be PHY\_ANY\_UID

\item[{\code{u32 phy\_uid\_mask}}] \leavevmode
Applied to phydev-\textgreater{}phy\_id and fixup-\textgreater{}phy\_uid before
comparison

\item[{\code{int (*)(struct phy\_device *) run}}] \leavevmode
The actual code to be run when a matching PHY is found

\end{description}
\index{phy\_unregister\_fixup (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_unregister_fixup}\pysiglinewithargsret{int \bfcode{phy\_unregister\_fixup}}{const char *\emph{bus\_id}, u32\emph{phy\_uid}, u32\emph{phy\_uid\_mask}}{}
remove a phy\_fixup from the list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const char * bus\_id}}] \leavevmode
A string matches fixup-\textgreater{}bus\_id (or PHY\_ANY\_ID) in phy\_fixup\_list

\item[{\code{u32 phy\_uid}}] \leavevmode
A phy id matches fixup-\textgreater{}phy\_id (or PHY\_ANY\_UID) in phy\_fixup\_list

\item[{\code{u32 phy\_uid\_mask}}] \leavevmode
Applied to phy\_uid and fixup-\textgreater{}phy\_uid before comparison

\end{description}
\index{get\_phy\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.get_phy_device}\pysiglinewithargsret{struct phy\_device * \bfcode{get\_phy\_device}}{struct mii\_bus *\emph{bus}, int\emph{addr}, bool\emph{is\_c45}}{}
reads the specified PHY device and returns its \textbf{phy\_device} struct

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mii\_bus * bus}}] \leavevmode
the target MII bus

\item[{\code{int addr}}] \leavevmode
PHY address on the MII bus

\item[{\code{bool is\_c45}}] \leavevmode
If true the PHY uses the 802.3 clause 45 protocol

\end{description}

\textbf{Description}
\begin{description}
\item[{Reads the ID registers of the PHY at \textbf{addr} on the}] \leavevmode
\textbf{bus}, then allocates and returns the phy\_device to represent it.

\end{description}
\index{phy\_device\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_device_register}\pysiglinewithargsret{int \bfcode{phy\_device\_register}}{struct phy\_device *\emph{phydev}}{}
Register the phy device on the MDIO bus

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
phy\_device structure to be added to the MDIO bus

\end{description}
\index{phy\_device\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_device_remove}\pysiglinewithargsret{void \bfcode{phy\_device\_remove}}{struct phy\_device *\emph{phydev}}{}
Remove a previously registered phy device from the MDIO bus

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
phy\_device structure to remove

\end{description}

\textbf{Description}

This doesn't free the phy\_device itself, it merely reverses the effects
of {\hyperref[networking/kapi:c.phy_device_register]{\emph{\code{phy\_device\_register()}}}}. Use \code{phy\_device\_free()} to free the device
after calling this function.
\index{phy\_find\_first (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_find_first}\pysiglinewithargsret{struct phy\_device * \bfcode{phy\_find\_first}}{struct mii\_bus *\emph{bus}}{}
finds the first PHY device on the bus

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mii\_bus * bus}}] \leavevmode
the target MII bus

\end{description}
\index{phy\_connect\_direct (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_connect_direct}\pysiglinewithargsret{int \bfcode{phy\_connect\_direct}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct phy\_device *\emph{phydev}, void (*handler) (struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}}\emph{*}, phy\_interface\_t\emph{interface}}{}
connect an ethernet device to a specific phy\_device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
the network device to connect

\item[{\code{struct phy\_device * phydev}}] \leavevmode
the pointer to the phy device

\item[{\code{void (*)(struct net\_device *) handler}}] \leavevmode
callback function for state change notifications

\item[{\code{phy\_interface\_t interface}}] \leavevmode
PHY device's interface

\end{description}
\index{phy\_connect (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_connect}\pysiglinewithargsret{struct phy\_device * \bfcode{phy\_connect}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, const char *\emph{bus\_id}, void (*handler) (struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}}\emph{*}, phy\_interface\_t\emph{interface}}{}
connect an ethernet device to a PHY device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
the network device to connect

\item[{\code{const char * bus\_id}}] \leavevmode
the id string of the PHY device to connect

\item[{\code{void (*)(struct net\_device *) handler}}] \leavevmode
callback function for state change notifications

\item[{\code{phy\_interface\_t interface}}] \leavevmode
PHY device's interface

\end{description}

\textbf{Description}
\begin{description}
\item[{Convenience function for connecting ethernet}] \leavevmode
devices to PHY devices.  The default behavior is for
the PHY infrastructure to handle everything, and only notify
the connected driver when the link status changes.  If you
don't want, or can't use the provided functionality, you may
choose to call only the subset of functions which provide
the desired functionality.

\end{description}
\index{phy\_disconnect (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_disconnect}\pysiglinewithargsret{void \bfcode{phy\_disconnect}}{struct phy\_device *\emph{phydev}}{}
disable interrupts, stop state machine, and detach a PHY device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}
\index{phy\_attach\_direct (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_attach_direct}\pysiglinewithargsret{int \bfcode{phy\_attach\_direct}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct phy\_device *\emph{phydev}, u32\emph{flags}, phy\_interface\_t\emph{interface}}{}
attach a network device to a given PHY device pointer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device to attach

\item[{\code{struct phy\_device * phydev}}] \leavevmode
Pointer to phy\_device to attach

\item[{\code{u32 flags}}] \leavevmode
PHY device's dev\_flags

\item[{\code{phy\_interface\_t interface}}] \leavevmode
PHY device's interface

\end{description}

\textbf{Description}
\begin{description}
\item[{Called by drivers to attach to a particular PHY}] \leavevmode
device. The phy\_device is found, and properly hooked up
to the phy\_driver.  If no driver is attached, then a
generic driver is used.  The phy\_device is given a ptr to
the attaching device, and given a callback for link status
change.  The phy\_device is returned to the attaching driver.
This function takes a reference on the phy device.

\end{description}
\index{phy\_attach (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_attach}\pysiglinewithargsret{struct phy\_device * \bfcode{phy\_attach}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, const char *\emph{bus\_id}, phy\_interface\_t\emph{interface}}{}
attach a network device to a particular PHY device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
network device to attach

\item[{\code{const char * bus\_id}}] \leavevmode
Bus ID of PHY device to attach

\item[{\code{phy\_interface\_t interface}}] \leavevmode
PHY device's interface

\end{description}

\textbf{Description}
\begin{description}
\item[{Same as {\hyperref[networking/kapi:c.phy_attach_direct]{\emph{\code{phy\_attach\_direct()}}}} except that a PHY bus\_id}] \leavevmode
string is passed instead of a pointer to a struct phy\_device.

\end{description}
\index{phy\_detach (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_detach}\pysiglinewithargsret{void \bfcode{phy\_detach}}{struct phy\_device *\emph{phydev}}{}
detach a PHY device from its network device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}

\textbf{Description}

This detaches the phy device from its network device and the phy
driver, and drops the reference count taken in {\hyperref[networking/kapi:c.phy_attach_direct]{\emph{\code{phy\_attach\_direct()}}}}.
\index{phy\_reset\_after\_clk\_enable (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_reset_after_clk_enable}\pysiglinewithargsret{int \bfcode{phy\_reset\_after\_clk\_enable}}{struct phy\_device *\emph{phydev}}{}
perform a PHY reset if needed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}

\textbf{Description}
\begin{description}
\item[{Some PHYs are known to need a reset after their refclk was}] \leavevmode
enabled. This function evaluates the flags and perform the reset if it's
needed. Returns \textless{} 0 on error, 0 if the phy wasn't reset and 1 if the phy
was reset.

\end{description}
\index{genphy\_setup\_forced (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.genphy_setup_forced}\pysiglinewithargsret{int \bfcode{genphy\_setup\_forced}}{struct phy\_device *\emph{phydev}}{}
configures/forces speed/duplex from \textbf{phydev}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}

\textbf{Description}
\begin{description}
\item[{Configures MII\_BMCR to force speed/duplex}] \leavevmode
to the values in phydev. Assumes that the values are valid.
Please see {\hyperref[networking/kapi:c.phy_sanitize_settings]{\emph{\code{phy\_sanitize\_settings()}}}}.

\end{description}
\index{genphy\_restart\_aneg (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.genphy_restart_aneg}\pysiglinewithargsret{int \bfcode{genphy\_restart\_aneg}}{struct phy\_device *\emph{phydev}}{}
Enable and Restart Autonegotiation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}
\index{genphy\_config\_aneg (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.genphy_config_aneg}\pysiglinewithargsret{int \bfcode{genphy\_config\_aneg}}{struct phy\_device *\emph{phydev}}{}
restart auto-negotiation or write BMCR

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}

\textbf{Description}
\begin{description}
\item[{If auto-negotiation is enabled, we configure the}] \leavevmode
advertising, and then restart auto-negotiation.  If it is not
enabled, then we write the BMCR.

\end{description}
\index{genphy\_aneg\_done (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.genphy_aneg_done}\pysiglinewithargsret{int \bfcode{genphy\_aneg\_done}}{struct phy\_device *\emph{phydev}}{}
return auto-negotiation status

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}

\textbf{Description}
\begin{description}
\item[{Reads the status register and returns 0 either if}] \leavevmode
auto-negotiation is incomplete, or if there was an error.
Returns BMSR\_ANEGCOMPLETE if auto-negotiation is done.

\end{description}
\index{genphy\_update\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.genphy_update_link}\pysiglinewithargsret{int \bfcode{genphy\_update\_link}}{struct phy\_device *\emph{phydev}}{}
update link status in \textbf{phydev}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}

\textbf{Description}
\begin{description}
\item[{Update the value in phydev-\textgreater{}link to reflect the}] \leavevmode
current link value.  In order to do this, we need to read
the status register twice, keeping the second value.

\end{description}
\index{genphy\_read\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.genphy_read_status}\pysiglinewithargsret{int \bfcode{genphy\_read\_status}}{struct phy\_device *\emph{phydev}}{}
check the link status and update current link state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}

\textbf{Description}
\begin{description}
\item[{Check the link, then figure out the current state}] \leavevmode
by comparing what we advertise with what the link partner
advertises.  Start by checking the gigabit possibilities,
then move on to 10/100.

\end{description}
\index{genphy\_soft\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.genphy_soft_reset}\pysiglinewithargsret{int \bfcode{genphy\_soft\_reset}}{struct phy\_device *\emph{phydev}}{}
software reset the PHY via BMCR\_RESET bit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}

\textbf{Description}

Perform a software PHY reset using the standard
BMCR\_RESET bit and poll for the reset bit to be cleared.

\textbf{Return}

0 on success, \textless{} 0 on failure
\index{phy\_driver\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_driver_register}\pysiglinewithargsret{int \bfcode{phy\_driver\_register}}{struct phy\_driver *\emph{new\_driver}, struct module *\emph{owner}}{}
register a phy\_driver with the PHY layer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_driver * new\_driver}}] \leavevmode
new phy\_driver to register

\item[{\code{struct module * owner}}] \leavevmode
module owning this PHY

\end{description}
\index{get\_phy\_c45\_ids (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.get_phy_c45_ids}\pysiglinewithargsret{int \bfcode{get\_phy\_c45\_ids}}{struct mii\_bus *\emph{bus}, int\emph{addr}, u32 *\emph{phy\_id}, struct phy\_c45\_device\_ids *\emph{c45\_ids}}{}
reads the specified addr for its 802.3-c45 IDs.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mii\_bus * bus}}] \leavevmode
the target MII bus

\item[{\code{int addr}}] \leavevmode
PHY address on the MII bus

\item[{\code{u32 * phy\_id}}] \leavevmode
where to store the ID retrieved.

\item[{\code{struct phy\_c45\_device\_ids * c45\_ids}}] \leavevmode
where to store the c45 ID information.

\end{description}

\textbf{Description}
\begin{quote}

If the PHY devices-in-package appears to be valid, it and the
corresponding identifiers are stored in \textbf{c45\_ids}, zero is stored
in \textbf{phy\_id}.  Otherwise 0xffffffff is stored in \textbf{phy\_id}.  Returns
zero on success.
\end{quote}
\index{get\_phy\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.get_phy_id}\pysiglinewithargsret{int \bfcode{get\_phy\_id}}{struct mii\_bus *\emph{bus}, int\emph{addr}, u32 *\emph{phy\_id}, bool\emph{is\_c45}, struct phy\_c45\_device\_ids *\emph{c45\_ids}}{}
reads the specified addr for its ID.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mii\_bus * bus}}] \leavevmode
the target MII bus

\item[{\code{int addr}}] \leavevmode
PHY address on the MII bus

\item[{\code{u32 * phy\_id}}] \leavevmode
where to store the ID retrieved.

\item[{\code{bool is\_c45}}] \leavevmode
If true the PHY uses the 802.3 clause 45 protocol

\item[{\code{struct phy\_c45\_device\_ids * c45\_ids}}] \leavevmode
where to store the c45 ID information.

\end{description}

\textbf{Description}
\begin{description}
\item[{In the case of a 802.3-c22 PHY, reads the ID registers}] \leavevmode
of the PHY at \textbf{addr} on the \textbf{bus}, stores it in \textbf{phy\_id} and returns
zero on success.

In the case of a 802.3-c45 PHY, {\hyperref[networking/kapi:c.get_phy_c45_ids]{\emph{\code{get\_phy\_c45\_ids()}}}} is invoked, and
its return value is in turn returned.

\end{description}
\index{phy\_prepare\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_prepare_link}\pysiglinewithargsret{void \bfcode{phy\_prepare\_link}}{struct phy\_device *\emph{phydev}, void (*handler) (struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}}\emph{*}}{}
prepares the PHY layer to monitor link status

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\item[{\code{void (*)(struct net\_device *) handler}}] \leavevmode
callback function for link status change notifications

\end{description}

\textbf{Description}
\begin{description}
\item[{Tells the PHY infrastructure to handle the}] \leavevmode
gory details on monitoring link status (whether through
polling or an interrupt), and to call back to the
connected device driver when the link status changes.
If you want to monitor your own link state, don't call
this function.

\end{description}
\index{phy\_poll\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_poll_reset}\pysiglinewithargsret{int \bfcode{phy\_poll\_reset}}{struct phy\_device *\emph{phydev}}{}
Safely wait until a PHY reset has properly completed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
The PHY device to poll

\end{description}

\textbf{Description}
\begin{description}
\item[{According to IEEE 802.3, Section 2, Subsection 22.2.4.1.1, as}] \leavevmode
published in 2008, a PHY reset may take up to 0.5 seconds.  The MII BMCR
register must be polled until the BMCR\_RESET bit clears.

Furthermore, any attempts to write to PHY registers may have no effect
or even generate MDIO bus errors until this is complete.

Some PHYs (such as the Marvell 88E1111) don't entirely conform to the
standard and do not fully reset after the BMCR\_RESET bit is set, and may
even \emph{REQUIRE} a soft-reset to properly restart autonegotiation.  In an
effort to support such broken PHYs, this function is separate from the
standard \code{phy\_init\_hw()} which will zero all the other bits in the BMCR
and reapply all driver-specific and board-specific fixups.

\end{description}
\index{genphy\_config\_advert (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.genphy_config_advert}\pysiglinewithargsret{int \bfcode{genphy\_config\_advert}}{struct phy\_device *\emph{phydev}}{}
sanitize and advertise auto-negotiation parameters

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}

\textbf{Description}
\begin{description}
\item[{Writes MII\_ADVERTISE with the appropriate values,}] \leavevmode
after sanitizing the values to make sure we only advertise
what is supported.  Returns \textless{} 0 on error, 0 if the PHY's advertisement
hasn't changed, and \textgreater{} 0 if it has changed.

\end{description}
\index{genphy\_config\_eee\_advert (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.genphy_config_eee_advert}\pysiglinewithargsret{int \bfcode{genphy\_config\_eee\_advert}}{struct phy\_device *\emph{phydev}}{}
disable unwanted eee mode advertisement

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phy\_device * phydev}}] \leavevmode
target phy\_device struct

\end{description}

\textbf{Description}
\begin{description}
\item[{Writes MDIO\_AN\_EEE\_ADV after disabling unsupported energy}] \leavevmode
efficent ethernet modes. Returns 0 if the PHY's advertisement hasn't
changed, and 1 if it has changed.

\end{description}
\index{phy\_probe (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phy_probe}\pysiglinewithargsret{int \bfcode{phy\_probe}}{struct device *\emph{dev}}{}
probe and init a PHY device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device to probe and init

\end{description}

\textbf{Description}
\begin{description}
\item[{Take care of setting up the phy\_device structure,}] \leavevmode
set the state to READY (the driver's init function should
set it to STARTING if needed).

\end{description}
\index{mdiobus\_alloc\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.mdiobus_alloc_size}\pysiglinewithargsret{struct mii\_bus * \bfcode{mdiobus\_alloc\_size}}{size\_t\emph{size}}{}
allocate a mii\_bus structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{size\_t size}}] \leavevmode
extra amount of memory to allocate for private storage.
If non-zero, then bus-\textgreater{}priv is points to that memory.

\end{description}

\textbf{Description}

called by a bus driver to allocate an mii\_bus
structure to fill in.
\index{devm\_mdiobus\_alloc\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.devm_mdiobus_alloc_size}\pysiglinewithargsret{struct mii\_bus * \bfcode{devm\_mdiobus\_alloc\_size}}{struct device *\emph{dev}, int\emph{sizeof\_priv}}{}
Resource-managed {\hyperref[networking/kapi:c.mdiobus_alloc_size]{\emph{\code{mdiobus\_alloc\_size()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device to allocate mii\_bus for

\item[{\code{int sizeof\_priv}}] \leavevmode
Space to allocate for private structure.

\end{description}

\textbf{Description}

Managed mdiobus\_alloc\_size. mii\_bus allocated with this function is
automatically freed on driver detach.

If an mii\_bus allocated with this function needs to be freed separately,
{\hyperref[networking/kapi:c.devm_mdiobus_free]{\emph{\code{devm\_mdiobus\_free()}}}} must be used.

\textbf{Return}

Pointer to allocated mii\_bus on success, NULL on failure.
\index{devm\_mdiobus\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.devm_mdiobus_free}\pysiglinewithargsret{void \bfcode{devm\_mdiobus\_free}}{struct device *\emph{dev}, struct mii\_bus *\emph{bus}}{}
Resource-managed {\hyperref[networking/kapi:c.mdiobus_free]{\emph{\code{mdiobus\_free()}}}}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device this mii\_bus belongs to

\item[{\code{struct mii\_bus * bus}}] \leavevmode
the mii\_bus associated with the device

\end{description}

\textbf{Description}

Free mii\_bus allocated with {\hyperref[networking/kapi:c.devm_mdiobus_alloc_size]{\emph{\code{devm\_mdiobus\_alloc\_size()}}}}.
\index{of\_mdio\_find\_bus (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.of_mdio_find_bus}\pysiglinewithargsret{struct mii\_bus * \bfcode{of\_mdio\_find\_bus}}{struct device\_node *\emph{mdio\_bus\_np}}{}
Given an mii\_bus node, find the mii\_bus.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device\_node * mdio\_bus\_np}}] \leavevmode
Pointer to the mii\_bus.

\end{description}

\textbf{Description}

Returns a reference to the mii\_bus, or NULL if none found.  The
embedded struct device will have its reference count incremented,
and this must be put once the bus is finished with.

Because the association of a device\_node and mii\_bus is made via
\code{of\_mdiobus\_register()}, the mii\_bus cannot be found before it is
registered with \code{of\_mdiobus\_register()}.
\index{\_\_mdiobus\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__mdiobus_register}\pysiglinewithargsret{int \bfcode{\_\_mdiobus\_register}}{struct mii\_bus *\emph{bus}, struct module *\emph{owner}}{}
bring up all the PHYs on a given bus and attach them to bus

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mii\_bus * bus}}] \leavevmode
target mii\_bus

\item[{\code{struct module * owner}}] \leavevmode
module containing bus accessor functions

\end{description}

\textbf{Description}
\begin{description}
\item[{Called by a bus driver to bring up all the PHYs}] \leavevmode
on a given bus, and attach them to the bus. Drivers should use
\code{mdiobus\_register()} rather than {\hyperref[networking/kapi:c.__mdiobus_register]{\emph{\code{\_\_mdiobus\_register()}}}} unless they
need to pass a specific owner module. MDIO devices which are not
PHYs will not be brought up by this function. They are expected to
to be explicitly listed in DT and instantiated by \code{of\_mdiobus\_register()}.

\end{description}

Returns 0 on success or \textless{} 0 on error.
\index{mdiobus\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.mdiobus_free}\pysiglinewithargsret{void \bfcode{mdiobus\_free}}{struct mii\_bus *\emph{bus}}{}
free a struct mii\_bus

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mii\_bus * bus}}] \leavevmode
mii\_bus to free

\end{description}

\textbf{Description}

This function releases the reference to the underlying device
object in the mii\_bus.  If this is the last reference, the mii\_bus
will be freed.
\index{mdiobus\_scan (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.mdiobus_scan}\pysiglinewithargsret{struct phy\_device * \bfcode{mdiobus\_scan}}{struct mii\_bus *\emph{bus}, int\emph{addr}}{}
scan a bus for MDIO devices.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mii\_bus * bus}}] \leavevmode
mii\_bus to scan

\item[{\code{int addr}}] \leavevmode
address on bus to scan

\end{description}

\textbf{Description}

This function scans the MDIO bus, looking for devices which can be
identified using a vendor/product ID in registers 2 and 3. Not all
MDIO devices have such registers, but PHY devices typically
do. Hence this function assumes anything found is a PHY, or can be
treated as a PHY. Other MDIO devices, such as switches, will
probably not be found during the scan.
\index{\_\_mdiobus\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__mdiobus_read}\pysiglinewithargsret{int \bfcode{\_\_mdiobus\_read}}{struct mii\_bus *\emph{bus}, int\emph{addr}, u32\emph{regnum}}{}
Unlocked version of the mdiobus\_read function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mii\_bus * bus}}] \leavevmode
the mii\_bus struct

\item[{\code{int addr}}] \leavevmode
the phy address

\item[{\code{u32 regnum}}] \leavevmode
register number to read

\end{description}

\textbf{Description}

Read a MDIO bus register. Caller must hold the mdio bus lock.

\textbf{NOTE}

MUST NOT be called from interrupt context.
\index{\_\_mdiobus\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.__mdiobus_write}\pysiglinewithargsret{int \bfcode{\_\_mdiobus\_write}}{struct mii\_bus *\emph{bus}, int\emph{addr}, u32\emph{regnum}, u16\emph{val}}{}
Unlocked version of the mdiobus\_write function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mii\_bus * bus}}] \leavevmode
the mii\_bus struct

\item[{\code{int addr}}] \leavevmode
the phy address

\item[{\code{u32 regnum}}] \leavevmode
register number to write

\item[{\code{u16 val}}] \leavevmode
value to write to \textbf{regnum}

\end{description}

\textbf{Description}

Write a MDIO bus register. Caller must hold the mdio bus lock.

\textbf{NOTE}

MUST NOT be called from interrupt context.
\index{mdiobus\_read\_nested (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.mdiobus_read_nested}\pysiglinewithargsret{int \bfcode{mdiobus\_read\_nested}}{struct mii\_bus *\emph{bus}, int\emph{addr}, u32\emph{regnum}}{}
Nested version of the mdiobus\_read function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mii\_bus * bus}}] \leavevmode
the mii\_bus struct

\item[{\code{int addr}}] \leavevmode
the phy address

\item[{\code{u32 regnum}}] \leavevmode
register number to read

\end{description}

\textbf{Description}

In case of nested MDIO bus access avoid lockdep false positives by
using \code{mutex\_lock\_nested()}.

\textbf{NOTE}

MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.
\index{mdiobus\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.mdiobus_read}\pysiglinewithargsret{int \bfcode{mdiobus\_read}}{struct mii\_bus *\emph{bus}, int\emph{addr}, u32\emph{regnum}}{}
Convenience function for reading a given MII mgmt register

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mii\_bus * bus}}] \leavevmode
the mii\_bus struct

\item[{\code{int addr}}] \leavevmode
the phy address

\item[{\code{u32 regnum}}] \leavevmode
register number to read

\end{description}

\textbf{NOTE}

MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.
\index{mdiobus\_write\_nested (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.mdiobus_write_nested}\pysiglinewithargsret{int \bfcode{mdiobus\_write\_nested}}{struct mii\_bus *\emph{bus}, int\emph{addr}, u32\emph{regnum}, u16\emph{val}}{}
Nested version of the mdiobus\_write function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mii\_bus * bus}}] \leavevmode
the mii\_bus struct

\item[{\code{int addr}}] \leavevmode
the phy address

\item[{\code{u32 regnum}}] \leavevmode
register number to write

\item[{\code{u16 val}}] \leavevmode
value to write to \textbf{regnum}

\end{description}

\textbf{Description}

In case of nested MDIO bus access avoid lockdep false positives by
using \code{mutex\_lock\_nested()}.

\textbf{NOTE}

MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.
\index{mdiobus\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.mdiobus_write}\pysiglinewithargsret{int \bfcode{mdiobus\_write}}{struct mii\_bus *\emph{bus}, int\emph{addr}, u32\emph{regnum}, u16\emph{val}}{}
Convenience function for writing a given MII mgmt register

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mii\_bus * bus}}] \leavevmode
the mii\_bus struct

\item[{\code{int addr}}] \leavevmode
the phy address

\item[{\code{u32 regnum}}] \leavevmode
register number to write

\item[{\code{u16 val}}] \leavevmode
value to write to \textbf{regnum}

\end{description}

\textbf{NOTE}

MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.
\index{mdiobus\_release (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.mdiobus_release}\pysiglinewithargsret{void \bfcode{mdiobus\_release}}{struct device *\emph{d}}{}
mii\_bus device release callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * d}}] \leavevmode
the target struct device that contains the mii\_bus

\end{description}

\textbf{Description}

called when the last reference to an mii\_bus is
dropped, to free the underlying memory.
\index{mdiobus\_create\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.mdiobus_create_device}\pysiglinewithargsret{int \bfcode{mdiobus\_create\_device}}{struct mii\_bus *\emph{bus}, struct mdio\_board\_info *\emph{bi}}{}
create a full MDIO device given a mdio\_board\_info structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mii\_bus * bus}}] \leavevmode
MDIO bus to create the devices on

\item[{\code{struct mdio\_board\_info * bi}}] \leavevmode
mdio\_board\_info structure describing the devices

\end{description}

\textbf{Description}

Returns 0 on success or \textless{} 0 on error.
\index{mdio\_bus\_match (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.mdio_bus_match}\pysiglinewithargsret{int \bfcode{mdio\_bus\_match}}{struct device *\emph{dev}, struct device\_driver *\emph{drv}}{}
determine if given MDIO driver supports the given MDIO device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
target MDIO device

\item[{\code{struct device\_driver * drv}}] \leavevmode
given MDIO driver

\end{description}

\textbf{Description}
\begin{description}
\item[{Given a MDIO device, and a MDIO driver, return 1 if}] \leavevmode
the driver supports the device.  Otherwise, return 0. This may
require calling the devices own match function, since different classes
of MDIO devices have different match criteria.

\end{description}


\subsection{PHYLINK}
\label{networking/kapi:phylink}\begin{quote}

PHYLINK interfaces traditional network drivers with PHYLIB, fixed-links,
and SFF modules (eg, hot-pluggable SFP) that may contain PHYs.  PHYLINK
provides management of the link state and link modes.
\end{quote}
\index{phylink\_link\_state (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_link_state}\pysigline{struct \bfcode{phylink\_link\_state}}
link state structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct phylink\PYGZus{}link\PYGZus{}state \PYGZob{}
  \PYGZus{}\PYGZus{}ETHTOOL\PYGZus{}DECLARE\PYGZus{}LINK\PYGZus{}MODE\PYGZus{}MASK(advertising);
  \PYGZus{}\PYGZus{}ETHTOOL\PYGZus{}DECLARE\PYGZus{}LINK\PYGZus{}MODE\PYGZus{}MASK(lp\PYGZus{}advertising);
  phy\PYGZus{}interface\PYGZus{}t interface;
  int speed;
  int duplex;
  int pause;
  unsigned int link:1;
  unsigned int an\PYGZus{}enabled:1;
  unsigned int an\PYGZus{}complete:1;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{interface}}] \leavevmode
link \code{typedef phy\_interface\_t} mode

\item[{\code{speed}}] \leavevmode
link speed, one of the SPEED\_* constants.

\item[{\code{duplex}}] \leavevmode
link duplex mode, one of DUPLEX\_* constants.

\item[{\code{pause}}] \leavevmode
link pause state, described by MLO\_PAUSE\_* constants.

\item[{\code{link}}] \leavevmode
true if the link is up.

\item[{\code{an\_enabled}}] \leavevmode
true if autonegotiation is enabled/desired.

\item[{\code{an\_complete}}] \leavevmode
true if autonegotiation has completed.

\end{description}
\index{phylink\_mac\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_mac_ops}\pysigline{struct \bfcode{phylink\_mac\_ops}}
MAC operations structure.

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct phylink\PYGZus{}mac\PYGZus{}ops \PYGZob{}
  void (*validate)(struct net\PYGZus{}device *ndev, unsigned long *supported, struct phylink\PYGZus{}link\PYGZus{}state *state);
  int (*mac\PYGZus{}link\PYGZus{}state)(struct net\PYGZus{}device *ndev, struct phylink\PYGZus{}link\PYGZus{}state *state);
  void (*mac\PYGZus{}config)(struct net\PYGZus{}device *ndev, unsigned int mode, const struct phylink\PYGZus{}link\PYGZus{}state *state);
  void (*mac\PYGZus{}an\PYGZus{}restart)(struct net\PYGZus{}device *ndev);
  void (*mac\PYGZus{}link\PYGZus{}down)(struct net\PYGZus{}device *ndev, unsigned int mode);
  void (*mac\PYGZus{}link\PYGZus{}up)(struct net\PYGZus{}device *ndev, unsigned int mode, struct phy\PYGZus{}device *phy);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{validate}}] \leavevmode
Validate and update the link configuration.

\item[{\code{mac\_link\_state}}] \leavevmode
Read the current link state from the hardware.

\item[{\code{mac\_config}}] \leavevmode
configure the MAC for the selected mode and state.

\item[{\code{mac\_an\_restart}}] \leavevmode
restart 802.3z BaseX autonegotiation.

\item[{\code{mac\_link\_down}}] \leavevmode
take the link down.

\item[{\code{mac\_link\_up}}] \leavevmode
allow the link to come up.

\end{description}

\textbf{Description}

The individual methods are described more fully below.
\index{validate (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.validate}\pysiglinewithargsret{void \bfcode{validate}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{ndev}, unsigned long *\emph{supported}, struct {\hyperref[networking/kapi:c.phylink_link_state]{\emph{phylink\_link\_state}}} *\emph{state}}{}
Validate and update the link configuration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * ndev}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.net_device]{\emph{\code{struct net\_device}}}} for the MAC.

\item[{\code{unsigned long * supported}}] \leavevmode
ethtool bitmask for supported link modes.

\item[{\code{struct phylink\_link\_state * state}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink_link_state]{\emph{\code{struct phylink\_link\_state}}}}.

\end{description}

\textbf{Description}

Clear bits in the \textbf{supported} and \textbf{state}-\textgreater{}advertising masks that
are not supportable by the MAC.

Note that the PHY may be able to transform from one connection
technology to another, so, eg, don't clear 1000BaseX just
because the MAC is unable to BaseX mode. This is more about
clearing unsupported speeds and duplex settings.

If the \textbf{state}-\textgreater{}interface mode is \code{PHY\_INTERFACE\_MODE\_1000BASEX}
or \code{PHY\_INTERFACE\_MODE\_2500BASEX}, select the appropriate mode
based on \textbf{state}-\textgreater{}advertising and/or \textbf{state}-\textgreater{}speed and update
\textbf{state}-\textgreater{}interface accordingly.
\index{mac\_link\_state (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.mac_link_state}\pysiglinewithargsret{int \bfcode{mac\_link\_state}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{ndev}, struct {\hyperref[networking/kapi:c.phylink_link_state]{\emph{phylink\_link\_state}}} *\emph{state}}{}
Read the current link state from the hardware

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * ndev}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.net_device]{\emph{\code{struct net\_device}}}} for the MAC.

\item[{\code{struct phylink\_link\_state * state}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink_link_state]{\emph{\code{struct phylink\_link\_state}}}}.

\end{description}

\textbf{Description}

Read the current link state from the MAC, reporting the current
speed in \textbf{state}-\textgreater{}speed, duplex mode in \textbf{state}-\textgreater{}duplex, pause mode
in \textbf{state}-\textgreater{}pause using the \code{MLO\_PAUSE\_RX} and \code{MLO\_PAUSE\_TX} bits,
negotiation completion state in \textbf{state}-\textgreater{}an\_complete, and link
up state in \textbf{state}-\textgreater{}link.
\index{mac\_config (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.mac_config}\pysiglinewithargsret{void \bfcode{mac\_config}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{ndev}, unsigned int\emph{mode}, const struct {\hyperref[networking/kapi:c.phylink_link_state]{\emph{phylink\_link\_state}}} *\emph{state}}{}
configure the MAC for the selected mode and state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * ndev}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.net_device]{\emph{\code{struct net\_device}}}} for the MAC.

\item[{\code{unsigned int mode}}] \leavevmode
one of \code{MLO\_AN\_FIXED}, \code{MLO\_AN\_PHY}, \code{MLO\_AN\_INBAND}.

\item[{\code{const struct phylink\_link\_state * state}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink_link_state]{\emph{\code{struct phylink\_link\_state}}}}.

\end{description}

\textbf{Description}

The action performed depends on the currently selected mode:
\begin{description}
\item[{\code{MLO\_AN\_FIXED}, \code{MLO\_AN\_PHY}:}] \leavevmode
Configure the specified \textbf{state}-\textgreater{}speed, \textbf{state}-\textgreater{}duplex and
\textbf{state}-\textgreater{}pause (\code{MLO\_PAUSE\_TX} / \code{MLO\_PAUSE\_RX}) mode.

\item[{\code{MLO\_AN\_INBAND}:}] \leavevmode
place the link in an inband negotiation mode (such as 802.3z
1000base-X or Cisco SGMII mode depending on the \textbf{state}-\textgreater{}interface
mode). In both cases, link state management (whether the link
is up or not) is performed by the MAC, and reported via the
{\hyperref[networking/kapi:c.mac_link_state]{\emph{\code{mac\_link\_state()}}}} callback. Changes in link state must be made
by calling {\hyperref[networking/kapi:c.phylink_mac_change]{\emph{\code{phylink\_mac\_change()}}}}.

If in 802.3z mode, the link speed is fixed, dependent on the
\textbf{state}-\textgreater{}interface. Duplex is negotiated, and pause is advertised
according to \textbf{state}-\textgreater{}an\_enabled, \textbf{state}-\textgreater{}pause and
\textbf{state}-\textgreater{}advertising flags. Beware of MACs which only support full
duplex at gigabit and higher speeds.

If in Cisco SGMII mode, the link speed and duplex mode are passed
in the serial bitstream 16-bit configuration word, and the MAC
should be configured to read these bits and acknowledge the
configuration word. Nothing is advertised by the MAC. The MAC is
responsible for reading the configuration word and configuring
itself accordingly.

\end{description}
\index{mac\_an\_restart (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.mac_an_restart}\pysiglinewithargsret{void \bfcode{mac\_an\_restart}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{ndev}}{}
restart 802.3z BaseX autonegotiation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * ndev}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.net_device]{\emph{\code{struct net\_device}}}} for the MAC.

\end{description}
\index{mac\_link\_down (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.mac_link_down}\pysiglinewithargsret{void \bfcode{mac\_link\_down}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{ndev}, unsigned int\emph{mode}}{}
take the link down

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * ndev}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.net_device]{\emph{\code{struct net\_device}}}} for the MAC.

\item[{\code{unsigned int mode}}] \leavevmode
link autonegotiation mode

\end{description}

\textbf{Description}

If \textbf{mode} is not an in-band negotiation mode (as defined by
\code{phylink\_autoneg\_inband()}), force the link down and disable any
Energy Efficient Ethernet MAC configuration.
\index{mac\_link\_up (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.mac_link_up}\pysiglinewithargsret{void \bfcode{mac\_link\_up}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{ndev}, unsigned int\emph{mode}, struct phy\_device *\emph{phy}}{}
allow the link to come up

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * ndev}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.net_device]{\emph{\code{struct net\_device}}}} for the MAC.

\item[{\code{unsigned int mode}}] \leavevmode
link autonegotiation mode

\item[{\code{struct phy\_device * phy}}] \leavevmode
any attached phy

\end{description}

\textbf{Description}

If \textbf{mode} is not an in-band negotiation mode (as defined by
\code{phylink\_autoneg\_inband()}), allow the link to come up. If \textbf{phy}
is non-\code{NULL}, configure Energy Efficient Ethernet by calling
{\hyperref[networking/kapi:c.phy_init_eee]{\emph{\code{phy\_init\_eee()}}}} and perform appropriate MAC configuration for EEE.
\index{phylink (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink}\pysigline{struct \bfcode{phylink}}
internal data type for phylink

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct phylink \PYGZob{}
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\index{phylink\_set\_port\_modes (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_set_port_modes}\pysiglinewithargsret{void \bfcode{phylink\_set\_port\_modes}}{unsigned long *\emph{mask}}{}
set the port type modes in the ethtool mask

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long * mask}}] \leavevmode
ethtool link mode mask

\end{description}

\textbf{Description}

Sets all the port type modes in the ethtool mask.  MAC drivers should
use this in their `validate' callback.
\index{phylink\_create (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_create}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} * \bfcode{phylink\_create}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{ndev}, struct fwnode\_handle *\emph{fwnode}, phy\_interface\_t\emph{iface}, const struct {\hyperref[networking/kapi:c.phylink_mac_ops]{\emph{phylink\_mac\_ops}}} *\emph{ops}}{}
create a phylink instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * ndev}}] \leavevmode
a pointer to the {\hyperref[networking/kapi:c.net_device]{\emph{\code{struct net\_device}}}}

\item[{\code{struct fwnode\_handle * fwnode}}] \leavevmode
a pointer to a \code{struct fwnode\_handle} describing the network
interface

\item[{\code{phy\_interface\_t iface}}] \leavevmode
the desired link mode defined by \code{typedef phy\_interface\_t}

\item[{\code{const struct phylink\_mac\_ops * ops}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink_mac_ops]{\emph{\code{struct phylink\_mac\_ops}}}} for the MAC.

\end{description}

\textbf{Description}

Create a new phylink instance, and parse the link parameters found in \textbf{np}.
This will parse in-band modes, fixed-link or SFP configuration.

Returns a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}}, or an error-pointer value. Users
must use \code{IS\_ERR()} to check for errors from this function.
\index{phylink\_destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_destroy}\pysiglinewithargsret{void \bfcode{phylink\_destroy}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}}{}
cleanup and destroy the phylink instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\end{description}

\textbf{Description}

Destroy a phylink instance. Any PHY that has been attached must have been
cleaned up via {\hyperref[networking/kapi:c.phylink_disconnect_phy]{\emph{\code{phylink\_disconnect\_phy()}}}} prior to calling this function.
\index{phylink\_connect\_phy (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_connect_phy}\pysiglinewithargsret{int \bfcode{phylink\_connect\_phy}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}, struct phy\_device *\emph{phy}}{}
connect a PHY to the phylink instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\item[{\code{struct phy\_device * phy}}] \leavevmode
a pointer to a \code{struct phy\_device}.

\end{description}

\textbf{Description}

Connect \textbf{phy} to the phylink instance specified by \textbf{pl} by calling
{\hyperref[networking/kapi:c.phy_attach_direct]{\emph{\code{phy\_attach\_direct()}}}}. Configure the \textbf{phy} according to the MAC driver's
capabilities, start the PHYLIB state machine and enable any interrupts
that the PHY supports.

This updates the phylink's ethtool supported and advertising link mode
masks.

Returns 0 on success or a negative errno.
\index{phylink\_of\_phy\_connect (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_of_phy_connect}\pysiglinewithargsret{int \bfcode{phylink\_of\_phy\_connect}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}, struct device\_node *\emph{dn}, u32\emph{flags}}{}
connect the PHY specified in the DT mode.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\item[{\code{struct device\_node * dn}}] \leavevmode
a pointer to a \code{struct device\_node}.

\item[{\code{u32 flags}}] \leavevmode
PHY-specific flags to communicate to the PHY device driver

\end{description}

\textbf{Description}

Connect the phy specified in the device node \textbf{dn} to the phylink instance
specified by \textbf{pl}. Actions specified in {\hyperref[networking/kapi:c.phylink_connect_phy]{\emph{\code{phylink\_connect\_phy()}}}} will be
performed.

Returns 0 on success or a negative errno.
\index{phylink\_disconnect\_phy (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_disconnect_phy}\pysiglinewithargsret{void \bfcode{phylink\_disconnect\_phy}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}}{}
disconnect any PHY attached to the phylink instance.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\end{description}

\textbf{Description}

Disconnect any current PHY from the phylink instance described by \textbf{pl}.
\index{phylink\_fixed\_state\_cb (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_fixed_state_cb}\pysiglinewithargsret{int \bfcode{phylink\_fixed\_state\_cb}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}, void (*cb) (struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}}\emph{*dev}, struct {\hyperref[networking/kapi:c.phylink_link_state]{\emph{phylink\_link\_state}}}\emph{*state}}{}
allow setting a fixed link callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\item[{\code{void (*)(struct net\_device *dev, struct phylink\_link\_state *state) cb}}] \leavevmode
callback to execute to determine the fixed link state.

\end{description}

\textbf{Description}

The MAC driver should call this driver when the state of its link
can be determined through e.g: an out of band MMIO register.
\index{phylink\_mac\_change (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_mac_change}\pysiglinewithargsret{void \bfcode{phylink\_mac\_change}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}, bool\emph{up}}{}
notify phylink of a change in MAC state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\item[{\code{bool up}}] \leavevmode
indicates whether the link is currently up.

\end{description}

\textbf{Description}

The MAC driver should call this driver when the state of its link
changes (eg, link failure, new negotiation results, etc.)
\index{phylink\_start (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_start}\pysiglinewithargsret{void \bfcode{phylink\_start}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}}{}
start a phylink instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\end{description}

\textbf{Description}

Start the phylink instance specified by \textbf{pl}, configuring the MAC for the
desired link mode(s) and negotiation style. This should be called from the
network device driver's \code{struct net\_device\_ops} \code{ndo\_open()} method.
\index{phylink\_stop (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_stop}\pysiglinewithargsret{void \bfcode{phylink\_stop}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}}{}
stop a phylink instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\end{description}

\textbf{Description}

Stop the phylink instance specified by \textbf{pl}. This should be called from the
network device driver's \code{struct net\_device\_ops} \code{ndo\_stop()} method.  The
network device's carrier state should not be changed prior to calling this
function.
\index{phylink\_ethtool\_get\_wol (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_ethtool_get_wol}\pysiglinewithargsret{void \bfcode{phylink\_ethtool\_get\_wol}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}, struct ethtool\_wolinfo *\emph{wol}}{}
get the wake on lan parameters for the PHY

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\item[{\code{struct ethtool\_wolinfo * wol}}] \leavevmode
a pointer to \code{struct ethtool\_wolinfo} to hold the read parameters

\end{description}

\textbf{Description}

Read the wake on lan parameters from the PHY attached to the phylink
instance specified by \textbf{pl}. If no PHY is currently attached, report no
support for wake on lan.
\index{phylink\_ethtool\_set\_wol (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_ethtool_set_wol}\pysiglinewithargsret{int \bfcode{phylink\_ethtool\_set\_wol}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}, struct ethtool\_wolinfo *\emph{wol}}{}
set wake on lan parameters

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\item[{\code{struct ethtool\_wolinfo * wol}}] \leavevmode
a pointer to \code{struct ethtool\_wolinfo} for the desired parameters

\end{description}

\textbf{Description}

Set the wake on lan parameters for the PHY attached to the phylink
instance specified by \textbf{pl}. If no PHY is attached, returns \code{EOPNOTSUPP}
error.

Returns zero on success or negative errno code.
\index{phylink\_ethtool\_ksettings\_get (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_ethtool_ksettings_get}\pysiglinewithargsret{int \bfcode{phylink\_ethtool\_ksettings\_get}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}, struct ethtool\_link\_ksettings *\emph{kset}}{}
get the current link settings

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\item[{\code{struct ethtool\_link\_ksettings * kset}}] \leavevmode
a pointer to a \code{struct ethtool\_link\_ksettings} to hold link settings

\end{description}

\textbf{Description}

Read the current link settings for the phylink instance specified by \textbf{pl}.
This will be the link settings read from the MAC, PHY or fixed link
settings depending on the current negotiation mode.
\index{phylink\_ethtool\_ksettings\_set (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_ethtool_ksettings_set}\pysiglinewithargsret{int \bfcode{phylink\_ethtool\_ksettings\_set}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}, const struct ethtool\_link\_ksettings *\emph{kset}}{}
set the link settings

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\item[{\code{const struct ethtool\_link\_ksettings * kset}}] \leavevmode
a pointer to a \code{struct ethtool\_link\_ksettings} for the desired modes

\end{description}
\index{phylink\_ethtool\_nway\_reset (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_ethtool_nway_reset}\pysiglinewithargsret{int \bfcode{phylink\_ethtool\_nway\_reset}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}}{}
restart negotiation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\end{description}

\textbf{Description}

Restart negotiation for the phylink instance specified by \textbf{pl}. This will
cause any attached phy to restart negotiation with the link partner, and
if the MAC is in a BaseX mode, the MAC will also be requested to restart
negotiation.

Returns zero on success, or negative error code.
\index{phylink\_ethtool\_get\_pauseparam (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_ethtool_get_pauseparam}\pysiglinewithargsret{void \bfcode{phylink\_ethtool\_get\_pauseparam}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}, struct ethtool\_pauseparam *\emph{pause}}{}
get the current pause parameters

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\item[{\code{struct ethtool\_pauseparam * pause}}] \leavevmode
a pointer to a \code{struct ethtool\_pauseparam}

\end{description}
\index{phylink\_ethtool\_set\_pauseparam (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_ethtool_set_pauseparam}\pysiglinewithargsret{int \bfcode{phylink\_ethtool\_set\_pauseparam}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}, struct ethtool\_pauseparam *\emph{pause}}{}
set the current pause parameters

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\item[{\code{struct ethtool\_pauseparam * pause}}] \leavevmode
a pointer to a \code{struct ethtool\_pauseparam}

\end{description}
\index{phylink\_get\_eee\_err (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_get_eee_err}\pysiglinewithargsret{int \bfcode{phylink\_get\_eee\_err}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}}{}
read the energy efficient ethernet error counter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}.

\end{description}

\textbf{Description}

Read the Energy Efficient Ethernet error counter from the PHY associated
with the phylink instance specified by \textbf{pl}.

Returns positive error counter value, or negative error code.
\index{phylink\_ethtool\_get\_eee (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_ethtool_get_eee}\pysiglinewithargsret{int \bfcode{phylink\_ethtool\_get\_eee}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}, struct ethtool\_eee *\emph{eee}}{}
read the energy efficient ethernet parameters

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\item[{\code{struct ethtool\_eee * eee}}] \leavevmode
a pointer to a \code{struct ethtool\_eee} for the read parameters

\end{description}
\index{phylink\_ethtool\_set\_eee (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_ethtool_set_eee}\pysiglinewithargsret{int \bfcode{phylink\_ethtool\_set\_eee}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}, struct ethtool\_eee *\emph{eee}}{}
set the energy efficient ethernet parameters

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\item[{\code{struct ethtool\_eee * eee}}] \leavevmode
a pointer to a \code{struct ethtool\_eee} for the desired parameters

\end{description}
\index{phylink\_mii\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.phylink_mii_ioctl}\pysiglinewithargsret{int \bfcode{phylink\_mii\_ioctl}}{struct {\hyperref[networking/kapi:c.phylink]{\emph{phylink}}} *\emph{pl}, struct ifreq *\emph{ifr}, int\emph{cmd}}{}
generic mii ioctl interface

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct phylink * pl}}] \leavevmode
a pointer to a {\hyperref[networking/kapi:c.phylink]{\emph{\code{struct phylink}}}} returned from {\hyperref[networking/kapi:c.phylink_create]{\emph{\code{phylink\_create()}}}}

\item[{\code{struct ifreq * ifr}}] \leavevmode
a pointer to a \code{struct ifreq} for socket ioctls

\item[{\code{int cmd}}] \leavevmode
ioctl cmd to execute

\end{description}

\textbf{Description}

Perform the specified MII ioctl on the PHY attached to the phylink instance
specified by \textbf{pl}. If no PHY is attached, emulate the presence of the PHY.

\textbf{Return}

zero on success or negative error code.
\begin{description}
\item[{\code{SIOCGMIIPHY}:}] \leavevmode
read register from the current PHY.

\item[{\code{SIOCGMIIREG}:}] \leavevmode
read register from the specified PHY.

\item[{\code{SIOCSMIIREG}:}] \leavevmode
set a register on the specified PHY.

\end{description}


\subsection{SFP support}
\label{networking/kapi:sfp-support}\index{sfp\_bus (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sfp_bus}\pysigline{struct \bfcode{sfp\_bus}}
internal representation of a sfp bus

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct sfp\PYGZus{}bus \PYGZob{}
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\index{sfp\_eeprom\_id (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sfp_eeprom_id}\pysigline{struct \bfcode{sfp\_eeprom\_id}}
raw SFP module identification information

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct sfp\PYGZus{}eeprom\PYGZus{}id \PYGZob{}
  struct sfp\PYGZus{}eeprom\PYGZus{}base base;
  struct sfp\PYGZus{}eeprom\PYGZus{}ext ext;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{base}}] \leavevmode
base SFP module identification structure

\item[{\code{ext}}] \leavevmode
extended SFP module identification structure

\end{description}

\textbf{Description}

See the SFF-8472 specification and related documents for the definition
of these structure members. This can be obtained from
\href{ftp://ftp.seagate.com/sff}{ftp://ftp.seagate.com/sff}
\index{sfp\_upstream\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sfp_upstream_ops}\pysigline{struct \bfcode{sfp\_upstream\_ops}}
upstream operations structure

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct sfp\PYGZus{}upstream\PYGZus{}ops \PYGZob{}
  int (*module\PYGZus{}insert)(void *priv, const struct sfp\PYGZus{}eeprom\PYGZus{}id *id);
  void (*module\PYGZus{}remove)(void *priv);
  void (*link\PYGZus{}down)(void *priv);
  void (*link\PYGZus{}up)(void *priv);
  int (*connect\PYGZus{}phy)(void *priv, struct phy\PYGZus{}device *);
  void (*disconnect\PYGZus{}phy)(void *priv);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{module\_insert}}] \leavevmode
called after a module has been detected to determine
whether the module is supported for the upstream device.

\item[{\code{module\_remove}}] \leavevmode
called after the module has been removed.

\item[{\code{link\_down}}] \leavevmode
called when the link is non-operational for whatever
reason.

\item[{\code{link\_up}}] \leavevmode
called when the link is operational.

\item[{\code{connect\_phy}}] \leavevmode
called when an I2C accessible PHY has been detected
on the module.

\item[{\code{disconnect\_phy}}] \leavevmode
called when a module with an I2C accessible PHY has
been removed.

\end{description}
\index{sfp\_parse\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sfp_parse_port}\pysiglinewithargsret{int \bfcode{sfp\_parse\_port}}{struct {\hyperref[networking/kapi:c.sfp_bus]{\emph{sfp\_bus}}} *\emph{bus}, const struct {\hyperref[networking/kapi:c.sfp_eeprom_id]{\emph{sfp\_eeprom\_id}}} *\emph{id}, unsigned long *\emph{support}}{}
Parse the EEPROM base ID, setting the port type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sfp\_bus * bus}}] \leavevmode
a pointer to the {\hyperref[networking/kapi:c.sfp_bus]{\emph{\code{struct sfp\_bus}}}} structure for the sfp module

\item[{\code{const struct sfp\_eeprom\_id * id}}] \leavevmode
a pointer to the module's {\hyperref[networking/kapi:c.sfp_eeprom_id]{\emph{\code{struct sfp\_eeprom\_id}}}}

\item[{\code{unsigned long * support}}] \leavevmode
optional pointer to an array of unsigned long for the
ethtool support mask

\end{description}

\textbf{Description}

Parse the EEPROM identification given in \textbf{id}, and return one of
\code{PORT\_TP}, \code{PORT\_FIBRE} or \code{PORT\_OTHER}. If \textbf{support} is non-\code{NULL},
also set the ethtool \code{ETHTOOL\_LINK\_MODE\_xxx\_BIT} corresponding with
the connector type.

If the port type is not known, returns \code{PORT\_OTHER}.
\index{sfp\_parse\_interface (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sfp_parse_interface}\pysiglinewithargsret{phy\_interface\_t \bfcode{sfp\_parse\_interface}}{struct {\hyperref[networking/kapi:c.sfp_bus]{\emph{sfp\_bus}}} *\emph{bus}, const struct {\hyperref[networking/kapi:c.sfp_eeprom_id]{\emph{sfp\_eeprom\_id}}} *\emph{id}}{}
Parse the phy\_interface\_t

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sfp\_bus * bus}}] \leavevmode
a pointer to the {\hyperref[networking/kapi:c.sfp_bus]{\emph{\code{struct sfp\_bus}}}} structure for the sfp module

\item[{\code{const struct sfp\_eeprom\_id * id}}] \leavevmode
a pointer to the module's {\hyperref[networking/kapi:c.sfp_eeprom_id]{\emph{\code{struct sfp\_eeprom\_id}}}}

\end{description}

\textbf{Description}

Derive the phy\_interface\_t mode for the information found in the
module's identifying EEPROM. There is no standard or defined way
to derive this information, so we use some heuristics.

If the encoding is 64b66b, then the module must be \textgreater{}= 10G, so
return \code{PHY\_INTERFACE\_MODE\_10GKR}.

If it's 8b10b, then it's 1G or slower. If it's definitely a fibre
module, return \code{PHY\_INTERFACE\_MODE\_1000BASEX} mode, otherwise return
\code{PHY\_INTERFACE\_MODE\_SGMII} mode.

If the encoding is not known, return \code{PHY\_INTERFACE\_MODE\_NA}.
\index{sfp\_parse\_support (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sfp_parse_support}\pysiglinewithargsret{void \bfcode{sfp\_parse\_support}}{struct {\hyperref[networking/kapi:c.sfp_bus]{\emph{sfp\_bus}}} *\emph{bus}, const struct {\hyperref[networking/kapi:c.sfp_eeprom_id]{\emph{sfp\_eeprom\_id}}} *\emph{id}, unsigned long *\emph{support}}{}
Parse the eeprom id for supported link modes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sfp\_bus * bus}}] \leavevmode
a pointer to the {\hyperref[networking/kapi:c.sfp_bus]{\emph{\code{struct sfp\_bus}}}} structure for the sfp module

\item[{\code{const struct sfp\_eeprom\_id * id}}] \leavevmode
a pointer to the module's {\hyperref[networking/kapi:c.sfp_eeprom_id]{\emph{\code{struct sfp\_eeprom\_id}}}}

\item[{\code{unsigned long * support}}] \leavevmode
pointer to an array of unsigned long for the ethtool support mask

\end{description}

\textbf{Description}

Parse the EEPROM identification information and derive the supported
ethtool link modes for the module.
\index{sfp\_get\_module\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sfp_get_module_info}\pysiglinewithargsret{int \bfcode{sfp\_get\_module\_info}}{struct {\hyperref[networking/kapi:c.sfp_bus]{\emph{sfp\_bus}}} *\emph{bus}, struct ethtool\_modinfo *\emph{modinfo}}{}
Get the ethtool\_modinfo for a SFP module

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sfp\_bus * bus}}] \leavevmode
a pointer to the {\hyperref[networking/kapi:c.sfp_bus]{\emph{\code{struct sfp\_bus}}}} structure for the sfp module

\item[{\code{struct ethtool\_modinfo * modinfo}}] \leavevmode
a \code{struct ethtool\_modinfo}

\end{description}

\textbf{Description}

Fill in the type and eeprom\_len parameters in \textbf{modinfo} for a module on
the sfp bus specified by \textbf{bus}.

Returns 0 on success or a negative errno number.
\index{sfp\_get\_module\_eeprom (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sfp_get_module_eeprom}\pysiglinewithargsret{int \bfcode{sfp\_get\_module\_eeprom}}{struct {\hyperref[networking/kapi:c.sfp_bus]{\emph{sfp\_bus}}} *\emph{bus}, struct ethtool\_eeprom *\emph{ee}, u8 *\emph{data}}{}
Read the SFP module EEPROM

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sfp\_bus * bus}}] \leavevmode
a pointer to the {\hyperref[networking/kapi:c.sfp_bus]{\emph{\code{struct sfp\_bus}}}} structure for the sfp module

\item[{\code{struct ethtool\_eeprom * ee}}] \leavevmode
a \code{struct ethtool\_eeprom}

\item[{\code{u8 * data}}] \leavevmode
buffer to contain the EEPROM data (must be at least \textbf{ee}-\textgreater{}len bytes)

\end{description}

\textbf{Description}

Read the EEPROM as specified by the supplied \textbf{ee}. See the documentation
for \code{struct ethtool\_eeprom} for the region to be read.

Returns 0 on success or a negative errno number.
\index{sfp\_upstream\_start (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sfp_upstream_start}\pysiglinewithargsret{void \bfcode{sfp\_upstream\_start}}{struct {\hyperref[networking/kapi:c.sfp_bus]{\emph{sfp\_bus}}} *\emph{bus}}{}
Inform the SFP that the network device is up

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sfp\_bus * bus}}] \leavevmode
a pointer to the {\hyperref[networking/kapi:c.sfp_bus]{\emph{\code{struct sfp\_bus}}}} structure for the sfp module

\end{description}

\textbf{Description}

Inform the SFP socket that the network device is now up, so that the
module can be enabled by allowing TX\_DISABLE to be deasserted. This
should be called from the network device driver's \code{struct net\_device\_ops}
\code{ndo\_open()} method.
\index{sfp\_upstream\_stop (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sfp_upstream_stop}\pysiglinewithargsret{void \bfcode{sfp\_upstream\_stop}}{struct {\hyperref[networking/kapi:c.sfp_bus]{\emph{sfp\_bus}}} *\emph{bus}}{}
Inform the SFP that the network device is down

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sfp\_bus * bus}}] \leavevmode
a pointer to the {\hyperref[networking/kapi:c.sfp_bus]{\emph{\code{struct sfp\_bus}}}} structure for the sfp module

\end{description}

\textbf{Description}

Inform the SFP socket that the network device is now up, so that the
module can be disabled by asserting TX\_DISABLE, disabling the laser
in optical modules. This should be called from the network device
driver's \code{struct net\_device\_ops} \code{ndo\_stop()} method.
\index{sfp\_register\_upstream (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sfp_register_upstream}\pysiglinewithargsret{struct {\hyperref[networking/kapi:c.sfp_bus]{\emph{sfp\_bus}}} * \bfcode{sfp\_register\_upstream}}{struct fwnode\_handle *\emph{fwnode}, struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{ndev}, void *\emph{upstream}, const struct {\hyperref[networking/kapi:c.sfp_upstream_ops]{\emph{sfp\_upstream\_ops}}} *\emph{ops}}{}
Register the neighbouring device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct fwnode\_handle * fwnode}}] \leavevmode
firmware node for the SFP bus

\item[{\code{struct net\_device * ndev}}] \leavevmode
network device associated with the interface

\item[{\code{void * upstream}}] \leavevmode
the upstream private data

\item[{\code{const struct sfp\_upstream\_ops * ops}}] \leavevmode
the upstream's {\hyperref[networking/kapi:c.sfp_upstream_ops]{\emph{\code{struct sfp\_upstream\_ops}}}}

\end{description}

\textbf{Description}

Register the upstream device (eg, PHY) with the SFP bus. MAC drivers
should use phylink, which will call this function for them. Returns
a pointer to the allocated {\hyperref[networking/kapi:c.sfp_bus]{\emph{\code{struct sfp\_bus}}}}.

On error, returns \code{NULL}.
\index{sfp\_unregister\_upstream (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/kapi:c.sfp_unregister_upstream}\pysiglinewithargsret{void \bfcode{sfp\_unregister\_upstream}}{struct {\hyperref[networking/kapi:c.sfp_bus]{\emph{sfp\_bus}}} *\emph{bus}}{}
Unregister sfp bus

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sfp\_bus * bus}}] \leavevmode
a pointer to the {\hyperref[networking/kapi:c.sfp_bus]{\emph{\code{struct sfp\_bus}}}} structure for the sfp module

\end{description}

\textbf{Description}

Unregister a previously registered upstream connection for the SFP
module. \textbf{bus} is returned from {\hyperref[networking/kapi:c.sfp_register_upstream]{\emph{\code{sfp\_register\_upstream()}}}}.


\chapter{Z8530 Programming Guide}
\label{networking/z8530book::doc}\label{networking/z8530book:z8530-programming-guide}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Alan Cox

\end{description}\end{quote}


\section{Introduction}
\label{networking/z8530book:introduction}
The Z85x30 family synchronous/asynchronous controller chips are used on
a large number of cheap network interface cards. The kernel provides a
core interface layer that is designed to make it easy to provide WAN
services using this chip.

The current driver only support synchronous operation. Merging the
asynchronous driver support into this code to allow any Z85x30 device to
be used as both a tty interface and as a synchronous controller is a
project for Linux post the 2.4 release


\section{Driver Modes}
\label{networking/z8530book:driver-modes}
The Z85230 driver layer can drive Z8530, Z85C30 and Z85230 devices in
three different modes. Each mode can be applied to an individual channel
on the chip (each chip has two channels).

The PIO synchronous mode supports the most common Z8530 wiring. Here the
chip is interface to the I/O and interrupt facilities of the host
machine but not to the DMA subsystem. When running PIO the Z8530 has
extremely tight timing requirements. Doing high speeds, even with a
Z85230 will be tricky. Typically you should expect to achieve at best
9600 baud with a Z8C530 and 64Kbits with a Z85230.

The DMA mode supports the chip when it is configured to use dual DMA
channels on an ISA bus. The better cards tend to support this mode of
operation for a single channel. With DMA running the Z85230 tops out
when it starts to hit ISA DMA constraints at about 512Kbits. It is worth
noting here that many PC machines hang or crash when the chip is driven
fast enough to hold the ISA bus solid.

Transmit DMA mode uses a single DMA channel. The DMA channel is used for
transmission as the transmit FIFO is smaller than the receive FIFO. it
gives better performance than pure PIO mode but is nowhere near as ideal
as pure DMA mode.


\section{Using the Z85230 driver}
\label{networking/z8530book:using-the-z85230-driver}
The Z85230 driver provides the back end interface to your board. To
configure a Z8530 interface you need to detect the board and to identify
its ports and interrupt resources. It is also your problem to verify the
resources are available.

Having identified the chip you need to fill in a struct z8530\_dev,
which describes each chip. This object must exist until you finally
shutdown the board. Firstly zero the active field. This ensures nothing
goes off without you intending it. The irq field should be set to the
interrupt number of the chip. (Each chip has a single interrupt source
rather than each channel). You are responsible for allocating the
interrupt line. The interrupt handler should be set to
{\hyperref[networking/z8530book:c.z8530_interrupt]{\emph{\code{z8530\_interrupt()}}}}. The device id should be set to the
z8530\_dev structure pointer. Whether the interrupt can be shared or not
is board dependent, and up to you to initialise.

The structure holds two channel structures. Initialise chanA.ctrlio and
chanA.dataio with the address of the control and data ports. You can or
this with Z8530\_PORT\_SLEEP to indicate your interface needs the 5uS
delay for chip settling done in software. The PORT\_SLEEP option is
architecture specific. Other flags may become available on future
platforms, eg for MMIO. Initialise the chanA.irqs to \&z8530\_nop to
start the chip up as disabled and discarding interrupt events. This
ensures that stray interrupts will be mopped up and not hang the bus.
Set chanA.dev to point to the device structure itself. The private and
name field you may use as you wish. The private field is unused by the
Z85230 layer. The name is used for error reporting and it may thus make
sense to make it match the network name.

Repeat the same operation with the B channel if your chip has both
channels wired to something useful. This isn't always the case. If it is
not wired then the I/O values do not matter, but you must initialise
chanB.dev.

If your board has DMA facilities then initialise the txdma and rxdma
fields for the relevant channels. You must also allocate the ISA DMA
channels and do any necessary board level initialisation to configure
them. The low level driver will do the Z8530 and DMA controller
programming but not board specific magic.

Having initialised the device you can then call
{\hyperref[networking/z8530book:c.z8530_init]{\emph{\code{z8530\_init()}}}}. This will probe the chip and reset it into
a known state. An identification sequence is then run to identify the
chip type. If the checks fail to pass the function returns a non zero
error code. Typically this indicates that the port given is not valid.
After this call the type field of the z8530\_dev structure is
initialised to either Z8530, Z85C30 or Z85230 according to the chip
found.

Once you have called z8530\_init you can also make use of the utility
function {\hyperref[networking/z8530book:c.z8530_describe]{\emph{\code{z8530\_describe()}}}}. This provides a consistent
reporting format for the Z8530 devices, and allows all the drivers to
provide consistent reporting.


\section{Attaching Network Interfaces}
\label{networking/z8530book:attaching-network-interfaces}
If you wish to use the network interface facilities of the driver, then
you need to attach a network device to each channel that is present and
in use. In addition to use the generic HDLC you need to follow some
additional plumbing rules. They may seem complex but a look at the
example hostess\_sv11 driver should reassure you.

The network device used for each channel should be pointed to by the
netdevice field of each channel. The hdlc-\textgreater{} priv field of the network
device points to your private data - you will need to be able to find
your private data from this.

The way most drivers approach this particular problem is to create a
structure holding the Z8530 device definition and put that into the
private field of the network device. The network device fields of the
channels then point back to the network devices.

If you wish to use the generic HDLC then you need to register the HDLC
device.

Before you register your network device you will also need to provide
suitable handlers for most of the network device callbacks. See the
network device documentation for more details on this.


\section{Configuring And Activating The Port}
\label{networking/z8530book:configuring-and-activating-the-port}
The Z85230 driver provides helper functions and tables to load the port
registers on the Z8530 chips. When programming the register settings for
a channel be aware that the documentation recommends initialisation
orders. Strange things happen when these are not followed.

{\hyperref[networking/z8530book:c.z8530_channel_load]{\emph{\code{z8530\_channel\_load()}}}} takes an array of pairs of
initialisation values in an array of u8 type. The first value is the
Z8530 register number. Add 16 to indicate the alternate register bank on
the later chips. The array is terminated by a 255.

The driver provides a pair of public tables. The z8530\_hdlc\_kilostream
table is for the UK `Kilostream' service and also happens to cover most
other end host configurations. The z8530\_hdlc\_kilostream\_85230 table
is the same configuration using the enhancements of the 85230 chip. The
configuration loaded is standard NRZ encoded synchronous data with HDLC
bitstuffing. All of the timing is taken from the other end of the link.

When writing your own tables be aware that the driver internally tracks
register values. It may need to reload values. You should therefore be
sure to set registers 1-7, 9-11, 14 and 15 in all configurations. Where
the register settings depend on DMA selection the driver will update the
bits itself when you open or close. Loading a new table with the
interface open is not recommended.

There are three standard configurations supported by the core code. In
PIO mode the interface is programmed up to use interrupt driven PIO.
This places high demands on the host processor to avoid latency. The
driver is written to take account of latency issues but it cannot avoid
latencies caused by other drivers, notably IDE in PIO mode. Because the
drivers allocate buffers you must also prevent MTU changes while the
port is open.

Once the port is open it will call the rx\_function of each channel
whenever a completed packet arrived. This is invoked from interrupt
context and passes you the channel and a network buffer (struct
sk\_buff) holding the data. The data includes the CRC bytes so most
users will want to trim the last two bytes before processing the data.
This function is very timing critical. When you wish to simply discard
data the support code provides the function
{\hyperref[networking/z8530book:c.z8530_null_rx]{\emph{\code{z8530\_null\_rx()}}}} to discard the data.

To active PIO mode sending and receiving the \code{z8530\_sync\_open} is called.
This expects to be passed the network device and the channel. Typically
this is called from your network device open callback. On a failure a
non zero error status is returned.
The {\hyperref[networking/z8530book:c.z8530_sync_close]{\emph{\code{z8530\_sync\_close()}}}} function shuts down a PIO
channel. This must be done before the channel is opened again and before
the driver shuts down and unloads.

The ideal mode of operation is dual channel DMA mode. Here the kernel
driver will configure the board for DMA in both directions. The driver
also handles ISA DMA issues such as controller programming and the
memory range limit for you. This mode is activated by calling the
{\hyperref[networking/z8530book:c.z8530_sync_dma_open]{\emph{\code{z8530\_sync\_dma\_open()}}}} function. On failure a non zero
error value is returned. Once this mode is activated it can be shut down
by calling the {\hyperref[networking/z8530book:c.z8530_sync_dma_close]{\emph{\code{z8530\_sync\_dma\_close()}}}}. You must call
the close function matching the open mode you used.

The final supported mode uses a single DMA channel to drive the transmit
side. As the Z85C30 has a larger FIFO on the receive channel this tends
to increase the maximum speed a little. This is activated by calling the
\code{z8530\_sync\_txdma\_open}. This returns a non zero error code on failure. The
{\hyperref[networking/z8530book:c.z8530_sync_txdma_close]{\emph{\code{z8530\_sync\_txdma\_close()}}}} function closes down the Z8530
interface from this mode.


\section{Network Layer Functions}
\label{networking/z8530book:network-layer-functions}
The Z8530 layer provides functions to queue packets for transmission.
The driver internally buffers the frame currently being transmitted and
one further frame (in order to keep back to back transmission running).
Any further buffering is up to the caller.

The function {\hyperref[networking/z8530book:c.z8530_queue_xmit]{\emph{\code{z8530\_queue\_xmit()}}}} takes a network buffer
in sk\_buff format and queues it for transmission. The caller must
provide the entire packet with the exception of the bitstuffing and CRC.
This is normally done by the caller via the generic HDLC interface
layer. It returns 0 if the buffer has been queued and non zero values
for queue full. If the function accepts the buffer it becomes property
of the Z8530 layer and the caller should not free it.

The function \code{z8530\_get\_stats()} returns a pointer to an
internally maintained per interface statistics block. This provides most
of the interface code needed to implement the network layer get\_stats
callback.


\section{Porting The Z8530 Driver}
\label{networking/z8530book:porting-the-z8530-driver}
The Z8530 driver is written to be portable. In DMA mode it makes
assumptions about the use of ISA DMA. These are probably warranted in
most cases as the Z85230 in particular was designed to glue to PC type
machines. The PIO mode makes no real assumptions.

Should you need to retarget the Z8530 driver to another architecture the
only code that should need changing are the port I/O functions. At the
moment these assume PC I/O port accesses. This may not be appropriate
for all platforms. Replacing {\hyperref[networking/z8530book:c.z8530_read_port]{\emph{\code{z8530\_read\_port()}}}} and
\code{z8530\_write\_port} is intended to be all that is required to port
this driver layer.


\section{Known Bugs And Assumptions}
\label{networking/z8530book:known-bugs-and-assumptions}\begin{description}
\item[{Interrupt Locking}] \leavevmode
The locking in the driver is done via the global cli/sti lock. This
makes for relatively poor SMP performance. Switching this to use a
per device spin lock would probably materially improve performance.

\item[{Occasional Failures}] \leavevmode
We have reports of occasional failures when run for very long
periods of time and the driver starts to receive junk frames. At the
moment the cause of this is not clear.

\end{description}


\section{Public Functions Provided}
\label{networking/z8530book:public-functions-provided}\index{z8530\_interrupt (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_interrupt}\pysiglinewithargsret{irqreturn\_t \bfcode{z8530\_interrupt}}{int\emph{irq}, void *\emph{dev\_id}}{}
Handle an interrupt from a Z8530

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int irq}}] \leavevmode
Interrupt number

\item[{\code{void * dev\_id}}] \leavevmode
The Z8530 device that is interrupting.

\end{description}

\textbf{Description}
\begin{quote}

A Z85{[}2{]}30 device has stuck its hand in the air for attention.
We scan both the channels on the chip for events and then call
the channel specific call backs for each channel that has events.
We have to use callback functions because the two channels can be
in different modes.

Locking is done for the handlers. Note that locking is done
at the chip level (the 5uS delay issue is per chip not per
channel). c-\textgreater{}lock for both channels points to dev-\textgreater{}lock
\end{quote}
\index{z8530\_sync\_open (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_sync_open}\pysiglinewithargsret{int \bfcode{z8530\_sync\_open}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct z8530\_channel *\emph{c}}{}
Open a Z8530 channel for PIO

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
The network interface we are using

\item[{\code{struct z8530\_channel * c}}] \leavevmode
The Z8530 channel to open in synchronous PIO mode

\end{description}

\textbf{Description}
\begin{quote}

Switch a Z8530 into synchronous mode without DMA assist. We
raise the RTS/DTR and commence network operation.
\end{quote}
\index{z8530\_sync\_close (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_sync_close}\pysiglinewithargsret{int \bfcode{z8530\_sync\_close}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct z8530\_channel *\emph{c}}{}
Close a PIO Z8530 channel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
Network device to close

\item[{\code{struct z8530\_channel * c}}] \leavevmode
Z8530 channel to disassociate and move to idle

\end{description}

\textbf{Description}
\begin{quote}

Close down a Z8530 interface and switch its interrupt handlers
to discard future events.
\end{quote}
\index{z8530\_sync\_dma\_open (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_sync_dma_open}\pysiglinewithargsret{int \bfcode{z8530\_sync\_dma\_open}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct z8530\_channel *\emph{c}}{}
Open a Z8530 for DMA I/O

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
The network device to attach

\item[{\code{struct z8530\_channel * c}}] \leavevmode
The Z8530 channel to configure in sync DMA mode.

\end{description}

\textbf{Description}
\begin{quote}

Set up a Z85x30 device for synchronous DMA in both directions. Two
ISA DMA channels must be available for this to work. We assume ISA
DMA driven I/O and PC limits on access.
\end{quote}
\index{z8530\_sync\_dma\_close (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_sync_dma_close}\pysiglinewithargsret{int \bfcode{z8530\_sync\_dma\_close}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct z8530\_channel *\emph{c}}{}
Close down DMA I/O

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
Network device to detach

\item[{\code{struct z8530\_channel * c}}] \leavevmode
Z8530 channel to move into discard mode

\end{description}

\textbf{Description}
\begin{quote}

Shut down a DMA mode synchronous interface. Halt the DMA, and
free the buffers.
\end{quote}
\index{z8530\_sync\_txdma\_open (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_sync_txdma_open}\pysiglinewithargsret{int \bfcode{z8530\_sync\_txdma\_open}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct z8530\_channel *\emph{c}}{}
Open a Z8530 for TX driven DMA

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
The network device to attach

\item[{\code{struct z8530\_channel * c}}] \leavevmode
The Z8530 channel to configure in sync DMA mode.

\end{description}

\textbf{Description}
\begin{quote}

Set up a Z85x30 device for synchronous DMA transmission. One
ISA DMA channel must be available for this to work. The receive
side is run in PIO mode, but then it has the bigger FIFO.
\end{quote}
\index{z8530\_sync\_txdma\_close (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_sync_txdma_close}\pysiglinewithargsret{int \bfcode{z8530\_sync\_txdma\_close}}{struct {\hyperref[networking/kapi:c.net_device]{\emph{net\_device}}} *\emph{dev}, struct z8530\_channel *\emph{c}}{}
Close down a TX driven DMA channel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct net\_device * dev}}] \leavevmode
Network device to detach

\item[{\code{struct z8530\_channel * c}}] \leavevmode
Z8530 channel to move into discard mode

\end{description}

\textbf{Description}
\begin{quote}

Shut down a DMA/PIO split mode synchronous interface. Halt the DMA,
and  free the buffers.
\end{quote}
\index{z8530\_describe (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_describe}\pysiglinewithargsret{void \bfcode{z8530\_describe}}{struct z8530\_dev *\emph{dev}, char *\emph{mapping}, unsigned long\emph{io}}{}
Uniformly describe a Z8530 port

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_dev * dev}}] \leavevmode
Z8530 device to describe

\item[{\code{char * mapping}}] \leavevmode
string holding mapping type (eg ``I/O'' or ``Mem'')

\item[{\code{unsigned long io}}] \leavevmode
the port value in question

\end{description}

\textbf{Description}
\begin{quote}

Describe a Z8530 in a standard format. We must pass the I/O as
the port offset isn't predictable. The main reason for this function
is to try and get a common format of report.
\end{quote}
\index{z8530\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_init}\pysiglinewithargsret{int \bfcode{z8530\_init}}{struct z8530\_dev *\emph{dev}}{}
Initialise a Z8530 device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_dev * dev}}] \leavevmode
Z8530 device to initialise.

\end{description}

\textbf{Description}
\begin{quote}

Configure up a Z8530/Z85C30 or Z85230 chip. We check the device
is present, identify the type and then program it to hopefully
keep quite and behave. This matters a lot, a Z8530 in the wrong
state will sometimes get into stupid modes generating 10Khz
interrupt streams and the like.

We set the interrupt handler up to discard any events, in case
we get them during reset or setp.

Return 0 for success, or a negative value indicating the problem
in errno form.
\end{quote}
\index{z8530\_shutdown (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_shutdown}\pysiglinewithargsret{int \bfcode{z8530\_shutdown}}{struct z8530\_dev *\emph{dev}}{}
Shutdown a Z8530 device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_dev * dev}}] \leavevmode
The Z8530 chip to shutdown

\end{description}

\textbf{Description}
\begin{quote}

We set the interrupt handlers to silence any interrupts. We then
reset the chip and wait 100uS to be sure the reset completed. Just
in case the caller then tries to do stuff.

This is called without the lock held
\end{quote}
\index{z8530\_channel\_load (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_channel_load}\pysiglinewithargsret{int \bfcode{z8530\_channel\_load}}{struct z8530\_channel *\emph{c}, u8 *\emph{rtable}}{}
Load channel data

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * c}}] \leavevmode
Z8530 channel to configure

\item[{\code{u8 * rtable}}] \leavevmode
table of register, value pairs
FIXME: ioctl to allow user uploaded tables

\end{description}

\textbf{Description}
\begin{quote}

Load a Z8530 channel up from the system data. We use +16 to
indicate the ``prime'' registers. The value 255 terminates the
table.
\end{quote}
\index{z8530\_null\_rx (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_null_rx}\pysiglinewithargsret{void \bfcode{z8530\_null\_rx}}{struct z8530\_channel *\emph{c}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
Discard a packet

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * c}}] \leavevmode
The channel the packet arrived on

\item[{\code{struct sk\_buff * skb}}] \leavevmode
The buffer

\end{description}

\textbf{Description}
\begin{quote}

We point the receive handler at this function when idle. Instead
of processing the frames we get to throw them away.
\end{quote}
\index{z8530\_queue\_xmit (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_queue_xmit}\pysiglinewithargsret{netdev\_tx\_t \bfcode{z8530\_queue\_xmit}}{struct z8530\_channel *\emph{c}, struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
Queue a packet

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * c}}] \leavevmode
The channel to use

\item[{\code{struct sk\_buff * skb}}] \leavevmode
The packet to kick down the channel

\end{description}

\textbf{Description}
\begin{quote}

Queue a packet for transmission. Because we have rather
hard to hit interrupt latencies for the Z85230 per packet
even in DMA mode we do the flip to DMA buffer if needed here
not in the IRQ.

Called from the network code. The lock is not held at this
point.
\end{quote}


\section{Internal Functions}
\label{networking/z8530book:internal-functions}\index{z8530\_read\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_read_port}\pysiglinewithargsret{int \bfcode{z8530\_read\_port}}{unsigned long\emph{p}}{}
Architecture specific interface function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long p}}] \leavevmode
port to read

\end{description}

\textbf{Description}
\begin{quote}

Provided port access methods. The Comtrol SV11 requires no delays
between accesses and uses PC I/O. Some drivers may need a 5uS delay

In the longer term this should become an architecture specific
section so that this can become a generic driver interface for all
platforms. For now we only handle PC I/O ports with or without the
dread 5uS sanity delay.

The caller must hold sufficient locks to avoid violating the horrible
5uS delay rule.
\end{quote}
\index{z8530\_write\_port (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_write_port}\pysiglinewithargsret{void \bfcode{z8530\_write\_port}}{unsigned long\emph{p}, u8\emph{d}}{}
Architecture specific interface function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long p}}] \leavevmode
port to write

\item[{\code{u8 d}}] \leavevmode
value to write

\end{description}

\textbf{Description}
\begin{quote}

Write a value to a port with delays if need be. Note that the
caller must hold locks to avoid read/writes from other contexts
violating the 5uS rule

In the longer term this should become an architecture specific
section so that this can become a generic driver interface for all
platforms. For now we only handle PC I/O ports with or without the
dread 5uS sanity delay.
\end{quote}
\index{read\_zsreg (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.read_zsreg}\pysiglinewithargsret{u8 \bfcode{read\_zsreg}}{struct z8530\_channel *\emph{c}, u8\emph{reg}}{}
Read a register from a Z85230

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * c}}] \leavevmode
Z8530 channel to read from (2 per chip)

\item[{\code{u8 reg}}] \leavevmode
Register to read
FIXME: Use a spinlock.

Most of the Z8530 registers are indexed off the control registers.
A read is done by writing to the control register and reading the
register back.  The caller must hold the lock

\end{description}
\index{read\_zsdata (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.read_zsdata}\pysiglinewithargsret{u8 \bfcode{read\_zsdata}}{struct z8530\_channel *\emph{c}}{}
Read the data port of a Z8530 channel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * c}}] \leavevmode
The Z8530 channel to read the data port from

\end{description}

\textbf{Description}
\begin{quote}

The data port provides fast access to some things. We still
have all the 5uS delays to worry about.
\end{quote}
\index{write\_zsreg (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.write_zsreg}\pysiglinewithargsret{void \bfcode{write\_zsreg}}{struct z8530\_channel *\emph{c}, u8\emph{reg}, u8\emph{val}}{}
Write to a Z8530 channel register

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * c}}] \leavevmode
The Z8530 channel

\item[{\code{u8 reg}}] \leavevmode
Register number

\item[{\code{u8 val}}] \leavevmode
Value to write

\end{description}

\textbf{Description}
\begin{quote}

Write a value to an indexed register. The caller must hold the lock
to honour the irritating delay rules. We know about register 0
being fast to access.

Assumes c-\textgreater{}lock is held.
\end{quote}
\index{write\_zsctrl (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.write_zsctrl}\pysiglinewithargsret{void \bfcode{write\_zsctrl}}{struct z8530\_channel *\emph{c}, u8\emph{val}}{}
Write to a Z8530 control register

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * c}}] \leavevmode
The Z8530 channel

\item[{\code{u8 val}}] \leavevmode
Value to write

\end{description}

\textbf{Description}
\begin{quote}

Write directly to the control register on the Z8530
\end{quote}
\index{write\_zsdata (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.write_zsdata}\pysiglinewithargsret{void \bfcode{write\_zsdata}}{struct z8530\_channel *\emph{c}, u8\emph{val}}{}
Write to a Z8530 control register

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * c}}] \leavevmode
The Z8530 channel

\item[{\code{u8 val}}] \leavevmode
Value to write

\end{description}

\textbf{Description}
\begin{quote}

Write directly to the data register on the Z8530
\end{quote}
\index{z8530\_flush\_fifo (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_flush_fifo}\pysiglinewithargsret{void \bfcode{z8530\_flush\_fifo}}{struct z8530\_channel *\emph{c}}{}
Flush on chip RX FIFO

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * c}}] \leavevmode
Channel to flush

\end{description}

\textbf{Description}
\begin{quote}

Flush the receive FIFO. There is no specific option for this, we
blindly read bytes and discard them. Reading when there is no data
is harmless. The 8530 has a 4 byte FIFO, the 85230 has 8 bytes.

All locking is handled for the caller. On return data may still be
present if it arrived during the flush.
\end{quote}
\index{z8530\_rtsdtr (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_rtsdtr}\pysiglinewithargsret{void \bfcode{z8530\_rtsdtr}}{struct z8530\_channel *\emph{c}, int\emph{set}}{}
Control the outgoing DTS/RTS line

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * c}}] \leavevmode
The Z8530 channel to control;

\item[{\code{int set}}] \leavevmode
1 to set, 0 to clear

\end{description}

\textbf{Description}
\begin{quote}

Sets or clears DTR/RTS on the requested line. All locking is handled
by the caller. For now we assume all boards use the actual RTS/DTR
on the chip. Apparently one or two don't. We'll scream about them
later.
\end{quote}
\index{z8530\_rx (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_rx}\pysiglinewithargsret{void \bfcode{z8530\_rx}}{struct z8530\_channel *\emph{c}}{}
Handle a PIO receive event

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * c}}] \leavevmode
Z8530 channel to process

\end{description}

\textbf{Description}
\begin{quote}

Receive handler for receiving in PIO mode. This is much like the
async one but not quite the same or as complex
\end{quote}

\textbf{Note}
\begin{description}
\item[{Its intended that this handler can easily be separated from}] \leavevmode
the main code to run realtime. That'll be needed for some machines
(eg to ever clock 64kbits on a sparc ;)).

The RT\_LOCK macros don't do anything now. Keep the code covered
by them as short as possible in all circumstances - clocks cost
baud. The interrupt handler is assumed to be atomic w.r.t. to
other code - this is true in the RT case too.

We only cover the sync cases for this. If you want 2Mbit async
do it yourself but consider medical assistance first. This non DMA
synchronous mode is portable code. The DMA mode assumes PCI like
ISA DMA

Called with the device lock held

\end{description}
\index{z8530\_tx (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_tx}\pysiglinewithargsret{void \bfcode{z8530\_tx}}{struct z8530\_channel *\emph{c}}{}
Handle a PIO transmit event

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * c}}] \leavevmode
Z8530 channel to process

\end{description}

\textbf{Description}
\begin{quote}

Z8530 transmit interrupt handler for the PIO mode. The basic
idea is to attempt to keep the FIFO fed. We fill as many bytes
in as possible, its quite possible that we won't keep up with the
data rate otherwise.
\end{quote}
\index{z8530\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_status}\pysiglinewithargsret{void \bfcode{z8530\_status}}{struct z8530\_channel *\emph{chan}}{}
Handle a PIO status exception

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * chan}}] \leavevmode
Z8530 channel to process

\end{description}

\textbf{Description}
\begin{quote}

A status event occurred in PIO synchronous mode. There are several
reasons the chip will bother us here. A transmit underrun means we
failed to feed the chip fast enough and just broke a packet. A DCD
change is a line up or down.
\end{quote}
\index{z8530\_dma\_rx (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_dma_rx}\pysiglinewithargsret{void \bfcode{z8530\_dma\_rx}}{struct z8530\_channel *\emph{chan}}{}
Handle a DMA RX event

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * chan}}] \leavevmode
Channel to handle

\end{description}

\textbf{Description}
\begin{quote}

Non bus mastering DMA interfaces for the Z8x30 devices. This
is really pretty PC specific. The DMA mode means that most receive
events are handled by the DMA hardware. We get a kick here only if
a frame ended.
\end{quote}
\index{z8530\_dma\_tx (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_dma_tx}\pysiglinewithargsret{void \bfcode{z8530\_dma\_tx}}{struct z8530\_channel *\emph{chan}}{}
Handle a DMA TX event

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * chan}}] \leavevmode
The Z8530 channel to handle

\end{description}

\textbf{Description}
\begin{quote}

We have received an interrupt while doing DMA transmissions. It
shouldn't happen. Scream loudly if it does.
\end{quote}
\index{z8530\_dma\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_dma_status}\pysiglinewithargsret{void \bfcode{z8530\_dma\_status}}{struct z8530\_channel *\emph{chan}}{}
Handle a DMA status exception

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * chan}}] \leavevmode
Z8530 channel to process

A status event occurred on the Z8530. We receive these for two reasons
when in DMA mode. Firstly if we finished a packet transfer we get one
and kick the next packet out. Secondly we may see a DCD change.

\end{description}
\index{z8530\_rx\_clear (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_rx_clear}\pysiglinewithargsret{void \bfcode{z8530\_rx\_clear}}{struct z8530\_channel *\emph{c}}{}
Handle RX events from a stopped chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * c}}] \leavevmode
Z8530 channel to shut up

\end{description}

\textbf{Description}
\begin{quote}

Receive interrupt vectors for a Z8530 that is in `parked' mode.
For machines with PCI Z85x30 cards, or level triggered interrupts
(eg the MacII) we must clear the interrupt cause or die.
\end{quote}
\index{z8530\_tx\_clear (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_tx_clear}\pysiglinewithargsret{void \bfcode{z8530\_tx\_clear}}{struct z8530\_channel *\emph{c}}{}
Handle TX events from a stopped chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * c}}] \leavevmode
Z8530 channel to shut up

\end{description}

\textbf{Description}
\begin{quote}

Transmit interrupt vectors for a Z8530 that is in `parked' mode.
For machines with PCI Z85x30 cards, or level triggered interrupts
(eg the MacII) we must clear the interrupt cause or die.
\end{quote}
\index{z8530\_status\_clear (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_status_clear}\pysiglinewithargsret{void \bfcode{z8530\_status\_clear}}{struct z8530\_channel *\emph{chan}}{}
Handle status events from a stopped chip

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * chan}}] \leavevmode
Z8530 channel to shut up

\end{description}

\textbf{Description}
\begin{quote}

Status interrupt vectors for a Z8530 that is in `parked' mode.
For machines with PCI Z85x30 cards, or level triggered interrupts
(eg the MacII) we must clear the interrupt cause or die.
\end{quote}
\index{z8530\_tx\_begin (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_tx_begin}\pysiglinewithargsret{void \bfcode{z8530\_tx\_begin}}{struct z8530\_channel *\emph{c}}{}
Begin packet transmission

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * c}}] \leavevmode
The Z8530 channel to kick

\end{description}

\textbf{Description}
\begin{quote}

This is the speed sensitive side of transmission. If we are called
and no buffer is being transmitted we commence the next buffer. If
nothing is queued we idle the sync.
\end{quote}

\textbf{Note}
\begin{description}
\item[{We are handling this code path in the interrupt path, keep it}] \leavevmode
fast or bad things will happen.

Called with the lock held.

\end{description}
\index{z8530\_tx\_done (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_tx_done}\pysiglinewithargsret{void \bfcode{z8530\_tx\_done}}{struct z8530\_channel *\emph{c}}{}
TX complete callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * c}}] \leavevmode
The channel that completed a transmit.

\end{description}

\textbf{Description}
\begin{quote}

This is called when we complete a packet send. We wake the queue,
start the next packet going and then free the buffer of the existing
packet. This code is fairly timing sensitive.

Called with the register lock held.
\end{quote}
\index{z8530\_rx\_done (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.z8530_rx_done}\pysiglinewithargsret{void \bfcode{z8530\_rx\_done}}{struct z8530\_channel *\emph{c}}{}
Receive completion callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct z8530\_channel * c}}] \leavevmode
The channel that completed a receive

\end{description}

\textbf{Description}
\begin{quote}

A new packet is complete. Our goal here is to get back into receive
mode as fast as possible. On the Z85230 we could change to using
ESCC mode, but on the older chips we have no choice. We flip to the
new buffer immediately in DMA mode so that the DMA of the next
frame can occur while we are copying the previous buffer to an sk\_buff

Called with the lock held
\end{quote}
\index{spans\_boundary (C function)}

\begin{fulllineitems}
\phantomsection\label{networking/z8530book:c.spans_boundary}\pysiglinewithargsret{int \bfcode{spans\_boundary}}{struct {\hyperref[networking/kapi:c.sk_buff]{\emph{sk\_buff}}} *\emph{skb}}{}
Check a packet can be ISA DMA'd

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct sk\_buff * skb}}] \leavevmode
The buffer to check

\end{description}

\textbf{Description}
\begin{quote}

Returns true if the buffer cross a DMA boundary on a PC. The poor
thing can only DMA within a 64K block not across the edges of it.
\end{quote}


\chapter{MSG\_ZEROCOPY}
\label{networking/msg_zerocopy::doc}\label{networking/msg_zerocopy:msg-zerocopy}

\section{Intro}
\label{networking/msg_zerocopy:intro}
The MSG\_ZEROCOPY flag enables copy avoidance for socket send calls.
The feature is currently implemented for TCP sockets.


\subsection{Opportunity and Caveats}
\label{networking/msg_zerocopy:opportunity-and-caveats}
Copying large buffers between user process and kernel can be
expensive. Linux supports various interfaces that eschew copying,
such as sendpage and splice. The MSG\_ZEROCOPY flag extends the
underlying copy avoidance mechanism to common socket send calls.

Copy avoidance is not a free lunch. As implemented, with page pinning,
it replaces per byte copy cost with page accounting and completion
notification overhead. As a result, MSG\_ZEROCOPY is generally only
effective at writes over around 10 KB.

Page pinning also changes system call semantics. It temporarily shares
the buffer between process and network stack. Unlike with copying, the
process cannot immediately overwrite the buffer after system call
return without possibly modifying the data in flight. Kernel integrity
is not affected, but a buggy program can possibly corrupt its own data
stream.

The kernel returns a notification when it is safe to modify data.
Converting an existing application to MSG\_ZEROCOPY is not always as
trivial as just passing the flag, then.


\subsection{More Info}
\label{networking/msg_zerocopy:more-info}
Much of this document was derived from a longer paper presented at
netdev 2.1. For more in-depth information see that paper and talk,
the excellent reporting over at LWN.net or read the original code.
\begin{quote}
\begin{description}
\item[{paper, slides, video}] \leavevmode
\href{https://netdevconf.org/2.1/session.html?debruijn}{https://netdevconf.org/2.1/session.html?debruijn}

\item[{LWN article}] \leavevmode
\href{https://lwn.net/Articles/726917/}{https://lwn.net/Articles/726917/}

\item[{patchset}] \leavevmode
{[}PATCH net-next v4 0/9{]} socket sendmsg MSG\_ZEROCOPY
\href{http://lkml.kernel.org/r/20170803202945.70750-1-willemdebruijn.kernel@gmail.com}{http://lkml.kernel.org/r/20170803202945.70750-1-willemdebruijn.kernel@gmail.com}

\end{description}
\end{quote}


\section{Interface}
\label{networking/msg_zerocopy:interface}
Passing the MSG\_ZEROCOPY flag is the most obvious step to enable copy
avoidance, but not the only one.


\subsection{Socket Setup}
\label{networking/msg_zerocopy:socket-setup}
The kernel is permissive when applications pass undefined flags to the
send system call. By default it simply ignores these. To avoid enabling
copy avoidance mode for legacy processes that accidentally already pass
this flag, a process must first signal intent by setting a socket option:

\begin{Verbatim}[commandchars=\\\{\}]
if (setsockopt(fd, SOL\PYGZus{}SOCKET, SO\PYGZus{}ZEROCOPY, \PYGZam{}one, sizeof(one)))
        error(1, errno, \PYGZdq{}setsockopt zerocopy\PYGZdq{});
\end{Verbatim}

Setting the socket option only works when the socket is in its initial
(TCP\_CLOSED) state.  Trying to set the option for a socket returned by accept(),
for example, will lead to an EBUSY error. In this case, the option should be set
to the listening socket and it will be inherited by the accepted sockets.


\subsection{Transmission}
\label{networking/msg_zerocopy:transmission}
The change to send (or sendto, sendmsg, sendmmsg) itself is trivial.
Pass the new flag.

\begin{Verbatim}[commandchars=\\\{\}]
ret = send(fd, buf, sizeof(buf), MSG\PYGZus{}ZEROCOPY);
\end{Verbatim}

A zerocopy failure will return -1 with errno ENOBUFS. This happens if
the socket option was not set, the socket exceeds its optmem limit or
the user exceeds its ulimit on locked pages.


\subsubsection{Mixing copy avoidance and copying}
\label{networking/msg_zerocopy:mixing-copy-avoidance-and-copying}
Many workloads have a mixture of large and small buffers. Because copy
avoidance is more expensive than copying for small packets, the
feature is implemented as a flag. It is safe to mix calls with the flag
with those without.


\subsection{Notifications}
\label{networking/msg_zerocopy:notifications}
The kernel has to notify the process when it is safe to reuse a
previously passed buffer. It queues completion notifications on the
socket error queue, akin to the transmit timestamping interface.

The notification itself is a simple scalar value. Each socket
maintains an internal unsigned 32-bit counter. Each send call with
MSG\_ZEROCOPY that successfully sends data increments the counter. The
counter is not incremented on failure or if called with length zero.
The counter counts system call invocations, not bytes. It wraps after
UINT\_MAX calls.


\subsubsection{Notification Reception}
\label{networking/msg_zerocopy:notification-reception}
The below snippet demonstrates the API. In the simplest case, each
send syscall is followed by a poll and recvmsg on the error queue.

Reading from the error queue is always a non-blocking operation. The
poll call is there to block until an error is outstanding. It will set
POLLERR in its output flags. That flag does not have to be set in the
events field. Errors are signaled unconditionally.

\begin{Verbatim}[commandchars=\\\{\}]
pfd.fd = fd;
pfd.events = 0;
if (poll(\PYGZam{}pfd, 1, \PYGZhy{}1) != 1 \textbar{}\textbar{} pfd.revents \PYGZam{} POLLERR == 0)
        error(1, errno, \PYGZdq{}poll\PYGZdq{});

ret = recvmsg(fd, \PYGZam{}msg, MSG\PYGZus{}ERRQUEUE);
if (ret == \PYGZhy{}1)
        error(1, errno, \PYGZdq{}recvmsg\PYGZdq{});

read\PYGZus{}notification(msg);
\end{Verbatim}

The example is for demonstration purpose only. In practice, it is more
efficient to not wait for notifications, but read without blocking
every couple of send calls.

Notifications can be processed out of order with other operations on
the socket. A socket that has an error queued would normally block
other operations until the error is read. Zerocopy notifications have
a zero error code, however, to not block send and recv calls.


\subsubsection{Notification Batching}
\label{networking/msg_zerocopy:notification-batching}
Multiple outstanding packets can be read at once using the recvmmsg
call. This is often not needed. In each message the kernel returns not
a single value, but a range. It coalesces consecutive notifications
while one is outstanding for reception on the error queue.

When a new notification is about to be queued, it checks whether the
new value extends the range of the notification at the tail of the
queue. If so, it drops the new notification packet and instead increases
the range upper value of the outstanding notification.

For protocols that acknowledge data in-order, like TCP, each
notification can be squashed into the previous one, so that no more
than one notification is outstanding at any one point.

Ordered delivery is the common case, but not guaranteed. Notifications
may arrive out of order on retransmission and socket teardown.


\subsubsection{Notification Parsing}
\label{networking/msg_zerocopy:notification-parsing}
The below snippet demonstrates how to parse the control message: the
read\_notification() call in the previous snippet. A notification
is encoded in the standard error format, sock\_extended\_err.

The level and type fields in the control data are protocol family
specific, IP\_RECVERR or IPV6\_RECVERR.

Error origin is the new type SO\_EE\_ORIGIN\_ZEROCOPY. ee\_errno is zero,
as explained before, to avoid blocking read and write system calls on
the socket.

The 32-bit notification range is encoded as {[}ee\_info, ee\_data{]}. This
range is inclusive. Other fields in the struct must be treated as
undefined, bar for ee\_code, as discussed below.

\begin{Verbatim}[commandchars=\\\{\}]
struct sock\PYGZus{}extended\PYGZus{}err *serr;
struct cmsghdr *cm;

cm = CMSG\PYGZus{}FIRSTHDR(msg);
if (cm\PYGZhy{}\PYGZgt{}cmsg\PYGZus{}level != SOL\PYGZus{}IP \PYGZam{}\PYGZam{}
    cm\PYGZhy{}\PYGZgt{}cmsg\PYGZus{}type != IP\PYGZus{}RECVERR)
        error(1, 0, \PYGZdq{}cmsg\PYGZdq{});

serr = (void *) CMSG\PYGZus{}DATA(cm);
if (serr\PYGZhy{}\PYGZgt{}ee\PYGZus{}errno != 0 \textbar{}\textbar{}
    serr\PYGZhy{}\PYGZgt{}ee\PYGZus{}origin != SO\PYGZus{}EE\PYGZus{}ORIGIN\PYGZus{}ZEROCOPY)
        error(1, 0, \PYGZdq{}serr\PYGZdq{});

printf(\PYGZdq{}completed: \PYGZpc{}u..\PYGZpc{}u\PYGZbs{}n\PYGZdq{}, serr\PYGZhy{}\PYGZgt{}ee\PYGZus{}info, serr\PYGZhy{}\PYGZgt{}ee\PYGZus{}data);
\end{Verbatim}


\subsubsection{Deferred copies}
\label{networking/msg_zerocopy:deferred-copies}
Passing flag MSG\_ZEROCOPY is a hint to the kernel to apply copy
avoidance, and a contract that the kernel will queue a completion
notification. It is not a guarantee that the copy is elided.

Copy avoidance is not always feasible. Devices that do not support
scatter-gather I/O cannot send packets made up of kernel generated
protocol headers plus zerocopy user data. A packet may need to be
converted to a private copy of data deep in the stack, say to compute
a checksum.

In all these cases, the kernel returns a completion notification when
it releases its hold on the shared pages. That notification may arrive
before the (copied) data is fully transmitted. A zerocopy completion
notification is not a transmit completion notification, therefore.

Deferred copies can be more expensive than a copy immediately in the
system call, if the data is no longer warm in the cache. The process
also incurs notification processing cost for no benefit. For this
reason, the kernel signals if data was completed with a copy, by
setting flag SO\_EE\_CODE\_ZEROCOPY\_COPIED in field ee\_code on return.
A process may use this signal to stop passing flag MSG\_ZEROCOPY on
subsequent requests on the same socket.


\section{Implementation}
\label{networking/msg_zerocopy:implementation}

\subsection{Loopback}
\label{networking/msg_zerocopy:loopback}
Data sent to local sockets can be queued indefinitely if the receive
process does not read its socket. Unbound notification latency is not
acceptable. For this reason all packets generated with MSG\_ZEROCOPY
that are looped to a local socket will incur a deferred copy. This
includes looping onto packet sockets (e.g., tcpdump) and tun devices.


\section{Testing}
\label{networking/msg_zerocopy:testing}
More realistic example code can be found in the kernel source under
tools/testing/selftests/net/msg\_zerocopy.c.

Be cognizant of the loopback constraint. The test can be run between
a pair of hosts. But if run between a local pair of processes, for
instance when run with msg\_zerocopy.sh between a veth pair across
namespaces, the test will not show any improvement. For testing, the
loopback restriction can be temporarily relaxed by making
skb\_orphan\_frags\_rx identical to skb\_orphan\_frags.



\renewcommand{\indexname}{Index}
\printindex
\end{document}
