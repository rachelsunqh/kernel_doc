% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,8pt,english]{sphinxmanual}


\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }


	% Use some font with UTF-8 support with XeLaTeX
        \usepackage{fontspec}
        \setsansfont{DejaVu Serif}
        \setromanfont{DejaVu Sans}
        \setmonofont{DejaVu Sans Mono}

     \usepackage[margin=0.5in, top=1in, bottom=1in]{geometry}
        \usepackage{ifthen}

        % Put notes in color and let them be inside a table
	\definecolor{NoteColor}{RGB}{204,255,255}
	\definecolor{WarningColor}{RGB}{255,204,204}
	\definecolor{AttentionColor}{RGB}{255,255,204}
	\definecolor{ImportantColor}{RGB}{192,255,204}
	\definecolor{OtherColor}{RGB}{204,204,204}
        \newlength{\mynoticelength}
        \makeatletter\newenvironment{coloredbox}[1]{%
	   \setlength{\fboxrule}{1pt}
	   \setlength{\fboxsep}{7pt}
	   \setlength{\mynoticelength}{\linewidth}
	   \addtolength{\mynoticelength}{-2\fboxsep}
	   \addtolength{\mynoticelength}{-2\fboxrule}
           \begin{lrbox}{\@tempboxa}\begin{minipage}{\mynoticelength}}{\end{minipage}\end{lrbox}%
	   \ifthenelse%
	      {\equal{\py@noticetype}{note}}%
	      {\colorbox{NoteColor}{\usebox{\@tempboxa}}}%
	      {%
	         \ifthenelse%
	         {\equal{\py@noticetype}{warning}}%
	         {\colorbox{WarningColor}{\usebox{\@tempboxa}}}%
		 {%
	            \ifthenelse%
	            {\equal{\py@noticetype}{attention}}%
	            {\colorbox{AttentionColor}{\usebox{\@tempboxa}}}%
		    {%
	               \ifthenelse%
	               {\equal{\py@noticetype}{important}}%
	               {\colorbox{ImportantColor}{\usebox{\@tempboxa}}}%
	               {\colorbox{OtherColor}{\usebox{\@tempboxa}}}%
		    }%
		 }%
	      }%
        }\makeatother

        \makeatletter
        \renewenvironment{notice}[2]{%
          \def\py@noticetype{#1}
          \begin{coloredbox}{#1}
          \bf\it
          \par\strong{#2}
          \csname py@noticestart@#1\endcsname
        }
	{
          \csname py@noticeend@\py@noticetype\endcsname
          \end{coloredbox}
        }
	\makeatother

     

\title{The Linux input driver subsystem}
\date{March 08, 2018}
\release{4.16.0-rc4+}
\author{The kernel development community}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\setcounter{tocdepth}{1}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{input/index::doc}


Contents:


\chapter{Linux Input Subsystem userspace API}
\label{input/input_uapi:the-linux-input-documentation}\label{input/input_uapi::doc}\label{input/input_uapi:linux-input-subsystem-userspace-api}
Table of Contents


\section{Introduction}
\label{input/input:introduction}\label{input/input::doc}\begin{quote}\begin{description}
\item[{Copyright}] \leavevmode
© 1999-2001 Vojtech Pavlik \textless{}\href{mailto:vojtech@ucw.cz}{vojtech@ucw.cz}\textgreater{} - Sponsored by SuSE

\end{description}\end{quote}


\subsection{Architecture}
\label{input/input:architecture}
Input subsystem  a collection of drivers that is designed to support
all input devices under Linux. Most of the drivers reside in
drivers/input, although quite a few live in drivers/hid and
drivers/platform.

The core of the input subsystem is the input module, which must be
loaded before any other of the input modules - it serves as a way of
communication between two groups of modules:


\subsubsection{Device drivers}
\label{input/input:device-drivers}
These modules talk to the hardware (for example via USB), and provide
events (keystrokes, mouse movements) to the input module.


\subsubsection{Event handlers}
\label{input/input:event-handlers}
These modules get events from input core and pass them where needed
via various interfaces - keystrokes to the kernel, mouse movements via
a simulated PS/2 interface to GPM and X, and so on.


\subsection{Simple Usage}
\label{input/input:simple-usage}
For the most usual configuration, with one USB mouse and one USB keyboard,
you'll have to load the following modules (or have them built in to the
kernel):

\begin{Verbatim}[commandchars=\\\{\}]
input
mousedev
usbcore
uhci\PYGZus{}hcd or ohci\PYGZus{}hcd or ehci\PYGZus{}hcd
usbhid
hid\PYGZus{}generic
\end{Verbatim}

After this, the USB keyboard will work straight away, and the USB mouse
will be available as a character device on major 13, minor 63:

\begin{Verbatim}[commandchars=\\\{\}]
crw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}   1 root     root      13,  63 Mar 28 22:45 mice
\end{Verbatim}

This device usually created automatically by the system. The commands
to create it by hand are:

\begin{Verbatim}[commandchars=\\\{\}]
cd /dev
mkdir input
mknod input/mice c 13 63
\end{Verbatim}

After that you have to point GPM (the textmode mouse cut\&paste tool) and
XFree to this device to use it - GPM should be called like:

\begin{Verbatim}[commandchars=\\\{\}]
gpm \PYGZhy{}t ps2 \PYGZhy{}m /dev/input/mice
\end{Verbatim}

And in X:

\begin{Verbatim}[commandchars=\\\{\}]
Section \PYGZdq{}Pointer\PYGZdq{}
    Protocol    \PYGZdq{}ImPS/2\PYGZdq{}
    Device      \PYGZdq{}/dev/input/mice\PYGZdq{}
    ZAxisMapping 4 5
EndSection
\end{Verbatim}

When you do all of the above, you can use your USB mouse and keyboard.


\subsection{Detailed Description}
\label{input/input:detailed-description}

\subsubsection{Event handlers}
\label{input/input:id1}
Event handlers distribute the events from the devices to userspace and
in-kernel consumers, as needed.


\paragraph{evdev}
\label{input/input:evdev}
\code{evdev} is the generic input event interface. It passes the events
generated in the kernel straight to the program, with timestamps. The
event codes are the same on all architectures and are hardware
independent.

This is the preferred interface for userspace to consume user
input, and all clients are encouraged to use it.

See {\hyperref[input/input:event\string-interface]{\emph{Event interface}}} for notes on API.

The devices are in /dev/input:

\begin{Verbatim}[commandchars=\\\{\}]
crw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}   1 root     root      13,  64 Apr  1 10:49 event0
crw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}   1 root     root      13,  65 Apr  1 10:50 event1
crw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}   1 root     root      13,  66 Apr  1 10:50 event2
crw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}   1 root     root      13,  67 Apr  1 10:50 event3
...
\end{Verbatim}

There are two ranges of minors: 64 through 95 is the static legacy
range. If there are more than 32 input devices in a system, additional
evdev nodes are created with minors starting with 256.


\paragraph{keyboard}
\label{input/input:keyboard}
\code{keyboard} is in-kernel input handler and is a part of VT code. It
consumes keyboard keystrokes and handles user input for VT consoles.


\paragraph{mousedev}
\label{input/input:mousedev}
\code{mousedev} is a hack to make legacy programs that use mouse input
work. It takes events from either mice or digitizers/tablets and makes
a PS/2-style (a la /dev/psaux) mouse device available to the
userland.

Mousedev devices in /dev/input (as shown above) are:

\begin{Verbatim}[commandchars=\\\{\}]
crw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}   1 root     root      13,  32 Mar 28 22:45 mouse0
crw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}   1 root     root      13,  33 Mar 29 00:41 mouse1
crw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}   1 root     root      13,  34 Mar 29 00:41 mouse2
crw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}   1 root     root      13,  35 Apr  1 10:50 mouse3
...
...
crw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}   1 root     root      13,  62 Apr  1 10:50 mouse30
crw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}   1 root     root      13,  63 Apr  1 10:50 mice
\end{Verbatim}

Each \code{mouse} device is assigned to a single mouse or digitizer, except
the last one - \code{mice}. This single character device is shared by all
mice and digitizers, and even if none are connected, the device is
present.  This is useful for hotplugging USB mice, so that older programs
that do not handle hotplug can open the device even when no mice are
present.

CONFIG\_INPUT\_MOUSEDEV\_SCREEN\_{[}XY{]} in the kernel configuration are
the size of your screen (in pixels) in XFree86. This is needed if you
want to use your digitizer in X, because its movement is sent to X
via a virtual PS/2 mouse and thus needs to be scaled
accordingly. These values won't be used if you use a mouse only.

Mousedev will generate either PS/2, ImPS/2 (Microsoft IntelliMouse) or
ExplorerPS/2 (IntelliMouse Explorer) protocols, depending on what the
program reading the data wishes. You can set GPM and X to any of
these. You'll need ImPS/2 if you want to make use of a wheel on a USB
mouse and ExplorerPS/2 if you want to use extra (up to 5) buttons.


\paragraph{joydev}
\label{input/input:joydev}
\code{joydev} implements v0.x and v1.x Linux joystick API. See
{\hyperref[input/joydev/joystick\string-api:joystick\string-api]{\emph{Programming Interface}}} for details.

As soon as any joystick is connected, it can be accessed in /dev/input on:

\begin{Verbatim}[commandchars=\\\{\}]
crw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}   1 root     root      13,   0 Apr  1 10:50 js0
crw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}   1 root     root      13,   1 Apr  1 10:50 js1
crw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}   1 root     root      13,   2 Apr  1 10:50 js2
crw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}   1 root     root      13,   3 Apr  1 10:50 js3
...
\end{Verbatim}

And so on up to js31 in legacy range, and additional nodes with minors
above 256 if there are more joystick devices.


\subsubsection{Device drivers}
\label{input/input:id2}
Device drivers are the modules that generate events.


\paragraph{hid-generic}
\label{input/input:hid-generic}
\code{hid-generic} is one of the largest and most complex driver of the
whole suite. It handles all HID devices, and because there is a very
wide variety of them, and because the USB HID specification isn't
simple, it needs to be this big.

Currently, it handles USB mice, joysticks, gamepads, steering wheels
keyboards, trackballs and digitizers.

However, USB uses HID also for monitor controls, speaker controls, UPSs,
LCDs and many other purposes.

The monitor and speaker controls should be easy to add to the hid/input
interface, but for the UPSs and LCDs it doesn't make much sense. For this,
the hiddev interface was designed. See Documentation/hid/hiddev.txt
for more information about it.

The usage of the usbhid module is very simple, it takes no parameters,
detects everything automatically and when a HID device is inserted, it
detects it appropriately.

However, because the devices vary wildly, you might happen to have a
device that doesn't work well. In that case \#define DEBUG at the beginning
of hid-core.c and send me the syslog traces.


\paragraph{usbmouse}
\label{input/input:usbmouse}
For embedded systems, for mice with broken HID descriptors and just any
other use when the big usbhid wouldn't be a good choice, there is the
usbmouse driver. It handles USB mice only. It uses a simpler HIDBP
protocol. This also means the mice must support this simpler protocol. Not
all do. If you don't have any strong reason to use this module, use usbhid
instead.


\paragraph{usbkbd}
\label{input/input:usbkbd}
Much like usbmouse, this module talks to keyboards with a simplified
HIDBP protocol. It's smaller, but doesn't support any extra special keys.
Use usbhid instead if there isn't any special reason to use this.


\paragraph{psmouse}
\label{input/input:psmouse}
This is driver for all flavors of pointing devices using PS/2
protocol, including Synaptics and ALPS touchpads, Intellimouse
Explorer devices, Logitech PS/2 mice and so on.


\paragraph{atkbd}
\label{input/input:atkbd}
This is driver for PS/2 (AT) keyboards.


\paragraph{iforce}
\label{input/input:iforce}
A driver for I-Force joysticks and wheels, both over USB and RS232.
It includes Force Feedback support now, even though Immersion
Corp. considers the protocol a trade secret and won't disclose a word
about it.


\subsection{Verifying if it works}
\label{input/input:verifying-if-it-works}
Typing a couple keys on the keyboard should be enough to check that
a keyboard works and is correctly connected to the kernel keyboard
driver.

Doing a \code{cat /dev/input/mouse0} (c, 13, 32) will verify that a mouse
is also emulated; characters should appear if you move it.

You can test the joystick emulation with the \code{jstest} utility,
available in the joystick package (see {\hyperref[input/joydev/joystick:joystick\string-doc]{\emph{Introduction}}}).

You can test the event devices with the \code{evtest} utility.


\subsection{Event interface}
\label{input/input:event-interface}\label{input/input:id3}
You can use blocking and nonblocking reads, and also select() on the
/dev/input/eventX devices, and you'll always get a whole number of input
events on a read. Their layout is:

\begin{Verbatim}[commandchars=\\\{\}]
struct input\PYGZus{}event \PYGZob{}
        struct timeval time;
        unsigned short type;
        unsigned short code;
        unsigned int value;
\PYGZcb{};
\end{Verbatim}

\code{time} is the timestamp, it returns the time at which the event happened.
Type is for example EV\_REL for relative moment, EV\_KEY for a keypress or
release. More types are defined in include/uapi/linux/input-event-codes.h.

\code{code} is event code, for example REL\_X or KEY\_BACKSPACE, again a complete
list is in include/uapi/linux/input-event-codes.h.

\code{value} is the value the event carries. Either a relative change for
EV\_REL, absolute new value for EV\_ABS (joysticks ...), or 0 for EV\_KEY for
release, 1 for keypress and 2 for autorepeat.

See {\hyperref[input/event\string-codes:input\string-event\string-codes]{\emph{Input event codes}}} for more information about various even codes.


\section{Input event codes}
\label{input/event-codes:input-event-codes}\label{input/event-codes::doc}\label{input/event-codes:id1}
The input protocol uses a map of types and codes to express input device values
to userspace. This document describes the types and codes and how and when they
may be used.

A single hardware event generates multiple input events. Each input event
contains the new value of a single data item. A special event type, EV\_SYN, is
used to separate input events into packets of input data changes occurring at
the same moment in time. In the following, the term ``event'' refers to a single
input event encompassing a type, code, and value.

The input protocol is a stateful protocol. Events are emitted only when values
of event codes have changed. However, the state is maintained within the Linux
input subsystem; drivers do not need to maintain the state and may attempt to
emit unchanged values without harm. Userspace may obtain the current state of
event code values using the EVIOCG* ioctls defined in linux/input.h. The event
reports supported by a device are also provided by sysfs in
class/input/event*/device/capabilities/, and the properties of a device are
provided in class/input/event*/device/properties.


\subsection{Event types}
\label{input/event-codes:event-types}
Event types are groupings of codes under a logical input construct. Each
type has a set of applicable codes to be used in generating events. See the
Codes section for details on valid codes for each type.
\begin{itemize}
\item {} 
EV\_SYN:
\begin{itemize}
\item {} 
Used as markers to separate events. Events may be separated in time or in
space, such as with the multitouch protocol.

\end{itemize}

\item {} 
EV\_KEY:
\begin{itemize}
\item {} 
Used to describe state changes of keyboards, buttons, or other key-like
devices.

\end{itemize}

\item {} 
EV\_REL:
\begin{itemize}
\item {} 
Used to describe relative axis value changes, e.g. moving the mouse 5 units
to the left.

\end{itemize}

\item {} 
EV\_ABS:
\begin{itemize}
\item {} 
Used to describe absolute axis value changes, e.g. describing the
coordinates of a touch on a touchscreen.

\end{itemize}

\item {} 
EV\_MSC:
\begin{itemize}
\item {} 
Used to describe miscellaneous input data that do not fit into other types.

\end{itemize}

\item {} 
EV\_SW:
\begin{itemize}
\item {} 
Used to describe binary state input switches.

\end{itemize}

\item {} 
EV\_LED:
\begin{itemize}
\item {} 
Used to turn LEDs on devices on and off.

\end{itemize}

\item {} 
EV\_SND:
\begin{itemize}
\item {} 
Used to output sound to devices.

\end{itemize}

\item {} 
EV\_REP:
\begin{itemize}
\item {} 
Used for autorepeating devices.

\end{itemize}

\item {} 
EV\_FF:
\begin{itemize}
\item {} 
Used to send force feedback commands to an input device.

\end{itemize}

\item {} 
EV\_PWR:
\begin{itemize}
\item {} 
A special type for power button and switch input.

\end{itemize}

\item {} 
EV\_FF\_STATUS:
\begin{itemize}
\item {} 
Used to receive force feedback device status.

\end{itemize}

\end{itemize}


\subsection{Event codes}
\label{input/event-codes:event-codes}
Event codes define the precise type of event.


\subsubsection{EV\_SYN}
\label{input/event-codes:ev-syn}
EV\_SYN event values are undefined. Their usage is defined only by when they are
sent in the evdev event stream.
\begin{itemize}
\item {} 
SYN\_REPORT:
\begin{itemize}
\item {} 
Used to synchronize and separate events into packets of input data changes
occurring at the same moment in time. For example, motion of a mouse may set
the REL\_X and REL\_Y values for one motion, then emit a SYN\_REPORT. The next
motion will emit more REL\_X and REL\_Y values and send another SYN\_REPORT.

\end{itemize}

\item {} 
SYN\_CONFIG:
\begin{itemize}
\item {} 
TBD

\end{itemize}

\item {} 
SYN\_MT\_REPORT:
\begin{itemize}
\item {} 
Used to synchronize and separate touch events. See the
multi-touch-protocol.txt document for more information.

\end{itemize}

\item {} 
SYN\_DROPPED:
\begin{itemize}
\item {} 
Used to indicate buffer overrun in the evdev client's event queue.
Client should ignore all events up to and including next SYN\_REPORT
event and query the device (using EVIOCG* ioctls) to obtain its
current state.

\end{itemize}

\end{itemize}


\subsubsection{EV\_KEY}
\label{input/event-codes:ev-key}
EV\_KEY events take the form KEY\_\textless{}name\textgreater{} or BTN\_\textless{}name\textgreater{}. For example, KEY\_A is used
to represent the `A' key on a keyboard. When a key is depressed, an event with
the key's code is emitted with value 1. When the key is released, an event is
emitted with value 0. Some hardware send events when a key is repeated. These
events have a value of 2. In general, KEY\_\textless{}name\textgreater{} is used for keyboard keys, and
BTN\_\textless{}name\textgreater{} is used for other types of momentary switch events.

A few EV\_KEY codes have special meanings:
\begin{itemize}
\item {} 
BTN\_TOOL\_\textless{}name\textgreater{}:
\begin{itemize}
\item {} 
These codes are used in conjunction with input trackpads, tablets, and
touchscreens. These devices may be used with fingers, pens, or other tools.
When an event occurs and a tool is used, the corresponding BTN\_TOOL\_\textless{}name\textgreater{}
code should be set to a value of 1. When the tool is no longer interacting
with the input device, the BTN\_TOOL\_\textless{}name\textgreater{} code should be reset to 0. All
trackpads, tablets, and touchscreens should use at least one BTN\_TOOL\_\textless{}name\textgreater{}
code when events are generated.

\end{itemize}

\item {} 
BTN\_TOUCH:
\begin{quote}

BTN\_TOUCH is used for touch contact. While an input tool is determined to be
within meaningful physical contact, the value of this property must be set
to 1. Meaningful physical contact may mean any contact, or it may mean
contact conditioned by an implementation defined property. For example, a
touchpad may set the value to 1 only when the touch pressure rises above a
certain value. BTN\_TOUCH may be combined with BTN\_TOOL\_\textless{}name\textgreater{} codes. For
example, a pen tablet may set BTN\_TOOL\_PEN to 1 and BTN\_TOUCH to 0 while the
pen is hovering over but not touching the tablet surface.
\end{quote}

\end{itemize}

Note: For appropriate function of the legacy mousedev emulation driver,
BTN\_TOUCH must be the first evdev code emitted in a synchronization frame.

Note: Historically a touch device with BTN\_TOOL\_FINGER and BTN\_TOUCH was
interpreted as a touchpad by userspace, while a similar device without
BTN\_TOOL\_FINGER was interpreted as a touchscreen. For backwards compatibility
with current userspace it is recommended to follow this distinction. In the
future, this distinction will be deprecated and the device properties ioctl
EVIOCGPROP, defined in linux/input.h, will be used to convey the device type.
\begin{itemize}
\item {} 
BTN\_TOOL\_FINGER, BTN\_TOOL\_DOUBLETAP, BTN\_TOOL\_TRIPLETAP, BTN\_TOOL\_QUADTAP:
\begin{itemize}
\item {} 
These codes denote one, two, three, and four finger interaction on a
trackpad or touchscreen. For example, if the user uses two fingers and moves
them on the touchpad in an effort to scroll content on screen,
BTN\_TOOL\_DOUBLETAP should be set to value 1 for the duration of the motion.
Note that all BTN\_TOOL\_\textless{}name\textgreater{} codes and the BTN\_TOUCH code are orthogonal in
purpose. A trackpad event generated by finger touches should generate events
for one code from each group. At most only one of these BTN\_TOOL\_\textless{}name\textgreater{}
codes should have a value of 1 during any synchronization frame.

\end{itemize}

\end{itemize}

Note: Historically some drivers emitted multiple of the finger count codes with
a value of 1 in the same synchronization frame. This usage is deprecated.

Note: In multitouch drivers, the input\_mt\_report\_finger\_count() function should
be used to emit these codes. Please see multi-touch-protocol.txt for details.


\subsubsection{EV\_REL}
\label{input/event-codes:ev-rel}
EV\_REL events describe relative changes in a property. For example, a mouse may
move to the left by a certain number of units, but its absolute position in
space is unknown. If the absolute position is known, EV\_ABS codes should be used
instead of EV\_REL codes.

A few EV\_REL codes have special meanings:
\begin{itemize}
\item {} 
REL\_WHEEL, REL\_HWHEEL:
\begin{itemize}
\item {} 
These codes are used for vertical and horizontal scroll wheels,
respectively.

\end{itemize}

\end{itemize}


\subsubsection{EV\_ABS}
\label{input/event-codes:ev-abs}
EV\_ABS events describe absolute changes in a property. For example, a touchpad
may emit coordinates for a touch location.

A few EV\_ABS codes have special meanings:
\begin{itemize}
\item {} 
ABS\_DISTANCE:
\begin{itemize}
\item {} 
Used to describe the distance of a tool from an interaction surface. This
event should only be emitted while the tool is hovering, meaning in close
proximity of the device and while the value of the BTN\_TOUCH code is 0. If
the input device may be used freely in three dimensions, consider ABS\_Z
instead.

\item {} 
BTN\_TOOL\_\textless{}name\textgreater{} should be set to 1 when the tool comes into detectable
proximity and set to 0 when the tool leaves detectable proximity.
BTN\_TOOL\_\textless{}name\textgreater{} signals the type of tool that is currently detected by the
hardware and is otherwise independent of ABS\_DISTANCE and/or BTN\_TOUCH.

\end{itemize}

\item {} 
ABS\_MT\_\textless{}name\textgreater{}:
\begin{itemize}
\item {} 
Used to describe multitouch input events. Please see
multi-touch-protocol.txt for details.

\end{itemize}

\end{itemize}


\subsubsection{EV\_SW}
\label{input/event-codes:ev-sw}
EV\_SW events describe stateful binary switches. For example, the SW\_LID code is
used to denote when a laptop lid is closed.

Upon binding to a device or resuming from suspend, a driver must report
the current switch state. This ensures that the device, kernel, and userspace
state is in sync.

Upon resume, if the switch state is the same as before suspend, then the input
subsystem will filter out the duplicate switch state reports. The driver does
not need to keep the state of the switch at any time.


\subsubsection{EV\_MSC}
\label{input/event-codes:ev-msc}
EV\_MSC events are used for input and output events that do not fall under other
categories.

A few EV\_MSC codes have special meaning:
\begin{itemize}
\item {} 
MSC\_TIMESTAMP:
\begin{itemize}
\item {} 
Used to report the number of microseconds since the last reset. This event
should be coded as an uint32 value, which is allowed to wrap around with
no special consequence. It is assumed that the time difference between two
consecutive events is reliable on a reasonable time scale (hours).
A reset to zero can happen, in which case the time since the last event is
unknown.  If the device does not provide this information, the driver must
not provide it to user space.

\end{itemize}

\end{itemize}


\subsubsection{EV\_LED}
\label{input/event-codes:ev-led}
EV\_LED events are used for input and output to set and query the state of
various LEDs on devices.


\subsubsection{EV\_REP}
\label{input/event-codes:ev-rep}
EV\_REP events are used for specifying autorepeating events.


\subsubsection{EV\_SND}
\label{input/event-codes:ev-snd}
EV\_SND events are used for sending sound commands to simple sound output
devices.


\subsubsection{EV\_FF}
\label{input/event-codes:ev-ff}
EV\_FF events are used to initialize a force feedback capable device and to cause
such device to feedback.


\subsubsection{EV\_PWR}
\label{input/event-codes:ev-pwr}
EV\_PWR events are a special type of event used specifically for power
management. Its usage is not well defined. To be addressed later.


\subsection{Device properties}
\label{input/event-codes:device-properties}
Normally, userspace sets up an input device based on the data it emits,
i.e., the event types. In the case of two devices emitting the same event
types, additional information can be provided in the form of device
properties.


\subsubsection{INPUT\_PROP\_DIRECT + INPUT\_PROP\_POINTER}
\label{input/event-codes:input-prop-direct-input-prop-pointer}
The INPUT\_PROP\_DIRECT property indicates that device coordinates should be
directly mapped to screen coordinates (not taking into account trivial
transformations, such as scaling, flipping and rotating). Non-direct input
devices require non-trivial transformation, such as absolute to relative
transformation for touchpads. Typical direct input devices: touchscreens,
drawing tablets; non-direct devices: touchpads, mice.

The INPUT\_PROP\_POINTER property indicates that the device is not transposed
on the screen and thus requires use of an on-screen pointer to trace user's
movements.  Typical pointer devices: touchpads, tablets, mice; non-pointer
device: touchscreen.

If neither INPUT\_PROP\_DIRECT or INPUT\_PROP\_POINTER are set, the property is
considered undefined and the device type should be deduced in the
traditional way, using emitted event types.


\subsubsection{INPUT\_PROP\_BUTTONPAD}
\label{input/event-codes:input-prop-buttonpad}
For touchpads where the button is placed beneath the surface, such that
pressing down on the pad causes a button click, this property should be
set. Common in clickpad notebooks and macbooks from 2009 and onwards.

Originally, the buttonpad property was coded into the bcm5974 driver
version field under the name integrated button. For backwards
compatibility, both methods need to be checked in userspace.


\subsubsection{INPUT\_PROP\_SEMI\_MT}
\label{input/event-codes:input-prop-semi-mt}
Some touchpads, most common between 2008 and 2011, can detect the presence
of multiple contacts without resolving the individual positions; only the
number of contacts and a rectangular shape is known. For such
touchpads, the semi-mt property should be set.

Depending on the device, the rectangle may enclose all touches, like a
bounding box, or just some of them, for instance the two most recent
touches. The diversity makes the rectangle of limited use, but some
gestures can normally be extracted from it.

If INPUT\_PROP\_SEMI\_MT is not set, the device is assumed to be a true MT
device.


\subsubsection{INPUT\_PROP\_TOPBUTTONPAD}
\label{input/event-codes:input-prop-topbuttonpad}
Some laptops, most notably the Lenovo 40 series provide a trackstick
device but do not have physical buttons associated with the trackstick
device. Instead, the top area of the touchpad is marked to show
visual/haptic areas for left, middle, right buttons intended to be used
with the trackstick.

If INPUT\_PROP\_TOPBUTTONPAD is set, userspace should emulate buttons
accordingly. This property does not affect kernel behavior.
The kernel does not provide button emulation for such devices but treats
them as any other INPUT\_PROP\_BUTTONPAD device.


\subsubsection{INPUT\_PROP\_ACCELEROMETER}
\label{input/event-codes:input-prop-accelerometer}
Directional axes on this device (absolute and/or relative x, y, z) represent
accelerometer data. Some devices also report gyroscope data, which devices
can report through the rotational axes (absolute and/or relative rx, ry, rz).

All other axes retain their meaning. A device must not mix
regular directional axes and accelerometer axes on the same event node.


\subsection{Guidelines}
\label{input/event-codes:guidelines}
The guidelines below ensure proper single-touch and multi-finger functionality.
For multi-touch functionality, see the multi-touch-protocol.txt document for
more information.


\subsubsection{Mice}
\label{input/event-codes:mice}
REL\_\{X,Y\} must be reported when the mouse moves. BTN\_LEFT must be used to report
the primary button press. BTN\_\{MIDDLE,RIGHT,4,5,etc.\} should be used to report
further buttons of the device. REL\_WHEEL and REL\_HWHEEL should be used to report
scroll wheel events where available.


\subsubsection{Touchscreens}
\label{input/event-codes:touchscreens}
ABS\_\{X,Y\} must be reported with the location of the touch. BTN\_TOUCH must be
used to report when a touch is active on the screen.
BTN\_\{MOUSE,LEFT,MIDDLE,RIGHT\} must not be reported as the result of touch
contact. BTN\_TOOL\_\textless{}name\textgreater{} events should be reported where possible.

For new hardware, INPUT\_PROP\_DIRECT should be set.


\subsubsection{Trackpads}
\label{input/event-codes:trackpads}
Legacy trackpads that only provide relative position information must report
events like mice described above.

Trackpads that provide absolute touch position must report ABS\_\{X,Y\} for the
location of the touch. BTN\_TOUCH should be used to report when a touch is active
on the trackpad. Where multi-finger support is available, BTN\_TOOL\_\textless{}name\textgreater{} should
be used to report the number of touches active on the trackpad.

For new hardware, INPUT\_PROP\_POINTER should be set.


\subsubsection{Tablets}
\label{input/event-codes:tablets}
BTN\_TOOL\_\textless{}name\textgreater{} events must be reported when a stylus or other tool is active on
the tablet. ABS\_\{X,Y\} must be reported with the location of the tool. BTN\_TOUCH
should be used to report when the tool is in contact with the tablet.
BTN\_\{STYLUS,STYLUS2\} should be used to report buttons on the tool itself. Any
button may be used for buttons on the tablet except BTN\_\{MOUSE,LEFT\}.
BTN\_\{0,1,2,etc\} are good generic codes for unlabeled buttons. Do not use
meaningful buttons, like BTN\_FORWARD, unless the button is labeled for that
purpose on the device.

For new hardware, both INPUT\_PROP\_DIRECT and INPUT\_PROP\_POINTER should be set.


\section{Multi-touch (MT) Protocol}
\label{input/multi-touch-protocol::doc}\label{input/multi-touch-protocol:multi-touch-mt-protocol}\begin{quote}\begin{description}
\item[{Copyright}] \leavevmode
© 2009-2010    Henrik Rydberg \textless{}\href{mailto:rydberg@euromail.se}{rydberg@euromail.se}\textgreater{}

\end{description}\end{quote}


\subsection{Introduction}
\label{input/multi-touch-protocol:introduction}
In order to utilize the full power of the new multi-touch and multi-user
devices, a way to report detailed data from multiple contacts, i.e.,
objects in direct contact with the device surface, is needed.  This
document describes the multi-touch (MT) protocol which allows kernel
drivers to report details for an arbitrary number of contacts.

The protocol is divided into two types, depending on the capabilities of the
hardware. For devices handling anonymous contacts (type A), the protocol
describes how to send the raw data for all contacts to the receiver. For
devices capable of tracking identifiable contacts (type B), the protocol
describes how to send updates for individual contacts via event slots.

\begin{notice}{note}{Note:}
MT potocol type A is obsolete, all kernel drivers have been
converted to use type B.
\end{notice}


\subsection{Protocol Usage}
\label{input/multi-touch-protocol:protocol-usage}
Contact details are sent sequentially as separate packets of ABS\_MT
events. Only the ABS\_MT events are recognized as part of a contact
packet. Since these events are ignored by current single-touch (ST)
applications, the MT protocol can be implemented on top of the ST protocol
in an existing driver.

Drivers for type A devices separate contact packets by calling
input\_mt\_sync() at the end of each packet. This generates a SYN\_MT\_REPORT
event, which instructs the receiver to accept the data for the current
contact and prepare to receive another.

Drivers for type B devices separate contact packets by calling
input\_mt\_slot(), with a slot as argument, at the beginning of each packet.
This generates an ABS\_MT\_SLOT event, which instructs the receiver to
prepare for updates of the given slot.

All drivers mark the end of a multi-touch transfer by calling the usual
input\_sync() function. This instructs the receiver to act upon events
accumulated since last EV\_SYN/SYN\_REPORT and prepare to receive a new set
of events/packets.

The main difference between the stateless type A protocol and the stateful
type B slot protocol lies in the usage of identifiable contacts to reduce
the amount of data sent to userspace. The slot protocol requires the use of
the ABS\_MT\_TRACKING\_ID, either provided by the hardware or computed from
the raw data \footnote[5]{
See the section on finger tracking.
}.

For type A devices, the kernel driver should generate an arbitrary
enumeration of the full set of anonymous contacts currently on the
surface. The order in which the packets appear in the event stream is not
important.  Event filtering and finger tracking is left to user space \footnote[3]{
The mtdev project: \href{http://bitmath.org/code/mtdev/}{http://bitmath.org/code/mtdev/}.
}.

For type B devices, the kernel driver should associate a slot with each
identified contact, and use that slot to propagate changes for the contact.
Creation, replacement and destruction of contacts is achieved by modifying
the ABS\_MT\_TRACKING\_ID of the associated slot.  A non-negative tracking id
is interpreted as a contact, and the value -1 denotes an unused slot.  A
tracking id not previously present is considered new, and a tracking id no
longer present is considered removed.  Since only changes are propagated,
the full state of each initiated contact has to reside in the receiving
end.  Upon receiving an MT event, one simply updates the appropriate
attribute of the current slot.

Some devices identify and/or track more contacts than they can report to the
driver.  A driver for such a device should associate one type B slot with each
contact that is reported by the hardware.  Whenever the identity of the
contact associated with a slot changes, the driver should invalidate that
slot by changing its ABS\_MT\_TRACKING\_ID.  If the hardware signals that it is
tracking more contacts than it is currently reporting, the driver should use
a BTN\_TOOL\_*TAP event to inform userspace of the total number of contacts
being tracked by the hardware at that moment.  The driver should do this by
explicitly sending the corresponding BTN\_TOOL\_*TAP event and setting
use\_count to false when calling input\_mt\_report\_pointer\_emulation().
The driver should only advertise as many slots as the hardware can report.
Userspace can detect that a driver can report more total contacts than slots
by noting that the largest supported BTN\_TOOL\_*TAP event is larger than the
total number of type B slots reported in the absinfo for the ABS\_MT\_SLOT axis.

The minimum value of the ABS\_MT\_SLOT axis must be 0.


\subsection{Protocol Example A}
\label{input/multi-touch-protocol:protocol-example-a}
Here is what a minimal event sequence for a two-contact touch would look
like for a type A device:

\begin{Verbatim}[commandchars=\\\{\}]
ABS\PYGZus{}MT\PYGZus{}POSITION\PYGZus{}X x[0]
ABS\PYGZus{}MT\PYGZus{}POSITION\PYGZus{}Y y[0]
SYN\PYGZus{}MT\PYGZus{}REPORT
ABS\PYGZus{}MT\PYGZus{}POSITION\PYGZus{}X x[1]
ABS\PYGZus{}MT\PYGZus{}POSITION\PYGZus{}Y y[1]
SYN\PYGZus{}MT\PYGZus{}REPORT
SYN\PYGZus{}REPORT
\end{Verbatim}

The sequence after moving one of the contacts looks exactly the same; the
raw data for all present contacts are sent between every synchronization
with SYN\_REPORT.

Here is the sequence after lifting the first contact:

\begin{Verbatim}[commandchars=\\\{\}]
ABS\PYGZus{}MT\PYGZus{}POSITION\PYGZus{}X x[1]
ABS\PYGZus{}MT\PYGZus{}POSITION\PYGZus{}Y y[1]
SYN\PYGZus{}MT\PYGZus{}REPORT
SYN\PYGZus{}REPORT
\end{Verbatim}

And here is the sequence after lifting the second contact:

\begin{Verbatim}[commandchars=\\\{\}]
SYN\PYGZus{}MT\PYGZus{}REPORT
SYN\PYGZus{}REPORT
\end{Verbatim}

If the driver reports one of BTN\_TOUCH or ABS\_PRESSURE in addition to the
ABS\_MT events, the last SYN\_MT\_REPORT event may be omitted. Otherwise, the
last SYN\_REPORT will be dropped by the input core, resulting in no
zero-contact event reaching userland.


\subsection{Protocol Example B}
\label{input/multi-touch-protocol:protocol-example-b}
Here is what a minimal event sequence for a two-contact touch would look
like for a type B device:

\begin{Verbatim}[commandchars=\\\{\}]
ABS\PYGZus{}MT\PYGZus{}SLOT 0
ABS\PYGZus{}MT\PYGZus{}TRACKING\PYGZus{}ID 45
ABS\PYGZus{}MT\PYGZus{}POSITION\PYGZus{}X x[0]
ABS\PYGZus{}MT\PYGZus{}POSITION\PYGZus{}Y y[0]
ABS\PYGZus{}MT\PYGZus{}SLOT 1
ABS\PYGZus{}MT\PYGZus{}TRACKING\PYGZus{}ID 46
ABS\PYGZus{}MT\PYGZus{}POSITION\PYGZus{}X x[1]
ABS\PYGZus{}MT\PYGZus{}POSITION\PYGZus{}Y y[1]
SYN\PYGZus{}REPORT
\end{Verbatim}

Here is the sequence after moving contact 45 in the x direction:

\begin{Verbatim}[commandchars=\\\{\}]
ABS\PYGZus{}MT\PYGZus{}SLOT 0
ABS\PYGZus{}MT\PYGZus{}POSITION\PYGZus{}X x[0]
SYN\PYGZus{}REPORT
\end{Verbatim}

Here is the sequence after lifting the contact in slot 0:

\begin{Verbatim}[commandchars=\\\{\}]
ABS\PYGZus{}MT\PYGZus{}TRACKING\PYGZus{}ID \PYGZhy{}1
SYN\PYGZus{}REPORT
\end{Verbatim}

The slot being modified is already 0, so the ABS\_MT\_SLOT is omitted.  The
message removes the association of slot 0 with contact 45, thereby
destroying contact 45 and freeing slot 0 to be reused for another contact.

Finally, here is the sequence after lifting the second contact:

\begin{Verbatim}[commandchars=\\\{\}]
ABS\PYGZus{}MT\PYGZus{}SLOT 1
ABS\PYGZus{}MT\PYGZus{}TRACKING\PYGZus{}ID \PYGZhy{}1
SYN\PYGZus{}REPORT
\end{Verbatim}


\subsection{Event Usage}
\label{input/multi-touch-protocol:event-usage}
A set of ABS\_MT events with the desired properties is defined. The events
are divided into categories, to allow for partial implementation.  The
minimum set consists of ABS\_MT\_POSITION\_X and ABS\_MT\_POSITION\_Y, which
allows for multiple contacts to be tracked.  If the device supports it, the
ABS\_MT\_TOUCH\_MAJOR and ABS\_MT\_WIDTH\_MAJOR may be used to provide the size
of the contact area and approaching tool, respectively.

The TOUCH and WIDTH parameters have a geometrical interpretation; imagine
looking through a window at someone gently holding a finger against the
glass.  You will see two regions, one inner region consisting of the part
of the finger actually touching the glass, and one outer region formed by
the perimeter of the finger. The center of the touching region (a) is
ABS\_MT\_POSITION\_X/Y and the center of the approaching finger (b) is
ABS\_MT\_TOOL\_X/Y. The touch diameter is ABS\_MT\_TOUCH\_MAJOR and the finger
diameter is ABS\_MT\_WIDTH\_MAJOR. Now imagine the person pressing the finger
harder against the glass. The touch region will increase, and in general,
the ratio ABS\_MT\_TOUCH\_MAJOR / ABS\_MT\_WIDTH\_MAJOR, which is always smaller
than unity, is related to the contact pressure. For pressure-based devices,
ABS\_MT\_PRESSURE may be used to provide the pressure on the contact area
instead. Devices capable of contact hovering can use ABS\_MT\_DISTANCE to
indicate the distance between the contact and the surface.

\begin{Verbatim}[commandchars=\\\{\}]
     Linux MT                               Win8
    \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}                     \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
   /          \PYGZbs{}                   \textbar{}                       \textbar{}
  /            \PYGZbs{}                  \textbar{}                       \textbar{}
 /     \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}     \PYGZbs{}                 \textbar{}                       \textbar{}
/     /    \PYGZbs{}     \PYGZbs{}                \textbar{}                       \textbar{}
\PYGZbs{}     \PYGZbs{}  a  \PYGZbs{}     \PYGZbs{}               \textbar{}       a               \textbar{}
 \PYGZbs{}     \PYGZbs{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}/      \PYGZbs{}              \textbar{}                       \textbar{}
  \PYGZbs{}                 \PYGZbs{}             \textbar{}                       \textbar{}
   \PYGZbs{}        b        \PYGZbs{}            \textbar{}           b           \textbar{}
    \PYGZbs{}                 \PYGZbs{}           \textbar{}                       \textbar{}
     \PYGZbs{}                 \PYGZbs{}          \textbar{}                       \textbar{}
      \PYGZbs{}                 \PYGZbs{}         \textbar{}                       \textbar{}
       \PYGZbs{}                /         \textbar{}                       \textbar{}
        \PYGZbs{}              /          \textbar{}                       \textbar{}
         \PYGZbs{}            /           \textbar{}                       \textbar{}
          \PYGZbs{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}/            \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}
\end{Verbatim}

In addition to the MAJOR parameters, the oval shape of the touch and finger
regions can be described by adding the MINOR parameters, such that MAJOR
and MINOR are the major and minor axis of an ellipse. The orientation of
the touch ellipse can be described with the ORIENTATION parameter, and the
direction of the finger ellipse is given by the vector (a - b).

For type A devices, further specification of the touch shape is possible
via ABS\_MT\_BLOB\_ID.

The ABS\_MT\_TOOL\_TYPE may be used to specify whether the touching tool is a
finger or a pen or something else. Finally, the ABS\_MT\_TRACKING\_ID event
may be used to track identified contacts over time \footnotemark[5].

In the type B protocol, ABS\_MT\_TOOL\_TYPE and ABS\_MT\_TRACKING\_ID are
implicitly handled by input core; drivers should instead call
input\_mt\_report\_slot\_state().


\subsection{Event Semantics}
\label{input/multi-touch-protocol:event-semantics}\begin{description}
\item[{ABS\_MT\_TOUCH\_MAJOR}] \leavevmode
The length of the major axis of the contact. The length should be given in
surface units. If the surface has an X times Y resolution, the largest
possible value of ABS\_MT\_TOUCH\_MAJOR is sqrt(X\textasciicircum{}2 + Y\textasciicircum{}2), the diagonal \footnote[4]{
See the section on event computation.
}.

\item[{ABS\_MT\_TOUCH\_MINOR}] \leavevmode
The length, in surface units, of the minor axis of the contact. If the
contact is circular, this event can be omitted \footnotemark[4].

\item[{ABS\_MT\_WIDTH\_MAJOR}] \leavevmode
The length, in surface units, of the major axis of the approaching
tool. This should be understood as the size of the tool itself. The
orientation of the contact and the approaching tool are assumed to be the
same \footnotemark[4].

\item[{ABS\_MT\_WIDTH\_MINOR}] \leavevmode
The length, in surface units, of the minor axis of the approaching
tool. Omit if circular \footnotemark[4].

The above four values can be used to derive additional information about
the contact. The ratio ABS\_MT\_TOUCH\_MAJOR / ABS\_MT\_WIDTH\_MAJOR approximates
the notion of pressure. The fingers of the hand and the palm all have
different characteristic widths.

\item[{ABS\_MT\_PRESSURE}] \leavevmode
The pressure, in arbitrary units, on the contact area. May be used instead
of TOUCH and WIDTH for pressure-based devices or any device with a spatial
signal intensity distribution.

\item[{ABS\_MT\_DISTANCE}] \leavevmode
The distance, in surface units, between the contact and the surface. Zero
distance means the contact is touching the surface. A positive number means
the contact is hovering above the surface.

\item[{ABS\_MT\_ORIENTATION}] \leavevmode
The orientation of the touching ellipse. The value should describe a signed
quarter of a revolution clockwise around the touch center. The signed value
range is arbitrary, but zero should be returned for an ellipse aligned with
the Y axis (north) of the surface, a negative value when the ellipse is
turned to the left, and a positive value when the ellipse is turned to the
right. When aligned with the X axis in the positive direction, the range
max should be returned; when aligned with the X axis in the negative
direction, the range -max should be returned.

Touch ellipsis are symmetrical by default. For devices capable of true 360
degree orientation, the reported orientation must exceed the range max to
indicate more than a quarter of a revolution. For an upside-down finger,
range max * 2 should be returned.

Orientation can be omitted if the touch area is circular, or if the
information is not available in the kernel driver. Partial orientation
support is possible if the device can distinguish between the two axis, but
not (uniquely) any values in between. In such cases, the range of
ABS\_MT\_ORIENTATION should be {[}0, 1{]} \footnotemark[4].

\item[{ABS\_MT\_POSITION\_X}] \leavevmode
The surface X coordinate of the center of the touching ellipse.

\item[{ABS\_MT\_POSITION\_Y}] \leavevmode
The surface Y coordinate of the center of the touching ellipse.

\item[{ABS\_MT\_TOOL\_X}] \leavevmode
The surface X coordinate of the center of the approaching tool. Omit if
the device cannot distinguish between the intended touch point and the
tool itself.

\item[{ABS\_MT\_TOOL\_Y}] \leavevmode
The surface Y coordinate of the center of the approaching tool. Omit if the
device cannot distinguish between the intended touch point and the tool
itself.

The four position values can be used to separate the position of the touch
from the position of the tool. If both positions are present, the major
tool axis points towards the touch point \footnote[1]{
Also, the difference (TOOL\_X - POSITION\_X) can be used to model tilt.
}. Otherwise, the tool axes are
aligned with the touch axes.

\item[{ABS\_MT\_TOOL\_TYPE}] \leavevmode
The type of approaching tool. A lot of kernel drivers cannot distinguish
between different tool types, such as a finger or a pen. In such cases, the
event should be omitted. The protocol currently supports MT\_TOOL\_FINGER,
MT\_TOOL\_PEN, and MT\_TOOL\_PALM \footnote[2]{
The list can of course be extended.
}. For type B devices, this event is
handled by input core; drivers should instead use
input\_mt\_report\_slot\_state(). A contact's ABS\_MT\_TOOL\_TYPE may change over
time while still touching the device, because the firmware may not be able
to determine which tool is being used when it first appears.

\item[{ABS\_MT\_BLOB\_ID}] \leavevmode
The BLOB\_ID groups several packets together into one arbitrarily shaped
contact. The sequence of points forms a polygon which defines the shape of
the contact. This is a low-level anonymous grouping for type A devices, and
should not be confused with the high-level trackingID \footnotemark[5]. Most type A
devices do not have blob capability, so drivers can safely omit this event.

\item[{ABS\_MT\_TRACKING\_ID}] \leavevmode
The TRACKING\_ID identifies an initiated contact throughout its life cycle
\footnotemark[5]. The value range of the TRACKING\_ID should be large enough to ensure
unique identification of a contact maintained over an extended period of
time. For type B devices, this event is handled by input core; drivers
should instead use input\_mt\_report\_slot\_state().

\end{description}


\subsection{Event Computation}
\label{input/multi-touch-protocol:event-computation}
The flora of different hardware unavoidably leads to some devices fitting
better to the MT protocol than others. To simplify and unify the mapping,
this section gives recipes for how to compute certain events.

For devices reporting contacts as rectangular shapes, signed orientation
cannot be obtained. Assuming X and Y are the lengths of the sides of the
touching rectangle, here is a simple formula that retains the most
information possible:

\begin{Verbatim}[commandchars=\\\{\}]
ABS\PYGZus{}MT\PYGZus{}TOUCH\PYGZus{}MAJOR := max(X, Y)
ABS\PYGZus{}MT\PYGZus{}TOUCH\PYGZus{}MINOR := min(X, Y)
ABS\PYGZus{}MT\PYGZus{}ORIENTATION := bool(X \PYGZgt{} Y)
\end{Verbatim}

The range of ABS\_MT\_ORIENTATION should be set to {[}0, 1{]}, to indicate that
the device can distinguish between a finger along the Y axis (0) and a
finger along the X axis (1).

For win8 devices with both T and C coordinates, the position mapping is:

\begin{Verbatim}[commandchars=\\\{\}]
ABS\PYGZus{}MT\PYGZus{}POSITION\PYGZus{}X := T\PYGZus{}X
ABS\PYGZus{}MT\PYGZus{}POSITION\PYGZus{}Y := T\PYGZus{}Y
ABS\PYGZus{}MT\PYGZus{}TOOL\PYGZus{}X := C\PYGZus{}X
ABS\PYGZus{}MT\PYGZus{}TOOL\PYGZus{}Y := C\PYGZus{}Y
\end{Verbatim}

Unfortunately, there is not enough information to specify both the touching
ellipse and the tool ellipse, so one has to resort to approximations.  One
simple scheme, which is compatible with earlier usage, is:

\begin{Verbatim}[commandchars=\\\{\}]
ABS\PYGZus{}MT\PYGZus{}TOUCH\PYGZus{}MAJOR := min(X, Y)
ABS\PYGZus{}MT\PYGZus{}TOUCH\PYGZus{}MINOR := \PYGZlt{}not used\PYGZgt{}
ABS\PYGZus{}MT\PYGZus{}ORIENTATION := \PYGZlt{}not used\PYGZgt{}
ABS\PYGZus{}MT\PYGZus{}WIDTH\PYGZus{}MAJOR := min(X, Y) + distance(T, C)
ABS\PYGZus{}MT\PYGZus{}WIDTH\PYGZus{}MINOR := min(X, Y)
\end{Verbatim}

Rationale: We have no information about the orientation of the touching
ellipse, so approximate it with an inscribed circle instead. The tool
ellipse should align with the vector (T - C), so the diameter must
increase with distance(T, C). Finally, assume that the touch diameter is
equal to the tool thickness, and we arrive at the formulas above.


\subsection{Finger Tracking}
\label{input/multi-touch-protocol:finger-tracking}
The process of finger tracking, i.e., to assign a unique trackingID to each
initiated contact on the surface, is a Euclidian Bipartite Matching
problem.  At each event synchronization, the set of actual contacts is
matched to the set of contacts from the previous synchronization. A full
implementation can be found in \footnotemark[3].


\subsection{Gestures}
\label{input/multi-touch-protocol:gestures}
In the specific application of creating gesture events, the TOUCH and WIDTH
parameters can be used to, e.g., approximate finger pressure or distinguish
between index finger and thumb. With the addition of the MINOR parameters,
one can also distinguish between a sweeping finger and a pointing finger,
and with ORIENTATION, one can detect twisting of fingers.


\subsection{Notes}
\label{input/multi-touch-protocol:notes}
In order to stay compatible with existing applications, the data reported
in a finger packet must not be recognized as single-touch events.

For type A devices, all finger data bypasses input filtering, since
subsequent events of the same type refer to different fingers.


\section{Linux Gamepad Specification}
\label{input/gamepad::doc}\label{input/gamepad:linux-gamepad-specification}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
2013 by David Herrmann \textless{}\href{mailto:dh.herrmann@gmail.com}{dh.herrmann@gmail.com}\textgreater{}

\end{description}\end{quote}


\subsection{Introduction}
\label{input/gamepad:introduction}
Linux provides many different input drivers for gamepad hardware. To avoid
having user-space deal with different button-mappings for each gamepad, this
document defines how gamepads are supposed to report their data.


\subsection{Geometry}
\label{input/gamepad:geometry}
As ``gamepad'' we define devices which roughly look like this:

\begin{Verbatim}[commandchars=\\\{\}]
          \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}              \PYGZus{}\PYGZus{}
         / [\PYGZus{}\PYGZus{}ZL\PYGZus{}\PYGZus{}]          [\PYGZus{}\PYGZus{}ZR\PYGZus{}\PYGZus{}] \PYGZbs{}               \textbar{}
        / [\PYGZus{}\PYGZus{} TL \PYGZus{}\PYGZus{}]        [\PYGZus{}\PYGZus{} TR \PYGZus{}\PYGZus{}] \PYGZbs{}              \textbar{} Front Triggers
     \PYGZus{}\PYGZus{}/\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZbs{}\PYGZus{}\PYGZus{}         \PYGZus{}\PYGZus{}\textbar{}
    /                                  \PYGZus{}   \PYGZbs{}          \textbar{}
   /      /\PYGZbs{}           \PYGZus{}\PYGZus{}             (N)   \PYGZbs{}         \textbar{}
  /       \textbar{}\textbar{}      \PYGZus{}\PYGZus{}  \textbar{}MO\textbar{}  \PYGZus{}\PYGZus{}     \PYGZus{}       \PYGZus{} \PYGZbs{}        \textbar{} Main Pad
 \textbar{}    \PYGZlt{}===DP===\PYGZgt{} \textbar{}SE\textbar{}      \textbar{}ST\textbar{}   (W) \PYGZhy{}\textbar{}\PYGZhy{} (E) \textbar{}       \textbar{}
  \PYGZbs{}       \textbar{}\textbar{}    \PYGZus{}\PYGZus{}\PYGZus{}          \PYGZus{}\PYGZus{}\PYGZus{}       \PYGZus{}     /        \textbar{}
  /\PYGZbs{}      \PYGZbs{}/   /   \PYGZbs{}        /   \PYGZbs{}     (S)   /\PYGZbs{}      \PYGZus{}\PYGZus{}\textbar{}
 /  \PYGZbs{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{} \textbar{} LS  \textbar{} \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{} \textbar{}  RS \textbar{} \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}/  \PYGZbs{}       \textbar{}
\textbar{}         /  \PYGZbs{} \PYGZbs{}\PYGZus{}\PYGZus{}\PYGZus{}/ /    \PYGZbs{} \PYGZbs{}\PYGZus{}\PYGZus{}\PYGZus{}/ /  \PYGZbs{}         \textbar{}      \textbar{} Control Sticks
\textbar{}        /    \PYGZbs{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}/      \PYGZbs{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}/    \PYGZbs{}        \textbar{}    \PYGZus{}\PYGZus{}\textbar{}
\textbar{}       /                              \PYGZbs{}       \textbar{}
 \PYGZbs{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}/                                \PYGZbs{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}/

     \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}    \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}
       D\PYGZhy{}Pad    Left       Right   Action Pad
               Stick       Stick

                 \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}
                    Menu Pad
\end{Verbatim}

Most gamepads have the following features:
\begin{itemize}
\item {} 
Action-Pad
4 buttons in diamonds-shape (on the right side). The buttons are
differently labeled on most devices so we define them as NORTH,
SOUTH, WEST and EAST.

\item {} 
D-Pad (Direction-pad)
4 buttons (on the left side) that point up, down, left and right.

\item {} 
Menu-Pad
Different constellations, but most-times 2 buttons: SELECT - START
Furthermore, many gamepads have a fancy branded button that is used as
special system-button. It often looks different to the other buttons and
is used to pop up system-menus or system-settings.

\item {} 
Analog-Sticks
Analog-sticks provide freely moveable sticks to control directions. Not
all devices have both or any, but they are present at most times.
Analog-sticks may also provide a digital button if you press them.

\item {} 
Triggers
Triggers are located on the upper-side of the pad in vertical direction.
Not all devices provide them, but the upper buttons are normally named
Left- and Right-Triggers, the lower buttons Z-Left and Z-Right.

\item {} 
Rumble
Many devices provide force-feedback features. But are mostly just
simple rumble motors.

\end{itemize}


\subsection{Detection}
\label{input/gamepad:detection}
All gamepads that follow the protocol described here map BTN\_GAMEPAD. This is
an alias for BTN\_SOUTH/BTN\_A. It can be used to identify a gamepad as such.
However, not all gamepads provide all features, so you need to test for all
features that you need, first. How each feature is mapped is described below.

Legacy drivers often don't comply to these rules. As we cannot change them
for backwards-compatibility reasons, you need to provide fixup mappings in
user-space yourself. Some of them might also provide module-options that
change the mappings so you can advise users to set these.

All new gamepads are supposed to comply with this mapping. Please report any
bugs, if they don't.

There are a lot of less-featured/less-powerful devices out there, which re-use
the buttons from this protocol. However, they try to do this in a compatible
fashion. For example, the ``Nintendo Wii Nunchuk'' provides two trigger buttons
and one analog stick. It reports them as if it were a gamepad with only one
analog stick and two trigger buttons on the right side.
But that means, that if you only support ``real'' gamepads, you must test
devices for \_all\_ reported events that you need. Otherwise, you will also get
devices that report a small subset of the events.

No other devices, that do not look/feel like a gamepad, shall report these
events.


\subsection{Events}
\label{input/gamepad:events}
Gamepads report the following events:
\begin{itemize}
\item {} 
Action-Pad:

Every gamepad device has at least 2 action buttons. This means, that every
device reports BTN\_SOUTH (which BTN\_GAMEPAD is an alias for). Regardless
of the labels on the buttons, the codes are sent according to the
physical position of the buttons.

Please note that 2- and 3-button pads are fairly rare and old. You might
want to filter gamepads that do not report all four.
\begin{itemize}
\item {} 
2-Button Pad:

If only 2 action-buttons are present, they are reported as BTN\_SOUTH and
BTN\_EAST. For vertical layouts, the upper button is BTN\_EAST. For
horizontal layouts, the button more on the right is BTN\_EAST.

\item {} 
3-Button Pad:

If only 3 action-buttons are present, they are reported as (from left
to right): BTN\_WEST, BTN\_SOUTH, BTN\_EAST
If the buttons are aligned perfectly vertically, they are reported as
(from top down): BTN\_WEST, BTN\_SOUTH, BTN\_EAST

\item {} 
4-Button Pad:

If all 4 action-buttons are present, they can be aligned in two
different formations. If diamond-shaped, they are reported as BTN\_NORTH,
BTN\_WEST, BTN\_SOUTH, BTN\_EAST according to their physical location.
If rectangular-shaped, the upper-left button is BTN\_NORTH, lower-left
is BTN\_WEST, lower-right is BTN\_SOUTH and upper-right is BTN\_EAST.

\end{itemize}

\item {} 
D-Pad:

Every gamepad provides a D-Pad with four directions: Up, Down, Left, Right
Some of these are available as digital buttons, some as analog buttons. Some
may even report both. The kernel does not convert between these so
applications should support both and choose what is more appropriate if
both are reported.
\begin{itemize}
\item {} 
Digital buttons are reported as:

BTN\_DPAD\_*

\item {} 
Analog buttons are reported as:

ABS\_HAT0X and ABS\_HAT0Y

\end{itemize}

(for ABS values negative is left/up, positive is right/down)

\item {} 
Analog-Sticks:

The left analog-stick is reported as ABS\_X, ABS\_Y. The right analog stick is
reported as ABS\_RX, ABS\_RY. Zero, one or two sticks may be present.
If analog-sticks provide digital buttons, they are mapped accordingly as
BTN\_THUMBL (first/left) and BTN\_THUMBR (second/right).

(for ABS values negative is left/up, positive is right/down)

\item {} 
Triggers:

Trigger buttons can be available as digital or analog buttons or both. User-
space must correctly deal with any situation and choose the most appropriate
mode.

Upper trigger buttons are reported as BTN\_TR or ABS\_HAT1X (right) and BTN\_TL
or ABS\_HAT1Y (left). Lower trigger buttons are reported as BTN\_TR2 or
ABS\_HAT2X (right/ZR) and BTN\_TL2 or ABS\_HAT2Y (left/ZL).

If only one trigger-button combination is present (upper+lower), they are
reported as ``right'' triggers (BTN\_TR/ABS\_HAT1X).

(ABS trigger values start at 0, pressure is reported as positive values)

\item {} 
Menu-Pad:

Menu buttons are always digital and are mapped according to their location
instead of their labels. That is:
\begin{itemize}
\item {} 
1-button Pad:

Mapped as BTN\_START

\item {} 
2-button Pad:

Left button mapped as BTN\_SELECT, right button mapped as BTN\_START

\end{itemize}

Many pads also have a third button which is branded or has a special symbol
and meaning. Such buttons are mapped as BTN\_MODE. Examples are the Nintendo
``HOME'' button, the XBox ``X''-button or Sony ``PS'' button.

\item {} 
Rumble:

Rumble is advertised as FF\_RUMBLE.

\end{itemize}


\section{Force feedback for Linux}
\label{input/ff:force-feedback-for-linux}\label{input/ff::doc}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Johann Deneux \textless{}\href{mailto:johann.deneux@gmail.com}{johann.deneux@gmail.com}\textgreater{} on 2001/04/22.

\item[{Updated}] \leavevmode
Anssi Hannula \textless{}\href{mailto:anssi.hannula@gmail.com}{anssi.hannula@gmail.com}\textgreater{} on 2006/04/09.

\end{description}\end{quote}

You may redistribute this file. Please remember to include shape.svg and
interactive.svg as well.


\subsection{Introduction}
\label{input/ff:introduction}
This document describes how to use force feedback devices under Linux. The
goal is not to support these devices as if they were simple input-only devices
(as it is already the case), but to really enable the rendering of force
effects.
This document only describes the force feedback part of the Linux input
interface. Please read joystick.txt and input.txt before reading further this
document.


\subsection{Instructions to the user}
\label{input/ff:instructions-to-the-user}
To enable force feedback, you have to:
\begin{enumerate}
\item {} 
have your kernel configured with evdev and a driver that supports your
device.

\item {} 
make sure evdev module is loaded and /dev/input/event* device files are
created.

\end{enumerate}

Before you start, let me WARN you that some devices shake violently during the
initialisation phase. This happens for example with my ``AVB Top Shot Pegasus''.
To stop this annoying behaviour, move your joystick to its limits. Anyway, you
should keep a hand on your device, in order to avoid it to break down if
something goes wrong.

If you have a serial iforce device, you need to start inputattach. See
joystick.txt for details.


\subsubsection{Does it work ?}
\label{input/ff:does-it-work}
There is an utility called fftest that will allow you to test the driver:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} fftest /dev/input/eventXX
\end{Verbatim}


\subsection{Instructions to the developer}
\label{input/ff:instructions-to-the-developer}
All interactions are done using the event API. That is, you can use ioctl()
and write() on /dev/input/eventXX.
This information is subject to change.


\subsubsection{Querying device capabilities}
\label{input/ff:querying-device-capabilities}
\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}linux/input.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}sys/ioctl.h\PYGZgt{}

\PYGZsh{}define BITS\PYGZus{}TO\PYGZus{}LONGS(x) \PYGZbs{}
        (((x) + 8 * sizeof (unsigned long) \PYGZhy{} 1) / (8 * sizeof (unsigned long)))
unsigned long features[BITS\PYGZus{}TO\PYGZus{}LONGS(FF\PYGZus{}CNT)];
int ioctl(int file\PYGZus{}descriptor, int request, unsigned long *features);
\end{Verbatim}

``request'' must be EVIOCGBIT(EV\_FF, size of features array in bytes )

Returns the features supported by the device. features is a bitfield with the
following bits:
\begin{itemize}
\item {} 
FF\_CONSTANT   can render constant force effects

\item {} 
FF\_PERIODIC   can render periodic effects with the following waveforms:
\begin{itemize}
\item {} 
FF\_SQUARE     square waveform

\item {} 
FF\_TRIANGLE   triangle waveform

\item {} 
FF\_SINE       sine waveform

\item {} 
FF\_SAW\_UP     sawtooth up waveform

\item {} 
FF\_SAW\_DOWN   sawtooth down waveform

\item {} 
FF\_CUSTOM     custom waveform

\end{itemize}

\item {} 
FF\_RAMP       can render ramp effects

\item {} 
FF\_SPRING     can simulate the presence of a spring

\item {} 
FF\_FRICTION   can simulate friction

\item {} 
FF\_DAMPER     can simulate damper effects

\item {} 
FF\_RUMBLE     rumble effects

\item {} 
FF\_INERTIA    can simulate inertia

\item {} 
FF\_GAIN       gain is adjustable

\item {} 
FF\_AUTOCENTER autocenter is adjustable

\end{itemize}

\begin{notice}{note}{Note:}\begin{itemize}
\item {} 
In most cases you should use FF\_PERIODIC instead of FF\_RUMBLE. All
devices that support FF\_RUMBLE support FF\_PERIODIC (square, triangle,
sine) and the other way around.

\item {} 
The exact syntax FF\_CUSTOM is undefined for the time being as no driver
supports it yet.

\end{itemize}
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
int ioctl(int fd, EVIOCGEFFECTS, int *n);
\end{Verbatim}

Returns the number of effects the device can keep in its memory.


\subsubsection{Uploading effects to the device}
\label{input/ff:uploading-effects-to-the-device}
\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}linux/input.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}sys/ioctl.h\PYGZgt{}

int ioctl(int file\PYGZus{}descriptor, int request, struct ff\PYGZus{}effect *effect);
\end{Verbatim}

``request'' must be EVIOCSFF.

``effect'' points to a structure describing the effect to upload. The effect is
uploaded, but not played.
The content of effect may be modified. In particular, its field ``id'' is set
to the unique id assigned by the driver. This data is required for performing
some operations (removing an effect, controlling the playback).
The ``id'' field must be set to -1 by the user in order to tell the driver to
allocate a new effect.

Effects are file descriptor specific.

See \textless{}uapi/linux/input.h\textgreater{} for a description of the ff\_effect struct.  You
should also find help in a few sketches, contained in files shape.svg
and interactive.svg:
\begin{figure}[htbp]
\centering
\capstart

\includegraphics{{shape}.pdf}
\caption{Shape}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\includegraphics{{interactive}.pdf}
\caption{Interactive}\end{figure}


\subsubsection{Removing an effect from the device}
\label{input/ff:removing-an-effect-from-the-device}
\begin{Verbatim}[commandchars=\\\{\}]
int ioctl(int fd, EVIOCRMFF, effect.id);
\end{Verbatim}

This makes room for new effects in the device's memory. Note that this also
stops the effect if it was playing.


\subsubsection{Controlling the playback of effects}
\label{input/ff:controlling-the-playback-of-effects}
Control of playing is done with write(). Below is an example:

\begin{Verbatim}[commandchars=\\\{\}]
 \PYGZsh{}include \PYGZlt{}linux/input.h\PYGZgt{}
 \PYGZsh{}include \PYGZlt{}unistd.h\PYGZgt{}

     struct input\PYGZus{}event play;
     struct input\PYGZus{}event stop;
     struct ff\PYGZus{}effect effect;
     int fd;
...
     fd = open(\PYGZdq{}/dev/input/eventXX\PYGZdq{}, O\PYGZus{}RDWR);
...
     /* Play three times */
     play.type = EV\PYGZus{}FF;
     play.code = effect.id;
     play.value = 3;

     write(fd, (const void*) \PYGZam{}play, sizeof(play));
...
     /* Stop an effect */
     stop.type = EV\PYGZus{}FF;
     stop.code = effect.id;
     stop.value = 0;

     write(fd, (const void*) \PYGZam{}stop, sizeof(stop));
\end{Verbatim}


\subsubsection{Setting the gain}
\label{input/ff:setting-the-gain}
Not all devices have the same strength. Therefore, users should set a gain
factor depending on how strong they want effects to be. This setting is
persistent across access to the driver.

\begin{Verbatim}[commandchars=\\\{\}]
/* Set the gain of the device
int gain;           /* between 0 and 100 */
struct input\PYGZus{}event ie;      /* structure used to communicate with the driver */

ie.type = EV\PYGZus{}FF;
ie.code = FF\PYGZus{}GAIN;
ie.value = 0xFFFFUL * gain / 100;

if (write(fd, \PYGZam{}ie, sizeof(ie)) == \PYGZhy{}1)
    perror(\PYGZdq{}set gain\PYGZdq{});
\end{Verbatim}


\subsubsection{Enabling/Disabling autocenter}
\label{input/ff:enabling-disabling-autocenter}
The autocenter feature quite disturbs the rendering of effects in my opinion,
and I think it should be an effect, which computation depends on the game
type. But you can enable it if you want.

\begin{Verbatim}[commandchars=\\\{\}]
int autocenter;             /* between 0 and 100 */
struct input\PYGZus{}event ie;

ie.type = EV\PYGZus{}FF;
ie.code = FF\PYGZus{}AUTOCENTER;
ie.value = 0xFFFFUL * autocenter / 100;

if (write(fd, \PYGZam{}ie, sizeof(ie)) == \PYGZhy{}1)
    perror(\PYGZdq{}set auto\PYGZhy{}center\PYGZdq{});
\end{Verbatim}

A value of 0 means ``no auto-center''.


\subsubsection{Dynamic update of an effect}
\label{input/ff:dynamic-update-of-an-effect}
Proceed as if you wanted to upload a new effect, except that instead of
setting the id field to -1, you set it to the wanted effect id.
Normally, the effect is not stopped and restarted. However, depending on the
type of device, not all parameters can be dynamically updated. For example,
the direction of an effect cannot be updated with iforce devices. In this
case, the driver stops the effect, up-load it, and restart it.

Therefore it is recommended to dynamically change direction while the effect
is playing only when it is ok to restart the effect with a replay count of 1.


\subsubsection{Information about the status of effects}
\label{input/ff:information-about-the-status-of-effects}
Every time the status of an effect is changed, an event is sent. The values
and meanings of the fields of the event are as follows:

\begin{Verbatim}[commandchars=\\\{\}]
struct input\PYGZus{}event \PYGZob{}
/* When the status of the effect changed */
        struct timeval time;

/* Set to EV\PYGZus{}FF\PYGZus{}STATUS */
        unsigned short type;

/* Contains the id of the effect */
        unsigned short code;

/* Indicates the status */
        unsigned int value;
\PYGZcb{};

FF\PYGZus{}STATUS\PYGZus{}STOPPED   The effect stopped playing
FF\PYGZus{}STATUS\PYGZus{}PLAYING   The effect started to play
\end{Verbatim}

\begin{notice}{note}{Note:}\begin{itemize}
\item {} 
Status feedback is only supported by iforce driver. If you have
a really good reason to use this, please contact
\href{mailto:linux-joystick@atrey.karlin.mff.cuni.cz}{linux-joystick@atrey.karlin.mff.cuni.cz} or \href{mailto:anssi.hannula@gmail.com}{anssi.hannula@gmail.com}
so that support for it can be added to the rest of the drivers.

\end{itemize}
\end{notice}


\section{Linux Joystick support}
\label{input/joydev/index::doc}\label{input/joydev/index:linux-joystick-support}\begin{quote}\begin{description}
\item[{Copyright}] \leavevmode
© 1996-2000 Vojtech Pavlik \textless{}\href{mailto:vojtech@ucw.cz}{vojtech@ucw.cz}\textgreater{} - Sponsored by SuSE

\end{description}\end{quote}

Table of Contents


\subsection{Introduction}
\label{input/joydev/joystick:introduction}\label{input/joydev/joystick::doc}\label{input/joydev/joystick:joystick-doc}
The joystick driver for Linux provides support for a variety of joysticks
and similar devices. It is based on a larger project aiming to support all
input devices in Linux.

The mailing list for the project is:
\begin{quote}

\href{mailto:linux-input@vger.kernel.org}{linux-input@vger.kernel.org}
\end{quote}

send ``subscribe linux-input'' to \href{mailto:majordomo@vger.kernel.org}{majordomo@vger.kernel.org} to subscribe to it.


\subsection{Usage}
\label{input/joydev/joystick:usage}
For basic usage you just choose the right options in kernel config and
you should be set.


\subsubsection{Utilities}
\label{input/joydev/joystick:utilities}
For testing and other purposes (for example serial devices), there is a set
of utilities, such as \code{jstest}, \code{jscal}, and \code{evtest},
usually packaged as \code{joystick}, \code{input-utils}, \code{evtest}, and so on.

\code{inputattach} utility is required if your joystick is connected to a
serial port.


\subsubsection{Device nodes}
\label{input/joydev/joystick:device-nodes}
For applications to be able to use the joysticks, device nodes should be
created in /dev. Normally it is done automatically by the system, but
it can also be done by hand:

\begin{Verbatim}[commandchars=\\\{\}]
cd /dev
rm js*
mkdir input
mknod input/js0 c 13 0
mknod input/js1 c 13 1
mknod input/js2 c 13 2
mknod input/js3 c 13 3
ln \PYGZhy{}s input/js0 js0
ln \PYGZhy{}s input/js1 js1
ln \PYGZhy{}s input/js2 js2
ln \PYGZhy{}s input/js3 js3
\end{Verbatim}

For testing with inpututils it's also convenient to create these:

\begin{Verbatim}[commandchars=\\\{\}]
mknod input/event0 c 13 64
mknod input/event1 c 13 65
mknod input/event2 c 13 66
mknod input/event3 c 13 67
\end{Verbatim}


\subsubsection{Modules needed}
\label{input/joydev/joystick:modules-needed}
For all joystick drivers to function, you'll need the userland interface
module in kernel, either loaded or compiled in:

\begin{Verbatim}[commandchars=\\\{\}]
modprobe joydev
\end{Verbatim}

For gameport joysticks, you'll have to load the gameport driver as well:

\begin{Verbatim}[commandchars=\\\{\}]
modprobe ns558
\end{Verbatim}

And for serial port joysticks, you'll need the serial input line
discipline module loaded and the inputattach utility started:

\begin{Verbatim}[commandchars=\\\{\}]
modprobe serport
inputattach \PYGZhy{}xxx /dev/tts/X \PYGZam{}
\end{Verbatim}

In addition to that, you'll need the joystick driver module itself, most
usually you'll have an analog joystick:

\begin{Verbatim}[commandchars=\\\{\}]
modprobe analog
\end{Verbatim}

For automatic module loading, something like this might work - tailor to
your needs:

\begin{Verbatim}[commandchars=\\\{\}]
alias tty\PYGZhy{}ldisc\PYGZhy{}2 serport
alias char\PYGZhy{}major\PYGZhy{}13 input
above input joydev ns558 analog
options analog map=gamepad,none,2btn
\end{Verbatim}


\subsubsection{Verifying that it works}
\label{input/joydev/joystick:verifying-that-it-works}
For testing the joystick driver functionality, there is the jstest
program in the utilities package. You run it by typing:

\begin{Verbatim}[commandchars=\\\{\}]
jstest /dev/input/js0
\end{Verbatim}

And it should show a line with the joystick values, which update as you
move the stick, and press its buttons. The axes should all be zero when the
joystick is in the center position. They should not jitter by themselves to
other close values, and they also should be steady in any other position of
the stick. They should have the full range from -32767 to 32767. If all this
is met, then it's all fine, and you can play the games. :)

If it's not, then there might be a problem. Try to calibrate the joystick,
and if it still doesn't work, read the drivers section of this file, the
troubleshooting section, and the FAQ.


\subsubsection{Calibration}
\label{input/joydev/joystick:calibration}
For most joysticks you won't need any manual calibration, since the
joystick should be autocalibrated by the driver automagically. However, with
some analog joysticks, that either do not use linear resistors, or if you
want better precision, you can use the jscal program:

\begin{Verbatim}[commandchars=\\\{\}]
jscal \PYGZhy{}c /dev/input/js0
\end{Verbatim}

included in the joystick package to set better correction coefficients than
what the driver would choose itself.

After calibrating the joystick you can verify if you like the new
calibration using the jstest command, and if you do, you then can save the
correction coefficients into a file:

\begin{Verbatim}[commandchars=\\\{\}]
jscal \PYGZhy{}p /dev/input/js0 \PYGZgt{} /etc/joystick.cal
\end{Verbatim}

And add a line to your rc script executing that file:

\begin{Verbatim}[commandchars=\\\{\}]
source /etc/joystick.cal
\end{Verbatim}

This way, after the next reboot your joystick will remain calibrated. You
can also add the \code{jscal -p} line to your shutdown script.


\subsection{HW specific driver information}
\label{input/joydev/joystick:hw-specific-driver-information}
In this section each of the separate hardware specific drivers is described.


\subsubsection{Analog joysticks}
\label{input/joydev/joystick:analog-joysticks}
The analog.c uses the standard analog inputs of the gameport, and thus
supports all standard joysticks and gamepads. It uses a very advanced
routine for this, allowing for data precision that can't be found on any
other system.

It also supports extensions like additional hats and buttons compatible
with CH Flightstick Pro, ThrustMaster FCS or 6 and 8 button gamepads. Saitek
Cyborg `digital' joysticks are also supported by this driver, because
they're basically souped up CHF sticks.

However the only types that can be autodetected are:
\begin{itemize}
\item {} 
2-axis, 4-button joystick

\item {} 
3-axis, 4-button joystick

\item {} 
4-axis, 4-button joystick

\item {} 
Saitek Cyborg `digital' joysticks

\end{itemize}

For other joystick types (more/less axes, hats, and buttons) support
you'll need to specify the types either on the kernel command line or on the
module command line, when inserting analog into the kernel. The
parameters are:

\begin{Verbatim}[commandchars=\\\{\}]
analog.map=\PYGZlt{}type1\PYGZgt{},\PYGZlt{}type2\PYGZgt{},\PYGZlt{}type3\PYGZgt{},....
\end{Verbatim}

`type' is type of the joystick from the table below, defining joysticks
present on gameports in the system, starting with gameport0, second `type'
entry defining joystick on gameport1 and so on.
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Type
} & \textsf{\relax 
Meaning
}\\
\hline
none
 & 
No analog joystick on that port
\\
\hline
auto
 & 
Autodetect joystick
\\
\hline
2btn
 & 
2-button n-axis joystick
\\
\hline
y-joy
 & 
Two 2-button 2-axis joysticks on an Y-cable
\\
\hline
y-pad
 & 
Two 2-button 2-axis gamepads on an Y-cable
\\
\hline
fcs
 & 
Thrustmaster FCS compatible joystick
\\
\hline
chf
 & 
Joystick with a CH Flightstick compatible hat
\\
\hline
fullchf
 & 
CH Flightstick compatible with two hats and 6 buttons
\\
\hline
gamepad
 & 
4/6-button n-axis gamepad
\\
\hline
gamepad8
 & 
8-button 2-axis gamepad
\\
\hline\end{tabulary}

\end{quote}

In case your joystick doesn't fit in any of the above categories, you can
specify the type as a number by combining the bits in the table below. This
is not recommended unless you really know what are you doing. It's not
dangerous, but not simple either.
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Bit
} & \textsf{\relax 
Meaning
}\\
\hline
0
 & 
Axis X1
\\
\hline
1
 & 
Axis Y1
\\
\hline
2
 & 
Axis X2
\\
\hline
3
 & 
Axis Y2
\\
\hline
4
 & 
Button A
\\
\hline
5
 & 
Button B
\\
\hline
6
 & 
Button C
\\
\hline
7
 & 
Button D
\\
\hline
8
 & 
CHF Buttons X and Y
\\
\hline
9
 & 
CHF Hat 1
\\
\hline
10
 & 
CHF Hat 2
\\
\hline
11
 & 
FCS Hat
\\
\hline
12
 & 
Pad Button X
\\
\hline
13
 & 
Pad Button Y
\\
\hline
14
 & 
Pad Button U
\\
\hline
15
 & 
Pad Button V
\\
\hline
16
 & 
Saitek F1-F4 Buttons
\\
\hline
17
 & 
Saitek Digital Mode
\\
\hline
19
 & 
GamePad
\\
\hline
20
 & 
Joy2 Axis X1
\\
\hline
21
 & 
Joy2 Axis Y1
\\
\hline
22
 & 
Joy2 Axis X2
\\
\hline
23
 & 
Joy2 Axis Y2
\\
\hline
24
 & 
Joy2 Button A
\\
\hline
25
 & 
Joy2 Button B
\\
\hline
26
 & 
Joy2 Button C
\\
\hline
27
 & 
Joy2 Button D
\\
\hline
31
 & 
Joy2 GamePad
\\
\hline\end{tabulary}

\end{quote}


\subsubsection{Microsoft SideWinder joysticks}
\label{input/joydev/joystick:microsoft-sidewinder-joysticks}
Microsoft `Digital Overdrive' protocol is supported by the sidewinder.c
module. All currently supported joysticks:
\begin{itemize}
\item {} 
Microsoft SideWinder 3D Pro

\item {} 
Microsoft SideWinder Force Feedback Pro

\item {} 
Microsoft SideWinder Force Feedback Wheel

\item {} 
Microsoft SideWinder FreeStyle Pro

\item {} 
Microsoft SideWinder GamePad (up to four, chained)

\item {} 
Microsoft SideWinder Precision Pro

\item {} 
Microsoft SideWinder Precision Pro USB

\end{itemize}

are autodetected, and thus no module parameters are needed.

There is one caveat with the 3D Pro. There are 9 buttons reported,
although the joystick has only 8. The 9th button is the mode switch on the
rear side of the joystick. However, moving it, you'll reset the joystick,
and make it unresponsive for about a one third of a second. Furthermore, the
joystick will also re-center itself, taking the position it was in during
this time as a new center position. Use it if you want, but think first.

The SideWinder Standard is not a digital joystick, and thus is supported
by the analog driver described above.


\subsubsection{Logitech ADI devices}
\label{input/joydev/joystick:logitech-adi-devices}
Logitech ADI protocol is supported by the adi.c module. It should support
any Logitech device using this protocol. This includes, but is not limited
to:
\begin{itemize}
\item {} 
Logitech CyberMan 2

\item {} 
Logitech ThunderPad Digital

\item {} 
Logitech WingMan Extreme Digital

\item {} 
Logitech WingMan Formula

\item {} 
Logitech WingMan Interceptor

\item {} 
Logitech WingMan GamePad

\item {} 
Logitech WingMan GamePad USB

\item {} 
Logitech WingMan GamePad Extreme

\item {} 
Logitech WingMan Extreme Digital 3D

\end{itemize}

ADI devices are autodetected, and the driver supports up to two (any
combination of) devices on a single gameport, using an Y-cable or chained
together.

Logitech WingMan Joystick, Logitech WingMan Attack, Logitech WingMan
Extreme and Logitech WingMan ThunderPad are not digital joysticks and are
handled by the analog driver described above. Logitech WingMan Warrior and
Logitech Magellan are supported by serial drivers described below.  Logitech
WingMan Force and Logitech WingMan Formula Force are supported by the
I-Force driver described below. Logitech CyberMan is not supported yet.


\subsubsection{Gravis GrIP}
\label{input/joydev/joystick:gravis-grip}
Gravis GrIP protocol is supported by the grip.c module. It currently
supports:
\begin{itemize}
\item {} 
Gravis GamePad Pro

\item {} 
Gravis BlackHawk Digital

\item {} 
Gravis Xterminator

\item {} 
Gravis Xterminator DualControl

\end{itemize}

All these devices are autodetected, and you can even use any combination
of up to two of these pads either chained together or using an Y-cable on a
single gameport.

GrIP MultiPort isn't supported yet. Gravis Stinger is a serial device and is
supported by the stinger driver. Other Gravis joysticks are supported by the
analog driver.


\subsubsection{FPGaming A3D and MadCatz A3D}
\label{input/joydev/joystick:fpgaming-a3d-and-madcatz-a3d}
The Assassin 3D protocol created by FPGaming, is used both by FPGaming
themselves and is licensed to MadCatz. A3D devices are supported by the
a3d.c module. It currently supports:
\begin{itemize}
\item {} 
FPGaming Assassin 3D

\item {} 
MadCatz Panther

\item {} 
MadCatz Panther XL

\end{itemize}

All these devices are autodetected. Because the Assassin 3D and the Panther
allow connecting analog joysticks to them, you'll need to load the analog
driver as well to handle the attached joysticks.

The trackball should work with USB mousedev module as a normal mouse. See
the USB documentation for how to setup an USB mouse.


\subsubsection{ThrustMaster DirectConnect (BSP)}
\label{input/joydev/joystick:thrustmaster-directconnect-bsp}
The TM DirectConnect (BSP) protocol is supported by the tmdc.c
module. This includes, but is not limited to:
\begin{itemize}
\item {} 
ThrustMaster Millennium 3D Interceptor

\item {} 
ThrustMaster 3D Rage Pad

\item {} 
ThrustMaster Fusion Digital Game Pad

\end{itemize}

Devices not directly supported, but hopefully working are:
\begin{itemize}
\item {} 
ThrustMaster FragMaster

\item {} 
ThrustMaster Attack Throttle

\end{itemize}

If you have one of these, contact me.

TMDC devices are autodetected, and thus no parameters to the module
are needed. Up to two TMDC devices can be connected to one gameport, using
an Y-cable.


\subsubsection{Creative Labs Blaster}
\label{input/joydev/joystick:creative-labs-blaster}
The Blaster protocol is supported by the cobra.c module. It supports only
the:
\begin{itemize}
\item {} 
Creative Blaster GamePad Cobra

\end{itemize}

Up to two of these can be used on a single gameport, using an Y-cable.


\subsubsection{Genius Digital joysticks}
\label{input/joydev/joystick:genius-digital-joysticks}
The Genius digitally communicating joysticks are supported by the gf2k.c
module. This includes:
\begin{itemize}
\item {} 
Genius Flight2000 F-23 joystick

\item {} 
Genius Flight2000 F-31 joystick

\item {} 
Genius G-09D gamepad

\end{itemize}

Other Genius digital joysticks are not supported yet, but support can be
added fairly easily.


\subsubsection{InterAct Digital joysticks}
\label{input/joydev/joystick:interact-digital-joysticks}
The InterAct digitally communicating joysticks are supported by the
interact.c module. This includes:
\begin{itemize}
\item {} 
InterAct HammerHead/FX gamepad

\item {} 
InterAct ProPad8 gamepad

\end{itemize}

Other InterAct digital joysticks are not supported yet, but support can be
added fairly easily.


\subsubsection{PDPI Lightning 4 gamecards}
\label{input/joydev/joystick:pdpi-lightning-4-gamecards}
PDPI Lightning 4 gamecards are supported by the lightning.c module.
Once the module is loaded, the analog driver can be used to handle the
joysticks. Digitally communicating joystick will work only on port 0, while
using Y-cables, you can connect up to 8 analog joysticks to a single L4
card, 16 in case you have two in your system.


\subsubsection{Trident 4DWave / Aureal Vortex}
\label{input/joydev/joystick:trident-4dwave-aureal-vortex}
Soundcards with a Trident 4DWave DX/NX or Aureal Vortex/Vortex2 chipsets
provide an ``Enhanced Game Port'' mode where the soundcard handles polling the
joystick.  This mode is supported by the pcigame.c module. Once loaded the
analog driver can use the enhanced features of these gameports..


\subsubsection{Crystal SoundFusion}
\label{input/joydev/joystick:crystal-soundfusion}
Soundcards with Crystal SoundFusion chipsets provide an ``Enhanced Game
Port'', much like the 4DWave or Vortex above. This, and also the normal mode
for the port of the SoundFusion is supported by the cs461x.c module.


\subsubsection{SoundBlaster Live!}
\label{input/joydev/joystick:soundblaster-live}
The Live! has a special PCI gameport, which, although it doesn't provide
any ``Enhanced'' stuff like 4DWave and friends, is quite a bit faster than
its ISA counterparts. It also requires special support, hence the
emu10k1-gp.c module for it instead of the normal ns558.c one.


\subsubsection{SoundBlaster 64 and 128 - ES1370 and ES1371, ESS Solo1 and S3 SonicVibes}
\label{input/joydev/joystick:soundblaster-64-and-128-es1370-and-es1371-ess-solo1-and-s3-sonicvibes}
These PCI soundcards have specific gameports. They are handled by the
sound drivers themselves. Make sure you select gameport support in the
joystick menu and sound card support in the sound menu for your appropriate
card.


\subsubsection{Amiga}
\label{input/joydev/joystick:amiga}
Amiga joysticks, connected to an Amiga, are supported by the amijoy.c
driver. Since they can't be autodetected, the driver has a command line:
\begin{quote}

amijoy.map=\textless{}a\textgreater{},\textless{}b\textgreater{}
\end{quote}

a and b define the joysticks connected to the JOY0DAT and JOY1DAT ports of
the Amiga.
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Value
} & \textsf{\relax 
Joystick type
}\\
\hline
0
 & 
None
\\
\hline
1
 & 
1-button digital joystick
\\
\hline\end{tabulary}

\end{quote}

No more joystick types are supported now, but that should change in the
future if I get an Amiga in the reach of my fingers.


\subsubsection{Game console and 8-bit pads and joysticks}
\label{input/joydev/joystick:game-console-and-8-bit-pads-and-joysticks}
These pads and joysticks are not designed for PCs and other computers
Linux runs on, and usually require a special connector for attaching
them through a parallel port.

See {\hyperref[input/devices/joystick\string-parport:joystick\string-parport]{\emph{Parallel Port Joystick Drivers}}} for more info.


\subsubsection{SpaceTec/LabTec devices}
\label{input/joydev/joystick:spacetec-labtec-devices}
SpaceTec serial devices communicate using the SpaceWare protocol. It is
supported by the spaceorb.c and spaceball.c drivers. The devices currently
supported by spaceorb.c are:
\begin{itemize}
\item {} 
SpaceTec SpaceBall Avenger

\item {} 
SpaceTec SpaceOrb 360

\end{itemize}

Devices currently supported by spaceball.c are:
\begin{itemize}
\item {} 
SpaceTec SpaceBall 4000 FLX

\end{itemize}

In addition to having the spaceorb/spaceball and serport modules in the
kernel, you also need to attach a serial port to it. to do that, run the
inputattach program:

\begin{Verbatim}[commandchars=\\\{\}]
inputattach \PYGZhy{}\PYGZhy{}spaceorb /dev/tts/x \PYGZam{}
\end{Verbatim}

or:

\begin{Verbatim}[commandchars=\\\{\}]
inputattach \PYGZhy{}\PYGZhy{}spaceball /dev/tts/x \PYGZam{}
\end{Verbatim}

where /dev/tts/x is the serial port which the device is connected to. After
doing this, the device will be reported and will start working.

There is one caveat with the SpaceOrb. The button \#6, the on the bottom
side of the orb, although reported as an ordinary button, causes internal
recentering of the spaceorb, moving the zero point to the position in which
the ball is at the moment of pressing the button. So, think first before
you bind it to some other function.

SpaceTec SpaceBall 2003 FLX and 3003 FLX are not supported yet.


\subsubsection{Logitech SWIFT devices}
\label{input/joydev/joystick:logitech-swift-devices}
The SWIFT serial protocol is supported by the warrior.c module. It
currently supports only the:
\begin{itemize}
\item {} 
Logitech WingMan Warrior

\end{itemize}

but in the future, Logitech CyberMan (the original one, not CM2) could be
supported as well. To use the module, you need to run inputattach after you
insert/compile the module into your kernel:

\begin{Verbatim}[commandchars=\\\{\}]
inputattach \PYGZhy{}\PYGZhy{}warrior /dev/tts/x \PYGZam{}
\end{Verbatim}

/dev/tts/x is the serial port your Warrior is attached to.


\subsubsection{Magellan / Space Mouse}
\label{input/joydev/joystick:magellan-space-mouse}
The Magellan (or Space Mouse), manufactured by LogiCad3d (formerly Space
Systems), for many other companies (Logitech, HP, ...) is supported by the
joy-magellan module. It currently supports only the:
\begin{itemize}
\item {} 
Magellan 3D

\item {} 
Space Mouse

\end{itemize}

models, the additional buttons on the `Plus' versions are not supported yet.

To use it, you need to attach the serial port to the driver using the:

\begin{Verbatim}[commandchars=\\\{\}]
inputattach \PYGZhy{}\PYGZhy{}magellan /dev/tts/x \PYGZam{}
\end{Verbatim}

command. After that the Magellan will be detected, initialized, will beep,
and the /dev/input/jsX device should become usable.


\subsubsection{I-Force devices}
\label{input/joydev/joystick:i-force-devices}
All I-Force devices are supported by the iforce module. This includes:
\begin{itemize}
\item {} 
AVB Mag Turbo Force

\item {} 
AVB Top Shot Pegasus

\item {} 
AVB Top Shot Force Feedback Racing Wheel

\item {} 
Logitech WingMan Force

\item {} 
Logitech WingMan Force Wheel

\item {} 
Guillemot Race Leader Force Feedback

\item {} 
Guillemot Force Feedback Racing Wheel

\item {} 
Thrustmaster Motor Sport GT

\end{itemize}

To use it, you need to attach the serial port to the driver using the:

\begin{Verbatim}[commandchars=\\\{\}]
inputattach \PYGZhy{}\PYGZhy{}iforce /dev/tts/x \PYGZam{}
\end{Verbatim}

command. After that the I-Force device will be detected, and the
/dev/input/jsX device should become usable.

In case you're using the device via the USB port, the inputattach command
isn't needed.

The I-Force driver now supports force feedback via the event interface.

Please note that Logitech WingMan 3D devices are \_not\_ supported by this
module, rather by hid. Force feedback is not supported for those devices.
Logitech gamepads are also hid devices.


\subsubsection{Gravis Stinger gamepad}
\label{input/joydev/joystick:gravis-stinger-gamepad}
The Gravis Stinger serial port gamepad, designed for use with laptop
computers, is supported by the stinger.c module. To use it, attach the
serial port to the driver using:

\begin{Verbatim}[commandchars=\\\{\}]
inputattach \PYGZhy{}\PYGZhy{}stinger /dev/tty/x \PYGZam{}
\end{Verbatim}

where x is the number of the serial port.


\subsection{Troubleshooting}
\label{input/joydev/joystick:troubleshooting}
There is quite a high probability that you run into some problems. For
testing whether the driver works, if in doubt, use the jstest utility in
some of its modes. The most useful modes are ``normal'' - for the 1.x
interface, and ``old'' for the ``0.x'' interface. You run it by typing:

\begin{Verbatim}[commandchars=\\\{\}]
jstest \PYGZhy{}\PYGZhy{}normal /dev/input/js0
jstest \PYGZhy{}\PYGZhy{}old    /dev/input/js0
\end{Verbatim}

Additionally you can do a test with the evtest utility:

\begin{Verbatim}[commandchars=\\\{\}]
evtest /dev/input/event0
\end{Verbatim}

Oh, and read the FAQ! :)


\subsection{FAQ}
\label{input/joydev/joystick:faq}\begin{quote}\begin{description}
\item[{Q}] \leavevmode
Running `jstest /dev/input/js0' results in ``File not found'' error. What's the
cause?

\item[{A}] \leavevmode
The device files don't exist. Create them (see section 2.2).

\item[{Q}] \leavevmode
Is it possible to connect my old Atari/Commodore/Amiga/console joystick
or pad that uses a 9-pin D-type cannon connector to the serial port of my
PC?

\item[{A}] \leavevmode
Yes, it is possible, but it'll burn your serial port or the pad. It
won't work, of course.

\item[{Q}] \leavevmode
My joystick doesn't work with Quake / Quake 2. What's the cause?

\item[{A}] \leavevmode
Quake / Quake 2 don't support joystick. Use joy2key to simulate keypresses
for them.

\end{description}\end{quote}


\subsection{Programming Interface}
\label{input/joydev/joystick-api:programming-interface}\label{input/joydev/joystick-api::doc}\label{input/joydev/joystick-api:joystick-api}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Ragnar Hojland Espinosa \textless{}\href{mailto:ragnar@macula.net}{ragnar@macula.net}\textgreater{} - 7 Aug 1998

\end{description}\end{quote}


\subsubsection{Introduction}
\label{input/joydev/joystick-api:introduction}
\begin{notice}{important}{Important:}
This document describes legacy \code{js} interface. Newer clients are
encouraged to switch to the generic event (\code{evdev}) interface.
\end{notice}

The 1.0 driver uses a new, event based approach to the joystick driver.
Instead of the user program polling for the joystick values, the joystick
driver now reports only any changes of its state. See joystick-api.txt,
joystick.h and jstest.c included in the joystick package for more
information. The joystick device can be used in either blocking or
nonblocking mode, and supports select() calls.

For backward compatibility the old (v0.x) interface is still included.
Any call to the joystick driver using the old interface will return values
that are compatible to the old interface. This interface is still limited
to 2 axes, and applications using it usually decode only 2 buttons, although
the driver provides up to 32.


\subsubsection{Initialization}
\label{input/joydev/joystick-api:initialization}
Open the joystick device following the usual semantics (that is, with open).
Since the driver now reports events instead of polling for changes,
immediately after the open it will issue a series of synthetic events
(JS\_EVENT\_INIT) that you can read to obtain the initial state of the
joystick.

By default, the device is opened in blocking mode:

\begin{Verbatim}[commandchars=\\\{\}]
int fd = open (\PYGZdq{}/dev/input/js0\PYGZdq{}, O\PYGZus{}RDONLY);
\end{Verbatim}


\subsubsection{Event Reading}
\label{input/joydev/joystick-api:event-reading}
\begin{Verbatim}[commandchars=\\\{\}]
struct js\PYGZus{}event e;
read (fd, \PYGZam{}e, sizeof(e));
\end{Verbatim}

where js\_event is defined as:

\begin{Verbatim}[commandchars=\\\{\}]
struct js\PYGZus{}event \PYGZob{}
        \PYGZus{}\PYGZus{}u32 time;     /* event timestamp in milliseconds */
        \PYGZus{}\PYGZus{}s16 value;    /* value */
        \PYGZus{}\PYGZus{}u8 type;      /* event type */
        \PYGZus{}\PYGZus{}u8 number;    /* axis/button number */
\PYGZcb{};
\end{Verbatim}

If the read is successful, it will return sizeof(e), unless you wanted to read
more than one event per read as described in section 3.1.


\paragraph{js\_event.type}
\label{input/joydev/joystick-api:js-event-type}
The possible values of \code{type} are:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}define JS\PYGZus{}EVENT\PYGZus{}BUTTON         0x01    /* button pressed/released */
\PYGZsh{}define JS\PYGZus{}EVENT\PYGZus{}AXIS           0x02    /* joystick moved */
\PYGZsh{}define JS\PYGZus{}EVENT\PYGZus{}INIT           0x80    /* initial state of device */
\end{Verbatim}

As mentioned above, the driver will issue synthetic JS\_EVENT\_INIT ORed
events on open. That is, if it's issuing a INIT BUTTON event, the
current type value will be:

\begin{Verbatim}[commandchars=\\\{\}]
int type = JS\PYGZus{}EVENT\PYGZus{}BUTTON \textbar{} JS\PYGZus{}EVENT\PYGZus{}INIT;     /* 0x81 */
\end{Verbatim}

If you choose not to differentiate between synthetic or real events
you can turn off the JS\_EVENT\_INIT bits:

\begin{Verbatim}[commandchars=\\\{\}]
type \PYGZam{}= \PYGZti{}JS\PYGZus{}EVENT\PYGZus{}INIT;                         /* 0x01 */
\end{Verbatim}


\paragraph{js\_event.number}
\label{input/joydev/joystick-api:js-event-number}
The values of \code{number} correspond to the axis or button that
generated the event. Note that they carry separate numeration (that
is, you have both an axis 0 and a button 0). Generally,
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Axis
} & \textsf{\relax 
number
}\\
\hline
1st Axis X
 & 
0
\\
\hline
1st Axis Y
 & 
1
\\
\hline
2nd Axis X
 & 
2
\\
\hline
2nd Axis Y
 & 
3
\\
\hline
...and so on
 & \\
\hline\end{tabulary}

\end{quote}

Hats vary from one joystick type to another. Some can be moved in 8
directions, some only in 4, The driver, however, always reports a hat as two
independent axis, even if the hardware doesn't allow independent movement.


\paragraph{js\_event.value}
\label{input/joydev/joystick-api:js-event-value}
For an axis, \code{value} is a signed integer between -32767 and +32767
representing the position of the joystick along that axis. If you
don't read a 0 when the joystick is \code{dead}, or if it doesn't span the
full range, you should recalibrate it (with, for example, jscal).

For a button, \code{value} for a press button event is 1 and for a release
button event is 0.

Though this:

\begin{Verbatim}[commandchars=\\\{\}]
if (js\PYGZus{}event.type == JS\PYGZus{}EVENT\PYGZus{}BUTTON) \PYGZob{}
        buttons\PYGZus{}state \PYGZca{}= (1 \PYGZlt{}\PYGZlt{} js\PYGZus{}event.number);
\PYGZcb{}
\end{Verbatim}

may work well if you handle JS\_EVENT\_INIT events separately,

\begin{Verbatim}[commandchars=\\\{\}]
if ((js\PYGZus{}event.type \PYGZam{} \PYGZti{}JS\PYGZus{}EVENT\PYGZus{}INIT) == JS\PYGZus{}EVENT\PYGZus{}BUTTON) \PYGZob{}
        if (js\PYGZus{}event.value)
                buttons\PYGZus{}state \textbar{}= (1 \PYGZlt{}\PYGZlt{} js\PYGZus{}event.number);
        else
                buttons\PYGZus{}state \PYGZam{}= \PYGZti{}(1 \PYGZlt{}\PYGZlt{} js\PYGZus{}event.number);
\PYGZcb{}
\end{Verbatim}

is much safer since it can't lose sync with the driver. As you would
have to write a separate handler for JS\_EVENT\_INIT events in the first
snippet, this ends up being shorter.


\paragraph{js\_event.time}
\label{input/joydev/joystick-api:js-event-time}
The time an event was generated is stored in \code{js\_event.time}. It's a time
in milliseconds since ... well, since sometime in the past.  This eases the
task of detecting double clicks, figuring out if movement of axis and button
presses happened at the same time, and similar.


\subsubsection{Reading}
\label{input/joydev/joystick-api:reading}
If you open the device in blocking mode, a read will block (that is,
wait) forever until an event is generated and effectively read. There
are two alternatives if you can't afford to wait forever (which is,
admittedly, a long time;)
\begin{enumerate}
\item {} 
use select to wait until there's data to be read on fd, or
until it timeouts. There's a good example on the select(2)
man page.

\item {} 
open the device in non-blocking mode (O\_NONBLOCK)

\end{enumerate}


\paragraph{O\_NONBLOCK}
\label{input/joydev/joystick-api:o-nonblock}
If read returns -1 when reading in O\_NONBLOCK mode, this isn't
necessarily a ``real'' error (check errno(3)); it can just mean there
are no events pending to be read on the driver queue. You should read
all events on the queue (that is, until you get a -1).

For example,

\begin{Verbatim}[commandchars=\\\{\}]
while (1) \PYGZob{}
        while (read (fd, \PYGZam{}e, sizeof(e)) \PYGZgt{} 0) \PYGZob{}
                process\PYGZus{}event (e);
        \PYGZcb{}
        /* EAGAIN is returned when the queue is empty */
        if (errno != EAGAIN) \PYGZob{}
                /* error */
        \PYGZcb{}
        /* do something interesting with processed events */
\PYGZcb{}
\end{Verbatim}

One reason for emptying the queue is that if it gets full you'll start
missing events since the queue is finite, and older events will get
overwritten.

The other reason is that you want to know all what happened, and not
delay the processing till later.

Why can get the queue full? Because you don't empty the queue as
mentioned, or because too much time elapses from one read to another
and too many events to store in the queue get generated. Note that
high system load may contribute to space those reads even more.

If time between reads is enough to fill the queue and lose an event,
the driver will switch to startup mode and next time you read it,
synthetic events (JS\_EVENT\_INIT) will be generated to inform you of
the actual state of the joystick.

\begin{notice}{note}{Note:}
As of version 1.2.8, the queue is circular and able to hold 64
events. You can increment this size bumping up JS\_BUFF\_SIZE in
joystick.h and recompiling the driver.
\end{notice}

In the above code, you might as well want to read more than one event
at a time using the typical read(2) functionality. For that, you would
replace the read above with something like:

\begin{Verbatim}[commandchars=\\\{\}]
struct js\PYGZus{}event mybuffer[0xff];
int i = read (fd, mybuffer, sizeof(mybuffer));
\end{Verbatim}

In this case, read would return -1 if the queue was empty, or some
other value in which the number of events read would be i /
sizeof(js\_event)  Again, if the buffer was full, it's a good idea to
process the events and keep reading it until you empty the driver queue.


\subsubsection{IOCTLs}
\label{input/joydev/joystick-api:ioctls}
The joystick driver defines the following ioctl(2) operations:

\begin{Verbatim}[commandchars=\\\{\}]
                        /* function                     3rd arg  */
\PYGZsh{}define JSIOCGAXES      /* get number of axes           char     */
\PYGZsh{}define JSIOCGBUTTONS   /* get number of buttons        char     */
\PYGZsh{}define JSIOCGVERSION   /* get driver version           int      */
\PYGZsh{}define JSIOCGNAME(len) /* get identifier string        char     */
\PYGZsh{}define JSIOCSCORR      /* set correction values        \PYGZam{}js\PYGZus{}corr */
\PYGZsh{}define JSIOCGCORR      /* get correction values        \PYGZam{}js\PYGZus{}corr */
\end{Verbatim}

For example, to read the number of axes:

\begin{Verbatim}[commandchars=\\\{\}]
char number\PYGZus{}of\PYGZus{}axes;
ioctl (fd, JSIOCGAXES, \PYGZam{}number\PYGZus{}of\PYGZus{}axes);
\end{Verbatim}


\paragraph{JSIOGCVERSION}
\label{input/joydev/joystick-api:jsiogcversion}
JSIOGCVERSION is a good way to check in run-time whether the running
driver is 1.0+ and supports the event interface. If it is not, the
IOCTL will fail. For a compile-time decision, you can test the
JS\_VERSION symbol:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}ifdef JS\PYGZus{}VERSION
\PYGZsh{}if JS\PYGZus{}VERSION \PYGZgt{} 0xsomething
\end{Verbatim}


\paragraph{JSIOCGNAME}
\label{input/joydev/joystick-api:jsiocgname}
JSIOCGNAME(len) allows you to get the name string of the joystick - the same
as is being printed at boot time. The `len' argument is the length of the
buffer provided by the application asking for the name. It is used to avoid
possible overrun should the name be too long:

\begin{Verbatim}[commandchars=\\\{\}]
char name[128];
if (ioctl(fd, JSIOCGNAME(sizeof(name)), name) \PYGZlt{} 0)
        strncpy(name, \PYGZdq{}Unknown\PYGZdq{}, sizeof(name));
printf(\PYGZdq{}Name: \PYGZpc{}s\PYGZbs{}n\PYGZdq{}, name);
\end{Verbatim}


\paragraph{JSIOC{[}SG{]}CORR}
\label{input/joydev/joystick-api:jsioc-sg-corr}
For usage on JSIOC{[}SG{]}CORR I suggest you to look into jscal.c  They are
not needed in a normal program, only in joystick calibration software
such as jscal or kcmjoy. These IOCTLs and data types aren't considered
to be in the stable part of the API, and therefore may change without
warning in following releases of the driver.

Both JSIOCSCORR and JSIOCGCORR expect \&js\_corr to be able to hold
information for all axis. That is, struct js\_corr corr{[}MAX\_AXIS{]};

struct js\_corr is defined as:

\begin{Verbatim}[commandchars=\\\{\}]
struct js\PYGZus{}corr \PYGZob{}
        \PYGZus{}\PYGZus{}s32 coef[8];
        \PYGZus{}\PYGZus{}u16 prec;
        \PYGZus{}\PYGZus{}u16 type;
\PYGZcb{};
\end{Verbatim}

and \code{type}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}define JS\PYGZus{}CORR\PYGZus{}NONE            0x00    /* returns raw values */
\PYGZsh{}define JS\PYGZus{}CORR\PYGZus{}BROKEN          0x01    /* broken line */
\end{Verbatim}


\subsubsection{Backward compatibility}
\label{input/joydev/joystick-api:backward-compatibility}
The 0.x joystick driver API is quite limited and its usage is deprecated.
The driver offers backward compatibility, though. Here's a quick summary:

\begin{Verbatim}[commandchars=\\\{\}]
struct JS\PYGZus{}DATA\PYGZus{}TYPE js;
while (1) \PYGZob{}
        if (read (fd, \PYGZam{}js, JS\PYGZus{}RETURN) != JS\PYGZus{}RETURN) \PYGZob{}
                /* error */
        \PYGZcb{}
        usleep (1000);
\PYGZcb{}
\end{Verbatim}

As you can figure out from the example, the read returns immediately,
with the actual state of the joystick:

\begin{Verbatim}[commandchars=\\\{\}]
struct JS\PYGZus{}DATA\PYGZus{}TYPE \PYGZob{}
        int buttons;    /* immediate button state */
        int x;          /* immediate x axis value */
        int y;          /* immediate y axis value */
\PYGZcb{};
\end{Verbatim}

and JS\_RETURN is defined as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}define JS\PYGZus{}RETURN       sizeof(struct JS\PYGZus{}DATA\PYGZus{}TYPE)
\end{Verbatim}

To test the state of the buttons,

\begin{Verbatim}[commandchars=\\\{\}]
first\PYGZus{}button\PYGZus{}state  = js.buttons \PYGZam{} 1;
second\PYGZus{}button\PYGZus{}state = js.buttons \PYGZam{} 2;
\end{Verbatim}

The axis values do not have a defined range in the original 0.x driver,
except for that the values are non-negative. The 1.2.8+ drivers use a
fixed range for reporting the values, 1 being the minimum, 128 the
center, and 255 maximum value.

The v0.8.0.2 driver also had an interface for `digital joysticks', (now
called Multisystem joysticks in this driver), under /dev/djsX. This driver
doesn't try to be compatible with that interface.


\subsubsection{Final Notes}
\label{input/joydev/joystick-api:final-notes}
\begin{Verbatim}[commandchars=\\\{\}]
\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}/\textbar{}        Comments, additions, and specially corrections are welcome.
\PYGZbs{} o.O\textbar{}        Documentation valid for at least version 1.2.8 of the joystick
 =(\PYGZus{})=        driver and as usual, the ultimate source for documentation is
   U          to \PYGZdq{}Use The Source Luke\PYGZdq{} or, at your convenience, Vojtech ;)
\end{Verbatim}


\section{uinput module}
\label{input/uinput::doc}\label{input/uinput:uinput-module}

\subsection{Introduction}
\label{input/uinput:introduction}
uinput is a kernel module that makes it possible to emulate input devices
from userspace. By writing to /dev/uinput (or /dev/input/uinput) device, a
process can create a virtual input device with specific capabilities. Once
this virtual device is created, the process can send events through it,
that will be delivered to userspace and in-kernel consumers.


\subsection{Interface}
\label{input/uinput:interface}
\begin{Verbatim}[commandchars=\\\{\}]
linux/uinput.h
\end{Verbatim}

The uinput header defines ioctls to create, set up, and destroy virtual
devices.


\subsection{libevdev}
\label{input/uinput:libevdev}
libevdev is a wrapper library for evdev devices that provides interfaces to
create uinput devices and send events. libevdev is less error-prone than
accessing uinput directly, and should be considered for new software.

For examples and more information about libevdev:
\href{https://www.freedesktop.org/software/libevdev/doc/latest/}{https://www.freedesktop.org/software/libevdev/doc/latest/}


\subsection{Examples}
\label{input/uinput:examples}

\subsubsection{Keyboard events}
\label{input/uinput:keyboard-events}
This first example shows how to create a new virtual device, and how to
send a key event. All default imports and error handlers were removed for
the sake of simplicity.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}linux/uinput.h\PYGZgt{}}

\PYG{k+kt}{void} \PYG{n+nf}{emit}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{fd}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{type}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{code}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{val}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{k}{struct} \PYG{n}{input\PYGZus{}event} \PYG{n}{ie}\PYG{p}{;}

   \PYG{n}{ie}\PYG{p}{.}\PYG{n}{type} \PYG{o}{=} \PYG{n}{type}\PYG{p}{;}
   \PYG{n}{ie}\PYG{p}{.}\PYG{n}{code} \PYG{o}{=} \PYG{n}{code}\PYG{p}{;}
   \PYG{n}{ie}\PYG{p}{.}\PYG{n}{value} \PYG{o}{=} \PYG{n}{val}\PYG{p}{;}
   \PYG{c+cm}{/* timestamp values below are ignored */}
   \PYG{n}{ie}\PYG{p}{.}\PYG{n}{time}\PYG{p}{.}\PYG{n}{tv\PYGZus{}sec} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{n}{ie}\PYG{p}{.}\PYG{n}{time}\PYG{p}{.}\PYG{n}{tv\PYGZus{}usec} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

   \PYG{n}{write}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{ie}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{ie}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{k}{struct} \PYG{n}{uinput\PYGZus{}setup} \PYG{n}{usetup}\PYG{p}{;}

   \PYG{k+kt}{int} \PYG{n}{fd} \PYG{o}{=} \PYG{n}{open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/dev/uinput}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{O\PYGZus{}WRONLY} \PYG{o}{\textbar{}} \PYG{n}{O\PYGZus{}NONBLOCK}\PYG{p}{)}\PYG{p}{;}


   \PYG{c+cm}{/*}
\PYG{c+cm}{    * The ioctls below will enable the device that is about to be}
\PYG{c+cm}{    * created, to pass key events, in this case the space key.}
\PYG{c+cm}{    */}
   \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}SET\PYGZus{}EVBIT}\PYG{p}{,} \PYG{n}{EV\PYGZus{}KEY}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}SET\PYGZus{}KEYBIT}\PYG{p}{,} \PYG{n}{KEY\PYGZus{}SPACE}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{memset}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{usetup}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{usetup}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{usetup}\PYG{p}{.}\PYG{n}{id}\PYG{p}{.}\PYG{n}{bustype} \PYG{o}{=} \PYG{n}{BUS\PYGZus{}USB}\PYG{p}{;}
   \PYG{n}{usetup}\PYG{p}{.}\PYG{n}{id}\PYG{p}{.}\PYG{n}{vendor} \PYG{o}{=} \PYG{l+m+mh}{0x1234}\PYG{p}{;} \PYG{c+cm}{/* sample vendor */}
   \PYG{n}{usetup}\PYG{p}{.}\PYG{n}{id}\PYG{p}{.}\PYG{n}{product} \PYG{o}{=} \PYG{l+m+mh}{0x5678}\PYG{p}{;} \PYG{c+cm}{/* sample product */}
   \PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{usetup}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Example device}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}DEV\PYGZus{}SETUP}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{usetup}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}DEV\PYGZus{}CREATE}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+cm}{/*}
\PYG{c+cm}{    * On UI\PYGZus{}DEV\PYGZus{}CREATE the kernel will create the device node for this}
\PYG{c+cm}{    * device. We are inserting a pause here so that userspace has time}
\PYG{c+cm}{    * to detect, initialize the new device, and can start listening to}
\PYG{c+cm}{    * the event, otherwise it will not notice the event we are about}
\PYG{c+cm}{    * to send. This pause is only needed in our example code!}
\PYG{c+cm}{    */}
   \PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+cm}{/* Key press, report the event, send key release, and report again */}
   \PYG{n}{emit}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{EV\PYGZus{}KEY}\PYG{p}{,} \PYG{n}{KEY\PYGZus{}SPACE}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{emit}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{EV\PYGZus{}SYN}\PYG{p}{,} \PYG{n}{SYN\PYGZus{}REPORT}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{emit}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{EV\PYGZus{}KEY}\PYG{p}{,} \PYG{n}{KEY\PYGZus{}SPACE}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{emit}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{EV\PYGZus{}SYN}\PYG{p}{,} \PYG{n}{SYN\PYGZus{}REPORT}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+cm}{/*}
\PYG{c+cm}{    * Give userspace some time to read the events before we destroy the}
\PYG{c+cm}{    * device with UI\PYGZus{}DEV\PYGZus{}DESTOY.}
\PYG{c+cm}{    */}
   \PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}DEV\PYGZus{}DESTROY}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{close}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsubsection{Mouse movements}
\label{input/uinput:mouse-movements}
This example shows how to create a virtual device that behaves like a physical
mouse.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}linux/uinput.h\PYGZgt{}}

\PYG{c+cm}{/* emit function is identical to of the first example */}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{k}{struct} \PYG{n}{uinput\PYGZus{}setup} \PYG{n}{usetup}\PYG{p}{;}
   \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{;}

   \PYG{k+kt}{int} \PYG{n}{fd} \PYG{o}{=} \PYG{n}{open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/dev/uinput}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{O\PYGZus{}WRONLY} \PYG{o}{\textbar{}} \PYG{n}{O\PYGZus{}NONBLOCK}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+cm}{/* enable mouse button left and relative events */}
   \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}SET\PYGZus{}EVBIT}\PYG{p}{,} \PYG{n}{EV\PYGZus{}KEY}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}SET\PYGZus{}KEYBIT}\PYG{p}{,} \PYG{n}{BTN\PYGZus{}LEFT}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}SET\PYGZus{}EVBIT}\PYG{p}{,} \PYG{n}{EV\PYGZus{}REL}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}SET\PYGZus{}RELBIT}\PYG{p}{,} \PYG{n}{REL\PYGZus{}X}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}SET\PYGZus{}RELBIT}\PYG{p}{,} \PYG{n}{REL\PYGZus{}Y}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{memset}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{usetup}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{usetup}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{usetup}\PYG{p}{.}\PYG{n}{id}\PYG{p}{.}\PYG{n}{bustype} \PYG{o}{=} \PYG{n}{BUS\PYGZus{}USB}\PYG{p}{;}
   \PYG{n}{usetup}\PYG{p}{.}\PYG{n}{id}\PYG{p}{.}\PYG{n}{vendor} \PYG{o}{=} \PYG{l+m+mh}{0x1234}\PYG{p}{;} \PYG{c+cm}{/* sample vendor */}
   \PYG{n}{usetup}\PYG{p}{.}\PYG{n}{id}\PYG{p}{.}\PYG{n}{product} \PYG{o}{=} \PYG{l+m+mh}{0x5678}\PYG{p}{;} \PYG{c+cm}{/* sample product */}
   \PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{usetup}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Example device}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}DEV\PYGZus{}SETUP}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{usetup}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}DEV\PYGZus{}CREATE}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+cm}{/*}
\PYG{c+cm}{    * On UI\PYGZus{}DEV\PYGZus{}CREATE the kernel will create the device node for this}
\PYG{c+cm}{    * device. We are inserting a pause here so that userspace has time}
\PYG{c+cm}{    * to detect, initialize the new device, and can start listening to}
\PYG{c+cm}{    * the event, otherwise it will not notice the event we are about}
\PYG{c+cm}{    * to send. This pause is only needed in our example code!}
\PYG{c+cm}{    */}
   \PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+cm}{/* Move the mouse diagonally, 5 units per axis */}
   \PYG{k}{while} \PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{emit}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{EV\PYGZus{}REL}\PYG{p}{,} \PYG{n}{REL\PYGZus{}X}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{emit}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{EV\PYGZus{}REL}\PYG{p}{,} \PYG{n}{REL\PYGZus{}Y}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{emit}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{EV\PYGZus{}SYN}\PYG{p}{,} \PYG{n}{SYN\PYGZus{}REPORT}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{usleep}\PYG{p}{(}\PYG{l+m+mi}{15000}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{c+cm}{/*}
\PYG{c+cm}{    * Give userspace some time to read the events before we destroy the}
\PYG{c+cm}{    * device with UI\PYGZus{}DEV\PYGZus{}DESTOY.}
\PYG{c+cm}{    */}
   \PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}DEV\PYGZus{}DESTROY}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{close}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsubsection{uinput old interface}
\label{input/uinput:uinput-old-interface}
Before uinput version 5, there wasn't a dedicated ioctl to set up a virtual
device. Programs supportinf older versions of uinput interface need to fill
a uinput\_user\_dev structure and write it to the uinput file descriptor to
configure the new uinput device. New code should not use the old interface
but interact with uinput via ioctl calls, or use libevdev.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}linux/uinput.h\PYGZgt{}}

\PYG{c+cm}{/* emit function is identical to of the first example */}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{k}{struct} \PYG{n}{uinput\PYGZus{}user\PYGZus{}dev} \PYG{n}{uud}\PYG{p}{;}
   \PYG{k+kt}{int} \PYG{n}{version}\PYG{p}{,} \PYG{n}{rc}\PYG{p}{,} \PYG{n}{fd}\PYG{p}{;}

   \PYG{n}{fd} \PYG{o}{=} \PYG{n}{open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/dev/uinput}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{O\PYGZus{}WRONLY} \PYG{o}{\textbar{}} \PYG{n}{O\PYGZus{}NONBLOCK}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{rc} \PYG{o}{=} \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}GET\PYGZus{}VERSION}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{version}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if} \PYG{p}{(}\PYG{n}{rc} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{version} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{c+cm}{/* use UI\PYGZus{}DEV\PYGZus{}SETUP */}
      \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{c+cm}{/*}
\PYG{c+cm}{    * The ioctls below will enable the device that is about to be}
\PYG{c+cm}{    * created, to pass key events, in this case the space key.}
\PYG{c+cm}{    */}
   \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}SET\PYGZus{}EVBIT}\PYG{p}{,} \PYG{n}{EV\PYGZus{}KEY}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}SET\PYGZus{}KEYBIT}\PYG{p}{,} \PYG{n}{KEY\PYGZus{}SPACE}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{memset}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{uud}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{uud}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{snprintf}\PYG{p}{(}\PYG{n}{uud}\PYG{p}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{UINPUT\PYGZus{}MAX\PYGZus{}NAME\PYGZus{}SIZE}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{uinput old interface}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{write}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{uud}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{uud}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}DEV\PYGZus{}CREATE}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+cm}{/*}
\PYG{c+cm}{    * On UI\PYGZus{}DEV\PYGZus{}CREATE the kernel will create the device node for this}
\PYG{c+cm}{    * device. We are inserting a pause here so that userspace has time}
\PYG{c+cm}{    * to detect, initialize the new device, and can start listening to}
\PYG{c+cm}{    * the event, otherwise it will not notice the event we are about}
\PYG{c+cm}{    * to send. This pause is only needed in our example code!}
\PYG{c+cm}{    */}
   \PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+cm}{/* Key press, report the event, send key release, and report again */}
   \PYG{n}{emit}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{EV\PYGZus{}KEY}\PYG{p}{,} \PYG{n}{KEY\PYGZus{}SPACE}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{emit}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{EV\PYGZus{}SYN}\PYG{p}{,} \PYG{n}{SYN\PYGZus{}REPORT}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{emit}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{EV\PYGZus{}KEY}\PYG{p}{,} \PYG{n}{KEY\PYGZus{}SPACE}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{emit}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{EV\PYGZus{}SYN}\PYG{p}{,} \PYG{n}{SYN\PYGZus{}REPORT}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+cm}{/*}
\PYG{c+cm}{    * Give userspace some time to read the events before we destroy the}
\PYG{c+cm}{    * device with UI\PYGZus{}DEV\PYGZus{}DESTOY.}
\PYG{c+cm}{    */}
   \PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{ioctl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{UI\PYGZus{}DEV\PYGZus{}DESTROY}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{close}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\section{The userio Protocol}
\label{input/userio:the-userio-protocol}\label{input/userio::doc}\begin{quote}\begin{description}
\item[{Copyright}] \leavevmode
© 2015 Stephen Chandler Paul \textless{}\href{mailto:thatslyude@gmail.com}{thatslyude@gmail.com}\textgreater{}

\end{description}\end{quote}

Sponsored by Red Hat


\subsection{Introduction}
\label{input/userio:introduction}
This module is intended to try to make the lives of input driver developers
easier by allowing them to test various serio devices (mainly the various
touchpads found on laptops) without having to have the physical device in front
of them. userio accomplishes this by allowing any privileged userspace program
to directly interact with the kernel's serio driver and control a virtual serio
port from there.


\subsection{Usage overview}
\label{input/userio:usage-overview}
In order to interact with the userio kernel module, one simply opens the
/dev/userio character device in their applications. Commands are sent to the
kernel module by writing to the device, and any data received from the serio
driver is read as-is from the /dev/userio device. All of the structures and
macros you need to interact with the device are defined in \textless{}linux/userio.h\textgreater{} and
\textless{}linux/serio.h\textgreater{}.


\subsection{Command Structure}
\label{input/userio:command-structure}
The struct used for sending commands to /dev/userio is as follows:

\begin{Verbatim}[commandchars=\\\{\}]
struct userio\PYGZus{}cmd \PYGZob{}
        \PYGZus{}\PYGZus{}u8 type;
        \PYGZus{}\PYGZus{}u8 data;
\PYGZcb{};
\end{Verbatim}

\code{type} describes the type of command that is being sent. This can be any one
of the USERIO\_CMD macros defined in \textless{}linux/userio.h\textgreater{}. \code{data} is the argument
that goes along with the command. In the event that the command doesn't have an
argument, this field can be left untouched and will be ignored by the kernel.
Each command should be sent by writing the struct directly to the character
device. In the event that the command you send is invalid, an error will be
returned by the character device and a more descriptive error will be printed
to the kernel log. Only one command can be sent at a time, any additional data
written to the character device after the initial command will be ignored.

To close the virtual serio port, just close /dev/userio.


\subsection{Commands}
\label{input/userio:commands}

\subsubsection{USERIO\_CMD\_REGISTER}
\label{input/userio:userio-cmd-register}
Registers the port with the serio driver and begins transmitting data back and
forth. Registration can only be performed once a port type is set with
USERIO\_CMD\_SET\_PORT\_TYPE. Has no argument.


\subsubsection{USERIO\_CMD\_SET\_PORT\_TYPE}
\label{input/userio:userio-cmd-set-port-type}
Sets the type of port we're emulating, where \code{data} is the port type being
set. Can be any of the macros from \textless{}linux/serio.h\textgreater{}. For example: SERIO\_8042
would set the port type to be a normal PS/2 port.


\subsubsection{USERIO\_CMD\_SEND\_INTERRUPT}
\label{input/userio:userio-cmd-send-interrupt}
Sends an interrupt through the virtual serio port to the serio driver, where
\code{data} is the interrupt data being sent.


\subsection{Userspace tools}
\label{input/userio:userspace-tools}
The userio userspace tools are able to record PS/2 devices using some of the
debugging information from i8042, and play back the devices on /dev/userio. The
latest version of these tools can be found at:
\begin{quote}

\href{https://github.com/Lyude/ps2emu}{https://github.com/Lyude/ps2emu}
\end{quote}


\chapter{Linux Input Subsystem kernel API}
\label{input/input_kapi:linux-input-subsystem-kernel-api}\label{input/input_kapi::doc}
Table of Contents


\section{Creating an input device driver}
\label{input/input-programming::doc}\label{input/input-programming:creating-an-input-device-driver}

\subsection{The simplest example}
\label{input/input-programming:the-simplest-example}
Here comes a very simple example of an input device driver. The device has
just one button and the button is accessible at i/o port BUTTON\_PORT. When
pressed or released a BUTTON\_IRQ happens. The driver could look like:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}linux/input.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}linux/module.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}linux/init.h\PYGZgt{}

\PYGZsh{}include \PYGZlt{}asm/irq.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}asm/io.h\PYGZgt{}

static struct input\PYGZus{}dev *button\PYGZus{}dev;

static irqreturn\PYGZus{}t button\PYGZus{}interrupt(int irq, void *dummy)
\PYGZob{}
        input\PYGZus{}report\PYGZus{}key(button\PYGZus{}dev, BTN\PYGZus{}0, inb(BUTTON\PYGZus{}PORT) \PYGZam{} 1);
        input\PYGZus{}sync(button\PYGZus{}dev);
        return IRQ\PYGZus{}HANDLED;
\PYGZcb{}

static int \PYGZus{}\PYGZus{}init button\PYGZus{}init(void)
\PYGZob{}
        int error;

        if (request\PYGZus{}irq(BUTTON\PYGZus{}IRQ, button\PYGZus{}interrupt, 0, \PYGZdq{}button\PYGZdq{}, NULL)) \PYGZob{}
                printk(KERN\PYGZus{}ERR \PYGZdq{}button.c: Can\PYGZsq{}t allocate irq \PYGZpc{}d\PYGZbs{}n\PYGZdq{}, button\PYGZus{}irq);
                return \PYGZhy{}EBUSY;
        \PYGZcb{}

        button\PYGZus{}dev = input\PYGZus{}allocate\PYGZus{}device();
        if (!button\PYGZus{}dev) \PYGZob{}
                printk(KERN\PYGZus{}ERR \PYGZdq{}button.c: Not enough memory\PYGZbs{}n\PYGZdq{});
                error = \PYGZhy{}ENOMEM;
                goto err\PYGZus{}free\PYGZus{}irq;
        \PYGZcb{}

        button\PYGZus{}dev\PYGZhy{}\PYGZgt{}evbit[0] = BIT\PYGZus{}MASK(EV\PYGZus{}KEY);
        button\PYGZus{}dev\PYGZhy{}\PYGZgt{}keybit[BIT\PYGZus{}WORD(BTN\PYGZus{}0)] = BIT\PYGZus{}MASK(BTN\PYGZus{}0);

        error = input\PYGZus{}register\PYGZus{}device(button\PYGZus{}dev);
        if (error) \PYGZob{}
                printk(KERN\PYGZus{}ERR \PYGZdq{}button.c: Failed to register device\PYGZbs{}n\PYGZdq{});
                goto err\PYGZus{}free\PYGZus{}dev;
        \PYGZcb{}

        return 0;

err\PYGZus{}free\PYGZus{}dev:
        input\PYGZus{}free\PYGZus{}device(button\PYGZus{}dev);
err\PYGZus{}free\PYGZus{}irq:
        free\PYGZus{}irq(BUTTON\PYGZus{}IRQ, button\PYGZus{}interrupt);
        return error;
\PYGZcb{}

static void \PYGZus{}\PYGZus{}exit button\PYGZus{}exit(void)
\PYGZob{}
        input\PYGZus{}unregister\PYGZus{}device(button\PYGZus{}dev);
        free\PYGZus{}irq(BUTTON\PYGZus{}IRQ, button\PYGZus{}interrupt);
\PYGZcb{}

module\PYGZus{}init(button\PYGZus{}init);
module\PYGZus{}exit(button\PYGZus{}exit);
\end{Verbatim}


\subsection{What the example does}
\label{input/input-programming:what-the-example-does}
First it has to include the \textless{}linux/input.h\textgreater{} file, which interfaces to the
input subsystem. This provides all the definitions needed.

In the \_init function, which is called either upon module load or when
booting the kernel, it grabs the required resources (it should also check
for the presence of the device).

Then it allocates a new input device structure with input\_allocate\_device()
and sets up input bitfields. This way the device driver tells the other
parts of the input systems what it is - what events can be generated or
accepted by this input device. Our example device can only generate EV\_KEY
type events, and from those only BTN\_0 event code. Thus we only set these
two bits. We could have used:

\begin{Verbatim}[commandchars=\\\{\}]
set\PYGZus{}bit(EV\PYGZus{}KEY, button\PYGZus{}dev.evbit);
set\PYGZus{}bit(BTN\PYGZus{}0, button\PYGZus{}dev.keybit);
\end{Verbatim}

as well, but with more than single bits the first approach tends to be
shorter.

Then the example driver registers the input device structure by calling:

\begin{Verbatim}[commandchars=\\\{\}]
input\PYGZus{}register\PYGZus{}device(\PYGZam{}button\PYGZus{}dev);
\end{Verbatim}

This adds the button\_dev structure to linked lists of the input driver and
calls device handler modules \_connect functions to tell them a new input
device has appeared. input\_register\_device() may sleep and therefore must
not be called from an interrupt or with a spinlock held.

While in use, the only used function of the driver is:

\begin{Verbatim}[commandchars=\\\{\}]
button\PYGZus{}interrupt()
\end{Verbatim}

which upon every interrupt from the button checks its state and reports it
via the:

\begin{Verbatim}[commandchars=\\\{\}]
input\PYGZus{}report\PYGZus{}key()
\end{Verbatim}

call to the input system. There is no need to check whether the interrupt
routine isn't reporting two same value events (press, press for example) to
the input system, because the input\_report\_* functions check that
themselves.

Then there is the:

\begin{Verbatim}[commandchars=\\\{\}]
input\PYGZus{}sync()
\end{Verbatim}

call to tell those who receive the events that we've sent a complete report.
This doesn't seem important in the one button case, but is quite important
for for example mouse movement, where you don't want the X and Y values
to be interpreted separately, because that'd result in a different movement.


\subsection{dev-\textgreater{}open() and dev-\textgreater{}close()}
\label{input/input-programming:dev-open-and-dev-close}
In case the driver has to repeatedly poll the device, because it doesn't
have an interrupt coming from it and the polling is too expensive to be done
all the time, or if the device uses a valuable resource (eg. interrupt), it
can use the open and close callback to know when it can stop polling or
release the interrupt and when it must resume polling or grab the interrupt
again. To do that, we would add this to our example driver:

\begin{Verbatim}[commandchars=\\\{\}]
static int button\PYGZus{}open(struct input\PYGZus{}dev *dev)
\PYGZob{}
        if (request\PYGZus{}irq(BUTTON\PYGZus{}IRQ, button\PYGZus{}interrupt, 0, \PYGZdq{}button\PYGZdq{}, NULL)) \PYGZob{}
                printk(KERN\PYGZus{}ERR \PYGZdq{}button.c: Can\PYGZsq{}t allocate irq \PYGZpc{}d\PYGZbs{}n\PYGZdq{}, button\PYGZus{}irq);
                return \PYGZhy{}EBUSY;
        \PYGZcb{}

        return 0;
\PYGZcb{}

static void button\PYGZus{}close(struct input\PYGZus{}dev *dev)
\PYGZob{}
        free\PYGZus{}irq(IRQ\PYGZus{}AMIGA\PYGZus{}VERTB, button\PYGZus{}interrupt);
\PYGZcb{}

static int \PYGZus{}\PYGZus{}init button\PYGZus{}init(void)
\PYGZob{}
        ...
        button\PYGZus{}dev\PYGZhy{}\PYGZgt{}open = button\PYGZus{}open;
        button\PYGZus{}dev\PYGZhy{}\PYGZgt{}close = button\PYGZus{}close;
        ...
\PYGZcb{}
\end{Verbatim}

Note that input core keeps track of number of users for the device and
makes sure that dev-\textgreater{}open() is called only when the first user connects
to the device and that dev-\textgreater{}close() is called when the very last user
disconnects. Calls to both callbacks are serialized.

The open() callback should return a 0 in case of success or any nonzero value
in case of failure. The close() callback (which is void) must always succeed.


\subsection{Basic event types}
\label{input/input-programming:basic-event-types}
The most simple event type is EV\_KEY, which is used for keys and buttons.
It's reported to the input system via:

\begin{Verbatim}[commandchars=\\\{\}]
input\PYGZus{}report\PYGZus{}key(struct input\PYGZus{}dev *dev, int code, int value)
\end{Verbatim}

See uapi/linux/input-event-codes.h for the allowable values of code (from 0 to
KEY\_MAX). Value is interpreted as a truth value, ie any nonzero value means key
pressed, zero value means key released. The input code generates events only
in case the value is different from before.

In addition to EV\_KEY, there are two more basic event types: EV\_REL and
EV\_ABS. They are used for relative and absolute values supplied by the
device. A relative value may be for example a mouse movement in the X axis.
The mouse reports it as a relative difference from the last position,
because it doesn't have any absolute coordinate system to work in. Absolute
events are namely for joysticks and digitizers - devices that do work in an
absolute coordinate systems.

Having the device report EV\_REL buttons is as simple as with EV\_KEY, simply
set the corresponding bits and call the:

\begin{Verbatim}[commandchars=\\\{\}]
input\PYGZus{}report\PYGZus{}rel(struct input\PYGZus{}dev *dev, int code, int value)
\end{Verbatim}

function. Events are generated only for nonzero value.

However EV\_ABS requires a little special care. Before calling
input\_register\_device, you have to fill additional fields in the input\_dev
struct for each absolute axis your device has. If our button device had also
the ABS\_X axis:

\begin{Verbatim}[commandchars=\\\{\}]
button\PYGZus{}dev.absmin[ABS\PYGZus{}X] = 0;
button\PYGZus{}dev.absmax[ABS\PYGZus{}X] = 255;
button\PYGZus{}dev.absfuzz[ABS\PYGZus{}X] = 4;
button\PYGZus{}dev.absflat[ABS\PYGZus{}X] = 8;
\end{Verbatim}

Or, you can just say:

\begin{Verbatim}[commandchars=\\\{\}]
input\PYGZus{}set\PYGZus{}abs\PYGZus{}params(button\PYGZus{}dev, ABS\PYGZus{}X, 0, 255, 4, 8);
\end{Verbatim}

This setting would be appropriate for a joystick X axis, with the minimum of
0, maximum of 255 (which the joystick \emph{must} be able to reach, no problem if
it sometimes reports more, but it must be able to always reach the min and
max values), with noise in the data up to +- 4, and with a center flat
position of size 8.

If you don't need absfuzz and absflat, you can set them to zero, which mean
that the thing is precise and always returns to exactly the center position
(if it has any).


\subsection{BITS\_TO\_LONGS(), BIT\_WORD(), BIT\_MASK()}
\label{input/input-programming:bits-to-longs-bit-word-bit-mask}
These three macros from bitops.h help some bitfield computations:

\begin{Verbatim}[commandchars=\\\{\}]
BITS\PYGZus{}TO\PYGZus{}LONGS(x) \PYGZhy{} returns the length of a bitfield array in longs for
                   x bits
BIT\PYGZus{}WORD(x)      \PYGZhy{} returns the index in the array in longs for bit x
BIT\PYGZus{}MASK(x)      \PYGZhy{} returns the index in a long for bit x
\end{Verbatim}


\subsection{The id* and name fields}
\label{input/input-programming:the-id-and-name-fields}
The dev-\textgreater{}name should be set before registering the input device by the input
device driver. It's a string like `Generic button device' containing a
user friendly name of the device.

The id* fields contain the bus ID (PCI, USB, ...), vendor ID and device ID
of the device. The bus IDs are defined in input.h. The vendor and device ids
are defined in pci\_ids.h, usb\_ids.h and similar include files. These fields
should be set by the input device driver before registering it.

The idtype field can be used for specific information for the input device
driver.

The id and name fields can be passed to userland via the evdev interface.


\subsection{The keycode, keycodemax, keycodesize fields}
\label{input/input-programming:the-keycode-keycodemax-keycodesize-fields}
These three fields should be used by input devices that have dense keymaps.
The keycode is an array used to map from scancodes to input system keycodes.
The keycode max should contain the size of the array and keycodesize the
size of each entry in it (in bytes).

Userspace can query and alter current scancode to keycode mappings using
EVIOCGKEYCODE and EVIOCSKEYCODE ioctls on corresponding evdev interface.
When a device has all 3 aforementioned fields filled in, the driver may
rely on kernel's default implementation of setting and querying keycode
mappings.


\subsection{dev-\textgreater{}getkeycode() and dev-\textgreater{}setkeycode()}
\label{input/input-programming:dev-getkeycode-and-dev-setkeycode}
getkeycode() and setkeycode() callbacks allow drivers to override default
keycode/keycodesize/keycodemax mapping mechanism provided by input core
and implement sparse keycode maps.


\subsection{Key autorepeat}
\label{input/input-programming:key-autorepeat}
... is simple. It is handled by the input.c module. Hardware autorepeat is
not used, because it's not present in many devices and even where it is
present, it is broken sometimes (at keyboards: Toshiba notebooks). To enable
autorepeat for your device, just set EV\_REP in dev-\textgreater{}evbit. All will be
handled by the input system.


\subsection{Other event types, handling output events}
\label{input/input-programming:other-event-types-handling-output-events}
The other event types up to now are:
\begin{itemize}
\item {} 
EV\_LED - used for the keyboard LEDs.

\item {} 
EV\_SND - used for keyboard beeps.

\end{itemize}

They are very similar to for example key events, but they go in the other
direction - from the system to the input device driver. If your input device
driver can handle these events, it has to set the respective bits in evbit,
\emph{and} also the callback routine:

\begin{Verbatim}[commandchars=\\\{\}]
button\PYGZus{}dev\PYGZhy{}\PYGZgt{}event = button\PYGZus{}event;

int button\PYGZus{}event(struct input\PYGZus{}dev *dev, unsigned int type,
                 unsigned int code, int value)
\PYGZob{}
        if (type == EV\PYGZus{}SND \PYGZam{}\PYGZam{} code == SND\PYGZus{}BELL) \PYGZob{}
                outb(value, BUTTON\PYGZus{}BELL);
                return 0;
        \PYGZcb{}
        return \PYGZhy{}1;
\PYGZcb{}
\end{Verbatim}

This callback routine can be called from an interrupt or a BH (although that
isn't a rule), and thus must not sleep, and must not take too long to finish.


\section{Programming gameport drivers}
\label{input/gameport-programming:programming-gameport-drivers}\label{input/gameport-programming::doc}

\subsection{A basic classic gameport}
\label{input/gameport-programming:a-basic-classic-gameport}
If the gameport doesn't provide more than the inb()/outb() functionality,
the code needed to register it with the joystick drivers is simple:

\begin{Verbatim}[commandchars=\\\{\}]
struct gameport gameport;

gameport.io = MY\PYGZus{}IO\PYGZus{}ADDRESS;
gameport\PYGZus{}register\PYGZus{}port(\PYGZam{}gameport);
\end{Verbatim}

Make sure struct gameport is initialized to 0 in all other fields. The
gameport generic code will take care of the rest.

If your hardware supports more than one io address, and your driver can
choose which one to program the hardware to, starting from the more exotic
addresses is preferred, because the likelihood of clashing with the standard
0x201 address is smaller.

Eg. if your driver supports addresses 0x200, 0x208, 0x210 and 0x218, then
0x218 would be the address of first choice.

If your hardware supports a gameport address that is not mapped to ISA io
space (is above 0x1000), use that one, and don't map the ISA mirror.

Also, always request\_region() on the whole io space occupied by the
gameport. Although only one ioport is really used, the gameport usually
occupies from one to sixteen addresses in the io space.

Please also consider enabling the gameport on the card in the -\textgreater{}open()
callback if the io is mapped to ISA space - this way it'll occupy the io
space only when something really is using it. Disable it again in the
-\textgreater{}close() callback. You also can select the io address in the -\textgreater{}open()
callback, so that it doesn't fail if some of the possible addresses are
already occupied by other gameports.


\subsection{Memory mapped gameport}
\label{input/gameport-programming:memory-mapped-gameport}
When a gameport can be accessed through MMIO, this way is preferred, because
it is faster, allowing more reads per second. Registering such a gameport
isn't as easy as a basic IO one, but not so much complex:

\begin{Verbatim}[commandchars=\\\{\}]
struct gameport gameport;

void my\PYGZus{}trigger(struct gameport *gameport)
\PYGZob{}
        my\PYGZus{}mmio = 0xff;
\PYGZcb{}

unsigned char my\PYGZus{}read(struct gameport *gameport)
\PYGZob{}
        return my\PYGZus{}mmio;
\PYGZcb{}

gameport.read = my\PYGZus{}read;
gameport.trigger = my\PYGZus{}trigger;
gameport\PYGZus{}register\PYGZus{}port(\PYGZam{}gameport);
\end{Verbatim}


\subsection{Cooked mode gameport}
\label{input/gameport-programming:cooked-mode-gameport}\label{input/gameport-programming:gameport-pgm-cooked-mode}
There are gameports that can report the axis values as numbers, that means
the driver doesn't have to measure them the old way - an ADC is built into
the gameport. To register a cooked gameport:

\begin{Verbatim}[commandchars=\\\{\}]
struct gameport gameport;

int my\PYGZus{}cooked\PYGZus{}read(struct gameport *gameport, int *axes, int *buttons)
\PYGZob{}
        int i;

        for (i = 0; i \PYGZlt{} 4; i++)
                axes[i] = my\PYGZus{}mmio[i];
        buttons[i] = my\PYGZus{}mmio[4];
\PYGZcb{}

int my\PYGZus{}open(struct gameport *gameport, int mode)
\PYGZob{}
        return \PYGZhy{}(mode != GAMEPORT\PYGZus{}MODE\PYGZus{}COOKED);
\PYGZcb{}

gameport.cooked\PYGZus{}read = my\PYGZus{}cooked\PYGZus{}read;
gameport.open = my\PYGZus{}open;
gameport.fuzz = 8;
gameport\PYGZus{}register\PYGZus{}port(\PYGZam{}gameport);
\end{Verbatim}

The only confusing thing here is the fuzz value. Best determined by
experimentation, it is the amount of noise in the ADC data. Perfect
gameports can set this to zero, most common have fuzz between 8 and 32.
See analog.c and input.c for handling of fuzz - the fuzz value determines
the size of a gaussian filter window that is used to eliminate the noise
in the data.


\subsection{More complex gameports}
\label{input/gameport-programming:more-complex-gameports}
Gameports can support both raw and cooked modes. In that case combine either
examples 1+2 or 1+3. Gameports can support internal calibration - see below,
and also lightning.c and analog.c on how that works. If your driver supports
more than one gameport instance simultaneously, use the -\textgreater{}private member of
the gameport struct to point to your data.


\subsection{Unregistering a gameport}
\label{input/gameport-programming:unregistering-a-gameport}
Simple:

\begin{Verbatim}[commandchars=\\\{\}]
gameport\PYGZus{}unregister\PYGZus{}port(\PYGZam{}gameport);
\end{Verbatim}


\subsection{The gameport structure}
\label{input/gameport-programming:the-gameport-structure}
\begin{notice}{note}{Note:}
This section is outdated. There are several fields here that don't
match what's there at include/linux/gameport.h.
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
struct gameport \PYGZob{}

    void *private;
\end{Verbatim}

A private pointer for free use in the gameport driver. (Not the joystick
driver!)

\begin{Verbatim}[commandchars=\\\{\}]
int number;
\end{Verbatim}

Number assigned to the gameport when registered. Informational purpose only.

\begin{Verbatim}[commandchars=\\\{\}]
int io;
\end{Verbatim}

I/O address for use with raw mode. You have to either set this, or -\textgreater{}read()
to some value if your gameport supports raw mode.

\begin{Verbatim}[commandchars=\\\{\}]
int speed;
\end{Verbatim}

Raw mode speed of the gameport reads in thousands of reads per second.

\begin{Verbatim}[commandchars=\\\{\}]
int fuzz;
\end{Verbatim}

If the gameport supports cooked mode, this should be set to a value that
represents the amount of noise in the data. See
{\hyperref[input/gameport\string-programming:gameport\string-pgm\string-cooked\string-mode]{\emph{Cooked mode gameport}}}.

\begin{Verbatim}[commandchars=\\\{\}]
void (*trigger)(struct gameport *);
\end{Verbatim}

Trigger. This function should trigger the ns558 oneshots. If set to NULL,
outb(0xff, io) will be used.

\begin{Verbatim}[commandchars=\\\{\}]
unsigned char (*read)(struct gameport *);
\end{Verbatim}

Read the buttons and ns558 oneshot bits. If set to NULL, inb(io) will be
used instead.

\begin{Verbatim}[commandchars=\\\{\}]
int (*cooked\PYGZus{}read)(struct gameport *, int *axes, int *buttons);
\end{Verbatim}

If the gameport supports cooked mode, it should point this to its cooked
read function. It should fill axes{[}0..3{]} with four values of the joystick axes
and buttons{[}0{]} with four bits representing the buttons.

\begin{Verbatim}[commandchars=\\\{\}]
int (*calibrate)(struct gameport *, int *axes, int *max);
\end{Verbatim}

Function for calibrating the ADC hardware. When called, axes{[}0..3{]} should be
pre-filled by cooked data by the caller, max{[}0..3{]} should be pre-filled with
expected maximums for each axis. The calibrate() function should set the
sensitivity of the ADC hardware so that the maximums fit in its range and
recompute the axes{[}{]} values to match the new sensitivity or re-read them from
the hardware so that they give valid values.

\begin{Verbatim}[commandchars=\\\{\}]
int (*open)(struct gameport *, int mode);
\end{Verbatim}

Open() serves two purposes. First a driver either opens the port in raw or
in cooked mode, the open() callback can decide which modes are supported.
Second, resource allocation can happen here. The port can also be enabled
here. Prior to this call, other fields of the gameport struct (namely the io
member) need not to be valid.

\begin{Verbatim}[commandchars=\\\{\}]
void (*close)(struct gameport *);
\end{Verbatim}

Close() should free the resources allocated by open, possibly disabling the
gameport.

\begin{Verbatim}[commandchars=\\\{\}]
struct gameport\PYGZus{}dev *dev;
struct gameport *next;
\end{Verbatim}

For internal use by the gameport layer.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZcb{};
\end{Verbatim}

Enjoy!


\section{Keyboard notifier}
\label{input/notifier::doc}\label{input/notifier:keyboard-notifier}
One can use register\_keyboard\_notifier to get called back on keyboard
events (see kbd\_keycode() function for details).  The passed structure is
keyboard\_notifier\_param:
\begin{itemize}
\item {} 
`vc' always provide the VC for which the keyboard event applies;

\item {} 
`down' is 1 for a key press event, 0 for a key release;

\item {} 
`shift' is the current modifier state, mask bit indexes are KG\_*;

\item {} 
`value' depends on the type of event.

\item {} 
KBD\_KEYCODE events are always sent before other events, value is the keycode.

\item {} 
KBD\_UNBOUND\_KEYCODE events are sent if the keycode is not bound to a keysym.
value is the keycode.

\item {} 
KBD\_UNICODE events are sent if the keycode -\textgreater{} keysym translation produced a
unicode character. value is the unicode value.

\item {} 
KBD\_KEYSYM events are sent if the keycode -\textgreater{} keysym translation produced a
non-unicode character. value is the keysym.

\item {} 
KBD\_POST\_KEYSYM events are sent after the treatment of non-unicode keysyms.
That permits one to inspect the resulting LEDs for instance.

\end{itemize}

For each kind of event but the last, the callback may return NOTIFY\_STOP in
order to ``eat'' the event: the notify loop is stopped and the keyboard event is
dropped.

In a rough C snippet, we have:

\begin{Verbatim}[commandchars=\\\{\}]
kbd\PYGZus{}keycode(keycode) \PYGZob{}
    ...
    params.value = keycode;
    if (notifier\PYGZus{}call\PYGZus{}chain(KBD\PYGZus{}KEYCODE,\PYGZam{}params) == NOTIFY\PYGZus{}STOP)
        \textbar{}\textbar{} !bound) \PYGZob{}
            notifier\PYGZus{}call\PYGZus{}chain(KBD\PYGZus{}UNBOUND\PYGZus{}KEYCODE,\PYGZam{}params);
            return;
    \PYGZcb{}

    if (unicode) \PYGZob{}
            param.value = unicode;
            if (notifier\PYGZus{}call\PYGZus{}chain(KBD\PYGZus{}UNICODE,\PYGZam{}params) == NOTIFY\PYGZus{}STOP)
                    return;
            emit unicode;
            return;
    \PYGZcb{}

    params.value = keysym;
    if (notifier\PYGZus{}call\PYGZus{}chain(KBD\PYGZus{}KEYSYM,\PYGZam{}params) == NOTIFY\PYGZus{}STOP)
            return;
    apply keysym;
    notifier\PYGZus{}call\PYGZus{}chain(KBD\PYGZus{}POST\PYGZus{}KEYSYM,\PYGZam{}params);
\PYGZcb{}
\end{Verbatim}

\begin{notice}{note}{Note:}
This notifier is usually called from interrupt context.
\end{notice}


\chapter{Driver-specific documentation}
\label{input/devices/index:driver-specific-documentation}\label{input/devices/index::doc}
This section provides information about various devices supported by the
Linux kernel, their protocols, and driver details.


\section{ALPS Touchpad Protocol}
\label{input/devices/alps:alps-touchpad-protocol}\label{input/devices/alps::doc}

\subsection{Introduction}
\label{input/devices/alps:introduction}
Currently the ALPS touchpad driver supports seven protocol versions in use by
ALPS touchpads, called versions 1, 2, 3, 4, 5, 6, 7 and 8.

Since roughly mid-2010 several new ALPS touchpads have been released and
integrated into a variety of laptops and netbooks.  These new touchpads
have enough behavior differences that the alps\_model\_data definition
table, describing the properties of the different versions, is no longer
adequate.  The design choices were to re-define the alps\_model\_data
table, with the risk of regression testing existing devices, or isolate
the new devices outside of the alps\_model\_data table.  The latter design
choice was made.  The new touchpad signatures are named: ``Rushmore'',
``Pinnacle'', and ``Dolphin'', which you will see in the alps.c code.
For the purposes of this document, this group of ALPS touchpads will
generically be called ``new ALPS touchpads''.

We experimented with probing the ACPI interface \_HID (Hardware ID)/\_CID
(Compatibility ID) definition as a way to uniquely identify the
different ALPS variants but there did not appear to be a 1:1 mapping.
In fact, it appeared to be an m:n mapping between the \_HID and actual
hardware type.


\subsection{Detection}
\label{input/devices/alps:detection}
All ALPS touchpads should respond to the ``E6 report'' command sequence:
E8-E6-E6-E6-E9. An ALPS touchpad should respond with either 00-00-0A or
00-00-64 if no buttons are pressed. The bits 0-2 of the first byte will be 1s
if some buttons are pressed.

If the E6 report is successful, the touchpad model is identified using the ``E7
report'' sequence: E8-E7-E7-E7-E9. The response is the model signature and is
matched against known models in the alps\_model\_data\_array.

For older touchpads supporting protocol versions 3 and 4, the E7 report
model signature is always 73-02-64. To differentiate between these
versions, the response from the ``Enter Command Mode'' sequence must be
inspected as described below.

The new ALPS touchpads have an E7 signature of 73-03-50 or 73-03-0A but
seem to be better differentiated by the EC Command Mode response.


\subsection{Command Mode}
\label{input/devices/alps:command-mode}
Protocol versions 3 and 4 have a command mode that is used to read and write
one-byte device registers in a 16-bit address space. The command sequence
EC-EC-EC-E9 places the device in command mode, and the device will respond
with 88-07 followed by a third byte. This third byte can be used to determine
whether the devices uses the version 3 or 4 protocol.

To exit command mode, PSMOUSE\_CMD\_SETSTREAM (EA) is sent to the touchpad.

While in command mode, register addresses can be set by first sending a
specific command, either EC for v3 devices or F5 for v4 devices. Then the
address is sent one nibble at a time, where each nibble is encoded as a
command with optional data. This encoding differs slightly between the v3 and
v4 protocols.

Once an address has been set, the addressed register can be read by sending
PSMOUSE\_CMD\_GETINFO (E9). The first two bytes of the response contains the
address of the register being read, and the third contains the value of the
register. Registers are written by writing the value one nibble at a time
using the same encoding used for addresses.

For the new ALPS touchpads, the EC command is used to enter command
mode. The response in the new ALPS touchpads is significantly different,
and more important in determining the behavior.  This code has been
separated from the original alps\_model\_data table and put in the
alps\_identify function.  For example, there seem to be two hardware init
sequences for the ``Dolphin'' touchpads as determined by the second byte
of the EC response.


\subsection{Packet Format}
\label{input/devices/alps:packet-format}
In the following tables, the following notation is used:

\begin{Verbatim}[commandchars=\\\{\}]
CAPITALS = stick, miniscules = touchpad
\end{Verbatim}

?'s can have different meanings on different models, such as wheel rotation,
extra buttons, stick buttons on a dualpoint, etc.


\subsection{PS/2 packet format}
\label{input/devices/alps:ps-2-packet-format}
\begin{Verbatim}[commandchars=\\\{\}]
byte 0:  0    0 YSGN XSGN    1    M    R    L
byte 1: X7   X6   X5   X4   X3   X2   X1   X0
byte 2: Y7   Y6   Y5   Y4   Y3   Y2   Y1   Y0
\end{Verbatim}

Note that the device never signals overflow condition.

For protocol version 2 devices when the trackpoint is used, and no fingers
are on the touchpad, the M R L bits signal the combined status of both the
pointingstick and touchpad buttons.


\subsection{ALPS Absolute Mode - Protocol Version 1}
\label{input/devices/alps:alps-absolute-mode-protocol-version-1}
\begin{Verbatim}[commandchars=\\\{\}]
byte 0:  1    0    0    0    1   x9   x8   x7
byte 1:  0   x6   x5   x4   x3   x2   x1   x0
byte 2:  0    ?    ?    l    r    ?  fin  ges
byte 3:  0    ?    ?    ?    ?   y9   y8   y7
byte 4:  0   y6   y5   y4   y3   y2   y1   y0
byte 5:  0   z6   z5   z4   z3   z2   z1   z0
\end{Verbatim}


\subsection{ALPS Absolute Mode - Protocol Version 2}
\label{input/devices/alps:alps-absolute-mode-protocol-version-2}
\begin{Verbatim}[commandchars=\\\{\}]
byte 0:  1    ?    ?    ?    1  PSM  PSR  PSL
byte 1:  0   x6   x5   x4   x3   x2   x1   x0
byte 2:  0  x10   x9   x8   x7    ?  fin  ges
byte 3:  0   y9   y8   y7    1    M    R    L
byte 4:  0   y6   y5   y4   y3   y2   y1   y0
byte 5:  0   z6   z5   z4   z3   z2   z1   z0
\end{Verbatim}

Protocol Version 2 DualPoint devices send standard PS/2 mouse packets for
the DualPoint Stick. The M, R and L bits signal the combined status of both
the pointingstick and touchpad buttons, except for Dell dualpoint devices
where the pointingstick buttons get reported separately in the PSM, PSR
and PSL bits.


\subsection{Dualpoint device -- interleaved packet format}
\label{input/devices/alps:dualpoint-device-interleaved-packet-format}
\begin{Verbatim}[commandchars=\\\{\}]
byte 0:    1    1    0    0    1    1    1    1
byte 1:    0   x6   x5   x4   x3   x2   x1   x0
byte 2:    0  x10   x9   x8   x7    0  fin  ges
byte 3:    0    0 YSGN XSGN    1    1    1    1
byte 4:   X7   X6   X5   X4   X3   X2   X1   X0
byte 5:   Y7   Y6   Y5   Y4   Y3   Y2   Y1   Y0
byte 6:    0   y9   y8   y7    1    m    r    l
byte 7:    0   y6   y5   y4   y3   y2   y1   y0
byte 8:    0   z6   z5   z4   z3   z2   z1   z0
\end{Verbatim}

Devices which use the interleaving format normally send standard PS/2 mouse
packets for the DualPoint Stick + ALPS Absolute Mode packets for the
touchpad, switching to the interleaved packet format when both the stick and
the touchpad are used at the same time.


\subsection{ALPS Absolute Mode - Protocol Version 3}
\label{input/devices/alps:alps-absolute-mode-protocol-version-3}
ALPS protocol version 3 has three different packet formats. The first two are
associated with touchpad events, and the third is associated with trackstick
events.

The first type is the touchpad position packet:

\begin{Verbatim}[commandchars=\\\{\}]
byte 0:    1    ?   x1   x0    1    1    1    1
byte 1:    0  x10   x9   x8   x7   x6   x5   x4
byte 2:    0  y10   y9   y8   y7   y6   y5   y4
byte 3:    0    M    R    L    1    m    r    l
byte 4:    0   mt   x3   x2   y3   y2   y1   y0
byte 5:    0   z6   z5   z4   z3   z2   z1   z0
\end{Verbatim}

Note that for some devices the trackstick buttons are reported in this packet,
and on others it is reported in the trackstick packets.

The second packet type contains bitmaps representing the x and y axes. In the
bitmaps a given bit is set if there is a finger covering that position on the
given axis. Thus the bitmap packet can be used for low-resolution multi-touch
data, although finger tracking is not possible.  This packet also encodes the
number of contacts (f1 and f0 in the table below):

\begin{Verbatim}[commandchars=\\\{\}]
byte 0:    1    1   x1   x0    1    1    1    1
byte 1:    0   x8   x7   x6   x5   x4   x3   x2
byte 2:    0   y7   y6   y5   y4   y3   y2   y1
byte 3:    0  y10   y9   y8    1    1    1    1
byte 4:    0  x14  x13  x12  x11  x10   x9   y0
byte 5:    0    1    ?    ?    ?    ?   f1   f0
\end{Verbatim}

This packet only appears after a position packet with the mt bit set, and
usually only appears when there are two or more contacts (although
occasionally it's seen with only a single contact).

The final v3 packet type is the trackstick packet:

\begin{Verbatim}[commandchars=\\\{\}]
byte 0:    1    1   x7   y7    1    1    1    1
byte 1:    0   x6   x5   x4   x3   x2   x1   x0
byte 2:    0   y6   y5   y4   y3   y2   y1   y0
byte 3:    0    1    0    0    1    0    0    0
byte 4:    0   z4   z3   z2   z1   z0    ?    ?
byte 5:    0    0    1    1    1    1    1    1
\end{Verbatim}


\subsection{ALPS Absolute Mode - Protocol Version 4}
\label{input/devices/alps:alps-absolute-mode-protocol-version-4}
Protocol version 4 has an 8-byte packet format:

\begin{Verbatim}[commandchars=\\\{\}]
byte 0:    1    ?   x1   x0    1    1    1    1
byte 1:    0  x10   x9   x8   x7   x6   x5   x4
byte 2:    0  y10   y9   y8   y7   y6   y5   y4
byte 3:    0    1   x3   x2   y3   y2   y1   y0
byte 4:    0    ?    ?    ?    1    ?    r    l
byte 5:    0   z6   z5   z4   z3   z2   z1   z0
byte 6:    bitmap data (described below)
byte 7:    bitmap data (described below)
\end{Verbatim}

The last two bytes represent a partial bitmap packet, with 3 full packets
required to construct a complete bitmap packet.  Once assembled, the 6-byte
bitmap packet has the following format:

\begin{Verbatim}[commandchars=\\\{\}]
byte 0:    0    1   x7   x6   x5   x4   x3   x2
byte 1:    0   x1   x0   y4   y3   y2   y1   y0
byte 2:    0    0    ?  x14  x13  x12  x11  x10
byte 3:    0   x9   x8   y9   y8   y7   y6   y5
byte 4:    0    0    0    0    0    0    0    0
byte 5:    0    0    0    0    0    0    0  y10
\end{Verbatim}

There are several things worth noting here.
\begin{enumerate}
\item {} 
In the bitmap data, bit 6 of byte 0 serves as a sync byte to
identify the first fragment of a bitmap packet.

\item {} 
The bitmaps represent the same data as in the v3 bitmap packets, although
the packet layout is different.

\item {} 
There doesn't seem to be a count of the contact points anywhere in the v4
protocol packets. Deriving a count of contact points must be done by
analyzing the bitmaps.

\item {} 
There is a 3 to 1 ratio of position packets to bitmap packets. Therefore
MT position can only be updated for every third ST position update, and
the count of contact points can only be updated every third packet as
well.

\end{enumerate}

So far no v4 devices with tracksticks have been encountered.


\subsection{ALPS Absolute Mode - Protocol Version 5}
\label{input/devices/alps:alps-absolute-mode-protocol-version-5}
This is basically Protocol Version 3 but with different logic for packet
decode.  It uses the same alps\_process\_touchpad\_packet\_v3 call with a
specialized decode\_fields function pointer to correctly interpret the
packets.  This appears to only be used by the Dolphin devices.

For single-touch, the 6-byte packet format is:

\begin{Verbatim}[commandchars=\\\{\}]
byte 0:    1    1    0    0    1    0    0    0
byte 1:    0   x6   x5   x4   x3   x2   x1   x0
byte 2:    0   y6   y5   y4   y3   y2   y1   y0
byte 3:    0    M    R    L    1    m    r    l
byte 4:   y10  y9   y8   y7  x10   x9   x8   x7
byte 5:    0   z6   z5   z4   z3   z2   z1   z0
\end{Verbatim}

For mt, the format is:

\begin{Verbatim}[commandchars=\\\{\}]
byte 0:    1    1    1    n3   1   n2   n1   x24
byte 1:    1   y7   y6    y5  y4   y3   y2    y1
byte 2:    ?   x2   x1   y12 y11  y10   y9    y8
byte 3:    0  x23  x22   x21 x20  x19  x18   x17
byte 4:    0   x9   x8    x7  x6   x5   x4    x3
byte 5:    0  x16  x15   x14 x13  x12  x11   x10
\end{Verbatim}


\subsection{ALPS Absolute Mode - Protocol Version 6}
\label{input/devices/alps:alps-absolute-mode-protocol-version-6}
For trackstick packet, the format is:

\begin{Verbatim}[commandchars=\\\{\}]
byte 0:    1    1    1    1    1    1    1    1
byte 1:    0   X6   X5   X4   X3   X2   X1   X0
byte 2:    0   Y6   Y5   Y4   Y3   Y2   Y1   Y0
byte 3:    ?   Y7   X7    ?    ?    M    R    L
byte 4:   Z7   Z6   Z5   Z4   Z3   Z2   Z1   Z0
byte 5:    0    1    1    1    1    1    1    1
\end{Verbatim}

For touchpad packet, the format is:

\begin{Verbatim}[commandchars=\\\{\}]
byte 0:    1    1    1    1    1    1    1    1
byte 1:    0    0    0    0   x3   x2   x1   x0
byte 2:    0    0    0    0   y3   y2   y1   y0
byte 3:    ?   x7   x6   x5   x4    ?    r    l
byte 4:    ?   y7   y6   y5   y4    ?    ?    ?
byte 5:   z7   z6   z5   z4   z3   z2   z1   z0
\end{Verbatim}

(v6 touchpad does not have middle button)


\subsection{ALPS Absolute Mode - Protocol Version 7}
\label{input/devices/alps:alps-absolute-mode-protocol-version-7}
For trackstick packet, the format is:

\begin{Verbatim}[commandchars=\\\{\}]
byte 0:    0    1    0    0    1    0    0    0
byte 1:    1    1    *    *    1    M    R    L
byte 2:   X7    1   X5   X4   X3   X2   X1   X0
byte 3:   Z6    1   Y6   X6    1   Y2   Y1   Y0
byte 4:   Y7    0   Y5   Y4   Y3    1    1    0
byte 5:  T\PYGZam{}P    0   Z5   Z4   Z3   Z2   Z1   Z0
\end{Verbatim}

For touchpad packet, the format is:

\begin{Verbatim}[commandchars=\\\{\}]
        packet\PYGZhy{}fmt     b7     b6     b5     b4     b3     b2     b1     b0
byte 0: TWO \PYGZam{} MULTI     L      1      R      M      1   Y0\PYGZhy{}2   Y0\PYGZhy{}1   Y0\PYGZhy{}0
byte 0: NEW             L      1   X1\PYGZhy{}5      1      1   Y0\PYGZhy{}2   Y0\PYGZhy{}1   Y0\PYGZhy{}0
byte 1:             Y0\PYGZhy{}10   Y0\PYGZhy{}9   Y0\PYGZhy{}8   Y0\PYGZhy{}7   Y0\PYGZhy{}6   Y0\PYGZhy{}5   Y0\PYGZhy{}4   Y0\PYGZhy{}3
byte 2:             X0\PYGZhy{}11      1  X0\PYGZhy{}10   X0\PYGZhy{}9   X0\PYGZhy{}8   X0\PYGZhy{}7   X0\PYGZhy{}6   X0\PYGZhy{}5
byte 3:             X1\PYGZhy{}11      1   X0\PYGZhy{}4   X0\PYGZhy{}3      1   X0\PYGZhy{}2   X0\PYGZhy{}1   X0\PYGZhy{}0
byte 4: TWO         X1\PYGZhy{}10    TWO   X1\PYGZhy{}9   X1\PYGZhy{}8   X1\PYGZhy{}7   X1\PYGZhy{}6   X1\PYGZhy{}5   X1\PYGZhy{}4
byte 4: MULTI       X1\PYGZhy{}10    TWO   X1\PYGZhy{}9   X1\PYGZhy{}8   X1\PYGZhy{}7   X1\PYGZhy{}6   Y1\PYGZhy{}5      1
byte 4: NEW         X1\PYGZhy{}10    TWO   X1\PYGZhy{}9   X1\PYGZhy{}8   X1\PYGZhy{}7   X1\PYGZhy{}6      0      0
byte 5: TWO \PYGZam{} NEW   Y1\PYGZhy{}10      0   Y1\PYGZhy{}9   Y1\PYGZhy{}8   Y1\PYGZhy{}7   Y1\PYGZhy{}6   Y1\PYGZhy{}5   Y1\PYGZhy{}4
byte 5: MULTI       Y1\PYGZhy{}10      0   Y1\PYGZhy{}9   Y1\PYGZhy{}8   Y1\PYGZhy{}7   Y1\PYGZhy{}6    F\PYGZhy{}1    F\PYGZhy{}0

L:         Left button
R / M:     Non\PYGZhy{}clickpads: Right / Middle button
           Clickpads: When \PYGZgt{} 2 fingers are down, and some fingers
           are in the button area, then the 2 coordinates reported
           are for fingers outside the button area and these report
           extra fingers being present in the right / left button
           area. Note these fingers are not added to the F field!
           so if a TWO packet is received and R = 1 then there are
           3 fingers down, etc.
TWO:       1: Two touches present, byte 0/4/5 are in TWO fmt
           0: If byte 4 bit 0 is 1, then byte 0/4/5 are in MULTI fmt
              otherwise byte 0 bit 4 must be set and byte 0/4/5 are
              in NEW fmt
F:         Number of fingers \PYGZhy{} 3, 0 means 3 fingers, 1 means 4 ...
\end{Verbatim}


\subsection{ALPS Absolute Mode - Protocol Version 8}
\label{input/devices/alps:alps-absolute-mode-protocol-version-8}
Spoken by SS4 (73 03 14) and SS5 (73 03 28) hardware.

The packet type is given by the APD field, bits 4-5 of byte 3.

Touchpad packet (APD = 0x2):

\begin{Verbatim}[commandchars=\\\{\}]
          b7   b6   b5   b4   b3   b2   b1   b0
byte 0:  SWM  SWR  SWL    1    1    0    0   X7
byte 1:    0   X6   X5   X4   X3   X2   X1   X0
byte 2:    0   Y6   Y5   Y4   Y3   Y2   Y1   Y0
byte 3:    0  T\PYGZam{}P    1    0    1    0    0   Y7
byte 4:    0   Z6   Z5   Z4   Z3   Z2   Z1   Z0
byte 5:    0    0    0    0    0    0    0    0
\end{Verbatim}

SWM, SWR, SWL: Middle, Right, and Left button states

Touchpad 1 Finger packet (APD = 0x0):

\begin{Verbatim}[commandchars=\\\{\}]
          b7   b6   b5   b4   b3   b2   b1   b0
byte 0:  SWM  SWR  SWL    1    1   X2   X1   X0
byte 1:   X9   X8   X7    1   X6   X5   X4   X3
byte 2:    0  X11  X10  LFB   Y3   Y2   Y1   Y0
byte 3:   Y5   Y4    0    0    1 TAPF2 TAPF1 TAPF0
byte 4:  Zv7  Y11  Y10    1   Y9   Y8   Y7   Y6
byte 5:  Zv6  Zv5  Zv4    0  Zv3  Zv2  Zv1  Zv0
\end{Verbatim}

TAPF: ???
LFB:  ???

Touchpad 2 Finger packet (APD = 0x1):

\begin{Verbatim}[commandchars=\\\{\}]
          b7   b6   b5   b4   b3   b2   b1   b0
byte 0:  SWM  SWR  SWL    1    1  AX6  AX5  AX4
byte 1: AX11 AX10  AX9  AX8  AX7  AZ1  AY4  AZ0
byte 2: AY11 AY10  AY9  CONT AY8  AY7  AY6  AY5
byte 3:    0    0    0    1    1  BX6  BX5  BX4
byte 4: BX11 BX10  BX9  BX8  BX7  BZ1  BY4  BZ0
byte 5: BY11 BY10  BY9    0  BY8  BY7  BY5  BY5
\end{Verbatim}

CONT: A 3-or-4 Finger packet is to follow

Touchpad 3-or-4 Finger packet (APD = 0x3):

\begin{Verbatim}[commandchars=\\\{\}]
          b7   b6   b5   b4   b3   b2   b1   b0
byte 0:  SWM  SWR  SWL    1    1  AX6  AX5  AX4
byte 1: AX11 AX10  AX9  AX8  AX7  AZ1  AY4  AZ0
byte 2: AY11 AY10  AY9  OVF  AY8  AY7  AY6  AY5
byte 3:    0    0    1    1    1  BX6  BX5  BX4
byte 4: BX11 BX10  BX9  BX8  BX7  BZ1  BY4  BZ0
byte 5: BY11 BY10  BY9    0  BY8  BY7  BY5  BY5
\end{Verbatim}

OVF: 5th finger detected


\section{Amiga joystick extensions}
\label{input/devices/amijoy:amiga-joystick-extensions}\label{input/devices/amijoy::doc}

\subsection{Amiga 4-joystick parport extension}
\label{input/devices/amijoy:amiga-4-joystick-parport-extension}
Parallel port pins:

\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Pin
} & \textsf{\relax 
Meaning
} & \textsf{\relax 
Pin
} & \textsf{\relax 
Meaning
}\\
\hline
2
 & 
Up1
 & 
6
 & 
Up2
\\
\hline
3
 & 
Down1
 & 
7
 & 
Down2
\\
\hline
4
 & 
Left1
 & 
8
 & 
Left2
\\
\hline
5
 & 
Right1
 & 
9
 & 
Right2
\\
\hline
13
 & 
Fire1
 & 
11
 & 
Fire2
\\
\hline
18
 & 
Gnd1
 & 
18
 & 
Gnd2
\\
\hline\end{tabulary}



\subsection{Amiga digital joystick pinout}
\label{input/devices/amijoy:amiga-digital-joystick-pinout}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Pin
} & \textsf{\relax 
Meaning
}\\
\hline
1
 & 
Up
\\
\hline
2
 & 
Down
\\
\hline
3
 & 
Left
\\
\hline
4
 & 
Right
\\
\hline
5
 & 
n/c
\\
\hline
6
 & 
Fire button
\\
\hline
7
 & 
+5V (50mA)
\\
\hline
8
 & 
Gnd
\\
\hline
9
 & 
Thumb button
\\
\hline\end{tabulary}



\subsection{Amiga mouse pinout}
\label{input/devices/amijoy:amiga-mouse-pinout}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Pin
} & \textsf{\relax 
Meaning
}\\
\hline
1
 & 
V-pulse
\\
\hline
2
 & 
H-pulse
\\
\hline
3
 & 
VQ-pulse
\\
\hline
4
 & 
HQ-pulse
\\
\hline
5
 & 
Middle button
\\
\hline
6
 & 
Left button
\\
\hline
7
 & 
+5V (50mA)
\\
\hline
8
 & 
Gnd
\\
\hline
9
 & 
Right button
\\
\hline\end{tabulary}



\subsection{Amiga analog joystick pinout}
\label{input/devices/amijoy:amiga-analog-joystick-pinout}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Pin
} & \textsf{\relax 
Meaning
}\\
\hline
1
 & 
Top button
\\
\hline
2
 & 
Top2 button
\\
\hline
3
 & 
Trigger button
\\
\hline
4
 & 
Thumb button
\\
\hline
5
 & 
Analog X
\\
\hline
6
 & 
n/c
\\
\hline
7
 & 
+5V (50mA)
\\
\hline
8
 & 
Gnd
\\
\hline
9
 & 
Analog Y
\\
\hline\end{tabulary}



\subsection{Amiga lightpen pinout}
\label{input/devices/amijoy:amiga-lightpen-pinout}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Pin
} & \textsf{\relax 
Meaning
}\\
\hline
1
 & 
n/c
\\
\hline
2
 & 
n/c
\\
\hline
3
 & 
n/c
\\
\hline
4
 & 
n/c
\\
\hline
5
 & 
Touch button
\\
\hline
6
 & 
/Beamtrigger
\\
\hline
7
 & 
+5V (50mA)
\\
\hline
8
 & 
Gnd
\\
\hline
9
 & 
Stylus button
\\
\hline\end{tabulary}



\bigskip\hrule{}\bigskip


\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|}
\hline
\textsf{\relax 
NAME
} & \textsf{\relax 
rev
} & \textsf{\relax 
ADDR
} & \textsf{\relax 
type
} & \textsf{\relax 
chip
} & \textsf{\relax 
Description
}\\
\hline
JOY0DAT
 &  & 
00A
 & 
R
 & 
Denise
 & 
Joystick-mouse 0 data (left vert, horiz)
\\
\hline
JOY1DAT
 &  & 
00C
 & 
R
 & 
Denise
 & 
Joystick-mouse 1 data (right vert,horiz)
\\
\hline\end{tabulary}

\begin{quote}

These addresses each read a 16 bit register. These in turn
are loaded from the MDAT serial stream and are clocked in on
the rising edge of SCLK. MLD output is used to parallel load
the external parallel-to-serial converter.This in turn is
loaded with the 4 quadrature inputs from each of two game
controller ports (8 total) plus 8 miscellaneous control bits
which are new for LISA and can be read in upper 8 bits of
LISAID.

Register bits are as follows:
\begin{itemize}
\item {} 
Mouse counter usage (pins  1,3 =Yclock, pins 2,4 =Xclock)

\end{itemize}
\end{quote}

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|L|L|L|L|L|L|L|L|L|L|L|}
\hline
\textsf{\relax 
BIT\#
} & \textsf{\relax 
15
} & \textsf{\relax 
14
} & \textsf{\relax 
13
} & \textsf{\relax 
12
} & \textsf{\relax 
11
} & \textsf{\relax 
10
} & \textsf{\relax 
09
} & \textsf{\relax 
08
} & \textsf{\relax 
07
} & \textsf{\relax 
06
} & \textsf{\relax 
05
} & \textsf{\relax 
04
} & \textsf{\relax 
03
} & \textsf{\relax 
02
} & \textsf{\relax 
01
} & \textsf{\relax 
00
}\\
\hline
JOY0DAT
 & 
Y7
 & 
Y6
 & 
Y5
 & 
Y4
 & 
Y3
 & 
Y2
 & 
Y1
 & 
Y0
 & 
X7
 & 
X6
 & 
X5
 & 
X4
 & 
X3
 & 
X2
 & 
X1
 & 
X0
\\
\hline
JOY1DAT
 & 
Y7
 & 
Y6
 & 
Y5
 & 
Y4
 & 
Y3
 & 
Y2
 & 
Y1
 & 
Y0
 & 
X7
 & 
X6
 & 
X5
 & 
X4
 & 
X3
 & 
X2
 & 
X1
 & 
X0
\\
\hline\end{tabulary}

\begin{quote}

0=LEFT CONTROLLER PAIR, 1=RIGHT CONTROLLER PAIR.
(4 counters total). The bit usage for both left and right
addresses is shown below. Each 6 bit counter (Y7-Y2,X7-X2) is
clocked by 2 of the signals input from the mouse serial
stream. Starting with first bit received:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
 \multicolumn{2}{|l|}{\textsf{\relax 
Serial \textbar{} Bit Name
}} & \textsf{\relax 
Description
}\\
\hline
0
 & 
M0H
 & 
JOY0DAT Horizontal Clock
\\
\hline
1
 & 
M0HQ
 & 
JOY0DAT Horizontal Clock (quadrature)
\\
\hline
2
 & 
M0V
 & 
JOY0DAT Vertical Clock
\\
\hline
3
 & 
M0VQ
 & 
JOY0DAT Vertical Clock  (quadrature)
\\
\hline
4
 & 
M1V
 & 
JOY1DAT Horizontal Clock
\\
\hline
5
 & 
M1VQ
 & 
JOY1DAT Horizontal Clock (quadrature)
\\
\hline
6
 & 
M1V
 & 
JOY1DAT Vertical Clock
\\
\hline
7
 & 
M1VQ
 & 
JOY1DAT Vertical Clock (quadrature)
\\
\hline\end{tabulary}


Bits 1 and 0 of each counter (Y1-Y0,X1-X0) may be
read to determine the state of the related input signal pair.
This allows these pins to double as joystick switch inputs.
Joystick switch closures can be deciphered as follows:

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Directions
} & \textsf{\relax 
Pin\#
} & \textsf{\relax 
Counter bits
}\\
\hline
Forward
 & 
1
 & 
Y1 xor Y0 (BIT\#09 xor BIT\#08)
\\
\hline
Left
 & 
3
 & 
Y1
\\
\hline
Back
 & 
2
 & 
X1 xor X0 (BIT\#01 xor BIT\#00)
\\
\hline
Right
 & 
4
 & 
X1
\\
\hline\end{tabulary}

\end{quote}
\end{quote}


\bigskip\hrule{}\bigskip


\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|}
\hline
\textsf{\relax 
NAME
} & \textsf{\relax 
rev
} & \textsf{\relax 
ADDR
} & \textsf{\relax 
type
} & \textsf{\relax 
chip
} & \textsf{\relax 
Description
}\\
\hline
JOYTEST
 &  & 
036
 & 
W
 & 
Denise
 & 
Write to all 4  joystick-mouse counters at once.
\\
\hline\end{tabulary}

\begin{quote}

Mouse counter write test data:
\end{quote}

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|L|L|L|L|L|L|L|L|L|L|L|}
\hline
\textsf{\relax 
BIT\#
} & \textsf{\relax 
15
} & \textsf{\relax 
14
} & \textsf{\relax 
13
} & \textsf{\relax 
12
} & \textsf{\relax 
11
} & \textsf{\relax 
10
} & \textsf{\relax 
09
} & \textsf{\relax 
08
} & \textsf{\relax 
07
} & \textsf{\relax 
06
} & \textsf{\relax 
05
} & \textsf{\relax 
04
} & \textsf{\relax 
03
} & \textsf{\relax 
02
} & \textsf{\relax 
01
} & \textsf{\relax 
00
}\\
\hline
JOYxDAT
 & 
Y7
 & 
Y6
 & 
Y5
 & 
Y4
 & 
Y3
 & 
Y2
 & 
xx
 & 
xx
 & 
X7
 & 
X6
 & 
X5
 & 
X4
 & 
X3
 & 
X2
 & 
xx
 & 
xx
\\
\hline
JOYxDAT
 & 
Y7
 & 
Y6
 & 
Y5
 & 
Y4
 & 
Y3
 & 
Y2
 & 
xx
 & 
xx
 & 
X7
 & 
X6
 & 
X5
 & 
X4
 & 
X3
 & 
X2
 & 
xx
 & 
xx
\\
\hline\end{tabulary}



\bigskip\hrule{}\bigskip


\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|}
\hline
\textsf{\relax 
NAME
} & \textsf{\relax 
rev
} & \textsf{\relax 
ADDR
} & \textsf{\relax 
type
} & \textsf{\relax 
chip
} & \textsf{\relax 
Description
}\\
\hline
POT0DAT
 & 
h
 & 
012
 & 
R
 & 
Paula
 & 
Pot counter data left pair (vert, horiz)
\\
\hline
POT1DAT
 & 
h
 & 
014
 & 
R
 & 
Paula
 & 
Pot counter data right pair (vert,horiz)
\\
\hline\end{tabulary}

\begin{quote}

These addresses each read a pair of 8 bit pot counters.
(4 counters total). The bit assignment for both
addresses is shown below. The counters are stopped by signals
from 2 controller connectors (left-right) with 2 pins each.
\end{quote}

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|L|L|L|L|L|L|L|L|L|L|L|}
\hline
\textsf{\relax 
BIT\#
} & \textsf{\relax 
15
} & \textsf{\relax 
14
} & \textsf{\relax 
13
} & \textsf{\relax 
12
} & \textsf{\relax 
11
} & \textsf{\relax 
10
} & \textsf{\relax 
09
} & \textsf{\relax 
08
} & \textsf{\relax 
07
} & \textsf{\relax 
06
} & \textsf{\relax 
05
} & \textsf{\relax 
04
} & \textsf{\relax 
03
} & \textsf{\relax 
02
} & \textsf{\relax 
01
} & \textsf{\relax 
00
}\\
\hline
RIGHT
 & 
Y7
 & 
Y6
 & 
Y5
 & 
Y4
 & 
Y3
 & 
Y2
 & 
Y1
 & 
Y0
 & 
X7
 & 
X6
 & 
X5
 & 
X4
 & 
X3
 & 
X2
 & 
X1
 & 
X0
\\
\hline
LEFT
 & 
Y7
 & 
Y6
 & 
Y5
 & 
Y4
 & 
Y3
 & 
Y2
 & 
Y1
 & 
Y0
 & 
X7
 & 
X6
 & 
X5
 & 
X4
 & 
X3
 & 
X2
 & 
X1
 & 
X0
\\
\hline\end{tabulary}

\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
 \multicolumn{4}{|l|}{\textsf{\relax 
CONNECTORS
}} & \textsf{\relax 
PAULA
}\\
\hline\textsf{\relax 
Loc.
} & \textsf{\relax 
Dir.
} & \textsf{\relax 
Sym
} & \textsf{\relax 
pin
} & \textsf{\relax 
pin
}\\
\hline
RIGHT
 & 
Y
 & 
RX
 & 
9
 & 
33
\\
\hline
RIGHT
 & 
X
 & 
RX
 & 
5
 & 
32
\\
\hline
LEFT
 & 
Y
 & 
LY
 & 
9
 & 
36
\\
\hline
LEFT
 & 
X
 & 
LX
 & 
5
 & 
35
\\
\hline\end{tabulary}


With normal (NTSC or PAL) horiz. line rate, the pots will
give a full scale (FF) reading with about 500kohms in one
frame time. With proportionally faster horiz line times,
the counters will count proportionally faster.
This should be noted when doing variable beam displays.
\end{quote}


\bigskip\hrule{}\bigskip


\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|}
\hline
\textsf{\relax 
NAME
} & \textsf{\relax 
rev
} & \textsf{\relax 
ADDR
} & \textsf{\relax 
type
} & \textsf{\relax 
chip
} & \textsf{\relax 
Description
}\\
\hline
POTGO
 &  & 
034
 & 
W
 & 
Paula
 & 
Pot port (4 bit) bi-direction and data, and pot
counter start.
\\
\hline\end{tabulary}



\bigskip\hrule{}\bigskip


\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|}
\hline
\textsf{\relax 
NAME
} & \textsf{\relax 
rev
} & \textsf{\relax 
ADDR
} & \textsf{\relax 
type
} & \textsf{\relax 
chip
} & \textsf{\relax 
Description
}\\
\hline
POTINP
 &  & 
016
 & 
R
 & 
Paula
 & 
Pot pin data read
\\
\hline\end{tabulary}

\begin{quote}

This register controls a 4 bit bi-direction I/O port
that shares the same 4 pins as the 4 pot counters above.
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
BIT\#
} & \textsf{\relax 
FUNCTION
} & \textsf{\relax 
DESCRIPTION
}\\
\hline
15
 & 
OUTRY
 & 
Output enable for Paula pin 33
\\
\hline
14
 & 
DATRY
 & 
I/O data Paula pin 33
\\
\hline
13
 & 
OUTRX
 & 
Output enable for Paula pin 32
\\
\hline
12
 & 
DATRX
 & 
I/O data Paula pin 32
\\
\hline
11
 & 
OUTLY
 & 
Out put enable for Paula pin 36
\\
\hline
10
 & 
DATLY
 & 
I/O data Paula pin 36
\\
\hline
09
 & 
OUTLX
 & 
Output enable for Paula pin 35
\\
\hline
08
 & 
DATLX
 & 
I/O data  Paula pin 35
\\
\hline
07-01
 & 
X
 & 
Not used
\\
\hline
00
 & 
START
 & 
Start pots (dump capacitors,start counters)
\\
\hline\end{tabulary}

\end{quote}
\end{quote}


\section{Apple Touchpad Driver (appletouch)}
\label{input/devices/appletouch:apple-touchpad-driver-appletouch}\label{input/devices/appletouch::doc}\begin{quote}\begin{description}
\item[{Copyright}] \leavevmode
© 2005 Stelian Pop \textless{}\href{mailto:stelian@popies.net}{stelian@popies.net}\textgreater{}

\end{description}\end{quote}

appletouch is a Linux kernel driver for the USB touchpad found on post
February 2005 and October 2005 Apple Aluminium Powerbooks.

This driver is derived from Johannes Berg's appletrackpad driver \footnote[1]{
\href{http://johannes.sipsolutions.net/PowerBook/touchpad/}{http://johannes.sipsolutions.net/PowerBook/touchpad/}
},
but it has been improved in some areas:
\begin{itemize}
\item {} 
appletouch is a full kernel driver, no userspace program is necessary

\item {} 
appletouch can be interfaced with the synaptics X11 driver, in order
to have touchpad acceleration, scrolling, etc.

\end{itemize}

Credits go to Johannes Berg for reverse-engineering the touchpad protocol,
Frank Arnold for further improvements, and Alex Harper for some additional
information about the inner workings of the touchpad sensors. Michael
Hanselmann added support for the October 2005 models.


\subsection{Usage}
\label{input/devices/appletouch:usage}
In order to use the touchpad in the basic mode, compile the driver and load
the module. A new input device will be detected and you will be able to read
the mouse data from /dev/input/mice (using gpm, or X11).

In X11, you can configure the touchpad to use the synaptics X11 driver, which
will give additional functionalities, like acceleration, scrolling, 2 finger
tap for middle button mouse emulation, 3 finger tap for right button mouse
emulation, etc. In order to do this, make sure you're using a recent version of
the synaptics driver (tested with 0.14.2, available from \footnote[2]{
\href{http://web.archive.org/web/*/http://web.telia.com/~u89404340/touchpad/index.html}{http://web.archive.org/web/*/http://web.telia.com/\textasciitilde{}u89404340/touchpad/index.html}
}), and configure
a new input device in your X11 configuration file (take a look below for an
example). For additional configuration, see the synaptics driver documentation:

\begin{Verbatim}[commandchars=\\\{\}]
Section \PYGZdq{}InputDevice\PYGZdq{}
        Identifier      \PYGZdq{}Synaptics Touchpad\PYGZdq{}
        Driver          \PYGZdq{}synaptics\PYGZdq{}
        Option          \PYGZdq{}SendCoreEvents\PYGZdq{}        \PYGZdq{}true\PYGZdq{}
        Option          \PYGZdq{}Device\PYGZdq{}                \PYGZdq{}/dev/input/mice\PYGZdq{}
        Option          \PYGZdq{}Protocol\PYGZdq{}              \PYGZdq{}auto\PYGZhy{}dev\PYGZdq{}
        Option          \PYGZdq{}LeftEdge\PYGZdq{}              \PYGZdq{}0\PYGZdq{}
        Option          \PYGZdq{}RightEdge\PYGZdq{}             \PYGZdq{}850\PYGZdq{}
        Option          \PYGZdq{}TopEdge\PYGZdq{}               \PYGZdq{}0\PYGZdq{}
        Option          \PYGZdq{}BottomEdge\PYGZdq{}            \PYGZdq{}645\PYGZdq{}
        Option          \PYGZdq{}MinSpeed\PYGZdq{}              \PYGZdq{}0.4\PYGZdq{}
        Option          \PYGZdq{}MaxSpeed\PYGZdq{}              \PYGZdq{}1\PYGZdq{}
        Option          \PYGZdq{}AccelFactor\PYGZdq{}           \PYGZdq{}0.02\PYGZdq{}
        Option          \PYGZdq{}FingerLow\PYGZdq{}             \PYGZdq{}0\PYGZdq{}
        Option          \PYGZdq{}FingerHigh\PYGZdq{}            \PYGZdq{}30\PYGZdq{}
        Option          \PYGZdq{}MaxTapMove\PYGZdq{}            \PYGZdq{}20\PYGZdq{}
        Option          \PYGZdq{}MaxTapTime\PYGZdq{}            \PYGZdq{}100\PYGZdq{}
        Option          \PYGZdq{}HorizScrollDelta\PYGZdq{}      \PYGZdq{}0\PYGZdq{}
        Option          \PYGZdq{}VertScrollDelta\PYGZdq{}       \PYGZdq{}30\PYGZdq{}
        Option          \PYGZdq{}SHMConfig\PYGZdq{}             \PYGZdq{}on\PYGZdq{}
EndSection

Section \PYGZdq{}ServerLayout\PYGZdq{}
        ...
        InputDevice     \PYGZdq{}Mouse\PYGZdq{}
        InputDevice     \PYGZdq{}Synaptics Touchpad\PYGZdq{}
...
EndSection
\end{Verbatim}


\subsection{Fuzz problems}
\label{input/devices/appletouch:fuzz-problems}
The touchpad sensors are very sensitive to heat, and will generate a lot of
noise when the temperature changes. This is especially true when you power-on
the laptop for the first time.

The appletouch driver tries to handle this noise and auto adapt itself, but it
is not perfect. If finger movements are not recognized anymore, try reloading
the driver.

You can activate debugging using the `debug' module parameter. A value of 0
deactivates any debugging, 1 activates tracing of invalid samples, 2 activates
full tracing (each sample is being traced):

\begin{Verbatim}[commandchars=\\\{\}]
modprobe appletouch debug=1
\end{Verbatim}

or:

\begin{Verbatim}[commandchars=\\\{\}]
echo \PYGZdq{}1\PYGZdq{} \PYGZgt{} /sys/module/appletouch/parameters/debug
\end{Verbatim}


\section{Intelligent Keyboard (ikbd) Protocol}
\label{input/devices/atarikbd:intelligent-keyboard-ikbd-protocol}\label{input/devices/atarikbd::doc}

\subsection{Introduction}
\label{input/devices/atarikbd:introduction}
The Atari Corp. Intelligent Keyboard (ikbd) is a general purpose keyboard
controller that is flexible enough that it can be used in a variety of
products without modification. The keyboard, with its microcontroller,
provides a convenient connection point for a mouse and switch-type joysticks.
The ikbd processor also maintains a time-of-day clock with one second
resolution.
The ikbd has been designed to be general enough that it can be used with a
variety of new computer products. Product variations in a number of
keyswitches, mouse resolution, etc. can be accommodated.
The ikbd communicates with the main processor over a high speed bi-directional
serial interface. It can function in a variety of modes to facilitate
different applications of the keyboard,  joysticks, or mouse. Limited use of
the controller is possible in applications in which only a unidirectional
communications medium is available by carefully designing the default modes.


\subsection{Keyboard}
\label{input/devices/atarikbd:keyboard}
The keyboard always returns key make/break scan codes. The ikbd generates
keyboard scan codes for each key press and release. The key scan make (key
closure) codes start at 1, and are defined in Appendix A. For example, the
ISO key position in the scan code table should exist even if no keyswitch
exists in that position on a particular keyboard. The break code for each key
is obtained by ORing 0x80 with the make code.

The special codes 0xF6 through 0xFF are reserved for use as follows:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Code
} & \textsf{\relax 
Command
}\\
\hline
0xF6
 & 
status report
\\
\hline
0xF7
 & 
absolute mouse position record
\\
\hline
0xF8-0xFB
 & 
relative mouse position records (lsbs determined by
mouse button states)
\\
\hline
0xFC
 & 
time-of-day
\\
\hline
0xFD
 & 
joystick report (both sticks)
\\
\hline
0xFE
 & 
joystick 0 event
\\
\hline
0xFF
 & 
joystick 1 event
\\
\hline\end{tabulary}


The two shift keys return different scan codes in this mode. The ENTER key
and the RETurn key are also distinct.


\subsection{Mouse}
\label{input/devices/atarikbd:mouse}
The mouse port should be capable of supporting a mouse with resolution of
approximately 200 counts (phase changes or `clicks') per inch of travel. The
mouse should be scanned at a rate that will permit accurate tracking at
velocities up to 10 inches per second.
The ikbd can report mouse motion in three distinctly different ways. It can
report relative motion, absolute motion in a coordinate system maintained
within the ikbd, or by converting mouse motion into keyboard cursor control
key equivalents.
The mouse buttons can be treated as part of the mouse or as additional
keyboard keys.


\subsubsection{Relative Position Reporting}
\label{input/devices/atarikbd:relative-position-reporting}
In relative position mode, the ikbd will return relative mouse position
records whenever a mouse event occurs. A mouse event consists of a mouse
button being pressed or released, or motion in either axis exceeding a
settable threshold of motion. Regardless of the threshold, all bits of
resolution are returned to the host computer.
Note that the ikbd may return mouse relative position reports with
significantly more than the threshold delta x or y. This may happen since no
relative mouse motion events will be generated: (a) while the keyboard has
been `paused' ( the event will be stored until keyboard communications is
resumed) (b) while any event is being transmitted.

The relative mouse position record is a three byte record of the form
(regardless of keyboard mode):

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{}111110xy           ; mouse position record flag
                    ; where y is the right button state
                    ; and x is the left button state
X                   ; delta x as twos complement integer
Y                   ; delta y as twos complement integer
\end{Verbatim}

Note that the value of the button state bits should be valid even if the
MOUSE BUTTON ACTION has set the buttons to act like part of the keyboard.
If the accumulated motion before the report packet is generated exceeds the
+127...-128 range, the motion is broken into multiple packets.
Note that the sign of the delta y reported is a function of the Y origin
selected.


\subsubsection{Absolute Position reporting}
\label{input/devices/atarikbd:absolute-position-reporting}
The ikbd can also maintain absolute mouse position. Commands exist for
resetting the mouse position, setting X/Y scaling, and interrogating the
current mouse position.


\subsubsection{Mouse Cursor Key Mode}
\label{input/devices/atarikbd:mouse-cursor-key-mode}
The ikbd can translate mouse motion into the equivalent cursor keystrokes.
The number of mouse clicks per keystroke is independently programmable in
each axis. The ikbd internally maintains mouse motion information to the
highest resolution available, and merely generates a pair of cursor key events
for each multiple of the scale factor.
Mouse motion produces the cursor key make code immediately followed by the
break code for the appropriate cursor key. The mouse buttons produce scan
codes above those normally assigned for the largest envisioned keyboard (i.e.
LEFT=0x74 \& RIGHT=0x75).


\subsection{Joystick}
\label{input/devices/atarikbd:joystick}

\subsubsection{Joystick Event Reporting}
\label{input/devices/atarikbd:joystick-event-reporting}
In this mode, the ikbd generates a record whenever the joystick position is
changed (i.e. for each opening or closing of a joystick switch or trigger).

The joystick event record is two bytes of the form:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{}1111111x           ; Joystick event marker
                    ; where x is Joystick 0 or 1
\PYGZpc{}x000yyyy           ; where yyyy is the stick position
                    ; and x is the trigger
\end{Verbatim}


\subsubsection{Joystick Interrogation}
\label{input/devices/atarikbd:joystick-interrogation}
The current state of the joystick ports may be interrogated at any time in
this mode by sending an `Interrogate Joystick' command to the ikbd.

The ikbd response to joystick interrogation is a three byte report of the form:

\begin{Verbatim}[commandchars=\\\{\}]
0xFD                ; joystick report header
\PYGZpc{}x000yyyy           ; Joystick 0
\PYGZpc{}x000yyyy           ; Joystick 1
                    ; where x is the trigger
                    ; and yyy is the stick position
\end{Verbatim}


\subsubsection{Joystick Monitoring}
\label{input/devices/atarikbd:joystick-monitoring}
A mode is available that devotes nearly all of the keyboard communications
time to reporting the state of the joystick ports at a user specifiable rate.
It remains in this mode until reset or commanded into another mode. The PAUSE
command in this mode not only stop the output but also temporarily stops
scanning the joysticks (samples are not queued).


\subsubsection{Fire Button Monitoring}
\label{input/devices/atarikbd:fire-button-monitoring}
A mode is provided to permit monitoring a single input bit at a high rate. In
this mode the ikbd monitors the state of the Joystick 1 fire button at the
maximum rate permitted by the serial communication channel. The data is packed
8 bits per byte for transmission to the host. The ikbd remains in this mode
until reset or commanded into another mode. The PAUSE command in this mode not
only stops the output but also temporarily stops scanning the button (samples
are not queued).


\subsubsection{Joystick Key Code Mode}
\label{input/devices/atarikbd:joystick-key-code-mode}
The ikbd may be commanded to translate the use of either joystick into the
equivalent cursor control keystroke(s). The ikbd provides a single breakpoint
velocity joystick cursor.
Joystick events produce the make code, immediately followed by the break code
for the appropriate cursor motion keys. The trigger or fire buttons of the
joysticks produce pseudo key scan codes above those used by the largest key
matrix envisioned (i.e. JOYSTICK0=0x74, JOYSTICK1=0x75).


\subsection{Time-of-Day Clock}
\label{input/devices/atarikbd:time-of-day-clock}
The ikbd also maintains a time-of-day clock for the system. Commands are
available to set and interrogate the timer-of-day clock. Time-keeping is
maintained down to a resolution of one second.


\subsection{Status Inquiries}
\label{input/devices/atarikbd:status-inquiries}
The current state of ikbd modes and parameters may be found by sending status
inquiry commands that correspond to the ikbd set commands.


\subsection{Power-Up Mode}
\label{input/devices/atarikbd:power-up-mode}
The keyboard controller will perform a simple self-test on power-up to detect
major controller faults (ROM checksum and RAM test) and such things as stuck
keys. Any keys down at power-up are presumed to be stuck, and their BREAK
(sic) code is returned (which without the preceding MAKE code is a flag for a
keyboard error). If the controller self-test completes without error, the code
0xF0 is returned. (This code will be used to indicate the version/release of
the ikbd controller. The first release of the ikbd is version 0xF0, should
there be a second release it will be 0xF1, and so on.)
The ikbd defaults to a mouse position reporting with threshold of 1 unit in
either axis and the Y=0 origin at the top of the screen, and joystick event
reporting mode for joystick 1, with both buttons being logically assigned to
the mouse. After any joystick command, the ikbd assumes that joysticks are
connected to both Joystick0 and Joystick1. Any mouse command (except MOUSE
DISABLE) then causes port 0 to again be scanned as if it were a mouse, and
both buttons are logically connected to it. If a mouse disable command is
received while port 0 is presumed to be a mouse, the button is logically
assigned to Joystick1 (until the mouse is reenabled by another mouse command).


\subsection{ikbd Command Set}
\label{input/devices/atarikbd:ikbd-command-set}
This section contains a list of commands that can be sent to the ikbd. Command
codes (such as 0x00) which are not specified should perform no operation
(NOPs).


\subsubsection{RESET}
\label{input/devices/atarikbd:reset}
\begin{Verbatim}[commandchars=\\\{\}]
0x80
0x01
\end{Verbatim}

N.B. The RESET command is the only two byte command understood by the ikbd.
Any byte following an 0x80 command byte other than 0x01 is ignored (and causes
the 0x80 to be ignored).
A reset may also be caused by sending a break lasting at least 200mS to the
ikbd.
Executing the RESET command returns the keyboard to its default (power-up)
mode and parameter settings. It does not affect the time-of-day clock.
The RESET command or function causes the ikbd to perform a simple self-test.
If the test is successful, the ikbd will send the code of 0xF0 within 300mS
of receipt of the RESET command (or the end of the break, or power-up). The
ikbd will then scan the key matrix for any stuck (closed) keys. Any keys found
closed will cause the break scan code to be generated (the break code arriving
without being preceded by the make code is a flag for a key matrix error).


\subsubsection{SET MOUSE BUTTON ACTION}
\label{input/devices/atarikbd:set-mouse-button-action}
\begin{Verbatim}[commandchars=\\\{\}]
0x07
\PYGZpc{}00000mss           ; mouse button action
                    ;       (m is presumed = 1 when in MOUSE KEYCODE mode)
                    ; mss=0xy, mouse button press or release causes mouse
                    ;  position report
                    ;  where y=1, mouse key press causes absolute report
                    ;  and x=1, mouse key release causes absolute report
                    ; mss=100, mouse buttons act like keys
\end{Verbatim}

This command sets how the ikbd should treat the buttons on the mouse. The
default mouse button action mode is \%00000000, the buttons are treated as part
of the mouse logically.
When buttons act like keys, LEFT=0x74 \& RIGHT=0x75.


\subsubsection{SET RELATIVE MOUSE POSITION REPORTING}
\label{input/devices/atarikbd:set-relative-mouse-position-reporting}
\begin{Verbatim}[commandchars=\\\{\}]
0x08
\end{Verbatim}

Set relative mouse position reporting. (DEFAULT) Mouse position packets are
generated asynchronously by the ikbd whenever motion exceeds the setable
threshold in either axis (see SET MOUSE THRESHOLD). Depending upon the mouse
key mode, mouse position reports may also be generated when either mouse
button is pressed or released. Otherwise the mouse buttons behave as if they
were keyboard keys.


\subsubsection{SET ABSOLUTE MOUSE POSITIONING}
\label{input/devices/atarikbd:set-absolute-mouse-positioning}
\begin{Verbatim}[commandchars=\\\{\}]
0x09
XMSB                ; X maximum (in scaled mouse clicks)
XLSB
YMSB                ; Y maximum (in scaled mouse clicks)
YLSB
\end{Verbatim}

Set absolute mouse position maintenance. Resets the ikbd maintained X and Y
coordinates.
In this mode, the value of the internally maintained coordinates does NOT wrap
between 0 and large positive numbers. Excess motion below 0 is ignored. The
command sets the maximum positive value that can be attained in the scaled
coordinate system. Motion beyond that value is also ignored.


\subsubsection{SET MOUSE KEYCODE MOSE}
\label{input/devices/atarikbd:set-mouse-keycode-mose}
\begin{Verbatim}[commandchars=\\\{\}]
0x0A
deltax              ; distance in X clicks to return (LEFT) or (RIGHT)
deltay              ; distance in Y clicks to return (UP) or (DOWN)
\end{Verbatim}

Set mouse monitoring routines to return cursor motion keycodes instead of
either RELATIVE or ABSOLUTE motion records. The ikbd returns the appropriate
cursor keycode after mouse travel exceeding the user specified deltas in
either axis. When the keyboard is in key scan code mode, mouse motion will
cause the make code immediately followed by the break code. Note that this
command is not affected by the mouse motion origin.


\subsubsection{SET MOUSE THRESHOLD}
\label{input/devices/atarikbd:set-mouse-threshold}
\begin{Verbatim}[commandchars=\\\{\}]
0x0B
X                   ; x threshold in mouse ticks (positive integers)
Y                   ; y threshold in mouse ticks (positive integers)
\end{Verbatim}

This command sets the threshold before a mouse event is generated. Note that
it does NOT affect the resolution of the data returned to the host. This
command is valid only in RELATIVE MOUSE POSITIONING mode. The thresholds
default to 1 at RESET (or power-up).


\subsubsection{SET MOUSE SCALE}
\label{input/devices/atarikbd:set-mouse-scale}
\begin{Verbatim}[commandchars=\\\{\}]
0x0C
X                   ; horizontal mouse ticks per internal X
Y                   ; vertical mouse ticks per internal Y
\end{Verbatim}

This command sets the scale factor for the ABSOLUTE MOUSE POSITIONING mode.
In this mode, the specified number of mouse phase changes (`clicks') must
occur before the internally maintained coordinate is changed by one
(independently scaled for each axis). Remember that the mouse position
information is available only by interrogating the ikbd in the ABSOLUTE MOUSE
POSITIONING mode unless the ikbd has been commanded to report on button press
or release (see SET MOSE BUTTON ACTION).


\subsubsection{INTERROGATE MOUSE POSITION}
\label{input/devices/atarikbd:interrogate-mouse-position}
\begin{Verbatim}[commandchars=\\\{\}]
0x0D
Returns:
        0xF7       ; absolute mouse position header
BUTTONS
        0000dcba   ; where a is right button down since last interrogation
                   ; b is right button up since last
                   ; c is left button down since last
                   ; d is left button up since last
        XMSB       ; X coordinate
        XLSB
        YMSB       ; Y coordinate
        YLSB
\end{Verbatim}

The INTERROGATE MOUSE POSITION command is valid when in the ABSOLUTE MOUSE
POSITIONING mode, regardless of the setting of the MOUSE BUTTON ACTION.


\subsubsection{LOAD MOUSE POSITION}
\label{input/devices/atarikbd:load-mouse-position}
\begin{Verbatim}[commandchars=\\\{\}]
0x0E
0x00                ; filler
XMSB                ; X coordinate
XLSB                ; (in scaled coordinate system)
YMSB                ; Y coordinate
YLSB
\end{Verbatim}

This command allows the user to preset the internally maintained absolute
mouse position.


\subsubsection{SET Y=0 AT BOTTOM}
\label{input/devices/atarikbd:set-y-0-at-bottom}
\begin{Verbatim}[commandchars=\\\{\}]
0x0F
\end{Verbatim}

This command makes the origin of the Y axis to be at the bottom of the
logical coordinate system internal to the ikbd for all relative or absolute
mouse motion. This causes mouse motion toward the user to be negative in sign
and away from the user to be positive.


\subsubsection{SET Y=0 AT TOP}
\label{input/devices/atarikbd:set-y-0-at-top}
\begin{Verbatim}[commandchars=\\\{\}]
0x10
\end{Verbatim}

Makes the origin of the Y axis to be at the top of the logical coordinate
system within the ikbd for all relative or absolute mouse motion. (DEFAULT)
This causes mouse motion toward the user to be positive in sign and away from
the user to be negative.


\subsubsection{RESUME}
\label{input/devices/atarikbd:resume}
\begin{Verbatim}[commandchars=\\\{\}]
0x11
\end{Verbatim}

Resume sending data to the host. Since any command received by the ikbd after
its output has been paused also causes an implicit RESUME this command can be
thought of as a NO OPERATION command. If this command is received by the ikbd
and it is not PAUSED, it is simply ignored.


\subsubsection{DISABLE MOUSE}
\label{input/devices/atarikbd:disable-mouse}
\begin{Verbatim}[commandchars=\\\{\}]
0x12
\end{Verbatim}

All mouse event reporting is disabled (and scanning may be internally
disabled). Any valid mouse mode command resumes mouse motion monitoring. (The
valid mouse mode commands are SET RELATIVE MOUSE POSITION REPORTING, SET
ABSOLUTE MOUSE POSITIONING, and SET MOUSE KEYCODE MODE. )
N.B. If the mouse buttons have been commanded to act like keyboard keys, this
command DOES affect their actions.


\subsubsection{PAUSE OUTPUT}
\label{input/devices/atarikbd:pause-output}
\begin{Verbatim}[commandchars=\\\{\}]
0x13
\end{Verbatim}

Stop sending data to the host until another valid command is received. Key
matrix activity is still monitored and scan codes or ASCII characters enqueued
(up to the maximum supported by the microcontroller) to be sent when the host
allows the output to be resumed. If in the JOYSTICK EVENT REPORTING mode,
joystick events are also queued.
Mouse motion should be accumulated while the output is paused. If the ikbd is
in RELATIVE MOUSE POSITIONING REPORTING mode, motion is accumulated beyond the
normal threshold limits to produce the minimum number of packets necessary for
transmission when output is resumed. Pressing or releasing either mouse button
causes any accumulated motion to be immediately queued as packets, if the
mouse is in RELATIVE MOUSE POSITION REPORTING mode.
Because of the limitations of the microcontroller memory this command should
be used sparingly, and the output should not be shut of for more than \textless{}tbd\textgreater{}
milliseconds at a time.
The output is stopped only at the end of the current `even'. If the PAUSE
OUTPUT command is received in the middle of a multiple byte report, the packet
will still be transmitted to conclusion and then the PAUSE will take effect.
When the ikbd is in either the JOYSTICK MONITORING mode or the FIRE BUTTON
MONITORING mode, the PAUSE OUTPUT command also temporarily stops the
monitoring process (i.e. the samples are not enqueued for transmission).


\subsubsection{SET JOYSTICK EVENT REPORTING}
\label{input/devices/atarikbd:set-joystick-event-reporting}
\begin{Verbatim}[commandchars=\\\{\}]
0x14
\end{Verbatim}

Enter JOYSTICK EVENT REPORTING mode (DEFAULT). Each opening or closure of a
joystick switch or trigger causes a joystick event record to be generated.


\subsubsection{SET JOYSTICK INTERROGATION MODE}
\label{input/devices/atarikbd:set-joystick-interrogation-mode}
\begin{Verbatim}[commandchars=\\\{\}]
0x15
\end{Verbatim}

Disables JOYSTICK EVENT REPORTING. Host must send individual JOYSTICK
INTERROGATE commands to sense joystick state.


\subsubsection{JOYSTICK INTERROGATE}
\label{input/devices/atarikbd:joystick-interrogate}
\begin{Verbatim}[commandchars=\\\{\}]
0x16
\end{Verbatim}

Return a record indicating the current state of the joysticks. This command
is valid in either the JOYSTICK EVENT REPORTING mode or the JOYSTICK
INTERROGATION MODE.


\subsubsection{SET JOYSTICK MONITORING}
\label{input/devices/atarikbd:set-joystick-monitoring}
\begin{Verbatim}[commandchars=\\\{\}]
0x17
rate                ; time between samples in hundredths of a second
Returns: (in packets of two as long as in mode)
        \PYGZpc{}000000xy   ; where y is JOYSTICK1 Fire button
                    ; and x is JOYSTICK0 Fire button
        \PYGZpc{}nnnnmmmm   ; where m is JOYSTICK1 state
                    ; and n is JOYSTICK0 state
\end{Verbatim}

Sets the ikbd to do nothing but monitor the serial command line, maintain the
time-of-day clock, and monitor the joystick. The rate sets the interval
between joystick samples.
N.B. The user should not set the rate higher than the serial communications
channel will allow the 2 bytes packets to be transmitted.


\subsubsection{SET FIRE BUTTON MONITORING}
\label{input/devices/atarikbd:set-fire-button-monitoring}
\begin{Verbatim}[commandchars=\\\{\}]
0x18
Returns: (as long as in mode)
        \PYGZpc{}bbbbbbbb   ; state of the JOYSTICK1 fire button packed
                    ; 8 bits per byte, the first sample if the MSB
\end{Verbatim}

Set the ikbd to do nothing but monitor the serial command line, maintain the
time-of-day clock, and monitor the fire button on Joystick 1. The fire button
is scanned at a rate that causes 8 samples to be made in the time it takes for
the previous byte to be sent to the host (i.e. scan rate = 8/10 * baud rate).
The sample interval should be as constant as possible.


\subsubsection{SET JOYSTICK KEYCODE MODE}
\label{input/devices/atarikbd:set-joystick-keycode-mode}
\begin{Verbatim}[commandchars=\\\{\}]
0x19
RX                  ; length of time (in tenths of seconds) until
                    ; horizontal velocity breakpoint is reached
RY                  ; length of time (in tenths of seconds) until
                    ; vertical velocity breakpoint is reached
TX                  ; length (in tenths of seconds) of joystick closure
                    ; until horizontal cursor key is generated before RX
                    ; has elapsed
TY                  ; length (in tenths of seconds) of joystick closure
                    ; until vertical cursor key is generated before RY
                    ; has elapsed
VX                  ; length (in tenths of seconds) of joystick closure
                    ; until horizontal cursor keystrokes are generated
                    ; after RX has elapsed
VY                  ; length (in tenths of seconds) of joystick closure
                    ; until vertical cursor keystrokes are generated
                    ; after RY has elapsed
\end{Verbatim}

In this mode, joystick 0 is scanned in a way that simulates cursor keystrokes.
On initial closure, a keystroke pair (make/break) is generated. Then up to Rn
tenths of seconds later, keystroke pairs are generated every Tn tenths of
seconds. After the Rn breakpoint is reached, keystroke pairs are generated
every Vn tenths of seconds. This provides a velocity (auto-repeat) breakpoint
feature.
Note that by setting RX and/or Ry to zero, the velocity feature can be
disabled. The values of TX and TY then become meaningless, and the generation
of cursor `keystrokes' is set by VX and VY.


\subsubsection{DISABLE JOYSTICKS}
\label{input/devices/atarikbd:disable-joysticks}
\begin{Verbatim}[commandchars=\\\{\}]
0x1A
\end{Verbatim}

Disable the generation of any joystick events (and scanning may be internally
disabled). Any valid joystick mode command resumes joystick monitoring. (The
joystick mode commands are SET JOYSTICK EVENT REPORTING, SET JOYSTICK
INTERROGATION MODE, SET JOYSTICK MONITORING, SET FIRE BUTTON MONITORING, and
SET JOYSTICK KEYCODE MODE.)


\subsubsection{TIME-OF-DAY CLOCK SET}
\label{input/devices/atarikbd:time-of-day-clock-set}
\begin{Verbatim}[commandchars=\\\{\}]
0x1B
YY                  ; year (2 least significant digits)
MM                  ; month
DD                  ; day
hh                  ; hour
mm                  ; minute
ss                  ; second
\end{Verbatim}

All time-of-day data should be sent to the ikbd in packed BCD format.
Any digit that is not a valid BCD digit should be treated as a `don't care'
and not alter that particular field of the date or time. This permits setting
only some subfields of the time-of-day clock.


\subsubsection{INTERROGATE TIME-OF-DAT CLOCK}
\label{input/devices/atarikbd:interrogate-time-of-dat-clock}
\begin{Verbatim}[commandchars=\\\{\}]
0x1C
Returns:
        0xFC        ; time\PYGZhy{}of\PYGZhy{}day event header
        YY          ; year (2 least significant digits)
        MM          ; month
        DD          ; day
        hh          ; hour
        mm          ; minute
        ss          ; second

All time\PYGZhy{}of\PYGZhy{}day is sent in packed BCD format.
\end{Verbatim}


\subsubsection{MEMORY LOAD}
\label{input/devices/atarikbd:memory-load}
\begin{Verbatim}[commandchars=\\\{\}]
0x20
ADRMSB              ; address in controller
ADRLSB              ; memory to be loaded
NUM                 ; number of bytes (0\PYGZhy{}128)
\PYGZob{} data \PYGZcb{}
\end{Verbatim}

This command permits the host to load arbitrary values into the ikbd
controller memory. The time between data bytes must be less than 20ms.


\subsubsection{MEMORY READ}
\label{input/devices/atarikbd:memory-read}
\begin{Verbatim}[commandchars=\\\{\}]
0x21
ADRMSB              ; address in controller
ADRLSB              ; memory to be read
Returns:
        0xF6        ; status header
        0x20        ; memory access
        \PYGZob{} data \PYGZcb{}    ; 6 data bytes starting at ADR
\end{Verbatim}

This command permits the host to read from the ikbd controller memory.


\subsubsection{CONTROLLER EXECUTE}
\label{input/devices/atarikbd:controller-execute}
\begin{Verbatim}[commandchars=\\\{\}]
0x22
ADRMSB              ; address of subroutine in
ADRLSB              ; controller memory to be called
\end{Verbatim}

This command allows the host to command the execution of a subroutine in the
ikbd controller memory.


\subsubsection{STATUS INQUIRIES}
\label{input/devices/atarikbd:id1}
\begin{Verbatim}[commandchars=\\\{\}]
Status commands are formed by inclusively ORing 0x80 with the
relevant SET command.

Example:
0x88 (or 0x89 or 0x8A)  ; request mouse mode
Returns:
        0xF6        ; status response header
        mode        ; 0x08 is RELATIVE
                    ; 0x09 is ABSOLUTE
                    ; 0x0A is KEYCODE
        param1      ; 0 is RELATIVE
                    ; XMSB maximum if ABSOLUTE
                    ; DELTA X is KEYCODE
        param2      ; 0 is RELATIVE
                    ; YMSB maximum if ABSOLUTE
                    ; DELTA Y is KEYCODE
        param3      ; 0 if RELATIVE
                    ; or KEYCODE
                    ; YMSB is ABSOLUTE
        param4      ; 0 if RELATIVE
                    ; or KEYCODE
                    ; YLSB is ABSOLUTE
        0           ; pad
        0
\end{Verbatim}

The STATUS INQUIRY commands request the ikbd to return either the current mode
or the parameters associated with a given command. All status reports are
padded to form 8 byte long return packets. The responses to the status
requests are designed so that the host may store them away (after stripping
off the status report header byte) and later send them back as commands to
ikbd to restore its state. The 0 pad bytes will be treated as NOPs by the
ikbd.
\begin{quote}

Valid STATUS INQUIRY commands are:

\begin{Verbatim}[commandchars=\\\{\}]
0x87    mouse button action
0x88    mouse mode
0x89
0x8A
0x8B    mnouse threshold
0x8C    mouse scale
0x8F    mouse vertical coordinates
0x90    ( returns       0x0F Y=0 at bottom
                0x10 Y=0 at top )
0x92    mouse enable/disable
        ( returns       0x00 enabled)
                0x12 disabled )
0x94    joystick mode
0x95
0x96
0x9A    joystick enable/disable
        ( returns       0x00 enabled
                0x1A disabled )
\end{Verbatim}
\end{quote}

It is the (host) programmer's responsibility to have only one unanswered
inquiry in process at a time.
STATUS INQUIRY commands are not valid if the ikbd is in JOYSTICK MONITORING
mode or FIRE BUTTON MONITORING mode.


\subsection{SCAN CODES}
\label{input/devices/atarikbd:scan-codes}
The key scan codes returned by the ikbd are chosen to simplify the
implementation of GSX.

GSX Standard Keyboard Mapping

\begin{longtable}{|l|l|}
\hline
\textsf{\relax 
Hex
} & \textsf{\relax 
Keytop
}\\
\hline\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\textsf{\relax 
Hex
} & \textsf{\relax 
Keytop
}\\
\hline\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


01
 & 
Esc
\\
\hline
02
 & 
1
\\
\hline
03
 & 
2
\\
\hline
04
 & 
3
\\
\hline
05
 & 
4
\\
\hline
06
 & 
5
\\
\hline
07
 & 
6
\\
\hline
08
 & 
7
\\
\hline
09
 & 
8
\\
\hline
0A
 & 
9
\\
\hline
0B
 & 
0
\\
\hline
0C
 & 
-
\\
\hline
0D
 & 
=
\\
\hline
0E
 & 
BS
\\
\hline
0F
 & 
TAB
\\
\hline
10
 & 
Q
\\
\hline
11
 & 
W
\\
\hline
12
 & 
E
\\
\hline
13
 & 
R
\\
\hline
14
 & 
T
\\
\hline
15
 & 
Y
\\
\hline
16
 & 
U
\\
\hline
17
 & 
I
\\
\hline
18
 & 
O
\\
\hline
19
 & 
P
\\
\hline
1A
 & 
{[}
\\
\hline
1B
 & 
{]}
\\
\hline
1C
 & 
RET
\\
\hline
1D
 & 
CTRL
\\
\hline
1E
 & 
A
\\
\hline
1F
 & 
S
\\
\hline
20
 & 
D
\\
\hline
21
 & 
F
\\
\hline
22
 & 
G
\\
\hline
23
 & 
H
\\
\hline
24
 & 
J
\\
\hline
25
 & 
K
\\
\hline
26
 & 
L
\\
\hline
27
 & 
;
\\
\hline
28
 & 
`
\\
\hline
29
 & 
{}`
\\
\hline
2A
 & 
(LEFT) SHIFT
\\
\hline
2B
 & 
\textbackslash{}
\\
\hline
2C
 & 
Z
\\
\hline
2D
 & 
X
\\
\hline
2E
 & 
C
\\
\hline
2F
 & 
V
\\
\hline
30
 & 
B
\\
\hline
31
 & 
N
\\
\hline
32
 & 
M
\\
\hline
33
 & 
,
\\
\hline
34
 & 
.
\\
\hline
35
 & 
/
\\
\hline
36
 & 
(RIGHT) SHIFT
\\
\hline
37
 & 
\{ NOT USED \}
\\
\hline
38
 & 
ALT
\\
\hline
39
 & 
SPACE BAR
\\
\hline
3A
 & 
CAPS LOCK
\\
\hline
3B
 & 
F1
\\
\hline
3C
 & 
F2
\\
\hline
3D
 & 
F3
\\
\hline
3E
 & 
F4
\\
\hline
3F
 & 
F5
\\
\hline
40
 & 
F6
\\
\hline
41
 & 
F7
\\
\hline
42
 & 
F8
\\
\hline
43
 & 
F9
\\
\hline
44
 & 
F10
\\
\hline
45
 & 
\{ NOT USED \}
\\
\hline
46
 & 
\{ NOT USED \}
\\
\hline
47
 & 
HOME
\\
\hline
48
 & 
UP ARROW
\\
\hline
49
 & 
\{ NOT USED \}
\\
\hline
4A
 & 
KEYPAD -
\\
\hline
4B
 & 
LEFT ARROW
\\
\hline
4C
 & 
\{ NOT USED \}
\\
\hline
4D
 & 
RIGHT ARROW
\\
\hline
4E
 & 
KEYPAD +
\\
\hline
4F
 & 
\{ NOT USED \}
\\
\hline
50
 & 
DOWN ARROW
\\
\hline
51
 & 
\{ NOT USED \}
\\
\hline
52
 & 
INSERT
\\
\hline
53
 & 
DEL
\\
\hline
54
 & 
\{ NOT USED \}
\\
\hline
5F
 & 
\{ NOT USED \}
\\
\hline
60
 & 
ISO KEY
\\
\hline
61
 & 
UNDO
\\
\hline
62
 & 
HELP
\\
\hline
63
 & 
KEYPAD (
\\
\hline
64
 & 
KEYPAD /
\\
\hline
65
 & 
KEYPAD *
\\
\hline
66
 & 
KEYPAD *
\\
\hline
67
 & 
KEYPAD 7
\\
\hline
68
 & 
KEYPAD 8
\\
\hline
69
 & 
KEYPAD 9
\\
\hline
6A
 & 
KEYPAD 4
\\
\hline
6B
 & 
KEYPAD 5
\\
\hline
6C
 & 
KEYPAD 6
\\
\hline
6D
 & 
KEYPAD 1
\\
\hline
6E
 & 
KEYPAD 2
\\
\hline
6F
 & 
KEYPAD 3
\\
\hline
70
 & 
KEYPAD 0
\\
\hline
71
 & 
KEYPAD .
\\
\hline
72
 & 
KEYPAD ENTER
\\
\hline\end{longtable}



\section{BCM5974 Driver (bcm5974)}
\label{input/devices/bcm5974:bcm5974-driver-bcm5974}\label{input/devices/bcm5974::doc}\begin{quote}\begin{description}
\item[{Copyright}] \leavevmode
© 2008-2009    Henrik Rydberg \textless{}\href{mailto:rydberg@euromail.se}{rydberg@euromail.se}\textgreater{}

\end{description}\end{quote}

The USB initialization and package decoding was made by Scott Shawcroft as
part of the touchd user-space driver project:
\begin{quote}\begin{description}
\item[{Copyright}] \leavevmode
© 2008 Scott Shawcroft (\href{mailto:scott.shawcroft@gmail.com}{scott.shawcroft@gmail.com})

\end{description}\end{quote}

The BCM5974 driver is based on the appletouch driver:
\begin{quote}\begin{description}
\item[{Copyright}] \leavevmode
© 2001-2004    Greg Kroah-Hartman (\href{mailto:greg@kroah.com}{greg@kroah.com})

\item[{Copyright}] \leavevmode
© 2005         Johannes Berg (\href{mailto:johannes@sipsolutions.net}{johannes@sipsolutions.net})

\item[{Copyright}] \leavevmode
© 2005         Stelian Pop (\href{mailto:stelian@popies.net}{stelian@popies.net})

\item[{Copyright}] \leavevmode
© 2005         Frank Arnold (\href{mailto:frank@scirocco-5v-turbo.de}{frank@scirocco-5v-turbo.de})

\item[{Copyright}] \leavevmode
© 2005         Peter Osterlund (\href{mailto:petero2@telia.com}{petero2@telia.com})

\item[{Copyright}] \leavevmode
© 2005         Michael Hanselmann (\href{mailto:linux-kernel@hansmi.ch}{linux-kernel@hansmi.ch})

\item[{Copyright}] \leavevmode
© 2006         Nicolas Boichat (\href{mailto:nicolas@boichat.ch}{nicolas@boichat.ch})

\end{description}\end{quote}

This driver adds support for the multi-touch trackpad on the new Apple
Macbook Air and Macbook Pro laptops. It replaces the appletouch driver on
those computers, and integrates well with the synaptics driver of the Xorg
system.

Known to work on Macbook Air, Macbook Pro Penryn and the new unibody
Macbook 5 and Macbook Pro 5.


\subsection{Usage}
\label{input/devices/bcm5974:usage}
The driver loads automatically for the supported usb device ids, and
becomes available both as an event device (/dev/input/event*) and as a
mouse via the mousedev driver (/dev/input/mice).


\subsection{USB Race}
\label{input/devices/bcm5974:usb-race}
The Apple multi-touch trackpads report both mouse and keyboard events via
different interfaces of the same usb device. This creates a race condition
with the HID driver, which, if not told otherwise, will find the standard
HID mouse and keyboard, and claim the whole device. To remedy, the usb
product id must be listed in the mouse\_ignore list of the hid driver.


\subsection{Debug output}
\label{input/devices/bcm5974:debug-output}
To ease the development for new hardware version, verbose packet output can
be switched on with the debug kernel module parameter. The range {[}1-9{]}
yields different levels of verbosity. Example (as root):

\begin{Verbatim}[commandchars=\\\{\}]
echo \PYGZhy{}n 9 \PYGZgt{} /sys/module/bcm5974/parameters/debug

tail \PYGZhy{}f /var/log/debug

echo \PYGZhy{}n 0 \PYGZgt{} /sys/module/bcm5974/parameters/debug
\end{Verbatim}


\subsection{Trivia}
\label{input/devices/bcm5974:trivia}
The driver was developed at the ubuntu forums in June 2008 \footnote[1]{
\href{http://ubuntuforums.org/showthread.php?t=840040}{http://ubuntuforums.org/showthread.php?t=840040}
}, and now has
a more permanent home at bitmath.org \footnote[2]{
\href{http://bitmath.org/code/}{http://bitmath.org/code/}
}.


\section{CMA3000-D0x Accelerometer}
\label{input/devices/cma3000_d0x:cma3000-d0x-accelerometer}\label{input/devices/cma3000_d0x::doc}
Supported chips:
* VTI CMA3000-D0x
\begin{description}
\item[{Datasheet:}] \leavevmode
CMA3000-D0X Product Family Specification 8281000A.02.pdf
\textless{}\href{http://www.vti.fi/en/}{http://www.vti.fi/en/}\textgreater{}

\end{description}
\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Hemanth V \textless{}\href{mailto:hemanthv@ti.com}{hemanthv@ti.com}\textgreater{}

\end{description}\end{quote}


\subsection{Description}
\label{input/devices/cma3000_d0x:description}
CMA3000 Tri-axis accelerometer supports Motion detect, Measurement and
Free fall modes.
\begin{description}
\item[{Motion Detect Mode:}] \leavevmode
Its the low power mode where interrupts are generated only
when motion exceeds the defined thresholds.

\item[{Measurement Mode:}] \leavevmode
This mode is used to read the acceleration data on X,Y,Z
axis and supports 400, 100, 40 Hz sample frequency.

\item[{Free fall Mode:}] \leavevmode
This mode is intended to save system resources.

\item[{Threshold values:}] \leavevmode
Chip supports defining threshold values for above modes
which includes time and g value. Refer product specifications for
more details.

\end{description}

CMA3000 chip supports mutually exclusive I2C and SPI interfaces for
communication, currently the driver supports I2C based communication only.
Initial configuration for bus mode is set in non volatile memory and can later
be modified through bus interface command.

Driver reports acceleration data through input subsystem. It generates ABS\_MISC
event with value 1 when free fall is detected.

Platform data need to be configured for initial default values.


\subsection{Platform Data}
\label{input/devices/cma3000_d0x:platform-data}\begin{description}
\item[{fuzz\_x:}] \leavevmode
Noise on X Axis

\item[{fuzz\_y:}] \leavevmode
Noise on Y Axis

\item[{fuzz\_z:}] \leavevmode
Noise on Z Axis

\item[{g\_range:}] \leavevmode
G range in milli g i.e 2000 or 8000

\item[{mode:}] \leavevmode
Default Operating mode

\item[{mdthr:}] \leavevmode
Motion detect g range threshold value

\item[{mdfftmr:}] \leavevmode
Motion detect and free fall time threshold value

\item[{ffthr:}] \leavevmode
Free fall g range threshold value

\end{description}


\subsection{Input Interface}
\label{input/devices/cma3000_d0x:input-interface}
Input driver version is 1.0.0
Input device ID: bus 0x18 vendor 0x0 product 0x0 version 0x0
Input device name: ``cma3000-accelerometer''

Supported events:

\begin{Verbatim}[commandchars=\\\{\}]
Event type 0 (Sync)
Event type 3 (Absolute)
  Event code 0 (X)
    Value     47
    Min    \PYGZhy{}8000
    Max     8000
    Fuzz     200
  Event code 1 (Y)
    Value    \PYGZhy{}28
    Min    \PYGZhy{}8000
    Max     8000
    Fuzz     200
  Event code 2 (Z)
    Value    905
    Min    \PYGZhy{}8000
    Max     8000
    Fuzz     200
  Event code 40 (Misc)
    Value      0
    Min        0
    Max        1
Event type 4 (Misc)
\end{Verbatim}


\subsection{Register/Platform parameters Description}
\label{input/devices/cma3000_d0x:register-platform-parameters-description}
mode:

\begin{Verbatim}[commandchars=\\\{\}]
0: power down mode
1: 100 Hz Measurement mode
2: 400 Hz Measurement mode
3: 40 Hz Measurement mode
4: Motion Detect mode (default)
5: 100 Hz Free fall mode
6: 40 Hz Free fall mode
7: Power off mode
\end{Verbatim}

grange:

\begin{Verbatim}[commandchars=\\\{\}]
2000: 2000 mg or 2G Range
8000: 8000 mg or 8G Range
\end{Verbatim}

mdthr:

\begin{Verbatim}[commandchars=\\\{\}]
X: X * 71mg (8G Range)
X: X * 18mg (2G Range)
\end{Verbatim}

mdfftmr:

\begin{Verbatim}[commandchars=\\\{\}]
X: (X \PYGZam{} 0x70) * 100 ms (MDTMR)
   (X \PYGZam{} 0x0F) * 2.5 ms (FFTMR 400 Hz)
   (X \PYGZam{} 0x0F) * 10 ms  (FFTMR 100 Hz)
\end{Verbatim}

ffthr:

\begin{Verbatim}[commandchars=\\\{\}]
X: (X \PYGZgt{}\PYGZgt{} 2) * 18mg (2G Range)
X: (X \PYGZam{} 0x0F) * 71 mg (8G Range)
\end{Verbatim}


\section{Crystal SoundFusion CS4610/CS4612/CS461 joystick}
\label{input/devices/cs461x::doc}\label{input/devices/cs461x:crystal-soundfusion-cs4610-cs4612-cs461-joystick}
This is a new low-level driver to support analog joystick attached to
Crystal SoundFusion CS4610/CS4612/CS4615. This code is based upon
Vortex/Solo drivers as an example of decoration style, and ALSA
0.5.8a kernel drivers as an chipset documentation and samples.

This version does not have cooked mode support; the basic code
is present here, but have not tested completely. The button analysis
is completed in this mode, but the axis movement is not.

Raw mode works fine with analog joystick front-end driver and cs461x
driver as a backend. I've tested this driver with CS4610, 4-axis and
4-button joystick; I mean the jstest utility. Also I've tried to
play in xracer game using joystick, and the result is better than
keyboard only mode.

The sensitivity and calibrate quality have not been tested; the two
reasons are performed: the same hardware cannot work under Win95 (blue
screen in VJOYD); I have no documentation on my chip; and the existing
behavior in my case was not raised the requirement of joystick calibration.
So the driver have no code to perform hardware related calibration.

This driver have the basic support for PCI devices only; there is no
ISA or PnP ISA cards supported.

The driver works with ALSA drivers simultaneously. For example, the xracer
uses joystick as input device and PCM device as sound output in one time.
There are no sound or input collisions detected. The source code have
comments about them; but I've found the joystick can be initialized
separately of ALSA modules. So, you can use only one joystick driver
without ALSA drivers. The ALSA drivers are not needed to compile or
run this driver.

There are no debug information print have been placed in source, and no
specific options required to work this driver. The found chipset parameters
are printed via printk(KERN\_INFO ''...''), see the /var/log/messages to
inspect cs461x: prefixed messages to determine possible card detection
errors.

Regards,
Viktor


\section{EDT ft5x06 based Polytouch devices}
\label{input/devices/edt-ft5x06::doc}\label{input/devices/edt-ft5x06:edt-ft5x06-based-polytouch-devices}
The edt-ft5x06 driver is useful for the EDT ``Polytouch'' family of capacitive
touch screens. Note that it is \emph{not} suitable for other devices based on the
focaltec ft5x06 devices, since they contain vendor-specific firmware. In
particular this driver is not suitable for the Nook tablet.
\begin{description}
\item[{It has been tested with the following devices:}] \leavevmode\begin{itemize}
\item {} 
EP0350M06

\item {} 
EP0430M06

\item {} 
EP0570M06

\item {} 
EP0700M06

\end{itemize}

\end{description}

The driver allows configuration of the touch screen via a set of sysfs files:
\begin{description}
\item[{/sys/class/input/eventX/device/device/threshold:}] \leavevmode
allows setting the ``click''-threshold in the range from 0 to 80.

\item[{/sys/class/input/eventX/device/device/gain:}] \leavevmode
allows setting the sensitivity in the range from 0 to 31. Note that
lower values indicate higher sensitivity.

\item[{/sys/class/input/eventX/device/device/offset:}] \leavevmode
allows setting the edge compensation in the range from 0 to 31.

\item[{/sys/class/input/eventX/device/device/report\_rate:}] \leavevmode
allows setting the report rate in the range from 3 to 14.

\end{description}

For debugging purposes the driver provides a few files in the debug
filesystem (if available in the kernel). In /sys/kernel/debug/edt\_ft5x06
you'll find the following files:
\begin{description}
\item[{num\_x, num\_y:}] \leavevmode
(readonly) contains the number of sensor fields in X- and
Y-direction.

\item[{mode:}] \leavevmode
allows switching the sensor between ``factory mode'' and ``operation
mode'' by writing ``1'' or ``0'' to it. In factory mode (1) it is
possible to get the raw data from the sensor. Note that in factory
mode regular events don't get delivered and the options described
above are unavailable.

\item[{raw\_data:}] \leavevmode
contains num\_x * num\_y big endian 16 bit values describing the raw
values for each sensor field. Note that each read() call on this
files triggers a new readout. It is recommended to provide a buffer
big enough to contain num\_x * num\_y * 2 bytes.

\end{description}

Note that reading raw\_data gives a I/O error when the device is not in factory
mode. The same happens when reading/writing to the parameter files when the
device is not in regular operation mode.


\section{Elantech Touchpad Driver}
\label{input/devices/elantech::doc}\label{input/devices/elantech:elantech-touchpad-driver}\begin{quote}

Copyright (C) 2007-2008 Arjan Opmeer \textless{}\href{mailto:arjan@opmeer.net}{arjan@opmeer.net}\textgreater{}

Extra information for hardware version 1 found and
provided by Steve Havelka

Version 2 (EeePC) hardware support based on patches
received from Woody at Xandros and forwarded to me
by user StewieGriffin at the eeeuser.com forum
\end{quote}


\subsection{Introduction}
\label{input/devices/elantech:introduction}
Currently the Linux Elantech touchpad driver is aware of four different
hardware versions unimaginatively called version 1,version 2, version 3
and version 4. Version 1 is found in ``older'' laptops and uses 4 bytes per
packet. Version 2 seems to be introduced with the EeePC and uses 6 bytes
per packet, and provides additional features such as position of two fingers,
and width of the touch.  Hardware version 3 uses 6 bytes per packet (and
for 2 fingers the concatenation of two 6 bytes packets) and allows tracking
of up to 3 fingers. Hardware version 4 uses 6 bytes per packet, and can
combine a status packet with multiple head or motion packets. Hardware version
4 allows tracking up to 5 fingers.

Some Hardware version 3 and version 4 also have a trackpoint which uses a
separate packet format. It is also 6 bytes per packet.

The driver tries to support both hardware versions and should be compatible
with the Xorg Synaptics touchpad driver and its graphical configuration
utilities.

Note that a mouse button is also associated with either the touchpad or the
trackpoint when a trackpoint is available.  Disabling the Touchpad in xorg
(TouchPadOff=0) will also disable the buttons associated with the touchpad.

Additionally the operation of the touchpad can be altered by adjusting the
contents of some of its internal registers. These registers are represented
by the driver as sysfs entries under /sys/bus/serio/drivers/psmouse/serio?
that can be read from and written to.

Currently only the registers for hardware version 1 are somewhat understood.
Hardware version 2 seems to use some of the same registers but it is not
known whether the bits in the registers represent the same thing or might
have changed their meaning.

On top of that, some register settings have effect only when the touchpad is
in relative mode and not in absolute mode. As the Linux Elantech touchpad
driver always puts the hardware into absolute mode not all information
mentioned below can be used immediately. But because there is no freely
available Elantech documentation the information is provided here anyway for
completeness sake.


\subsection{Extra knobs}
\label{input/devices/elantech:extra-knobs}
Currently the Linux Elantech touchpad driver provides three extra knobs under
/sys/bus/serio/drivers/psmouse/serio? for the user.
\begin{itemize}
\item {} 
debug
\begin{quote}

Turn different levels of debugging ON or OFF.

By echoing ``0'' to this file all debugging will be turned OFF.

Currently a value of ``1'' will turn on some basic debugging and a value of
``2'' will turn on packet debugging. For hardware version 1 the default is
OFF. For version 2 the default is ``1''.

Turning packet debugging on will make the driver dump every packet
received to the syslog before processing it. Be warned that this can
generate quite a lot of data!
\end{quote}

\item {} 
paritycheck
\begin{quote}

Turns parity checking ON or OFF.

By echoing ``0'' to this file parity checking will be turned OFF. Any
non-zero value will turn it ON. For hardware version 1 the default is ON.
For version 2 the default it is OFF.

Hardware version 1 provides basic data integrity verification by
calculating a parity bit for the last 3 bytes of each packet. The driver
can check these bits and reject any packet that appears corrupted. Using
this knob you can bypass that check.

Hardware version 2 does not provide the same parity bits. Only some basic
data consistency checking can be done. For now checking is disabled by
default. Currently even turning it on will do nothing.
\end{quote}

\item {} 
crc\_enabled
\begin{quote}

Sets crc\_enabled to 0/1. The name ``crc\_enabled'' is the official name of
this integrity check, even though it is not an actual cyclic redundancy
check.

Depending on the state of crc\_enabled, certain basic data integrity
verification is done by the driver on hardware version 3 and 4. The
driver will reject any packet that appears corrupted. Using this knob,
The state of crc\_enabled can be altered with this knob.

Reading the crc\_enabled value will show the active value. Echoing
``0'' or ``1'' to this file will set the state to ``0'' or ``1''.
\end{quote}

\end{itemize}


\subsection{Differentiating hardware versions}
\label{input/devices/elantech:differentiating-hardware-versions}
To detect the hardware version, read the version number as param{[}0{]}.param{[}1{]}.param{[}2{]}:

\begin{Verbatim}[commandchars=\\\{\}]
4 bytes version: (after the arrow is the name given in the Dell\PYGZhy{}provided driver)
02.00.22 =\PYGZgt{} EF013
02.06.00 =\PYGZgt{} EF019
\end{Verbatim}

In the wild, there appear to be more versions, such as 00.01.64, 01.00.21,
02.00.00, 02.00.04, 02.00.06:

\begin{Verbatim}[commandchars=\\\{\}]
6 bytes:
02.00.30 =\PYGZgt{} EF113
02.08.00 =\PYGZgt{} EF023
02.08.XX =\PYGZgt{} EF123
02.0B.00 =\PYGZgt{} EF215
04.01.XX =\PYGZgt{} Scroll\PYGZus{}EF051
04.02.XX =\PYGZgt{} EF051
\end{Verbatim}

In the wild, there appear to be more versions, such as 04.03.01, 04.04.11. There
appears to be almost no difference, except for EF113, which does not report
pressure/width and has different data consistency checks.

Probably all the versions with param{[}0{]} \textless{}= 01 can be considered as
4 bytes/firmware 1. The versions \textless{} 02.08.00, with the exception of 02.00.30, as
4 bytes/firmware 2. Everything \textgreater{}= 02.08.00 can be considered as 6 bytes.


\subsection{Hardware version 1}
\label{input/devices/elantech:hardware-version-1}

\subsubsection{Registers}
\label{input/devices/elantech:registers}
By echoing a hexadecimal value to a register it contents can be altered.

For example:

\begin{Verbatim}[commandchars=\\\{\}]
echo \PYGZhy{}n 0x16 \PYGZgt{} reg\PYGZus{}10
\end{Verbatim}
\begin{itemize}
\item {} 
reg\_10:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      B   C   T   D   L   A   S   E

      E: 1 = enable smart edges unconditionally
      S: 1 = enable smart edges only when dragging
      A: 1 = absolute mode (needs 4 byte packets, see reg\PYGZus{}11)
      L: 1 = enable drag lock (see reg\PYGZus{}22)
      D: 1 = disable dynamic resolution
      T: 1 = disable tapping
      C: 1 = enable corner tap
      B: 1 = swap left and right button
\end{Verbatim}

\item {} 
reg\_11:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      1   0   0   H   V   1   F   P

      P: 1 = enable parity checking for relative mode
      F: 1 = enable native 4 byte packet mode
      V: 1 = enable vertical scroll area
      H: 1 = enable horizontal scroll area
\end{Verbatim}

\item {} 
reg\_20:

\begin{Verbatim}[commandchars=\\\{\}]
single finger width?
\end{Verbatim}

\item {} 
reg\_21:

\begin{Verbatim}[commandchars=\\\{\}]
scroll area width (small: 0x40 ... wide: 0xff)
\end{Verbatim}

\item {} 
reg\_22:

\begin{Verbatim}[commandchars=\\\{\}]
drag lock time out (short: 0x14 ... long: 0xfe;
                    0xff = tap again to release)
\end{Verbatim}

\item {} 
reg\_23:

\begin{Verbatim}[commandchars=\\\{\}]
tap make timeout?
\end{Verbatim}

\item {} 
reg\_24:

\begin{Verbatim}[commandchars=\\\{\}]
tap release timeout?
\end{Verbatim}

\item {} 
reg\_25:

\begin{Verbatim}[commandchars=\\\{\}]
smart edge cursor speed (0x02 = slow, 0x03 = medium, 0x04 = fast)
\end{Verbatim}

\item {} 
reg\_26:

\begin{Verbatim}[commandchars=\\\{\}]
smart edge activation area width?
\end{Verbatim}

\end{itemize}


\subsubsection{Native relative mode 4 byte packet format}
\label{input/devices/elantech:native-relative-mode-4-byte-packet-format}
byte 0:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      c   c  p2  p1   1   M   R   L

      L, R, M = 1 when Left, Right, Middle mouse button pressed
         some models have M as byte 3 odd parity bit
      when parity checking is enabled (reg\PYGZus{}11, P = 1):
         p1..p2 = byte 1 and 2 odd parity bit
      c = 1 when corner tap detected
\end{Verbatim}

byte 1:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     dx7 dx6 dx5 dx4 dx3 dx2 dx1 dx0

      dx7..dx0 = x movement;   positive = right, negative = left
      byte 1 = 0xf0 when corner tap detected
\end{Verbatim}

byte 2:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     dy7 dy6 dy5 dy4 dy3 dy2 dy1 dy0

      dy7..dy0 = y movement;   positive = up,    negative = down
\end{Verbatim}

byte 3:

\begin{Verbatim}[commandchars=\\\{\}]
parity checking enabled (reg\PYGZus{}11, P = 1):

   bit   7   6   5   4   3   2   1   0
         w   h  n1  n0  ds3 ds2 ds1 ds0

         normally:
            ds3..ds0 = scroll wheel amount and direction
                       positive = down or left
                       negative = up or right
         when corner tap detected:
            ds0 = 1 when top right corner tapped
            ds1 = 1 when bottom right corner tapped
            ds2 = 1 when bottom left corner tapped
            ds3 = 1 when top left corner tapped
         n1..n0 = number of fingers on touchpad
            only models with firmware 2.x report this, models with
            firmware 1.x seem to map one, two and three finger taps
            directly to L, M and R mouse buttons
         h = 1 when horizontal scroll action
         w = 1 when wide finger touch?

otherwise (reg\PYGZus{}11, P = 0):

   bit   7   6   5   4   3   2   1   0
        ds7 ds6 ds5 ds4 ds3 ds2 ds1 ds0

         ds7..ds0 = vertical scroll amount and direction
                    negative = up
                    positive = down
\end{Verbatim}


\subsubsection{Native absolute mode 4 byte packet format}
\label{input/devices/elantech:native-absolute-mode-4-byte-packet-format}
EF013 and EF019 have a special behaviour (due to a bug in the firmware?), and
when 1 finger is touching, the first 2 position reports must be discarded.
This counting is reset whenever a different number of fingers is reported.

byte 0:

\begin{Verbatim}[commandchars=\\\{\}]
firmware version 1.x:

   bit   7   6   5   4   3   2   1   0
         D   U  p1  p2   1  p3   R   L

         L, R = 1 when Left, Right mouse button pressed
         p1..p3 = byte 1..3 odd parity bit
         D, U = 1 when rocker switch pressed Up, Down

firmware version 2.x:

   bit   7   6   5   4   3   2   1   0
        n1  n0  p2  p1   1  p3   R   L

         L, R = 1 when Left, Right mouse button pressed
         p1..p3 = byte 1..3 odd parity bit
         n1..n0 = number of fingers on touchpad
\end{Verbatim}

byte 1:

\begin{Verbatim}[commandchars=\\\{\}]
firmware version 1.x:

   bit   7   6   5   4   3   2   1   0
         f   0  th  tw  x9  x8  y9  y8

         tw = 1 when two finger touch
         th = 1 when three finger touch
         f  = 1 when finger touch

firmware version 2.x:

   bit   7   6   5   4   3   2   1   0
         .   .   .   .  x9  x8  y9  y8
\end{Verbatim}

byte 2:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     x7  x6  x5  x4  x3  x2  x1  x0

      x9..x0 = absolute x value (horizontal)
\end{Verbatim}

byte 3:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     y7  y6  y5  y4  y3  y2  y1  y0

      y9..y0 = absolute y value (vertical)
\end{Verbatim}


\subsection{Hardware version 2}
\label{input/devices/elantech:hardware-version-2}

\subsubsection{Registers}
\label{input/devices/elantech:id1}
By echoing a hexadecimal value to a register it contents can be altered.

For example:

\begin{Verbatim}[commandchars=\\\{\}]
echo \PYGZhy{}n 0x56 \PYGZgt{} reg\PYGZus{}10
\end{Verbatim}
\begin{itemize}
\item {} 
reg\_10:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      0   1   0   1   0   1   D   0

      D: 1 = enable drag and drop
\end{Verbatim}

\item {} 
reg\_11:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      1   0   0   0   S   0   1   0

      S: 1 = enable vertical scroll
\end{Verbatim}

\item {} 
reg\_21:

\begin{Verbatim}[commandchars=\\\{\}]
unknown (0x00)
\end{Verbatim}

\item {} 
reg\_22:

\begin{Verbatim}[commandchars=\\\{\}]
drag and drop release time out (short: 0x70 ... long 0x7e;
                          0x7f = never i.e. tap again to release)
\end{Verbatim}

\end{itemize}


\subsubsection{Native absolute mode 6 byte packet format}
\label{input/devices/elantech:native-absolute-mode-6-byte-packet-format}

\paragraph{Parity checking and packet re-synchronization}
\label{input/devices/elantech:parity-checking-and-packet-re-synchronization}
There is no parity checking, however some consistency checks can be performed.

For instance for EF113:

\begin{Verbatim}[commandchars=\\\{\}]
SA1= packet[0];
A1 = packet[1];
B1 = packet[2];
SB1= packet[3];
C1 = packet[4];
D1 = packet[5];
if( (((SA1 \PYGZam{} 0x3C) != 0x3C) \PYGZam{}\PYGZam{} ((SA1 \PYGZam{} 0xC0) != 0x80)) \textbar{}\textbar{} // check Byte 1
    (((SA1 \PYGZam{} 0x0C) != 0x0C) \PYGZam{}\PYGZam{} ((SA1 \PYGZam{} 0xC0) == 0x80)) \textbar{}\textbar{} // check Byte 1 (one finger pressed)
    (((SA1 \PYGZam{} 0xC0) != 0x80) \PYGZam{}\PYGZam{} (( A1 \PYGZam{} 0xF0) != 0x00)) \textbar{}\textbar{} // check Byte 2
    (((SB1 \PYGZam{} 0x3E) != 0x38) \PYGZam{}\PYGZam{} ((SA1 \PYGZam{} 0xC0) != 0x80)) \textbar{}\textbar{} // check Byte 4
    (((SB1 \PYGZam{} 0x0E) != 0x08) \PYGZam{}\PYGZam{} ((SA1 \PYGZam{} 0xC0) == 0x80)) \textbar{}\textbar{} // check Byte 4 (one finger pressed)
    (((SA1 \PYGZam{} 0xC0) != 0x80) \PYGZam{}\PYGZam{} (( C1 \PYGZam{} 0xF0) != 0x00))  ) // check Byte 5
        // error detected
\end{Verbatim}

For all the other ones, there are just a few constant bits:

\begin{Verbatim}[commandchars=\\\{\}]
if( ((packet[0] \PYGZam{} 0x0C) != 0x04) \textbar{}\textbar{}
    ((packet[3] \PYGZam{} 0x0f) != 0x02) )
        // error detected
\end{Verbatim}

In case an error is detected, all the packets are shifted by one (and packet{[}0{]} is discarded).


\paragraph{One/Three finger touch}
\label{input/devices/elantech:one-three-finger-touch}
byte 0:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      n1  n0  w3  w2   .   .   R   L

      L, R = 1 when Left, Right mouse button pressed
      n1..n0 = number of fingers on touchpad
\end{Verbatim}

byte 1:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      p7  p6  p5  p4 x11 x10 x9  x8
\end{Verbatim}

byte 2:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      x7  x6  x5  x4  x3  x2  x1  x0

      x11..x0 = absolute x value (horizontal)
\end{Verbatim}

byte 3:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      n4  vf  w1  w0   .   .   .  b2

      n4 = set if more than 3 fingers (only in 3 fingers mode)
      vf = a kind of flag ? (only on EF123, 0 when finger is over one
           of the buttons, 1 otherwise)
      w3..w0 = width of the finger touch (not EF113)
      b2 (on EF113 only, 0 otherwise), b2.R.L indicates one button pressed:
             0 = none
             1 = Left
             2 = Right
             3 = Middle (Left and Right)
             4 = Forward
             5 = Back
             6 = Another one
             7 = Another one
\end{Verbatim}

byte 4:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     p3  p1  p2  p0  y11 y10 y9  y8

      p7..p0 = pressure (not EF113)
\end{Verbatim}

byte 5:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     y7  y6  y5  y4  y3  y2  y1  y0

      y11..y0 = absolute y value (vertical)
\end{Verbatim}


\paragraph{Two finger touch}
\label{input/devices/elantech:two-finger-touch}
Note that the two pairs of coordinates are not exactly the coordinates of the
two fingers, but only the pair of the lower-left and upper-right coordinates.
So the actual fingers might be situated on the other diagonal of the square
defined by these two points.

byte 0:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     n1  n0  ay8 ax8  .   .   R   L

      L, R = 1 when Left, Right mouse button pressed
      n1..n0 = number of fingers on touchpad
\end{Verbatim}

byte 1:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     ax7 ax6 ax5 ax4 ax3 ax2 ax1 ax0

      ax8..ax0 = lower\PYGZhy{}left finger absolute x value
\end{Verbatim}

byte 2:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     ay7 ay6 ay5 ay4 ay3 ay2 ay1 ay0

      ay8..ay0 = lower\PYGZhy{}left finger absolute y value
\end{Verbatim}

byte 3:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      .   .  by8 bx8  .   .   .   .
\end{Verbatim}

byte 4:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     bx7 bx6 bx5 bx4 bx3 bx2 bx1 bx0

      bx8..bx0 = upper\PYGZhy{}right finger absolute x value
\end{Verbatim}

byte 5:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     by7 by8 by5 by4 by3 by2 by1 by0

      by8..by0 = upper\PYGZhy{}right finger absolute y value
\end{Verbatim}


\subsection{Hardware version 3}
\label{input/devices/elantech:hardware-version-3}

\subsubsection{Registers}
\label{input/devices/elantech:id2}\begin{itemize}
\item {} 
reg\_10:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      0   0   0   0   R   F   T   A

      A: 1 = enable absolute tracking
      T: 1 = enable two finger mode auto correct
      F: 1 = disable ABS Position Filter
      R: 1 = enable real hardware resolution
\end{Verbatim}

\end{itemize}


\subsubsection{Native absolute mode 6 byte packet format}
\label{input/devices/elantech:id3}
1 and 3 finger touch shares the same 6-byte packet format, except that
3 finger touch only reports the position of the center of all three fingers.

Firmware would send 12 bytes of data for 2 finger touch.

Note on debounce:
In case the box has unstable power supply or other electricity issues, or
when number of finger changes, F/W would send ``debounce packet'' to inform
driver that the hardware is in debounce status.
The debouce packet has the following signature:

\begin{Verbatim}[commandchars=\\\{\}]
byte 0: 0xc4
byte 1: 0xff
byte 2: 0xff
byte 3: 0x02
byte 4: 0xff
byte 5: 0xff
\end{Verbatim}

When we encounter this kind of packet, we just ignore it.


\paragraph{One/Three finger touch}
\label{input/devices/elantech:id4}
byte 0:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     n1  n0  w3  w2   0   1   R   L

     L, R = 1 when Left, Right mouse button pressed
     n1..n0 = number of fingers on touchpad
\end{Verbatim}

byte 1:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     p7  p6  p5  p4 x11 x10  x9  x8
\end{Verbatim}

byte 2:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     x7  x6  x5  x4  x3  x2  x1  x0

     x11..x0 = absolute x value (horizontal)
\end{Verbatim}

byte 3:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      0   0  w1  w0   0   0   1   0

      w3..w0 = width of the finger touch
\end{Verbatim}

byte 4:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     p3  p1  p2  p0  y11 y10 y9  y8

     p7..p0 = pressure
\end{Verbatim}

byte 5:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     y7  y6  y5  y4  y3  y2  y1  y0

     y11..y0 = absolute y value (vertical)
\end{Verbatim}


\paragraph{Two finger touch}
\label{input/devices/elantech:id5}
The packet format is exactly the same for two finger touch, except the hardware
sends two 6 byte packets. The first packet contains data for the first finger,
the second packet has data for the second finger. So for two finger touch a
total of 12 bytes are sent.


\subsection{Hardware version 4}
\label{input/devices/elantech:hardware-version-4}

\subsubsection{Registers}
\label{input/devices/elantech:id6}\begin{itemize}
\item {} 
reg\_07:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      0   0   0   0   0   0   0   A

      A: 1 = enable absolute tracking
\end{Verbatim}

\end{itemize}


\subsubsection{Native absolute mode 6 byte packet format}
\label{input/devices/elantech:id7}
v4 hardware is a true multitouch touchpad, capable of tracking up to 5 fingers.
Unfortunately, due to PS/2's limited bandwidth, its packet format is rather
complex.

Whenever the numbers or identities of the fingers changes, the hardware sends a
status packet to indicate how many and which fingers is on touchpad, followed by
head packets or motion packets. A head packet contains data of finger id, finger
position (absolute x, y values), width, and pressure. A motion packet contains
two fingers' position delta.

For example, when status packet tells there are 2 fingers on touchpad, then we
can expect two following head packets. If the finger status doesn't change,
the following packets would be motion packets, only sending delta of finger
position, until we receive a status packet.

One exception is one finger touch. when a status packet tells us there is only
one finger, the hardware would just send head packets afterwards.


\paragraph{Status packet}
\label{input/devices/elantech:status-packet}
byte 0:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      .   .   .   .   0   1   R   L

      L, R = 1 when Left, Right mouse button pressed
\end{Verbatim}

byte 1:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      .   .   . ft4 ft3 ft2 ft1 ft0

      ft4 ft3 ft2 ft1 ft0 ftn = 1 when finger n is on touchpad
\end{Verbatim}

byte 2:

\begin{Verbatim}[commandchars=\\\{\}]
not used
\end{Verbatim}

byte 3:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      .   .   .   1   0   0   0   0

      constant bits
\end{Verbatim}

byte 4:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      p   .   .   .   .   .   .   .

      p = 1 for palm
\end{Verbatim}

byte 5:

\begin{Verbatim}[commandchars=\\\{\}]
not used
\end{Verbatim}


\paragraph{Head packet}
\label{input/devices/elantech:head-packet}
byte 0:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     w3  w2  w1  w0   0   1   R   L

     L, R = 1 when Left, Right mouse button pressed
     w3..w0 = finger width (spans how many trace lines)
\end{Verbatim}

byte 1:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     p7  p6  p5  p4 x11 x10  x9  x8
\end{Verbatim}

byte 2:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     x7  x6  x5  x4  x3  x2  x1  x0

     x11..x0 = absolute x value (horizontal)
\end{Verbatim}

byte 3:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
    id2 id1 id0   1   0   0   0   1

    id2..id0 = finger id
\end{Verbatim}

byte 4:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     p3  p1  p2  p0  y11 y10 y9  y8

     p7..p0 = pressure
\end{Verbatim}

byte 5:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     y7  y6  y5  y4  y3  y2  y1  y0

     y11..y0 = absolute y value (vertical)
\end{Verbatim}


\paragraph{Motion packet}
\label{input/devices/elantech:motion-packet}
byte 0:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
    id2 id1 id0   w   0   1   R   L

    L, R = 1 when Left, Right mouse button pressed
    id2..id0 = finger id
    w = 1 when delta overflows (\PYGZgt{} 127 or \PYGZlt{} \PYGZhy{}128), in this case
    firmware sends us (delta x / 5) and (delta y  / 5)
\end{Verbatim}

byte 1:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     x7  x6  x5  x4  x3  x2  x1  x0

     x7..x0 = delta x (two\PYGZsq{}s complement)
\end{Verbatim}

byte 2:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     y7  y6  y5  y4  y3  y2  y1  y0

     y7..y0 = delta y (two\PYGZsq{}s complement)
\end{Verbatim}

byte 3:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
    id2 id1 id0   1   0   0   1   0

    id2..id0 = finger id
\end{Verbatim}

byte 4:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     x7  x6  x5  x4  x3  x2  x1  x0

     x7..x0 = delta x (two\PYGZsq{}s complement)
\end{Verbatim}

byte 5:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     y7  y6  y5  y4  y3  y2  y1  y0

     y7..y0 = delta y (two\PYGZsq{}s complement)

     byte 0 \PYGZti{} 2 for one finger
     byte 3 \PYGZti{} 5 for another
\end{Verbatim}


\subsection{Trackpoint (for Hardware version 3 and 4)}
\label{input/devices/elantech:trackpoint-for-hardware-version-3-and-4}

\subsubsection{Registers}
\label{input/devices/elantech:id8}
No special registers have been identified.


\subsubsection{Native relative mode 6 byte packet format}
\label{input/devices/elantech:native-relative-mode-6-byte-packet-format}

\paragraph{Status Packet}
\label{input/devices/elantech:id9}
byte 0:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      0   0  sx  sy   0   M   R   L
\end{Verbatim}

byte 1:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
    \PYGZti{}sx   0   0   0   0   0   0   0
\end{Verbatim}

byte 2:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
    \PYGZti{}sy   0   0   0   0   0   0   0
\end{Verbatim}

byte 3:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
      0   0 \PYGZti{}sy \PYGZti{}sx   0   1   1   0
\end{Verbatim}

byte 4:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     x7  x6  x5  x4  x3  x2  x1  x0
\end{Verbatim}

byte 5:

\begin{Verbatim}[commandchars=\\\{\}]
bit   7   6   5   4   3   2   1   0
     y7  y6  y5  y4  y3  y2  y1  y0


      x and y are written in two\PYGZsq{}s complement spread
          over 9 bits with sx/sy the relative top bit and
          x7..x0 and y7..y0 the lower bits.
      \PYGZti{}sx is the inverse of sx, \PYGZti{}sy is the inverse of sy.
      The sign of y is opposite to what the input driver
          expects for a relative movement
\end{Verbatim}


\section{Iforce Protocol}
\label{input/devices/iforce-protocol:iforce-protocol}\label{input/devices/iforce-protocol::doc}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Johann Deneux \textless{}\href{mailto:johann.deneux@gmail.com}{johann.deneux@gmail.com}\textgreater{}

\end{description}\end{quote}

Home page at \href{http://web.archive.org/web/*/http://www.esil.univ-mrs.fr}{http://web.archive.org/web/*/http://www.esil.univ-mrs.fr}
\begin{quote}\begin{description}
\item[{Additions}] \leavevmode
by Vojtech Pavlik.

\end{description}\end{quote}


\subsection{Introduction}
\label{input/devices/iforce-protocol:introduction}
This document describes what I managed to discover about the protocol used to
specify force effects to I-Force 2.0 devices.  None of this information comes
from Immerse. That's why you should not trust what is written in this
document. This document is intended to help understanding the protocol.
This is not a reference. Comments and corrections are welcome.  To contact me,
send an email to: \href{mailto:johann.deneux@gmail.com}{johann.deneux@gmail.com}

\begin{notice}{warning}{Warning:}
I shall not be held responsible for any damage or harm caused if you try to
send data to your I-Force device based on what you read in this document.
\end{notice}


\subsection{Preliminary Notes}
\label{input/devices/iforce-protocol:preliminary-notes}
All values are hexadecimal with big-endian encoding (msb on the left). Beware,
values inside packets are encoded using little-endian.  Bytes whose roles are
unknown are marked ???  Information that needs deeper inspection is marked (?)


\subsubsection{General form of a packet}
\label{input/devices/iforce-protocol:general-form-of-a-packet}
This is how packets look when the device uses the rs232 to communicate.

\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline

2B
 & 
OP
 & 
LEN
 & 
DATA
 & 
CS
\\
\hline\end{tabulary}


CS is the checksum. It is equal to the exclusive or of all bytes.

When using USB:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

OP
 & 
DATA
\\
\hline\end{tabulary}


The 2B, LEN and CS fields have disappeared, probably because USB handles
frames and data corruption is handled or unsignificant.

First, I describe effects that are sent by the device to the computer


\subsection{Device input state}
\label{input/devices/iforce-protocol:device-input-state}
This packet is used to indicate the state of each button and the value of each
axis:

\begin{Verbatim}[commandchars=\\\{\}]
OP= 01 for a joystick, 03 for a wheel
LEN= Varies from device to device
00 X\PYGZhy{}Axis lsb
01 X\PYGZhy{}Axis msb
02 Y\PYGZhy{}Axis lsb, or gas pedal for a wheel
03 Y\PYGZhy{}Axis msb, or brake pedal for a wheel
04 Throttle
05 Buttons
06 Lower 4 bits: Buttons
   Upper 4 bits: Hat
07 Rudder
\end{Verbatim}


\subsection{Device effects states}
\label{input/devices/iforce-protocol:device-effects-states}
\begin{Verbatim}[commandchars=\\\{\}]
OP= 02
LEN= Varies
00 ? Bit 1 (Value 2) is the value of the deadman switch
01 Bit 8 is set if the effect is playing. Bits 0 to 7 are the effect id.
02 ??
03 Address of parameter block changed (lsb)
04 Address of parameter block changed (msb)
05 Address of second parameter block changed (lsb)
... depending on the number of parameter blocks updated
\end{Verbatim}


\subsubsection{Force effect}
\label{input/devices/iforce-protocol:force-effect}
\begin{Verbatim}[commandchars=\\\{\}]
OP=  01
LEN= 0e
00 Channel (when playing several effects at the same time, each must
            be assigned a channel)
01 Wave form
        Val 00 Constant
        Val 20 Square
        Val 21 Triangle
        Val 22 Sine
        Val 23 Sawtooth up
        Val 24 Sawtooth down
        Val 40 Spring (Force = f(pos))
        Val 41 Friction (Force = f(velocity)) and Inertia
               (Force = f(acceleration))


02 Axes affected and trigger
        Bits 4\PYGZhy{}7: Val 2 = effect along one axis. Byte 05 indicates direction
                Val 4 = X axis only. Byte 05 must contain 5a
                Val 8 = Y axis only. Byte 05 must contain b4
                Val c = X and Y axes. Bytes 05 must contain 60
        Bits 0\PYGZhy{}3: Val 0 = No trigger
                Val x+1 = Button x triggers the effect
        When the whole byte is 0, cancel the previously set trigger

03\PYGZhy{}04 Duration of effect (little endian encoding, in ms)

05 Direction of effect, if applicable. Else, see 02 for value to assign.

06\PYGZhy{}07 Minimum time between triggering.

08\PYGZhy{}09 Address of periodicity or magnitude parameters
0a\PYGZhy{}0b Address of attack and fade parameters, or ffff if none.
*or*
08\PYGZhy{}09 Address of interactive parameters for X\PYGZhy{}axis,
      or ffff if not applicable
0a\PYGZhy{}0b Address of interactive parameters for Y\PYGZhy{}axis,
      or ffff if not applicable

0c\PYGZhy{}0d Delay before execution of effect (little endian encoding, in ms)
\end{Verbatim}


\subsubsection{Time based parameters}
\label{input/devices/iforce-protocol:time-based-parameters}

\paragraph{Attack and fade}
\label{input/devices/iforce-protocol:attack-and-fade}
\begin{Verbatim}[commandchars=\\\{\}]
OP=  02
LEN= 08
00\PYGZhy{}01 Address where to store the parameters
02\PYGZhy{}03 Duration of attack (little endian encoding, in ms)
04 Level at end of attack. Signed byte.
05\PYGZhy{}06 Duration of fade.
07 Level at end of fade.
\end{Verbatim}


\paragraph{Magnitude}
\label{input/devices/iforce-protocol:magnitude}
\begin{Verbatim}[commandchars=\\\{\}]
OP=  03
LEN= 03
00\PYGZhy{}01 Address
02 Level. Signed byte.
\end{Verbatim}


\paragraph{Periodicity}
\label{input/devices/iforce-protocol:periodicity}
\begin{Verbatim}[commandchars=\\\{\}]
OP=  04
LEN= 07
00\PYGZhy{}01 Address
02 Magnitude. Signed byte.
03 Offset. Signed byte.
04 Phase. Val 00 = 0 deg, Val 40 = 90 degs.
05\PYGZhy{}06 Period (little endian encoding, in ms)
\end{Verbatim}


\subsubsection{Interactive parameters}
\label{input/devices/iforce-protocol:interactive-parameters}
\begin{Verbatim}[commandchars=\\\{\}]
OP=  05
LEN= 0a
00\PYGZhy{}01 Address
02 Positive Coeff
03 Negative Coeff
04+05 Offset (center)
06+07 Dead band (Val 01F4 = 5000 (decimal))
08 Positive saturation (Val 0a = 1000 (decimal) Val 64 = 10000 (decimal))
09 Negative saturation
\end{Verbatim}

The encoding is a bit funny here: For coeffs, these are signed values. The
maximum value is 64 (100 decimal), the min is 9c.
For the offset, the minimum value is FE0C, the maximum value is 01F4.
For the deadband, the minimum value is 0, the max is 03E8.


\subsubsection{Controls}
\label{input/devices/iforce-protocol:controls}
\begin{Verbatim}[commandchars=\\\{\}]
OP=  41
LEN= 03
00 Channel
01 Start/Stop
        Val 00: Stop
        Val 01: Start and play once.
        Val 41: Start and play n times (See byte 02 below)
02 Number of iterations n.
\end{Verbatim}


\subsubsection{Init}
\label{input/devices/iforce-protocol:init}

\paragraph{Querying features}
\label{input/devices/iforce-protocol:querying-features}
\begin{Verbatim}[commandchars=\\\{\}]
OP=  ff
Query command. Length varies according to the query type.
The general format of this packet is:
ff 01 QUERY [INDEX] CHECKSUM
responses are of the same form:
FF LEN QUERY VALUE\PYGZus{}QUERIED CHECKSUM2
where LEN = 1 + length(VALUE\PYGZus{}QUERIED)
\end{Verbatim}


\subparagraph{Query ram size}
\label{input/devices/iforce-protocol:query-ram-size}
\begin{Verbatim}[commandchars=\\\{\}]
QUERY = 42 (\PYGZsq{}B\PYGZsq{}uffer size)
\end{Verbatim}

The device should reply with the same packet plus two additional bytes
containing the size of the memory:
ff 03 42 03 e8 CS would mean that the device has 1000 bytes of ram available.


\subparagraph{Query number of effects}
\label{input/devices/iforce-protocol:query-number-of-effects}
\begin{Verbatim}[commandchars=\\\{\}]
QUERY = 4e (\PYGZsq{}N\PYGZsq{}umber of effects)
\end{Verbatim}

The device should respond by sending the number of effects that can be played
at the same time (one byte)
ff 02 4e 14 CS would stand for 20 effects.


\subparagraph{Vendor's id}
\label{input/devices/iforce-protocol:vendor-s-id}
\begin{Verbatim}[commandchars=\\\{\}]
QUERY = 4d (\PYGZsq{}M\PYGZsq{}anufacturer)
\end{Verbatim}

Query the vendors'id (2 bytes)


\subparagraph{Product id}
\label{input/devices/iforce-protocol:product-id}
\begin{Verbatim}[commandchars=\\\{\}]
QUERY = 50 (\PYGZsq{}P\PYGZsq{}roduct)
\end{Verbatim}

Query the product id (2 bytes)


\subparagraph{Open device}
\label{input/devices/iforce-protocol:open-device}
\begin{Verbatim}[commandchars=\\\{\}]
QUERY = 4f (\PYGZsq{}O\PYGZsq{}pen)
\end{Verbatim}

No data returned.


\subparagraph{Close device}
\label{input/devices/iforce-protocol:close-device}
\begin{Verbatim}[commandchars=\\\{\}]
QUERY = 43 (\PYGZsq{}C\PYGZsq{})lose
\end{Verbatim}

No data returned.


\subparagraph{Query effect}
\label{input/devices/iforce-protocol:query-effect}
\begin{Verbatim}[commandchars=\\\{\}]
QUERY = 45 (\PYGZsq{}E\PYGZsq{})
\end{Verbatim}

Send effect type.
Returns nonzero if supported (2 bytes)


\subparagraph{Firmware Version}
\label{input/devices/iforce-protocol:firmware-version}
\begin{Verbatim}[commandchars=\\\{\}]
QUERY = 56 (\PYGZsq{}V\PYGZsq{}ersion)
\end{Verbatim}

Sends back 3 bytes - major, minor, subminor


\paragraph{Initialisation of the device}
\label{input/devices/iforce-protocol:initialisation-of-the-device}

\subparagraph{Set Control}
\label{input/devices/iforce-protocol:set-control}
\begin{notice}{note}{Note:}
Device dependent, can be different on different models!
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
OP=  40 \PYGZlt{}idx\PYGZgt{} \PYGZlt{}val\PYGZgt{} [\PYGZlt{}val\PYGZgt{}]
LEN= 2 or 3
00 Idx
   Idx 00 Set dead zone (0..2048)
   Idx 01 Ignore Deadman sensor (0..1)
   Idx 02 Enable comm watchdog (0..1)
   Idx 03 Set the strength of the spring (0..100)
   Idx 04 Enable or disable the spring (0/1)
   Idx 05 Set axis saturation threshold (0..2048)
\end{Verbatim}


\subparagraph{Set Effect State}
\label{input/devices/iforce-protocol:set-effect-state}
\begin{Verbatim}[commandchars=\\\{\}]
OP=  42 \PYGZlt{}val\PYGZgt{}
LEN= 1
00 State
   Bit 3 Pause force feedback
   Bit 2 Enable force feedback
   Bit 0 Stop all effects
\end{Verbatim}


\subparagraph{Set overall}
\label{input/devices/iforce-protocol:set-overall}
\begin{Verbatim}[commandchars=\\\{\}]
OP=  43 \PYGZlt{}val\PYGZgt{}
LEN= 1
00 Gain
   Val 00 = 0\PYGZpc{}
   Val 40 = 50\PYGZpc{}
   Val 80 = 100\PYGZpc{}
\end{Verbatim}


\subsubsection{Parameter memory}
\label{input/devices/iforce-protocol:parameter-memory}
Each device has a certain amount of memory to store parameters of effects.
The amount of RAM may vary, I encountered values from 200 to 1000 bytes. Below
is the amount of memory apparently needed for every set of parameters:
\begin{itemize}
\item {} 
period : 0c

\item {} 
magnitude : 02

\item {} 
attack and fade : 0e

\item {} 
interactive : 08

\end{itemize}


\subsection{Appendix: How to study the protocol?}
\label{input/devices/iforce-protocol:appendix-how-to-study-the-protocol}
1. Generate effects using the force editor provided with the DirectX SDK, or
use Immersion Studio (freely available at their web site in the developer section:
www.immersion.com)
2. Start a soft spying RS232 or USB (depending on where you connected your
joystick/wheel). I used ComPortSpy from fCoder (alpha version!)
3. Play the effect, and watch what happens on the spy screen.

A few words about ComPortSpy:
At first glance, this software seems, hum, well... buggy. In fact, data appear with a
few seconds latency. Personally, I restart it every time I play an effect.
Remember it's free (as in free beer) and alpha!


\subsection{URLS}
\label{input/devices/iforce-protocol:urls}
Check \href{http://www.immerse.com}{http://www.immerse.com} for Immersion Studio,
and \href{http://www.fcoder.com}{http://www.fcoder.com} for ComPortSpy.

I-Force is trademark of Immersion Corp.


\section{Parallel Port Joystick Drivers}
\label{input/devices/joystick-parport:parallel-port-joystick-drivers}\label{input/devices/joystick-parport::doc}\label{input/devices/joystick-parport:joystick-parport}\begin{quote}\begin{description}
\item[{Copyright}] \leavevmode
© 1998-2000 Vojtech Pavlik \textless{}\href{mailto:vojtech@ucw.cz}{vojtech@ucw.cz}\textgreater{}

\item[{Copyright}] \leavevmode
© 1998 Andree Borrmann \textless{}\href{mailto:a.borrmann@tu-bs.de}{a.borrmann@tu-bs.de}\textgreater{}

\end{description}\end{quote}

Sponsored by SuSE


\subsection{Disclaimer}
\label{input/devices/joystick-parport:disclaimer}
Any information in this file is provided as-is, without any guarantee that
it will be true. So, use it at your own risk. The possible damages that can
happen include burning your parallel port, and/or the sticks and joystick
and maybe even more. Like when a lightning kills you it is not our problem.


\subsection{Introduction}
\label{input/devices/joystick-parport:introduction}
The joystick parport drivers are used for joysticks and gamepads not
originally designed for PCs and other computers Linux runs on. Because of
that, PCs usually lack the right ports to connect these devices to. Parallel
port, because of its ability to change single bits at will, and providing
both output and input bits is the most suitable port on the PC for
connecting such devices.


\subsection{Devices supported}
\label{input/devices/joystick-parport:devices-supported}
Many console and 8-bit computer gamepads and joysticks are supported. The
following subsections discuss usage of each.


\subsubsection{NES and SNES}
\label{input/devices/joystick-parport:nes-and-snes}
The Nintendo Entertainment System and Super Nintendo Entertainment System
gamepads are widely available, and easy to get. Also, they are quite easy to
connect to a PC, and don't need much processing speed (108 us for NES and
165 us for SNES, compared to about 1000 us for PC gamepads) to communicate
with them.

All NES and SNES use the same synchronous serial protocol, clocked from
the computer's side (and thus timing insensitive). To allow up to 5 NES
and/or SNES gamepads and/or SNES mice connected to the parallel port at once,
the output lines of the parallel port are shared, while one of 5 available
input lines is assigned to each gamepad.

This protocol is handled by the gamecon.c driver, so that's the one
you'll use for NES, SNES gamepads and SNES mice.

The main problem with PC parallel ports is that they don't have +5V power
source on any of their pins. So, if you want a reliable source of power
for your pads, use either keyboard or joystick port, and make a pass-through
cable. You can also pull the power directly from the power supply (the red
wire is +5V).

If you want to use the parallel port only, you can take the power is from
some data pin. For most gamepad and parport implementations only one pin is
needed, and I'd recommend pin 9 for that, the highest data bit. On the other
hand, if you are not planning to use anything else than NES / SNES on the
port, anything between and including pin 4 and pin 9 will work:

\begin{Verbatim}[commandchars=\\\{\}]
(pin 9) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Power
\end{Verbatim}

Unfortunately, there are pads that need a lot more of power, and parallel
ports that can't give much current through the data pins. If this is your
case, you'll need to use diodes (as a prevention of destroying your parallel
port), and combine the currents of two or more data bits together:

\begin{Verbatim}[commandchars=\\\{\}]
          Diodes
(pin 9) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZgt{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Power
                    \textbar{}
(pin 8) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZgt{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
                    \textbar{}
(pin 7) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZgt{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
                    \textbar{}
\PYGZlt{}and so on\PYGZgt{}         :
                    \textbar{}
(pin 4) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZgt{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{Verbatim}

Ground is quite easy. On PC's parallel port the ground is on any of the
pins from pin 18 to pin 25. So use any pin of these you like for the ground:

\begin{Verbatim}[commandchars=\\\{\}]
(pin 18) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Ground
\end{Verbatim}

NES and SNES pads have two input bits, Clock and Latch, which drive the
serial transfer. These are connected to pins 2 and 3 of the parallel port,
respectively:

\begin{Verbatim}[commandchars=\\\{\}]
(pin 2) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Clock
(pin 3) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Latch
\end{Verbatim}

And the last thing is the NES / SNES data wire. Only that isn't shared and
each pad needs its own data pin. The parallel port pins are:

\begin{Verbatim}[commandchars=\\\{\}]
(pin 10) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Pad 1 data
(pin 11) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Pad 2 data
(pin 12) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Pad 3 data
(pin 13) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Pad 4 data
(pin 15) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Pad 5 data
\end{Verbatim}

Note that pin 14 is not used, since it is not an input pin on the parallel
port.

This is everything you need on the PC's side of the connection, now on to
the gamepads side. The NES and SNES have different connectors. Also, there
are quite a lot of NES clones, and because Nintendo used proprietary
connectors for their machines, the cloners couldn't and used standard D-Cannon
connectors. Anyway, if you've got a gamepad, and it has buttons A, B, Turbo
A, Turbo B, Select and Start, and is connected through 5 wires, then it is
either a NES or NES clone and will work with this connection. SNES gamepads
also use 5 wires, but have more buttons. They will work as well, of course:

\begin{Verbatim}[commandchars=\\\{\}]
Pinout for NES gamepads                 Pinout for SNES gamepads and mice

           +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Power                   +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZbs{}
           \textbar{}                            7 \textbar{} o  o  o  o \textbar{}  x  x  o  \textbar{} 1
 5 +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+  7                         +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}/
   \textbar{} x  x  o   \PYGZbs{}                            \textbar{}  \textbar{}  \textbar{}  \textbar{}          \textbar{}
   \textbar{} o  o  o  o \textbar{}                           \textbar{}  \textbar{}  \textbar{}  \textbar{}          +\PYGZhy{}\PYGZgt{} Ground
 4 +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+ 1                         \textbar{}  \textbar{}  \textbar{}  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Data
     \textbar{}  \textbar{}  \textbar{}  \textbar{}                             \textbar{}  \textbar{}  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Latch
     \textbar{}  \textbar{}  \textbar{}  +\PYGZhy{}\PYGZgt{} Ground                    \textbar{}  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Clock
     \textbar{}  \textbar{}  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Clock                     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Power
     \textbar{}  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Latch
     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Data

Pinout for NES clone (db9) gamepads     Pinout for NES clone (db15) gamepads

      +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Clock                    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Data
      \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Latch                    \textbar{}             +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Ground
      \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Data                     \textbar{}             \textbar{}
      \textbar{} \textbar{} \textbar{}                              \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
  \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}                        8 \PYGZbs{} o x x x x x x o / 1
5 \PYGZbs{} x o o o x / 1                         \PYGZbs{} o x x o x x o /
   \PYGZbs{} x o x o /                          15 {}`\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZsq{} 9
  9 {}`\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZsq{} 6                             \textbar{}     \textbar{}     \textbar{}
       \textbar{}   \textbar{}                                \textbar{}     \textbar{}     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Clock
       \textbar{}   +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Power                     \textbar{}     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Latch
       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Ground                    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Power
\end{Verbatim}


\subsubsection{Multisystem joysticks}
\label{input/devices/joystick-parport:multisystem-joysticks}
In the era of 8-bit machines, there was something like de-facto standard
for joystick ports. They were all digital, and all used D-Cannon 9 pin
connectors (db9). Because of that, a single joystick could be used without
hassle on Atari (130, 800XE, 800XL, 2600, 7200), Amiga, Commodore C64,
Amstrad CPC, Sinclair ZX Spectrum and many other machines. That's why these
joysticks are called ``Multisystem''.

Now their pinout:

\begin{Verbatim}[commandchars=\\\{\}]
      +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Right
      \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Left
      \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Down
      \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Up
      \textbar{} \textbar{} \textbar{} \textbar{}
  \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
5 \PYGZbs{} x o o o o / 1
   \PYGZbs{} x o x o /
  9 {}`\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZsq{} 6
       \textbar{}   \textbar{}
       \textbar{}   +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button
       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Ground
\end{Verbatim}

However, as time passed, extensions to this standard developed, and these
were not compatible with each other:

\begin{Verbatim}[commandchars=\\\{\}]
        Atari 130, 800/XL/XE                   MSX

                                         +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Power
      +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Right                  \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Right
      \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Left                   \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Left
      \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Down                   \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Down
      \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Up                     \textbar{} \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Up
      \textbar{} \textbar{} \textbar{} \textbar{}                            \textbar{} \textbar{} \textbar{} \textbar{} \textbar{}
  \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}                        \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
5 \PYGZbs{} x o o o o / 1                    5 \PYGZbs{} o o o o o / 1
   \PYGZbs{} x o o o /                          \PYGZbs{} o o o o /
  9 {}`\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZsq{} 6                        9 {}`\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZsq{} 6
       \textbar{} \textbar{} \textbar{}                              \textbar{} \textbar{} \textbar{} \textbar{}
       \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button                  \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 1
       \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Power                   \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 2
       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Ground                  \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Output 3
                                          +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Ground

        Amstrad CPC                           Commodore C64

                                         +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Analog Y
      +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Right                  \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Right
      \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Left                   \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Left
      \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Down                   \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Down
      \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Up                     \textbar{} \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Up
      \textbar{} \textbar{} \textbar{} \textbar{}                            \textbar{} \textbar{} \textbar{} \textbar{} \textbar{}
  \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}                        \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
5 \PYGZbs{} x o o o o / 1                    5 \PYGZbs{} o o o o o / 1
   \PYGZbs{} x o o o /                          \PYGZbs{} o o o o /
  9 {}`\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZsq{} 6                        9 {}`\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZsq{} 6
       \textbar{} \textbar{} \textbar{}                              \textbar{} \textbar{} \textbar{} \textbar{}
       \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 1                \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button
       \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 2                \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Power
       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Ground                  \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Ground
                                          +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Analog X

        Sinclair Spectrum +2A/+3           Amiga 1200

    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Up                     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 3
    \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Fire                   \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Right
    \textbar{} \textbar{}                                  \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Left
    \textbar{} \textbar{}   +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Ground                 \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Down
    \textbar{} \textbar{}   \textbar{}                              \textbar{} \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Up
    \textbar{} \textbar{}   \textbar{}                              \textbar{} \textbar{} \textbar{} \textbar{} \textbar{}
  \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}                        \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
5 \PYGZbs{} o o x o x / 1                    5 \PYGZbs{} o o o o o / 1
   \PYGZbs{} o o o o /                          \PYGZbs{} o o o o /
  9 {}`\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZsq{} 6                        9 {}`\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZsq{} 6
     \textbar{} \textbar{} \textbar{} \textbar{}                              \textbar{} \textbar{} \textbar{} \textbar{}
     \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Right                   \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 1
     \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Left                    \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Power
     \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Ground                  \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Ground
     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Down                    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 2

And there were many others.
\end{Verbatim}


\paragraph{Multisystem joysticks using db9.c}
\label{input/devices/joystick-parport:multisystem-joysticks-using-db9-c}
For the Multisystem joysticks, and their derivatives, the db9.c driver
was written. It allows only one joystick / gamepad per parallel port, but
the interface is easy to build and works with almost anything.

For the basic 1-button Multisystem joystick you connect its wires to the
parallel port like this:

\begin{Verbatim}[commandchars=\\\{\}]
(pin  1) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Power
(pin 18) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Ground

(pin  2) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Up
(pin  3) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Down
(pin  4) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Left
(pin  5) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Right
(pin  6) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 1
\end{Verbatim}

However, if the joystick is switch based (eg. clicks when you move it),
you might or might not, depending on your parallel port, need 10 kOhm pullup
resistors on each of the direction and button signals, like this:

\begin{Verbatim}[commandchars=\\\{\}]
(pin 2) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Up
          Resistor  \textbar{}
(pin 1) \PYGZhy{}\PYGZhy{}[10kOhm]\PYGZhy{}\PYGZhy{}+
\end{Verbatim}

Try without, and if it doesn't work, add them. For TTL based joysticks /
gamepads the pullups are not needed.

For joysticks with two buttons you connect the second button to pin 7 on
the parallel port:

\begin{Verbatim}[commandchars=\\\{\}]
(pin 7) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 2
\end{Verbatim}

And that's it.

On a side note, if you have already built a different adapter for use with
the digital joystick driver 0.8.0.2, this is also supported by the db9.c
driver, as device type 8. (See section 3.2)


\paragraph{Multisystem joysticks using gamecon.c}
\label{input/devices/joystick-parport:multisystem-joysticks-using-gamecon-c}
For some people just one joystick per parallel port is not enough, and/or
want to use them on one parallel port together with NES/SNES/PSX pads. This is
possible using the gamecon.c. It supports up to 5 devices of the above types,
including 1 and 2 buttons Multisystem joysticks.

However, there is nothing for free. To allow more sticks to be used at
once, you need the sticks to be purely switch based (that is non-TTL), and
not to need power. Just a plain simple six switches inside. If your
joystick can do more (eg. turbofire) you'll need to disable it totally first
if you want to use gamecon.c.

Also, the connection is a bit more complex. You'll need a bunch of diodes,
and one pullup resistor. First, you connect the Directions and the button
the same as for db9, however with the diodes between:

\begin{Verbatim}[commandchars=\\\{\}]
            Diodes
(pin 2) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZlt{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Up
(pin 3) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZlt{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Down
(pin 4) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZlt{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Left
(pin 5) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZlt{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Right
(pin 6) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZlt{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 1
\end{Verbatim}

For two button sticks you also connect the other button:

\begin{Verbatim}[commandchars=\\\{\}]
(pin 7) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}\PYGZlt{}\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 2
\end{Verbatim}

And finally, you connect the Ground wire of the joystick, like done in
this little schematic to Power and Data on the parallel port, as described
for the NES / SNES pads in section 2.1 of this file - that is, one data pin
for each joystick. The power source is shared:

\begin{Verbatim}[commandchars=\\\{\}]
Data    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Ground
          Resistor  \textbar{}
Power   \PYGZhy{}\PYGZhy{}[10kOhm]\PYGZhy{}\PYGZhy{}+
\end{Verbatim}

And that's all, here we go!


\paragraph{Multisystem joysticks using turbografx.c}
\label{input/devices/joystick-parport:multisystem-joysticks-using-turbografx-c}
The TurboGraFX interface, designed by
\begin{quote}

Steffen Schwenke \textless{}\href{mailto:schwenke@burg-halle.de}{schwenke@burg-halle.de}\textgreater{}
\end{quote}

allows up to 7 Multisystem joysticks connected to the parallel port. In
Steffen's version, there is support for up to 5 buttons per joystick.  However,
since this doesn't work reliably on all parallel ports, the turbografx.c driver
supports only one button per joystick. For more information on how to build the
interface, see:
\begin{quote}

\href{http://www2.burg-halle.de/~schwenke/parport.html}{http://www2.burg-halle.de/\textasciitilde{}schwenke/parport.html}
\end{quote}


\subsubsection{Sony Playstation}
\label{input/devices/joystick-parport:sony-playstation}
The PSX controller is supported by the gamecon.c. Pinout of the PSX
controller (compatible with DirectPadPro):

\begin{Verbatim}[commandchars=\\\{\}]
  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
9 \textbar{} o  o  o \textbar{} o  o  o \textbar{} o  o  o \textbar{} 1               parallel
   \PYGZbs{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}/                  port pins
    \textbar{}  \textbar{}      \textbar{}  \textbar{}  \textbar{}   \textbar{}
    \textbar{}  \textbar{}      \textbar{}  \textbar{}  \textbar{}   +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}  Clock    \PYGZhy{}\PYGZhy{}\PYGZhy{}  (4)
    \textbar{}  \textbar{}      \textbar{}  \textbar{}  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}  Select   \PYGZhy{}\PYGZhy{}\PYGZhy{}  (3)
    \textbar{}  \textbar{}      \textbar{}  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}  Power    \PYGZhy{}\PYGZhy{}\PYGZhy{}  (5\PYGZhy{}9)
    \textbar{}  \textbar{}      +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}  Ground   \PYGZhy{}\PYGZhy{}\PYGZhy{}  (18\PYGZhy{}25)
    \textbar{}  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}  Command  \PYGZhy{}\PYGZhy{}\PYGZhy{}  (2)
    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}  Data     \PYGZhy{}\PYGZhy{}\PYGZhy{}  (one of 10,11,12,13,15)
\end{Verbatim}

The driver supports these controllers:
\begin{itemize}
\item {} 
Standard PSX Pad

\item {} 
NegCon PSX Pad

\item {} 
Analog PSX Pad (red mode)

\item {} 
Analog PSX Pad (green mode)

\item {} 
PSX Rumble Pad

\item {} 
PSX DDR Pad

\end{itemize}


\subsubsection{Sega}
\label{input/devices/joystick-parport:sega}
All the Sega controllers are more or less based on the standard 2-button
Multisystem joystick. However, since they don't use switches and use TTL
logic, the only driver usable with them is the db9.c driver.


\paragraph{Sega Master System}
\label{input/devices/joystick-parport:sega-master-system}
The SMS gamepads are almost exactly the same as normal 2-button
Multisystem joysticks. Set the driver to Multi2 mode, use the corresponding
parallel port pins, and the following schematic:

\begin{Verbatim}[commandchars=\\\{\}]
    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Power
    \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Right
    \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Left
    \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Down
    \textbar{} \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Up
    \textbar{} \textbar{} \textbar{} \textbar{} \textbar{}
  \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
5 \PYGZbs{} o o o o o / 1
   \PYGZbs{} o o x o /
  9 {}`\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZsq{} 6
     \textbar{} \textbar{}   \textbar{}
     \textbar{} \textbar{}   +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 1
     \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Ground
     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 2
\end{Verbatim}


\paragraph{Sega Genesis aka MegaDrive}
\label{input/devices/joystick-parport:sega-genesis-aka-megadrive}
The Sega Genesis (in Europe sold as Sega MegaDrive) pads are an extension
to the Sega Master System pads. They use more buttons (3+1, 5+1, 6+1).  Use
the following schematic:

\begin{Verbatim}[commandchars=\\\{\}]
    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Power
    \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Right
    \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Left
    \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Down
    \textbar{} \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Up
    \textbar{} \textbar{} \textbar{} \textbar{} \textbar{}
  \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
5 \PYGZbs{} o o o o o / 1
   \PYGZbs{} o o o o /
  9 {}`\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZsq{} 6
    \textbar{} \textbar{} \textbar{} \textbar{}
    \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 1
    \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Select
    \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Ground
    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 2
\end{Verbatim}

The Select pin goes to pin 14 on the parallel port:

\begin{Verbatim}[commandchars=\\\{\}]
(pin 14) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Select
\end{Verbatim}

The rest is the same as for Multi2 joysticks using db9.c


\paragraph{Sega Saturn}
\label{input/devices/joystick-parport:sega-saturn}
Sega Saturn has eight buttons, and to transfer that, without hacks like
Genesis 6 pads use, it needs one more select pin. Anyway, it is still
handled by the db9.c driver. Its pinout is very different from anything
else.  Use this schematic:

\begin{Verbatim}[commandchars=\\\{\}]
    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Select 1
    \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Power
    \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Up
    \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Down
    \textbar{} \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Ground
    \textbar{} \textbar{} \textbar{} \textbar{} \textbar{}
  \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
5 \PYGZbs{} o o o o o / 1
   \PYGZbs{} o o o o /
  9 {}`\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZsq{} 6
     \textbar{} \textbar{} \textbar{} \textbar{}
     \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Select 2
     \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Right
     \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Left
     +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Power
\end{Verbatim}

Select 1 is pin 14 on the parallel port, Select 2 is pin 16 on the
parallel port:

\begin{Verbatim}[commandchars=\\\{\}]
(pin 14) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Select 1
(pin 16) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Select 2
\end{Verbatim}

The other pins (Up, Down, Right, Left, Power, Ground) are the same as for
Multi joysticks using db9.c


\subsubsection{Amiga CD32}
\label{input/devices/joystick-parport:amiga-cd32}
Amiga CD32 joypad uses the following pinout:

\begin{Verbatim}[commandchars=\\\{\}]
    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 3
    \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Right
    \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Left
    \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Down
    \textbar{} \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Up
    \textbar{} \textbar{} \textbar{} \textbar{} \textbar{}
  \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
5 \PYGZbs{} o o o o o / 1
   \PYGZbs{} o o o o /
  9 {}`\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZsq{} 6
    \textbar{} \textbar{} \textbar{} \textbar{}
    \textbar{} \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 1
    \textbar{} \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Power
    \textbar{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Ground
    +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Button 2
\end{Verbatim}

It can be connected to the parallel port and driven by db9.c driver. It needs the following wiring:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
CD32 pad
} & \textsf{\relax 
Parallel port
}\\
\hline
1 (Up)
 & 
2 (D0)
\\
\hline
2 (Down)
 & 
3 (D1)
\\
\hline
3 (Left)
 & 
4 (D2)
\\
\hline
4 (Right)
 & 
5 (D3)
\\
\hline
5 (Button 3)
 & 
14 (AUTOFD)
\\
\hline
6 (Button 1)
 & 
17 (SELIN)
\\
\hline
7 (+5V)
 & 
1 (STROBE)
\\
\hline
8 (Gnd)
 & 
18 (Gnd)
\\
\hline
9 (Button 2)
 & 
7 (D5)
\\
\hline\end{tabulary}

\end{quote}


\subsection{The drivers}
\label{input/devices/joystick-parport:the-drivers}
There are three drivers for the parallel port interfaces. Each, as
described above, allows to connect a different group of joysticks and pads.
Here are described their command lines:


\subsubsection{gamecon.c}
\label{input/devices/joystick-parport:gamecon-c}
Using gamecon.c you can connect up to five devices to one parallel port. It
uses the following kernel/module command line:

\begin{Verbatim}[commandchars=\\\{\}]
gamecon.map=port,pad1,pad2,pad3,pad4,pad5
\end{Verbatim}

Where \code{port} the number of the parport interface (eg. 0 for parport0).

And \code{pad1} to \code{pad5} are pad types connected to different data input pins
(10,11,12,13,15), as described in section 2.1 of this file.

The types are:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Type
} & \textsf{\relax 
Joystick/Pad
}\\
\hline
0
 & 
None
\\
\hline
1
 & 
SNES pad
\\
\hline
2
 & 
NES pad
\\
\hline
4
 & 
Multisystem 1-button joystick
\\
\hline
5
 & 
Multisystem 2-button joystick
\\
\hline
6
 & 
N64 pad
\\
\hline
7
 & 
Sony PSX controller
\\
\hline
8
 & 
Sony PSX DDR controller
\\
\hline
9
 & 
SNES mouse
\\
\hline\end{tabulary}

\end{quote}

The exact type of the PSX controller type is autoprobed when used, so
hot swapping should work (but is not recommended).

Should you want to use more than one of parallel ports at once, you can use
gamecon.map2 and gamecon.map3 as additional command line parameters for two
more parallel ports.

There are two options specific to PSX driver portion.  gamecon.psx\_delay sets
the command delay when talking to the controllers. The default of 25 should
work but you can try lowering it for better performance. If your pads don't
respond try raising it until they work. Setting the type to 8 allows the
driver to be used with Dance Dance Revolution or similar games. Arrow keys are
registered as key presses instead of X and Y axes.


\subsubsection{db9.c}
\label{input/devices/joystick-parport:db9-c}
Apart from making an interface, there is nothing difficult on using the
db9.c driver. It uses the following kernel/module command line:

\begin{Verbatim}[commandchars=\\\{\}]
db9.dev=port,type
\end{Verbatim}

Where \code{port} is the number of the parport interface (eg. 0 for parport0).

Caveat here: This driver only works on bidirectional parallel ports. If
your parallel port is recent enough, you should have no trouble with this.
Old parallel ports may not have this feature.

\code{Type} is the type of joystick or pad attached:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Type
} & \textsf{\relax 
Joystick/Pad
}\\
\hline
0
 & 
None
\\
\hline
1
 & 
Multisystem 1-button joystick
\\
\hline
2
 & 
Multisystem 2-button joystick
\\
\hline
3
 & 
Genesis pad (3+1 buttons)
\\
\hline
5
 & 
Genesis pad (5+1 buttons)
\\
\hline
6
 & 
Genesis pad (6+2 buttons)
\\
\hline
7
 & 
Saturn pad (8 buttons)
\\
\hline
8
 & 
Multisystem 1-button joystick (v0.8.0.2 pin-out)
\\
\hline
9
 & 
Two Multisystem 1-button joysticks (v0.8.0.2 pin-out)
\\
\hline
10
 & 
Amiga CD32 pad
\\
\hline\end{tabulary}

\end{quote}

Should you want to use more than one of these joysticks/pads at once, you
can use db9.dev2 and db9.dev3 as additional command line parameters for two
more joysticks/pads.


\subsubsection{turbografx.c}
\label{input/devices/joystick-parport:turbografx-c}
The turbografx.c driver uses a very simple kernel/module command line:

\begin{Verbatim}[commandchars=\\\{\}]
turbografx.map=port,js1,js2,js3,js4,js5,js6,js7
\end{Verbatim}

Where \code{port} is the number of the parport interface (eg. 0 for parport0).

\code{jsX} is the number of buttons the Multisystem joysticks connected to the
interface ports 1-7 have. For a standard multisystem joystick, this is 1.

Should you want to use more than one of these interfaces at once, you can
use turbografx.map2 and turbografx.map3 as additional command line parameters
for two more interfaces.


\subsection{PC parallel port pinout}
\label{input/devices/joystick-parport:pc-parallel-port-pinout}
\begin{Verbatim}[commandchars=\\\{\}]
               .\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}.
At the PC:     \PYGZbs{} 13 12 11 10  9  8  7  6  5  4  3  2  1 /
                \PYGZbs{}  25 24 23 22 21 20 19 18 17 16 15 14 /
                  \PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}
\end{Verbatim}

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Pin
} & \textsf{\relax 
Name
} & \textsf{\relax 
Description
}\\
\hline
1
 & 
/STROBE
 & 
Strobe
\\
\hline
2-9
 & 
D0-D7
 & 
Data Bit 0-7
\\
\hline
10
 & 
/ACK
 & 
Acknowledge
\\
\hline
11
 & 
BUSY
 & 
Busy
\\
\hline
12
 & 
PE
 & 
Paper End
\\
\hline
13
 & 
SELIN
 & 
Select In
\\
\hline
14
 & 
/AUTOFD
 & 
Autofeed
\\
\hline
15
 & 
/ERROR
 & 
Error
\\
\hline
16
 & 
/INIT
 & 
Initialize
\\
\hline
17
 & 
/SEL
 & 
Select
\\
\hline
18-25
 & 
GND
 & 
Signal Ground
\\
\hline\end{tabulary}


That's all, folks! Have fun!


\section{N-Trig touchscreen Driver}
\label{input/devices/ntrig::doc}\label{input/devices/ntrig:n-trig-touchscreen-driver}\begin{quote}\begin{description}
\item[{Copyright}] \leavevmode
© 2008-2010 Rafi Rubin \textless{}\href{mailto:rafi@seas.upenn.edu}{rafi@seas.upenn.edu}\textgreater{}

\item[{Copyright}] \leavevmode
© 2009-2010 Stephane Chatty

\end{description}\end{quote}

This driver provides support for N-Trig pen and multi-touch sensors.  Single
and multi-touch events are translated to the appropriate protocols for
the hid and input systems.  Pen events are sufficiently hid compliant and
are left to the hid core.  The driver also provides additional filtering
and utility functions accessible with sysfs and module parameters.

This driver has been reported to work properly with multiple N-Trig devices
attached.


\subsection{Parameters}
\label{input/devices/ntrig:parameters}
Note: values set at load time are global and will apply to all applicable
devices.  Adjusting parameters with sysfs will override the load time values,
but only for that one device.

The following parameters are used to configure filters to reduce noise:

\begin{tabulary}{\linewidth}{|L|L|}
\hline

activate\_slack
 & 
number of fingers to ignore before processing events
\\
\hline
activation\_height,
activation\_width
 & 
size threshold to activate immediately
\\
\hline
min\_height,
min\_width
 & 
size threshold bellow which fingers are ignored
both to decide activation and during activity
\\
\hline
deactivate\_slack
 & 
the number of ``no contact'' frames to ignore before
propagating the end of activity events
\\
\hline\end{tabulary}


When the last finger is removed from the device, it sends a number of empty
frames.  By holding off on deactivation for a few frames we can tolerate false
erroneous disconnects, where the sensor may mistakenly not detect a finger that
is still present.  Thus deactivate\_slack addresses problems where a users might
see breaks in lines during drawing, or drop an object during a long drag.


\subsection{Additional sysfs items}
\label{input/devices/ntrig:additional-sysfs-items}
These nodes just provide easy access to the ranges reported by the device.

\begin{tabulary}{\linewidth}{|L|L|}
\hline

sensor\_logical\_height,
sensor\_logical\_width
 & 
the range for positions reported during activity
\\
\hline
sensor\_physical\_height,
sensor\_physical\_width
 & 
internal ranges not used for normal events but
useful for tuning
\\
\hline\end{tabulary}


All N-Trig devices with product id of 1 report events in the ranges of
\begin{itemize}
\item {} 
X: 0-9600

\item {} 
Y: 0-7200

\end{itemize}

However not all of these devices have the same physical dimensions.  Most
seem to be 12'' sensors (Dell Latitude XT and XT2 and the HP TX2), and
at least one model (Dell Studio 17) has a 17'' sensor.  The ratio of physical
to logical sizes is used to adjust the size based filter parameters.


\subsection{Filtering}
\label{input/devices/ntrig:filtering}
With the release of the early multi-touch firmwares it became increasingly
obvious that these sensors were prone to erroneous events.  Users reported
seeing both inappropriately dropped contact and ghosts, contacts reported
where no finger was actually touching the screen.

Deactivation slack helps prevent dropped contact for single touch use, but does
not address the problem of dropping one of more contacts while other contacts
are still active.  Drops in the multi-touch context require additional
processing and should be handled in tandem with tacking.

As observed ghost contacts are similar to actual use of the sensor, but they
seem to have different profiles.  Ghost activity typically shows up as small
short lived touches.  As such, I assume that the longer the continuous stream
of events the more likely those events are from a real contact, and that the
larger the size of each contact the more likely it is real.  Balancing the
goals of preventing ghosts and accepting real events quickly (to minimize
user observable latency), the filter accumulates confidence for incoming
events until it hits thresholds and begins propagating.  In the interest in
minimizing stored state as well as the cost of operations to make a decision,
I've kept that decision simple.

Time is measured in terms of the number of fingers reported, not frames since
the probability of multiple simultaneous ghosts is expected to drop off
dramatically with increasing numbers.  Rather than accumulate weight as a
function of size, I just use it as a binary threshold.  A sufficiently large
contact immediately overrides the waiting period and leads to activation.

Setting the activation size thresholds to large values will result in deciding
primarily on activation slack.  If you see longer lived ghosts, turning up the
activation slack while reducing the size thresholds may suffice to eliminate
the ghosts while keeping the screen quite responsive to firm taps.

Contacts continue to be filtered with min\_height and min\_width even after
the initial activation filter is satisfied.  The intent is to provide
a mechanism for filtering out ghosts in the form of an extra finger while
you actually are using the screen.  In practice this sort of ghost has
been far less problematic or relatively rare and I've left the defaults
set to 0 for both parameters, effectively turning off that filter.

I don't know what the optimal values are for these filters.  If the defaults
don't work for you, please play with the parameters.  If you do find other
values more comfortable, I would appreciate feedback.

The calibration of these devices does drift over time.  If ghosts or contact
dropping worsen and interfere with the normal usage of your device, try
recalibrating it.


\subsection{Calibration}
\label{input/devices/ntrig:calibration}
The N-Trig windows tools provide calibration and testing routines.  Also an
unofficial unsupported set of user space tools including a calibrator is
available at:
\href{http://code.launchpad.net/~rafi-seas/+junk/ntrig\_calib}{http://code.launchpad.net/\textasciitilde{}rafi-seas/+junk/ntrig\_calib}


\subsection{Tracking}
\label{input/devices/ntrig:tracking}
As of yet, all tested N-Trig firmwares do not track fingers.  When multiple
contacts are active they seem to be sorted primarily by Y position.


\section{rotary-encoder - a generic driver for GPIO connected devices}
\label{input/devices/rotary-encoder::doc}\label{input/devices/rotary-encoder:rotary-encoder-a-generic-driver-for-gpio-connected-devices}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Daniel Mack \textless{}\href{mailto:daniel@caiaq.de}{daniel@caiaq.de}\textgreater{}, Feb 2009

\end{description}\end{quote}


\subsection{Function}
\label{input/devices/rotary-encoder:function}
Rotary encoders are devices which are connected to the CPU or other
peripherals with two wires. The outputs are phase-shifted by 90 degrees
and by triggering on falling and rising edges, the turn direction can
be determined.

Some encoders have both outputs low in stable states, others also have
a stable state with both outputs high (half-period mode) and some have
a stable state in all steps (quarter-period mode).

The phase diagram of these two outputs look like this:

\begin{Verbatim}[commandchars=\\\{\}]
                \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}       \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}       \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
               \textbar{}     \textbar{}     \textbar{}     \textbar{}     \textbar{}     \textbar{}
Channel A  \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}     \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}     \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}     \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}

               :  :  :  :  :  :  :  :  :  :  :  :
          \PYGZus{}\PYGZus{}       \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}       \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}       \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
            \textbar{}     \textbar{}     \textbar{}     \textbar{}     \textbar{}     \textbar{}     \textbar{}
Channel B   \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}     \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}     \textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}     \textbar{}\PYGZus{}\PYGZus{}

               :  :  :  :  :  :  :  :  :  :  :  :
Event          a  b  c  d  a  b  c  d  a  b  c  d

              \textbar{}\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}\textbar{}
                one step

              \textbar{}\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZgt{}\textbar{}
                one step (half\PYGZhy{}period mode)

              \textbar{}\PYGZlt{}\PYGZgt{}\textbar{}
                one step (quarter\PYGZhy{}period mode)
\end{Verbatim}
\begin{description}
\item[{For more information, please see}] \leavevmode
\href{https://en.wikipedia.org/wiki/Rotary\_encoder}{https://en.wikipedia.org/wiki/Rotary\_encoder}

\end{description}


\subsection{Events / state machine}
\label{input/devices/rotary-encoder:events-state-machine}
In half-period mode, state a) and c) above are used to determine the
rotational direction based on the last stable state. Events are reported in
states b) and d) given that the new stable state is different from the last
(i.e. the rotation was not reversed half-way).

Otherwise, the following apply:
\begin{enumerate}
\item {} \begin{description}
\item[{Rising edge on channel A, channel B in low state}] \leavevmode
This state is used to recognize a clockwise turn

\end{description}

\item {} \begin{description}
\item[{Rising edge on channel B, channel A in high state}] \leavevmode
When entering this state, the encoder is put into `armed' state,
meaning that there it has seen half the way of a one-step transition.

\end{description}

\item {} \begin{description}
\item[{Falling edge on channel A, channel B in high state}] \leavevmode
This state is used to recognize a counter-clockwise turn

\end{description}

\item {} \begin{description}
\item[{Falling edge on channel B, channel A in low state}] \leavevmode
Parking position. If the encoder enters this state, a full transition
should have happened, unless it flipped back on half the way. The
`armed' state tells us about that.

\end{description}

\end{enumerate}


\subsection{Platform requirements}
\label{input/devices/rotary-encoder:platform-requirements}
As there is no hardware dependent call in this driver, the platform it is
used with must support gpiolib. Another requirement is that IRQs must be
able to fire on both edges.


\subsection{Board integration}
\label{input/devices/rotary-encoder:board-integration}
To use this driver in your system, register a platform\_device with the
name `rotary-encoder' and associate the IRQs and some specific platform
data with it. Because the driver uses generic device properties, this can
be done either via device tree, ACPI, or using static board files, like in
example below:

\begin{Verbatim}[commandchars=\\\{\}]
/* board support file example */

\PYGZsh{}include \PYGZlt{}linux/input.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}linux/gpio/machine.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}linux/property.h\PYGZgt{}

\PYGZsh{}define GPIO\PYGZus{}ROTARY\PYGZus{}A 1
\PYGZsh{}define GPIO\PYGZus{}ROTARY\PYGZus{}B 2

static struct gpiod\PYGZus{}lookup\PYGZus{}table rotary\PYGZus{}encoder\PYGZus{}gpios = \PYGZob{}
        .dev\PYGZus{}id = \PYGZdq{}rotary\PYGZhy{}encoder.0\PYGZdq{},
        .table = \PYGZob{}
                GPIO\PYGZus{}LOOKUP\PYGZus{}IDX(\PYGZdq{}gpio\PYGZhy{}0\PYGZdq{},
                                GPIO\PYGZus{}ROTARY\PYGZus{}A, NULL, 0, GPIO\PYGZus{}ACTIVE\PYGZus{}LOW),
                GPIO\PYGZus{}LOOKUP\PYGZus{}IDX(\PYGZdq{}gpio\PYGZhy{}0\PYGZdq{},
                                GPIO\PYGZus{}ROTARY\PYGZus{}B, NULL, 1, GPIO\PYGZus{}ACTIVE\PYGZus{}HIGH),
                \PYGZob{} \PYGZcb{},
        \PYGZcb{},
\PYGZcb{};

static const struct property\PYGZus{}entry rotary\PYGZus{}encoder\PYGZus{}properties[] \PYGZus{}\PYGZus{}initconst = \PYGZob{}
        PROPERTY\PYGZus{}ENTRY\PYGZus{}U32(\PYGZdq{}rotary\PYGZhy{}encoder,steps\PYGZhy{}per\PYGZhy{}period\PYGZdq{}, 24),
        PROPERTY\PYGZus{}ENTRY\PYGZus{}U32(\PYGZdq{}linux,axis\PYGZdq{},                      ABS\PYGZus{}X),
        PROPERTY\PYGZus{}ENTRY\PYGZus{}U32(\PYGZdq{}rotary\PYGZhy{}encoder,relative\PYGZus{}axis\PYGZdq{},    0),
        \PYGZob{} \PYGZcb{},
\PYGZcb{};

static struct platform\PYGZus{}device rotary\PYGZus{}encoder\PYGZus{}device = \PYGZob{}
        .name           = \PYGZdq{}rotary\PYGZhy{}encoder\PYGZdq{},
        .id             = 0,
\PYGZcb{};

...

gpiod\PYGZus{}add\PYGZus{}lookup\PYGZus{}table(\PYGZam{}rotary\PYGZus{}encoder\PYGZus{}gpios);
device\PYGZus{}add\PYGZus{}properties(\PYGZam{}rotary\PYGZus{}encoder\PYGZus{}device, rotary\PYGZus{}encoder\PYGZus{}properties);
platform\PYGZus{}device\PYGZus{}register(\PYGZam{}rotary\PYGZus{}encoder\PYGZus{}device);

...
\end{Verbatim}

Please consult device tree binding documentation to see all properties
supported by the driver.


\section{Sentelic Touchpad}
\label{input/devices/sentelic::doc}\label{input/devices/sentelic:sentelic-touchpad}\begin{quote}\begin{description}
\item[{Copyright}] \leavevmode
© 2002-2011 Sentelic Corporation.

\item[{Last update}] \leavevmode
Dec-07-2011

\end{description}\end{quote}


\subsection{Finger Sensing Pad Intellimouse Mode (scrolling wheel, 4th and 5th buttons)}
\label{input/devices/sentelic:finger-sensing-pad-intellimouse-mode-scrolling-wheel-4th-and-5th-buttons}\begin{enumerate}
\item {} 
MSID 4: Scrolling wheel mode plus Forward page(4th button) and Backward
page (5th button)

\end{enumerate}
\begin{enumerate}
\item {} 
Set sample rate to 200;

\item {} 
Set sample rate to 200;

\item {} 
Set sample rate to 80;

\item {} 
Issuing the ``Get device ID'' command (0xF2) and waits for the response;

\item {} 
FSP will respond 0x04.

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
Packet 1
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
  1   \textbar{}Y\textbar{}X\textbar{}y\textbar{}x\textbar{}1\textbar{}M\textbar{}R\textbar{}L\textbar{}  2  \textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}  3 \textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}  4 \textbar{} \textbar{} \textbar{}B\textbar{}F\textbar{}W\textbar{}W\textbar{}W\textbar{}W\textbar{}
      \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}

Byte 1: Bit7 =\PYGZgt{} Y overflow
        Bit6 =\PYGZgt{} X overflow
        Bit5 =\PYGZgt{} Y sign bit
        Bit4 =\PYGZgt{} X sign bit
        Bit3 =\PYGZgt{} 1
        Bit2 =\PYGZgt{} Middle Button, 1 is pressed, 0 is not pressed.
        Bit1 =\PYGZgt{} Right Button, 1 is pressed, 0 is not pressed.
        Bit0 =\PYGZgt{} Left Button, 1 is pressed, 0 is not pressed.
Byte 2: X Movement(9\PYGZhy{}bit 2\PYGZsq{}s complement integers)
Byte 3: Y Movement(9\PYGZhy{}bit 2\PYGZsq{}s complement integers)
Byte 4: Bit3\PYGZti{}Bit0 =\PYGZgt{} the scrolling wheel\PYGZsq{}s movement since the last data report.
                    valid values, \PYGZhy{}8 \PYGZti{} +7
        Bit4 =\PYGZgt{} 1 = 4th mouse button is pressed, Forward one page.
                0 = 4th mouse button is not pressed.
        Bit5 =\PYGZgt{} 1 = 5th mouse button is pressed, Backward one page.
                0 = 5th mouse button is not pressed.
\end{Verbatim}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
MSID 6: Horizontal and Vertical scrolling

\end{enumerate}
\begin{itemize}
\item {} 
Set bit 1 in register 0x40 to 1

\end{itemize}

FSP replaces scrolling wheel's movement as 4 bits to show horizontal and
vertical scrolling.

\begin{Verbatim}[commandchars=\\\{\}]
Packet 1
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
  1   \textbar{}Y\textbar{}X\textbar{}y\textbar{}x\textbar{}1\textbar{}M\textbar{}R\textbar{}L\textbar{}  2  \textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}  3 \textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}  4 \textbar{} \textbar{} \textbar{}B\textbar{}F\textbar{}r\textbar{}l\textbar{}u\textbar{}d\textbar{}
      \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}

Byte 1: Bit7 =\PYGZgt{} Y overflow
        Bit6 =\PYGZgt{} X overflow
        Bit5 =\PYGZgt{} Y sign bit
        Bit4 =\PYGZgt{} X sign bit
        Bit3 =\PYGZgt{} 1
        Bit2 =\PYGZgt{} Middle Button, 1 is pressed, 0 is not pressed.
        Bit1 =\PYGZgt{} Right Button, 1 is pressed, 0 is not pressed.
        Bit0 =\PYGZgt{} Left Button, 1 is pressed, 0 is not pressed.
Byte 2: X Movement(9\PYGZhy{}bit 2\PYGZsq{}s complement integers)
Byte 3: Y Movement(9\PYGZhy{}bit 2\PYGZsq{}s complement integers)
Byte 4: Bit0 =\PYGZgt{} the Vertical scrolling movement downward.
        Bit1 =\PYGZgt{} the Vertical scrolling movement upward.
        Bit2 =\PYGZgt{} the Horizontal scrolling movement leftward.
        Bit3 =\PYGZgt{} the Horizontal scrolling movement rightward.
        Bit4 =\PYGZgt{} 1 = 4th mouse button is pressed, Forward one page.
                0 = 4th mouse button is not pressed.
        Bit5 =\PYGZgt{} 1 = 5th mouse button is pressed, Backward one page.
                0 = 5th mouse button is not pressed.
\end{Verbatim}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
MSID 7

\end{enumerate}

FSP uses 2 packets (8 Bytes) to represent Absolute Position.
so we have PACKET NUMBER to identify packets.
\begin{quote}

If PACKET NUMBER is 0, the packet is Packet 1.
If PACKET NUMBER is 1, the packet is Packet 2.
Please count this number in program.
\end{quote}

MSID6 special packet will be enable at the same time when enable MSID 7.


\subsection{Absolute position for STL3886-G0}
\label{input/devices/sentelic:absolute-position-for-stl3886-g0}\begin{enumerate}
\item {} 
Set bit 2 or 3 in register 0x40 to 1

\item {} 
Set bit 6 in register 0x40 to 1

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
Packet 1 (ABSOLUTE POSITION)
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
  1   \textbar{}0\textbar{}1\textbar{}V\textbar{}1\textbar{}1\textbar{}M\textbar{}R\textbar{}L\textbar{}  2  \textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}  3 \textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}  4 \textbar{}r\textbar{}l\textbar{}d\textbar{}u\textbar{}X\textbar{}X\textbar{}Y\textbar{}Y\textbar{}
      \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}

Byte 1: Bit7\PYGZti{}Bit6 =\PYGZgt{} 00, Normal data packet
                =\PYGZgt{} 01, Absolute coordination packet
                =\PYGZgt{} 10, Notify packet
        Bit5 =\PYGZgt{} valid bit
        Bit4 =\PYGZgt{} 1
        Bit3 =\PYGZgt{} 1
        Bit2 =\PYGZgt{} Middle Button, 1 is pressed, 0 is not pressed.
        Bit1 =\PYGZgt{} Right Button, 1 is pressed, 0 is not pressed.
        Bit0 =\PYGZgt{} Left Button, 1 is pressed, 0 is not pressed.
Byte 2: X coordinate (xpos[9:2])
Byte 3: Y coordinate (ypos[9:2])
Byte 4: Bit1\PYGZti{}Bit0 =\PYGZgt{} Y coordinate (xpos[1:0])
        Bit3\PYGZti{}Bit2 =\PYGZgt{} X coordinate (ypos[1:0])
        Bit4 =\PYGZgt{} scroll up
        Bit5 =\PYGZgt{} scroll down
        Bit6 =\PYGZgt{} scroll left
        Bit7 =\PYGZgt{} scroll right

Notify Packet for G0
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
  1   \textbar{}1\textbar{}0\textbar{}0\textbar{}1\textbar{}1\textbar{}M\textbar{}R\textbar{}L\textbar{}  2  \textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}  3 \textbar{}M\textbar{}M\textbar{}M\textbar{}M\textbar{}M\textbar{}M\textbar{}M\textbar{}M\textbar{}  4 \textbar{}0\textbar{}0\textbar{}0\textbar{}0\textbar{}0\textbar{}0\textbar{}0\textbar{}0\textbar{}
      \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}

Byte 1: Bit7\PYGZti{}Bit6 =\PYGZgt{} 00, Normal data packet
                =\PYGZgt{} 01, Absolute coordination packet
                =\PYGZgt{} 10, Notify packet
        Bit5 =\PYGZgt{} 0
        Bit4 =\PYGZgt{} 1
        Bit3 =\PYGZgt{} 1
        Bit2 =\PYGZgt{} Middle Button, 1 is pressed, 0 is not pressed.
        Bit1 =\PYGZgt{} Right Button, 1 is pressed, 0 is not pressed.
        Bit0 =\PYGZgt{} Left Button, 1 is pressed, 0 is not pressed.
Byte 2: Message Type =\PYGZgt{} 0x5A (Enable/Disable status packet)
        Mode Type =\PYGZgt{} 0xA5 (Normal/Icon mode status)
Byte 3: Message Type =\PYGZgt{} 0x00 (Disabled)
                    =\PYGZgt{} 0x01 (Enabled)
        Mode Type    =\PYGZgt{} 0x00 (Normal)
                    =\PYGZgt{} 0x01 (Icon)
Byte 4: Bit7\PYGZti{}Bit0 =\PYGZgt{} Don\PYGZsq{}t Care
\end{Verbatim}


\subsection{Absolute position for STL3888-Ax}
\label{input/devices/sentelic:absolute-position-for-stl3888-ax}
\begin{Verbatim}[commandchars=\\\{\}]
Packet 1 (ABSOLUTE POSITION)
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
  1   \textbar{}0\textbar{}1\textbar{}V\textbar{}A\textbar{}1\textbar{}L\textbar{}0\textbar{}1\textbar{}  2  \textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}  3 \textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}  4 \textbar{}x\textbar{}x\textbar{}y\textbar{}y\textbar{}X\textbar{}X\textbar{}Y\textbar{}Y\textbar{}
      \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}

Byte 1: Bit7\PYGZti{}Bit6 =\PYGZgt{} 00, Normal data packet
                =\PYGZgt{} 01, Absolute coordination packet
                =\PYGZgt{} 10, Notify packet
                =\PYGZgt{} 11, Normal data packet with on\PYGZhy{}pad click
        Bit5 =\PYGZgt{} Valid bit, 0 means that the coordinate is invalid or finger up.
                When both fingers are up, the last two reports have zero valid
                bit.
        Bit4 =\PYGZgt{} arc
        Bit3 =\PYGZgt{} 1
        Bit2 =\PYGZgt{} Left Button, 1 is pressed, 0 is released.
        Bit1 =\PYGZgt{} 0
        Bit0 =\PYGZgt{} 1
Byte 2: X coordinate (xpos[9:2])
Byte 3: Y coordinate (ypos[9:2])
Byte 4: Bit1\PYGZti{}Bit0 =\PYGZgt{} Y coordinate (xpos[1:0])
        Bit3\PYGZti{}Bit2 =\PYGZgt{} X coordinate (ypos[1:0])
        Bit5\PYGZti{}Bit4 =\PYGZgt{} y1\PYGZus{}g
        Bit7\PYGZti{}Bit6 =\PYGZgt{} x1\PYGZus{}g

Packet 2 (ABSOLUTE POSITION)
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
  1   \textbar{}0\textbar{}1\textbar{}V\textbar{}A\textbar{}1\textbar{}R\textbar{}1\textbar{}0\textbar{}  2  \textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}  3 \textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}  4 \textbar{}x\textbar{}x\textbar{}y\textbar{}y\textbar{}X\textbar{}X\textbar{}Y\textbar{}Y\textbar{}
      \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}

Byte 1: Bit7\PYGZti{}Bit6 =\PYGZgt{} 00, Normal data packet
                =\PYGZgt{} 01, Absolute coordinates packet
                =\PYGZgt{} 10, Notify packet
                =\PYGZgt{} 11, Normal data packet with on\PYGZhy{}pad click
        Bit5 =\PYGZgt{} Valid bit, 0 means that the coordinate is invalid or finger up.
                When both fingers are up, the last two reports have zero valid
                bit.
        Bit4 =\PYGZgt{} arc
        Bit3 =\PYGZgt{} 1
        Bit2 =\PYGZgt{} Right Button, 1 is pressed, 0 is released.
        Bit1 =\PYGZgt{} 1
        Bit0 =\PYGZgt{} 0
Byte 2: X coordinate (xpos[9:2])
Byte 3: Y coordinate (ypos[9:2])
Byte 4: Bit1\PYGZti{}Bit0 =\PYGZgt{} Y coordinate (xpos[1:0])
        Bit3\PYGZti{}Bit2 =\PYGZgt{} X coordinate (ypos[1:0])
        Bit5\PYGZti{}Bit4 =\PYGZgt{} y2\PYGZus{}g
        Bit7\PYGZti{}Bit6 =\PYGZgt{} x2\PYGZus{}g

Notify Packet for STL3888\PYGZhy{}Ax
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
  1   \textbar{}1\textbar{}0\textbar{}1\textbar{}P\textbar{}1\textbar{}M\textbar{}R\textbar{}L\textbar{}  2  \textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}  3 \textbar{}0\textbar{}0\textbar{}F\textbar{}F\textbar{}0\textbar{}0\textbar{}0\textbar{}i\textbar{}  4 \textbar{}r\textbar{}l\textbar{}d\textbar{}u\textbar{}0\textbar{}0\textbar{}0\textbar{}0\textbar{}
      \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}

Byte 1: Bit7\PYGZti{}Bit6 =\PYGZgt{} 00, Normal data packet
                =\PYGZgt{} 01, Absolute coordinates packet
                =\PYGZgt{} 10, Notify packet
                =\PYGZgt{} 11, Normal data packet with on\PYGZhy{}pad click
        Bit5 =\PYGZgt{} 1
        Bit4 =\PYGZgt{} when in absolute coordinates mode (valid when EN\PYGZus{}PKT\PYGZus{}GO is 1):
                0: left button is generated by the on\PYGZhy{}pad command
                1: left button is generated by the external button
        Bit3 =\PYGZgt{} 1
        Bit2 =\PYGZgt{} Middle Button, 1 is pressed, 0 is not pressed.
        Bit1 =\PYGZgt{} Right Button, 1 is pressed, 0 is not pressed.
        Bit0 =\PYGZgt{} Left Button, 1 is pressed, 0 is not pressed.
Byte 2: Message Type =\PYGZgt{} 0xB7 (Multi Finger, Multi Coordinate mode)
Byte 3: Bit7\PYGZti{}Bit6 =\PYGZgt{} Don\PYGZsq{}t care
        Bit5\PYGZti{}Bit4 =\PYGZgt{} Number of fingers
        Bit3\PYGZti{}Bit1 =\PYGZgt{} Reserved
        Bit0 =\PYGZgt{} 1: enter gesture mode; 0: leaving gesture mode
Byte 4: Bit7 =\PYGZgt{} scroll right button
        Bit6 =\PYGZgt{} scroll left button
        Bit5 =\PYGZgt{} scroll down button
        Bit4 =\PYGZgt{} scroll up button
            * Note that if gesture and additional button (Bit4\PYGZti{}Bit7)
            happen at the same time, the button information will not
            be sent.
        Bit3\PYGZti{}Bit0 =\PYGZgt{} Reserved
\end{Verbatim}

Sample sequence of Multi-finger, Multi-coordinate mode:
\begin{quote}

notify packet (valid bit == 1), abs pkt 1, abs pkt 2, abs pkt 1,
abs pkt 2, ..., notify packet (valid bit == 0)
\end{quote}


\subsection{Absolute position for STL3888-B0}
\label{input/devices/sentelic:absolute-position-for-stl3888-b0}
\begin{Verbatim}[commandchars=\\\{\}]
Packet 1(ABSOLUTE POSITION)
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
  1   \textbar{}0\textbar{}1\textbar{}V\textbar{}F\textbar{}1\textbar{}0\textbar{}R\textbar{}L\textbar{}  2  \textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}  3 \textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}  4 \textbar{}r\textbar{}l\textbar{}u\textbar{}d\textbar{}X\textbar{}X\textbar{}Y\textbar{}Y\textbar{}
      \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}

Byte 1: Bit7\PYGZti{}Bit6 =\PYGZgt{} 00, Normal data packet
                =\PYGZgt{} 01, Absolute coordinates packet
                =\PYGZgt{} 10, Notify packet
                =\PYGZgt{} 11, Normal data packet with on\PYGZhy{}pad click
        Bit5 =\PYGZgt{} Valid bit, 0 means that the coordinate is invalid or finger up.
                When both fingers are up, the last two reports have zero valid
                bit.
        Bit4 =\PYGZgt{} finger up/down information. 1: finger down, 0: finger up.
        Bit3 =\PYGZgt{} 1
        Bit2 =\PYGZgt{} finger index, 0 is the first finger, 1 is the second finger.
        Bit1 =\PYGZgt{} Right Button, 1 is pressed, 0 is not pressed.
        Bit0 =\PYGZgt{} Left Button, 1 is pressed, 0 is not pressed.
Byte 2: X coordinate (xpos[9:2])
Byte 3: Y coordinate (ypos[9:2])
Byte 4: Bit1\PYGZti{}Bit0 =\PYGZgt{} Y coordinate (xpos[1:0])
        Bit3\PYGZti{}Bit2 =\PYGZgt{} X coordinate (ypos[1:0])
        Bit4 =\PYGZgt{} scroll down button
        Bit5 =\PYGZgt{} scroll up button
        Bit6 =\PYGZgt{} scroll left button
        Bit7 =\PYGZgt{} scroll right button

Packet 2 (ABSOLUTE POSITION)
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
  1   \textbar{}0\textbar{}1\textbar{}V\textbar{}F\textbar{}1\textbar{}1\textbar{}R\textbar{}L\textbar{}  2  \textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}  3 \textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}  4 \textbar{}r\textbar{}l\textbar{}u\textbar{}d\textbar{}X\textbar{}X\textbar{}Y\textbar{}Y\textbar{}
      \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}

Byte 1: Bit7\PYGZti{}Bit6 =\PYGZgt{} 00, Normal data packet
                =\PYGZgt{} 01, Absolute coordination packet
                =\PYGZgt{} 10, Notify packet
                =\PYGZgt{} 11, Normal data packet with on\PYGZhy{}pad click
        Bit5 =\PYGZgt{} Valid bit, 0 means that the coordinate is invalid or finger up.
                When both fingers are up, the last two reports have zero valid
                bit.
        Bit4 =\PYGZgt{} finger up/down information. 1: finger down, 0: finger up.
        Bit3 =\PYGZgt{} 1
        Bit2 =\PYGZgt{} finger index, 0 is the first finger, 1 is the second finger.
        Bit1 =\PYGZgt{} Right Button, 1 is pressed, 0 is not pressed.
        Bit0 =\PYGZgt{} Left Button, 1 is pressed, 0 is not pressed.
Byte 2: X coordinate (xpos[9:2])
Byte 3: Y coordinate (ypos[9:2])
Byte 4: Bit1\PYGZti{}Bit0 =\PYGZgt{} Y coordinate (xpos[1:0])
        Bit3\PYGZti{}Bit2 =\PYGZgt{} X coordinate (ypos[1:0])
        Bit4 =\PYGZgt{} scroll down button
        Bit5 =\PYGZgt{} scroll up button
        Bit6 =\PYGZgt{} scroll left button
        Bit7 =\PYGZgt{} scroll right button
\end{Verbatim}

Notify Packet for STL3888-B0:

\begin{Verbatim}[commandchars=\\\{\}]
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
  1   \textbar{}1\textbar{}0\textbar{}1\textbar{}P\textbar{}1\textbar{}M\textbar{}R\textbar{}L\textbar{}  2  \textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}  3 \textbar{}0\textbar{}0\textbar{}F\textbar{}F\textbar{}0\textbar{}0\textbar{}0\textbar{}i\textbar{}  4 \textbar{}r\textbar{}l\textbar{}u\textbar{}d\textbar{}0\textbar{}0\textbar{}0\textbar{}0\textbar{}
      \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}

Byte 1: Bit7\PYGZti{}Bit6 =\PYGZgt{} 00, Normal data packet
                =\PYGZgt{} 01, Absolute coordination packet
                =\PYGZgt{} 10, Notify packet
                =\PYGZgt{} 11, Normal data packet with on\PYGZhy{}pad click
        Bit5 =\PYGZgt{} 1
        Bit4 =\PYGZgt{} when in absolute coordinates mode (valid when EN\PYGZus{}PKT\PYGZus{}GO is 1):
                0: left button is generated by the on\PYGZhy{}pad command
                1: left button is generated by the external button
        Bit3 =\PYGZgt{} 1
        Bit2 =\PYGZgt{} Middle Button, 1 is pressed, 0 is not pressed.
        Bit1 =\PYGZgt{} Right Button, 1 is pressed, 0 is not pressed.
        Bit0 =\PYGZgt{} Left Button, 1 is pressed, 0 is not pressed.
Byte 2: Message Type =\PYGZgt{} 0xB7 (Multi Finger, Multi Coordinate mode)
Byte 3: Bit7\PYGZti{}Bit6 =\PYGZgt{} Don\PYGZsq{}t care
        Bit5\PYGZti{}Bit4 =\PYGZgt{} Number of fingers
        Bit3\PYGZti{}Bit1 =\PYGZgt{} Reserved
        Bit0 =\PYGZgt{} 1: enter gesture mode; 0: leaving gesture mode
Byte 4: Bit7 =\PYGZgt{} scroll right button
        Bit6 =\PYGZgt{} scroll left button
        Bit5 =\PYGZgt{} scroll up button
        Bit4 =\PYGZgt{} scroll down button
            * Note that if gesture and additional button(Bit4\PYGZti{}Bit7)
            happen at the same time, the button information will not
            be sent.
        Bit3\PYGZti{}Bit0 =\PYGZgt{} Reserved
\end{Verbatim}

Sample sequence of Multi-finger, Multi-coordinate mode:
\begin{quote}

notify packet (valid bit == 1), abs pkt 1, abs pkt 2, abs pkt 1,
abs pkt 2, ..., notify packet (valid bit == 0)
\end{quote}


\subsection{Absolute position for STL3888-Cx and STL3888-Dx}
\label{input/devices/sentelic:absolute-position-for-stl3888-cx-and-stl3888-dx}
\begin{Verbatim}[commandchars=\\\{\}]
Single Finger, Absolute Coordinate Mode (SFAC)
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
  1   \textbar{}0\textbar{}1\textbar{}0\textbar{}P\textbar{}1\textbar{}M\textbar{}R\textbar{}L\textbar{}  2  \textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}  3 \textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}  4 \textbar{}r\textbar{}l\textbar{}B\textbar{}F\textbar{}X\textbar{}X\textbar{}Y\textbar{}Y\textbar{}
      \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}

Byte 1: Bit7\PYGZti{}Bit6 =\PYGZgt{} 00, Normal data packet
                =\PYGZgt{} 01, Absolute coordinates packet
                =\PYGZgt{} 10, Notify packet
        Bit5 =\PYGZgt{} Coordinate mode(always 0 in SFAC mode):
                0: single\PYGZhy{}finger absolute coordinates (SFAC) mode
                1: multi\PYGZhy{}finger, multiple coordinates (MFMC) mode
        Bit4 =\PYGZgt{} 0: The LEFT button is generated by on\PYGZhy{}pad command (OPC)
                1: The LEFT button is generated by external button
                Default is 1 even if the LEFT button is not pressed.
        Bit3 =\PYGZgt{} Always 1, as specified by PS/2 protocol.
        Bit2 =\PYGZgt{} Middle Button, 1 is pressed, 0 is not pressed.
        Bit1 =\PYGZgt{} Right Button, 1 is pressed, 0 is not pressed.
        Bit0 =\PYGZgt{} Left Button, 1 is pressed, 0 is not pressed.
Byte 2: X coordinate (xpos[9:2])
Byte 3: Y coordinate (ypos[9:2])
Byte 4: Bit1\PYGZti{}Bit0 =\PYGZgt{} Y coordinate (xpos[1:0])
        Bit3\PYGZti{}Bit2 =\PYGZgt{} X coordinate (ypos[1:0])
        Bit4 =\PYGZgt{} 4th mouse button(forward one page)
        Bit5 =\PYGZgt{} 5th mouse button(backward one page)
        Bit6 =\PYGZgt{} scroll left button
        Bit7 =\PYGZgt{} scroll right button

Multi Finger, Multiple Coordinates Mode (MFMC):
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
  1   \textbar{}0\textbar{}1\textbar{}1\textbar{}P\textbar{}1\textbar{}F\textbar{}R\textbar{}L\textbar{}  2  \textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}X\textbar{}  3 \textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}Y\textbar{}  4 \textbar{}r\textbar{}l\textbar{}B\textbar{}F\textbar{}X\textbar{}X\textbar{}Y\textbar{}Y\textbar{}
      \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}

Byte 1: Bit7\PYGZti{}Bit6 =\PYGZgt{} 00, Normal data packet
                =\PYGZgt{} 01, Absolute coordination packet
                =\PYGZgt{} 10, Notify packet
        Bit5 =\PYGZgt{} Coordinate mode (always 1 in MFMC mode):
                0: single\PYGZhy{}finger absolute coordinates (SFAC) mode
                1: multi\PYGZhy{}finger, multiple coordinates (MFMC) mode
        Bit4 =\PYGZgt{} 0: The LEFT button is generated by on\PYGZhy{}pad command (OPC)
                1: The LEFT button is generated by external button
                Default is 1 even if the LEFT button is not pressed.
        Bit3 =\PYGZgt{} Always 1, as specified by PS/2 protocol.
        Bit2 =\PYGZgt{} Finger index, 0 is the first finger, 1 is the second finger.
                If bit 1 and 0 are all 1 and bit 4 is 0, the middle external
                button is pressed.
        Bit1 =\PYGZgt{} Right Button, 1 is pressed, 0 is not pressed.
        Bit0 =\PYGZgt{} Left Button, 1 is pressed, 0 is not pressed.
Byte 2: X coordinate (xpos[9:2])
Byte 3: Y coordinate (ypos[9:2])
Byte 4: Bit1\PYGZti{}Bit0 =\PYGZgt{} Y coordinate (xpos[1:0])
        Bit3\PYGZti{}Bit2 =\PYGZgt{} X coordinate (ypos[1:0])
        Bit4 =\PYGZgt{} 4th mouse button(forward one page)
        Bit5 =\PYGZgt{} 5th mouse button(backward one page)
        Bit6 =\PYGZgt{} scroll left button
        Bit7 =\PYGZgt{} scroll right button
\end{Verbatim}

When one of the two fingers is up, the device will output four consecutive
MFMC\#0 report packets with zero X and Y to represent 1st finger is up or
four consecutive MFMC\#1 report packets with zero X and Y to represent that
the 2nd finger is up.  On the other hand, if both fingers are up, the device
will output four consecutive single-finger, absolute coordinate(SFAC) packets
with zero X and Y.

Notify Packet for STL3888-Cx/Dx:

\begin{Verbatim}[commandchars=\\\{\}]
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
  1   \textbar{}1\textbar{}0\textbar{}0\textbar{}P\textbar{}1\textbar{}M\textbar{}R\textbar{}L\textbar{}  2  \textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}C\textbar{}  3 \textbar{}0\textbar{}0\textbar{}F\textbar{}F\textbar{}0\textbar{}0\textbar{}0\textbar{}i\textbar{}  4 \textbar{}r\textbar{}l\textbar{}u\textbar{}d\textbar{}0\textbar{}0\textbar{}0\textbar{}0\textbar{}
      \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}

Byte 1: Bit7\PYGZti{}Bit6 =\PYGZgt{} 00, Normal data packet
                =\PYGZgt{} 01, Absolute coordinates packet
                =\PYGZgt{} 10, Notify packet
        Bit5 =\PYGZgt{} Always 0
        Bit4 =\PYGZgt{} 0: The LEFT button is generated by on\PYGZhy{}pad command(OPC)
                1: The LEFT button is generated by external button
                Default is 1 even if the LEFT button is not pressed.
        Bit3 =\PYGZgt{} 1
        Bit2 =\PYGZgt{} Middle Button, 1 is pressed, 0 is not pressed.
        Bit1 =\PYGZgt{} Right Button, 1 is pressed, 0 is not pressed.
        Bit0 =\PYGZgt{} Left Button, 1 is pressed, 0 is not pressed.
Byte 2: Message type:
        0xba =\PYGZgt{} gesture information
        0xc0 =\PYGZgt{} one finger hold\PYGZhy{}rotating gesture
Byte 3: The first parameter for the received message:
        0xba =\PYGZgt{} gesture ID (refer to the \PYGZsq{}Gesture ID\PYGZsq{} section)
        0xc0 =\PYGZgt{} region ID
Byte 4: The second parameter for the received message:
        0xba =\PYGZgt{} N/A
        0xc0 =\PYGZgt{} finger up/down information
\end{Verbatim}

Sample sequence of Multi-finger, Multi-coordinates mode:
\begin{quote}

notify packet (valid bit == 1), MFMC packet 1 (byte 1, bit 2 == 0),
MFMC packet 2 (byte 1, bit 2 == 1), MFMC packet 1, MFMC packet 2,
..., notify packet (valid bit == 0)

That is, when the device is in MFMC mode, the host will receive
interleaved absolute coordinate packets for each finger.
\end{quote}


\subsection{FSP Enable/Disable packet}
\label{input/devices/sentelic:fsp-enable-disable-packet}
\begin{Verbatim}[commandchars=\\\{\}]
Bit 7 6 5 4 3 2 1 0       7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0      7 6 5 4 3 2 1 0
BYTE  \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}BYTE\textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}
  1   \textbar{}Y\textbar{}X\textbar{}0\textbar{}0\textbar{}1\textbar{}M\textbar{}R\textbar{}L\textbar{}  2  \textbar{}0\textbar{}1\textbar{}0\textbar{}1\textbar{}1\textbar{}0\textbar{}1\textbar{}E\textbar{}  3 \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{}  4 \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{}
      \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}     \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}    \textbar{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\textbar{}

FSP will send out enable/disable packet when FSP receive PS/2 enable/disable
command. Host will receive the packet which Middle, Right, Left button will
be set. The packet only use byte 0 and byte 1 as a pattern of original packet.
Ignore the other bytes of the packet.

Byte 1: Bit7 =\PYGZgt{} 0, Y overflow
        Bit6 =\PYGZgt{} 0, X overflow
        Bit5 =\PYGZgt{} 0, Y sign bit
        Bit4 =\PYGZgt{} 0, X sign bit
        Bit3 =\PYGZgt{} 1
        Bit2 =\PYGZgt{} 1, Middle Button
        Bit1 =\PYGZgt{} 1, Right Button
        Bit0 =\PYGZgt{} 1, Left Button
Byte 2: Bit7\PYGZti{}1 =\PYGZgt{} (0101101b)
        Bit0 =\PYGZgt{} 1 = Enable
                0 = Disable
Byte 3: Don\PYGZsq{}t care
Byte 4: Don\PYGZsq{}t care (MOUSE ID 3, 4)
Byte 5\PYGZti{}8: Don\PYGZsq{}t care (Absolute packet)
\end{Verbatim}


\subsection{PS/2 Command Set}
\label{input/devices/sentelic:ps-2-command-set}
FSP supports basic PS/2 commanding set and modes, refer to following URL for
details about PS/2 commands:

\href{http://www.computer-engineering.org/ps2mouse/}{http://www.computer-engineering.org/ps2mouse/}


\subsection{Programming Sequence for Determining Packet Parsing Flow}
\label{input/devices/sentelic:programming-sequence-for-determining-packet-parsing-flow}\begin{enumerate}
\item {} 
Identify FSP by reading device ID(0x00) and version(0x01) register

\item {} 
For FSP version \textless{} STL3888 Cx, determine number of buttons by reading
the `test mode status' (0x20) register:

\begin{Verbatim}[commandchars=\\\{\}]
buttons = reg[0x20] \PYGZam{} 0x30

if buttons == 0x30 or buttons == 0x20:
        \PYGZsh{} two/four buttons
        Refer to \PYGZsq{}Finger Sensing Pad PS/2 Mouse Intellimouse\PYGZsq{}
        section A for packet parsing detail(ignore byte 4, bit \PYGZti{} 7)
elif buttons == 0x10:
        \PYGZsh{} 6 buttons
        Refer to \PYGZsq{}Finger Sensing Pad PS/2 Mouse Intellimouse\PYGZsq{}
        section B for packet parsing detail
elif buttons == 0x00:
        \PYGZsh{} 6 buttons
        Refer to \PYGZsq{}Finger Sensing Pad PS/2 Mouse Intellimouse\PYGZsq{}
        section A for packet parsing detail
\end{Verbatim}

\item {} \begin{description}
\item[{For FSP version \textgreater{}= STL3888 Cx:}] \leavevmode
Refer to `Finger Sensing Pad PS/2 Mouse Intellimouse'
section A for packet parsing detail (ignore byte 4, bit \textasciitilde{} 7)

\end{description}

\end{enumerate}


\subsection{Programming Sequence for Register Reading/Writing}
\label{input/devices/sentelic:programming-sequence-for-register-reading-writing}
Register inversion requirement:

Following values needed to be inverted(the `\textasciitilde{}' operator in C) before being
sent to FSP:

\begin{Verbatim}[commandchars=\\\{\}]
0xe8, 0xe9, 0xee, 0xf2, 0xf3 and 0xff.
\end{Verbatim}

Register swapping requirement:

Following values needed to have their higher 4 bits and lower 4 bits being
swapped before being sent to FSP:

\begin{Verbatim}[commandchars=\\\{\}]
10, 20, 40, 60, 80, 100 and 200.
\end{Verbatim}

Register reading sequence:
\begin{quote}
\begin{enumerate}
\item {} 
send 0xf3 PS/2 command to FSP;

\item {} 
send 0x66 PS/2 command to FSP;

\item {} 
send 0x88 PS/2 command to FSP;

\item {} 
send 0xf3 PS/2 command to FSP;

\end{enumerate}

5. if the register address being to read is not required to be
inverted(refer to the `Register inversion requirement' section),
goto step 6
\begin{enumerate}
\item {} 
send 0x68 PS/2 command to FSP;

\item {} 
send the inverted register address to FSP and goto step 8;

\end{enumerate}

6. if the register address being to read is not required to be
swapped(refer to the `Register swapping requirement' section),
goto step 7
\begin{enumerate}
\item {} 
send 0xcc PS/2 command to FSP;

\item {} 
send the swapped register address to FSP and goto step 8;

\end{enumerate}
\begin{enumerate}
\setcounter{enumi}{6}
\item {} 
send 0x66 PS/2 command to FSP;

\end{enumerate}
\begin{enumerate}
\item {} 
send the original register address to FSP and goto step 8;

\end{enumerate}
\begin{enumerate}
\setcounter{enumi}{7}
\item {} 
send 0xe9(status request) PS/2 command to FSP;

\end{enumerate}

9. the 4th byte of the response read from FSP should be the
requested register value(?? indicates don't care byte):

\begin{Verbatim}[commandchars=\\\{\}]
host: 0xe9
3888: 0xfa (??) (??) (val)
\end{Verbatim}
\begin{itemize}
\item {} 
Note that since the Cx release, the hardware will return 1's
complement of the register value at the 3rd byte of status request
result:

\begin{Verbatim}[commandchars=\\\{\}]
host: 0xe9
3888: 0xfa (??) (\PYGZti{}val) (val)
\end{Verbatim}

\end{itemize}
\end{quote}

Register writing sequence:
\begin{quote}
\begin{enumerate}
\item {} 
send 0xf3 PS/2 command to FSP;

\end{enumerate}

2. if the register address being to write is not required to be
inverted(refer to the `Register inversion requirement' section),
goto step 3
\begin{enumerate}
\item {} 
send 0x74 PS/2 command to FSP;

\item {} 
send the inverted register address to FSP and goto step 5;

\end{enumerate}

3. if the register address being to write is not required to be
swapped(refer to the `Register swapping requirement' section),
goto step 4
\begin{enumerate}
\item {} 
send 0x77 PS/2 command to FSP;

\item {} 
send the swapped register address to FSP and goto step 5;

\end{enumerate}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
send 0x55 PS/2 command to FSP;

\end{enumerate}
\begin{enumerate}
\item {} 
send the register address to FSP and goto step 5;

\end{enumerate}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
send 0xf3 PS/2 command to FSP;

\end{enumerate}

6. if the register value being to write is not required to be
inverted(refer to the `Register inversion requirement' section),
goto step 7
\begin{enumerate}
\item {} 
send 0x47 PS/2 command to FSP;

\item {} 
send the inverted register value to FSP and goto step 9;

\end{enumerate}

7. if the register value being to write is not required to be
swapped(refer to the `Register swapping requirement' section),
goto step 8
\begin{enumerate}
\item {} 
send 0x44 PS/2 command to FSP;

\item {} 
send the swapped register value to FSP and goto step 9;

\end{enumerate}
\begin{enumerate}
\setcounter{enumi}{7}
\item {} 
send 0x33 PS/2 command to FSP;

\end{enumerate}
\begin{enumerate}
\item {} 
send the register value to FSP;

\end{enumerate}
\begin{enumerate}
\setcounter{enumi}{8}
\item {} 
the register writing sequence is completed.

\end{enumerate}
\begin{itemize}
\item {} 
Since the Cx release, the hardware will return 1's
complement of the register value at the 3rd byte of status request
result. Host can optionally send another 0xe9 (status request) PS/2
command to FSP at the end of register writing to verify that the
register writing operation is successful (?? indicates don't care
byte):

\begin{Verbatim}[commandchars=\\\{\}]
host: 0xe9
3888: 0xfa (??) (\PYGZti{}val) (val)
\end{Verbatim}

\end{itemize}
\end{quote}


\subsection{Programming Sequence for Page Register Reading/Writing}
\label{input/devices/sentelic:programming-sequence-for-page-register-reading-writing}
In order to overcome the limitation of maximum number of registers
supported, the hardware separates register into different groups called
`pages.' Each page is able to include up to 255 registers.

The default page after power up is 0x82; therefore, if one has to get
access to register 0x8301, one has to use following sequence to switch
to page 0x83, then start reading/writing from/to offset 0x01 by using
the register read/write sequence described in previous section.

Page register reading sequence:
\begin{enumerate}
\item {} 
send 0xf3 PS/2 command to FSP;

\item {} 
send 0x66 PS/2 command to FSP;

\item {} 
send 0x88 PS/2 command to FSP;

\item {} 
send 0xf3 PS/2 command to FSP;

\item {} 
send 0x83 PS/2 command to FSP;

\item {} 
send 0x88 PS/2 command to FSP;

\item {} 
send 0xe9(status request) PS/2 command to FSP;

\item {} 
the response read from FSP should be the requested page value.

\end{enumerate}

Page register writing sequence:
\begin{quote}
\begin{enumerate}
\item {} 
send 0xf3 PS/2 command to FSP;

\item {} 
send 0x38 PS/2 command to FSP;

\item {} 
send 0x88 PS/2 command to FSP;

\item {} 
send 0xf3 PS/2 command to FSP;

\end{enumerate}

5. if the page address being written is not required to be
inverted(refer to the `Register inversion requirement' section),
goto step 6
\begin{enumerate}
\item {} 
send 0x47 PS/2 command to FSP;

\item {} 
send the inverted page address to FSP and goto step 9;

\end{enumerate}

6. if the page address being written is not required to be
swapped(refer to the `Register swapping requirement' section),
goto step 7
\begin{enumerate}
\item {} 
send 0x44 PS/2 command to FSP;

\item {} 
send the swapped page address to FSP and goto step 9;

\end{enumerate}
\begin{enumerate}
\setcounter{enumi}{6}
\item {} 
send 0x33 PS/2 command to FSP;

\item {} 
send the page address to FSP;

\item {} 
the page register writing sequence is completed.

\end{enumerate}
\end{quote}


\subsection{Gesture ID}
\label{input/devices/sentelic:gesture-id}
Unlike other devices which sends multiple fingers' coordinates to host,
FSP processes multiple fingers' coordinates internally and convert them
into a 8 bits integer, namely `Gesture ID.'  Following is a list of
supported gesture IDs:
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
ID
} & \textsf{\relax 
Description
}\\
\hline
0x86
 & 
2 finger straight up
\\
\hline
0x82
 & 
2 finger straight down
\\
\hline
0x80
 & 
2 finger straight right
\\
\hline
0x84
 & 
2 finger straight left
\\
\hline
0x8f
 & 
2 finger zoom in
\\
\hline
0x8b
 & 
2 finger zoom out
\\
\hline
0xc0
 & 
2 finger curve, counter clockwise
\\
\hline
0xc4
 & 
2 finger curve, clockwise
\\
\hline
0x2e
 & 
3 finger straight up
\\
\hline
0x2a
 & 
3 finger straight down
\\
\hline
0x28
 & 
3 finger straight right
\\
\hline
0x2c
 & 
3 finger straight left
\\
\hline
0x38
 & 
palm
\\
\hline\end{tabulary}

\end{quote}


\subsection{Register Listing}
\label{input/devices/sentelic:register-listing}
Registers are represented in 16 bits values. The higher 8 bits represent
the page address and the lower 8 bits represent the relative offset within
that particular page.  Refer to the `Programming Sequence for Page Register
Reading/Writing' section for instructions on how to change current page
address:

\begin{Verbatim}[commandchars=\\\{\}]
offset width           default r/w     name
0x8200 bit7\PYGZti{}bit0       0x01    RO      device ID

0x8201 bit7\PYGZti{}bit0               RW      version ID
                                       0xc1: STL3888 Ax
                                       0xd0 \PYGZti{} 0xd2: STL3888 Bx
                                       0xe0 \PYGZti{} 0xe1: STL3888 Cx
                                       0xe2 \PYGZti{} 0xe3: STL3888 Dx

0x8202 bit7\PYGZti{}bit0       0x01    RO      vendor ID

0x8203 bit7\PYGZti{}bit0       0x01    RO      product ID

0x8204 bit3\PYGZti{}bit0       0x01    RW      revision ID

0x820b                                 test mode status 1
       bit3            1       RO      0: rotate 180 degree
                                       1: no rotation
                                       *only supported by H/W prior to Cx

0x820f                                 register file page control
       bit2            0       RW      1: rotate 180 degree
                                       0: no rotation
                                       *supported since Cx

       bit0            0       RW      1 to enable page 1 register files
                                       *only supported by H/W prior to Cx

0x8210                         RW      system control 1
       bit0            1       RW      Reserved, must be 1
       bit1            0       RW      Reserved, must be 0
       bit4            0       RW      Reserved, must be 0
       bit5            1       RW      register clock gating enable
                                       0: read only, 1: read/write enable
       (Note that following registers does not require clock gating being
       enabled prior to write: 05 06 07 08 09 0c 0f 10 11 12 16 17 18 23 2e
       40 41 42 43.  In addition to that, this bit must be 1 when gesture
       mode is enabled)

0x8220                                 test mode status
       bit5\PYGZti{}bit4               RO      number of buttons
                                       11 =\PYGZgt{} 2, lbtn/rbtn
                                       10 =\PYGZgt{} 4, lbtn/rbtn/scru/scrd
                                       01 =\PYGZgt{} 6, lbtn/rbtn/scru/scrd/scrl/scrr
                                       00 =\PYGZgt{} 6, lbtn/rbtn/scru/scrd/fbtn/bbtn
                                       *only supported by H/W prior to Cx

0x8231                         RW      on\PYGZhy{}pad command detection
       bit7            0       RW      on\PYGZhy{}pad command left button down tag
                                       enable
                                       0: disable, 1: enable
                                       *only supported by H/W prior to Cx

0x8234                         RW      on\PYGZhy{}pad command control 5
       bit4\PYGZti{}bit0       0x05    RW      XLO in 0s/4/1, so 03h = 0010.1b = 2.5
       (Note that position unit is in 0.5 scanline)
                                       *only supported by H/W prior to Cx

       bit7            0       RW      on\PYGZhy{}pad tap zone enable
                                       0: disable, 1: enable
                                       *only supported by H/W prior to Cx

0x8235                         RW      on\PYGZhy{}pad command control 6
       bit4\PYGZti{}bit0       0x1d    RW      XHI in 0s/4/1, so 19h = 1100.1b = 12.5
       (Note that position unit is in 0.5 scanline)
                                       *only supported by H/W prior to Cx

0x8236                         RW      on\PYGZhy{}pad command control 7
       bit4\PYGZti{}bit0       0x04    RW      YLO in 0s/4/1, so 03h = 0010.1b = 2.5
       (Note that position unit is in 0.5 scanline)
                                       *only supported by H/W prior to Cx

0x8237                         RW      on\PYGZhy{}pad command control 8
       bit4\PYGZti{}bit0       0x13    RW      YHI in 0s/4/1, so 11h = 1000.1b = 8.5
       (Note that position unit is in 0.5 scanline)
                                       *only supported by H/W prior to Cx

0x8240                         RW      system control 5
       bit1            0       RW      FSP Intellimouse mode enable
                                       0: disable, 1: enable
                                       *only supported by H/W prior to Cx

       bit2            0       RW      movement + abs. coordinate mode enable
                                       0: disable, 1: enable
       (Note that this function has the functionality of bit 1 even when
       bit 1 is not set. However, the format is different from that of bit 1.
       In addition, when bit 1 and bit 2 are set at the same time, bit 2 will
       override bit 1.)
                                       *only supported by H/W prior to Cx

       bit3            0       RW      abs. coordinate only mode enable
                                       0: disable, 1: enable
       (Note that this function has the functionality of bit 1 even when
       bit 1 is not set. However, the format is different from that of bit 1.
       In addition, when bit 1, bit 2 and bit 3 are set at the same time,
       bit 3 will override bit 1 and 2.)
                                       *only supported by H/W prior to Cx

       bit5            0       RW      auto switch enable
                                       0: disable, 1: enable
                                       *only supported by H/W prior to Cx

       bit6            0       RW      G0 abs. + notify packet format enable
                                       0: disable, 1: enable
       (Note that the absolute/relative coordinate output still depends on
       bit 2 and 3.  That is, if any of those bit is 1, host will receive
       absolute coordinates; otherwise, host only receives packets with
       relative coordinate.)
                                       *only supported by H/W prior to Cx

       bit7            0       RW      EN\PYGZus{}PS2\PYGZus{}F2: PS/2 gesture mode 2nd
                                       finger packet enable
                                       0: disable, 1: enable
                                       *only supported by H/W prior to Cx

0x8243                         RW      on\PYGZhy{}pad control
       bit0            0       RW      on\PYGZhy{}pad control enable
                                       0: disable, 1: enable
       (Note that if this bit is cleared, bit 3/5 will be ineffective)
                                       *only supported by H/W prior to Cx

       bit3            0       RW      on\PYGZhy{}pad fix vertical scrolling enable
                                       0: disable, 1: enable
                                       *only supported by H/W prior to Cx

       bit5            0       RW      on\PYGZhy{}pad fix horizontal scrolling enable
                                       0: disable, 1: enable
                                       *only supported by H/W prior to Cx

0x8290                         RW      software control register 1
       bit0            0       RW      absolute coordination mode
                                       0: disable, 1: enable
                                       *supported since Cx

       bit1            0       RW      gesture ID output
                                       0: disable, 1: enable
                                       *supported since Cx

       bit2            0       RW      two fingers\PYGZsq{} coordinates output
                                       0: disable, 1: enable
                                       *supported since Cx

       bit3            0       RW      finger up one packet output
                                       0: disable, 1: enable
                                       *supported since Cx

       bit4            0       RW      absolute coordination continuous mode
                                       0: disable, 1: enable
                                       *supported since Cx

       bit6\PYGZti{}bit5       00      RW      gesture group selection
                                       00: basic
                                       01: suite
                                       10: suite pro
                                       11: advanced
                                       *supported since Cx

       bit7            0       RW      Bx packet output compatible mode
                                       0: disable, 1: enable
                                       *supported since Cx
                                       *supported since Cx


0x833d                         RW      on\PYGZhy{}pad command control 1
       bit7            1       RW      on\PYGZhy{}pad command detection enable
                                       0: disable, 1: enable
                                       *supported since Cx

0x833e                         RW      on\PYGZhy{}pad command detection
       bit7            0       RW      on\PYGZhy{}pad command left button down tag
                                       enable. Works only in H/W based PS/2
                                       data packet mode.
                                       0: disable, 1: enable
                                       *supported since Cx
\end{Verbatim}


\section{Walkera WK-0701 transmitter}
\label{input/devices/walkera0701:walkera-wk-0701-transmitter}\label{input/devices/walkera0701::doc}
Walkera WK-0701 transmitter is supplied with a ready to fly Walkera
helicopters such as HM36, HM37, HM60. The walkera0701 module enables to use
this transmitter as joystick

Devel homepage and download:
\href{http://zub.fei.tuke.sk/walkera-wk0701/}{http://zub.fei.tuke.sk/walkera-wk0701/}

or use cogito:
cg-clone \href{http://zub.fei.tuke.sk/GIT/walkera0701-joystick}{http://zub.fei.tuke.sk/GIT/walkera0701-joystick}


\subsection{Connecting to PC}
\label{input/devices/walkera0701:connecting-to-pc}
At back side of transmitter S-video connector can be found. Modulation
pulses from processor to HF part can be found at pin 2 of this connector,
pin 3 is GND. Between pin 3 and CPU 5k6 resistor can be found. To get
modulation pulses to PC, signal pulses must be amplified.

Cable: (walkera TX to parport)

Walkera WK-0701 TX S-VIDEO connector:

\begin{Verbatim}[commandchars=\\\{\}]
(back side of TX)
    \PYGZus{}\PYGZus{}   \PYGZus{}\PYGZus{}              S\PYGZhy{}video:                                  canon25
   /  \textbar{}\PYGZus{}\textbar{}  \PYGZbs{}             pin 2 (signal)              NPN           parport
  / O 4 3 O \PYGZbs{}            pin 3 (GND)        LED        \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}  10 ACK
 ( O 2   1 O )                                         \textbar{} C
  \PYGZbs{}   \PYGZus{}\PYGZus{}\PYGZus{}   /      2 \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}\PYGZbs{}\textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}/
   \textbar{} [\PYGZus{}\PYGZus{}\PYGZus{}] \textbar{}                                 \textbar{}/\textbar{}   B \textbar{}\PYGZbs{}
    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}        3 \PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\textbar{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{} 25 GND
                                                         E
\end{Verbatim}

I use green LED and BC109 NPN transistor.


\subsection{Software}
\label{input/devices/walkera0701:software}
Build kernel with walkera0701 module. Module walkera0701 need exclusive
access to parport, modules like lp must be unloaded before loading
walkera0701 module, check dmesg for error messages. Connect TX to PC by
cable and run jstest /dev/input/js0 to see values from TX. If no value can
be changed by TX ``joystick'', check output from /proc/interrupts. Value for
(usually irq7) parport must increase if TX is on.


\subsection{Technical details}
\label{input/devices/walkera0701:technical-details}
Driver use interrupt from parport ACK input bit to measure pulse length
using hrtimers.

Frame format:
Based on walkera WK-0701 PCM Format description by Shaul Eizikovich.
(downloaded from \href{http://www.smartpropoplus.com/Docs/Walkera\_Wk-0701\_PCM.pdf}{http://www.smartpropoplus.com/Docs/Walkera\_Wk-0701\_PCM.pdf})


\subsubsection{Signal pulses}
\label{input/devices/walkera0701:signal-pulses}
\begin{Verbatim}[commandchars=\\\{\}]
                   (ANALOG)
    SYNC      BIN   OCT
  +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+      +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+
  \textbar{}         \textbar{}      \textbar{}      \textbar{}
\PYGZhy{}\PYGZhy{}+         +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+      +\PYGZhy{}\PYGZhy{}\PYGZhy{}
\end{Verbatim}


\subsubsection{Frame}
\label{input/devices/walkera0701:frame}
\begin{Verbatim}[commandchars=\\\{\}]
SYNC , BIN1, OCT1, BIN2, OCT2 ... BIN24, OCT24, BIN25, next frame SYNC ..
\end{Verbatim}


\subsubsection{pulse length}
\label{input/devices/walkera0701:pulse-length}
\begin{Verbatim}[commandchars=\\\{\}]
 Binary values:               Analog octal values:

 288 uS Binary 0              318 uS       000
 438 uS Binary 1              398 uS       001
                              478 uS       010
                              558 uS       011
                              638 uS       100
1306 uS SYNC                  718 uS       101
                              798 uS       110
                              878 uS       111
\end{Verbatim}

24 bin+oct values + 1 bin value = 24*4+1 bits  = 97 bits

(Warning, pulses on ACK are inverted by transistor, irq is raised up on sync
to bin change or octal value to bin change).


\subsubsection{Binary data representations}
\label{input/devices/walkera0701:binary-data-representations}
One binary and octal value can be grouped to nibble. 24 nibbles + one binary
values can be sampled between sync pulses.

Values for first four channels (analog joystick values) can be found in
first 10 nibbles. Analog value is represented by one sign bit and 9 bit
absolute binary value. (10 bits per channel). Next nibble is checksum for
first ten nibbles.

Next nibbles 12 .. 21 represents four channels (not all channels can be
directly controlled from TX). Binary representations are the same as in first
four channels. In nibbles 22 and 23 is a special magic number. Nibble 24 is
checksum for nibbles 12..23.

After last octal value for nibble 24 and next sync pulse one additional
binary value can be sampled. This bit and magic number is not used in
software driver. Some details about this magic numbers can be found in
Walkera\_Wk-0701\_PCM.pdf.


\subsubsection{Checksum calculation}
\label{input/devices/walkera0701:checksum-calculation}
Summary of octal values in nibbles must be same as octal value in checksum
nibble (only first 3 bits are used). Binary value for checksum nibble is
calculated by sum of binary values in checked nibbles + sum of octal values
in checked nibbles divided by 8. Only bit 0 of this sum is used.


\section{xpad - Linux USB driver for Xbox compatible controllers}
\label{input/devices/xpad:xpad-linux-usb-driver-for-xbox-compatible-controllers}\label{input/devices/xpad::doc}
This driver exposes all first-party and third-party Xbox compatible
controllers. It has a long history and has enjoyed considerable usage
as Window's xinput library caused most PC games to focus on Xbox
controller compatibility.

Due to backwards compatibility all buttons are reported as digital.
This only effects Original Xbox controllers. All later controller models
have only digital face buttons.

Rumble is supported on some models of Xbox 360 controllers but not of
Original Xbox controllers nor on Xbox One controllers. As of writing
the Xbox One's rumble protocol has not been reverse engineered but in
the future could be supported.


\subsection{Notes}
\label{input/devices/xpad:notes}
The number of buttons/axes reported varies based on 3 things:
\begin{itemize}
\item {} 
if you are using a known controller

\item {} 
if you are using a known dance pad

\item {} 
if using an unknown device (one not listed below), what you set in the
module configuration for ``Map D-PAD to buttons rather than axes for unknown
pads'' (module option dpad\_to\_buttons)

\end{itemize}

If you set dpad\_to\_buttons to N and you are using an unknown device
the driver will map the directional pad to axes (X/Y).
If you said Y it will map the d-pad to buttons, which is needed for dance
style games to function correctly. The default is Y.

dpad\_to\_buttons has no effect for known pads. A erroneous commit message
claimed dpad\_to\_buttons could be used to force behavior on known devices.
This is not true. Both dpad\_to\_buttons and triggers\_to\_buttons only affect
unknown controllers.


\subsubsection{Normal Controllers}
\label{input/devices/xpad:normal-controllers}
With a normal controller, the directional pad is mapped to its own X/Y axes.
The jstest-program from joystick-1.2.15 (jstest-version 2.1.0) will report 8
axes and 10 buttons.

All 8 axes work, though they all have the same range (-32768..32767)
and the zero-setting is not correct for the triggers (I don't know if that
is some limitation of jstest, since the input device setup should be fine. I
didn't have a look at jstest itself yet).

All of the 10 buttons work (in digital mode). The six buttons on the
right side (A, B, X, Y, black, white) are said to be ``analog'' and
report their values as 8 bit unsigned, not sure what this is good for.

I tested the controller with quake3, and configuration and
in game functionality were OK. However, I find it rather difficult to
play first person shooters with a pad. Your mileage may vary.


\subsubsection{Xbox Dance Pads}
\label{input/devices/xpad:xbox-dance-pads}
When using a known dance pad, jstest will report 6 axes and 14 buttons.

For dance style pads (like the redoctane pad) several changes
have been made.  The old driver would map the d-pad to axes, resulting
in the driver being unable to report when the user was pressing both
left+right or up+down, making DDR style games unplayable.

Known dance pads automatically map the d-pad to buttons and will work
correctly out of the box.

If your dance pad is recognized by the driver but is using axes instead
of buttons, see section 0.3 - Unknown Controllers

I've tested this with Stepmania, and it works quite well.


\subsubsection{Unknown Controllers}
\label{input/devices/xpad:unknown-controllers}
If you have an unknown xbox controller, it should work just fine with
the default settings.

HOWEVER if you have an unknown dance pad not listed below, it will not
work UNLESS you set ``dpad\_to\_buttons'' to 1 in the module configuration.


\subsection{USB adapters}
\label{input/devices/xpad:usb-adapters}
All generations of Xbox controllers speak USB over the wire.
\begin{itemize}
\item {} 
Original Xbox controllers use a proprietary connector and require adapters.

\item {} 
Wireless Xbox 360 controllers require a `Xbox 360 Wireless Gaming Receiver
for Windows'

\item {} 
Wired Xbox 360 controllers use standard USB connectors.

\item {} 
Xbox One controllers can be wireless but speak Wi-Fi Direct and are not
yet supported.

\item {} 
Xbox One controllers can be wired and use standard Micro-USB connectors.

\end{itemize}


\subsubsection{Original Xbox USB adapters}
\label{input/devices/xpad:original-xbox-usb-adapters}
Using this driver with an Original Xbox controller requires an
adapter cable to break out the proprietary connector's pins to USB.
You can buy these online fairly cheap, or build your own.

Such a cable is pretty easy to build. The Controller itself is a USB
compound device (a hub with three ports for two expansion slots and
the controller device) with the only difference in a nonstandard connector
(5 pins vs. 4 on standard USB 1.0 connectors).

You just need to solder a USB connector onto the cable and keep the
yellow wire unconnected. The other pins have the same order on both
connectors so there is no magic to it. Detailed info on these matters
can be found on the net (\footnote[1]{
\href{http://euc.jp/periphs/xbox-controller.ja.html}{http://euc.jp/periphs/xbox-controller.ja.html} (ITO Takayuki)
}, \footnote[2]{
\href{http://xpad.xbox-scene.com/}{http://xpad.xbox-scene.com/}
}, \footnote[3]{
\href{http://www.markosweb.com/www/xboxhackz.com/}{http://www.markosweb.com/www/xboxhackz.com/}
}).

Thanks to the trip splitter found on the cable you don't even need to cut the
original one. You can buy an extension cable and cut that instead. That way,
you can still use the controller with your X-Box, if you have one ;)


\subsection{Driver Installation}
\label{input/devices/xpad:driver-installation}
Once you have the adapter cable, if needed, and the controller connected
the xpad module should be auto loaded. To confirm you can cat
/sys/kernel/debug/usb/devices. There should be an entry like those:

\needspace{\literalblockneedspace}\vspace{\literalblockcaptiontopvspace}\captionof{literal-block}{dump from InterAct PowerPad Pro (Germany)}
\begin{Verbatim}[commandchars=\\\{\}]
 T:  Bus=01 Lev=03 Prnt=04 Port=00 Cnt=01 Dev\PYGZsh{}=  5 Spd=12  MxCh= 0
 D:  Ver= 1.10 Cls=00(\PYGZgt{}ifc ) Sub=00 Prot=00 MxPS=32 \PYGZsh{}Cfgs=  1
 P:  Vendor=05fd ProdID=107a Rev= 1.00
 C:* \PYGZsh{}Ifs= 1 Cfg\PYGZsh{}= 1 Atr=80 MxPwr=100mA
 I:  If\PYGZsh{}= 0 Alt= 0 \PYGZsh{}EPs= 2 Cls=58(unk. ) Sub=42 Prot=00 Driver=(none)
 E:  Ad=81(I) Atr=03(Int.) MxPS=  32 Ivl= 10ms
 E:  Ad=02(O) Atr=03(Int.) MxPS=  32 Ivl= 10ms
\end{Verbatim}
\phantomsection\label{input/devices/xpad:dump-from-interact-powerpad-pro-germany}

\needspace{\literalblockneedspace}\vspace{\literalblockcaptiontopvspace}\captionof{literal-block}{dump from Redoctane Xbox Dance Pad (US)}
\begin{Verbatim}[commandchars=\\\{\}]
 T:  Bus=01 Lev=02 Prnt=09 Port=00 Cnt=01 Dev\PYGZsh{}= 10 Spd=12  MxCh= 0
 D:  Ver= 1.10 Cls=00(\PYGZgt{}ifc ) Sub=00 Prot=00 MxPS= 8 \PYGZsh{}Cfgs=  1
 P:  Vendor=0c12 ProdID=8809 Rev= 0.01
 S:  Product=XBOX DDR
 C:* \PYGZsh{}Ifs= 1 Cfg\PYGZsh{}= 1 Atr=80 MxPwr=100mA
 I:  If\PYGZsh{}= 0 Alt= 0 \PYGZsh{}EPs= 2 Cls=58(unk. ) Sub=42 Prot=00 Driver=xpad
 E:  Ad=82(I) Atr=03(Int.) MxPS=  32 Ivl=4ms
 E:  Ad=02(O) Atr=03(Int.) MxPS=  32 Ivl=4ms
\end{Verbatim}
\phantomsection\label{input/devices/xpad:dump-from-redoctane-xbox-dance-pad-us}


\subsection{Supported Controllers}
\label{input/devices/xpad:supported-controllers}
For a full list of supported controllers and associated vendor and product
IDs see the xpad\_device{[}{]} array\footnote[4]{
\href{http://lxr.free-electrons.com/ident?i=xpad\_device}{http://lxr.free-electrons.com/ident?i=xpad\_device}
}.

As of the historic version 0.0.6 (2006-10-10) the following devices
were supported:

\begin{Verbatim}[commandchars=\\\{\}]
original Microsoft XBOX controller (US),    vendor=0x045e, product=0x0202
smaller  Microsoft XBOX controller (US),    vendor=0x045e, product=0x0289
original Microsoft XBOX controller (Japan), vendor=0x045e, product=0x0285
InterAct PowerPad Pro (Germany),            vendor=0x05fd, product=0x107a
RedOctane Xbox Dance Pad (US),              vendor=0x0c12, product=0x8809
\end{Verbatim}

Unrecognized models of Xbox controllers should function as Generic
Xbox controllers. Unrecognized Dance Pad controllers require setting
the module option `dpad\_to\_buttons'.

If you have an unrecognized controller please see 0.3 - Unknown Controllers


\subsection{Manual Testing}
\label{input/devices/xpad:manual-testing}
To test this driver's functionality you may use `jstest'.

For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZgt{} modprobe xpad
\PYGZgt{} modprobe joydev
\PYGZgt{} jstest /dev/js0
\end{Verbatim}

If you're using a normal controller, there should be a single line showing
18 inputs (8 axes, 10 buttons), and its values should change if you move
the sticks and push the buttons.  If you're using a dance pad, it should
show 20 inputs (6 axes, 14 buttons).

It works? Voila, you're done ;)


\subsection{Thanks}
\label{input/devices/xpad:thanks}\begin{description}
\item[{I have to thank ITO Takayuki for the detailed info on his site}] \leavevmode
\href{http://euc.jp/periphs/xbox-controller.ja.html}{http://euc.jp/periphs/xbox-controller.ja.html}.

\end{description}

His useful info and both the usb-skeleton as well as the iforce input driver
(Greg Kroah-Hartmann; Vojtech Pavlik) helped a lot in rapid prototyping
the basic functionality.


\subsection{References}
\label{input/devices/xpad:references}

\subsection{Historic Edits}
\label{input/devices/xpad:historic-edits}\begin{description}
\item[{2002-07-16 - Marko Friedemann \textless{}\href{mailto:mfr@bmx-chemnitz.de}{mfr@bmx-chemnitz.de}\textgreater{}}] \leavevmode\begin{itemize}
\item {} 
original doc

\end{itemize}

\item[{2005-03-19 - Dominic Cerquetti \textless{}\href{mailto:binary1230@yahoo.com}{binary1230@yahoo.com}\textgreater{}}] \leavevmode\begin{itemize}
\item {} 
added stuff for dance pads, new d-pad-\textgreater{}axes mappings

\end{itemize}

\end{description}

Later changes may be viewed with
`git log --follow Documentation/input/devices/xpad.rst'


\section{Driver documentation for yealink usb-p1k phones}
\label{input/devices/yealink:driver-documentation-for-yealink-usb-p1k-phones}\label{input/devices/yealink::doc}

\subsection{Status}
\label{input/devices/yealink:status}
The p1k is a relatively cheap usb 1.1 phone with:
\begin{itemize}
\item {} 
keyboard            full support, yealink.ko / input event API

\item {} 
LCD                 full support, yealink.ko / sysfs API

\item {} 
LED                 full support, yealink.ko / sysfs API

\item {} 
dialtone            full support, yealink.ko / sysfs API

\item {} 
ringtone            full support, yealink.ko / sysfs API

\item {} 
audio playback      full support, snd\_usb\_audio.ko / alsa API

\item {} 
audio record        full support, snd\_usb\_audio.ko / alsa API

\end{itemize}

For vendor documentation see \href{http://www.yealink.com}{http://www.yealink.com}


\subsection{keyboard features}
\label{input/devices/yealink:keyboard-features}
The current mapping in the kernel is provided by the map\_p1k\_to\_key
function:

\begin{Verbatim}[commandchars=\\\{\}]
Physical USB\PYGZhy{}P1K button layout       input events


           up                             up
     IN           OUT                left,   right
          down                           down

   pickup   C    hangup              enter, backspace, escape
     1      2      3                 1, 2, 3
     4      5      6                 4, 5, 6,
     7      8      9                 7, 8, 9,
     *      0      \PYGZsh{}                 *, 0, \PYGZsh{},
\end{Verbatim}

The ``up'' and ``down'' keys, are symbolised by arrows on the button.
The ``pickup'' and ``hangup'' keys are symbolised by a green and red phone
on the button.


\subsection{LCD features}
\label{input/devices/yealink:lcd-features}
The LCD is divided and organised as a 3 line display:

\begin{Verbatim}[commandchars=\\\{\}]
  \textbar{}[]   [][]   [][]   [][]   in   \textbar{}[][]
  \textbar{}[] M [][] D [][] : [][]   out  \textbar{}[][]
                            store

  NEW REP         SU MO TU WE TH FR SA

  [] [] [] [] [] [] [] [] [] [] [] []
  [] [] [] [] [] [] [] [] [] [] [] []


Line 1  Format (see below)    : 18.e8.M8.88...188
        Icon names            :   M  D  :  IN OUT STORE
Line 2  Format                : .........
        Icon name             : NEW REP SU MO TU WE TH FR SA
Line 3  Format                : 888888888888
\end{Verbatim}
\begin{description}
\item[{Format description:}] \leavevmode
From a userspace perspective the world is separated into ``digits'' and ``icons''.
A digit can have a character set, an icon can only be ON or OFF.

Format specifier:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsq{}8\PYGZsq{} :  Generic 7 segment digit with individual addressable segments

Reduced capability 7 segment digit, when segments are hard wired together.
\PYGZsq{}1\PYGZsq{} : 2 segments digit only able to produce a 1.
\PYGZsq{}e\PYGZsq{} : Most significant day of the month digit,
      able to produce at least 1 2 3.
\PYGZsq{}M\PYGZsq{} : Most significant minute digit,
      able to produce at least 0 1 2 3 4 5.

Icons or pictograms:
\PYGZsq{}.\PYGZsq{} : For example like AM, PM, SU, a \PYGZsq{}dot\PYGZsq{} .. or other single segment
      elements.
\end{Verbatim}

\end{description}


\subsection{Driver usage}
\label{input/devices/yealink:driver-usage}
For userland the following interfaces are available using the sysfs interface:

\begin{Verbatim}[commandchars=\\\{\}]
/sys/.../
         line1        Read/Write, lcd line1
         line2        Read/Write, lcd line2
         line3        Read/Write, lcd line3

         get\PYGZus{}icons    Read, returns a set of available icons.
         hide\PYGZus{}icon    Write, hide the element by writing the icon name.
         show\PYGZus{}icon    Write, display the element by writing the icon name.

         map\PYGZus{}seg7     Read/Write, the 7 segments char set, common for all
                      yealink phones. (see map\PYGZus{}to\PYGZus{}7segment.h)

         ringtone     Write, upload binary representation of a ringtone,
                      see yealink.c. status EXPERIMENTAL due to potential
                      races between async. and sync usb calls.
\end{Verbatim}


\subsubsection{lineX}
\label{input/devices/yealink:linex}
Reading /sys/../lineX will return the format string with its current value.
\begin{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
cat ./line3
888888888888
Linux Rocks!
\end{Verbatim}
\end{quote}

Writing to /sys/../lineX will set the corresponding LCD line.
\begin{quote}
\begin{itemize}
\item {} 
Excess characters are ignored.

\item {} 
If less characters are written than allowed, the remaining digits are
unchanged.

\item {} 
The tab `t'and `n' char does not overwrite the original content.

\item {} 
Writing a space to an icon will always hide its content.

\end{itemize}
\begin{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
date +\PYGZdq{}\PYGZpc{}m.\PYGZpc{}e.\PYGZpc{}k:\PYGZpc{}M\PYGZdq{}  \textbar{} sed \PYGZsq{}s/\PYGZca{}0/ /\PYGZsq{} \PYGZgt{} ./line1
\end{Verbatim}

Will update the LCD with the current date \& time.
\end{quote}
\end{quote}


\subsubsection{get\_icons}
\label{input/devices/yealink:get-icons}
Reading will return all available icon names and its current settings:

\begin{Verbatim}[commandchars=\\\{\}]
cat ./get\PYGZus{}icons
on M
on D
on :
   IN
   OUT
   STORE
   NEW
   REP
   SU
   MO
   TU
   WE
   TH
   FR
   SA
   LED
   DIALTONE
   RINGTONE
\end{Verbatim}


\subsubsection{show/hide icons}
\label{input/devices/yealink:show-hide-icons}
Writing to these files will update the state of the icon.
Only one icon at a time can be updated.

If an icon is also on a ./lineX the corresponding value is
updated with the first letter of the icon.
\begin{quote}

Example - light up the store icon:

\begin{Verbatim}[commandchars=\\\{\}]
echo \PYGZhy{}n \PYGZdq{}STORE\PYGZdq{} \PYGZgt{} ./show\PYGZus{}icon

cat ./line1
18.e8.M8.88...188
              S
\end{Verbatim}

Example - sound the ringtone for 10 seconds:

\begin{Verbatim}[commandchars=\\\{\}]
echo \PYGZhy{}n RINGTONE \PYGZgt{} /sys/..../show\PYGZus{}icon
sleep 10
echo \PYGZhy{}n RINGTONE \PYGZgt{} /sys/..../hide\PYGZus{}icon
\end{Verbatim}
\end{quote}


\subsection{Sound features}
\label{input/devices/yealink:sound-features}
Sound is supported by the ALSA driver: snd\_usb\_audio

One 16-bit channel with sample and playback rates of 8000 Hz is the practical
limit of the device.
\begin{quote}

Example - recording test:

\begin{Verbatim}[commandchars=\\\{\}]
arecord \PYGZhy{}v \PYGZhy{}d 10 \PYGZhy{}r 8000 \PYGZhy{}f S16\PYGZus{}LE \PYGZhy{}t wav  foobar.wav
\end{Verbatim}

Example - playback test:

\begin{Verbatim}[commandchars=\\\{\}]
aplay foobar.wav
\end{Verbatim}
\end{quote}


\subsection{Troubleshooting}
\label{input/devices/yealink:troubleshooting}\begin{quote}\begin{description}
\item[{Q}] \leavevmode
Module yealink compiled and installed without any problem but phone
is not initialized and does not react to any actions.

\item[{A}] \leavevmode
If you see something like:
hiddev0: USB HID v1.00 Device {[}Yealink Network Technology Ltd. VOIP USB Phone
in dmesg, it means that the hid driver has grabbed the device first. Try to
load module yealink before any other usb hid driver. Please see the
instructions provided by your distribution on module configuration.

\item[{Q}] \leavevmode
Phone is working now (displays version and accepts keypad input) but I can't
find the sysfs files.

\item[{A}] \leavevmode
The sysfs files are located on the particular usb endpoint. On most
distributions you can do: ``find /sys/ -name get\_icons'' for a hint.

\end{description}\end{quote}


\subsection{Credits \& Acknowledgments}
\label{input/devices/yealink:credits-acknowledgments}\begin{itemize}
\item {} 
Olivier Vandorpe, for starting the usbb2k-api project doing much of
the reverse engineering.

\item {} 
Martin Diehl, for pointing out how to handle USB memory allocation.

\item {} 
Dmitry Torokhov, for the numerous code reviews and suggestions.

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
