% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,8pt,english]{sphinxmanual}


\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }


	% Use some font with UTF-8 support with XeLaTeX
        \usepackage{fontspec}
        \setsansfont{DejaVu Serif}
        \setromanfont{DejaVu Sans}
        \setmonofont{DejaVu Sans Mono}

     \usepackage[margin=0.5in, top=1in, bottom=1in]{geometry}
        \usepackage{ifthen}

        % Put notes in color and let them be inside a table
	\definecolor{NoteColor}{RGB}{204,255,255}
	\definecolor{WarningColor}{RGB}{255,204,204}
	\definecolor{AttentionColor}{RGB}{255,255,204}
	\definecolor{ImportantColor}{RGB}{192,255,204}
	\definecolor{OtherColor}{RGB}{204,204,204}
        \newlength{\mynoticelength}
        \makeatletter\newenvironment{coloredbox}[1]{%
	   \setlength{\fboxrule}{1pt}
	   \setlength{\fboxsep}{7pt}
	   \setlength{\mynoticelength}{\linewidth}
	   \addtolength{\mynoticelength}{-2\fboxsep}
	   \addtolength{\mynoticelength}{-2\fboxrule}
           \begin{lrbox}{\@tempboxa}\begin{minipage}{\mynoticelength}}{\end{minipage}\end{lrbox}%
	   \ifthenelse%
	      {\equal{\py@noticetype}{note}}%
	      {\colorbox{NoteColor}{\usebox{\@tempboxa}}}%
	      {%
	         \ifthenelse%
	         {\equal{\py@noticetype}{warning}}%
	         {\colorbox{WarningColor}{\usebox{\@tempboxa}}}%
		 {%
	            \ifthenelse%
	            {\equal{\py@noticetype}{attention}}%
	            {\colorbox{AttentionColor}{\usebox{\@tempboxa}}}%
		    {%
	               \ifthenelse%
	               {\equal{\py@noticetype}{important}}%
	               {\colorbox{ImportantColor}{\usebox{\@tempboxa}}}%
	               {\colorbox{OtherColor}{\usebox{\@tempboxa}}}%
		    }%
		 }%
	      }%
        }\makeatother

        \makeatletter
        \renewenvironment{notice}[2]{%
          \def\py@noticetype{#1}
          \begin{coloredbox}{#1}
          \bf\it
          \par\strong{#2}
          \csname py@noticestart@#1\endcsname
        }
	{
          \csname py@noticeend@\py@noticetype\endcsname
          \end{coloredbox}
        }
	\makeatother

     

\title{Unreliable Guide To Hacking The Linux Kernel}
\date{March 08, 2018}
\release{4.16.0-rc4+}
\author{The kernel development community}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\setcounter{tocdepth}{1}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{kernel-hacking/index::doc}



\chapter{Unreliable Guide To Hacking The Linux Kernel}
\label{kernel-hacking/hacking:kernel-hacking-guides}\label{kernel-hacking/hacking::doc}\label{kernel-hacking/hacking:unreliable-guide-to-hacking-the-linux-kernel}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Rusty Russell

\end{description}\end{quote}


\section{Introduction}
\label{kernel-hacking/hacking:introduction}
Welcome, gentle reader, to Rusty's Remarkably Unreliable Guide to Linux
Kernel Hacking. This document describes the common routines and general
requirements for kernel code: its goal is to serve as a primer for Linux
kernel development for experienced C programmers. I avoid implementation
details: that's what the code is for, and I ignore whole tracts of
useful routines.

Before you read this, please understand that I never wanted to write
this document, being grossly under-qualified, but I always wanted to
read it, and this was the only way. I hope it will grow into a
compendium of best practice, common starting points and random
information.


\section{The Players}
\label{kernel-hacking/hacking:the-players}
At any time each of the CPUs in a system can be:
\begin{itemize}
\item {} 
not associated with any process, serving a hardware interrupt;

\item {} 
not associated with any process, serving a softirq or tasklet;

\item {} 
running in kernel space, associated with a process (user context);

\item {} 
running a process in user space.

\end{itemize}

There is an ordering between these. The bottom two can preempt each
other, but above that is a strict hierarchy: each can only be preempted
by the ones above it. For example, while a softirq is running on a CPU,
no other softirq will preempt it, but a hardware interrupt can. However,
any other CPUs in the system execute independently.

We'll see a number of ways that the user context can block interrupts,
to become truly non-preemptable.


\subsection{User Context}
\label{kernel-hacking/hacking:user-context}
User context is when you are coming in from a system call or other trap:
like userspace, you can be preempted by more important tasks and by
interrupts. You can sleep, by calling \code{schedule()}.

\begin{notice}{note}{Note:}
You are always in user context on module load and unload, and on
operations on the block device layer.
\end{notice}

In user context, the \code{current} pointer (indicating the task we are
currently executing) is valid, and \code{in\_interrupt()}
(\code{include/linux/preempt.h}) is false.

\begin{notice}{warning}{Warning:}
Beware that if you have preemption or softirqs disabled (see below),
\code{in\_interrupt()} will return a false positive.
\end{notice}


\subsection{Hardware Interrupts (Hard IRQs)}
\label{kernel-hacking/hacking:hardware-interrupts-hard-irqs}
Timer ticks, network cards and keyboard are examples of real hardware
which produce interrupts at any time. The kernel runs interrupt
handlers, which services the hardware. The kernel guarantees that this
handler is never re-entered: if the same interrupt arrives, it is queued
(or dropped). Because it disables interrupts, this handler has to be
fast: frequently it simply acknowledges the interrupt, marks a `software
interrupt' for execution and exits.

You can tell you are in a hardware interrupt, because
\code{in\_irq()} returns true.

\begin{notice}{warning}{Warning:}
Beware that this will return a false positive if interrupts are
disabled (see below).
\end{notice}


\subsection{Software Interrupt Context: Softirqs and Tasklets}
\label{kernel-hacking/hacking:software-interrupt-context-softirqs-and-tasklets}
Whenever a system call is about to return to userspace, or a hardware
interrupt handler exits, any `software interrupts' which are marked
pending (usually by hardware interrupts) are run (\code{kernel/softirq.c}).

Much of the real interrupt handling work is done here. Early in the
transition to SMP, there were only `bottom halves' (BHs), which didn't
take advantage of multiple CPUs. Shortly after we switched from wind-up
computers made of match-sticks and snot, we abandoned this limitation
and switched to `softirqs'.

\code{include/linux/interrupt.h} lists the different softirqs. A very
important softirq is the timer softirq (\code{include/linux/timer.h}): you
can register to have it call functions for you in a given length of
time.

Softirqs are often a pain to deal with, since the same softirq will run
simultaneously on more than one CPU. For this reason, tasklets
(\code{include/linux/interrupt.h}) are more often used: they are
dynamically-registrable (meaning you can have as many as you want), and
they also guarantee that any tasklet will only run on one CPU at any
time, although different tasklets can run simultaneously.

\begin{notice}{warning}{Warning:}
The name `tasklet' is misleading: they have nothing to do with
`tasks', and probably more to do with some bad vodka Alexey
Kuznetsov had at the time.
\end{notice}

You can tell you are in a softirq (or tasklet) using the
\code{in\_softirq()} macro (\code{include/linux/preempt.h}).

\begin{notice}{warning}{Warning:}
Beware that this will return a false positive if a
{\hyperref[kernel\string-hacking/hacking:local\string-bh\string-disable]{\emph{botton half lock}}} is held.
\end{notice}


\section{Some Basic Rules}
\label{kernel-hacking/hacking:some-basic-rules}\begin{description}
\item[{No memory protection}] \leavevmode
If you corrupt memory, whether in user context or interrupt context,
the whole machine will crash. Are you sure you can't do what you
want in userspace?

\item[{No floating point or MMX}] \leavevmode
The FPU context is not saved; even in user context the FPU state
probably won't correspond with the current process: you would mess
with some user process' FPU state. If you really want to do this,
you would have to explicitly save/restore the full FPU state (and
avoid context switches). It is generally a bad idea; use fixed point
arithmetic first.

\item[{A rigid stack limit}] \leavevmode
Depending on configuration options the kernel stack is about 3K to
6K for most 32-bit architectures: it's about 14K on most 64-bit
archs, and often shared with interrupts so you can't use it all.
Avoid deep recursion and huge local arrays on the stack (allocate
them dynamically instead).

\item[{The Linux kernel is portable}] \leavevmode
Let's keep it that way. Your code should be 64-bit clean, and
endian-independent. You should also minimize CPU specific stuff,
e.g. inline assembly should be cleanly encapsulated and minimized to
ease porting. Generally it should be restricted to the
architecture-dependent part of the kernel tree.

\end{description}


\section{ioctls: Not writing a new system call}
\label{kernel-hacking/hacking:ioctls-not-writing-a-new-system-call}
A system call generally looks like this:

\begin{Verbatim}[commandchars=\\\{\}]
asmlinkage long sys\PYGZus{}mycall(int arg)
\PYGZob{}
        return 0;
\PYGZcb{}
\end{Verbatim}

First, in most cases you don't want to create a new system call. You
create a character device and implement an appropriate ioctl for it.
This is much more flexible than system calls, doesn't have to be entered
in every architecture's \code{include/asm/unistd.h} and
\code{arch/kernel/entry.S} file, and is much more likely to be accepted by
Linus.

If all your routine does is read or write some parameter, consider
implementing a \code{sysfs()} interface instead.

Inside the ioctl you're in user context to a process. When a error
occurs you return a negated errno (see
\code{include/uapi/asm-generic/errno-base.h},
\code{include/uapi/asm-generic/errno.h} and \code{include/linux/errno.h}),
otherwise you return 0.

After you slept you should check if a signal occurred: the Unix/Linux
way of handling signals is to temporarily exit the system call with the
\code{-ERESTARTSYS} error. The system call entry code will switch back to
user context, process the signal handler and then your system call will
be restarted (unless the user disabled that). So you should be prepared
to process the restart, e.g. if you're in the middle of manipulating
some data structure.

\begin{Verbatim}[commandchars=\\\{\}]
if (signal\PYGZus{}pending(current))
        return \PYGZhy{}ERESTARTSYS;
\end{Verbatim}

If you're doing longer computations: first think userspace. If you
\textbf{really} want to do it in kernel you should regularly check if you need
to give up the CPU (remember there is cooperative multitasking per CPU).
Idiom:

\begin{Verbatim}[commandchars=\\\{\}]
cond\PYGZus{}resched(); /* Will sleep */
\end{Verbatim}

A short note on interface design: the UNIX system call motto is ``Provide
mechanism not policy''.


\section{Recipes for Deadlock}
\label{kernel-hacking/hacking:recipes-for-deadlock}
You cannot call any routines which may sleep, unless:
\begin{itemize}
\item {} 
You are in user context.

\item {} 
You do not own any spinlocks.

\item {} 
You have interrupts enabled (actually, Andi Kleen says that the
scheduling code will enable them for you, but that's probably not
what you wanted).

\end{itemize}

Note that some functions may sleep implicitly: common ones are the user
space access functions (*\_user) and memory allocation functions
without \code{GFP\_ATOMIC}.

You should always compile your kernel \code{CONFIG\_DEBUG\_ATOMIC\_SLEEP} on,
and it will warn you if you break these rules. If you \textbf{do} break the
rules, you will eventually lock up your box.

Really.


\section{Common Routines}
\label{kernel-hacking/hacking:common-routines}

\subsection{\texttt{printk()}}
\label{kernel-hacking/hacking:printk}
Defined in \code{include/linux/printk.h}

\code{printk()} feeds kernel messages to the console, dmesg, and
the syslog daemon. It is useful for debugging and reporting errors, and
can be used inside interrupt context, but use with caution: a machine
which has its console flooded with printk messages is unusable. It uses
a format string mostly compatible with ANSI C printf, and C string
concatenation to give it a first ``priority'' argument:

\begin{Verbatim}[commandchars=\\\{\}]
printk(KERN\PYGZus{}INFO \PYGZdq{}i = \PYGZpc{}u\PYGZbs{}n\PYGZdq{}, i);
\end{Verbatim}

See \code{include/linux/kern\_levels.h}; for other \code{KERN\_} values; these are
interpreted by syslog as the level. Special case: for printing an IP
address use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZus{}\PYGZus{}be32 ipaddress;
printk(KERN\PYGZus{}INFO \PYGZdq{}my ip: \PYGZpc{}pI4\PYGZbs{}n\PYGZdq{}, \PYGZam{}ipaddress);
\end{Verbatim}

\code{printk()} internally uses a 1K buffer and does not catch
overruns. Make sure that will be enough.

\begin{notice}{note}{Note:}
You will know when you are a real kernel hacker when you start
typoing printf as printk in your user programs :)
\end{notice}

\begin{notice}{note}{Note:}
Another sidenote: the original Unix Version 6 sources had a comment
on top of its printf function: ``Printf should not be used for
chit-chat''. You should follow that advice.
\end{notice}


\subsection{\texttt{copy\_to\_user()} / \texttt{copy\_from\_user()} / \texttt{get\_user()} / \texttt{put\_user()}}
\label{kernel-hacking/hacking:copy-to-user-copy-from-user-get-user-put-user}
Defined in \code{include/linux/uaccess.h} / \code{asm/uaccess.h}

\textbf{{[}SLEEPS{]}}

\code{put\_user()} and \code{get\_user()} are used to get
and put single values (such as an int, char, or long) from and to
userspace. A pointer into userspace should never be simply dereferenced:
data should be copied using these routines. Both return \code{-EFAULT} or
0.

\code{copy\_to\_user()} and \code{copy\_from\_user()} are
more general: they copy an arbitrary amount of data to and from
userspace.

\begin{notice}{warning}{Warning:}
Unlike \code{put\_user()} and \code{get\_user()}, they
return the amount of uncopied data (ie. 0 still means success).
\end{notice}

{[}Yes, this moronic interface makes me cringe. The flamewar comes up
every year or so. --RR.{]}

The functions may sleep implicitly. This should never be called outside
user context (it makes no sense), with interrupts disabled, or a
spinlock held.


\subsection{\texttt{kmalloc()}/\texttt{kfree()}}
\label{kernel-hacking/hacking:kmalloc-kfree}
Defined in \code{include/linux/slab.h}

\textbf{{[}MAY SLEEP: SEE BELOW{]}}

These routines are used to dynamically request pointer-aligned chunks of
memory, like malloc and free do in userspace, but
\code{kmalloc()} takes an extra flag word. Important values:
\begin{description}
\item[{\code{GFP\_KERNEL}}] \leavevmode
May sleep and swap to free memory. Only allowed in user context, but
is the most reliable way to allocate memory.

\item[{\code{GFP\_ATOMIC}}] \leavevmode
Don't sleep. Less reliable than \code{GFP\_KERNEL}, but may be called
from interrupt context. You should \textbf{really} have a good
out-of-memory error-handling strategy.

\item[{\code{GFP\_DMA}}] \leavevmode
Allocate ISA DMA lower than 16MB. If you don't know what that is you
don't need it. Very unreliable.

\end{description}

If you see a sleeping function called from invalid context warning
message, then maybe you called a sleeping allocation function from
interrupt context without \code{GFP\_ATOMIC}. You should really fix that.
Run, don't walk.

If you are allocating at least \code{PAGE\_SIZE} (\code{asm/page.h} or
\code{asm/page\_types.h}) bytes, consider using \code{\_\_get\_free\_pages()}
(\code{include/linux/gfp.h}). It takes an order argument (0 for page sized,
1 for double page, 2 for four pages etc.) and the same memory priority
flag word as above.

If you are allocating more than a page worth of bytes you can use
\code{vmalloc()}. It'll allocate virtual memory in the kernel
map. This block is not contiguous in physical memory, but the MMU makes
it look like it is for you (so it'll only look contiguous to the CPUs,
not to external device drivers). If you really need large physically
contiguous memory for some weird device, you have a problem: it is
poorly supported in Linux because after some time memory fragmentation
in a running kernel makes it hard. The best way is to allocate the block
early in the boot process via the \code{alloc\_bootmem()}
routine.

Before inventing your own cache of often-used objects consider using a
slab cache in \code{include/linux/slab.h}


\subsection{\texttt{current()}}
\label{kernel-hacking/hacking:current}
Defined in \code{include/asm/current.h}

This global variable (really a macro) contains a pointer to the current
task structure, so is only valid in user context. For example, when a
process makes a system call, this will point to the task structure of
the calling process. It is \textbf{not NULL} in interrupt context.


\subsection{\texttt{mdelay()}/\texttt{udelay()}}
\label{kernel-hacking/hacking:mdelay-udelay}
Defined in \code{include/asm/delay.h} / \code{include/linux/delay.h}

The \code{udelay()} and \code{ndelay()} functions can be
used for small pauses. Do not use large values with them as you risk
overflow - the helper function \code{mdelay()} is useful here, or
consider \code{msleep()}.


\subsection{\texttt{cpu\_to\_be32()}/\texttt{be32\_to\_cpu()}/\texttt{cpu\_to\_le32()}/\texttt{le32\_to\_cpu()}}
\label{kernel-hacking/hacking:cpu-to-be32-be32-to-cpu-cpu-to-le32-le32-to-cpu}
Defined in \code{include/asm/byteorder.h}

The \code{cpu\_to\_be32()} family (where the ``32'' can be replaced
by 64 or 16, and the ``be'' can be replaced by ``le'') are the general way
to do endian conversions in the kernel: they return the converted value.
All variations supply the reverse as well:
\code{be32\_to\_cpu()}, etc.

There are two major variations of these functions: the pointer
variation, such as \code{cpu\_to\_be32p()}, which take a pointer
to the given type, and return the converted value. The other variation
is the ``in-situ'' family, such as \code{cpu\_to\_be32s()}, which
convert value referred to by the pointer, and return void.


\subsection{\texttt{local\_irq\_save()}/\texttt{local\_irq\_restore()}}
\label{kernel-hacking/hacking:local-irq-save-local-irq-restore}
Defined in \code{include/linux/irqflags.h}

These routines disable hard interrupts on the local CPU, and restore
them. They are reentrant; saving the previous state in their one
\code{unsigned long flags} argument. If you know that interrupts are
enabled, you can simply use \code{local\_irq\_disable()} and
\code{local\_irq\_enable()}.


\subsection{\texttt{local\_bh\_disable()}/\texttt{local\_bh\_enable()}}
\label{kernel-hacking/hacking:local-bh-disable}\label{kernel-hacking/hacking:local-bh-disable-local-bh-enable}
Defined in \code{include/linux/bottom\_half.h}

These routines disable soft interrupts on the local CPU, and restore
them. They are reentrant; if soft interrupts were disabled before, they
will still be disabled after this pair of functions has been called.
They prevent softirqs and tasklets from running on the current CPU.


\subsection{\texttt{smp\_processor\_id()}}
\label{kernel-hacking/hacking:smp-processor-id}
Defined in \code{include/linux/smp.h}

\code{get\_cpu()} disables preemption (so you won't suddenly get
moved to another CPU) and returns the current processor number, between
0 and \code{NR\_CPUS}. Note that the CPU numbers are not necessarily
continuous. You return it again with \code{put\_cpu()} when you
are done.

If you know you cannot be preempted by another task (ie. you are in
interrupt context, or have preemption disabled) you can use
smp\_processor\_id().


\subsection{\texttt{\_\_init}/\texttt{\_\_exit}/\texttt{\_\_initdata}}
\label{kernel-hacking/hacking:init-exit-initdata}
Defined in  \code{include/linux/init.h}

After boot, the kernel frees up a special section; functions marked with
\code{\_\_init} and data structures marked with \code{\_\_initdata} are dropped
after boot is complete: similarly modules discard this memory after
initialization. \code{\_\_exit} is used to declare a function which is only
required on exit: the function will be dropped if this file is not
compiled as a module. See the header file for use. Note that it makes no
sense for a function marked with \code{\_\_init} to be exported to modules
with \code{EXPORT\_SYMBOL()} or \code{EXPORT\_SYMBOL\_GPL()}- this
will break.


\subsection{\texttt{\_\_initcall()}/\texttt{module\_init()}}
\label{kernel-hacking/hacking:initcall-module-init}
Defined in  \code{include/linux/init.h} / \code{include/linux/module.h}

Many parts of the kernel are well served as a module
(dynamically-loadable parts of the kernel). Using the
\code{module\_init()} and \code{module\_exit()} macros it
is easy to write code without \#ifdefs which can operate both as a module
or built into the kernel.

The \code{module\_init()} macro defines which function is to be
called at module insertion time (if the file is compiled as a module),
or at boot time: if the file is not compiled as a module the
\code{module\_init()} macro becomes equivalent to
\code{\_\_initcall()}, which through linker magic ensures that
the function is called on boot.

The function can return a negative error number to cause module loading
to fail (unfortunately, this has no effect if the module is compiled
into the kernel). This function is called in user context with
interrupts enabled, so it can sleep.


\subsection{\texttt{module\_exit()}}
\label{kernel-hacking/hacking:module-exit}
Defined in  \code{include/linux/module.h}

This macro defines the function to be called at module removal time (or
never, in the case of the file compiled into the kernel). It will only
be called if the module usage count has reached zero. This function can
also sleep, but cannot fail: everything must be cleaned up by the time
it returns.

Note that this macro is optional: if it is not present, your module will
not be removable (except for `rmmod -f').


\subsection{\texttt{try\_module\_get()}/\texttt{module\_put()}}
\label{kernel-hacking/hacking:try-module-get-module-put}
Defined in \code{include/linux/module.h}

These manipulate the module usage count, to protect against removal (a
module also can't be removed if another module uses one of its exported
symbols: see below). Before calling into module code, you should call
\code{try\_module\_get()} on that module: if it fails, then the
module is being removed and you should act as if it wasn't there.
Otherwise, you can safely enter the module, and call
\code{module\_put()} when you're finished.

Most registerable structures have an owner field, such as in the
\code{struct file\_operations} structure.
Set this field to the macro \code{THIS\_MODULE}.


\section{Wait Queues \texttt{include/linux/wait.h}}
\label{kernel-hacking/hacking:wait-queues-include-linux-wait-h}
\textbf{{[}SLEEPS{]}}

A wait queue is used to wait for someone to wake you up when a certain
condition is true. They must be used carefully to ensure there is no
race condition. You declare a \code{wait\_queue\_head\_t}, and then processes
which want to wait for that condition declare a \code{wait\_queue\_entry\_t}
referring to themselves, and place that in the queue.


\subsection{Declaring}
\label{kernel-hacking/hacking:declaring}
You declare a \code{wait\_queue\_head\_t} using the
\code{DECLARE\_WAIT\_QUEUE\_HEAD()} macro, or using the
\code{init\_waitqueue\_head()} routine in your initialization
code.


\subsection{Queuing}
\label{kernel-hacking/hacking:queuing}
Placing yourself in the waitqueue is fairly complex, because you must
put yourself in the queue before checking the condition. There is a
macro to do this: \code{wait\_event\_interruptible()}
(\code{include/linux/wait.h}) The first argument is the wait queue head, and
the second is an expression which is evaluated; the macro returns 0 when
this expression is true, or \code{-ERESTARTSYS} if a signal is received. The
\code{wait\_event()} version ignores signals.


\subsection{Waking Up Queued Tasks}
\label{kernel-hacking/hacking:waking-up-queued-tasks}
Call \code{wake\_up()} (\code{include/linux/wait.h}), which will wake
up every process in the queue. The exception is if one has
\code{TASK\_EXCLUSIVE} set, in which case the remainder of the queue will
not be woken. There are other variants of this basic function available
in the same header.


\section{Atomic Operations}
\label{kernel-hacking/hacking:atomic-operations}
Certain operations are guaranteed atomic on all platforms. The first
class of operations work on \code{atomic\_t} (\code{include/asm/atomic.h});
this contains a signed integer (at least 32 bits long), and you must use
these functions to manipulate or read \code{atomic\_t} variables.
\code{atomic\_read()} and \code{atomic\_set()} get and set
the counter, \code{atomic\_add()}, \code{atomic\_sub()},
\code{atomic\_inc()}, \code{atomic\_dec()}, and
\code{atomic\_dec\_and\_test()} (returns true if it was
decremented to zero).

Yes. It returns true (i.e. != 0) if the atomic variable is zero.

Note that these functions are slower than normal arithmetic, and so
should not be used unnecessarily.

The second class of atomic operations is atomic bit operations on an
\code{unsigned long}, defined in \code{include/linux/bitops.h}. These
operations generally take a pointer to the bit pattern, and a bit
number: 0 is the least significant bit. \code{set\_bit()},
\code{clear\_bit()} and \code{change\_bit()} set, clear,
and flip the given bit. \code{test\_and\_set\_bit()},
\code{test\_and\_clear\_bit()} and
\code{test\_and\_change\_bit()} do the same thing, except return
true if the bit was previously set; these are particularly useful for
atomically setting flags.

It is possible to call these operations with bit indices greater than
\code{BITS\_PER\_LONG}. The resulting behavior is strange on big-endian
platforms though so it is a good idea not to do this.


\section{Symbols}
\label{kernel-hacking/hacking:symbols}
Within the kernel proper, the normal linking rules apply (ie. unless a
symbol is declared to be file scope with the \code{static} keyword, it can
be used anywhere in the kernel). However, for modules, a special
exported symbol table is kept which limits the entry points to the
kernel proper. Modules can also export symbols.


\subsection{\texttt{EXPORT\_SYMBOL()}}
\label{kernel-hacking/hacking:export-symbol}
Defined in \code{include/linux/export.h}

This is the classic method of exporting a symbol: dynamically loaded
modules will be able to use the symbol as normal.


\subsection{\texttt{EXPORT\_SYMBOL\_GPL()}}
\label{kernel-hacking/hacking:export-symbol-gpl}
Defined in \code{include/linux/export.h}

Similar to \code{EXPORT\_SYMBOL()} except that the symbols
exported by \code{EXPORT\_SYMBOL\_GPL()} can only be seen by
modules with a \code{MODULE\_LICENSE()} that specifies a GPL
compatible license. It implies that the function is considered an
internal implementation issue, and not really an interface. Some
maintainers and developers may however require EXPORT\_SYMBOL\_GPL()
when adding any new APIs or functionality.


\section{Routines and Conventions}
\label{kernel-hacking/hacking:routines-and-conventions}

\subsection{Double-linked lists \texttt{include/linux/list.h}}
\label{kernel-hacking/hacking:double-linked-lists-include-linux-list-h}
There used to be three sets of linked-list routines in the kernel
headers, but this one is the winner. If you don't have some particular
pressing need for a single list, it's a good choice.

In particular, \code{list\_for\_each\_entry()} is useful.


\subsection{Return Conventions}
\label{kernel-hacking/hacking:return-conventions}
For code called in user context, it's very common to defy C convention,
and return 0 for success, and a negative error number (eg. \code{-EFAULT}) for
failure. This can be unintuitive at first, but it's fairly widespread in
the kernel.

Using \code{ERR\_PTR()} (\code{include/linux/err.h}) to encode a
negative error number into a pointer, and \code{IS\_ERR()} and
\code{PTR\_ERR()} to get it back out again: avoids a separate
pointer parameter for the error number. Icky, but in a good way.


\subsection{Breaking Compilation}
\label{kernel-hacking/hacking:breaking-compilation}
Linus and the other developers sometimes change function or structure
names in development kernels; this is not done just to keep everyone on
their toes: it reflects a fundamental change (eg. can no longer be
called with interrupts on, or does extra checks, or doesn't do checks
which were caught before). Usually this is accompanied by a fairly
complete note to the linux-kernel mailing list; search the archive.
Simply doing a global replace on the file usually makes things \textbf{worse}.


\subsection{Initializing structure members}
\label{kernel-hacking/hacking:initializing-structure-members}
The preferred method of initializing structures is to use designated
initialisers, as defined by ISO C99, eg:

\begin{Verbatim}[commandchars=\\\{\}]
static struct block\PYGZus{}device\PYGZus{}operations opt\PYGZus{}fops = \PYGZob{}
        .open               = opt\PYGZus{}open,
        .release            = opt\PYGZus{}release,
        .ioctl              = opt\PYGZus{}ioctl,
        .check\PYGZus{}media\PYGZus{}change = opt\PYGZus{}media\PYGZus{}change,
\PYGZcb{};
\end{Verbatim}

This makes it easy to grep for, and makes it clear which structure
fields are set. You should do this because it looks cool.


\subsection{GNU Extensions}
\label{kernel-hacking/hacking:gnu-extensions}
GNU Extensions are explicitly allowed in the Linux kernel. Note that
some of the more complex ones are not very well supported, due to lack
of general use, but the following are considered standard (see the GCC
info page section ``C Extensions'' for more details - Yes, really the info
page, the man page is only a short summary of the stuff in info).
\begin{itemize}
\item {} 
Inline functions

\item {} 
Statement expressions (ie. the (\{ and \}) constructs).

\item {} 
Declaring attributes of a function / variable / type
(\_\_attribute\_\_)

\item {} 
typeof

\item {} 
Zero length arrays

\item {} 
Macro varargs

\item {} 
Arithmetic on void pointers

\item {} 
Non-Constant initializers

\item {} 
Assembler Instructions (not outside arch/ and include/asm/)

\item {} 
Function names as strings (\_\_func\_\_).

\item {} 
\_\_builtin\_constant\_p()

\end{itemize}

Be wary when using long long in the kernel, the code gcc generates for
it is horrible and worse: division and multiplication does not work on
i386 because the GCC runtime functions for it are missing from the
kernel environment.


\subsection{C++}
\label{kernel-hacking/hacking:c}
Using C++ in the kernel is usually a bad idea, because the kernel does
not provide the necessary runtime environment and the include files are
not tested for it. It is still possible, but not recommended. If you
really want to do this, forget about exceptions at least.


\subsection{\#if}
\label{kernel-hacking/hacking:if}
It is generally considered cleaner to use macros in header files (or at
the top of .c files) to abstract away functions rather than using {}`\#if'
pre-processor statements throughout the source code.


\section{Putting Your Stuff in the Kernel}
\label{kernel-hacking/hacking:putting-your-stuff-in-the-kernel}
In order to get your stuff into shape for official inclusion, or even to
make a neat patch, there's administrative work to be done:
\begin{itemize}
\item {} 
Figure out whose pond you've been pissing in. Look at the top of the
source files, inside the \code{MAINTAINERS} file, and last of all in the
\code{CREDITS} file. You should coordinate with this person to make sure
you're not duplicating effort, or trying something that's already
been rejected.

Make sure you put your name and EMail address at the top of any files
you create or mangle significantly. This is the first place people
will look when they find a bug, or when \textbf{they} want to make a change.

\item {} 
Usually you want a configuration option for your kernel hack. Edit
\code{Kconfig} in the appropriate directory. The Config language is
simple to use by cut and paste, and there's complete documentation in
\code{Documentation/kbuild/kconfig-language.txt}.

In your description of the option, make sure you address both the
expert user and the user who knows nothing about your feature.
Mention incompatibilities and issues here. \textbf{Definitely} end your
description with “if in doubt, say N” (or, occasionally, {}`Y'); this
is for people who have no idea what you are talking about.

\item {} 
Edit the \code{Makefile}: the CONFIG variables are exported here so you
can usually just add a ``obj-\$(CONFIG\_xxx) += xxx.o'' line. The syntax
is documented in \code{Documentation/kbuild/makefiles.txt}.

\item {} 
Put yourself in \code{CREDITS} if you've done something noteworthy,
usually beyond a single file (your name should be at the top of the
source files anyway). \code{MAINTAINERS} means you want to be consulted
when changes are made to a subsystem, and hear about bugs; it implies
a more-than-passing commitment to some part of the code.

\item {} 
Finally, don't forget to read
\code{Documentation/process/submitting-patches.rst} and possibly
\code{Documentation/process/submitting-drivers.rst}.

\end{itemize}


\section{Kernel Cantrips}
\label{kernel-hacking/hacking:kernel-cantrips}
Some favorites from browsing the source. Feel free to add to this list.

\code{arch/x86/include/asm/delay.h}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}define ndelay(n) (\PYGZus{}\PYGZus{}builtin\PYGZus{}constant\PYGZus{}p(n) ? \PYGZbs{}
        ((n) \PYGZgt{} 20000 ? \PYGZus{}\PYGZus{}bad\PYGZus{}ndelay() : \PYGZus{}\PYGZus{}const\PYGZus{}udelay((n) * 5ul)) : \PYGZbs{}
        \PYGZus{}\PYGZus{}ndelay(n))
\end{Verbatim}

\code{include/linux/fs.h}:

\begin{Verbatim}[commandchars=\\\{\}]
/*
 * Kernel pointers have redundant information, so we can use a
 * scheme where we can return either an error code or a dentry
 * pointer with the same return value.
 *
 * This should be a per\PYGZhy{}architecture thing, to allow different
 * error and pointer decisions.
 */
 \PYGZsh{}define ERR\PYGZus{}PTR(err)    ((void *)((long)(err)))
 \PYGZsh{}define PTR\PYGZus{}ERR(ptr)    ((long)(ptr))
 \PYGZsh{}define IS\PYGZus{}ERR(ptr)     ((unsigned long)(ptr) \PYGZgt{} (unsigned long)(\PYGZhy{}1000))
\end{Verbatim}

\code{arch/x86/include/asm/uaccess\_32.h:}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}define copy\PYGZus{}to\PYGZus{}user(to,from,n)                         \PYGZbs{}
        (\PYGZus{}\PYGZus{}builtin\PYGZus{}constant\PYGZus{}p(n) ?                      \PYGZbs{}
         \PYGZus{}\PYGZus{}constant\PYGZus{}copy\PYGZus{}to\PYGZus{}user((to),(from),(n)) :     \PYGZbs{}
         \PYGZus{}\PYGZus{}generic\PYGZus{}copy\PYGZus{}to\PYGZus{}user((to),(from),(n)))
\end{Verbatim}

\code{arch/sparc/kernel/head.S:}:

\begin{Verbatim}[commandchars=\\\{\}]
/*
 * Sun people can\PYGZsq{}t spell worth damn. \PYGZdq{}compatability\PYGZdq{} indeed.
 * At least we *know* we can\PYGZsq{}t spell, and use a spell\PYGZhy{}checker.
 */

/* Uh, actually Linus it is I who cannot spell. Too much murky
 * Sparc assembly will do this to ya.
 */
C\PYGZus{}LABEL(cputypvar):
        .asciz \PYGZdq{}compatibility\PYGZdq{}

/* Tested on SS\PYGZhy{}5, SS\PYGZhy{}10. Probably someone at Sun applied a spell\PYGZhy{}checker. */
        .align 4
C\PYGZus{}LABEL(cputypvar\PYGZus{}sun4m):
        .asciz \PYGZdq{}compatible\PYGZdq{}
\end{Verbatim}

\code{arch/sparc/lib/checksum.S:}:

\begin{Verbatim}[commandchars=\\\{\}]
/* Sun, you just can\PYGZsq{}t beat me, you just can\PYGZsq{}t.  Stop trying,
 * give up.  I\PYGZsq{}m serious, I am going to kick the living shit
 * out of you, game over, lights out.
 */
\end{Verbatim}


\section{Thanks}
\label{kernel-hacking/hacking:thanks}
Thanks to Andi Kleen for the idea, answering my questions, fixing my
mistakes, filling content, etc. Philipp Rumpf for more spelling and
clarity fixes, and some excellent non-obvious points. Werner Almesberger
for giving me a great summary of \code{disable\_irq()}, and Jes
Sorensen and Andrea Arcangeli added caveats. Michael Elizabeth Chastain
for checking and adding to the Configure section. Telsa Gwynne for
teaching me DocBook.


\chapter{Unreliable Guide To Locking}
\label{kernel-hacking/locking::doc}\label{kernel-hacking/locking:unreliable-guide-to-locking}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Rusty Russell

\end{description}\end{quote}


\section{Introduction}
\label{kernel-hacking/locking:introduction}
Welcome, to Rusty's Remarkably Unreliable Guide to Kernel Locking
issues. This document describes the locking systems in the Linux Kernel
in 2.6.

With the wide availability of HyperThreading, and preemption in the
Linux Kernel, everyone hacking on the kernel needs to know the
fundamentals of concurrency and locking for SMP.


\section{The Problem With Concurrency}
\label{kernel-hacking/locking:the-problem-with-concurrency}
(Skip this if you know what a Race Condition is).

In a normal program, you can increment a counter like so:

\begin{Verbatim}[commandchars=\\\{\}]
very\PYGZus{}important\PYGZus{}count++;
\end{Verbatim}

This is what they would expect to happen:


\begin{threeparttable}
\capstart\caption{Expected Results}\label{kernel-hacking/locking:id1}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Instance 1
} & \textsf{\relax 
Instance 2
}\\
\hline
read very\_important\_count (5)
 & \\
\hline
add 1 (6)
 & \\
\hline
write very\_important\_count (6)
 & \\
\hline & 
read very\_important\_count (6)
\\
\hline & 
add 1 (7)
\\
\hline & 
write very\_important\_count (7)
\\
\hline\end{tabulary}

\end{threeparttable}


This is what might happen:


\begin{threeparttable}
\capstart\caption{Possible Results}\label{kernel-hacking/locking:id2}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Instance 1
} & \textsf{\relax 
Instance 2
}\\
\hline
read very\_important\_count (5)
 & \\
\hline & 
read very\_important\_count (5)
\\
\hline
add 1 (6)
 & \\
\hline & 
add 1 (6)
\\
\hline
write very\_important\_count (6)
 & \\
\hline & 
write very\_important\_count (6)
\\
\hline\end{tabulary}

\end{threeparttable}



\subsection{Race Conditions and Critical Regions}
\label{kernel-hacking/locking:race-conditions-and-critical-regions}
This overlap, where the result depends on the relative timing of
multiple tasks, is called a race condition. The piece of code containing
the concurrency issue is called a critical region. And especially since
Linux starting running on SMP machines, they became one of the major
issues in kernel design and implementation.

Preemption can have the same effect, even if there is only one CPU: by
preempting one task during the critical region, we have exactly the same
race condition. In this case the thread which preempts might run the
critical region itself.

The solution is to recognize when these simultaneous accesses occur, and
use locks to make sure that only one instance can enter the critical
region at any time. There are many friendly primitives in the Linux
kernel to help you do this. And then there are the unfriendly
primitives, but I'll pretend they don't exist.


\section{Locking in the Linux Kernel}
\label{kernel-hacking/locking:locking-in-the-linux-kernel}
If I could give you one piece of advice: never sleep with anyone crazier
than yourself. But if I had to give you advice on locking: \textbf{keep it
simple}.

Be reluctant to introduce new locks.

Strangely enough, this last one is the exact reverse of my advice when
you \textbf{have} slept with someone crazier than yourself. And you should
think about getting a big dog.


\subsection{Two Main Types of Kernel Locks: Spinlocks and Mutexes}
\label{kernel-hacking/locking:two-main-types-of-kernel-locks-spinlocks-and-mutexes}
There are two main types of kernel locks. The fundamental type is the
spinlock (\code{include/asm/spinlock.h}), which is a very simple
single-holder lock: if you can't get the spinlock, you keep trying
(spinning) until you can. Spinlocks are very small and fast, and can be
used anywhere.

The second type is a mutex (\code{include/linux/mutex.h}): it is like a
spinlock, but you may block holding a mutex. If you can't lock a mutex,
your task will suspend itself, and be woken up when the mutex is
released. This means the CPU can do something else while you are
waiting. There are many cases when you simply can't sleep (see
{\hyperref[kernel\string-hacking/locking:sleeping\string-things]{\emph{What Functions Are Safe To Call From Interrupts?}}}),
and so have to use a spinlock instead.

Neither type of lock is recursive: see
{\hyperref[kernel\string-hacking/locking:deadlock]{\emph{Deadlock: Simple and Advanced}}}.


\subsection{Locks and Uniprocessor Kernels}
\label{kernel-hacking/locking:locks-and-uniprocessor-kernels}
For kernels compiled without \code{CONFIG\_SMP}, and without
\code{CONFIG\_PREEMPT} spinlocks do not exist at all. This is an excellent
design decision: when no-one else can run at the same time, there is no
reason to have a lock.

If the kernel is compiled without \code{CONFIG\_SMP}, but \code{CONFIG\_PREEMPT}
is set, then spinlocks simply disable preemption, which is sufficient to
prevent any races. For most purposes, we can think of preemption as
equivalent to SMP, and not worry about it separately.

You should always test your locking code with \code{CONFIG\_SMP} and
\code{CONFIG\_PREEMPT} enabled, even if you don't have an SMP test box,
because it will still catch some kinds of locking bugs.

Mutexes still exist, because they are required for synchronization
between user contexts, as we will see below.


\subsection{Locking Only In User Context}
\label{kernel-hacking/locking:locking-only-in-user-context}
If you have a data structure which is only ever accessed from user
context, then you can use a simple mutex (\code{include/linux/mutex.h}) to
protect it. This is the most trivial case: you initialize the mutex.
Then you can call {\hyperref[kernel\string-hacking/locking:c.mutex_lock_interruptible]{\emph{\code{mutex\_lock\_interruptible()}}}} to grab the
mutex, and {\hyperref[kernel\string-hacking/locking:c.mutex_unlock]{\emph{\code{mutex\_unlock()}}}} to release it. There is also a
{\hyperref[kernel\string-hacking/locking:c.mutex_lock]{\emph{\code{mutex\_lock()}}}}, which should be avoided, because it will
not return if a signal is received.

Example: \code{net/netfilter/nf\_sockopt.c} allows registration of new
\code{setsockopt()} and \code{getsockopt()} calls, with
\code{nf\_register\_sockopt()}. Registration and de-registration
are only done on module load and unload (and boot time, where there is
no concurrency), and the list of registrations is only consulted for an
unknown \code{setsockopt()} or \code{getsockopt()} system
call. The \code{nf\_sockopt\_mutex} is perfect to protect this, especially
since the setsockopt and getsockopt calls may well sleep.


\subsection{Locking Between User Context and Softirqs}
\label{kernel-hacking/locking:locking-between-user-context-and-softirqs}
If a softirq shares data with user context, you have two problems.
Firstly, the current user context can be interrupted by a softirq, and
secondly, the critical region could be entered from another CPU. This is
where \code{spin\_lock\_bh()} (\code{include/linux/spinlock.h}) is
used. It disables softirqs on that CPU, then grabs the lock.
\code{spin\_unlock\_bh()} does the reverse. (The `\_bh' suffix is
a historical reference to ``Bottom Halves'', the old name for software
interrupts. It should really be called spin\_lock\_softirq()' in a
perfect world).

Note that you can also use \code{spin\_lock\_irq()} or
\code{spin\_lock\_irqsave()} here, which stop hardware interrupts
as well: see {\hyperref[kernel\string-hacking/locking:hardirq\string-context]{\emph{Hard IRQ Context}}}.

This works perfectly for UP as well: the spin lock vanishes, and this
macro simply becomes \code{local\_bh\_disable()}
(\code{include/linux/interrupt.h}), which protects you from the softirq
being run.


\subsection{Locking Between User Context and Tasklets}
\label{kernel-hacking/locking:locking-between-user-context-and-tasklets}
This is exactly the same as above, because tasklets are actually run
from a softirq.


\subsection{Locking Between User Context and Timers}
\label{kernel-hacking/locking:locking-between-user-context-and-timers}
This, too, is exactly the same as above, because timers are actually run
from a softirq. From a locking point of view, tasklets and timers are
identical.


\subsection{Locking Between Tasklets/Timers}
\label{kernel-hacking/locking:locking-between-tasklets-timers}
Sometimes a tasklet or timer might want to share data with another
tasklet or timer.


\subsubsection{The Same Tasklet/Timer}
\label{kernel-hacking/locking:the-same-tasklet-timer}
Since a tasklet is never run on two CPUs at once, you don't need to
worry about your tasklet being reentrant (running twice at once), even
on SMP.


\subsubsection{Different Tasklets/Timers}
\label{kernel-hacking/locking:different-tasklets-timers}
If another tasklet/timer wants to share data with your tasklet or timer
, you will both need to use \code{spin\_lock()} and
\code{spin\_unlock()} calls. \code{spin\_lock\_bh()} is
unnecessary here, as you are already in a tasklet, and none will be run
on the same CPU.


\subsection{Locking Between Softirqs}
\label{kernel-hacking/locking:locking-between-softirqs}
Often a softirq might want to share data with itself or a tasklet/timer.


\subsubsection{The Same Softirq}
\label{kernel-hacking/locking:the-same-softirq}
The same softirq can run on the other CPUs: you can use a per-CPU array
(see {\hyperref[kernel\string-hacking/locking:per\string-cpu]{\emph{Per-CPU Data}}}) for better performance. If you're
going so far as to use a softirq, you probably care about scalable
performance enough to justify the extra complexity.

You'll need to use \code{spin\_lock()} and
\code{spin\_unlock()} for shared data.


\subsubsection{Different Softirqs}
\label{kernel-hacking/locking:different-softirqs}
You'll need to use \code{spin\_lock()} and
\code{spin\_unlock()} for shared data, whether it be a timer,
tasklet, different softirq or the same or another softirq: any of them
could be running on a different CPU.


\section{Hard IRQ Context}
\label{kernel-hacking/locking:hard-irq-context}
Hardware interrupts usually communicate with a tasklet or softirq.
Frequently this involves putting work in a queue, which the softirq will
take out.


\subsection{Locking Between Hard IRQ and Softirqs/Tasklets}
\label{kernel-hacking/locking:locking-between-hard-irq-and-softirqs-tasklets}
If a hardware irq handler shares data with a softirq, you have two
concerns. Firstly, the softirq processing can be interrupted by a
hardware interrupt, and secondly, the critical region could be entered
by a hardware interrupt on another CPU. This is where
\code{spin\_lock\_irq()} is used. It is defined to disable
interrupts on that cpu, then grab the lock.
\code{spin\_unlock\_irq()} does the reverse.

The irq handler does not to use \code{spin\_lock\_irq()}, because
the softirq cannot run while the irq handler is running: it can use
\code{spin\_lock()}, which is slightly faster. The only exception
would be if a different hardware irq handler uses the same lock:
\code{spin\_lock\_irq()} will stop that from interrupting us.

This works perfectly for UP as well: the spin lock vanishes, and this
macro simply becomes \code{local\_irq\_disable()}
(\code{include/asm/smp.h}), which protects you from the softirq/tasklet/BH
being run.

\code{spin\_lock\_irqsave()} (\code{include/linux/spinlock.h}) is a
variant which saves whether interrupts were on or off in a flags word,
which is passed to \code{spin\_unlock\_irqrestore()}. This means
that the same code can be used inside an hard irq handler (where
interrupts are already off) and in softirqs (where the irq disabling is
required).

Note that softirqs (and hence tasklets and timers) are run on return
from hardware interrupts, so \code{spin\_lock\_irq()} also stops
these. In that sense, \code{spin\_lock\_irqsave()} is the most
general and powerful locking function.


\subsection{Locking Between Two Hard IRQ Handlers}
\label{kernel-hacking/locking:locking-between-two-hard-irq-handlers}
It is rare to have to share data between two IRQ handlers, but if you
do, \code{spin\_lock\_irqsave()} should be used: it is
architecture-specific whether all interrupts are disabled inside irq
handlers themselves.


\section{Cheat Sheet For Locking}
\label{kernel-hacking/locking:cheat-sheet-for-locking}
Pete Zaitcev gives the following summary:
\begin{itemize}
\item {} 
If you are in a process context (any syscall) and want to lock other
process out, use a mutex. You can take a mutex and sleep
(\code{copy\_from\_user*(} or \code{kmalloc(x,GFP\_KERNEL)}).

\item {} 
Otherwise (== data can be touched in an interrupt), use
\code{spin\_lock\_irqsave()} and
\code{spin\_unlock\_irqrestore()}.

\item {} 
Avoid holding spinlock for more than 5 lines of code and across any
function call (except accessors like \code{readb()}).

\end{itemize}


\subsection{Table of Minimum Requirements}
\label{kernel-hacking/locking:table-of-minimum-requirements}
The following table lists the \textbf{minimum} locking requirements between
various contexts. In some cases, the same context can only be running on
one CPU at a time, so no locking is required for that context (eg. a
particular thread can only run on one CPU at a time, but if it needs
shares data with another thread, locking is required).

Remember the advice above: you can always use
\code{spin\_lock\_irqsave()}, which is a superset of all other
spinlock primitives.

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|L|L|L|L|L|}
\hline
\textsf{\relax 
.
} & \textsf{\relax 
IRQ Handler A
} & \textsf{\relax 
IRQ Handler B
} & \textsf{\relax 
Softirq A
} & \textsf{\relax 
Softirq B
} & \textsf{\relax 
Tasklet A
} & \textsf{\relax 
Tasklet B
} & \textsf{\relax 
Timer A
} & \textsf{\relax 
Timer B
} & \textsf{\relax 
User Context A
} & \textsf{\relax 
User Context B
}\\
\hline
IRQ Handler A
 & 
None
 &  &  &  &  &  &  &  &  & \\
\hline
IRQ Handler B
 & 
SLIS
 & 
None
 &  &  &  &  &  &  &  & \\
\hline
Softirq A
 & 
SLI
 & 
SLI
 & 
SL
 &  &  &  &  &  &  & \\
\hline
Softirq B
 & 
SLI
 & 
SLI
 & 
SL
 & 
SL
 &  &  &  &  &  & \\
\hline
Tasklet A
 & 
SLI
 & 
SLI
 & 
SL
 & 
SL
 & 
None
 &  &  &  &  & \\
\hline
Tasklet B
 & 
SLI
 & 
SLI
 & 
SL
 & 
SL
 & 
SL
 & 
None
 &  &  &  & \\
\hline
Timer A
 & 
SLI
 & 
SLI
 & 
SL
 & 
SL
 & 
SL
 & 
SL
 & 
None
 &  &  & \\
\hline
Timer B
 & 
SLI
 & 
SLI
 & 
SL
 & 
SL
 & 
SL
 & 
SL
 & 
SL
 & 
None
 &  & \\
\hline
User Context A
 & 
SLI
 & 
SLI
 & 
SLBH
 & 
SLBH
 & 
SLBH
 & 
SLBH
 & 
SLBH
 & 
SLBH
 & 
None
 & \\
\hline
User Context B
 & 
SLI
 & 
SLI
 & 
SLBH
 & 
SLBH
 & 
SLBH
 & 
SLBH
 & 
SLBH
 & 
SLBH
 & 
MLI
 & 
None
\\
\hline\end{tabulary}


Table: Table of Locking Requirements

\begin{tabulary}{\linewidth}{|L|L|}
\hline

SLIS
 & 
spin\_lock\_irqsave
\\
\hline
SLI
 & 
spin\_lock\_irq
\\
\hline
SL
 & 
spin\_lock
\\
\hline
SLBH
 & 
spin\_lock\_bh
\\
\hline
MLI
 & 
mutex\_lock\_interruptible
\\
\hline\end{tabulary}


Table: Legend for Locking Requirements Table


\section{The trylock Functions}
\label{kernel-hacking/locking:the-trylock-functions}
There are functions that try to acquire a lock only once and immediately
return a value telling about success or failure to acquire the lock.
They can be used if you need no access to the data protected with the
lock when some other thread is holding the lock. You should acquire the
lock later if you then need access to the data protected with the lock.

\code{spin\_trylock()} does not spin but returns non-zero if it
acquires the spinlock on the first try or 0 if not. This function can be
used in all contexts like \code{spin\_lock()}: you must have
disabled the contexts that might interrupt you and acquire the spin
lock.

{\hyperref[kernel\string-hacking/locking:c.mutex_trylock]{\emph{\code{mutex\_trylock()}}}} does not suspend your task but returns
non-zero if it could lock the mutex on the first try or 0 if not. This
function cannot be safely used in hardware or software interrupt
contexts despite not sleeping.


\section{Common Examples}
\label{kernel-hacking/locking:common-examples}
Let's step through a simple example: a cache of number to name mappings.
The cache keeps a count of how often each of the objects is used, and
when it gets full, throws out the least used one.


\subsection{All In User Context}
\label{kernel-hacking/locking:all-in-user-context}
For our first example, we assume that all operations are in user context
(ie. from system calls), so we can sleep. This means we can use a mutex
to protect the cache and all the objects within it. Here's the code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}linux/list.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}linux/slab.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}linux/string.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}linux/mutex.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}asm/errno.h\PYGZgt{}

struct object
\PYGZob{}
        struct list\PYGZus{}head list;
        int id;
        char name[32];
        int popularity;
\PYGZcb{};

/* Protects the cache, cache\PYGZus{}num, and the objects within it */
static DEFINE\PYGZus{}MUTEX(cache\PYGZus{}lock);
static LIST\PYGZus{}HEAD(cache);
static unsigned int cache\PYGZus{}num = 0;
\PYGZsh{}define MAX\PYGZus{}CACHE\PYGZus{}SIZE 10

/* Must be holding cache\PYGZus{}lock */
static struct object *\PYGZus{}\PYGZus{}cache\PYGZus{}find(int id)
\PYGZob{}
        struct object *i;

        list\PYGZus{}for\PYGZus{}each\PYGZus{}entry(i, \PYGZam{}cache, list)
                if (i\PYGZhy{}\PYGZgt{}id == id) \PYGZob{}
                        i\PYGZhy{}\PYGZgt{}popularity++;
                        return i;
                \PYGZcb{}
        return NULL;
\PYGZcb{}

/* Must be holding cache\PYGZus{}lock */
static void \PYGZus{}\PYGZus{}cache\PYGZus{}delete(struct object *obj)
\PYGZob{}
        BUG\PYGZus{}ON(!obj);
        list\PYGZus{}del(\PYGZam{}obj\PYGZhy{}\PYGZgt{}list);
        kfree(obj);
        cache\PYGZus{}num\PYGZhy{}\PYGZhy{};
\PYGZcb{}

/* Must be holding cache\PYGZus{}lock */
static void \PYGZus{}\PYGZus{}cache\PYGZus{}add(struct object *obj)
\PYGZob{}
        list\PYGZus{}add(\PYGZam{}obj\PYGZhy{}\PYGZgt{}list, \PYGZam{}cache);
        if (++cache\PYGZus{}num \PYGZgt{} MAX\PYGZus{}CACHE\PYGZus{}SIZE) \PYGZob{}
                struct object *i, *outcast = NULL;
                list\PYGZus{}for\PYGZus{}each\PYGZus{}entry(i, \PYGZam{}cache, list) \PYGZob{}
                        if (!outcast \textbar{}\textbar{} i\PYGZhy{}\PYGZgt{}popularity \PYGZlt{} outcast\PYGZhy{}\PYGZgt{}popularity)
                                outcast = i;
                \PYGZcb{}
                \PYGZus{}\PYGZus{}cache\PYGZus{}delete(outcast);
        \PYGZcb{}
\PYGZcb{}

int cache\PYGZus{}add(int id, const char *name)
\PYGZob{}
        struct object *obj;

        if ((obj = kmalloc(sizeof(*obj), GFP\PYGZus{}KERNEL)) == NULL)
                return \PYGZhy{}ENOMEM;

        strlcpy(obj\PYGZhy{}\PYGZgt{}name, name, sizeof(obj\PYGZhy{}\PYGZgt{}name));
        obj\PYGZhy{}\PYGZgt{}id = id;
        obj\PYGZhy{}\PYGZgt{}popularity = 0;

        mutex\PYGZus{}lock(\PYGZam{}cache\PYGZus{}lock);
        \PYGZus{}\PYGZus{}cache\PYGZus{}add(obj);
        mutex\PYGZus{}unlock(\PYGZam{}cache\PYGZus{}lock);
        return 0;
\PYGZcb{}

void cache\PYGZus{}delete(int id)
\PYGZob{}
        mutex\PYGZus{}lock(\PYGZam{}cache\PYGZus{}lock);
        \PYGZus{}\PYGZus{}cache\PYGZus{}delete(\PYGZus{}\PYGZus{}cache\PYGZus{}find(id));
        mutex\PYGZus{}unlock(\PYGZam{}cache\PYGZus{}lock);
\PYGZcb{}

int cache\PYGZus{}find(int id, char *name)
\PYGZob{}
        struct object *obj;
        int ret = \PYGZhy{}ENOENT;

        mutex\PYGZus{}lock(\PYGZam{}cache\PYGZus{}lock);
        obj = \PYGZus{}\PYGZus{}cache\PYGZus{}find(id);
        if (obj) \PYGZob{}
                ret = 0;
                strcpy(name, obj\PYGZhy{}\PYGZgt{}name);
        \PYGZcb{}
        mutex\PYGZus{}unlock(\PYGZam{}cache\PYGZus{}lock);
        return ret;
\PYGZcb{}
\end{Verbatim}

Note that we always make sure we have the cache\_lock when we add,
delete, or look up the cache: both the cache infrastructure itself and
the contents of the objects are protected by the lock. In this case it's
easy, since we copy the data for the user, and never let them access the
objects directly.

There is a slight (and common) optimization here: in
\code{cache\_add()} we set up the fields of the object before
grabbing the lock. This is safe, as no-one else can access it until we
put it in cache.


\subsection{Accessing From Interrupt Context}
\label{kernel-hacking/locking:accessing-from-interrupt-context}
Now consider the case where \code{cache\_find()} can be called
from interrupt context: either a hardware interrupt or a softirq. An
example would be a timer which deletes object from the cache.

The change is shown below, in standard patch format: the \code{-} are lines
which are taken away, and the \code{+} are lines which are added.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{} cache.c.usercontext 2003\PYGZhy{}12\PYGZhy{}09 13:58:54.000000000 +1100
+++ cache.c.interrupt   2003\PYGZhy{}12\PYGZhy{}09 14:07:49.000000000 +1100
@@ \PYGZhy{}12,7 +12,7 @@
         int popularity;
 \PYGZcb{};

\PYGZhy{}static DEFINE\PYGZus{}MUTEX(cache\PYGZus{}lock);
+static DEFINE\PYGZus{}SPINLOCK(cache\PYGZus{}lock);
 static LIST\PYGZus{}HEAD(cache);
 static unsigned int cache\PYGZus{}num = 0;
 \PYGZsh{}define MAX\PYGZus{}CACHE\PYGZus{}SIZE 10
@@ \PYGZhy{}55,6 +55,7 @@
 int cache\PYGZus{}add(int id, const char *name)
 \PYGZob{}
         struct object *obj;
+        unsigned long flags;

         if ((obj = kmalloc(sizeof(*obj), GFP\PYGZus{}KERNEL)) == NULL)
                 return \PYGZhy{}ENOMEM;
@@ \PYGZhy{}63,30 +64,33 @@
         obj\PYGZhy{}\PYGZgt{}id = id;
         obj\PYGZhy{}\PYGZgt{}popularity = 0;

\PYGZhy{}        mutex\PYGZus{}lock(\PYGZam{}cache\PYGZus{}lock);
+        spin\PYGZus{}lock\PYGZus{}irqsave(\PYGZam{}cache\PYGZus{}lock, flags);
         \PYGZus{}\PYGZus{}cache\PYGZus{}add(obj);
\PYGZhy{}        mutex\PYGZus{}unlock(\PYGZam{}cache\PYGZus{}lock);
+        spin\PYGZus{}unlock\PYGZus{}irqrestore(\PYGZam{}cache\PYGZus{}lock, flags);
         return 0;
 \PYGZcb{}

 void cache\PYGZus{}delete(int id)
 \PYGZob{}
\PYGZhy{}        mutex\PYGZus{}lock(\PYGZam{}cache\PYGZus{}lock);
+        unsigned long flags;
+
+        spin\PYGZus{}lock\PYGZus{}irqsave(\PYGZam{}cache\PYGZus{}lock, flags);
         \PYGZus{}\PYGZus{}cache\PYGZus{}delete(\PYGZus{}\PYGZus{}cache\PYGZus{}find(id));
\PYGZhy{}        mutex\PYGZus{}unlock(\PYGZam{}cache\PYGZus{}lock);
+        spin\PYGZus{}unlock\PYGZus{}irqrestore(\PYGZam{}cache\PYGZus{}lock, flags);
 \PYGZcb{}

 int cache\PYGZus{}find(int id, char *name)
 \PYGZob{}
         struct object *obj;
         int ret = \PYGZhy{}ENOENT;
+        unsigned long flags;

\PYGZhy{}        mutex\PYGZus{}lock(\PYGZam{}cache\PYGZus{}lock);
+        spin\PYGZus{}lock\PYGZus{}irqsave(\PYGZam{}cache\PYGZus{}lock, flags);
         obj = \PYGZus{}\PYGZus{}cache\PYGZus{}find(id);
         if (obj) \PYGZob{}
                 ret = 0;
                 strcpy(name, obj\PYGZhy{}\PYGZgt{}name);
         \PYGZcb{}
\PYGZhy{}        mutex\PYGZus{}unlock(\PYGZam{}cache\PYGZus{}lock);
+        spin\PYGZus{}unlock\PYGZus{}irqrestore(\PYGZam{}cache\PYGZus{}lock, flags);
         return ret;
 \PYGZcb{}
\end{Verbatim}

Note that the \code{spin\_lock\_irqsave()} will turn off
interrupts if they are on, otherwise does nothing (if we are already in
an interrupt handler), hence these functions are safe to call from any
context.

Unfortunately, \code{cache\_add()} calls \code{kmalloc()}
with the \code{GFP\_KERNEL} flag, which is only legal in user context. I
have assumed that \code{cache\_add()} is still only called in
user context, otherwise this should become a parameter to
\code{cache\_add()}.


\subsection{Exposing Objects Outside This File}
\label{kernel-hacking/locking:exposing-objects-outside-this-file}
If our objects contained more information, it might not be sufficient to
copy the information in and out: other parts of the code might want to
keep pointers to these objects, for example, rather than looking up the
id every time. This produces two problems.

The first problem is that we use the \code{cache\_lock} to protect objects:
we'd need to make this non-static so the rest of the code can use it.
This makes locking trickier, as it is no longer all in one place.

The second problem is the lifetime problem: if another structure keeps a
pointer to an object, it presumably expects that pointer to remain
valid. Unfortunately, this is only guaranteed while you hold the lock,
otherwise someone might call \code{cache\_delete()} and even
worse, add another object, re-using the same address.

As there is only one lock, you can't hold it forever: no-one else would
get any work done.

The solution to this problem is to use a reference count: everyone who
has a pointer to the object increases it when they first get the object,
and drops the reference count when they're finished with it. Whoever
drops it to zero knows it is unused, and can actually delete it.

Here is the code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{} cache.c.interrupt   2003\PYGZhy{}12\PYGZhy{}09 14:25:43.000000000 +1100
+++ cache.c.refcnt  2003\PYGZhy{}12\PYGZhy{}09 14:33:05.000000000 +1100
@@ \PYGZhy{}7,6 +7,7 @@
 struct object
 \PYGZob{}
         struct list\PYGZus{}head list;
+        unsigned int refcnt;
         int id;
         char name[32];
         int popularity;
@@ \PYGZhy{}17,6 +18,35 @@
 static unsigned int cache\PYGZus{}num = 0;
 \PYGZsh{}define MAX\PYGZus{}CACHE\PYGZus{}SIZE 10

+static void \PYGZus{}\PYGZus{}object\PYGZus{}put(struct object *obj)
+\PYGZob{}
+        if (\PYGZhy{}\PYGZhy{}obj\PYGZhy{}\PYGZgt{}refcnt == 0)
+                kfree(obj);
+\PYGZcb{}
+
+static void \PYGZus{}\PYGZus{}object\PYGZus{}get(struct object *obj)
+\PYGZob{}
+        obj\PYGZhy{}\PYGZgt{}refcnt++;
+\PYGZcb{}
+
+void object\PYGZus{}put(struct object *obj)
+\PYGZob{}
+        unsigned long flags;
+
+        spin\PYGZus{}lock\PYGZus{}irqsave(\PYGZam{}cache\PYGZus{}lock, flags);
+        \PYGZus{}\PYGZus{}object\PYGZus{}put(obj);
+        spin\PYGZus{}unlock\PYGZus{}irqrestore(\PYGZam{}cache\PYGZus{}lock, flags);
+\PYGZcb{}
+
+void object\PYGZus{}get(struct object *obj)
+\PYGZob{}
+        unsigned long flags;
+
+        spin\PYGZus{}lock\PYGZus{}irqsave(\PYGZam{}cache\PYGZus{}lock, flags);
+        \PYGZus{}\PYGZus{}object\PYGZus{}get(obj);
+        spin\PYGZus{}unlock\PYGZus{}irqrestore(\PYGZam{}cache\PYGZus{}lock, flags);
+\PYGZcb{}
+
 /* Must be holding cache\PYGZus{}lock */
 static struct object *\PYGZus{}\PYGZus{}cache\PYGZus{}find(int id)
 \PYGZob{}
@@ \PYGZhy{}35,6 +65,7 @@
 \PYGZob{}
         BUG\PYGZus{}ON(!obj);
         list\PYGZus{}del(\PYGZam{}obj\PYGZhy{}\PYGZgt{}list);
+        \PYGZus{}\PYGZus{}object\PYGZus{}put(obj);
         cache\PYGZus{}num\PYGZhy{}\PYGZhy{};
 \PYGZcb{}

@@ \PYGZhy{}63,6 +94,7 @@
         strlcpy(obj\PYGZhy{}\PYGZgt{}name, name, sizeof(obj\PYGZhy{}\PYGZgt{}name));
         obj\PYGZhy{}\PYGZgt{}id = id;
         obj\PYGZhy{}\PYGZgt{}popularity = 0;
+        obj\PYGZhy{}\PYGZgt{}refcnt = 1; /* The cache holds a reference */

         spin\PYGZus{}lock\PYGZus{}irqsave(\PYGZam{}cache\PYGZus{}lock, flags);
         \PYGZus{}\PYGZus{}cache\PYGZus{}add(obj);
@@ \PYGZhy{}79,18 +111,15 @@
         spin\PYGZus{}unlock\PYGZus{}irqrestore(\PYGZam{}cache\PYGZus{}lock, flags);
 \PYGZcb{}

\PYGZhy{}int cache\PYGZus{}find(int id, char *name)
+struct object *cache\PYGZus{}find(int id)
 \PYGZob{}
         struct object *obj;
\PYGZhy{}        int ret = \PYGZhy{}ENOENT;
         unsigned long flags;

         spin\PYGZus{}lock\PYGZus{}irqsave(\PYGZam{}cache\PYGZus{}lock, flags);
         obj = \PYGZus{}\PYGZus{}cache\PYGZus{}find(id);
\PYGZhy{}        if (obj) \PYGZob{}
\PYGZhy{}                ret = 0;
\PYGZhy{}                strcpy(name, obj\PYGZhy{}\PYGZgt{}name);
\PYGZhy{}        \PYGZcb{}
+        if (obj)
+                \PYGZus{}\PYGZus{}object\PYGZus{}get(obj);
         spin\PYGZus{}unlock\PYGZus{}irqrestore(\PYGZam{}cache\PYGZus{}lock, flags);
\PYGZhy{}        return ret;
+        return obj;
 \PYGZcb{}
\end{Verbatim}

We encapsulate the reference counting in the standard `get' and `put'
functions. Now we can return the object itself from
\code{cache\_find()} which has the advantage that the user can
now sleep holding the object (eg. to \code{copy\_to\_user()} to
name to userspace).

The other point to note is that I said a reference should be held for
every pointer to the object: thus the reference count is 1 when first
inserted into the cache. In some versions the framework does not hold a
reference count, but they are more complicated.


\subsubsection{Using Atomic Operations For The Reference Count}
\label{kernel-hacking/locking:using-atomic-operations-for-the-reference-count}
In practice, \code{atomic\_t} would usually be used for refcnt. There are a
number of atomic operations defined in \code{include/asm/atomic.h}: these
are guaranteed to be seen atomically from all CPUs in the system, so no
lock is required. In this case, it is simpler than using spinlocks,
although for anything non-trivial using spinlocks is clearer. The
\code{atomic\_inc()} and \code{atomic\_dec\_and\_test()}
are used instead of the standard increment and decrement operators, and
the lock is no longer used to protect the reference count itself.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{} cache.c.refcnt  2003\PYGZhy{}12\PYGZhy{}09 15:00:35.000000000 +1100
+++ cache.c.refcnt\PYGZhy{}atomic   2003\PYGZhy{}12\PYGZhy{}11 15:49:42.000000000 +1100
@@ \PYGZhy{}7,7 +7,7 @@
 struct object
 \PYGZob{}
         struct list\PYGZus{}head list;
\PYGZhy{}        unsigned int refcnt;
+        atomic\PYGZus{}t refcnt;
         int id;
         char name[32];
         int popularity;
@@ \PYGZhy{}18,33 +18,15 @@
 static unsigned int cache\PYGZus{}num = 0;
 \PYGZsh{}define MAX\PYGZus{}CACHE\PYGZus{}SIZE 10

\PYGZhy{}static void \PYGZus{}\PYGZus{}object\PYGZus{}put(struct object *obj)
\PYGZhy{}\PYGZob{}
\PYGZhy{}        if (\PYGZhy{}\PYGZhy{}obj\PYGZhy{}\PYGZgt{}refcnt == 0)
\PYGZhy{}                kfree(obj);
\PYGZhy{}\PYGZcb{}
\PYGZhy{}
\PYGZhy{}static void \PYGZus{}\PYGZus{}object\PYGZus{}get(struct object *obj)
\PYGZhy{}\PYGZob{}
\PYGZhy{}        obj\PYGZhy{}\PYGZgt{}refcnt++;
\PYGZhy{}\PYGZcb{}
\PYGZhy{}
 void object\PYGZus{}put(struct object *obj)
 \PYGZob{}
\PYGZhy{}        unsigned long flags;
\PYGZhy{}
\PYGZhy{}        spin\PYGZus{}lock\PYGZus{}irqsave(\PYGZam{}cache\PYGZus{}lock, flags);
\PYGZhy{}        \PYGZus{}\PYGZus{}object\PYGZus{}put(obj);
\PYGZhy{}        spin\PYGZus{}unlock\PYGZus{}irqrestore(\PYGZam{}cache\PYGZus{}lock, flags);
+        if (atomic\PYGZus{}dec\PYGZus{}and\PYGZus{}test(\PYGZam{}obj\PYGZhy{}\PYGZgt{}refcnt))
+                kfree(obj);
 \PYGZcb{}

 void object\PYGZus{}get(struct object *obj)
 \PYGZob{}
\PYGZhy{}        unsigned long flags;
\PYGZhy{}
\PYGZhy{}        spin\PYGZus{}lock\PYGZus{}irqsave(\PYGZam{}cache\PYGZus{}lock, flags);
\PYGZhy{}        \PYGZus{}\PYGZus{}object\PYGZus{}get(obj);
\PYGZhy{}        spin\PYGZus{}unlock\PYGZus{}irqrestore(\PYGZam{}cache\PYGZus{}lock, flags);
+        atomic\PYGZus{}inc(\PYGZam{}obj\PYGZhy{}\PYGZgt{}refcnt);
 \PYGZcb{}

 /* Must be holding cache\PYGZus{}lock */
@@ \PYGZhy{}65,7 +47,7 @@
 \PYGZob{}
         BUG\PYGZus{}ON(!obj);
         list\PYGZus{}del(\PYGZam{}obj\PYGZhy{}\PYGZgt{}list);
\PYGZhy{}        \PYGZus{}\PYGZus{}object\PYGZus{}put(obj);
+        object\PYGZus{}put(obj);
         cache\PYGZus{}num\PYGZhy{}\PYGZhy{};
 \PYGZcb{}

@@ \PYGZhy{}94,7 +76,7 @@
         strlcpy(obj\PYGZhy{}\PYGZgt{}name, name, sizeof(obj\PYGZhy{}\PYGZgt{}name));
         obj\PYGZhy{}\PYGZgt{}id = id;
         obj\PYGZhy{}\PYGZgt{}popularity = 0;
\PYGZhy{}        obj\PYGZhy{}\PYGZgt{}refcnt = 1; /* The cache holds a reference */
+        atomic\PYGZus{}set(\PYGZam{}obj\PYGZhy{}\PYGZgt{}refcnt, 1); /* The cache holds a reference */

         spin\PYGZus{}lock\PYGZus{}irqsave(\PYGZam{}cache\PYGZus{}lock, flags);
         \PYGZus{}\PYGZus{}cache\PYGZus{}add(obj);
@@ \PYGZhy{}119,7 +101,7 @@
         spin\PYGZus{}lock\PYGZus{}irqsave(\PYGZam{}cache\PYGZus{}lock, flags);
         obj = \PYGZus{}\PYGZus{}cache\PYGZus{}find(id);
         if (obj)
\PYGZhy{}                \PYGZus{}\PYGZus{}object\PYGZus{}get(obj);
+                object\PYGZus{}get(obj);
         spin\PYGZus{}unlock\PYGZus{}irqrestore(\PYGZam{}cache\PYGZus{}lock, flags);
         return obj;
 \PYGZcb{}
\end{Verbatim}


\subsection{Protecting The Objects Themselves}
\label{kernel-hacking/locking:protecting-the-objects-themselves}
In these examples, we assumed that the objects (except the reference
counts) never changed once they are created. If we wanted to allow the
name to change, there are three possibilities:
\begin{itemize}
\item {} 
You can make \code{cache\_lock} non-static, and tell people to grab that
lock before changing the name in any object.

\item {} 
You can provide a \code{cache\_obj\_rename()} which grabs this
lock and changes the name for the caller, and tell everyone to use
that function.

\item {} 
You can make the \code{cache\_lock} protect only the cache itself, and
use another lock to protect the name.

\end{itemize}

Theoretically, you can make the locks as fine-grained as one lock for
every field, for every object. In practice, the most common variants
are:
\begin{itemize}
\item {} 
One lock which protects the infrastructure (the \code{cache} list in
this example) and all the objects. This is what we have done so far.

\item {} 
One lock which protects the infrastructure (including the list
pointers inside the objects), and one lock inside the object which
protects the rest of that object.

\item {} 
Multiple locks to protect the infrastructure (eg. one lock per hash
chain), possibly with a separate per-object lock.

\end{itemize}

Here is the ``lock-per-object'' implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{} cache.c.refcnt\PYGZhy{}atomic   2003\PYGZhy{}12\PYGZhy{}11 15:50:54.000000000 +1100
+++ cache.c.perobjectlock   2003\PYGZhy{}12\PYGZhy{}11 17:15:03.000000000 +1100
@@ \PYGZhy{}6,11 +6,17 @@

 struct object
 \PYGZob{}
+        /* These two protected by cache\PYGZus{}lock. */
         struct list\PYGZus{}head list;
+        int popularity;
+
         atomic\PYGZus{}t refcnt;
+
+        /* Doesn\PYGZsq{}t change once created. */
         int id;
+
+        spinlock\PYGZus{}t lock; /* Protects the name */
         char name[32];
\PYGZhy{}        int popularity;
 \PYGZcb{};

 static DEFINE\PYGZus{}SPINLOCK(cache\PYGZus{}lock);
@@ \PYGZhy{}77,6 +84,7 @@
         obj\PYGZhy{}\PYGZgt{}id = id;
         obj\PYGZhy{}\PYGZgt{}popularity = 0;
         atomic\PYGZus{}set(\PYGZam{}obj\PYGZhy{}\PYGZgt{}refcnt, 1); /* The cache holds a reference */
+        spin\PYGZus{}lock\PYGZus{}init(\PYGZam{}obj\PYGZhy{}\PYGZgt{}lock);

         spin\PYGZus{}lock\PYGZus{}irqsave(\PYGZam{}cache\PYGZus{}lock, flags);
         \PYGZus{}\PYGZus{}cache\PYGZus{}add(obj);
\end{Verbatim}

Note that I decide that the popularity count should be protected by the
\code{cache\_lock} rather than the per-object lock: this is because it (like
the \code{struct list\_head} inside the object)
is logically part of the infrastructure. This way, I don't need to grab
the lock of every object in \code{\_\_cache\_add()} when seeking
the least popular.

I also decided that the id member is unchangeable, so I don't need to
grab each object lock in \code{\_\_cache\_find()} to examine the
id: the object lock is only used by a caller who wants to read or write
the name field.

Note also that I added a comment describing what data was protected by
which locks. This is extremely important, as it describes the runtime
behavior of the code, and can be hard to gain from just reading. And as
Alan Cox says, “Lock data, not code”.


\section{Common Problems}
\label{kernel-hacking/locking:common-problems}

\subsection{Deadlock: Simple and Advanced}
\label{kernel-hacking/locking:deadlock-simple-and-advanced}
There is a coding bug where a piece of code tries to grab a spinlock
twice: it will spin forever, waiting for the lock to be released
(spinlocks, rwlocks and mutexes are not recursive in Linux). This is
trivial to diagnose: not a
stay-up-five-nights-talk-to-fluffy-code-bunnies kind of problem.

For a slightly more complex case, imagine you have a region shared by a
softirq and user context. If you use a \code{spin\_lock()} call
to protect it, it is possible that the user context will be interrupted
by the softirq while it holds the lock, and the softirq will then spin
forever trying to get the same lock.

Both of these are called deadlock, and as shown above, it can occur even
with a single CPU (although not on UP compiles, since spinlocks vanish
on kernel compiles with \code{CONFIG\_SMP}=n. You'll still get data
corruption in the second example).

This complete lockup is easy to diagnose: on SMP boxes the watchdog
timer or compiling with \code{DEBUG\_SPINLOCK} set
(\code{include/linux/spinlock.h}) will show this up immediately when it
happens.

A more complex problem is the so-called `deadly embrace', involving two
or more locks. Say you have a hash table: each entry in the table is a
spinlock, and a chain of hashed objects. Inside a softirq handler, you
sometimes want to alter an object from one place in the hash to another:
you grab the spinlock of the old hash chain and the spinlock of the new
hash chain, and delete the object from the old one, and insert it in the
new one.

There are two problems here. First, if your code ever tries to move the
object to the same chain, it will deadlock with itself as it tries to
lock it twice. Secondly, if the same softirq on another CPU is trying to
move another object in the reverse direction, the following could
happen:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
CPU 1
} & \textsf{\relax 
CPU 2
}\\
\hline
Grab lock A -\textgreater{} OK
 & 
Grab lock B -\textgreater{} OK
\\
\hline
Grab lock B -\textgreater{} spin
 & 
Grab lock A -\textgreater{} spin
\\
\hline\end{tabulary}


Table: Consequences

The two CPUs will spin forever, waiting for the other to give up their
lock. It will look, smell, and feel like a crash.


\subsection{Preventing Deadlock}
\label{kernel-hacking/locking:preventing-deadlock}
Textbooks will tell you that if you always lock in the same order, you
will never get this kind of deadlock. Practice will tell you that this
approach doesn't scale: when I create a new lock, I don't understand
enough of the kernel to figure out where in the 5000 lock hierarchy it
will fit.

The best locks are encapsulated: they never get exposed in headers, and
are never held around calls to non-trivial functions outside the same
file. You can read through this code and see that it will never
deadlock, because it never tries to grab another lock while it has that
one. People using your code don't even need to know you are using a
lock.

A classic problem here is when you provide callbacks or hooks: if you
call these with the lock held, you risk simple deadlock, or a deadly
embrace (who knows what the callback will do?). Remember, the other
programmers are out to get you, so don't do this.


\subsubsection{Overzealous Prevention Of Deadlocks}
\label{kernel-hacking/locking:overzealous-prevention-of-deadlocks}
Deadlocks are problematic, but not as bad as data corruption. Code which
grabs a read lock, searches a list, fails to find what it wants, drops
the read lock, grabs a write lock and inserts the object has a race
condition.

If you don't see why, please stay the fuck away from my code.


\subsection{Racing Timers: A Kernel Pastime}
\label{kernel-hacking/locking:racing-timers-a-kernel-pastime}
Timers can produce their own special problems with races. Consider a
collection of objects (list, hash, etc) where each object has a timer
which is due to destroy it.

If you want to destroy the entire collection (say on module removal),
you might do the following:

\begin{Verbatim}[commandchars=\\\{\}]
/* THIS CODE BAD BAD BAD BAD: IF IT WAS ANY WORSE IT WOULD USE
   HUNGARIAN NOTATION */
spin\PYGZus{}lock\PYGZus{}bh(\PYGZam{}list\PYGZus{}lock);

while (list) \PYGZob{}
        struct foo *next = list\PYGZhy{}\PYGZgt{}next;
        del\PYGZus{}timer(\PYGZam{}list\PYGZhy{}\PYGZgt{}timer);
        kfree(list);
        list = next;
\PYGZcb{}

spin\PYGZus{}unlock\PYGZus{}bh(\PYGZam{}list\PYGZus{}lock);
\end{Verbatim}

Sooner or later, this will crash on SMP, because a timer can have just
gone off before the \code{spin\_lock\_bh()}, and it will only get
the lock after we \code{spin\_unlock\_bh()}, and then try to free
the element (which has already been freed!).

This can be avoided by checking the result of
\code{del\_timer()}: if it returns 1, the timer has been deleted.
If 0, it means (in this case) that it is currently running, so we can
do:

\begin{Verbatim}[commandchars=\\\{\}]
retry:
        spin\PYGZus{}lock\PYGZus{}bh(\PYGZam{}list\PYGZus{}lock);

        while (list) \PYGZob{}
                struct foo *next = list\PYGZhy{}\PYGZgt{}next;
                if (!del\PYGZus{}timer(\PYGZam{}list\PYGZhy{}\PYGZgt{}timer)) \PYGZob{}
                        /* Give timer a chance to delete this */
                        spin\PYGZus{}unlock\PYGZus{}bh(\PYGZam{}list\PYGZus{}lock);
                        goto retry;
                \PYGZcb{}
                kfree(list);
                list = next;
        \PYGZcb{}

        spin\PYGZus{}unlock\PYGZus{}bh(\PYGZam{}list\PYGZus{}lock);
\end{Verbatim}

Another common problem is deleting timers which restart themselves (by
calling \code{add\_timer()} at the end of their timer function).
Because this is a fairly common case which is prone to races, you should
use \code{del\_timer\_sync()} (\code{include/linux/timer.h}) to
handle this case. It returns the number of times the timer had to be
deleted before we finally stopped it from adding itself back in.


\section{Locking Speed}
\label{kernel-hacking/locking:locking-speed}
There are three main things to worry about when considering speed of
some code which does locking. First is concurrency: how many things are
going to be waiting while someone else is holding a lock. Second is the
time taken to actually acquire and release an uncontended lock. Third is
using fewer, or smarter locks. I'm assuming that the lock is used fairly
often: otherwise, you wouldn't be concerned about efficiency.

Concurrency depends on how long the lock is usually held: you should
hold the lock for as long as needed, but no longer. In the cache
example, we always create the object without the lock held, and then
grab the lock only when we are ready to insert it in the list.

Acquisition times depend on how much damage the lock operations do to
the pipeline (pipeline stalls) and how likely it is that this CPU was
the last one to grab the lock (ie. is the lock cache-hot for this CPU):
on a machine with more CPUs, this likelihood drops fast. Consider a
700MHz Intel Pentium III: an instruction takes about 0.7ns, an atomic
increment takes about 58ns, a lock which is cache-hot on this CPU takes
160ns, and a cacheline transfer from another CPU takes an additional 170
to 360ns. (These figures from Paul McKenney's \href{http://www.linuxjournal.com/article.php?sid=6993}{Linux Journal RCU
article}).

These two aims conflict: holding a lock for a short time might be done
by splitting locks into parts (such as in our final per-object-lock
example), but this increases the number of lock acquisitions, and the
results are often slower than having a single lock. This is another
reason to advocate locking simplicity.

The third concern is addressed below: there are some methods to reduce
the amount of locking which needs to be done.


\subsection{Read/Write Lock Variants}
\label{kernel-hacking/locking:read-write-lock-variants}
Both spinlocks and mutexes have read/write variants: \code{rwlock\_t} and
\code{struct rw\_semaphore}. These divide
users into two classes: the readers and the writers. If you are only
reading the data, you can get a read lock, but to write to the data you
need the write lock. Many people can hold a read lock, but a writer must
be sole holder.

If your code divides neatly along reader/writer lines (as our cache code
does), and the lock is held by readers for significant lengths of time,
using these locks can help. They are slightly slower than the normal
locks though, so in practice \code{rwlock\_t} is not usually worthwhile.


\subsection{Avoiding Locks: Read Copy Update}
\label{kernel-hacking/locking:avoiding-locks-read-copy-update}
There is a special method of read/write locking called Read Copy Update.
Using RCU, the readers can avoid taking a lock altogether: as we expect
our cache to be read more often than updated (otherwise the cache is a
waste of time), it is a candidate for this optimization.

How do we get rid of read locks? Getting rid of read locks means that
writers may be changing the list underneath the readers. That is
actually quite simple: we can read a linked list while an element is
being added if the writer adds the element very carefully. For example,
adding \code{new} to a single linked list called \code{list}:

\begin{Verbatim}[commandchars=\\\{\}]
new\PYGZhy{}\PYGZgt{}next = list\PYGZhy{}\PYGZgt{}next;
wmb();
list\PYGZhy{}\PYGZgt{}next = new;
\end{Verbatim}

The \code{wmb()} is a write memory barrier. It ensures that the
first operation (setting the new element's \code{next} pointer) is complete
and will be seen by all CPUs, before the second operation is (putting
the new element into the list). This is important, since modern
compilers and modern CPUs can both reorder instructions unless told
otherwise: we want a reader to either not see the new element at all, or
see the new element with the \code{next} pointer correctly pointing at the
rest of the list.

Fortunately, there is a function to do this for standard
\code{struct list\_head} lists:
\code{list\_add\_rcu()} (\code{include/linux/list.h}).

Removing an element from the list is even simpler: we replace the
pointer to the old element with a pointer to its successor, and readers
will either see it, or skip over it.

\begin{Verbatim}[commandchars=\\\{\}]
list\PYGZhy{}\PYGZgt{}next = old\PYGZhy{}\PYGZgt{}next;
\end{Verbatim}

There is \code{list\_del\_rcu()} (\code{include/linux/list.h}) which
does this (the normal version poisons the old object, which we don't
want).

The reader must also be careful: some CPUs can look through the \code{next}
pointer to start reading the contents of the next element early, but
don't realize that the pre-fetched contents is wrong when the \code{next}
pointer changes underneath them. Once again, there is a
\code{list\_for\_each\_entry\_rcu()} (\code{include/linux/list.h})
to help you. Of course, writers can just use
\code{list\_for\_each\_entry()}, since there cannot be two
simultaneous writers.

Our final dilemma is this: when can we actually destroy the removed
element? Remember, a reader might be stepping through this element in
the list right now: if we free this element and the \code{next} pointer
changes, the reader will jump off into garbage and crash. We need to
wait until we know that all the readers who were traversing the list
when we deleted the element are finished. We use
\code{call\_rcu()} to register a callback which will actually
destroy the object once all pre-existing readers are finished.
Alternatively, \code{synchronize\_rcu()} may be used to block
until all pre-existing are finished.

But how does Read Copy Update know when the readers are finished? The
method is this: firstly, the readers always traverse the list inside
\code{rcu\_read\_lock()}/\code{rcu\_read\_unlock()} pairs:
these simply disable preemption so the reader won't go to sleep while
reading the list.

RCU then waits until every other CPU has slept at least once: since
readers cannot sleep, we know that any readers which were traversing the
list during the deletion are finished, and the callback is triggered.
The real Read Copy Update code is a little more optimized than this, but
this is the fundamental idea.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{} cache.c.perobjectlock   2003\PYGZhy{}12\PYGZhy{}11 17:15:03.000000000 +1100
+++ cache.c.rcupdate    2003\PYGZhy{}12\PYGZhy{}11 17:55:14.000000000 +1100
@@ \PYGZhy{}1,15 +1,18 @@
 \PYGZsh{}include \PYGZlt{}linux/list.h\PYGZgt{}
 \PYGZsh{}include \PYGZlt{}linux/slab.h\PYGZgt{}
 \PYGZsh{}include \PYGZlt{}linux/string.h\PYGZgt{}
+\PYGZsh{}include \PYGZlt{}linux/rcupdate.h\PYGZgt{}
 \PYGZsh{}include \PYGZlt{}linux/mutex.h\PYGZgt{}
 \PYGZsh{}include \PYGZlt{}asm/errno.h\PYGZgt{}

 struct object
 \PYGZob{}
\PYGZhy{}        /* These two protected by cache\PYGZus{}lock. */
+        /* This is protected by RCU */
         struct list\PYGZus{}head list;
         int popularity;

+        struct rcu\PYGZus{}head rcu;
+
         atomic\PYGZus{}t refcnt;

         /* Doesn\PYGZsq{}t change once created. */
@@ \PYGZhy{}40,7 +43,7 @@
 \PYGZob{}
         struct object *i;

\PYGZhy{}        list\PYGZus{}for\PYGZus{}each\PYGZus{}entry(i, \PYGZam{}cache, list) \PYGZob{}
+        list\PYGZus{}for\PYGZus{}each\PYGZus{}entry\PYGZus{}rcu(i, \PYGZam{}cache, list) \PYGZob{}
                 if (i\PYGZhy{}\PYGZgt{}id == id) \PYGZob{}
                         i\PYGZhy{}\PYGZgt{}popularity++;
                         return i;
@@ \PYGZhy{}49,19 +52,25 @@
         return NULL;
 \PYGZcb{}

+/* Final discard done once we know no readers are looking. */
+static void cache\PYGZus{}delete\PYGZus{}rcu(void *arg)
+\PYGZob{}
+        object\PYGZus{}put(arg);
+\PYGZcb{}
+
 /* Must be holding cache\PYGZus{}lock */
 static void \PYGZus{}\PYGZus{}cache\PYGZus{}delete(struct object *obj)
 \PYGZob{}
         BUG\PYGZus{}ON(!obj);
\PYGZhy{}        list\PYGZus{}del(\PYGZam{}obj\PYGZhy{}\PYGZgt{}list);
\PYGZhy{}        object\PYGZus{}put(obj);
+        list\PYGZus{}del\PYGZus{}rcu(\PYGZam{}obj\PYGZhy{}\PYGZgt{}list);
         cache\PYGZus{}num\PYGZhy{}\PYGZhy{};
+        call\PYGZus{}rcu(\PYGZam{}obj\PYGZhy{}\PYGZgt{}rcu, cache\PYGZus{}delete\PYGZus{}rcu);
 \PYGZcb{}

 /* Must be holding cache\PYGZus{}lock */
 static void \PYGZus{}\PYGZus{}cache\PYGZus{}add(struct object *obj)
 \PYGZob{}
\PYGZhy{}        list\PYGZus{}add(\PYGZam{}obj\PYGZhy{}\PYGZgt{}list, \PYGZam{}cache);
+        list\PYGZus{}add\PYGZus{}rcu(\PYGZam{}obj\PYGZhy{}\PYGZgt{}list, \PYGZam{}cache);
         if (++cache\PYGZus{}num \PYGZgt{} MAX\PYGZus{}CACHE\PYGZus{}SIZE) \PYGZob{}
                 struct object *i, *outcast = NULL;
                 list\PYGZus{}for\PYGZus{}each\PYGZus{}entry(i, \PYGZam{}cache, list) \PYGZob{}
@@ \PYGZhy{}104,12 +114,11 @@
 struct object *cache\PYGZus{}find(int id)
 \PYGZob{}
         struct object *obj;
\PYGZhy{}        unsigned long flags;

\PYGZhy{}        spin\PYGZus{}lock\PYGZus{}irqsave(\PYGZam{}cache\PYGZus{}lock, flags);
+        rcu\PYGZus{}read\PYGZus{}lock();
         obj = \PYGZus{}\PYGZus{}cache\PYGZus{}find(id);
         if (obj)
                 object\PYGZus{}get(obj);
\PYGZhy{}        spin\PYGZus{}unlock\PYGZus{}irqrestore(\PYGZam{}cache\PYGZus{}lock, flags);
+        rcu\PYGZus{}read\PYGZus{}unlock();
         return obj;
 \PYGZcb{}
\end{Verbatim}

Note that the reader will alter the popularity member in
\code{\_\_cache\_find()}, and now it doesn't hold a lock. One
solution would be to make it an \code{atomic\_t}, but for this usage, we
don't really care about races: an approximate result is good enough, so
I didn't change it.

The result is that \code{cache\_find()} requires no
synchronization with any other functions, so is almost as fast on SMP as
it would be on UP.

There is a further optimization possible here: remember our original
cache code, where there were no reference counts and the caller simply
held the lock whenever using the object? This is still possible: if you
hold the lock, no one can delete the object, so you don't need to get
and put the reference count.

Now, because the `read lock' in RCU is simply disabling preemption, a
caller which always has preemption disabled between calling
\code{cache\_find()} and \code{object\_put()} does not
need to actually get and put the reference count: we could expose
\code{\_\_cache\_find()} by making it non-static, and such
callers could simply call that.

The benefit here is that the reference count is not written to: the
object is not altered in any way, which is much faster on SMP machines
due to caching.


\subsection{Per-CPU Data}
\label{kernel-hacking/locking:per-cpu-data}
Another technique for avoiding locking which is used fairly widely is to
duplicate information for each CPU. For example, if you wanted to keep a
count of a common condition, you could use a spin lock and a single
counter. Nice and simple.

If that was too slow (it's usually not, but if you've got a really big
machine to test on and can show that it is), you could instead use a
counter for each CPU, then none of them need an exclusive lock. See
\code{DEFINE\_PER\_CPU()}, \code{get\_cpu\_var()} and
\code{put\_cpu\_var()} (\code{include/linux/percpu.h}).

Of particular use for simple per-cpu counters is the \code{local\_t} type,
and the \code{cpu\_local\_inc()} and related functions, which are
more efficient than simple code on some architectures
(\code{include/asm/local.h}).

Note that there is no simple, reliable way of getting an exact value of
such a counter, without introducing more locks. This is not a problem
for some uses.


\subsection{Data Which Mostly Used By An IRQ Handler}
\label{kernel-hacking/locking:data-which-mostly-used-by-an-irq-handler}
If data is always accessed from within the same IRQ handler, you don't
need a lock at all: the kernel already guarantees that the irq handler
will not run simultaneously on multiple CPUs.

Manfred Spraul points out that you can still do this, even if the data
is very occasionally accessed in user context or softirqs/tasklets. The
irq handler doesn't use a lock, and all other accesses are done as so:

\begin{Verbatim}[commandchars=\\\{\}]
spin\PYGZus{}lock(\PYGZam{}lock);
disable\PYGZus{}irq(irq);
...
enable\PYGZus{}irq(irq);
spin\PYGZus{}unlock(\PYGZam{}lock);
\end{Verbatim}

The \code{disable\_irq()} prevents the irq handler from running
(and waits for it to finish if it's currently running on other CPUs).
The spinlock prevents any other accesses happening at the same time.
Naturally, this is slower than just a \code{spin\_lock\_irq()}
call, so it only makes sense if this type of access happens extremely
rarely.


\section{What Functions Are Safe To Call From Interrupts?}
\label{kernel-hacking/locking:what-functions-are-safe-to-call-from-interrupts}
Many functions in the kernel sleep (ie. call schedule()) directly or
indirectly: you can never call them while holding a spinlock, or with
preemption disabled. This also means you need to be in user context:
calling them from an interrupt is illegal.


\subsection{Some Functions Which Sleep}
\label{kernel-hacking/locking:some-functions-which-sleep}
The most common ones are listed below, but you usually have to read the
code to find out if other calls are safe. If everyone else who calls it
can sleep, you probably need to be able to sleep, too. In particular,
registration and deregistration functions usually expect to be called
from user context, and can sleep.
\begin{itemize}
\item {} 
Accesses to userspace:
\begin{itemize}
\item {} 
\code{copy\_from\_user()}

\item {} 
\code{copy\_to\_user()}

\item {} 
\code{get\_user()}

\item {} 
\code{put\_user()}

\end{itemize}

\item {} 
\code{kmalloc(GFP\_KERNEL)}

\item {} 
{\hyperref[kernel\string-hacking/locking:c.mutex_lock_interruptible]{\emph{\code{mutex\_lock\_interruptible()}}}} and
{\hyperref[kernel\string-hacking/locking:c.mutex_lock]{\emph{\code{mutex\_lock()}}}}

There is a {\hyperref[kernel\string-hacking/locking:c.mutex_trylock]{\emph{\code{mutex\_trylock()}}}} which does not sleep.
Still, it must not be used inside interrupt context since its
implementation is not safe for that. {\hyperref[kernel\string-hacking/locking:c.mutex_unlock]{\emph{\code{mutex\_unlock()}}}}
will also never sleep. It cannot be used in interrupt context either
since a mutex must be released by the same task that acquired it.

\end{itemize}


\subsection{Some Functions Which Don't Sleep}
\label{kernel-hacking/locking:some-functions-which-don-t-sleep}
Some functions are safe to call from any context, or holding almost any
lock.
\begin{itemize}
\item {} 
\code{printk()}

\item {} 
\code{kfree()}

\item {} 
\code{add\_timer()} and \code{del\_timer()}

\end{itemize}


\section{Mutex API reference}
\label{kernel-hacking/locking:mutex-api-reference}\index{mutex\_init (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.mutex_init}\pysiglinewithargsret{\bfcode{mutex\_init}}{\emph{mutex}}{}
initialize the mutex

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{mutex}}] \leavevmode
the mutex to be initialized

\end{description}

\textbf{Description}

Initialize the mutex to unlocked state.

It is not allowed to initialize an already locked mutex.
\index{mutex\_is\_locked (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.mutex_is_locked}\pysiglinewithargsret{bool \bfcode{mutex\_is\_locked}}{struct mutex *\emph{ lock}}{}
is the mutex locked

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mutex * lock}}] \leavevmode
the mutex to be queried

\end{description}

\textbf{Description}

Returns true if the mutex is locked, false if unlocked.
\index{mutex\_trylock\_recursive (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.mutex_trylock_recursive}\pysiglinewithargsret{enum mutex\_trylock\_recursive\_enum \bfcode{mutex\_trylock\_recursive}}{struct mutex *\emph{ lock}}{}
trylock variant that allows recursive locking

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mutex * lock}}] \leavevmode
mutex to be locked

\end{description}

\textbf{Description}

This function should not be used, \_ever\_. It is purely for hysterical GEM
raisins, and once those are gone this will be removed.

\textbf{Return}
\begin{itemize}
\item {} 
MUTEX\_TRYLOCK\_FAILED    - trylock failed,

\item {} 
MUTEX\_TRYLOCK\_SUCCESS   - lock acquired,

\item {} 
MUTEX\_TRYLOCK\_RECURSIVE - we already owned the lock.

\end{itemize}
\index{mutex\_lock (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.mutex_lock}\pysiglinewithargsret{void \_\_sched \bfcode{mutex\_lock}}{struct mutex *\emph{ lock}}{}
acquire the mutex

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mutex * lock}}] \leavevmode
the mutex to be acquired

\end{description}

\textbf{Description}

Lock the mutex exclusively for this task. If the mutex is not
available right now, it will sleep until it can get it.

The mutex must later on be released by the same task that
acquired it. Recursive locking is not allowed. The task
may not exit without first unlocking the mutex. Also, kernel
memory where the mutex resides must not be freed with
the mutex still locked. The mutex must first be initialized
(or statically defined) before it can be locked. \code{memset()}-ing
the mutex to 0 is not allowed.

(The CONFIG\_DEBUG\_MUTEXES .config option turns on debugging
checks that will enforce the restrictions and will also do
deadlock debugging)

This function is similar to (but not equivalent to) \code{down()}.
\index{mutex\_unlock (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.mutex_unlock}\pysiglinewithargsret{void \_\_sched \bfcode{mutex\_unlock}}{struct mutex *\emph{ lock}}{}
release the mutex

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mutex * lock}}] \leavevmode
the mutex to be released

\end{description}

\textbf{Description}

Unlock a mutex that has been locked by this task previously.

This function must not be used in interrupt context. Unlocking
of a not locked mutex is not allowed.

This function is similar to (but not equivalent to) \code{up()}.
\index{ww\_mutex\_unlock (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.ww_mutex_unlock}\pysiglinewithargsret{void \_\_sched \bfcode{ww\_mutex\_unlock}}{struct ww\_mutex *\emph{ lock}}{}
release the w/w mutex

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ww\_mutex * lock}}] \leavevmode
the mutex to be released

\end{description}

\textbf{Description}

Unlock a mutex that has been locked by this task previously with any of the
ww\_mutex\_lock* functions (with or without an acquire context). It is
forbidden to release the locks after releasing the acquire context.

This function must not be used in interrupt context. Unlocking
of a unlocked mutex is not allowed.
\index{mutex\_lock\_interruptible (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.mutex_lock_interruptible}\pysiglinewithargsret{int \_\_sched \bfcode{mutex\_lock\_interruptible}}{struct mutex *\emph{ lock}}{}
acquire the mutex, interruptible

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mutex * lock}}] \leavevmode
the mutex to be acquired

\end{description}

\textbf{Description}

Lock the mutex like {\hyperref[kernel\string-hacking/locking:c.mutex_lock]{\emph{\code{mutex\_lock()}}}}, and return 0 if the mutex has
been acquired or sleep until the mutex becomes available. If a
signal arrives while waiting for the lock then this function
returns -EINTR.

This function is similar to (but not equivalent to) \code{down\_interruptible()}.
\index{mutex\_trylock (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.mutex_trylock}\pysiglinewithargsret{int \_\_sched \bfcode{mutex\_trylock}}{struct mutex *\emph{ lock}}{}
try to acquire the mutex, without waiting

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct mutex * lock}}] \leavevmode
the mutex to be acquired

\end{description}

\textbf{Description}

Try to acquire the mutex atomically. Returns 1 if the mutex
has been acquired successfully, and 0 on contention.

\textbf{NOTE}

this function follows the \code{spin\_trylock()} convention, so
it is negated from the \code{down\_trylock()} return values! Be careful
about this when converting semaphore users to mutexes.

This function must not be used in interrupt context. The
mutex must be released by the same task that acquired it.
\index{atomic\_dec\_and\_mutex\_lock (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.atomic_dec_and_mutex_lock}\pysiglinewithargsret{int \bfcode{atomic\_dec\_and\_mutex\_lock}}{atomic\_t *\emph{ cnt}, struct mutex *\emph{ lock}}{}
return holding mutex if we dec to 0

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{atomic\_t * cnt}}] \leavevmode
the atomic which we are to dec

\item[{\code{struct mutex * lock}}] \leavevmode
the mutex to return holding if we dec to 0

\end{description}

\textbf{Description}

return true and hold lock if we dec to 0, return false otherwise


\section{Futex API reference}
\label{kernel-hacking/locking:futex-api-reference}\index{futex\_q (C type)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.futex_q}\pysigline{struct \bfcode{futex\_q}}
The hashed futex queue entry, one per waiting task

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct futex\PYGZus{}q \PYGZob{}
  struct plist\PYGZus{}node list;
  struct task\PYGZus{}struct *task;
  spinlock\PYGZus{}t *lock\PYGZus{}ptr;
  union futex\PYGZus{}key key;
  struct futex\PYGZus{}pi\PYGZus{}state *pi\PYGZus{}state;
  struct rt\PYGZus{}mutex\PYGZus{}waiter *rt\PYGZus{}waiter;
  union futex\PYGZus{}key *requeue\PYGZus{}pi\PYGZus{}key;
  u32 bitset;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{list}}] \leavevmode
priority-sorted list of tasks waiting on this futex

\item[{\code{task}}] \leavevmode
the task waiting on the futex

\item[{\code{lock\_ptr}}] \leavevmode
the hash bucket lock

\item[{\code{key}}] \leavevmode
the key the futex is hashed on

\item[{\code{pi\_state}}] \leavevmode
optional priority inheritance state

\item[{\code{rt\_waiter}}] \leavevmode
rt\_waiter storage for use with requeue\_pi

\item[{\code{requeue\_pi\_key}}] \leavevmode
the requeue\_pi target futex key

\item[{\code{bitset}}] \leavevmode
bitset for the optional bitmasked wakeup

\end{description}

\textbf{Description}

We use this hashed waitqueue, instead of a normal wait\_queue\_entry\_t, so
we can wake only the relevant ones (hashed queues may be shared).

A futex\_q has a woken state, just like tasks have TASK\_RUNNING.
It is considered woken when plist\_node\_empty(\code{q-\textgreater{}list}) \textbar{}\textbar{} q-\textgreater{}lock\_ptr == 0.
The order of wakeup is always to make the first condition true, then
the second.

PI futexes are typically woken before they are removed from the hash list via
the rt\_mutex code. See \code{unqueue\_me\_pi()}.
\index{hash\_futex (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.hash_futex}\pysiglinewithargsret{struct futex\_hash\_bucket * \bfcode{hash\_futex}}{union futex\_key *\emph{ key}}{}
Return the hash bucket in the global hash

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{union futex\_key * key}}] \leavevmode
Pointer to the futex key for which the hash is calculated

\end{description}

\textbf{Description}

We hash on the keys returned from get\_futex\_key (see below) and return the
corresponding hash bucket in the global hash.
\index{match\_futex (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.match_futex}\pysiglinewithargsret{int \bfcode{match\_futex}}{union futex\_key *\emph{ key1}, union futex\_key *\emph{ key2}}{}
Check whether two futex keys are equal

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{union futex\_key * key1}}] \leavevmode
Pointer to key1

\item[{\code{union futex\_key * key2}}] \leavevmode
Pointer to key2

\end{description}

\textbf{Description}

Return 1 if two futex\_keys are equal, 0 otherwise.
\index{get\_futex\_key (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.get_futex_key}\pysiglinewithargsret{int \bfcode{get\_futex\_key}}{u32 \_\_user *\emph{ uaddr}, int\emph{ fshared}, union futex\_key *\emph{ key}, int\emph{ rw}}{}
Get parameters which are the keys for a futex

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u32 \_\_user * uaddr}}] \leavevmode
virtual address of the futex

\item[{\code{int fshared}}] \leavevmode
0 for a PROCESS\_PRIVATE futex, 1 for PROCESS\_SHARED

\item[{\code{union futex\_key * key}}] \leavevmode
address where result is stored.

\item[{\code{int rw}}] \leavevmode
mapping needs to be read/write (values: VERIFY\_READ,
VERIFY\_WRITE)

\end{description}

\textbf{Return}

a negative error code or 0

The key words are stored in \textbf{key} on success.

For shared mappings, it's (page-\textgreater{}index, file\_inode(vma-\textgreater{}vm\_file),
offset\_within\_page).  For private mappings, it's (uaddr, current-\textgreater{}mm).
We can usually work out the index without swapping in the page.

\code{lock\_page()} might sleep, the caller should not hold a spinlock.
\index{fault\_in\_user\_writeable (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.fault_in_user_writeable}\pysiglinewithargsret{int \bfcode{fault\_in\_user\_writeable}}{u32 \_\_user *\emph{ uaddr}}{}
Fault in user address and verify RW access

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u32 \_\_user * uaddr}}] \leavevmode
pointer to faulting user space address

\end{description}

\textbf{Description}

Slow path to fixup the fault we just took in the atomic write
access to \textbf{uaddr}.

We have no generic implementation of a non-destructive write to the
user address. We know that we faulted in the atomic pagefault
disabled section so we can as well avoid the \#PF overhead by
calling \code{get\_user\_pages()} right away.
\index{futex\_top\_waiter (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.futex_top_waiter}\pysiglinewithargsret{struct {\hyperref[kernel\string-hacking/locking:c.futex_q]{\emph{futex\_q}}} * \bfcode{futex\_top\_waiter}}{struct futex\_hash\_bucket *\emph{ hb}, union futex\_key *\emph{ key}}{}
Return the highest priority waiter on a futex

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct futex\_hash\_bucket * hb}}] \leavevmode
the hash bucket the futex\_q's reside in

\item[{\code{union futex\_key * key}}] \leavevmode
the futex key (to distinguish it from other futex futex\_q's)

\end{description}

\textbf{Description}

Must be called with the hb lock held.
\index{futex\_lock\_pi\_atomic (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.futex_lock_pi_atomic}\pysiglinewithargsret{int \bfcode{futex\_lock\_pi\_atomic}}{u32 \_\_user *\emph{ uaddr}, struct futex\_hash\_bucket *\emph{ hb}, union futex\_key *\emph{ key}, struct futex\_pi\_state **\emph{ ps}, struct task\_struct *\emph{ task}, int\emph{ set\_waiters}}{}
Atomic work required to acquire a pi aware futex

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u32 \_\_user * uaddr}}] \leavevmode
the pi futex user address

\item[{\code{struct futex\_hash\_bucket * hb}}] \leavevmode
the pi futex hash bucket

\item[{\code{union futex\_key * key}}] \leavevmode
the futex key associated with uaddr and hb

\item[{\code{struct futex\_pi\_state ** ps}}] \leavevmode
the pi\_state pointer where we store the result of the
lookup

\item[{\code{struct task\_struct * task}}] \leavevmode
the task to perform the atomic lock work for.  This will
be ``current'' except in the case of requeue pi.

\item[{\code{int set\_waiters}}] \leavevmode
force setting the FUTEX\_WAITERS bit (1) or not (0)

\end{description}

\textbf{Return}
\begin{itemize}
\item {} 
0 - ready to wait;

\item {} 
1 - acquired the lock;

\item {} 
\textless{}0 - error

\end{itemize}

The hb-\textgreater{}lock and futex\_key refs shall be held by the caller.
\index{\_\_unqueue\_futex (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.__unqueue_futex}\pysiglinewithargsret{void \bfcode{\_\_unqueue\_futex}}{struct {\hyperref[kernel\string-hacking/locking:c.futex_q]{\emph{futex\_q}}} *\emph{ q}}{}
Remove the futex\_q from its futex\_hash\_bucket

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct futex\_q * q}}] \leavevmode
The futex\_q to unqueue

\end{description}

\textbf{Description}

The q-\textgreater{}lock\_ptr must not be NULL and must be held by the caller.
\index{requeue\_futex (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.requeue_futex}\pysiglinewithargsret{void \bfcode{requeue\_futex}}{struct {\hyperref[kernel\string-hacking/locking:c.futex_q]{\emph{futex\_q}}} *\emph{ q}, struct futex\_hash\_bucket *\emph{ hb1}, struct futex\_hash\_bucket *\emph{ hb2}, union futex\_key *\emph{ key2}}{}
Requeue a futex\_q from one hb to another

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct futex\_q * q}}] \leavevmode
the futex\_q to requeue

\item[{\code{struct futex\_hash\_bucket * hb1}}] \leavevmode
the source hash\_bucket

\item[{\code{struct futex\_hash\_bucket * hb2}}] \leavevmode
the target hash\_bucket

\item[{\code{union futex\_key * key2}}] \leavevmode
the new key for the requeued futex\_q

\end{description}
\index{requeue\_pi\_wake\_futex (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.requeue_pi_wake_futex}\pysiglinewithargsret{void \bfcode{requeue\_pi\_wake\_futex}}{struct {\hyperref[kernel\string-hacking/locking:c.futex_q]{\emph{futex\_q}}} *\emph{ q}, union futex\_key *\emph{ key}, struct futex\_hash\_bucket *\emph{ hb}}{}
Wake a task that acquired the lock during requeue

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct futex\_q * q}}] \leavevmode
the futex\_q

\item[{\code{union futex\_key * key}}] \leavevmode
the key of the requeue target futex

\item[{\code{struct futex\_hash\_bucket * hb}}] \leavevmode
the hash\_bucket of the requeue target futex

\end{description}

\textbf{Description}

During futex\_requeue, with requeue\_pi=1, it is possible to acquire the
target futex if it is uncontended or via a lock steal.  Set the futex\_q key
to the requeue target futex so the waiter can detect the wakeup on the right
futex, but remove it from the hb and NULL the rt\_waiter so it can detect
atomic lock acquisition.  Set the q-\textgreater{}lock\_ptr to the requeue target hb-\textgreater{}lock
to protect access to the pi\_state to fixup the owner later.  Must be called
with both q-\textgreater{}lock\_ptr and hb-\textgreater{}lock held.
\index{futex\_proxy\_trylock\_atomic (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.futex_proxy_trylock_atomic}\pysiglinewithargsret{int \bfcode{futex\_proxy\_trylock\_atomic}}{u32 \_\_user *\emph{ pifutex}, struct futex\_hash\_bucket *\emph{ hb1}, struct futex\_hash\_bucket *\emph{ hb2}, union futex\_key *\emph{ key1}, union futex\_key *\emph{ key2}, struct futex\_pi\_state **\emph{ ps}, int\emph{ set\_waiters}}{}
Attempt an atomic lock for the top waiter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u32 \_\_user * pifutex}}] \leavevmode
the user address of the to futex

\item[{\code{struct futex\_hash\_bucket * hb1}}] \leavevmode
the from futex hash bucket, must be locked by the caller

\item[{\code{struct futex\_hash\_bucket * hb2}}] \leavevmode
the to futex hash bucket, must be locked by the caller

\item[{\code{union futex\_key * key1}}] \leavevmode
the from futex key

\item[{\code{union futex\_key * key2}}] \leavevmode
the to futex key

\item[{\code{struct futex\_pi\_state ** ps}}] \leavevmode
address to store the pi\_state pointer

\item[{\code{int set\_waiters}}] \leavevmode
force setting the FUTEX\_WAITERS bit (1) or not (0)

\end{description}

\textbf{Description}

Try and get the lock on behalf of the top waiter if we can do it atomically.
Wake the top waiter if we succeed.  If the caller specified set\_waiters,
then direct {\hyperref[kernel\string-hacking/locking:c.futex_lock_pi_atomic]{\emph{\code{futex\_lock\_pi\_atomic()}}}} to force setting the FUTEX\_WAITERS bit.
hb1 and hb2 must be held by the caller.

\textbf{Return}
\begin{itemize}
\item {} 
0 - failed to acquire the lock atomically;

\item {} 
\textgreater{}0 - acquired the lock, return value is vpid of the top\_waiter

\item {} 
\textless{}0 - error

\end{itemize}
\index{futex\_requeue (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.futex_requeue}\pysiglinewithargsret{int \bfcode{futex\_requeue}}{u32 \_\_user *\emph{ uaddr1}, unsigned int\emph{ flags}, u32 \_\_user *\emph{ uaddr2}, int\emph{ nr\_wake}, int\emph{ nr\_requeue}, u32 *\emph{ cmpval}, int\emph{ requeue\_pi}}{}
Requeue waiters from uaddr1 to uaddr2

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u32 \_\_user * uaddr1}}] \leavevmode
source futex user address

\item[{\code{unsigned int flags}}] \leavevmode
futex flags (FLAGS\_SHARED, etc.)

\item[{\code{u32 \_\_user * uaddr2}}] \leavevmode
target futex user address

\item[{\code{int nr\_wake}}] \leavevmode
number of waiters to wake (must be 1 for requeue\_pi)

\item[{\code{int nr\_requeue}}] \leavevmode
number of waiters to requeue (0-INT\_MAX)

\item[{\code{u32 * cmpval}}] \leavevmode
\textbf{uaddr1} expected value (or \code{NULL})

\item[{\code{int requeue\_pi}}] \leavevmode
if we are attempting to requeue from a non-pi futex to a
pi futex (pi to pi requeue is not supported)

\end{description}

\textbf{Description}

Requeue waiters on uaddr1 to uaddr2. In the requeue\_pi case, try to acquire
uaddr2 atomically on behalf of the top waiter.

\textbf{Return}
\begin{itemize}
\item {} 
\textgreater{}=0 - on success, the number of tasks requeued or woken;

\item {} 
\textless{}0 - on error

\end{itemize}
\index{queue\_me (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.queue_me}\pysiglinewithargsret{void \bfcode{queue\_me}}{struct {\hyperref[kernel\string-hacking/locking:c.futex_q]{\emph{futex\_q}}} *\emph{ q}, struct futex\_hash\_bucket *\emph{ hb}}{}
Enqueue the futex\_q on the futex\_hash\_bucket

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct futex\_q * q}}] \leavevmode
The futex\_q to enqueue

\item[{\code{struct futex\_hash\_bucket * hb}}] \leavevmode
The destination hash bucket

\end{description}

\textbf{Description}

The hb-\textgreater{}lock must be held by the caller, and is released here. A call to
{\hyperref[kernel\string-hacking/locking:c.queue_me]{\emph{\code{queue\_me()}}}} is typically paired with exactly one call to {\hyperref[kernel\string-hacking/locking:c.unqueue_me]{\emph{\code{unqueue\_me()}}}}.  The
exceptions involve the PI related operations, which may use \code{unqueue\_me\_pi()}
or nothing if the unqueue is done as part of the wake process and the unqueue
state is implicit in the state of woken task (see {\hyperref[kernel\string-hacking/locking:c.futex_wait_requeue_pi]{\emph{\code{futex\_wait\_requeue\_pi()}}}} for
an example).
\index{unqueue\_me (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.unqueue_me}\pysiglinewithargsret{int \bfcode{unqueue\_me}}{struct {\hyperref[kernel\string-hacking/locking:c.futex_q]{\emph{futex\_q}}} *\emph{ q}}{}
Remove the futex\_q from its futex\_hash\_bucket

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct futex\_q * q}}] \leavevmode
The futex\_q to unqueue

\end{description}

\textbf{Description}

The q-\textgreater{}lock\_ptr must not be held by the caller. A call to {\hyperref[kernel\string-hacking/locking:c.unqueue_me]{\emph{\code{unqueue\_me()}}}} must
be paired with exactly one earlier call to {\hyperref[kernel\string-hacking/locking:c.queue_me]{\emph{\code{queue\_me()}}}}.

\textbf{Return}
\begin{itemize}
\item {} 
1 - if the futex\_q was still queued (and we removed unqueued it);

\item {} 
0 - if the futex\_q was already removed by the waking thread

\end{itemize}
\index{fixup\_owner (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.fixup_owner}\pysiglinewithargsret{int \bfcode{fixup\_owner}}{u32 \_\_user *\emph{ uaddr}, struct {\hyperref[kernel\string-hacking/locking:c.futex_q]{\emph{futex\_q}}} *\emph{ q}, int\emph{ locked}}{}
Post lock pi\_state and corner case management

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u32 \_\_user * uaddr}}] \leavevmode
user address of the futex

\item[{\code{struct futex\_q * q}}] \leavevmode
futex\_q (contains pi\_state and access to the rt\_mutex)

\item[{\code{int locked}}] \leavevmode
if the attempt to take the rt\_mutex succeeded (1) or not (0)

\end{description}

\textbf{Description}

After attempting to lock an rt\_mutex, this function is called to cleanup
the pi\_state owner as well as handle race conditions that may allow us to
acquire the lock. Must be called with the hb lock held.

\textbf{Return}
\begin{itemize}
\item {} 
1 - success, lock taken;

\item {} 
0 - success, lock not taken;

\item {} 
\textless{}0 - on error (-EFAULT)

\end{itemize}
\index{futex\_wait\_queue\_me (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.futex_wait_queue_me}\pysiglinewithargsret{void \bfcode{futex\_wait\_queue\_me}}{struct futex\_hash\_bucket *\emph{ hb}, struct {\hyperref[kernel\string-hacking/locking:c.futex_q]{\emph{futex\_q}}} *\emph{ q}, struct hrtimer\_sleeper *\emph{ timeout}}{}
{\hyperref[kernel\string-hacking/locking:c.queue_me]{\emph{\code{queue\_me()}}}} and wait for wakeup, timeout, or signal

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct futex\_hash\_bucket * hb}}] \leavevmode
the futex hash bucket, must be locked by the caller

\item[{\code{struct futex\_q * q}}] \leavevmode
the futex\_q to queue up on

\item[{\code{struct hrtimer\_sleeper * timeout}}] \leavevmode
the prepared hrtimer\_sleeper, or null for no timeout

\end{description}
\index{futex\_wait\_setup (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.futex_wait_setup}\pysiglinewithargsret{int \bfcode{futex\_wait\_setup}}{u32 \_\_user *\emph{ uaddr}, u32\emph{ val}, unsigned int\emph{ flags}, struct {\hyperref[kernel\string-hacking/locking:c.futex_q]{\emph{futex\_q}}} *\emph{ q}, struct futex\_hash\_bucket **\emph{ hb}}{}
Prepare to wait on a futex

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u32 \_\_user * uaddr}}] \leavevmode
the futex userspace address

\item[{\code{u32 val}}] \leavevmode
the expected value

\item[{\code{unsigned int flags}}] \leavevmode
futex flags (FLAGS\_SHARED, etc.)

\item[{\code{struct futex\_q * q}}] \leavevmode
the associated futex\_q

\item[{\code{struct futex\_hash\_bucket ** hb}}] \leavevmode
storage for hash\_bucket pointer to be returned to caller

\end{description}

\textbf{Description}

Setup the futex\_q and locate the hash\_bucket.  Get the futex value and
compare it with the expected value.  Handle atomic faults internally.
Return with the hb lock held and a q.key reference on success, and unlocked
with no q.key reference on failure.

\textbf{Return}
\begin{itemize}
\item {} 
0 - uaddr contains val and hb has been locked;

\item {} 
\textless{}1 - -EFAULT or -EWOULDBLOCK (uaddr does not contain val) and hb is unlocked

\end{itemize}
\index{handle\_early\_requeue\_pi\_wakeup (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.handle_early_requeue_pi_wakeup}\pysiglinewithargsret{int \bfcode{handle\_early\_requeue\_pi\_wakeup}}{struct futex\_hash\_bucket *\emph{ hb}, struct {\hyperref[kernel\string-hacking/locking:c.futex_q]{\emph{futex\_q}}} *\emph{ q}, union futex\_key *\emph{ key2}, struct hrtimer\_sleeper *\emph{ timeout}}{}
Detect early wakeup on the initial futex

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct futex\_hash\_bucket * hb}}] \leavevmode
the hash\_bucket futex\_q was original enqueued on

\item[{\code{struct futex\_q * q}}] \leavevmode
the futex\_q woken while waiting to be requeued

\item[{\code{union futex\_key * key2}}] \leavevmode
the futex\_key of the requeue target futex

\item[{\code{struct hrtimer\_sleeper * timeout}}] \leavevmode
the timeout associated with the wait (NULL if none)

\end{description}

\textbf{Description}

Detect if the task was woken on the initial futex as opposed to the requeue
target futex.  If so, determine if it was a timeout or a signal that caused
the wakeup and return the appropriate error code to the caller.  Must be
called with the hb lock held.

\textbf{Return}
\begin{itemize}
\item {} 
0 = no early wakeup detected;

\item {} 
\textless{}0 = -ETIMEDOUT or -ERESTARTNOINTR

\end{itemize}
\index{futex\_wait\_requeue\_pi (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.futex_wait_requeue_pi}\pysiglinewithargsret{int \bfcode{futex\_wait\_requeue\_pi}}{u32 \_\_user *\emph{ uaddr}, unsigned int\emph{ flags}, u32\emph{ val}, ktime\_t *\emph{ abs\_time}, u32\emph{ bitset}, u32 \_\_user *\emph{ uaddr2}}{}
Wait on uaddr and take uaddr2

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{u32 \_\_user * uaddr}}] \leavevmode
the futex we initially wait on (non-pi)

\item[{\code{unsigned int flags}}] \leavevmode
futex flags (FLAGS\_SHARED, FLAGS\_CLOCKRT, etc.), they must be
the same type, no requeueing from private to shared, etc.

\item[{\code{u32 val}}] \leavevmode
the expected value of uaddr

\item[{\code{ktime\_t * abs\_time}}] \leavevmode
absolute timeout

\item[{\code{u32 bitset}}] \leavevmode
32 bit wakeup bitset set by userspace, defaults to all

\item[{\code{u32 \_\_user * uaddr2}}] \leavevmode
the pi futex we will take prior to returning to user-space

\end{description}

\textbf{Description}

The caller will wait on uaddr and will be requeued by {\hyperref[kernel\string-hacking/locking:c.futex_requeue]{\emph{\code{futex\_requeue()}}}} to
uaddr2 which must be PI aware and unique from uaddr.  Normal wakeup will wake
on uaddr2 and complete the acquisition of the rt\_mutex prior to returning to
userspace.  This ensures the rt\_mutex maintains an owner when it has waiters;
without one, the pi logic would not know which task to boost/deboost, if
there was a need to.

We call schedule in {\hyperref[kernel\string-hacking/locking:c.futex_wait_queue_me]{\emph{\code{futex\_wait\_queue\_me()}}}} when we enqueue and return there
via the following--
1) wakeup on uaddr2 after an atomic lock acquisition by {\hyperref[kernel\string-hacking/locking:c.futex_requeue]{\emph{\code{futex\_requeue()}}}}
2) wakeup on uaddr2 after a requeue
3) signal
4) timeout

If 3, cleanup and return -ERESTARTNOINTR.

If 2, we may then block on trying to take the rt\_mutex and return via:
5) successful lock
6) signal
7) timeout
8) other lock acquisition failure

If 6, return -EWOULDBLOCK (restarting the syscall would do the same).

If 4 or 7, we cleanup and return with -ETIMEDOUT.

\textbf{Return}
\begin{itemize}
\item {} 
0 - On success;

\item {} 
\textless{}0 - On error

\end{itemize}
\index{sys\_set\_robust\_list (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.sys_set_robust_list}\pysiglinewithargsret{long \bfcode{sys\_set\_robust\_list}}{struct robust\_list\_head \_\_user *\emph{ head}, size\_t\emph{ len}}{}
Set the robust-futex list head of a task

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct robust\_list\_head \_\_user * head}}] \leavevmode
pointer to the list-head

\item[{\code{size\_t len}}] \leavevmode
length of the list-head, as userspace expects

\end{description}
\index{sys\_get\_robust\_list (C function)}

\begin{fulllineitems}
\phantomsection\label{kernel-hacking/locking:c.sys_get_robust_list}\pysiglinewithargsret{long \bfcode{sys\_get\_robust\_list}}{int\emph{ pid}, struct robust\_list\_head \_\_user *\_\_user *\emph{ head\_ptr}, size\_t \_\_user *\emph{ len\_ptr}}{}
Get the robust-futex list head of a task

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int pid}}] \leavevmode
pid of the process {[}zero for current task{]}

\item[{\code{struct robust\_list\_head \_\_user *\_\_user * head\_ptr}}] \leavevmode
pointer to a list-head pointer, the kernel fills it in

\item[{\code{size\_t \_\_user * len\_ptr}}] \leavevmode
pointer to a length field, the kernel fills in the header size

\end{description}


\section{Further reading}
\label{kernel-hacking/locking:further-reading}\begin{itemize}
\item {} 
\code{Documentation/locking/spinlocks.txt}: Linus Torvalds' spinlocking
tutorial in the kernel sources.

\item {} 
Unix Systems for Modern Architectures: Symmetric Multiprocessing and
Caching for Kernel Programmers:

Curt Schimmel's very good introduction to kernel level locking (not
written for Linux, but nearly everything applies). The book is
expensive, but really worth every penny to understand SMP locking.
{[}ISBN: 0201633388{]}

\end{itemize}


\section{Thanks}
\label{kernel-hacking/locking:thanks}
Thanks to Telsa Gwynne for DocBooking, neatening and adding style.

Thanks to Martin Pool, Philipp Rumpf, Stephen Rothwell, Paul Mackerras,
Ruedi Aschwanden, Alan Cox, Manfred Spraul, Tim Waugh, Pete Zaitcev,
James Morris, Robert Love, Paul McKenney, John Ashby for proofreading,
correcting, flaming, commenting.

Thanks to the cabal for having no influence on this document.


\section{Glossary}
\label{kernel-hacking/locking:glossary}\begin{description}
\item[{preemption}] \leavevmode
Prior to 2.5, or when \code{CONFIG\_PREEMPT} is unset, processes in user
context inside the kernel would not preempt each other (ie. you had that
CPU until you gave it up, except for interrupts). With the addition of
\code{CONFIG\_PREEMPT} in 2.5.4, this changed: when in user context, higher
priority tasks can ``cut in'': spinlocks were changed to disable
preemption, even on UP.

\item[{bh}] \leavevmode
Bottom Half: for historical reasons, functions with `\_bh' in them often
now refer to any software interrupt, e.g. \code{spin\_lock\_bh()}
blocks any software interrupt on the current CPU. Bottom halves are
deprecated, and will eventually be replaced by tasklets. Only one bottom
half will be running at any time.

\item[{Hardware Interrupt / Hardware IRQ}] \leavevmode
Hardware interrupt request. \code{in\_irq()} returns true in a
hardware interrupt handler.

\item[{Interrupt Context}] \leavevmode
Not user context: processing a hardware irq or software irq. Indicated
by the \code{in\_interrupt()} macro returning true.

\item[{SMP}] \leavevmode
Symmetric Multi-Processor: kernels compiled for multiple-CPU machines.
(\code{CONFIG\_SMP=y}).

\item[{Software Interrupt / softirq}] \leavevmode
Software interrupt handler. \code{in\_irq()} returns false;
\code{in\_softirq()} returns true. Tasklets and softirqs both
fall into the category of `software interrupts'.

Strictly speaking a softirq is one of up to 32 enumerated software
interrupts which can run on multiple CPUs at once. Sometimes used to
refer to tasklets as well (ie. all software interrupts).

\item[{tasklet}] \leavevmode
A dynamically-registrable software interrupt, which is guaranteed to
only run on one CPU at a time.

\item[{timer}] \leavevmode
A dynamically-registrable software interrupt, which is run at (or close
to) a given time. When running, it is just like a tasklet (in fact, they
are called from the \code{TIMER\_SOFTIRQ}).

\item[{UP}] \leavevmode
Uni-Processor: Non-SMP. (\code{CONFIG\_SMP=n}).

\item[{User Context}] \leavevmode
The kernel executing on behalf of a particular process (ie. a system
call or trap) or kernel thread. You can tell which process with the
\code{current} macro.) Not to be confused with userspace. Can be
interrupted by software or hardware interrupts.

\item[{Userspace}] \leavevmode
A process executing its own code outside the kernel.

\end{description}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
