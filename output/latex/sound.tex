% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,8pt,english]{sphinxmanual}


\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }


	% Use some font with UTF-8 support with XeLaTeX
        \usepackage{fontspec}
        \setsansfont{DejaVu Serif}
        \setromanfont{DejaVu Sans}
        \setmonofont{DejaVu Sans Mono}

     \usepackage[margin=0.5in, top=1in, bottom=1in]{geometry}
        \usepackage{ifthen}

        % Put notes in color and let them be inside a table
	\definecolor{NoteColor}{RGB}{204,255,255}
	\definecolor{WarningColor}{RGB}{255,204,204}
	\definecolor{AttentionColor}{RGB}{255,255,204}
	\definecolor{ImportantColor}{RGB}{192,255,204}
	\definecolor{OtherColor}{RGB}{204,204,204}
        \newlength{\mynoticelength}
        \makeatletter\newenvironment{coloredbox}[1]{%
	   \setlength{\fboxrule}{1pt}
	   \setlength{\fboxsep}{7pt}
	   \setlength{\mynoticelength}{\linewidth}
	   \addtolength{\mynoticelength}{-2\fboxsep}
	   \addtolength{\mynoticelength}{-2\fboxrule}
           \begin{lrbox}{\@tempboxa}\begin{minipage}{\mynoticelength}}{\end{minipage}\end{lrbox}%
	   \ifthenelse%
	      {\equal{\py@noticetype}{note}}%
	      {\colorbox{NoteColor}{\usebox{\@tempboxa}}}%
	      {%
	         \ifthenelse%
	         {\equal{\py@noticetype}{warning}}%
	         {\colorbox{WarningColor}{\usebox{\@tempboxa}}}%
		 {%
	            \ifthenelse%
	            {\equal{\py@noticetype}{attention}}%
	            {\colorbox{AttentionColor}{\usebox{\@tempboxa}}}%
		    {%
	               \ifthenelse%
	               {\equal{\py@noticetype}{important}}%
	               {\colorbox{ImportantColor}{\usebox{\@tempboxa}}}%
	               {\colorbox{OtherColor}{\usebox{\@tempboxa}}}%
		    }%
		 }%
	      }%
        }\makeatother

        \makeatletter
        \renewenvironment{notice}[2]{%
          \def\py@noticetype{#1}
          \begin{coloredbox}{#1}
          \bf\it
          \par\strong{#2}
          \csname py@noticestart@#1\endcsname
        }
	{
          \csname py@noticeend@\py@noticetype\endcsname
          \end{coloredbox}
        }
	\makeatother

     

\title{Linux Sound Subsystem Documentation}
\date{March 08, 2018}
\release{4.16.0-rc4+}
\author{The kernel development community}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\setcounter{tocdepth}{1}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{sound/index::doc}



\chapter{ALSA Kernel API Documentation}
\label{sound/kernel-api/index:linux-sound-subsystem-documentation}\label{sound/kernel-api/index:alsa-kernel-api-documentation}\label{sound/kernel-api/index::doc}

\section{The ALSA Driver API}
\label{sound/kernel-api/alsa-driver-api:the-alsa-driver-api}\label{sound/kernel-api/alsa-driver-api::doc}

\subsection{Management of Cards and Devices}
\label{sound/kernel-api/alsa-driver-api:management-of-cards-and-devices}

\subsubsection{Card Management}
\label{sound/kernel-api/alsa-driver-api:card-management}\index{snd\_device\_initialize (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_device_initialize}\pysiglinewithargsret{void \bfcode{snd\_device\_initialize}}{struct device *\emph{ dev}, struct snd\_card *\emph{ card}}{}
Initialize struct device for sound devices

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
device to initialize

\item[{\code{struct snd\_card * card}}] \leavevmode
card to assign, optional

\end{description}
\index{snd\_card\_new (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_card_new}\pysiglinewithargsret{int \bfcode{snd\_card\_new}}{struct device *\emph{ parent}, int\emph{ idx}, const char *\emph{ xid}, struct module *\emph{ module}, int\emph{ extra\_size}, struct snd\_card **\emph{ card\_ret}}{}
create and initialize a soundcard structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * parent}}] \leavevmode
the parent device object

\item[{\code{int idx}}] \leavevmode
card index (address) {[}0 ... (SNDRV\_CARDS-1){]}

\item[{\code{const char * xid}}] \leavevmode
card identification (ASCII string)

\item[{\code{struct module * module}}] \leavevmode
top level module for locking

\item[{\code{int extra\_size}}] \leavevmode
allocate this extra size after the main soundcard structure

\item[{\code{struct snd\_card ** card\_ret}}] \leavevmode
the pointer to store the created card instance

\end{description}

\textbf{Description}
\begin{quote}

Creates and initializes a soundcard structure.

The function allocates snd\_card instance via kzalloc with the given
space for the driver to use freely.  The allocated struct is stored
in the given card\_ret pointer.
\end{quote}

\textbf{Return}

Zero if successful or a negative error code.
\index{snd\_card\_disconnect (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_card_disconnect}\pysiglinewithargsret{int \bfcode{snd\_card\_disconnect}}{struct snd\_card *\emph{ card}}{}
disconnect all APIs from the file-operations (user space)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\end{description}

\textbf{Description}
\begin{quote}

Disconnects all APIs from the file-operations (user space).
\end{quote}

\textbf{Return}

Zero, otherwise a negative error code.

\textbf{Note}
\begin{description}
\item[{The current implementation replaces all active file-\textgreater{}f\_op with special}] \leavevmode
dummy file operations (they do nothing except release).

\end{description}
\index{snd\_card\_disconnect\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_card_disconnect_sync}\pysiglinewithargsret{void \bfcode{snd\_card\_disconnect\_sync}}{struct snd\_card *\emph{ card}}{}
disconnect card and wait until files get closed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
card object to disconnect

\end{description}

\textbf{Description}

This calls \code{snd\_card\_disconnect()} for disconnecting all belonging components
and waits until all pending files get closed.
It assures that all accesses from user-space finished so that the driver
can release its resources gracefully.
\index{snd\_card\_free\_when\_closed (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_card_free_when_closed}\pysiglinewithargsret{int \bfcode{snd\_card\_free\_when\_closed}}{struct snd\_card *\emph{ card}}{}
Disconnect the card, free it later eventually

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\end{description}

\textbf{Description}

Unlike \code{snd\_card\_free()}, this function doesn't try to release the card
resource immediately, but tries to disconnect at first.  When the card
is still in use, the function returns before freeing the resources.
The card resources will be freed when the refcount gets to zero.
\index{snd\_card\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_card_free}\pysiglinewithargsret{int \bfcode{snd\_card\_free}}{struct snd\_card *\emph{ card}}{}
frees given soundcard structure

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\end{description}

\textbf{Description}

This function releases the soundcard structure and the all assigned
devices automatically.  That is, you don't have to release the devices
by yourself.

This function waits until the all resources are properly released.

\textbf{Return}

Zero. Frees all associated devices and frees the control
interface associated to given soundcard.
\index{snd\_card\_set\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_card_set_id}\pysiglinewithargsret{void \bfcode{snd\_card\_set\_id}}{struct snd\_card *\emph{ card}, const char *\emph{ nid}}{}
set card identification name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\item[{\code{const char * nid}}] \leavevmode
new identification string

\end{description}

\textbf{Description}
\begin{quote}

This function sets the card identification and checks for name
collisions.
\end{quote}
\index{snd\_card\_add\_dev\_attr (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_card_add_dev_attr}\pysiglinewithargsret{int \bfcode{snd\_card\_add\_dev\_attr}}{struct snd\_card *\emph{ card}, const struct attribute\_group *\emph{ group}}{}
Append a new sysfs attribute group to card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
card instance

\item[{\code{const struct attribute\_group * group}}] \leavevmode
attribute group to append

\end{description}
\index{snd\_card\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_card_register}\pysiglinewithargsret{int \bfcode{snd\_card\_register}}{struct snd\_card *\emph{ card}}{}
register the soundcard

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\end{description}

\textbf{Description}
\begin{quote}

This function registers all the devices assigned to the soundcard.
Until calling this, the ALSA control interface is blocked from the
external accesses.  Thus, you should call this function at the end
of the initialization of the card.
\end{quote}

\textbf{Return}

Zero otherwise a negative error code if the registration failed.
\index{snd\_component\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_component_add}\pysiglinewithargsret{int \bfcode{snd\_component\_add}}{struct snd\_card *\emph{ card}, const char *\emph{ component}}{}
add a component string

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\item[{\code{const char * component}}] \leavevmode
the component id string

\end{description}

\textbf{Description}
\begin{quote}

This function adds the component id string to the supported list.
The component can be referred from the alsa-lib.
\end{quote}

\textbf{Return}

Zero otherwise a negative error code.
\index{snd\_card\_file\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_card_file_add}\pysiglinewithargsret{int \bfcode{snd\_card\_file\_add}}{struct snd\_card *\emph{ card}, struct file *\emph{ file}}{}
add the file to the file list of the card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\item[{\code{struct file * file}}] \leavevmode
file pointer

\end{description}

\textbf{Description}
\begin{quote}

This function adds the file to the file linked-list of the card.
This linked-list is used to keep tracking the connection state,
and to avoid the release of busy resources by hotplug.
\end{quote}

\textbf{Return}

zero or a negative error code.
\index{snd\_card\_file\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_card_file_remove}\pysiglinewithargsret{int \bfcode{snd\_card\_file\_remove}}{struct snd\_card *\emph{ card}, struct file *\emph{ file}}{}
remove the file from the file list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\item[{\code{struct file * file}}] \leavevmode
file pointer

\end{description}

\textbf{Description}
\begin{quote}

This function removes the file formerly added to the card via
\code{snd\_card\_file\_add()} function.
If all files are removed and \code{snd\_card\_free\_when\_closed()} was
called beforehand, it processes the pending release of
resources.
\end{quote}

\textbf{Return}

Zero or a negative error code.
\index{snd\_power\_wait (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_power_wait}\pysiglinewithargsret{int \bfcode{snd\_power\_wait}}{struct snd\_card *\emph{ card}, unsigned int\emph{ power\_state}}{}
wait until the power-state is changed.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
soundcard structure

\item[{\code{unsigned int power\_state}}] \leavevmode
expected power state

\end{description}

\textbf{Description}
\begin{quote}

Waits until the power-state is changed.
\end{quote}

\textbf{Return}

Zero if successful, or a negative error code.


\subsubsection{Device Components}
\label{sound/kernel-api/alsa-driver-api:device-components}\index{snd\_device\_new (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_device_new}\pysiglinewithargsret{int \bfcode{snd\_device\_new}}{struct snd\_card *\emph{ card}, enum snd\_device\_type\emph{ type}, void *\emph{ device\_data}, struct snd\_device\_ops *\emph{ ops}}{}
create an ALSA device component

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{enum snd\_device\_type type}}] \leavevmode
the device type, SNDRV\_DEV\_XXX

\item[{\code{void * device\_data}}] \leavevmode
the data pointer of this device

\item[{\code{struct snd\_device\_ops * ops}}] \leavevmode
the operator table

\end{description}

\textbf{Description}

Creates a new device component for the given data pointer.
The device will be assigned to the card and managed together
by the card.

The data pointer plays a role as the identifier, too, so the
pointer address must be unique and unchanged.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_device\_disconnect (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_device_disconnect}\pysiglinewithargsret{void \bfcode{snd\_device\_disconnect}}{struct snd\_card *\emph{ card}, void *\emph{ device\_data}}{}
disconnect the device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{void * device\_data}}] \leavevmode
the data pointer to disconnect

\end{description}

\textbf{Description}

Turns the device into the disconnection state, invoking
dev\_disconnect callback, if the device was already registered.

Usually called from \code{snd\_card\_disconnect()}.

\textbf{Return}

Zero if successful, or a negative error code on failure or if the
device not found.
\index{snd\_device\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_device_free}\pysiglinewithargsret{void \bfcode{snd\_device\_free}}{struct snd\_card *\emph{ card}, void *\emph{ device\_data}}{}
release the device from the card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{void * device\_data}}] \leavevmode
the data pointer to release

\end{description}

\textbf{Description}

Removes the device from the list on the card and invokes the
callbacks, dev\_disconnect and dev\_free, corresponding to the state.
Then release the device.
\index{snd\_device\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_device_register}\pysiglinewithargsret{int \bfcode{snd\_device\_register}}{struct snd\_card *\emph{ card}, void *\emph{ device\_data}}{}
register the device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{void * device\_data}}] \leavevmode
the data pointer to register

\end{description}

\textbf{Description}

Registers the device which was already created via
\code{snd\_device\_new()}.  Usually this is called from \code{snd\_card\_register()},
but it can be called later if any new devices are created after
invocation of \code{snd\_card\_register()}.

\textbf{Return}

Zero if successful, or a negative error code on failure or if the
device not found.


\subsubsection{Module requests and Device File Entries}
\label{sound/kernel-api/alsa-driver-api:module-requests-and-device-file-entries}\index{snd\_request\_card (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_request_card}\pysiglinewithargsret{void \bfcode{snd\_request\_card}}{int\emph{ card}}{}
try to load the card module

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int card}}] \leavevmode
the card number

\end{description}

\textbf{Description}

Tries to load the module ``snd-card-X'' for the given card number
via request\_module.  Returns immediately if already loaded.
\index{snd\_lookup\_minor\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_lookup_minor_data}\pysiglinewithargsret{void * \bfcode{snd\_lookup\_minor\_data}}{unsigned int\emph{ minor}, int\emph{ type}}{}
get user data of a registered device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int minor}}] \leavevmode
the minor number

\item[{\code{int type}}] \leavevmode
device type (SNDRV\_DEVICE\_TYPE\_XXX)

\end{description}

\textbf{Description}

Checks that a minor device with the specified type is registered, and returns
its user data pointer.

This function increments the reference counter of the card instance
if an associated instance with the given minor number and type is found.
The caller must call \code{snd\_card\_unref()} appropriately later.

\textbf{Return}

The user data pointer if the specified device is found. \code{NULL}
otherwise.
\index{snd\_register\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_register_device}\pysiglinewithargsret{int \bfcode{snd\_register\_device}}{int\emph{ type}, struct snd\_card *\emph{ card}, int\emph{ dev}, const struct file\_operations *\emph{ f\_ops}, void *\emph{ private\_data}, struct device *\emph{ device}}{}
Register the ALSA device file for the card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int type}}] \leavevmode
the device type, SNDRV\_DEVICE\_TYPE\_XXX

\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{int dev}}] \leavevmode
the device index

\item[{\code{const struct file\_operations * f\_ops}}] \leavevmode
the file operations

\item[{\code{void * private\_data}}] \leavevmode
user pointer for f\_ops-\textgreater{}:c:func:\emph{open()}

\item[{\code{struct device * device}}] \leavevmode
the device to register

\end{description}

\textbf{Description}

Registers an ALSA device file for the given card.
The operators have to be set in reg parameter.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_unregister\_device (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_unregister_device}\pysiglinewithargsret{int \bfcode{snd\_unregister\_device}}{struct device *\emph{ dev}}{}
unregister the device on the given card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
the device instance

\end{description}

\textbf{Description}

Unregisters the device file already registered via
\code{snd\_register\_device()}.

\textbf{Return}

Zero if successful, or a negative error code on failure.


\subsubsection{Memory Management Helpers}
\label{sound/kernel-api/alsa-driver-api:memory-management-helpers}\index{copy\_to\_user\_fromio (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.copy_to_user_fromio}\pysiglinewithargsret{int \bfcode{copy\_to\_user\_fromio}}{void \_\_user *\emph{ dst}, const volatile void \_\_iomem *\emph{ src}, size\_t\emph{ count}}{}
copy data from mmio-space to user-space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void \_\_user * dst}}] \leavevmode
the destination pointer on user-space

\item[{\code{const volatile void \_\_iomem * src}}] \leavevmode
the source pointer on mmio

\item[{\code{size\_t count}}] \leavevmode
the data size to copy in bytes

\end{description}

\textbf{Description}

Copies the data from mmio-space to user-space.

\textbf{Return}

Zero if successful, or non-zero on failure.
\index{copy\_from\_user\_toio (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.copy_from_user_toio}\pysiglinewithargsret{int \bfcode{copy\_from\_user\_toio}}{volatile void \_\_iomem *\emph{ dst}, const void \_\_user *\emph{ src}, size\_t\emph{ count}}{}
copy data from user-space to mmio-space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{volatile void \_\_iomem * dst}}] \leavevmode
the destination pointer on mmio-space

\item[{\code{const void \_\_user * src}}] \leavevmode
the source pointer on user-space

\item[{\code{size\_t count}}] \leavevmode
the data size to copy in bytes

\end{description}

\textbf{Description}

Copies the data from user-space to mmio-space.

\textbf{Return}

Zero if successful, or non-zero on failure.
\index{snd\_malloc\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_malloc_pages}\pysiglinewithargsret{void * \bfcode{snd\_malloc\_pages}}{size\_t\emph{ size}, gfp\_t\emph{ gfp\_flags}}{}
allocate pages with the given size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{size\_t size}}] \leavevmode
the size to allocate in bytes

\item[{\code{gfp\_t gfp\_flags}}] \leavevmode
the allocation conditions, GFP\_XXX

\end{description}

\textbf{Description}

Allocates the physically contiguous pages with the given size.

\textbf{Return}

The pointer of the buffer, or \code{NULL} if no enough memory.
\index{snd\_free\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_free_pages}\pysiglinewithargsret{void \bfcode{snd\_free\_pages}}{void *\emph{ ptr}, size\_t\emph{ size}}{}
release the pages

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{void * ptr}}] \leavevmode
the buffer pointer to release

\item[{\code{size\_t size}}] \leavevmode
the allocated buffer size

\end{description}

\textbf{Description}

Releases the buffer allocated via \code{snd\_malloc\_pages()}.
\index{snd\_malloc\_dev\_iram (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_malloc_dev_iram}\pysiglinewithargsret{void \bfcode{snd\_malloc\_dev\_iram}}{struct snd\_dma\_buffer *\emph{ dmab}, size\_t\emph{ size}}{}
allocate memory from on-chip internal ram

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_dma\_buffer * dmab}}] \leavevmode
buffer allocation record to store the allocated data

\item[{\code{size\_t size}}] \leavevmode
number of bytes to allocate from the iram

\end{description}

\textbf{Description}

This function requires iram phandle provided via of\_node
\index{snd\_free\_dev\_iram (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_free_dev_iram}\pysiglinewithargsret{void \bfcode{snd\_free\_dev\_iram}}{struct snd\_dma\_buffer *\emph{ dmab}}{}
free allocated specific memory from on-chip internal ram

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_dma\_buffer * dmab}}] \leavevmode
buffer allocation record to store the allocated data

\end{description}
\index{snd\_dma\_alloc\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dma_alloc_pages}\pysiglinewithargsret{int \bfcode{snd\_dma\_alloc\_pages}}{int\emph{ type}, struct device *\emph{ device}, size\_t\emph{ size}, struct snd\_dma\_buffer *\emph{ dmab}}{}
allocate the buffer area according to the given type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int type}}] \leavevmode
the DMA buffer type

\item[{\code{struct device * device}}] \leavevmode
the device pointer

\item[{\code{size\_t size}}] \leavevmode
the buffer size to allocate

\item[{\code{struct snd\_dma\_buffer * dmab}}] \leavevmode
buffer allocation record to store the allocated data

\end{description}

\textbf{Description}

Calls the memory-allocator function for the corresponding
buffer type.

\textbf{Return}

Zero if the buffer with the given size is allocated successfully,
otherwise a negative value on error.
\index{snd\_dma\_alloc\_pages\_fallback (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dma_alloc_pages_fallback}\pysiglinewithargsret{int \bfcode{snd\_dma\_alloc\_pages\_fallback}}{int\emph{ type}, struct device *\emph{ device}, size\_t\emph{ size}, struct snd\_dma\_buffer *\emph{ dmab}}{}
allocate the buffer area according to the given type with fallback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int type}}] \leavevmode
the DMA buffer type

\item[{\code{struct device * device}}] \leavevmode
the device pointer

\item[{\code{size\_t size}}] \leavevmode
the buffer size to allocate

\item[{\code{struct snd\_dma\_buffer * dmab}}] \leavevmode
buffer allocation record to store the allocated data

\end{description}

\textbf{Description}

Calls the memory-allocator function for the corresponding
buffer type.  When no space is left, this function reduces the size and
tries to allocate again.  The size actually allocated is stored in
res\_size argument.

\textbf{Return}

Zero if the buffer with the given size is allocated successfully,
otherwise a negative value on error.
\index{snd\_dma\_free\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dma_free_pages}\pysiglinewithargsret{void \bfcode{snd\_dma\_free\_pages}}{struct snd\_dma\_buffer *\emph{ dmab}}{}
release the allocated buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_dma\_buffer * dmab}}] \leavevmode
the buffer allocation record to release

\end{description}

\textbf{Description}

Releases the allocated buffer via \code{snd\_dma\_alloc\_pages()}.


\subsection{PCM API}
\label{sound/kernel-api/alsa-driver-api:pcm-api}

\subsubsection{PCM Core}
\label{sound/kernel-api/alsa-driver-api:pcm-core}\index{snd\_pcm\_format\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_format_name}\pysiglinewithargsret{const char * \bfcode{snd\_pcm\_format\_name}}{snd\_pcm\_format\_t\emph{ format}}{}
Return a name string for the given PCM format

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_pcm\_format\_t format}}] \leavevmode
PCM format

\end{description}
\index{snd\_pcm\_new\_stream (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_new_stream}\pysiglinewithargsret{int \bfcode{snd\_pcm\_new\_stream}}{struct snd\_pcm *\emph{ pcm}, int\emph{ stream}, int\emph{ substream\_count}}{}
create a new PCM stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm * pcm}}] \leavevmode
the pcm instance

\item[{\code{int stream}}] \leavevmode
the stream direction, SNDRV\_PCM\_STREAM\_XXX

\item[{\code{int substream\_count}}] \leavevmode
the number of substreams

\end{description}

\textbf{Description}

Creates a new stream for the pcm.
The corresponding stream on the pcm must have been empty before
calling this, i.e. zero must be given to the argument of
\code{snd\_pcm\_new()}.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_new (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_new}\pysiglinewithargsret{int \bfcode{snd\_pcm\_new}}{struct snd\_card *\emph{ card}, const char *\emph{ id}, int\emph{ device}, int\emph{ playback\_count}, int\emph{ capture\_count}, struct snd\_pcm **\emph{ rpcm}}{}
create a new PCM instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{const char * id}}] \leavevmode
the id string

\item[{\code{int device}}] \leavevmode
the device index (zero based)

\item[{\code{int playback\_count}}] \leavevmode
the number of substreams for playback

\item[{\code{int capture\_count}}] \leavevmode
the number of substreams for capture

\item[{\code{struct snd\_pcm ** rpcm}}] \leavevmode
the pointer to store the new pcm instance

\end{description}

\textbf{Description}

Creates a new PCM instance.

The pcm operators have to be set afterwards to the new instance
via \code{snd\_pcm\_set\_ops()}.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_new\_internal (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_new_internal}\pysiglinewithargsret{int \bfcode{snd\_pcm\_new\_internal}}{struct snd\_card *\emph{ card}, const char *\emph{ id}, int\emph{ device}, int\emph{ playback\_count}, int\emph{ capture\_count}, struct snd\_pcm **\emph{ rpcm}}{}
create a new internal PCM instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{const char * id}}] \leavevmode
the id string

\item[{\code{int device}}] \leavevmode
the device index (zero based - shared with normal PCMs)

\item[{\code{int playback\_count}}] \leavevmode
the number of substreams for playback

\item[{\code{int capture\_count}}] \leavevmode
the number of substreams for capture

\item[{\code{struct snd\_pcm ** rpcm}}] \leavevmode
the pointer to store the new pcm instance

\end{description}

\textbf{Description}

Creates a new internal PCM instance with no userspace device or procfs
entries. This is used by ASoC Back End PCMs in order to create a PCM that
will only be used internally by kernel drivers. i.e. it cannot be opened
by userspace. It provides existing ASoC components drivers with a substream
and access to any private data.

The pcm operators have to be set afterwards to the new instance
via \code{snd\_pcm\_set\_ops()}.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_notify (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_notify}\pysiglinewithargsret{int \bfcode{snd\_pcm\_notify}}{struct snd\_pcm\_notify *\emph{ notify}, int\emph{ nfree}}{}
Add/remove the notify list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_notify * notify}}] \leavevmode
PCM notify list

\item[{\code{int nfree}}] \leavevmode
0 = register, 1 = unregister

\end{description}

\textbf{Description}

This adds the given notifier to the global list so that the callback is
called for each registered PCM devices.  This exists only for PCM OSS
emulation, so far.
\index{snd\_pcm\_set\_ops (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_set_ops}\pysiglinewithargsret{void \bfcode{snd\_pcm\_set\_ops}}{struct snd\_pcm *\emph{ pcm}, int\emph{ direction}, const struct snd\_pcm\_ops *\emph{ ops}}{}
set the PCM operators

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm * pcm}}] \leavevmode
the pcm instance

\item[{\code{int direction}}] \leavevmode
stream direction, SNDRV\_PCM\_STREAM\_XXX

\item[{\code{const struct snd\_pcm\_ops * ops}}] \leavevmode
the operator table

\end{description}

\textbf{Description}

Sets the given PCM operators to the pcm instance.
\index{snd\_pcm\_set\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_set_sync}\pysiglinewithargsret{void \bfcode{snd\_pcm\_set\_sync}}{struct snd\_pcm\_substream *\emph{ substream}}{}
set the PCM sync id

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream

\end{description}

\textbf{Description}

Sets the PCM sync identifier for the card.
\index{snd\_interval\_refine (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_interval_refine}\pysiglinewithargsret{int \bfcode{snd\_interval\_refine}}{struct snd\_interval *\emph{ i}, const struct snd\_interval *\emph{ v}}{}
refine the interval value of configurator

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_interval * i}}] \leavevmode
the interval value to refine

\item[{\code{const struct snd\_interval * v}}] \leavevmode
the interval value to refer to

\end{description}

\textbf{Description}

Refines the interval value with the reference value.
The interval is changed to the range satisfying both intervals.
The interval status (min, max, integer, etc.) are evaluated.

\textbf{Return}

Positive if the value is changed, zero if it's not changed, or a
negative error code.
\index{snd\_interval\_div (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_interval_div}\pysiglinewithargsret{void \bfcode{snd\_interval\_div}}{const struct snd\_interval *\emph{ a}, const struct snd\_interval *\emph{ b}, struct snd\_interval *\emph{ c}}{}
refine the interval value with division

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_interval * a}}] \leavevmode
dividend

\item[{\code{const struct snd\_interval * b}}] \leavevmode
divisor

\item[{\code{struct snd\_interval * c}}] \leavevmode
quotient

\end{description}

\textbf{Description}

c = a / b

Returns non-zero if the value is changed, zero if not changed.
\index{snd\_interval\_muldivk (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_interval_muldivk}\pysiglinewithargsret{void \bfcode{snd\_interval\_muldivk}}{const struct snd\_interval *\emph{ a}, const struct snd\_interval *\emph{ b}, unsigned int\emph{ k}, struct snd\_interval *\emph{ c}}{}
refine the interval value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_interval * a}}] \leavevmode
dividend 1

\item[{\code{const struct snd\_interval * b}}] \leavevmode
dividend 2

\item[{\code{unsigned int k}}] \leavevmode
divisor (as integer)

\item[{\code{struct snd\_interval * c}}] \leavevmode
result

\end{description}

\textbf{Description}

c = a * b / k

Returns non-zero if the value is changed, zero if not changed.
\index{snd\_interval\_mulkdiv (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_interval_mulkdiv}\pysiglinewithargsret{void \bfcode{snd\_interval\_mulkdiv}}{const struct snd\_interval *\emph{ a}, unsigned int\emph{ k}, const struct snd\_interval *\emph{ b}, struct snd\_interval *\emph{ c}}{}
refine the interval value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_interval * a}}] \leavevmode
dividend 1

\item[{\code{unsigned int k}}] \leavevmode
dividend 2 (as integer)

\item[{\code{const struct snd\_interval * b}}] \leavevmode
divisor

\item[{\code{struct snd\_interval * c}}] \leavevmode
result

\end{description}

\textbf{Description}

c = a * k / b

Returns non-zero if the value is changed, zero if not changed.
\index{snd\_interval\_ratnum (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_interval_ratnum}\pysiglinewithargsret{int \bfcode{snd\_interval\_ratnum}}{struct snd\_interval *\emph{ i}, unsigned int\emph{ rats\_count}, const struct snd\_ratnum *\emph{ rats}, unsigned int *\emph{ nump}, unsigned int *\emph{ denp}}{}
refine the interval value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_interval * i}}] \leavevmode
interval to refine

\item[{\code{unsigned int rats\_count}}] \leavevmode
number of ratnum\_t

\item[{\code{const struct snd\_ratnum * rats}}] \leavevmode
ratnum\_t array

\item[{\code{unsigned int * nump}}] \leavevmode
pointer to store the resultant numerator

\item[{\code{unsigned int * denp}}] \leavevmode
pointer to store the resultant denominator

\end{description}

\textbf{Return}

Positive if the value is changed, zero if it's not changed, or a
negative error code.
\index{snd\_interval\_ratden (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_interval_ratden}\pysiglinewithargsret{int \bfcode{snd\_interval\_ratden}}{struct snd\_interval *\emph{ i}, unsigned int\emph{ rats\_count}, const struct snd\_ratden *\emph{ rats}, unsigned int *\emph{ nump}, unsigned int *\emph{ denp}}{}
refine the interval value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_interval * i}}] \leavevmode
interval to refine

\item[{\code{unsigned int rats\_count}}] \leavevmode
number of struct ratden

\item[{\code{const struct snd\_ratden * rats}}] \leavevmode
struct ratden array

\item[{\code{unsigned int * nump}}] \leavevmode
pointer to store the resultant numerator

\item[{\code{unsigned int * denp}}] \leavevmode
pointer to store the resultant denominator

\end{description}

\textbf{Return}

Positive if the value is changed, zero if it's not changed, or a
negative error code.
\index{snd\_interval\_list (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_interval_list}\pysiglinewithargsret{int \bfcode{snd\_interval\_list}}{struct snd\_interval *\emph{ i}, unsigned int\emph{ count}, const unsigned int *\emph{ list}, unsigned int\emph{ mask}}{}
refine the interval value from the list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_interval * i}}] \leavevmode
the interval value to refine

\item[{\code{unsigned int count}}] \leavevmode
the number of elements in the list

\item[{\code{const unsigned int * list}}] \leavevmode
the value list

\item[{\code{unsigned int mask}}] \leavevmode
the bit-mask to evaluate

\end{description}

\textbf{Description}

Refines the interval value from the list.
When mask is non-zero, only the elements corresponding to bit 1 are
evaluated.

\textbf{Return}

Positive if the value is changed, zero if it's not changed, or a
negative error code.
\index{snd\_interval\_ranges (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_interval_ranges}\pysiglinewithargsret{int \bfcode{snd\_interval\_ranges}}{struct snd\_interval *\emph{ i}, unsigned int\emph{ count}, const struct snd\_interval *\emph{ ranges}, unsigned int\emph{ mask}}{}
refine the interval value from the list of ranges

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_interval * i}}] \leavevmode
the interval value to refine

\item[{\code{unsigned int count}}] \leavevmode
the number of elements in the list of ranges

\item[{\code{const struct snd\_interval * ranges}}] \leavevmode
the ranges list

\item[{\code{unsigned int mask}}] \leavevmode
the bit-mask to evaluate

\end{description}

\textbf{Description}

Refines the interval value from the list of ranges.
When mask is non-zero, only the elements corresponding to bit 1 are
evaluated.

\textbf{Return}

Positive if the value is changed, zero if it's not changed, or a
negative error code.
\index{snd\_pcm\_hw\_rule\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_rule_add}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_rule\_add}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ cond}, int\emph{ var}, snd\_pcm\_hw\_rule\_func\_t\emph{ func}, void *\emph{ private}, int\emph{ dep}, ...}{}
add the hw-constraint rule

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
the pcm runtime instance

\item[{\code{unsigned int cond}}] \leavevmode
condition bits

\item[{\code{int var}}] \leavevmode
the variable to evaluate

\item[{\code{snd\_pcm\_hw\_rule\_func\_t func}}] \leavevmode
the evaluation function

\item[{\code{void * private}}] \leavevmode
the private data pointer passed to function

\item[{\code{int dep}}] \leavevmode
the dependent variables

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_constraint\_mask (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_constraint_mask}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_mask}}{struct snd\_pcm\_runtime *\emph{ runtime}, snd\_pcm\_hw\_param\_t\emph{ var}, u\_int32\_t\emph{ mask}}{}
apply the given bitmap mask constraint

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the mask

\item[{\code{u\_int32\_t mask}}] \leavevmode
the bitmap mask

\end{description}

\textbf{Description}

Apply the constraint of the given bitmap mask to a 32-bit mask parameter.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_constraint\_mask64 (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_constraint_mask64}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_mask64}}{struct snd\_pcm\_runtime *\emph{ runtime}, snd\_pcm\_hw\_param\_t\emph{ var}, u\_int64\_t\emph{ mask}}{}
apply the given bitmap mask constraint

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the mask

\item[{\code{u\_int64\_t mask}}] \leavevmode
the 64bit bitmap mask

\end{description}

\textbf{Description}

Apply the constraint of the given bitmap mask to a 64-bit mask parameter.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_constraint\_integer (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_constraint_integer}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_integer}}{struct snd\_pcm\_runtime *\emph{ runtime}, snd\_pcm\_hw\_param\_t\emph{ var}}{}
apply an integer constraint to an interval

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the integer constraint

\end{description}

\textbf{Description}

Apply the constraint of integer to an interval parameter.

\textbf{Return}

Positive if the value is changed, zero if it's not changed, or a
negative error code.
\index{snd\_pcm\_hw\_constraint\_minmax (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_constraint_minmax}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_minmax}}{struct snd\_pcm\_runtime *\emph{ runtime}, snd\_pcm\_hw\_param\_t\emph{ var}, unsigned int\emph{ min}, unsigned int\emph{ max}}{}
apply a min/max range constraint to an interval

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the range

\item[{\code{unsigned int min}}] \leavevmode
the minimal value

\item[{\code{unsigned int max}}] \leavevmode
the maximal value

\end{description}

\textbf{Description}

Apply the min/max range constraint to an interval parameter.

\textbf{Return}

Positive if the value is changed, zero if it's not changed, or a
negative error code.
\index{snd\_pcm\_hw\_constraint\_list (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_constraint_list}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_list}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ cond}, snd\_pcm\_hw\_param\_t\emph{ var}, const struct snd\_pcm\_hw\_constraint\_list *\emph{ l}}{}
apply a list of constraints to a parameter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{unsigned int cond}}] \leavevmode
condition bits

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the list constraint

\item[{\code{const struct snd\_pcm\_hw\_constraint\_list * l}}] \leavevmode
list

\end{description}

\textbf{Description}

Apply the list of constraints to an interval parameter.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_constraint\_ranges (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_constraint_ranges}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_ranges}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ cond}, snd\_pcm\_hw\_param\_t\emph{ var}, const struct snd\_pcm\_hw\_constraint\_ranges *\emph{ r}}{}
apply list of range constraints to a parameter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{unsigned int cond}}] \leavevmode
condition bits

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the list of range constraints

\item[{\code{const struct snd\_pcm\_hw\_constraint\_ranges * r}}] \leavevmode
ranges

\end{description}

\textbf{Description}

Apply the list of range constraints to an interval parameter.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_constraint\_ratnums (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_constraint_ratnums}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_ratnums}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ cond}, snd\_pcm\_hw\_param\_t\emph{ var}, const struct snd\_pcm\_hw\_constraint\_ratnums *\emph{ r}}{}
apply ratnums constraint to a parameter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{unsigned int cond}}] \leavevmode
condition bits

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the ratnums constraint

\item[{\code{const struct snd\_pcm\_hw\_constraint\_ratnums * r}}] \leavevmode
struct snd\_ratnums constriants

\end{description}

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_constraint\_ratdens (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_constraint_ratdens}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_ratdens}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ cond}, snd\_pcm\_hw\_param\_t\emph{ var}, const struct snd\_pcm\_hw\_constraint\_ratdens *\emph{ r}}{}
apply ratdens constraint to a parameter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{unsigned int cond}}] \leavevmode
condition bits

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the ratdens constraint

\item[{\code{const struct snd\_pcm\_hw\_constraint\_ratdens * r}}] \leavevmode
struct snd\_ratdens constriants

\end{description}

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_constraint\_msbits (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_constraint_msbits}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_msbits}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ cond}, unsigned int\emph{ width}, unsigned int\emph{ msbits}}{}
add a hw constraint msbits rule

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{unsigned int cond}}] \leavevmode
condition bits

\item[{\code{unsigned int width}}] \leavevmode
sample bits width

\item[{\code{unsigned int msbits}}] \leavevmode
msbits width

\end{description}

\textbf{Description}

This constraint will set the number of most significant bits (msbits) if a
sample format with the specified width has been select. If width is set to 0
the msbits will be set for any sample format with a width larger than the
specified msbits.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_constraint\_step (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_constraint_step}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_step}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ cond}, snd\_pcm\_hw\_param\_t\emph{ var}, unsigned long\emph{ step}}{}
add a hw constraint step rule

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{unsigned int cond}}] \leavevmode
condition bits

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the step constraint

\item[{\code{unsigned long step}}] \leavevmode
step size

\end{description}

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_constraint\_pow2 (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_constraint_pow2}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_pow2}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ cond}, snd\_pcm\_hw\_param\_t\emph{ var}}{}
add a hw constraint power-of-2 rule

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{unsigned int cond}}] \leavevmode
condition bits

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
hw\_params variable to apply the power-of-2 constraint

\end{description}

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_rule\_noresample (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_rule_noresample}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_rule\_noresample}}{struct snd\_pcm\_runtime *\emph{ runtime}, unsigned int\emph{ base\_rate}}{}
add a rule to allow disabling hw resampling

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{unsigned int base\_rate}}] \leavevmode
the rate at which the hardware does not resample

\end{description}

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_hw\_param\_value (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_param_value}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_param\_value}}{const struct snd\_pcm\_hw\_params *\emph{ params}, snd\_pcm\_hw\_param\_t\emph{ var}, int *\emph{ dir}}{}
return \textbf{params} field \textbf{var} value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_pcm\_hw\_params * params}}] \leavevmode
the hw\_params instance

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
parameter to retrieve

\item[{\code{int * dir}}] \leavevmode
pointer to the direction (-1,0,1) or \code{NULL}

\end{description}

\textbf{Return}

The value for field \textbf{var} if it's fixed in configuration space
defined by \textbf{params}. -\code{EINVAL} otherwise.
\index{snd\_pcm\_hw\_param\_first (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_param_first}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_param\_first}}{struct snd\_pcm\_substream *\emph{ pcm}, struct snd\_pcm\_hw\_params *\emph{ params}, snd\_pcm\_hw\_param\_t\emph{ var}, int *\emph{ dir}}{}
refine config space and return minimum value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * pcm}}] \leavevmode
PCM instance

\item[{\code{struct snd\_pcm\_hw\_params * params}}] \leavevmode
the hw\_params instance

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
parameter to retrieve

\item[{\code{int * dir}}] \leavevmode
pointer to the direction (-1,0,1) or \code{NULL}

\end{description}

\textbf{Description}

Inside configuration space defined by \textbf{params} remove from \textbf{var} all
values \textgreater{} minimum. Reduce configuration space accordingly.

\textbf{Return}

The minimum, or a negative error code on failure.
\index{snd\_pcm\_hw\_param\_last (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_param_last}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_param\_last}}{struct snd\_pcm\_substream *\emph{ pcm}, struct snd\_pcm\_hw\_params *\emph{ params}, snd\_pcm\_hw\_param\_t\emph{ var}, int *\emph{ dir}}{}
refine config space and return maximum value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * pcm}}] \leavevmode
PCM instance

\item[{\code{struct snd\_pcm\_hw\_params * params}}] \leavevmode
the hw\_params instance

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
parameter to retrieve

\item[{\code{int * dir}}] \leavevmode
pointer to the direction (-1,0,1) or \code{NULL}

\end{description}

\textbf{Description}

Inside configuration space defined by \textbf{params} remove from \textbf{var} all
values \textless{} maximum. Reduce configuration space accordingly.

\textbf{Return}

The maximum, or a negative error code on failure.
\index{snd\_pcm\_lib\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_lib_ioctl}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_ioctl}}{struct snd\_pcm\_substream *\emph{ substream}, unsigned int\emph{ cmd}, void *\emph{ arg}}{}
a generic PCM ioctl callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\item[{\code{unsigned int cmd}}] \leavevmode
ioctl command

\item[{\code{void * arg}}] \leavevmode
ioctl argument

\end{description}

\textbf{Description}

Processes the generic ioctl commands for PCM.
Can be passed as the ioctl callback for PCM ops.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_period\_elapsed (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_period_elapsed}\pysiglinewithargsret{void \bfcode{snd\_pcm\_period\_elapsed}}{struct snd\_pcm\_substream *\emph{ substream}}{}
update the pcm status for the next period

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\end{description}

\textbf{Description}

This function is called from the interrupt handler when the
PCM has processed the period size.  It will update the current
pointer, wake up sleepers, etc.

Even if more than one periods have elapsed since the last call, you
have to call this only once.
\index{snd\_pcm\_add\_chmap\_ctls (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_add_chmap_ctls}\pysiglinewithargsret{int \bfcode{snd\_pcm\_add\_chmap\_ctls}}{struct snd\_pcm *\emph{ pcm}, int\emph{ stream}, const struct snd\_pcm\_chmap\_elem *\emph{ chmap}, int\emph{ max\_channels}, unsigned long\emph{ private\_value}, struct snd\_pcm\_chmap **\emph{ info\_ret}}{}
create channel-mapping control elements

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm * pcm}}] \leavevmode
the assigned PCM instance

\item[{\code{int stream}}] \leavevmode
stream direction

\item[{\code{const struct snd\_pcm\_chmap\_elem * chmap}}] \leavevmode
channel map elements (for query)

\item[{\code{int max\_channels}}] \leavevmode
the max number of channels for the stream

\item[{\code{unsigned long private\_value}}] \leavevmode
the value passed to each kcontrol's private\_value field

\item[{\code{struct snd\_pcm\_chmap ** info\_ret}}] \leavevmode
store struct snd\_pcm\_chmap instance if non-NULL

\end{description}

\textbf{Description}

Create channel-mapping control elements assigned to the given PCM stream(s).

\textbf{Return}

Zero if successful, or a negative error value.
\index{snd\_pcm\_stream\_lock (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_stream_lock}\pysiglinewithargsret{void \bfcode{snd\_pcm\_stream\_lock}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Lock the PCM stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\end{description}

\textbf{Description}

This locks the PCM stream's spinlock or mutex depending on the nonatomic
flag of the given substream.  This also takes the global link rw lock
(or rw sem), too, for avoiding the race with linked streams.
\index{snd\_pcm\_stream\_unlock (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_stream_unlock}\pysiglinewithargsret{void \bfcode{snd\_pcm\_stream\_unlock}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Unlock the PCM stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\end{description}

\textbf{Description}

This unlocks the PCM stream that has been locked via \code{snd\_pcm\_stream\_lock()}.
\index{snd\_pcm\_stream\_lock\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_stream_lock_irq}\pysiglinewithargsret{void \bfcode{snd\_pcm\_stream\_lock\_irq}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Lock the PCM stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\end{description}

\textbf{Description}

This locks the PCM stream like \code{snd\_pcm\_stream\_lock()} and disables the local
IRQ (only when nonatomic is false).  In nonatomic case, this is identical
as \code{snd\_pcm\_stream\_lock()}.
\index{snd\_pcm\_stream\_unlock\_irq (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_stream_unlock_irq}\pysiglinewithargsret{void \bfcode{snd\_pcm\_stream\_unlock\_irq}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Unlock the PCM stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\end{description}

\textbf{Description}

This is a counter-part of \code{snd\_pcm\_stream\_lock\_irq()}.
\index{snd\_pcm\_stream\_unlock\_irqrestore (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_stream_unlock_irqrestore}\pysiglinewithargsret{void \bfcode{snd\_pcm\_stream\_unlock\_irqrestore}}{struct snd\_pcm\_substream *\emph{ substream}, unsigned long\emph{ flags}}{}
Unlock the PCM stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{unsigned long flags}}] \leavevmode
irq flags

\end{description}

\textbf{Description}

This is a counter-part of \code{snd\_pcm\_stream\_lock\_irqsave()}.
\index{snd\_pcm\_hw\_params\_choose (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_params_choose}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_params\_choose}}{struct snd\_pcm\_substream *\emph{ pcm}, struct snd\_pcm\_hw\_params *\emph{ params}}{}
choose a configuration defined by \textbf{params}

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * pcm}}] \leavevmode
PCM instance

\item[{\code{struct snd\_pcm\_hw\_params * params}}] \leavevmode
the hw\_params instance

\end{description}

\textbf{Description}

Choose one configuration from configuration space defined by \textbf{params}.
The configuration chosen is that obtained fixing in this order:
first access, first format, first subformat, min channels,
min rate, min period time, max buffer size, min tick time

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_start (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_start}\pysiglinewithargsret{int \bfcode{snd\_pcm\_start}}{struct snd\_pcm\_substream *\emph{ substream}}{}
start all linked streams

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the PCM substream instance

\end{description}

\textbf{Return}

Zero if successful, or a negative error code.
The stream lock must be acquired before calling this function.
\index{snd\_pcm\_stop (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_stop}\pysiglinewithargsret{int \bfcode{snd\_pcm\_stop}}{struct snd\_pcm\_substream *\emph{ substream}, snd\_pcm\_state\_t\emph{ state}}{}
try to stop all running streams in the substream group

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the PCM substream instance

\item[{\code{snd\_pcm\_state\_t state}}] \leavevmode
PCM state after stopping the stream

\end{description}

\textbf{Description}

The state of each stream is then changed to the given state unconditionally.

\textbf{Return}

Zero if successful, or a negative error code.
\index{snd\_pcm\_drain\_done (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_drain_done}\pysiglinewithargsret{int \bfcode{snd\_pcm\_drain\_done}}{struct snd\_pcm\_substream *\emph{ substream}}{}
stop the DMA only when the given stream is playback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the PCM substream

\end{description}

\textbf{Description}

After stopping, the state is changed to SETUP.
Unlike \code{snd\_pcm\_stop()}, this affects only the given stream.

\textbf{Return}

Zero if succesful, or a negative error code.
\index{snd\_pcm\_stop\_xrun (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_stop_xrun}\pysiglinewithargsret{int \bfcode{snd\_pcm\_stop\_xrun}}{struct snd\_pcm\_substream *\emph{ substream}}{}
stop the running streams as XRUN

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the PCM substream instance

\end{description}

\textbf{Description}

This stops the given running substream (and all linked substreams) as XRUN.
Unlike \code{snd\_pcm\_stop()}, this function takes the substream lock by itself.

\textbf{Return}

Zero if successful, or a negative error code.
\index{snd\_pcm\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_suspend}\pysiglinewithargsret{int \bfcode{snd\_pcm\_suspend}}{struct snd\_pcm\_substream *\emph{ substream}}{}
trigger SUSPEND to all linked streams

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the PCM substream

\end{description}

\textbf{Description}

After this call, all streams are changed to SUSPENDED state.

\textbf{Return}

Zero if successful (or \textbf{substream} is \code{NULL}), or a negative error
code.
\index{snd\_pcm\_suspend\_all (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_suspend_all}\pysiglinewithargsret{int \bfcode{snd\_pcm\_suspend\_all}}{struct snd\_pcm *\emph{ pcm}}{}
trigger SUSPEND to all substreams in the given pcm

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm * pcm}}] \leavevmode
the PCM instance

\end{description}

\textbf{Description}

After this call, all streams are changed to SUSPENDED state.

\textbf{Return}

Zero if successful (or \textbf{pcm} is \code{NULL}), or a negative error code.
\index{snd\_pcm\_prepare (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_prepare}\pysiglinewithargsret{int \bfcode{snd\_pcm\_prepare}}{struct snd\_pcm\_substream *\emph{ substream}, struct file *\emph{ file}}{}
prepare the PCM substream to be triggerable

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the PCM substream instance

\item[{\code{struct file * file}}] \leavevmode
file to refer f\_flags

\end{description}

\textbf{Return}

Zero if successful, or a negative error code.
\index{snd\_pcm\_kernel\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_kernel_ioctl}\pysiglinewithargsret{int \bfcode{snd\_pcm\_kernel\_ioctl}}{struct snd\_pcm\_substream *\emph{ substream}, unsigned int\emph{ cmd}, void *\emph{ arg}}{}
Execute PCM ioctl in the kernel-space

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{unsigned int cmd}}] \leavevmode
IOCTL cmd

\item[{\code{void * arg}}] \leavevmode
IOCTL argument

\end{description}

\textbf{Description}

The function is provided primarily for OSS layer and USB gadget drivers,
and it allows only the limited set of ioctls (hw\_params, sw\_params,
prepare, start, drain, drop, forward).
\index{snd\_pcm\_lib\_default\_mmap (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_lib_default_mmap}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_default\_mmap}}{struct snd\_pcm\_substream *\emph{ substream}, struct vm\_area\_struct *\emph{ area}}{}
Default PCM data mmap function

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{struct vm\_area\_struct * area}}] \leavevmode
VMA

\end{description}

\textbf{Description}

This is the default mmap handler for PCM data.  When mmap pcm\_ops is NULL,
this function is invoked implicitly.
\index{snd\_pcm\_lib\_mmap\_iomem (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_lib_mmap_iomem}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_mmap\_iomem}}{struct snd\_pcm\_substream *\emph{ substream}, struct vm\_area\_struct *\emph{ area}}{}
Default PCM data mmap function for I/O mem

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{struct vm\_area\_struct * area}}] \leavevmode
VMA

\end{description}

\textbf{Description}

When your hardware uses the iomapped pages as the hardware buffer and
wants to mmap it, pass this function as mmap pcm\_ops.  Note that this
is supposed to work only on limited architectures.
\index{snd\_pcm\_stream\_linked (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_stream_linked}\pysiglinewithargsret{int \bfcode{snd\_pcm\_stream\_linked}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Check whether the substream is linked with others

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
substream to check

\end{description}

\textbf{Description}

Returns true if the given substream is being linked with others.
\index{snd\_pcm\_stream\_lock\_irqsave (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_stream_lock_irqsave}\pysiglinewithargsret{\bfcode{snd\_pcm\_stream\_lock\_irqsave}}{\emph{substream}, \emph{flags}}{}
Lock the PCM stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{substream}}] \leavevmode
PCM substream

\item[{\code{flags}}] \leavevmode
irq flags

\end{description}

\textbf{Description}

This locks the PCM stream like \code{snd\_pcm\_stream\_lock()} but with the local
IRQ (only when nonatomic is false).  In nonatomic case, this is identical
as \code{snd\_pcm\_stream\_lock()}.
\index{snd\_pcm\_group\_for\_each\_entry (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_group_for_each_entry}\pysiglinewithargsret{\bfcode{snd\_pcm\_group\_for\_each\_entry}}{\emph{s}, \emph{substream}}{}
iterate over the linked substreams

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{s}}] \leavevmode
the iterator

\item[{\code{substream}}] \leavevmode
the substream

\end{description}

\textbf{Description}

Iterate over the all linked substreams to the given \textbf{substream}.
When \textbf{substream} isn't linked with any others, this gives returns \textbf{substream}
itself once.
\index{snd\_pcm\_running (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_running}\pysiglinewithargsret{int \bfcode{snd\_pcm\_running}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Check whether the substream is in a running state

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
substream to check

\end{description}

\textbf{Description}

Returns true if the given substream is in the state RUNNING, or in the
state DRAINING for playback.
\index{bytes\_to\_samples (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.bytes_to_samples}\pysiglinewithargsret{ssize\_t \bfcode{bytes\_to\_samples}}{struct snd\_pcm\_runtime *\emph{ runtime}, ssize\_t\emph{ size}}{}
Unit conversion of the size from bytes to samples

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{ssize\_t size}}] \leavevmode
size in bytes

\end{description}
\index{bytes\_to\_frames (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.bytes_to_frames}\pysiglinewithargsret{snd\_pcm\_sframes\_t \bfcode{bytes\_to\_frames}}{struct snd\_pcm\_runtime *\emph{ runtime}, ssize\_t\emph{ size}}{}
Unit conversion of the size from bytes to frames

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{ssize\_t size}}] \leavevmode
size in bytes

\end{description}
\index{samples\_to\_bytes (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.samples_to_bytes}\pysiglinewithargsret{ssize\_t \bfcode{samples\_to\_bytes}}{struct snd\_pcm\_runtime *\emph{ runtime}, ssize\_t\emph{ size}}{}
Unit conversion of the size from samples to bytes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{ssize\_t size}}] \leavevmode
size in samples

\end{description}
\index{frames\_to\_bytes (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.frames_to_bytes}\pysiglinewithargsret{ssize\_t \bfcode{frames\_to\_bytes}}{struct snd\_pcm\_runtime *\emph{ runtime}, snd\_pcm\_sframes\_t\emph{ size}}{}
Unit conversion of the size from frames to bytes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{snd\_pcm\_sframes\_t size}}] \leavevmode
size in frames

\end{description}
\index{frame\_aligned (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.frame_aligned}\pysiglinewithargsret{int \bfcode{frame\_aligned}}{struct snd\_pcm\_runtime *\emph{ runtime}, ssize\_t\emph{ bytes}}{}
Check whether the byte size is aligned to frames

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{ssize\_t bytes}}] \leavevmode
size in bytes

\end{description}
\index{snd\_pcm\_lib\_buffer\_bytes (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_lib_buffer_bytes}\pysiglinewithargsret{size\_t \bfcode{snd\_pcm\_lib\_buffer\_bytes}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Get the buffer size of the current PCM in bytes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\end{description}
\index{snd\_pcm\_lib\_period\_bytes (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_lib_period_bytes}\pysiglinewithargsret{size\_t \bfcode{snd\_pcm\_lib\_period\_bytes}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Get the period size of the current PCM in bytes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\end{description}
\index{snd\_pcm\_playback\_avail (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_playback_avail}\pysiglinewithargsret{snd\_pcm\_uframes\_t \bfcode{snd\_pcm\_playback\_avail}}{struct snd\_pcm\_runtime *\emph{ runtime}}{}
Get the available (writable) space for playback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\end{description}

\textbf{Description}

Result is between 0 ... (boundary - 1)
\index{snd\_pcm\_capture\_avail (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_capture_avail}\pysiglinewithargsret{snd\_pcm\_uframes\_t \bfcode{snd\_pcm\_capture\_avail}}{struct snd\_pcm\_runtime *\emph{ runtime}}{}
Get the available (readable) space for capture

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\end{description}

\textbf{Description}

Result is between 0 ... (boundary - 1)
\index{snd\_pcm\_playback\_hw\_avail (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_playback_hw_avail}\pysiglinewithargsret{snd\_pcm\_sframes\_t \bfcode{snd\_pcm\_playback\_hw\_avail}}{struct snd\_pcm\_runtime *\emph{ runtime}}{}
Get the queued space for playback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\end{description}
\index{snd\_pcm\_capture\_hw\_avail (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_capture_hw_avail}\pysiglinewithargsret{snd\_pcm\_sframes\_t \bfcode{snd\_pcm\_capture\_hw\_avail}}{struct snd\_pcm\_runtime *\emph{ runtime}}{}
Get the free space for capture

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\end{description}
\index{snd\_pcm\_playback\_ready (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_playback_ready}\pysiglinewithargsret{int \bfcode{snd\_pcm\_playback\_ready}}{struct snd\_pcm\_substream *\emph{ substream}}{}
check whether the playback buffer is available

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\end{description}

\textbf{Description}

Checks whether enough free space is available on the playback buffer.

\textbf{Return}

Non-zero if available, or zero if not.
\index{snd\_pcm\_capture\_ready (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_capture_ready}\pysiglinewithargsret{int \bfcode{snd\_pcm\_capture\_ready}}{struct snd\_pcm\_substream *\emph{ substream}}{}
check whether the capture buffer is available

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\end{description}

\textbf{Description}

Checks whether enough capture data is available on the capture buffer.

\textbf{Return}

Non-zero if available, or zero if not.
\index{snd\_pcm\_playback\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_playback_data}\pysiglinewithargsret{int \bfcode{snd\_pcm\_playback\_data}}{struct snd\_pcm\_substream *\emph{ substream}}{}
check whether any data exists on the playback buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\end{description}

\textbf{Description}

Checks whether any data exists on the playback buffer.

\textbf{Return}

Non-zero if any data exists, or zero if not. If stop\_threshold
is bigger or equal to boundary, then this function returns always non-zero.
\index{snd\_pcm\_playback\_empty (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_playback_empty}\pysiglinewithargsret{int \bfcode{snd\_pcm\_playback\_empty}}{struct snd\_pcm\_substream *\emph{ substream}}{}
check whether the playback buffer is empty

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\end{description}

\textbf{Description}

Checks whether the playback buffer is empty.

\textbf{Return}

Non-zero if empty, or zero if not.
\index{snd\_pcm\_capture\_empty (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_capture_empty}\pysiglinewithargsret{int \bfcode{snd\_pcm\_capture\_empty}}{struct snd\_pcm\_substream *\emph{ substream}}{}
check whether the capture buffer is empty

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\end{description}

\textbf{Description}

Checks whether the capture buffer is empty.

\textbf{Return}

Non-zero if empty, or zero if not.
\index{snd\_pcm\_trigger\_done (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_trigger_done}\pysiglinewithargsret{void \bfcode{snd\_pcm\_trigger\_done}}{struct snd\_pcm\_substream *\emph{ substream}, struct snd\_pcm\_substream *\emph{ master}}{}
Mark the master substream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\item[{\code{struct snd\_pcm\_substream * master}}] \leavevmode
the linked master substream

\end{description}

\textbf{Description}

When multiple substreams of the same card are linked and the hardware
supports the single-shot operation, the driver calls this in the loop
in \code{snd\_pcm\_group\_for\_each\_entry()} for marking the substream as ``done''.
Then most of trigger operations are performed only to the given master
substream.

The trigger\_master mark is cleared at timestamp updates at the end
of trigger operations.
\index{params\_channels (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.params_channels}\pysiglinewithargsret{unsigned int \bfcode{params\_channels}}{const struct snd\_pcm\_hw\_params *\emph{ p}}{}
Get the number of channels from the hw params

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_pcm\_hw\_params * p}}] \leavevmode
hw params

\end{description}
\index{params\_rate (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.params_rate}\pysiglinewithargsret{unsigned int \bfcode{params\_rate}}{const struct snd\_pcm\_hw\_params *\emph{ p}}{}
Get the sample rate from the hw params

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_pcm\_hw\_params * p}}] \leavevmode
hw params

\end{description}
\index{params\_period\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.params_period_size}\pysiglinewithargsret{unsigned int \bfcode{params\_period\_size}}{const struct snd\_pcm\_hw\_params *\emph{ p}}{}
Get the period size (in frames) from the hw params

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_pcm\_hw\_params * p}}] \leavevmode
hw params

\end{description}
\index{params\_periods (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.params_periods}\pysiglinewithargsret{unsigned int \bfcode{params\_periods}}{const struct snd\_pcm\_hw\_params *\emph{ p}}{}
Get the number of periods from the hw params

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_pcm\_hw\_params * p}}] \leavevmode
hw params

\end{description}
\index{params\_buffer\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.params_buffer_size}\pysiglinewithargsret{unsigned int \bfcode{params\_buffer\_size}}{const struct snd\_pcm\_hw\_params *\emph{ p}}{}
Get the buffer size (in frames) from the hw params

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_pcm\_hw\_params * p}}] \leavevmode
hw params

\end{description}
\index{params\_buffer\_bytes (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.params_buffer_bytes}\pysiglinewithargsret{unsigned int \bfcode{params\_buffer\_bytes}}{const struct snd\_pcm\_hw\_params *\emph{ p}}{}
Get the buffer size (in bytes) from the hw params

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_pcm\_hw\_params * p}}] \leavevmode
hw params

\end{description}
\index{snd\_pcm\_hw\_constraint\_single (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_hw_constraint_single}\pysiglinewithargsret{int \bfcode{snd\_pcm\_hw\_constraint\_single}}{struct snd\_pcm\_runtime *\emph{ runtime}, snd\_pcm\_hw\_param\_t\emph{ var}, unsigned int\emph{ val}}{}
Constrain parameter to a single value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{snd\_pcm\_hw\_param\_t var}}] \leavevmode
The hw\_params variable to constrain

\item[{\code{unsigned int val}}] \leavevmode
The value to constrain to

\end{description}

\textbf{Return}

Positive if the value is changed, zero if it's not changed, or a
negative error code.
\index{snd\_pcm\_format\_cpu\_endian (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_format_cpu_endian}\pysiglinewithargsret{int \bfcode{snd\_pcm\_format\_cpu\_endian}}{snd\_pcm\_format\_t\emph{ format}}{}
Check the PCM format is CPU-endian

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_pcm\_format\_t format}}] \leavevmode
the format to check

\end{description}

\textbf{Return}

1 if the given PCM format is CPU-endian, 0 if
opposite, or a negative error code if endian not specified.
\index{snd\_pcm\_set\_runtime\_buffer (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_set_runtime_buffer}\pysiglinewithargsret{void \bfcode{snd\_pcm\_set\_runtime\_buffer}}{struct snd\_pcm\_substream *\emph{ substream}, struct snd\_dma\_buffer *\emph{ bufp}}{}
Set the PCM runtime buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream to set

\item[{\code{struct snd\_dma\_buffer * bufp}}] \leavevmode
the buffer information, NULL to clear

\end{description}

\textbf{Description}

Copy the buffer information to runtime-\textgreater{}dma\_buffer when \textbf{bufp} is non-NULL.
Otherwise it clears the current buffer information.
\index{snd\_pcm\_gettime (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_gettime}\pysiglinewithargsret{void \bfcode{snd\_pcm\_gettime}}{struct snd\_pcm\_runtime *\emph{ runtime}, struct timespec *\emph{ tv}}{}
Fill the timespec depending on the timestamp mode

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
PCM runtime instance

\item[{\code{struct timespec * tv}}] \leavevmode
timespec to fill

\end{description}
\index{snd\_pcm\_lib\_alloc\_vmalloc\_buffer (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_lib_alloc_vmalloc_buffer}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_alloc\_vmalloc\_buffer}}{struct snd\_pcm\_substream *\emph{ substream}, size\_t\emph{ size}}{}
allocate virtual DMA buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the substream to allocate the buffer to

\item[{\code{size\_t size}}] \leavevmode
the requested buffer size, in bytes

\end{description}

\textbf{Description}

Allocates the PCM substream buffer using \code{vmalloc()}, i.e., the memory is
contiguous in kernel virtual space, but not in physical memory.  Use this
if the buffer is accessed by kernel code but not by device DMA.

\textbf{Return}

1 if the buffer was changed, 0 if not changed, or a negative error
code.
\index{snd\_pcm\_lib\_alloc\_vmalloc\_32\_buffer (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_lib_alloc_vmalloc_32_buffer}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_alloc\_vmalloc\_32\_buffer}}{struct snd\_pcm\_substream *\emph{ substream}, size\_t\emph{ size}}{}
allocate 32-bit-addressable buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the substream to allocate the buffer to

\item[{\code{size\_t size}}] \leavevmode
the requested buffer size, in bytes

\end{description}

\textbf{Description}

This function works like \code{snd\_pcm\_lib\_alloc\_vmalloc\_buffer()}, but uses
\code{vmalloc\_32()}, i.e., the pages are allocated from 32-bit-addressable memory.

\textbf{Return}

1 if the buffer was changed, 0 if not changed, or a negative error
code.
\index{snd\_pcm\_sgbuf\_get\_addr (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_sgbuf_get_addr}\pysiglinewithargsret{dma\_addr\_t \bfcode{snd\_pcm\_sgbuf\_get\_addr}}{struct snd\_pcm\_substream *\emph{ substream}, unsigned int\emph{ ofs}}{}
Get the DMA address at the corresponding offset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{unsigned int ofs}}] \leavevmode
byte offset

\end{description}
\index{snd\_pcm\_sgbuf\_get\_ptr (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_sgbuf_get_ptr}\pysiglinewithargsret{void * \bfcode{snd\_pcm\_sgbuf\_get\_ptr}}{struct snd\_pcm\_substream *\emph{ substream}, unsigned int\emph{ ofs}}{}
Get the virtual address at the corresponding offset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{unsigned int ofs}}] \leavevmode
byte offset

\end{description}
\index{snd\_pcm\_sgbuf\_get\_chunk\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_sgbuf_get_chunk_size}\pysiglinewithargsret{unsigned int \bfcode{snd\_pcm\_sgbuf\_get\_chunk\_size}}{struct snd\_pcm\_substream *\emph{ substream}, unsigned int\emph{ ofs}, unsigned int\emph{ size}}{}
Compute the max size that fits within the contig. page from the given size

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{unsigned int ofs}}] \leavevmode
byte offset

\item[{\code{unsigned int size}}] \leavevmode
byte size to examine

\end{description}
\index{snd\_pcm\_mmap\_data\_open (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_mmap_data_open}\pysiglinewithargsret{void \bfcode{snd\_pcm\_mmap\_data\_open}}{struct vm\_area\_struct *\emph{ area}}{}
increase the mmap counter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vm\_area\_struct * area}}] \leavevmode
VMA

\end{description}

\textbf{Description}

PCM mmap callback should handle this counter properly
\index{snd\_pcm\_mmap\_data\_close (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_mmap_data_close}\pysiglinewithargsret{void \bfcode{snd\_pcm\_mmap\_data\_close}}{struct vm\_area\_struct *\emph{ area}}{}
decrease the mmap counter

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct vm\_area\_struct * area}}] \leavevmode
VMA

\end{description}

\textbf{Description}

PCM mmap callback should handle this counter properly
\index{snd\_pcm\_limit\_isa\_dma\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_limit_isa_dma_size}\pysiglinewithargsret{void \bfcode{snd\_pcm\_limit\_isa\_dma\_size}}{int\emph{ dma}, size\_t *\emph{ max}}{}
Get the max size fitting with ISA DMA transfer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int dma}}] \leavevmode
DMA number

\item[{\code{size\_t * max}}] \leavevmode
pointer to store the max size

\end{description}
\index{snd\_pcm\_stream\_str (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_stream_str}\pysiglinewithargsret{const char * \bfcode{snd\_pcm\_stream\_str}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Get a string naming the direction of a stream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\end{description}

\textbf{Return}

A string naming the direction of the stream.
\index{snd\_pcm\_chmap\_substream (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_chmap_substream}\pysiglinewithargsret{struct snd\_pcm\_substream * \bfcode{snd\_pcm\_chmap\_substream}}{struct snd\_pcm\_chmap *\emph{ info}, unsigned int\emph{ idx}}{}
get the PCM substream assigned to the given chmap info

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_chmap * info}}] \leavevmode
chmap information

\item[{\code{unsigned int idx}}] \leavevmode
the substream number index

\end{description}
\index{pcm\_format\_to\_bits (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.pcm_format_to_bits}\pysiglinewithargsret{u64 \bfcode{pcm\_format\_to\_bits}}{snd\_pcm\_format\_t\emph{ pcm\_format}}{}
Strong-typed conversion of pcm\_format to bitwise

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_pcm\_format\_t pcm\_format}}] \leavevmode
PCM format

\end{description}


\subsubsection{PCM Format Helpers}
\label{sound/kernel-api/alsa-driver-api:pcm-format-helpers}\index{snd\_pcm\_format\_signed (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_format_signed}\pysiglinewithargsret{int \bfcode{snd\_pcm\_format\_signed}}{snd\_pcm\_format\_t\emph{ format}}{}
Check the PCM format is signed linear

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_pcm\_format\_t format}}] \leavevmode
the format to check

\end{description}

\textbf{Return}

1 if the given PCM format is signed linear, 0 if unsigned
linear, and a negative error code for non-linear formats.
\index{snd\_pcm\_format\_unsigned (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_format_unsigned}\pysiglinewithargsret{int \bfcode{snd\_pcm\_format\_unsigned}}{snd\_pcm\_format\_t\emph{ format}}{}
Check the PCM format is unsigned linear

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_pcm\_format\_t format}}] \leavevmode
the format to check

\end{description}

\textbf{Return}

1 if the given PCM format is unsigned linear, 0 if signed
linear, and a negative error code for non-linear formats.
\index{snd\_pcm\_format\_linear (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_format_linear}\pysiglinewithargsret{int \bfcode{snd\_pcm\_format\_linear}}{snd\_pcm\_format\_t\emph{ format}}{}
Check the PCM format is linear

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_pcm\_format\_t format}}] \leavevmode
the format to check

\end{description}

\textbf{Return}

1 if the given PCM format is linear, 0 if not.
\index{snd\_pcm\_format\_little\_endian (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_format_little_endian}\pysiglinewithargsret{int \bfcode{snd\_pcm\_format\_little\_endian}}{snd\_pcm\_format\_t\emph{ format}}{}
Check the PCM format is little-endian

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_pcm\_format\_t format}}] \leavevmode
the format to check

\end{description}

\textbf{Return}

1 if the given PCM format is little-endian, 0 if
big-endian, or a negative error code if endian not specified.
\index{snd\_pcm\_format\_big\_endian (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_format_big_endian}\pysiglinewithargsret{int \bfcode{snd\_pcm\_format\_big\_endian}}{snd\_pcm\_format\_t\emph{ format}}{}
Check the PCM format is big-endian

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_pcm\_format\_t format}}] \leavevmode
the format to check

\end{description}

\textbf{Return}

1 if the given PCM format is big-endian, 0 if
little-endian, or a negative error code if endian not specified.
\index{snd\_pcm\_format\_width (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_format_width}\pysiglinewithargsret{int \bfcode{snd\_pcm\_format\_width}}{snd\_pcm\_format\_t\emph{ format}}{}
return the bit-width of the format

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_pcm\_format\_t format}}] \leavevmode
the format to check

\end{description}

\textbf{Return}

The bit-width of the format, or a negative error code
if unknown format.
\index{snd\_pcm\_format\_physical\_width (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_format_physical_width}\pysiglinewithargsret{int \bfcode{snd\_pcm\_format\_physical\_width}}{snd\_pcm\_format\_t\emph{ format}}{}
return the physical bit-width of the format

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_pcm\_format\_t format}}] \leavevmode
the format to check

\end{description}

\textbf{Return}

The physical bit-width of the format, or a negative error code
if unknown format.
\index{snd\_pcm\_format\_size (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_format_size}\pysiglinewithargsret{ssize\_t \bfcode{snd\_pcm\_format\_size}}{snd\_pcm\_format\_t\emph{ format}, size\_t\emph{ samples}}{}
return the byte size of samples on the given format

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_pcm\_format\_t format}}] \leavevmode
the format to check

\item[{\code{size\_t samples}}] \leavevmode
sampling rate

\end{description}

\textbf{Return}

The byte size of the given samples for the format, or a
negative error code if unknown format.
\index{snd\_pcm\_format\_silence\_64 (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_format_silence_64}\pysiglinewithargsret{const unsigned char * \bfcode{snd\_pcm\_format\_silence\_64}}{snd\_pcm\_format\_t\emph{ format}}{}
return the silent data in 8 bytes array

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_pcm\_format\_t format}}] \leavevmode
the format to check

\end{description}

\textbf{Return}

The format pattern to fill or \code{NULL} if error.
\index{snd\_pcm\_format\_set\_silence (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_format_set_silence}\pysiglinewithargsret{int \bfcode{snd\_pcm\_format\_set\_silence}}{snd\_pcm\_format\_t\emph{ format}, void *\emph{ data}, unsigned int\emph{ samples}}{}
set the silence data on the buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_pcm\_format\_t format}}] \leavevmode
the PCM format

\item[{\code{void * data}}] \leavevmode
the buffer pointer

\item[{\code{unsigned int samples}}] \leavevmode
the number of samples to set silence

\end{description}

\textbf{Description}

Sets the silence data on the buffer for the given samples.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_limit\_hw\_rates (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_limit_hw_rates}\pysiglinewithargsret{int \bfcode{snd\_pcm\_limit\_hw\_rates}}{struct snd\_pcm\_runtime *\emph{ runtime}}{}
determine rate\_min/rate\_max fields

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
the runtime instance

\end{description}

\textbf{Description}

Determines the rate\_min and rate\_max fields from the rates bits of
the given runtime-\textgreater{}hw.

\textbf{Return}

Zero if successful.
\index{snd\_pcm\_rate\_to\_rate\_bit (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_rate_to_rate_bit}\pysiglinewithargsret{unsigned int \bfcode{snd\_pcm\_rate\_to\_rate\_bit}}{unsigned int\emph{ rate}}{}
converts sample rate to SNDRV\_PCM\_RATE\_xxx bit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int rate}}] \leavevmode
the sample rate to convert

\end{description}

\textbf{Return}

The SNDRV\_PCM\_RATE\_xxx flag that corresponds to the given rate, or
SNDRV\_PCM\_RATE\_KNOT for an unknown rate.
\index{snd\_pcm\_rate\_bit\_to\_rate (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_rate_bit_to_rate}\pysiglinewithargsret{unsigned int \bfcode{snd\_pcm\_rate\_bit\_to\_rate}}{unsigned int\emph{ rate\_bit}}{}
converts SNDRV\_PCM\_RATE\_xxx bit to sample rate

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int rate\_bit}}] \leavevmode
the rate bit to convert

\end{description}

\textbf{Return}

The sample rate that corresponds to the given SNDRV\_PCM\_RATE\_xxx flag
or 0 for an unknown rate bit.
\index{snd\_pcm\_rate\_mask\_intersect (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_rate_mask_intersect}\pysiglinewithargsret{unsigned int \bfcode{snd\_pcm\_rate\_mask\_intersect}}{unsigned int\emph{ rates\_a}, unsigned int\emph{ rates\_b}}{}
computes the intersection between two rate masks

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int rates\_a}}] \leavevmode
The first rate mask

\item[{\code{unsigned int rates\_b}}] \leavevmode
The second rate mask

\end{description}

\textbf{Description}

This function computes the rates that are supported by both rate masks passed
to the function. It will take care of the special handling of
SNDRV\_PCM\_RATE\_CONTINUOUS and SNDRV\_PCM\_RATE\_KNOT.

\textbf{Return}

A rate mask containing the rates that are supported by both rates\_a
and rates\_b.
\index{snd\_pcm\_rate\_range\_to\_bits (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_rate_range_to_bits}\pysiglinewithargsret{unsigned int \bfcode{snd\_pcm\_rate\_range\_to\_bits}}{unsigned int\emph{ rate\_min}, unsigned int\emph{ rate\_max}}{}
converts rate range to SNDRV\_PCM\_RATE\_xxx bit

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int rate\_min}}] \leavevmode
the minimum sample rate

\item[{\code{unsigned int rate\_max}}] \leavevmode
the maximum sample rate

\end{description}

\textbf{Description}

This function has an implicit assumption: the rates in the given range have
only the pre-defined rates like 44100 or 16000.

\textbf{Return}

The SNDRV\_PCM\_RATE\_xxx flag that corresponds to the given rate range,
or SNDRV\_PCM\_RATE\_KNOT for an unknown range.


\subsubsection{PCM Memory Management}
\label{sound/kernel-api/alsa-driver-api:pcm-memory-management}\index{snd\_pcm\_lib\_preallocate\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_lib_preallocate_free}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_preallocate\_free}}{struct snd\_pcm\_substream *\emph{ substream}}{}
release the preallocated buffer of the specified substream.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\end{description}

\textbf{Description}

Releases the pre-allocated buffer of the given substream.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_lib\_preallocate\_free\_for\_all (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_lib_preallocate_free_for_all}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_preallocate\_free\_for\_all}}{struct snd\_pcm *\emph{ pcm}}{}
release all pre-allocated buffers on the pcm

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm * pcm}}] \leavevmode
the pcm instance

\end{description}

\textbf{Description}

Releases all the pre-allocated buffers on the given pcm.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_lib\_preallocate\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_lib_preallocate_pages}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_preallocate\_pages}}{struct snd\_pcm\_substream *\emph{ substream}, int\emph{ type}, struct device *\emph{ data}, size\_t\emph{ size}, size\_t\emph{ max}}{}
pre-allocation for the given DMA type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\item[{\code{int type}}] \leavevmode
DMA type (SNDRV\_DMA\_TYPE\_*)

\item[{\code{struct device * data}}] \leavevmode
DMA type dependent data

\item[{\code{size\_t size}}] \leavevmode
the requested pre-allocation size in bytes

\item[{\code{size\_t max}}] \leavevmode
the max. allowed pre-allocation size

\end{description}

\textbf{Description}

Do pre-allocation for the given DMA buffer type.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_lib\_preallocate\_pages\_for\_all (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_lib_preallocate_pages_for_all}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_preallocate\_pages\_for\_all}}{struct snd\_pcm *\emph{ pcm}, int\emph{ type}, void *\emph{ data}, size\_t\emph{ size}, size\_t\emph{ max}}{}
pre-allocation for continuous memory type (all substreams)

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm * pcm}}] \leavevmode
the pcm instance

\item[{\code{int type}}] \leavevmode
DMA type (SNDRV\_DMA\_TYPE\_*)

\item[{\code{void * data}}] \leavevmode
DMA type dependent data

\item[{\code{size\_t size}}] \leavevmode
the requested pre-allocation size in bytes

\item[{\code{size\_t max}}] \leavevmode
the max. allowed pre-allocation size

\end{description}

\textbf{Description}

Do pre-allocation to all substreams of the given pcm for the
specified DMA type.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_sgbuf\_ops\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_sgbuf_ops_page}\pysiglinewithargsret{struct page * \bfcode{snd\_pcm\_sgbuf\_ops\_page}}{struct snd\_pcm\_substream *\emph{ substream}, unsigned long\emph{ offset}}{}
get the page struct at the given offset

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream instance

\item[{\code{unsigned long offset}}] \leavevmode
the buffer offset

\end{description}

\textbf{Description}

Used as the page callback of PCM ops.

\textbf{Return}

The page struct at the given buffer offset. \code{NULL} on failure.
\index{snd\_pcm\_lib\_malloc\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_lib_malloc_pages}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_malloc\_pages}}{struct snd\_pcm\_substream *\emph{ substream}, size\_t\emph{ size}}{}
allocate the DMA buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the substream to allocate the DMA buffer to

\item[{\code{size\_t size}}] \leavevmode
the requested buffer size in bytes

\end{description}

\textbf{Description}

Allocates the DMA buffer on the BUS type given earlier to
\code{snd\_pcm\_lib\_preallocate\_xxx\_pages()}.

\textbf{Return}

1 if the buffer is changed, 0 if not changed, or a negative
code on failure.
\index{snd\_pcm\_lib\_free\_pages (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_lib_free_pages}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_free\_pages}}{struct snd\_pcm\_substream *\emph{ substream}}{}
release the allocated DMA buffer.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the substream to release the DMA buffer

\end{description}

\textbf{Description}

Releases the DMA buffer allocated via \code{snd\_pcm\_lib\_malloc\_pages()}.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_lib\_free\_vmalloc\_buffer (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_lib_free_vmalloc_buffer}\pysiglinewithargsret{int \bfcode{snd\_pcm\_lib\_free\_vmalloc\_buffer}}{struct snd\_pcm\_substream *\emph{ substream}}{}
free vmalloc buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the substream with a buffer allocated by
\code{snd\_pcm\_lib\_alloc\_vmalloc\_buffer()}

\end{description}

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_pcm\_lib\_get\_vmalloc\_page (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_lib_get_vmalloc_page}\pysiglinewithargsret{struct page * \bfcode{snd\_pcm\_lib\_get\_vmalloc\_page}}{struct snd\_pcm\_substream *\emph{ substream}, unsigned long\emph{ offset}}{}
map vmalloc buffer offset to page struct

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the substream with a buffer allocated by
\code{snd\_pcm\_lib\_alloc\_vmalloc\_buffer()}

\item[{\code{unsigned long offset}}] \leavevmode
offset in the buffer

\end{description}

\textbf{Description}

This function is to be used as the page callback in the PCM ops.

\textbf{Return}

The page struct, or \code{NULL} on failure.


\subsubsection{PCM DMA Engine API}
\label{sound/kernel-api/alsa-driver-api:pcm-dma-engine-api}\index{snd\_hwparams\_to\_dma\_slave\_config (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_hwparams_to_dma_slave_config}\pysiglinewithargsret{int \bfcode{snd\_hwparams\_to\_dma\_slave\_config}}{const struct snd\_pcm\_substream *\emph{ substream}, const struct snd\_pcm\_hw\_params *\emph{ params}, struct dma\_slave\_config *\emph{ slave\_config}}{}
Convert hw\_params to dma\_slave\_config

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{const struct snd\_pcm\_hw\_params * params}}] \leavevmode
hw\_params

\item[{\code{struct dma\_slave\_config * slave\_config}}] \leavevmode
DMA slave config

\end{description}

\textbf{Description}

This function can be used to initialize a dma\_slave\_config from a substream
and hw\_params in a dmaengine based PCM driver implementation.
\index{snd\_dmaengine\_pcm\_set\_config\_from\_dai\_data (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dmaengine_pcm_set_config_from_dai_data}\pysiglinewithargsret{void \bfcode{snd\_dmaengine\_pcm\_set\_config\_from\_dai\_data}}{const struct snd\_pcm\_substream *\emph{ substream}, const struct {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_dmaengine_dai_dma_data]{\emph{snd\_dmaengine\_dai\_dma\_data}}} *\emph{ dma\_data}, struct dma\_slave\_config *\emph{ slave\_config}}{}
Initializes a dma slave config using DAI DMA data.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{const struct snd\_dmaengine\_dai\_dma\_data * dma\_data}}] \leavevmode
DAI DMA data

\item[{\code{struct dma\_slave\_config * slave\_config}}] \leavevmode
DMA slave configuration

\end{description}

\textbf{Description}

Initializes the \{dst,src\}\_addr, \{dst,src\}\_maxburst, \{dst,src\}\_addr\_width and
slave\_id fields of the DMA slave config from the same fields of the DAI DMA
data struct. The src and dst fields will be initialized depending on the
direction of the substream. If the substream is a playback stream the dst
fields will be initialized, if it is a capture stream the src fields will be
initialized. The \{dst,src\}\_addr\_width field will only be initialized if the
SND\_DMAENGINE\_PCM\_DAI\_FLAG\_PACK flag is set or if the addr\_width field of
the DAI DMA data struct is not equal to DMA\_SLAVE\_BUSWIDTH\_UNDEFINED. If
both conditions are met the latter takes priority.
\index{snd\_dmaengine\_pcm\_trigger (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dmaengine_pcm_trigger}\pysiglinewithargsret{int \bfcode{snd\_dmaengine\_pcm\_trigger}}{struct snd\_pcm\_substream *\emph{ substream}, int\emph{ cmd}}{}
dmaengine based PCM trigger implementation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{int cmd}}] \leavevmode
Trigger command

\end{description}

\textbf{Description}

Returns 0 on success, a negative error code otherwise.

This function can be used as the PCM trigger callback for dmaengine based PCM
driver implementations.
\index{snd\_dmaengine\_pcm\_pointer\_no\_residue (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dmaengine_pcm_pointer_no_residue}\pysiglinewithargsret{snd\_pcm\_uframes\_t \bfcode{snd\_dmaengine\_pcm\_pointer\_no\_residue}}{struct snd\_pcm\_substream *\emph{ substream}}{}
dmaengine based PCM pointer implementation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\end{description}

\textbf{Description}

This function is deprecated and should not be used by new drivers, as its
results may be unreliable.
\index{snd\_dmaengine\_pcm\_pointer (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dmaengine_pcm_pointer}\pysiglinewithargsret{snd\_pcm\_uframes\_t \bfcode{snd\_dmaengine\_pcm\_pointer}}{struct snd\_pcm\_substream *\emph{ substream}}{}
dmaengine based PCM pointer implementation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\end{description}

\textbf{Description}

This function can be used as the PCM pointer callback for dmaengine based PCM
driver implementations.
\index{snd\_dmaengine\_pcm\_request\_channel (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dmaengine_pcm_request_channel}\pysiglinewithargsret{struct dma\_chan * \bfcode{snd\_dmaengine\_pcm\_request\_channel}}{dma\_filter\_fn\emph{ filter\_fn}, void *\emph{ filter\_data}}{}
Request channel for the dmaengine PCM

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{dma\_filter\_fn filter\_fn}}] \leavevmode
Filter function used to request the DMA channel

\item[{\code{void * filter\_data}}] \leavevmode
Data passed to the DMA filter function

\end{description}

\textbf{Description}

Returns NULL or the requested DMA channel.

This function request a DMA channel for usage with dmaengine PCM.
\index{snd\_dmaengine\_pcm\_open (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dmaengine_pcm_open}\pysiglinewithargsret{int \bfcode{snd\_dmaengine\_pcm\_open}}{struct snd\_pcm\_substream *\emph{ substream}, struct dma\_chan *\emph{ chan}}{}
Open a dmaengine based PCM substream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{struct dma\_chan * chan}}] \leavevmode
DMA channel to use for data transfers

\end{description}

\textbf{Description}

Returns 0 on success, a negative error code otherwise.

The function should usually be called from the pcm open callback. Note that
this function will use private\_data field of the substream's runtime. So it
is not available to your pcm driver implementation.
\index{snd\_dmaengine\_pcm\_open\_request\_chan (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dmaengine_pcm_open_request_chan}\pysiglinewithargsret{int \bfcode{snd\_dmaengine\_pcm\_open\_request\_chan}}{struct snd\_pcm\_substream *\emph{ substream}, dma\_filter\_fn\emph{ filter\_fn}, void *\emph{ filter\_data}}{}
Open a dmaengine based PCM substream and request channel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{dma\_filter\_fn filter\_fn}}] \leavevmode
Filter function used to request the DMA channel

\item[{\code{void * filter\_data}}] \leavevmode
Data passed to the DMA filter function

\end{description}

\textbf{Description}

Returns 0 on success, a negative error code otherwise.

This function will request a DMA channel using the passed filter function and
data. The function should usually be called from the pcm open callback. Note
that this function will use private\_data field of the substream's runtime. So
it is not available to your pcm driver implementation.
\index{snd\_dmaengine\_pcm\_close (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dmaengine_pcm_close}\pysiglinewithargsret{int \bfcode{snd\_dmaengine\_pcm\_close}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Close a dmaengine based PCM substream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\end{description}
\index{snd\_dmaengine\_pcm\_close\_release\_chan (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dmaengine_pcm_close_release_chan}\pysiglinewithargsret{int \bfcode{snd\_dmaengine\_pcm\_close\_release\_chan}}{struct snd\_pcm\_substream *\emph{ substream}}{}
Close a dmaengine based PCM substream and release channel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\end{description}

\textbf{Description}

Releases the DMA channel associated with the PCM substream.
\index{snd\_pcm\_substream\_to\_dma\_direction (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_pcm_substream_to_dma_direction}\pysiglinewithargsret{enum dma\_transfer\_direction \bfcode{snd\_pcm\_substream\_to\_dma\_direction}}{const struct snd\_pcm\_substream *\emph{ substream}}{}
Get dma\_transfer\_direction for a PCM substream

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\end{description}
\index{snd\_dmaengine\_dai\_dma\_data (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dmaengine_dai_dma_data}\pysigline{struct \bfcode{snd\_dmaengine\_dai\_dma\_data}}
DAI DMA configuration data

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}dmaengine\PYGZus{}dai\PYGZus{}dma\PYGZus{}data \PYGZob{}
  dma\PYGZus{}addr\PYGZus{}t addr;
  enum dma\PYGZus{}slave\PYGZus{}buswidth addr\PYGZus{}width;
  u32 maxburst;
  unsigned int slave\PYGZus{}id;
  void *filter\PYGZus{}data;
  const char *chan\PYGZus{}name;
  unsigned int fifo\PYGZus{}size;
  unsigned int flags;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{addr}}] \leavevmode
Address of the DAI data source or destination register.

\item[{\code{addr\_width}}] \leavevmode
Width of the DAI data source or destination register.

\item[{\code{maxburst}}] \leavevmode
Maximum number of words(note: words, as in units of the
src\_addr\_width member, not bytes) that can be send to or received from the
DAI in one burst.

\item[{\code{slave\_id}}] \leavevmode
Slave requester id for the DMA channel.

\item[{\code{filter\_data}}] \leavevmode
Custom DMA channel filter data, this will usually be used when
requesting the DMA channel.

\item[{\code{chan\_name}}] \leavevmode
Custom channel name to use when requesting DMA channel.

\item[{\code{fifo\_size}}] \leavevmode
FIFO size of the DAI controller in bytes

\item[{\code{flags}}] \leavevmode
PCM\_DAI flags, only SND\_DMAENGINE\_PCM\_DAI\_FLAG\_PACK for now

\end{description}
\index{snd\_dmaengine\_pcm\_config (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dmaengine_pcm_config}\pysigline{struct \bfcode{snd\_dmaengine\_pcm\_config}}
Configuration data for dmaengine based PCM

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}dmaengine\PYGZus{}pcm\PYGZus{}config \PYGZob{}
  int (*prepare\PYGZus{}slave\PYGZus{}config)(struct snd\PYGZus{}pcm\PYGZus{}substream *substream,struct snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}params *params, struct dma\PYGZus{}slave\PYGZus{}config *slave\PYGZus{}config);
  struct dma\PYGZus{}chan *(*compat\PYGZus{}request\PYGZus{}channel)(struct snd\PYGZus{}soc\PYGZus{}pcm\PYGZus{}runtime *rtd, struct snd\PYGZus{}pcm\PYGZus{}substream *substream);
  dma\PYGZus{}filter\PYGZus{}fn compat\PYGZus{}filter\PYGZus{}fn;
  struct device *dma\PYGZus{}dev;
  const char *chan\PYGZus{}names[SNDRV\PYGZus{}PCM\PYGZus{}STREAM\PYGZus{}LAST + 1];
  const struct snd\PYGZus{}pcm\PYGZus{}hardware *pcm\PYGZus{}hardware;
  unsigned int prealloc\PYGZus{}buffer\PYGZus{}size;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{prepare\_slave\_config}}] \leavevmode
Callback used to fill in the DMA slave\_config for a
PCM substream. Will be called from the PCM drivers hwparams callback.

\item[{\code{compat\_request\_channel}}] \leavevmode
Callback to request a DMA channel for platforms
which do not use devicetree.

\item[{\code{compat\_filter\_fn}}] \leavevmode
Will be used as the filter function when requesting a
channel for platforms which do not use devicetree. The filter parameter
will be the DAI's DMA data.

\item[{\code{dma\_dev}}] \leavevmode
If set, request DMA channel on this device rather than the DAI
device.

\item[{\code{chan\_names}}] \leavevmode
If set, these custom DMA channel names will be requested at
registration time.

\item[{\code{pcm\_hardware}}] \leavevmode
snd\_pcm\_hardware struct to be used for the PCM.

\item[{\code{prealloc\_buffer\_size}}] \leavevmode
Size of the preallocated audio buffer.

\end{description}

\textbf{Note}

If both compat\_request\_channel and compat\_filter\_fn are set
compat\_request\_channel will be used to request the channel and
compat\_filter\_fn will be ignored. Otherwise the channel will be requested
using dma\_request\_channel with compat\_filter\_fn as the filter function.


\subsection{Control/Mixer API}
\label{sound/kernel-api/alsa-driver-api:control-mixer-api}

\subsubsection{General Control Interface}
\label{sound/kernel-api/alsa-driver-api:general-control-interface}\index{snd\_ctl\_notify (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_notify}\pysiglinewithargsret{void \bfcode{snd\_ctl\_notify}}{struct snd\_card *\emph{ card}, unsigned int\emph{ mask}, struct snd\_ctl\_elem\_id *\emph{ id}}{}
Send notification to user-space for a control change

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card to send notification

\item[{\code{unsigned int mask}}] \leavevmode
the event mask, SNDRV\_CTL\_EVENT\_*

\item[{\code{struct snd\_ctl\_elem\_id * id}}] \leavevmode
the ctl element id to send notification

\end{description}

\textbf{Description}

This function adds an event record with the given id and mask, appends
to the list and wakes up the user-space for notification.  This can be
called in the atomic context.
\index{snd\_ctl\_new (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_new}\pysiglinewithargsret{int \bfcode{snd\_ctl\_new}}{struct snd\_kcontrol **\emph{ kctl}, unsigned int\emph{ count}, unsigned int\emph{ access}, struct snd\_ctl\_file *\emph{ file}}{}
create a new control instance with some elements

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol ** kctl}}] \leavevmode
the pointer to store new control instance

\item[{\code{unsigned int count}}] \leavevmode
the number of elements in this control

\item[{\code{unsigned int access}}] \leavevmode
the default access flags for elements in this control

\item[{\code{struct snd\_ctl\_file * file}}] \leavevmode
given when locking these elements

\end{description}

\textbf{Description}

Allocates a memory object for a new control instance. The instance has
elements as many as the given number (\textbf{count}). Each element has given
access permissions (\textbf{access}). Each element is locked when \textbf{file} is given.

\textbf{Return}

0 on success, error code on failure
\index{snd\_ctl\_new1 (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_new1}\pysiglinewithargsret{struct snd\_kcontrol * \bfcode{snd\_ctl\_new1}}{const struct snd\_kcontrol\_new *\emph{ ncontrol}, void *\emph{ private\_data}}{}
create a control instance from the template

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_kcontrol\_new * ncontrol}}] \leavevmode
the initialization record

\item[{\code{void * private\_data}}] \leavevmode
the private data to set

\end{description}

\textbf{Description}

Allocates a new struct snd\_kcontrol instance and initialize from the given
template.  When the access field of ncontrol is 0, it's assumed as
READWRITE access. When the count field is 0, it's assumes as one.

\textbf{Return}

The pointer of the newly generated instance, or \code{NULL} on failure.
\index{snd\_ctl\_free\_one (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_free_one}\pysiglinewithargsret{void \bfcode{snd\_ctl\_free\_one}}{struct snd\_kcontrol *\emph{ kcontrol}}{}
release the control instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
the control instance

\end{description}

\textbf{Description}

Releases the control instance created via {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ctl_new]{\emph{\code{snd\_ctl\_new()}}}}
or \code{snd\_ctl\_new1()}.
Don't call this after the control was added to the card.
\index{snd\_ctl\_add (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_add}\pysiglinewithargsret{int \bfcode{snd\_ctl\_add}}{struct snd\_card *\emph{ card}, struct snd\_kcontrol *\emph{ kcontrol}}{}
add the control instance to the card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
the control instance to add

\end{description}

\textbf{Description}

Adds the control instance created via {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ctl_new]{\emph{\code{snd\_ctl\_new()}}}} or
\code{snd\_ctl\_new1()} to the given card. Assigns also an unique
numid used for fast search.

It frees automatically the control which cannot be added.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_ctl\_replace (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_replace}\pysiglinewithargsret{int \bfcode{snd\_ctl\_replace}}{struct snd\_card *\emph{ card}, struct snd\_kcontrol *\emph{ kcontrol}, bool\emph{ add\_on\_replace}}{}
replace the control instance of the card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
the control instance to replace

\item[{\code{bool add\_on\_replace}}] \leavevmode
add the control if not already added

\end{description}

\textbf{Description}

Replaces the given control.  If the given control does not exist
and the add\_on\_replace flag is set, the control is added.  If the
control exists, it is destroyed first.

It frees automatically the control which cannot be added or replaced.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_ctl\_remove (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_remove}\pysiglinewithargsret{int \bfcode{snd\_ctl\_remove}}{struct snd\_card *\emph{ card}, struct snd\_kcontrol *\emph{ kcontrol}}{}
remove the control from the card and release it

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
the control instance to remove

\end{description}

\textbf{Description}

Removes the control from the card and then releases the instance.
You don't need to call \code{snd\_ctl\_free\_one()}. You must be in
the write lock - down\_write(\code{card-\textgreater{}controls\_rwsem}).

\textbf{Return}

0 if successful, or a negative error code on failure.
\index{snd\_ctl\_remove\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_remove_id}\pysiglinewithargsret{int \bfcode{snd\_ctl\_remove\_id}}{struct snd\_card *\emph{ card}, struct snd\_ctl\_elem\_id *\emph{ id}}{}
remove the control of the given id and release it

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{struct snd\_ctl\_elem\_id * id}}] \leavevmode
the control id to remove

\end{description}

\textbf{Description}

Finds the control instance with the given id, removes it from the
card list and releases it.

\textbf{Return}

0 if successful, or a negative error code on failure.
\index{snd\_ctl\_remove\_user\_ctl (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_remove_user_ctl}\pysiglinewithargsret{int \bfcode{snd\_ctl\_remove\_user\_ctl}}{struct snd\_ctl\_file *\emph{ file}, struct snd\_ctl\_elem\_id *\emph{ id}}{}
remove and release the unlocked user control

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_ctl\_file * file}}] \leavevmode
active control handle

\item[{\code{struct snd\_ctl\_elem\_id * id}}] \leavevmode
the control id to remove

\end{description}

\textbf{Description}

Finds the control instance with the given id, removes it from the
card list and releases it.

\textbf{Return}

0 if successful, or a negative error code on failure.
\index{snd\_ctl\_activate\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_activate_id}\pysiglinewithargsret{int \bfcode{snd\_ctl\_activate\_id}}{struct snd\_card *\emph{ card}, struct snd\_ctl\_elem\_id *\emph{ id}, int\emph{ active}}{}
activate/inactivate the control of the given id

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{struct snd\_ctl\_elem\_id * id}}] \leavevmode
the control id to activate/inactivate

\item[{\code{int active}}] \leavevmode
non-zero to activate

\end{description}

\textbf{Description}

Finds the control instance with the given id, and activate or
inactivate the control together with notification, if changed.
The given ID data is filled with full information.

\textbf{Return}

0 if unchanged, 1 if changed, or a negative error code on failure.
\index{snd\_ctl\_rename\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_rename_id}\pysiglinewithargsret{int \bfcode{snd\_ctl\_rename\_id}}{struct snd\_card *\emph{ card}, struct snd\_ctl\_elem\_id *\emph{ src\_id}, struct snd\_ctl\_elem\_id *\emph{ dst\_id}}{}
replace the id of a control on the card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{struct snd\_ctl\_elem\_id * src\_id}}] \leavevmode
the old id

\item[{\code{struct snd\_ctl\_elem\_id * dst\_id}}] \leavevmode
the new id

\end{description}

\textbf{Description}

Finds the control with the old id from the card, and replaces the
id with the new one.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_ctl\_find\_numid (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_find_numid}\pysiglinewithargsret{struct snd\_kcontrol * \bfcode{snd\_ctl\_find\_numid}}{struct snd\_card *\emph{ card}, unsigned int\emph{ numid}}{}
find the control instance with the given number-id

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{unsigned int numid}}] \leavevmode
the number-id to search

\end{description}

\textbf{Description}

Finds the control instance with the given number-id from the card.

The caller must down card-\textgreater{}controls\_rwsem before calling this function
(if the race condition can happen).

\textbf{Return}

The pointer of the instance if found, or \code{NULL} if not.
\index{snd\_ctl\_find\_id (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_find_id}\pysiglinewithargsret{struct snd\_kcontrol * \bfcode{snd\_ctl\_find\_id}}{struct snd\_card *\emph{ card}, struct snd\_ctl\_elem\_id *\emph{ id}}{}
find the control instance with the given id

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{struct snd\_ctl\_elem\_id * id}}] \leavevmode
the id to search

\end{description}

\textbf{Description}

Finds the control instance with the given id from the card.

The caller must down card-\textgreater{}controls\_rwsem before calling this function
(if the race condition can happen).

\textbf{Return}

The pointer of the instance if found, or \code{NULL} if not.
\index{snd\_ctl\_register\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_register_ioctl}\pysiglinewithargsret{int \bfcode{snd\_ctl\_register\_ioctl}}{snd\_kctl\_ioctl\_func\_t\emph{ fcn}}{}
register the device-specific control-ioctls

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_kctl\_ioctl\_func\_t fcn}}] \leavevmode
ioctl callback function

\end{description}

\textbf{Description}

called from each device manager like pcm.c, hwdep.c, etc.
\index{snd\_ctl\_register\_ioctl\_compat (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_register_ioctl_compat}\pysiglinewithargsret{int \bfcode{snd\_ctl\_register\_ioctl\_compat}}{snd\_kctl\_ioctl\_func\_t\emph{ fcn}}{}
register the device-specific 32bit compat control-ioctls

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_kctl\_ioctl\_func\_t fcn}}] \leavevmode
ioctl callback function

\end{description}
\index{snd\_ctl\_unregister\_ioctl (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_unregister_ioctl}\pysiglinewithargsret{int \bfcode{snd\_ctl\_unregister\_ioctl}}{snd\_kctl\_ioctl\_func\_t\emph{ fcn}}{}
de-register the device-specific control-ioctls

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_kctl\_ioctl\_func\_t fcn}}] \leavevmode
ioctl callback function to unregister

\end{description}
\index{snd\_ctl\_unregister\_ioctl\_compat (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_unregister_ioctl_compat}\pysiglinewithargsret{int \bfcode{snd\_ctl\_unregister\_ioctl\_compat}}{snd\_kctl\_ioctl\_func\_t\emph{ fcn}}{}
de-register the device-specific compat 32bit control-ioctls

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{snd\_kctl\_ioctl\_func\_t fcn}}] \leavevmode
ioctl callback function to unregister

\end{description}
\index{snd\_ctl\_boolean\_mono\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_boolean_mono_info}\pysiglinewithargsret{int \bfcode{snd\_ctl\_boolean\_mono\_info}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_info *\emph{ uinfo}}{}
Helper function for a standard boolean info callback with a mono channel

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
the kcontrol instance

\item[{\code{struct snd\_ctl\_elem\_info * uinfo}}] \leavevmode
info to store

\end{description}

\textbf{Description}

This is a function that can be used as info callback for a standard
boolean control with a single mono channel.
\index{snd\_ctl\_boolean\_stereo\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_boolean_stereo_info}\pysiglinewithargsret{int \bfcode{snd\_ctl\_boolean\_stereo\_info}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_info *\emph{ uinfo}}{}
Helper function for a standard boolean info callback with stereo two channels

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
the kcontrol instance

\item[{\code{struct snd\_ctl\_elem\_info * uinfo}}] \leavevmode
info to store

\end{description}

\textbf{Description}

This is a function that can be used as info callback for a standard
boolean control with stereo two channels.
\index{snd\_ctl\_enum\_info (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_enum_info}\pysiglinewithargsret{int \bfcode{snd\_ctl\_enum\_info}}{struct snd\_ctl\_elem\_info *\emph{ info}, unsigned int\emph{ channels}, unsigned int\emph{ items}, const char *const\emph{ names}}{}
fills the info structure for an enumerated control

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_ctl\_elem\_info * info}}] \leavevmode
the structure to be filled

\item[{\code{unsigned int channels}}] \leavevmode
the number of the control's channels; often one

\item[{\code{unsigned int items}}] \leavevmode
the number of control values; also the size of \textbf{names}

\item[{\code{const char *const names}}] \leavevmode
an array containing the names of all control values

\end{description}

\textbf{Description}

Sets all required fields in \textbf{info} to their appropriate values.
If the control's accessibility is not the default (readable and writable),
the caller has to fill \textbf{info}-\textgreater{}access.

\textbf{Return}

Zero.


\subsubsection{AC97 Codec API}
\label{sound/kernel-api/alsa-driver-api:ac97-codec-api}\index{snd\_ac97\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ac97_write}\pysiglinewithargsret{void \bfcode{snd\_ac97\_write}}{struct snd\_ac97 *\emph{ ac97}, unsigned short\emph{ reg}, unsigned short\emph{ value}}{}
write a value on the given register

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_ac97 * ac97}}] \leavevmode
the ac97 instance

\item[{\code{unsigned short reg}}] \leavevmode
the register to change

\item[{\code{unsigned short value}}] \leavevmode
the value to set

\end{description}

\textbf{Description}

Writes a value on the given register.  This will invoke the write
callback directly after the register check.
This function doesn't change the register cache unlike
\#:c:func:\emph{snd\_ca97\_write\_cache()}, so use this only when you don't want to
reflect the change to the suspend/resume state.
\index{snd\_ac97\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ac97_read}\pysiglinewithargsret{unsigned short \bfcode{snd\_ac97\_read}}{struct snd\_ac97 *\emph{ ac97}, unsigned short\emph{ reg}}{}
read a value from the given register

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_ac97 * ac97}}] \leavevmode
the ac97 instance

\item[{\code{unsigned short reg}}] \leavevmode
the register to read

\end{description}

\textbf{Description}

Reads a value from the given register.  This will invoke the read
callback directly after the register check.

\textbf{Return}

The read value.
\index{snd\_ac97\_write\_cache (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ac97_write_cache}\pysiglinewithargsret{void \bfcode{snd\_ac97\_write\_cache}}{struct snd\_ac97 *\emph{ ac97}, unsigned short\emph{ reg}, unsigned short\emph{ value}}{}
write a value on the given register and update the cache

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_ac97 * ac97}}] \leavevmode
the ac97 instance

\item[{\code{unsigned short reg}}] \leavevmode
the register to change

\item[{\code{unsigned short value}}] \leavevmode
the value to set

\end{description}

\textbf{Description}

Writes a value on the given register and updates the register
cache.  The cached values are used for the cached-read and the
suspend/resume.
\index{snd\_ac97\_update (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ac97_update}\pysiglinewithargsret{int \bfcode{snd\_ac97\_update}}{struct snd\_ac97 *\emph{ ac97}, unsigned short\emph{ reg}, unsigned short\emph{ value}}{}
update the value on the given register

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_ac97 * ac97}}] \leavevmode
the ac97 instance

\item[{\code{unsigned short reg}}] \leavevmode
the register to change

\item[{\code{unsigned short value}}] \leavevmode
the value to set

\end{description}

\textbf{Description}

Compares the value with the register cache and updates the value
only when the value is changed.

\textbf{Return}

1 if the value is changed, 0 if no change, or a negative
code on failure.
\index{snd\_ac97\_update\_bits (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ac97_update_bits}\pysiglinewithargsret{int \bfcode{snd\_ac97\_update\_bits}}{struct snd\_ac97 *\emph{ ac97}, unsigned short\emph{ reg}, unsigned short\emph{ mask}, unsigned short\emph{ value}}{}
update the bits on the given register

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_ac97 * ac97}}] \leavevmode
the ac97 instance

\item[{\code{unsigned short reg}}] \leavevmode
the register to change

\item[{\code{unsigned short mask}}] \leavevmode
the bit-mask to change

\item[{\code{unsigned short value}}] \leavevmode
the value to set

\end{description}

\textbf{Description}

Updates the masked-bits on the given register only when the value
is changed.

\textbf{Return}

1 if the bits are changed, 0 if no change, or a negative
code on failure.
\index{snd\_ac97\_get\_short\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ac97_get_short_name}\pysiglinewithargsret{const char * \bfcode{snd\_ac97\_get\_short\_name}}{struct snd\_ac97 *\emph{ ac97}}{}
retrieve codec name

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_ac97 * ac97}}] \leavevmode
the codec instance

\end{description}

\textbf{Return}

The short identifying name of the codec.
\index{snd\_ac97\_bus (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ac97_bus}\pysiglinewithargsret{int \bfcode{snd\_ac97\_bus}}{struct snd\_card *\emph{ card}, int\emph{ num}, struct snd\_ac97\_bus\_ops *\emph{ ops}, void *\emph{ private\_data}, struct {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_bus]{\emph{snd\_ac97\_bus}}} **\emph{ rbus}}{}
create an AC97 bus component

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{int num}}] \leavevmode
the bus number

\item[{\code{struct snd\_ac97\_bus\_ops * ops}}] \leavevmode
the bus callbacks table

\item[{\code{void * private\_data}}] \leavevmode
private data pointer for the new instance

\item[{\code{struct snd\_ac97\_bus ** rbus}}] \leavevmode
the pointer to store the new AC97 bus instance.

\end{description}

\textbf{Description}

Creates an AC97 bus component.  An struct snd\_ac97\_bus instance is newly
allocated and initialized.

The ops table must include valid callbacks (at least read and
write).  The other callbacks, wait and reset, are not mandatory.

The clock is set to 48000.  If another clock is needed, set
\code{(*rbus)-\textgreater{}clock} manually.

The AC97 bus instance is registered as a low-level device, so you don't
have to release it manually.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_ac97\_mixer (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ac97_mixer}\pysiglinewithargsret{int \bfcode{snd\_ac97\_mixer}}{struct {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_bus]{\emph{snd\_ac97\_bus}}} *\emph{ bus}, struct snd\_ac97\_template *\emph{ template}, struct snd\_ac97 **\emph{ rac97}}{}
create an Codec97 component

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_ac97\_bus * bus}}] \leavevmode
the AC97 bus which codec is attached to

\item[{\code{struct snd\_ac97\_template * template}}] \leavevmode
the template of ac97, including index, callbacks and
the private data.

\item[{\code{struct snd\_ac97 ** rac97}}] \leavevmode
the pointer to store the new ac97 instance.

\end{description}

\textbf{Description}

Creates an Codec97 component.  An struct snd\_ac97 instance is newly
allocated and initialized from the template.  The codec
is then initialized by the standard procedure.

The template must include the codec number (num) and address (addr),
and the private data (private\_data).

The ac97 instance is registered as a low-level device, so you don't
have to release it manually.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_ac97\_update\_power (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ac97_update_power}\pysiglinewithargsret{int \bfcode{snd\_ac97\_update\_power}}{struct snd\_ac97 *\emph{ ac97}, int\emph{ reg}, int\emph{ powerup}}{}
update the powerdown register

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_ac97 * ac97}}] \leavevmode
the codec instance

\item[{\code{int reg}}] \leavevmode
the rate register, e.g. AC97\_PCM\_FRONT\_DAC\_RATE

\item[{\code{int powerup}}] \leavevmode
non-zero when power up the part

\end{description}

\textbf{Description}

Update the AC97 powerdown register bits of the given part.

\textbf{Return}

Zero.
\index{snd\_ac97\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ac97_suspend}\pysiglinewithargsret{void \bfcode{snd\_ac97\_suspend}}{struct snd\_ac97 *\emph{ ac97}}{}
General suspend function for AC97 codec

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_ac97 * ac97}}] \leavevmode
the ac97 instance

\end{description}

\textbf{Description}

Suspends the codec, power down the chip.
\index{snd\_ac97\_resume (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ac97_resume}\pysiglinewithargsret{void \bfcode{snd\_ac97\_resume}}{struct snd\_ac97 *\emph{ ac97}}{}
General resume function for AC97 codec

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_ac97 * ac97}}] \leavevmode
the ac97 instance

\end{description}

\textbf{Description}

Do the standard resume procedure, power up and restoring the
old register values.
\index{snd\_ac97\_tune\_hardware (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ac97_tune_hardware}\pysiglinewithargsret{int \bfcode{snd\_ac97\_tune\_hardware}}{struct snd\_ac97 *\emph{ ac97}, const struct ac97\_quirk *\emph{ quirk}, const char *\emph{ override}}{}
tune up the hardware

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_ac97 * ac97}}] \leavevmode
the ac97 instance

\item[{\code{const struct ac97\_quirk * quirk}}] \leavevmode
quirk list

\item[{\code{const char * override}}] \leavevmode
explicit quirk value (overrides the list if non-NULL)

\end{description}

\textbf{Description}

Do some workaround for each pci device, such as renaming of the
headphone (true line-out) control as ``Master''.
The quirk-list must be terminated with a zero-filled entry.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_ac97\_set\_rate (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ac97_set_rate}\pysiglinewithargsret{int \bfcode{snd\_ac97\_set\_rate}}{struct snd\_ac97 *\emph{ ac97}, int\emph{ reg}, unsigned int\emph{ rate}}{}
change the rate of the given input/output.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_ac97 * ac97}}] \leavevmode
the ac97 instance

\item[{\code{int reg}}] \leavevmode
the register to change

\item[{\code{unsigned int rate}}] \leavevmode
the sample rate to set

\end{description}

\textbf{Description}

Changes the rate of the given input/output on the codec.
If the codec doesn't support VAR, the rate must be 48000 (except
for SPDIF).

The valid registers are AC97\_PMC\_MIC\_ADC\_RATE,
AC97\_PCM\_FRONT\_DAC\_RATE, AC97\_PCM\_LR\_ADC\_RATE.
AC97\_PCM\_SURR\_DAC\_RATE and AC97\_PCM\_LFE\_DAC\_RATE are accepted
if the codec supports them.
AC97\_SPDIF is accepted as a pseudo register to modify the SPDIF
status bits.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_ac97\_pcm\_assign (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ac97_pcm_assign}\pysiglinewithargsret{int \bfcode{snd\_ac97\_pcm\_assign}}{struct {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_bus]{\emph{snd\_ac97\_bus}}} *\emph{ bus}, unsigned short\emph{ pcms\_count}, const struct ac97\_pcm *\emph{ pcms}}{}
assign AC97 slots to given PCM streams

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_ac97\_bus * bus}}] \leavevmode
the ac97 bus instance

\item[{\code{unsigned short pcms\_count}}] \leavevmode
count of PCMs to be assigned

\item[{\code{const struct ac97\_pcm * pcms}}] \leavevmode
PCMs to be assigned

\end{description}

\textbf{Description}

It assigns available AC97 slots for given PCMs. If none or only
some slots are available, pcm-\textgreater{}xxx.slots and pcm-\textgreater{}xxx.rslots{[}{]} members
are reduced and might be zero.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_ac97\_pcm\_open (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ac97_pcm_open}\pysiglinewithargsret{int \bfcode{snd\_ac97\_pcm\_open}}{struct ac97\_pcm *\emph{ pcm}, unsigned int\emph{ rate}, enum ac97\_pcm\_cfg\emph{ cfg}, unsigned short\emph{ slots}}{}
opens the given AC97 pcm

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ac97\_pcm * pcm}}] \leavevmode
the ac97 pcm instance

\item[{\code{unsigned int rate}}] \leavevmode
rate in Hz, if codec does not support VRA, this value must be 48000Hz

\item[{\code{enum ac97\_pcm\_cfg cfg}}] \leavevmode
output stream characteristics

\item[{\code{unsigned short slots}}] \leavevmode
a subset of allocated slots (snd\_ac97\_pcm\_assign) for this pcm

\end{description}

\textbf{Description}

It locks the specified slots and sets the given rate to AC97 registers.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_ac97\_pcm\_close (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ac97_pcm_close}\pysiglinewithargsret{int \bfcode{snd\_ac97\_pcm\_close}}{struct ac97\_pcm *\emph{ pcm}}{}
closes the given AC97 pcm

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct ac97\_pcm * pcm}}] \leavevmode
the ac97 pcm instance

\end{description}

\textbf{Description}

It frees the locked AC97 slots.

\textbf{Return}

Zero.
\index{snd\_ac97\_pcm\_double\_rate\_rules (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ac97_pcm_double_rate_rules}\pysiglinewithargsret{int \bfcode{snd\_ac97\_pcm\_double\_rate\_rules}}{struct snd\_pcm\_runtime *\emph{ runtime}}{}
set double rate constraints

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_runtime * runtime}}] \leavevmode
the runtime of the ac97 front playback pcm

\end{description}

\textbf{Description}

Installs the hardware constraint rules to prevent using double rates and
more than two channels at the same time.

\textbf{Return}

Zero if successful, or a negative error code on failure.


\subsubsection{Virtual Master Control API}
\label{sound/kernel-api/alsa-driver-api:virtual-master-control-api}\index{snd\_ctl\_make\_virtual\_master (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_make_virtual_master}\pysiglinewithargsret{struct snd\_kcontrol * \bfcode{snd\_ctl\_make\_virtual\_master}}{char *\emph{ name}, const unsigned int *\emph{ tlv}}{}
Create a virtual master control

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{char * name}}] \leavevmode
name string of the control element to create

\item[{\code{const unsigned int * tlv}}] \leavevmode
optional TLV int array for dB information

\end{description}

\textbf{Description}

Creates a virtual master control with the given name string.

After creating a vmaster element, you can add the slave controls
via {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ctl_add_slave]{\emph{\code{snd\_ctl\_add\_slave()}}}} or {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ctl_add_slave_uncached]{\emph{\code{snd\_ctl\_add\_slave\_uncached()}}}}.

The optional argument \textbf{tlv} can be used to specify the TLV information
for dB scale of the master control.  It should be a single element
with \#SNDRV\_CTL\_TLVT\_DB\_SCALE, \#SNDRV\_CTL\_TLV\_DB\_MINMAX or
\#SNDRV\_CTL\_TLVT\_DB\_MINMAX\_MUTE type, and should be the max 0dB.

\textbf{Return}

The created control element, or \code{NULL} for errors (ENOMEM).
\index{snd\_ctl\_add\_vmaster\_hook (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_add_vmaster_hook}\pysiglinewithargsret{int \bfcode{snd\_ctl\_add\_vmaster\_hook}}{struct snd\_kcontrol *\emph{ kcontrol}, void (*hook) (void\emph{ *private\_data}, int, void *\emph{ private\_data}}{}
Add a hook to a vmaster control

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
vmaster kctl element

\item[{\code{void (*)(void *private\_data, int) hook}}] \leavevmode
the hook function

\item[{\code{void * private\_data}}] \leavevmode
the private\_data pointer to be saved

\end{description}

\textbf{Description}

Adds the given hook to the vmaster control element so that it's called
at each time when the value is changed.

\textbf{Return}

Zero.
\index{snd\_ctl\_sync\_vmaster (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_sync_vmaster}\pysiglinewithargsret{void \bfcode{snd\_ctl\_sync\_vmaster}}{struct snd\_kcontrol *\emph{ kcontrol}, bool\emph{ hook\_only}}{}
Sync the vmaster slaves and hook

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
vmaster kctl element

\item[{\code{bool hook\_only}}] \leavevmode
sync only the hook

\end{description}

\textbf{Description}

Forcibly call the put callback of each slave and call the hook function
to synchronize with the current value of the given vmaster element.
NOP when NULL is passed to \textbf{kcontrol}.
\index{snd\_ctl\_apply\_vmaster\_slaves (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_apply_vmaster_slaves}\pysiglinewithargsret{int \bfcode{snd\_ctl\_apply\_vmaster\_slaves}}{struct snd\_kcontrol *\emph{ kctl}, int (*func) (struct snd\_kcontrol\emph{ *vslave}, struct snd\_kcontrol\emph{ *slave}, void\emph{ *arg}, void *\emph{ arg}}{}
Apply function to each vmaster slave

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kctl}}] \leavevmode
vmaster kctl element

\item[{\code{int (*)(struct snd\_kcontrol *vslave, struct snd\_kcontrol *slave, void *arg) func}}] \leavevmode
function to apply

\item[{\code{void * arg}}] \leavevmode
optional function argument

\end{description}

\textbf{Description}

Apply the function \textbf{func} to each slave kctl of the given vmaster kctl.
Returns 0 if successful, or a negative error code.
\index{snd\_ctl\_add\_slave (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_add_slave}\pysiglinewithargsret{int \bfcode{snd\_ctl\_add\_slave}}{struct snd\_kcontrol *\emph{ master}, struct snd\_kcontrol *\emph{ slave}}{}
Add a virtual slave control

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * master}}] \leavevmode
vmaster element

\item[{\code{struct snd\_kcontrol * slave}}] \leavevmode
slave element to add

\end{description}

\textbf{Description}

Add a virtual slave control to the given master element created via
\code{snd\_ctl\_create\_virtual\_master()} beforehand.

All slaves must be the same type (returning the same information
via info callback).  The function doesn't check it, so it's your
responsibility.

Also, some additional limitations:
at most two channels,
logarithmic volume control (dB level) thus no linear volume,
master can only attenuate the volume without gain

\textbf{Return}

Zero if successful or a negative error code.
\index{snd\_ctl\_add\_slave\_uncached (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_ctl_add_slave_uncached}\pysiglinewithargsret{int \bfcode{snd\_ctl\_add\_slave\_uncached}}{struct snd\_kcontrol *\emph{ master}, struct snd\_kcontrol *\emph{ slave}}{}
Add a virtual slave control

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * master}}] \leavevmode
vmaster element

\item[{\code{struct snd\_kcontrol * slave}}] \leavevmode
slave element to add

\end{description}

\textbf{Description}

Add a virtual slave control to the given master.
Unlike {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ctl_add_slave]{\emph{\code{snd\_ctl\_add\_slave()}}}}, the element added via this function
is supposed to have volatile values, and get callback is called
at each time queried from the master.

When the control peeks the hardware values directly and the value
can be changed by other means than the put callback of the element,
this function should be used to keep the value always up-to-date.

\textbf{Return}

Zero if successful or a negative error code.


\subsection{MIDI API}
\label{sound/kernel-api/alsa-driver-api:midi-api}

\subsubsection{Raw MIDI API}
\label{sound/kernel-api/alsa-driver-api:raw-midi-api}\index{snd\_rawmidi\_receive (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_rawmidi_receive}\pysiglinewithargsret{int \bfcode{snd\_rawmidi\_receive}}{struct snd\_rawmidi\_substream *\emph{ substream}, const unsigned char *\emph{ buffer}, int\emph{ count}}{}
receive the input data from the device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_rawmidi\_substream * substream}}] \leavevmode
the rawmidi substream

\item[{\code{const unsigned char * buffer}}] \leavevmode
the buffer pointer

\item[{\code{int count}}] \leavevmode
the data size to read

\end{description}

\textbf{Description}

Reads the data from the internal buffer.

\textbf{Return}

The size of read data, or a negative error code on failure.
\index{snd\_rawmidi\_transmit\_empty (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_rawmidi_transmit_empty}\pysiglinewithargsret{int \bfcode{snd\_rawmidi\_transmit\_empty}}{struct snd\_rawmidi\_substream *\emph{ substream}}{}
check whether the output buffer is empty

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_rawmidi\_substream * substream}}] \leavevmode
the rawmidi substream

\end{description}

\textbf{Return}

1 if the internal output buffer is empty, 0 if not.
\index{\_\_snd\_rawmidi\_transmit\_peek (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.__snd_rawmidi_transmit_peek}\pysiglinewithargsret{int \bfcode{\_\_snd\_rawmidi\_transmit\_peek}}{struct snd\_rawmidi\_substream *\emph{ substream}, unsigned char *\emph{ buffer}, int\emph{ count}}{}
copy data from the internal buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_rawmidi\_substream * substream}}] \leavevmode
the rawmidi substream

\item[{\code{unsigned char * buffer}}] \leavevmode
the buffer pointer

\item[{\code{int count}}] \leavevmode
data size to transfer

\end{description}

\textbf{Description}

This is a variant of \code{snd\_rawmidi\_transmit\_peek()} without spinlock.
\index{snd\_rawmidi\_transmit\_peek (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_rawmidi_transmit_peek}\pysiglinewithargsret{int \bfcode{snd\_rawmidi\_transmit\_peek}}{struct snd\_rawmidi\_substream *\emph{ substream}, unsigned char *\emph{ buffer}, int\emph{ count}}{}
copy data from the internal buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_rawmidi\_substream * substream}}] \leavevmode
the rawmidi substream

\item[{\code{unsigned char * buffer}}] \leavevmode
the buffer pointer

\item[{\code{int count}}] \leavevmode
data size to transfer

\end{description}

\textbf{Description}

Copies data from the internal output buffer to the given buffer.

Call this in the interrupt handler when the midi output is ready,
and call \code{snd\_rawmidi\_transmit\_ack()} after the transmission is
finished.

\textbf{Return}

The size of copied data, or a negative error code on failure.
\index{\_\_snd\_rawmidi\_transmit\_ack (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.__snd_rawmidi_transmit_ack}\pysiglinewithargsret{int \bfcode{\_\_snd\_rawmidi\_transmit\_ack}}{struct snd\_rawmidi\_substream *\emph{ substream}, int\emph{ count}}{}
acknowledge the transmission

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_rawmidi\_substream * substream}}] \leavevmode
the rawmidi substream

\item[{\code{int count}}] \leavevmode
the transferred count

\end{description}

\textbf{Description}

This is a variant of \code{\_\_snd\_rawmidi\_transmit\_ack()} without spinlock.
\index{snd\_rawmidi\_transmit\_ack (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_rawmidi_transmit_ack}\pysiglinewithargsret{int \bfcode{snd\_rawmidi\_transmit\_ack}}{struct snd\_rawmidi\_substream *\emph{ substream}, int\emph{ count}}{}
acknowledge the transmission

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_rawmidi\_substream * substream}}] \leavevmode
the rawmidi substream

\item[{\code{int count}}] \leavevmode
the transferred count

\end{description}

\textbf{Description}

Advances the hardware pointer for the internal output buffer with
the given size and updates the condition.
Call after the transmission is finished.

\textbf{Return}

The advanced size if successful, or a negative error code on failure.
\index{snd\_rawmidi\_transmit (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_rawmidi_transmit}\pysiglinewithargsret{int \bfcode{snd\_rawmidi\_transmit}}{struct snd\_rawmidi\_substream *\emph{ substream}, unsigned char *\emph{ buffer}, int\emph{ count}}{}
copy from the buffer to the device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_rawmidi\_substream * substream}}] \leavevmode
the rawmidi substream

\item[{\code{unsigned char * buffer}}] \leavevmode
the buffer pointer

\item[{\code{int count}}] \leavevmode
the data size to transfer

\end{description}

\textbf{Description}

Copies data from the buffer to the device and advances the pointer.

\textbf{Return}

The copied size if successful, or a negative error code on failure.
\index{snd\_rawmidi\_new (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_rawmidi_new}\pysiglinewithargsret{int \bfcode{snd\_rawmidi\_new}}{struct snd\_card *\emph{ card}, char *\emph{ id}, int\emph{ device}, int\emph{ output\_count}, int\emph{ input\_count}, struct snd\_rawmidi **\emph{ rrawmidi}}{}
create a rawmidi instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{char * id}}] \leavevmode
the id string

\item[{\code{int device}}] \leavevmode
the device index

\item[{\code{int output\_count}}] \leavevmode
the number of output streams

\item[{\code{int input\_count}}] \leavevmode
the number of input streams

\item[{\code{struct snd\_rawmidi ** rrawmidi}}] \leavevmode
the pointer to store the new rawmidi instance

\end{description}

\textbf{Description}

Creates a new rawmidi instance.
Use \code{snd\_rawmidi\_set\_ops()} to set the operators to the new instance.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_rawmidi\_set\_ops (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_rawmidi_set_ops}\pysiglinewithargsret{void \bfcode{snd\_rawmidi\_set\_ops}}{struct snd\_rawmidi *\emph{ rmidi}, int\emph{ stream}, const struct snd\_rawmidi\_ops *\emph{ ops}}{}
set the rawmidi operators

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_rawmidi * rmidi}}] \leavevmode
the rawmidi instance

\item[{\code{int stream}}] \leavevmode
the stream direction, SNDRV\_RAWMIDI\_STREAM\_XXX

\item[{\code{const struct snd\_rawmidi\_ops * ops}}] \leavevmode
the operator table

\end{description}

\textbf{Description}

Sets the rawmidi operators for the given stream direction.


\subsubsection{MPU401-UART API}
\label{sound/kernel-api/alsa-driver-api:mpu401-uart-api}\index{snd\_mpu401\_uart\_interrupt (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_mpu401_uart_interrupt}\pysiglinewithargsret{irqreturn\_t \bfcode{snd\_mpu401\_uart\_interrupt}}{int\emph{ irq}, void *\emph{ dev\_id}}{}
generic MPU401-UART interrupt handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int irq}}] \leavevmode
the irq number

\item[{\code{void * dev\_id}}] \leavevmode
mpu401 instance

\end{description}

\textbf{Description}

Processes the interrupt for MPU401-UART i/o.

\textbf{Return}

\code{IRQ\_HANDLED} if the interrupt was handled. \code{IRQ\_NONE} otherwise.
\index{snd\_mpu401\_uart\_interrupt\_tx (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_mpu401_uart_interrupt_tx}\pysiglinewithargsret{irqreturn\_t \bfcode{snd\_mpu401\_uart\_interrupt\_tx}}{int\emph{ irq}, void *\emph{ dev\_id}}{}
generic MPU401-UART transmit irq handler

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{int irq}}] \leavevmode
the irq number

\item[{\code{void * dev\_id}}] \leavevmode
mpu401 instance

\end{description}

\textbf{Description}

Processes the interrupt for MPU401-UART output.

\textbf{Return}

\code{IRQ\_HANDLED} if the interrupt was handled. \code{IRQ\_NONE} otherwise.
\index{snd\_mpu401\_uart\_new (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_mpu401_uart_new}\pysiglinewithargsret{int \bfcode{snd\_mpu401\_uart\_new}}{struct snd\_card *\emph{ card}, int\emph{ device}, unsigned short\emph{ hardware}, unsigned long\emph{ port}, unsigned int\emph{ info\_flags}, int\emph{ irq}, struct snd\_rawmidi **\emph{ rrawmidi}}{}
create an MPU401-UART instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{int device}}] \leavevmode
the device index, zero-based

\item[{\code{unsigned short hardware}}] \leavevmode
the hardware type, MPU401\_HW\_XXXX

\item[{\code{unsigned long port}}] \leavevmode
the base address of MPU401 port

\item[{\code{unsigned int info\_flags}}] \leavevmode
bitflags MPU401\_INFO\_XXX

\item[{\code{int irq}}] \leavevmode
the ISA irq number, -1 if not to be allocated

\item[{\code{struct snd\_rawmidi ** rrawmidi}}] \leavevmode
the pointer to store the new rawmidi instance

\end{description}

\textbf{Description}

Creates a new MPU-401 instance.

Note that the rawmidi instance is returned on the rrawmidi argument,
not the mpu401 instance itself.  To access to the mpu401 instance,
cast from rawmidi-\textgreater{}private\_data (with struct snd\_mpu401 magic-cast).

\textbf{Return}

Zero if successful, or a negative error code.


\subsection{Proc Info API}
\label{sound/kernel-api/alsa-driver-api:proc-info-api}

\subsubsection{Proc Info Interface}
\label{sound/kernel-api/alsa-driver-api:proc-info-interface}\index{snd\_info\_get\_line (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_info_get_line}\pysiglinewithargsret{int \bfcode{snd\_info\_get\_line}}{struct snd\_info\_buffer *\emph{ buffer}, char *\emph{ line}, int\emph{ len}}{}
read one line from the procfs buffer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_info\_buffer * buffer}}] \leavevmode
the procfs buffer

\item[{\code{char * line}}] \leavevmode
the buffer to store

\item[{\code{int len}}] \leavevmode
the max. buffer size

\end{description}

\textbf{Description}

Reads one line from the buffer and stores the string.

\textbf{Return}

Zero if successful, or 1 if error or EOF.
\index{snd\_info\_get\_str (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_info_get_str}\pysiglinewithargsret{const char * \bfcode{snd\_info\_get\_str}}{char *\emph{ dest}, const char *\emph{ src}, int\emph{ len}}{}
parse a string token

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{char * dest}}] \leavevmode
the buffer to store the string token

\item[{\code{const char * src}}] \leavevmode
the original string

\item[{\code{int len}}] \leavevmode
the max. length of token - 1

\end{description}

\textbf{Description}

Parses the original string and copy a token to the given
string buffer.

\textbf{Return}

The updated pointer of the original string so that
it can be used for the next call.
\index{snd\_info\_create\_module\_entry (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_info_create_module_entry}\pysiglinewithargsret{struct snd\_info\_entry * \bfcode{snd\_info\_create\_module\_entry}}{struct module *\emph{ module}, const char *\emph{ name}, struct snd\_info\_entry *\emph{ parent}}{}
create an info entry for the given module

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct module * module}}] \leavevmode
the module pointer

\item[{\code{const char * name}}] \leavevmode
the file name

\item[{\code{struct snd\_info\_entry * parent}}] \leavevmode
the parent directory

\end{description}

\textbf{Description}

Creates a new info entry and assigns it to the given module.

\textbf{Return}

The pointer of the new instance, or \code{NULL} on failure.
\index{snd\_info\_create\_card\_entry (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_info_create_card_entry}\pysiglinewithargsret{struct snd\_info\_entry * \bfcode{snd\_info\_create\_card\_entry}}{struct snd\_card *\emph{ card}, const char *\emph{ name}, struct snd\_info\_entry *\emph{ parent}}{}
create an info entry for the given card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{const char * name}}] \leavevmode
the file name

\item[{\code{struct snd\_info\_entry * parent}}] \leavevmode
the parent directory

\end{description}

\textbf{Description}

Creates a new info entry and assigns it to the given card.

\textbf{Return}

The pointer of the new instance, or \code{NULL} on failure.
\index{snd\_info\_free\_entry (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_info_free_entry}\pysiglinewithargsret{void \bfcode{snd\_info\_free\_entry}}{struct snd\_info\_entry *\emph{ entry}}{}
release the info entry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_info\_entry * entry}}] \leavevmode
the info entry

\end{description}

\textbf{Description}

Releases the info entry.
\index{snd\_info\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_info_register}\pysiglinewithargsret{int \bfcode{snd\_info\_register}}{struct snd\_info\_entry *\emph{ entry}}{}
register the info entry

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_info\_entry * entry}}] \leavevmode
the info entry

\end{description}

\textbf{Description}

Registers the proc info entry.

\textbf{Return}

Zero if successful, or a negative error code on failure.


\subsection{Compress Offload}
\label{sound/kernel-api/alsa-driver-api:compress-offload}

\subsubsection{Compress Offload API}
\label{sound/kernel-api/alsa-driver-api:compress-offload-api}\index{snd\_compress\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_compress_register}\pysiglinewithargsret{int \bfcode{snd\_compress\_register}}{struct {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_compr]{\emph{snd\_compr}}} *\emph{ device}}{}
register compressed device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_compr * device}}] \leavevmode
compressed device to register

\end{description}
\index{snd\_compressed\_buffer (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_compressed_buffer}\pysigline{struct \bfcode{snd\_compressed\_buffer}}
compressed buffer

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}compressed\PYGZus{}buffer \PYGZob{}
  \PYGZus{}\PYGZus{}u32 fragment\PYGZus{}size;
  \PYGZus{}\PYGZus{}u32 fragments;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{fragment\_size}}] \leavevmode
size of buffer fragment in bytes

\item[{\code{fragments}}] \leavevmode
number of such fragments

\end{description}
\index{snd\_compr\_params (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_compr_params}\pysigline{struct \bfcode{snd\_compr\_params}}
compressed stream params

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}compr\PYGZus{}params \PYGZob{}
  struct snd\PYGZus{}compressed\PYGZus{}buffer buffer;
  struct snd\PYGZus{}codec codec;
  \PYGZus{}\PYGZus{}u8 no\PYGZus{}wake\PYGZus{}mode;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{buffer}}] \leavevmode
buffer description

\item[{\code{codec}}] \leavevmode
codec parameters

\item[{\code{no\_wake\_mode}}] \leavevmode
dont wake on fragment elapsed

\end{description}
\index{snd\_compr\_tstamp (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_compr_tstamp}\pysigline{struct \bfcode{snd\_compr\_tstamp}}
timestamp descriptor

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}compr\PYGZus{}tstamp \PYGZob{}
  \PYGZus{}\PYGZus{}u32 byte\PYGZus{}offset;
  \PYGZus{}\PYGZus{}u32 copied\PYGZus{}total;
  \PYGZus{}\PYGZus{}u32 pcm\PYGZus{}frames;
  \PYGZus{}\PYGZus{}u32 pcm\PYGZus{}io\PYGZus{}frames;
  \PYGZus{}\PYGZus{}u32 sampling\PYGZus{}rate;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{byte\_offset}}] \leavevmode
Byte offset in ring buffer to DSP

\item[{\code{copied\_total}}] \leavevmode
Total number of bytes copied from/to ring buffer to/by DSP

\item[{\code{pcm\_frames}}] \leavevmode
Frames decoded or encoded by DSP. This field will evolve by
large steps and should only be used to monitor encoding/decoding
progress. It shall not be used for timing estimates.

\item[{\code{pcm\_io\_frames}}] \leavevmode
Frames rendered or received by DSP into a mixer or an audio
output/input. This field should be used for A/V sync or time estimates.

\item[{\code{sampling\_rate}}] \leavevmode
sampling rate of audio

\end{description}
\index{snd\_compr\_avail (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_compr_avail}\pysigline{struct \bfcode{snd\_compr\_avail}}
avail descriptor

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}compr\PYGZus{}avail \PYGZob{}
  \PYGZus{}\PYGZus{}u64 avail;
  struct snd\PYGZus{}compr\PYGZus{}tstamp tstamp;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{avail}}] \leavevmode
Number of bytes available in ring buffer for writing/reading

\item[{\code{tstamp}}] \leavevmode
timestamp information

\end{description}
\index{snd\_compr\_caps (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_compr_caps}\pysigline{struct \bfcode{snd\_compr\_caps}}
caps descriptor

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}compr\PYGZus{}caps \PYGZob{}
  \PYGZus{}\PYGZus{}u32 num\PYGZus{}codecs;
  \PYGZus{}\PYGZus{}u32 direction;
  \PYGZus{}\PYGZus{}u32 min\PYGZus{}fragment\PYGZus{}size;
  \PYGZus{}\PYGZus{}u32 max\PYGZus{}fragment\PYGZus{}size;
  \PYGZus{}\PYGZus{}u32 min\PYGZus{}fragments;
  \PYGZus{}\PYGZus{}u32 max\PYGZus{}fragments;
  \PYGZus{}\PYGZus{}u32 codecs[MAX\PYGZus{}NUM\PYGZus{}CODECS];
  \PYGZus{}\PYGZus{}u32 reserved[11];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{num\_codecs}}] \leavevmode
number of codecs supported

\item[{\code{direction}}] \leavevmode
direction supported. Of type snd\_compr\_direction

\item[{\code{min\_fragment\_size}}] \leavevmode
minimum fragment supported by DSP

\item[{\code{max\_fragment\_size}}] \leavevmode
maximum fragment supported by DSP

\item[{\code{min\_fragments}}] \leavevmode
min fragments supported by DSP

\item[{\code{max\_fragments}}] \leavevmode
max fragments supported by DSP

\item[{\code{codecs}}] \leavevmode
pointer to array of codecs

\item[{\code{reserved}}] \leavevmode
reserved field

\end{description}
\index{snd\_compr\_codec\_caps (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_compr_codec_caps}\pysigline{struct \bfcode{snd\_compr\_codec\_caps}}
query capability of codec

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}compr\PYGZus{}codec\PYGZus{}caps \PYGZob{}
  \PYGZus{}\PYGZus{}u32 codec;
  \PYGZus{}\PYGZus{}u32 num\PYGZus{}descriptors;
  struct snd\PYGZus{}codec\PYGZus{}desc descriptor[MAX\PYGZus{}NUM\PYGZus{}CODEC\PYGZus{}DESCRIPTORS];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{codec}}] \leavevmode
codec for which capability is queried

\item[{\code{num\_descriptors}}] \leavevmode
number of codec descriptors

\item[{\code{descriptor}}] \leavevmode
array of codec capability descriptor

\end{description}
\index{sndrv\_compress\_encoder (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.sndrv_compress_encoder}\pysigline{enum \bfcode{sndrv\_compress\_encoder}}
\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{SNDRV\_COMPRESS\_ENCODER\_PADDING}}] \leavevmode
no of samples appended by the encoder at the
end of the track

\item[{\code{SNDRV\_COMPRESS\_ENCODER\_DELAY}}] \leavevmode
no of samples inserted by the encoder at the
beginning of the track

\end{description}
\index{snd\_compr\_metadata (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_compr_metadata}\pysigline{struct \bfcode{snd\_compr\_metadata}}
compressed stream metadata

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}compr\PYGZus{}metadata \PYGZob{}
  \PYGZus{}\PYGZus{}u32 key;
  \PYGZus{}\PYGZus{}u32 value[8];
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{key}}] \leavevmode
key id

\item[{\code{value}}] \leavevmode
key value

\end{description}
\index{SNDRV\_COMPRESS\_IOCTL\_VERSION (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.SNDRV_COMPRESS_IOCTL_VERSION}\pysiglinewithargsret{\bfcode{SNDRV\_COMPRESS\_IOCTL\_VERSION}}{}{}
\end{fulllineitems}


\textbf{Parameters}

\textbf{Description}

SNDRV\_COMPRESS\_GET\_CAPS: Query capability of DSP
SNDRV\_COMPRESS\_GET\_CODEC\_CAPS: Query capability of a codec
SNDRV\_COMPRESS\_SET\_PARAMS: Set codec and stream parameters

\textbf{Note}

only codec params can be changed runtime and stream params cant be
SNDRV\_COMPRESS\_GET\_PARAMS: Query codec params
SNDRV\_COMPRESS\_TSTAMP: get the current timestamp value
SNDRV\_COMPRESS\_AVAIL: get the current buffer avail value.
This also queries the tstamp properties
SNDRV\_COMPRESS\_PAUSE: Pause the running stream
SNDRV\_COMPRESS\_RESUME: resume a paused stream
SNDRV\_COMPRESS\_START: Start a stream
SNDRV\_COMPRESS\_STOP: stop a running stream, discarding ring buffer content
and the buffers currently with DSP
SNDRV\_COMPRESS\_DRAIN: Play till end of buffers and stop after that
SNDRV\_COMPRESS\_IOCTL\_VERSION: Query the API version
\index{snd\_enc\_vorbis (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_enc_vorbis}\pysigline{struct \bfcode{snd\_enc\_vorbis}}
\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}enc\PYGZus{}vorbis \PYGZob{}
  \PYGZus{}\PYGZus{}s32 quality;
  \PYGZus{}\PYGZus{}u32 managed;
  \PYGZus{}\PYGZus{}u32 max\PYGZus{}bit\PYGZus{}rate;
  \PYGZus{}\PYGZus{}u32 min\PYGZus{}bit\PYGZus{}rate;
  \PYGZus{}\PYGZus{}u32 downmix;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{quality}}] \leavevmode
Sets encoding quality to n, between -1 (low) and 10 (high).
In the default mode of operation, the quality level is 3.
Normal quality range is 0 - 10.

\item[{\code{managed}}] \leavevmode
Boolean. Set  bitrate  management  mode. This turns off the
normal VBR encoding, but allows hard or soft bitrate constraints to be
enforced by the encoder. This mode can be slower, and may also be
lower quality. It is primarily useful for streaming.

\item[{\code{max\_bit\_rate}}] \leavevmode
Enabled only if managed is TRUE

\item[{\code{min\_bit\_rate}}] \leavevmode
Enabled only if managed is TRUE

\item[{\code{downmix}}] \leavevmode
Boolean. Downmix input from stereo to mono (has no effect on
non-stereo streams). Useful for lower-bitrate encoding.

\end{description}

\textbf{Description}

These options were extracted from the OpenMAX IL spec and Gstreamer vorbisenc
properties

For best quality users should specify VBR mode and set quality levels.
\index{snd\_enc\_real (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_enc_real}\pysigline{struct \bfcode{snd\_enc\_real}}
\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}enc\PYGZus{}real \PYGZob{}
  \PYGZus{}\PYGZus{}u32 quant\PYGZus{}bits;
  \PYGZus{}\PYGZus{}u32 start\PYGZus{}region;
  \PYGZus{}\PYGZus{}u32 num\PYGZus{}regions;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{quant\_bits}}] \leavevmode
number of coupling quantization bits in the stream

\item[{\code{start\_region}}] \leavevmode
coupling start region in the stream

\item[{\code{num\_regions}}] \leavevmode
number of regions value

\end{description}

\textbf{Description}

These options were extracted from the OpenMAX IL spec
\index{snd\_enc\_flac (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_enc_flac}\pysigline{struct \bfcode{snd\_enc\_flac}}
\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}enc\PYGZus{}flac \PYGZob{}
  \PYGZus{}\PYGZus{}u32 num;
  \PYGZus{}\PYGZus{}u32 gain;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{num}}] \leavevmode
serial number, valid only for OGG formats
needs to be set by application

\item[{\code{gain}}] \leavevmode
Add replay gain tags

\end{description}

\textbf{Description}

These options were extracted from the FLAC online documentation
at \href{http://flac.sourceforge.net/documentation\_tools\_flac.html}{http://flac.sourceforge.net/documentation\_tools\_flac.html}

To make the API simpler, it is assumed that the user will select quality
profiles. Additional options that affect encoding quality and speed can
be added at a later stage if needed.

By default the Subset format is used by encoders.

TAGS such as pictures, etc, cannot be handled by an offloaded encoder and are
not supported in this API.
\index{snd\_compr\_runtime (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_compr_runtime}\pysigline{struct \bfcode{snd\_compr\_runtime}}
\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}compr\PYGZus{}runtime \PYGZob{}
  snd\PYGZus{}pcm\PYGZus{}state\PYGZus{}t state;
  struct snd\PYGZus{}compr\PYGZus{}ops *ops;
  void *buffer;
  u64 buffer\PYGZus{}size;
  u32 fragment\PYGZus{}size;
  u32 fragments;
  u64 total\PYGZus{}bytes\PYGZus{}available;
  u64 total\PYGZus{}bytes\PYGZus{}transferred;
  wait\PYGZus{}queue\PYGZus{}head\PYGZus{}t sleep;
  void *private\PYGZus{}data;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{state}}] \leavevmode
stream state

\item[{\code{ops}}] \leavevmode
pointer to DSP callbacks

\item[{\code{buffer}}] \leavevmode
pointer to kernel buffer, valid only when not in mmap mode or
DSP doesn't implement copy

\item[{\code{buffer\_size}}] \leavevmode
size of the above buffer

\item[{\code{fragment\_size}}] \leavevmode
size of buffer fragment in bytes

\item[{\code{fragments}}] \leavevmode
number of such fragments

\item[{\code{total\_bytes\_available}}] \leavevmode
cumulative number of bytes made available in
the ring buffer

\item[{\code{total\_bytes\_transferred}}] \leavevmode
cumulative bytes transferred by offload DSP

\item[{\code{sleep}}] \leavevmode
poll sleep

\item[{\code{private\_data}}] \leavevmode
driver private data pointer

\end{description}
\index{snd\_compr\_stream (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_compr_stream}\pysigline{struct \bfcode{snd\_compr\_stream}}
\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}compr\PYGZus{}stream \PYGZob{}
  const char *name;
  struct snd\PYGZus{}compr\PYGZus{}ops *ops;
  struct snd\PYGZus{}compr\PYGZus{}runtime *runtime;
  struct snd\PYGZus{}compr *device;
  struct delayed\PYGZus{}work error\PYGZus{}work;
  enum snd\PYGZus{}compr\PYGZus{}direction direction;
  bool metadata\PYGZus{}set;
  bool next\PYGZus{}track;
  void *private\PYGZus{}data;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
device name

\item[{\code{ops}}] \leavevmode
pointer to DSP callbacks

\item[{\code{runtime}}] \leavevmode
pointer to runtime structure

\item[{\code{device}}] \leavevmode
device pointer

\item[{\code{error\_work}}] \leavevmode
delayed work used when closing the stream due to an error

\item[{\code{direction}}] \leavevmode
stream direction, playback/recording

\item[{\code{metadata\_set}}] \leavevmode
metadata set flag, true when set

\item[{\code{next\_track}}] \leavevmode
has userspace signal next track transition, true when set

\item[{\code{private\_data}}] \leavevmode
pointer to DSP private data

\end{description}
\index{snd\_compr\_ops (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_compr_ops}\pysigline{struct \bfcode{snd\_compr\_ops}}
\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}compr\PYGZus{}ops \PYGZob{}
  int (*open)(struct snd\PYGZus{}compr\PYGZus{}stream *stream);
  int (*free)(struct snd\PYGZus{}compr\PYGZus{}stream *stream);
  int (*set\PYGZus{}params)(struct snd\PYGZus{}compr\PYGZus{}stream *stream, struct snd\PYGZus{}compr\PYGZus{}params *params);
  int (*get\PYGZus{}params)(struct snd\PYGZus{}compr\PYGZus{}stream *stream, struct snd\PYGZus{}codec *params);
  int (*set\PYGZus{}metadata)(struct snd\PYGZus{}compr\PYGZus{}stream *stream, struct snd\PYGZus{}compr\PYGZus{}metadata *metadata);
  int (*get\PYGZus{}metadata)(struct snd\PYGZus{}compr\PYGZus{}stream *stream, struct snd\PYGZus{}compr\PYGZus{}metadata *metadata);
  int (*trigger)(struct snd\PYGZus{}compr\PYGZus{}stream *stream, int cmd);
  int (*pointer)(struct snd\PYGZus{}compr\PYGZus{}stream *stream, struct snd\PYGZus{}compr\PYGZus{}tstamp *tstamp);
  int (*copy)(struct snd\PYGZus{}compr\PYGZus{}stream *stream, char \PYGZus{}\PYGZus{}user *buf, size\PYGZus{}t count);
  int (*mmap)(struct snd\PYGZus{}compr\PYGZus{}stream *stream, struct vm\PYGZus{}area\PYGZus{}struct *vma);
  int (*ack)(struct snd\PYGZus{}compr\PYGZus{}stream *stream, size\PYGZus{}t bytes);
  int (*get\PYGZus{}caps) (struct snd\PYGZus{}compr\PYGZus{}stream *stream, struct snd\PYGZus{}compr\PYGZus{}caps *caps);
  int (*get\PYGZus{}codec\PYGZus{}caps) (struct snd\PYGZus{}compr\PYGZus{}stream *stream, struct snd\PYGZus{}compr\PYGZus{}codec\PYGZus{}caps *codec);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{open}}] \leavevmode
Open the compressed stream
This callback is mandatory and shall keep dsp ready to receive the stream
parameter

\item[{\code{free}}] \leavevmode
Close the compressed stream, mandatory

\item[{\code{set\_params}}] \leavevmode
Sets the compressed stream parameters, mandatory
This can be called in during stream creation only to set codec params
and the stream properties

\item[{\code{get\_params}}] \leavevmode
retrieve the codec parameters, mandatory

\item[{\code{set\_metadata}}] \leavevmode
Set the metadata values for a stream

\item[{\code{get\_metadata}}] \leavevmode
retrieves the requested metadata values from stream

\item[{\code{trigger}}] \leavevmode
Trigger operations like start, pause, resume, drain, stop.
This callback is mandatory

\item[{\code{pointer}}] \leavevmode
Retrieve current h/w pointer information. Mandatory

\item[{\code{copy}}] \leavevmode
Copy the compressed data to/from userspace, Optional
Can't be implemented if DSP supports mmap

\item[{\code{mmap}}] \leavevmode
DSP mmap method to mmap DSP memory

\item[{\code{ack}}] \leavevmode
Ack for DSP when data is written to audio buffer, Optional
Not valid if copy is implemented

\item[{\code{get\_caps}}] \leavevmode
Retrieve DSP capabilities, mandatory

\item[{\code{get\_codec\_caps}}] \leavevmode
Retrieve capabilities for a specific codec, mandatory

\end{description}
\index{snd\_compr (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_compr}\pysigline{struct \bfcode{snd\_compr}}
\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}compr \PYGZob{}
  const char *name;
  struct device dev;
  struct snd\PYGZus{}compr\PYGZus{}ops *ops;
  void *private\PYGZus{}data;
  struct snd\PYGZus{}card *card;
  unsigned int direction;
  struct mutex lock;
  int device;
\PYGZsh{}ifdef CONFIG\PYGZus{}SND\PYGZus{}VERBOSE\PYGZus{}PROCFS;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{name}}] \leavevmode
DSP device name

\item[{\code{dev}}] \leavevmode
associated device instance

\item[{\code{ops}}] \leavevmode
pointer to DSP callbacks

\item[{\code{private\_data}}] \leavevmode
pointer to DSP pvt data

\item[{\code{card}}] \leavevmode
sound card pointer

\item[{\code{direction}}] \leavevmode
Playback or capture direction

\item[{\code{lock}}] \leavevmode
device lock

\item[{\code{device}}] \leavevmode
device id

\end{description}


\subsection{ASoC}
\label{sound/kernel-api/alsa-driver-api:asoc}

\subsubsection{ASoC Core API}
\label{sound/kernel-api/alsa-driver-api:asoc-core-api}\index{snd\_soc\_jack\_pin (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_jack_pin}\pysigline{struct \bfcode{snd\_soc\_jack\_pin}}
Describes a pin to update based on jack detection

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}soc\PYGZus{}jack\PYGZus{}pin \PYGZob{}
  struct list\PYGZus{}head list;
  const char *pin;
  int mask;
  bool invert;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{list}}] \leavevmode
internal list entry

\item[{\code{pin}}] \leavevmode
name of the pin to update

\item[{\code{mask}}] \leavevmode
bits to check for in reported jack status

\item[{\code{invert}}] \leavevmode
if non-zero then pin is enabled when status is not reported

\end{description}
\index{snd\_soc\_jack\_zone (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_jack_zone}\pysigline{struct \bfcode{snd\_soc\_jack\_zone}}
Describes voltage zones of jack detection

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}soc\PYGZus{}jack\PYGZus{}zone \PYGZob{}
  unsigned int min\PYGZus{}mv;
  unsigned int max\PYGZus{}mv;
  unsigned int jack\PYGZus{}type;
  unsigned int debounce\PYGZus{}time;
  struct list\PYGZus{}head list;
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{min\_mv}}] \leavevmode
start voltage in mv

\item[{\code{max\_mv}}] \leavevmode
end voltage in mv

\item[{\code{jack\_type}}] \leavevmode
type of jack that is expected for this voltage

\item[{\code{debounce\_time}}] \leavevmode
debounce\_time for jack, codec driver should wait for this
duration before reading the adc for voltages

\item[{\code{list}}] \leavevmode
internal list entry

\end{description}
\index{snd\_soc\_jack\_gpio (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_jack_gpio}\pysigline{struct \bfcode{snd\_soc\_jack\_gpio}}
Describes a gpio pin for jack detection

\end{fulllineitems}


\textbf{Definition}

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}soc\PYGZus{}jack\PYGZus{}gpio \PYGZob{}
  unsigned int gpio;
  unsigned int idx;
  struct device *gpiod\PYGZus{}dev;
  const char *name;
  int report;
  int invert;
  int debounce\PYGZus{}time;
  bool wake;
  int (*jack\PYGZus{}status\PYGZus{}check)(void *data);
\PYGZcb{};
\end{Verbatim}

\textbf{Members}
\begin{description}
\item[{\code{gpio}}] \leavevmode
legacy gpio number

\item[{\code{idx}}] \leavevmode
gpio descriptor index within the function of the GPIO
consumer device

\item[{\code{gpiod\_dev}}] \leavevmode
GPIO consumer device

\item[{\code{name}}] \leavevmode
gpio name. Also as connection ID for the GPIO consumer
device function name lookup

\item[{\code{report}}] \leavevmode
value to report when jack detected

\item[{\code{invert}}] \leavevmode
report presence in low state

\item[{\code{debounce\_time}}] \leavevmode
debounce time in ms

\item[{\code{wake}}] \leavevmode
enable as wake source

\item[{\code{jack\_status\_check}}] \leavevmode
callback function which overrides the detection
to provide more complex checks (eg, reading an
ADC).

\end{description}
\index{snd\_soc\_component\_to\_codec (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_component_to_codec}\pysiglinewithargsret{struct snd\_soc\_codec * \bfcode{snd\_soc\_component\_to\_codec}}{struct snd\_soc\_component *\emph{ component}}{}
Casts a component to the CODEC it is embedded in

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
The component to cast to a CODEC

\end{description}

\textbf{Description}

This function must only be used on components that are known to be CODECs.
Otherwise the behavior is undefined.
\index{snd\_soc\_component\_to\_platform (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_component_to_platform}\pysiglinewithargsret{struct snd\_soc\_platform * \bfcode{snd\_soc\_component\_to\_platform}}{struct snd\_soc\_component *\emph{ component}}{}
Casts a component to the platform it is embedded in

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
The component to cast to a platform

\end{description}

\textbf{Description}

This function must only be used on components that are known to be platforms.
Otherwise the behavior is undefined.
\index{snd\_soc\_dapm\_to\_component (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_to_component}\pysiglinewithargsret{struct snd\_soc\_component * \bfcode{snd\_soc\_dapm\_to\_component}}{struct snd\_soc\_dapm\_context *\emph{ dapm}}{}
Casts a DAPM context to the component it is embedded in

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
The DAPM context to cast to the component

\end{description}

\textbf{Description}

This function must only be used on DAPM contexts that are known to be part of
a component (e.g. in a component driver). Otherwise the behavior is
undefined.
\index{snd\_soc\_dapm\_to\_codec (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_to_codec}\pysiglinewithargsret{struct snd\_soc\_codec * \bfcode{snd\_soc\_dapm\_to\_codec}}{struct snd\_soc\_dapm\_context *\emph{ dapm}}{}
Casts a DAPM context to the CODEC it is embedded in

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
The DAPM context to cast to the CODEC

\end{description}

\textbf{Description}

This function must only be used on DAPM contexts that are known to be part of
a CODEC (e.g. in a CODEC driver). Otherwise the behavior is undefined.
\index{snd\_soc\_dapm\_to\_platform (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_to_platform}\pysiglinewithargsret{struct snd\_soc\_platform * \bfcode{snd\_soc\_dapm\_to\_platform}}{struct snd\_soc\_dapm\_context *\emph{ dapm}}{}
Casts a DAPM context to the platform it is embedded in

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
The DAPM context to cast to the platform.

\end{description}

\textbf{Description}

This function must only be used on DAPM contexts that are known to be part of
a platform (e.g. in a platform driver). Otherwise the behavior is undefined.
\index{snd\_soc\_component\_get\_dapm (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_component_get_dapm}\pysiglinewithargsret{struct snd\_soc\_dapm\_context * \bfcode{snd\_soc\_component\_get\_dapm}}{struct snd\_soc\_component *\emph{ component}}{}
Returns the DAPM context associated with a component

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
The component for which to get the DAPM context

\end{description}
\index{snd\_soc\_codec\_get\_dapm (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_codec_get_dapm}\pysiglinewithargsret{struct snd\_soc\_dapm\_context * \bfcode{snd\_soc\_codec\_get\_dapm}}{struct snd\_soc\_codec *\emph{ codec}}{}
Returns the DAPM context for the CODEC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_codec * codec}}] \leavevmode
The CODEC for which to get the DAPM context

\end{description}

\textbf{Note}

Use this function instead of directly accessing the CODEC's dapm field
\index{snd\_soc\_codec\_init\_bias\_level (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_codec_init_bias_level}\pysiglinewithargsret{void \bfcode{snd\_soc\_codec\_init\_bias\_level}}{struct snd\_soc\_codec *\emph{ codec}, enum snd\_soc\_bias\_level\emph{ level}}{}
Initialize CODEC DAPM bias level

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_codec * codec}}] \leavevmode
The CODEC for which to initialize the DAPM bias level

\item[{\code{enum snd\_soc\_bias\_level level}}] \leavevmode
The DAPM level to initialize to

\end{description}

\textbf{Description}

Initializes the CODEC DAPM bias level. See \code{snd\_soc\_dapm\_init\_bias\_level()}.
\index{snd\_soc\_component\_init\_bias\_level (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_component_init_bias_level}\pysiglinewithargsret{void \bfcode{snd\_soc\_component\_init\_bias\_level}}{struct snd\_soc\_component *\emph{ component}, enum snd\_soc\_bias\_level\emph{ level}}{}
Initialize COMPONENT DAPM bias level

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
The COMPONENT for which to initialize the DAPM bias level

\item[{\code{enum snd\_soc\_bias\_level level}}] \leavevmode
The DAPM level to initialize to

\end{description}

\textbf{Description}

Initializes the COMPONENT DAPM bias level. See \code{snd\_soc\_dapm\_init\_bias\_level()}.
\index{snd\_soc\_codec\_get\_bias\_level (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_codec_get_bias_level}\pysiglinewithargsret{enum snd\_soc\_bias\_level \bfcode{snd\_soc\_codec\_get\_bias\_level}}{struct snd\_soc\_codec *\emph{ codec}}{}
Get current CODEC DAPM bias level

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_codec * codec}}] \leavevmode
The CODEC for which to get the DAPM bias level

\end{description}

\textbf{Return}

The current DAPM bias level of the CODEC.
\index{snd\_soc\_component\_get\_bias\_level (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_component_get_bias_level}\pysiglinewithargsret{enum snd\_soc\_bias\_level \bfcode{snd\_soc\_component\_get\_bias\_level}}{struct snd\_soc\_component *\emph{ component}}{}
Get current COMPONENT DAPM bias level

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
The COMPONENT for which to get the DAPM bias level

\end{description}

\textbf{Return}

The current DAPM bias level of the COMPONENT.
\index{snd\_soc\_codec\_force\_bias\_level (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_codec_force_bias_level}\pysiglinewithargsret{int \bfcode{snd\_soc\_codec\_force\_bias\_level}}{struct snd\_soc\_codec *\emph{ codec}, enum snd\_soc\_bias\_level\emph{ level}}{}
Set the CODEC DAPM bias level

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_codec * codec}}] \leavevmode
The CODEC for which to set the level

\item[{\code{enum snd\_soc\_bias\_level level}}] \leavevmode
The level to set to

\end{description}

\textbf{Description}

Forces the CODEC bias level to a specific state. See
{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_dapm_force_bias_level]{\emph{\code{snd\_soc\_dapm\_force\_bias\_level()}}}}.
\index{snd\_soc\_component\_force\_bias\_level (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_component_force_bias_level}\pysiglinewithargsret{int \bfcode{snd\_soc\_component\_force\_bias\_level}}{struct snd\_soc\_component *\emph{ component}, enum snd\_soc\_bias\_level\emph{ level}}{}
Set the COMPONENT DAPM bias level

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
The COMPONENT for which to set the level

\item[{\code{enum snd\_soc\_bias\_level level}}] \leavevmode
The level to set to

\end{description}

\textbf{Description}

Forces the COMPONENT bias level to a specific state. See
{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_dapm_force_bias_level]{\emph{\code{snd\_soc\_dapm\_force\_bias\_level()}}}}.
\index{snd\_soc\_dapm\_kcontrol\_codec (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_kcontrol_codec}\pysiglinewithargsret{struct snd\_soc\_codec * \bfcode{snd\_soc\_dapm\_kcontrol\_codec}}{struct snd\_kcontrol *\emph{ kcontrol}}{}
Returns the codec associated to a kcontrol

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
The kcontrol

\end{description}

\textbf{Description}

This function must only be used on DAPM contexts that are known to be part of
a CODEC (e.g. in a CODEC driver). Otherwise the behavior is undefined.
\index{snd\_soc\_dapm\_kcontrol\_component (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_kcontrol_component}\pysiglinewithargsret{struct snd\_soc\_component * \bfcode{snd\_soc\_dapm\_kcontrol\_component}}{struct snd\_kcontrol *\emph{ kcontrol}}{}
Returns the component associated to a kcontrol

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
The kcontrol

\end{description}

\textbf{Description}

This function must only be used on DAPM contexts that are known to be part of
a COMPONENT (e.g. in a COMPONENT driver). Otherwise the behavior is undefined.
\index{snd\_soc\_cache\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_cache_sync}\pysiglinewithargsret{int \bfcode{snd\_soc\_cache\_sync}}{struct snd\_soc\_codec *\emph{ codec}}{}
Sync the register cache with the hardware

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_codec * codec}}] \leavevmode
CODEC to sync

\end{description}

\textbf{Note}

This function will call \code{regcache\_sync()}
\index{snd\_soc\_component\_cache\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_component_cache_sync}\pysiglinewithargsret{int \bfcode{snd\_soc\_component\_cache\_sync}}{struct snd\_soc\_component *\emph{ component}}{}
Sync the register cache with the hardware

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
COMPONENT to sync

\end{description}

\textbf{Note}

This function will call \code{regcache\_sync()}
\index{snd\_soc\_codec\_init\_regmap (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_codec_init_regmap}\pysiglinewithargsret{void \bfcode{snd\_soc\_codec\_init\_regmap}}{struct snd\_soc\_codec *\emph{ codec}, struct regmap *\emph{ regmap}}{}
Initialize regmap instance for the CODEC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_codec * codec}}] \leavevmode
The CODEC for which to initialize the regmap instance

\item[{\code{struct regmap * regmap}}] \leavevmode
The regmap instance that should be used by the CODEC

\end{description}

\textbf{Description}

This function allows deferred assignment of the regmap instance that is
associated with the CODEC. Only use this if the regmap instance is not yet
ready when the CODEC is registered. The function must also be called before
the first IO attempt of the CODEC.
\index{snd\_soc\_codec\_exit\_regmap (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_codec_exit_regmap}\pysiglinewithargsret{void \bfcode{snd\_soc\_codec\_exit\_regmap}}{struct snd\_soc\_codec *\emph{ codec}}{}
De-initialize regmap instance for the CODEC

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_codec * codec}}] \leavevmode
The CODEC for which to de-initialize the regmap instance

\end{description}

\textbf{Description}

Calls \code{regmap\_exit()} on the regmap instance associated to the CODEC and
removes the regmap instance from the CODEC.

This function should only be used if {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_codec_init_regmap]{\emph{\code{snd\_soc\_codec\_init\_regmap()}}}} was used to
initialize the regmap instance.
\index{snd\_soc\_kcontrol\_component (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_kcontrol_component}\pysiglinewithargsret{struct snd\_soc\_component * \bfcode{snd\_soc\_kcontrol\_component}}{struct snd\_kcontrol *\emph{ kcontrol}}{}
Returns the component that registered the control

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
The control for which to get the component

\end{description}

\textbf{Note}

This function will work correctly if the control has been registered
for a component. Either with {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_add_codec_controls]{\emph{\code{snd\_soc\_add\_codec\_controls()}}}} or
{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_add_platform_controls]{\emph{\code{snd\_soc\_add\_platform\_controls()}}}} or via  table based setup for either a
CODEC, a platform or component driver. Otherwise the behavior is undefined.
\index{snd\_soc\_kcontrol\_codec (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_kcontrol_codec}\pysiglinewithargsret{struct snd\_soc\_codec * \bfcode{snd\_soc\_kcontrol\_codec}}{struct snd\_kcontrol *\emph{ kcontrol}}{}
Returns the CODEC that registered the control

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
The control for which to get the CODEC

\end{description}

\textbf{Note}

This function will only work correctly if the control has been
registered with {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_add_codec_controls]{\emph{\code{snd\_soc\_add\_codec\_controls()}}}} or via table based setup of
snd\_soc\_codec\_driver. Otherwise the behavior is undefined.
\index{snd\_soc\_kcontrol\_platform (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_kcontrol_platform}\pysiglinewithargsret{struct snd\_soc\_platform * \bfcode{snd\_soc\_kcontrol\_platform}}{struct snd\_kcontrol *\emph{ kcontrol}}{}
Returns the platform that registered the control

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
The control for which to get the platform

\end{description}

\textbf{Note}

This function will only work correctly if the control has been
registered with {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_add_platform_controls]{\emph{\code{snd\_soc\_add\_platform\_controls()}}}} or via table based setup of
a snd\_soc\_platform\_driver. Otherwise the behavior is undefined.
\index{snd\_soc\_find\_dai (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_find_dai}\pysiglinewithargsret{struct snd\_soc\_dai * \bfcode{snd\_soc\_find\_dai}}{const struct snd\_soc\_dai\_link\_component *\emph{ dlc}}{}
Find a registered DAI

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_soc\_dai\_link\_component * dlc}}] \leavevmode
name of the DAI or the DAI driver and optional component info to match

\end{description}

\textbf{Description}

This function will search all registered components and their DAIs to
find the DAI of the same name. The component's of\_node and name
should also match if being specified.

\textbf{Return}

pointer of DAI, or NULL if not found.
\index{snd\_soc\_find\_dai\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_find_dai_link}\pysiglinewithargsret{struct snd\_soc\_dai\_link * \bfcode{snd\_soc\_find\_dai\_link}}{struct snd\_soc\_card *\emph{ card}, int\emph{ id}, const char *\emph{ name}, const char *\emph{ stream\_name}}{}
Find a DAI link

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_card * card}}] \leavevmode
soc card

\item[{\code{int id}}] \leavevmode
DAI link ID to match

\item[{\code{const char * name}}] \leavevmode
DAI link name to match, optional

\item[{\code{const char * stream\_name}}] \leavevmode
DAI link stream name to match, optional

\end{description}

\textbf{Description}

This function will search all existing DAI links of the soc card to
find the link of the same ID. Since DAI links may not have their
unique ID, so name and stream name should also match if being
specified.

\textbf{Return}

pointer of DAI link, or NULL if not found.
\index{snd\_soc\_add\_dai\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_add_dai_link}\pysiglinewithargsret{int \bfcode{snd\_soc\_add\_dai\_link}}{struct snd\_soc\_card *\emph{ card}, struct snd\_soc\_dai\_link *\emph{ dai\_link}}{}
Add a DAI link dynamically

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_card * card}}] \leavevmode
The ASoC card to which the DAI link is added

\item[{\code{struct snd\_soc\_dai\_link * dai\_link}}] \leavevmode
The new DAI link to add

\end{description}

\textbf{Description}

This function adds a DAI link to the ASoC card's link list.

\textbf{Note}

Topology can use this API to add DAI links when probing the
topology component. And machine drivers can still define static
DAI links in dai\_link array.
\index{snd\_soc\_remove\_dai\_link (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_remove_dai_link}\pysiglinewithargsret{void \bfcode{snd\_soc\_remove\_dai\_link}}{struct snd\_soc\_card *\emph{ card}, struct snd\_soc\_dai\_link *\emph{ dai\_link}}{}
Remove a DAI link from the list

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_card * card}}] \leavevmode
The ASoC card that owns the link

\item[{\code{struct snd\_soc\_dai\_link * dai\_link}}] \leavevmode
The DAI link to remove

\end{description}

\textbf{Description}

This function removes a DAI link from the ASoC card's link list.

For DAI links previously added by topology, topology should
remove them by using the dobj embedded in the link.
\index{snd\_soc\_runtime\_set\_dai\_fmt (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_runtime_set_dai_fmt}\pysiglinewithargsret{int \bfcode{snd\_soc\_runtime\_set\_dai\_fmt}}{struct snd\_soc\_pcm\_runtime *\emph{ rtd}, unsigned int\emph{ dai\_fmt}}{}
Change DAI link format for a ASoC runtime

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_pcm\_runtime * rtd}}] \leavevmode
The runtime for which the DAI link format should be changed

\item[{\code{unsigned int dai\_fmt}}] \leavevmode
The new DAI link format

\end{description}

\textbf{Description}

This function updates the DAI link format for all DAIs connected to the DAI
link for the specified runtime.

\textbf{Note}

For setups with a static format set the dai\_fmt field in the
corresponding snd\_dai\_link struct instead of using this function.

Returns 0 on success, otherwise a negative error code.
\index{snd\_soc\_set\_dmi\_name (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_set_dmi_name}\pysiglinewithargsret{int \bfcode{snd\_soc\_set\_dmi\_name}}{struct snd\_soc\_card *\emph{ card}, const char *\emph{ flavour}}{}
Register DMI names to card

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_card * card}}] \leavevmode
The card to register DMI names

\item[{\code{const char * flavour}}] \leavevmode
The flavour ``differentiator'' for the card amongst its peers.

\end{description}

\textbf{Description}

An Intel machine driver may be used by many different devices but are
difficult for userspace to differentiate, since machine drivers ususally
use their own name as the card short name and leave the card long name
blank. To differentiate such devices and fix bugs due to lack of
device-specific configurations, this function allows DMI info to be used
as the sound card long name, in the format of
``vendor-product-version-board''
(Character `-` is used to separate different DMI fields here).
This will help the user space to load the device-specific Use Case Manager
(UCM) configurations for the card.

Possible card long names may be:
DellInc.-XPS139343-01-0310JH
ASUSTeKCOMPUTERINC.-T100TA-1.0-T100TA
Circuitco-MinnowboardMaxD0PLATFORM-D0-MinnowBoardMAX

This function also supports flavoring the card longname to provide
the extra differentiation, like ``vendor-product-version-board-flavor''.

We only keep number and alphabet characters and a few separator characters
in the card long name since UCM in the user space uses the card long names
as card configuration directory names and AudoConf cannot support special
charactors like SPACE.

Returns 0 on success, otherwise a negative error code.
\index{snd\_soc\_cnew (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_cnew}\pysiglinewithargsret{struct snd\_kcontrol * \bfcode{snd\_soc\_cnew}}{const struct snd\_kcontrol\_new *\emph{ \_template}, void *\emph{ data}, const char *\emph{ long\_name}, const char *\emph{ prefix}}{}
create new control

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{const struct snd\_kcontrol\_new * \_template}}] \leavevmode
control template

\item[{\code{void * data}}] \leavevmode
control private data

\item[{\code{const char * long\_name}}] \leavevmode
control long name

\item[{\code{const char * prefix}}] \leavevmode
control name prefix

\end{description}

\textbf{Description}

Create a new mixer control from a template control.

Returns 0 for success, else error.
\index{snd\_soc\_add\_component\_controls (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_add_component_controls}\pysiglinewithargsret{int \bfcode{snd\_soc\_add\_component\_controls}}{struct snd\_soc\_component *\emph{ component}, const struct snd\_kcontrol\_new *\emph{ controls}, unsigned int\emph{ num\_controls}}{}
Add an array of controls to a component.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
Component to add controls to

\item[{\code{const struct snd\_kcontrol\_new * controls}}] \leavevmode
Array of controls to add

\item[{\code{unsigned int num\_controls}}] \leavevmode
Number of elements in the array

\end{description}

\textbf{Return}

0 for success, else error.
\index{snd\_soc\_add\_codec\_controls (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_add_codec_controls}\pysiglinewithargsret{int \bfcode{snd\_soc\_add\_codec\_controls}}{struct snd\_soc\_codec *\emph{ codec}, const struct snd\_kcontrol\_new *\emph{ controls}, unsigned int\emph{ num\_controls}}{}
add an array of controls to a codec. Convenience function to add a list of controls. Many codecs were duplicating this code.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_codec * codec}}] \leavevmode
codec to add controls to

\item[{\code{const struct snd\_kcontrol\_new * controls}}] \leavevmode
array of controls to add

\item[{\code{unsigned int num\_controls}}] \leavevmode
number of elements in the array

\end{description}

\textbf{Description}

Return 0 for success, else error.
\index{snd\_soc\_add\_platform\_controls (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_add_platform_controls}\pysiglinewithargsret{int \bfcode{snd\_soc\_add\_platform\_controls}}{struct snd\_soc\_platform *\emph{ platform}, const struct snd\_kcontrol\_new *\emph{ controls}, unsigned int\emph{ num\_controls}}{}
add an array of controls to a platform. Convenience function to add a list of controls.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_platform * platform}}] \leavevmode
platform to add controls to

\item[{\code{const struct snd\_kcontrol\_new * controls}}] \leavevmode
array of controls to add

\item[{\code{unsigned int num\_controls}}] \leavevmode
number of elements in the array

\end{description}

\textbf{Description}

Return 0 for success, else error.
\index{snd\_soc\_add\_card\_controls (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_add_card_controls}\pysiglinewithargsret{int \bfcode{snd\_soc\_add\_card\_controls}}{struct snd\_soc\_card *\emph{ soc\_card}, const struct snd\_kcontrol\_new *\emph{ controls}, int\emph{ num\_controls}}{}
add an array of controls to a SoC card. Convenience function to add a list of controls.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_card * soc\_card}}] \leavevmode
SoC card to add controls to

\item[{\code{const struct snd\_kcontrol\_new * controls}}] \leavevmode
array of controls to add

\item[{\code{int num\_controls}}] \leavevmode
number of elements in the array

\end{description}

\textbf{Description}

Return 0 for success, else error.
\index{snd\_soc\_add\_dai\_controls (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_add_dai_controls}\pysiglinewithargsret{int \bfcode{snd\_soc\_add\_dai\_controls}}{struct snd\_soc\_dai *\emph{ dai}, const struct snd\_kcontrol\_new *\emph{ controls}, int\emph{ num\_controls}}{}
add an array of controls to a DAI. Convienience function to add a list of controls.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dai * dai}}] \leavevmode
DAI to add controls to

\item[{\code{const struct snd\_kcontrol\_new * controls}}] \leavevmode
array of controls to add

\item[{\code{int num\_controls}}] \leavevmode
number of elements in the array

\end{description}

\textbf{Description}

Return 0 for success, else error.
\index{snd\_soc\_dai\_set\_sysclk (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dai_set_sysclk}\pysiglinewithargsret{int \bfcode{snd\_soc\_dai\_set\_sysclk}}{struct snd\_soc\_dai *\emph{ dai}, int\emph{ clk\_id}, unsigned int\emph{ freq}, int\emph{ dir}}{}
configure DAI system or master clock.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dai * dai}}] \leavevmode
DAI

\item[{\code{int clk\_id}}] \leavevmode
DAI specific clock ID

\item[{\code{unsigned int freq}}] \leavevmode
new clock frequency in Hz

\item[{\code{int dir}}] \leavevmode
new clock direction - input/output.

\end{description}

\textbf{Description}

Configures the DAI master (MCLK) or system (SYSCLK) clocking.
\index{snd\_soc\_codec\_set\_sysclk (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_codec_set_sysclk}\pysiglinewithargsret{int \bfcode{snd\_soc\_codec\_set\_sysclk}}{struct snd\_soc\_codec *\emph{ codec}, int\emph{ clk\_id}, int\emph{ source}, unsigned int\emph{ freq}, int\emph{ dir}}{}
configure CODEC system or master clock.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_codec * codec}}] \leavevmode
CODEC

\item[{\code{int clk\_id}}] \leavevmode
DAI specific clock ID

\item[{\code{int source}}] \leavevmode
Source for the clock

\item[{\code{unsigned int freq}}] \leavevmode
new clock frequency in Hz

\item[{\code{int dir}}] \leavevmode
new clock direction - input/output.

\end{description}

\textbf{Description}

Configures the CODEC master (MCLK) or system (SYSCLK) clocking.
\index{snd\_soc\_component\_set\_sysclk (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_component_set_sysclk}\pysiglinewithargsret{int \bfcode{snd\_soc\_component\_set\_sysclk}}{struct snd\_soc\_component *\emph{ component}, int\emph{ clk\_id}, int\emph{ source}, unsigned int\emph{ freq}, int\emph{ dir}}{}
configure COMPONENT system or master clock.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
COMPONENT

\item[{\code{int clk\_id}}] \leavevmode
DAI specific clock ID

\item[{\code{int source}}] \leavevmode
Source for the clock

\item[{\code{unsigned int freq}}] \leavevmode
new clock frequency in Hz

\item[{\code{int dir}}] \leavevmode
new clock direction - input/output.

\end{description}

\textbf{Description}

Configures the CODEC master (MCLK) or system (SYSCLK) clocking.
\index{snd\_soc\_dai\_set\_clkdiv (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dai_set_clkdiv}\pysiglinewithargsret{int \bfcode{snd\_soc\_dai\_set\_clkdiv}}{struct snd\_soc\_dai *\emph{ dai}, int\emph{ div\_id}, int\emph{ div}}{}
configure DAI clock dividers.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dai * dai}}] \leavevmode
DAI

\item[{\code{int div\_id}}] \leavevmode
DAI specific clock divider ID

\item[{\code{int div}}] \leavevmode
new clock divisor.

\end{description}

\textbf{Description}

Configures the clock dividers. This is used to derive the best DAI bit and
frame clocks from the system or master clock. It's best to set the DAI bit
and frame clocks as low as possible to save system power.
\index{snd\_soc\_dai\_set\_pll (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dai_set_pll}\pysiglinewithargsret{int \bfcode{snd\_soc\_dai\_set\_pll}}{struct snd\_soc\_dai *\emph{ dai}, int\emph{ pll\_id}, int\emph{ source}, unsigned int\emph{ freq\_in}, unsigned int\emph{ freq\_out}}{}
configure DAI PLL.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dai * dai}}] \leavevmode
DAI

\item[{\code{int pll\_id}}] \leavevmode
DAI specific PLL ID

\item[{\code{int source}}] \leavevmode
DAI specific source for the PLL

\item[{\code{unsigned int freq\_in}}] \leavevmode
PLL input clock frequency in Hz

\item[{\code{unsigned int freq\_out}}] \leavevmode
requested PLL output clock frequency in Hz

\end{description}

\textbf{Description}

Configures and enables PLL to generate output clock based on input clock.
\index{snd\_soc\_dai\_set\_bclk\_ratio (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dai_set_bclk_ratio}\pysiglinewithargsret{int \bfcode{snd\_soc\_dai\_set\_bclk\_ratio}}{struct snd\_soc\_dai *\emph{ dai}, unsigned int\emph{ ratio}}{}
configure BCLK to sample rate ratio.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dai * dai}}] \leavevmode
DAI

\item[{\code{unsigned int ratio}}] \leavevmode
Ratio of BCLK to Sample rate.

\end{description}

\textbf{Description}

Configures the DAI for a preset BCLK to sample rate ratio.
\index{snd\_soc\_dai\_set\_fmt (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dai_set_fmt}\pysiglinewithargsret{int \bfcode{snd\_soc\_dai\_set\_fmt}}{struct snd\_soc\_dai *\emph{ dai}, unsigned int\emph{ fmt}}{}
configure DAI hardware audio format.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dai * dai}}] \leavevmode
DAI

\item[{\code{unsigned int fmt}}] \leavevmode
SND\_SOC\_DAIFMT\_* format value.

\end{description}

\textbf{Description}

Configures the DAI hardware format and clocking.
\index{snd\_soc\_xlate\_tdm\_slot\_mask (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_xlate_tdm_slot_mask}\pysiglinewithargsret{int \bfcode{snd\_soc\_xlate\_tdm\_slot\_mask}}{unsigned int\emph{ slots}, unsigned int *\emph{ tx\_mask}, unsigned int *\emph{ rx\_mask}}{}
generate tx/rx slot mask.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned int slots}}] \leavevmode
Number of slots in use.

\item[{\code{unsigned int * tx\_mask}}] \leavevmode
bitmask representing active TX slots.

\item[{\code{unsigned int * rx\_mask}}] \leavevmode
bitmask representing active RX slots.

\end{description}

\textbf{Description}

Generates the TDM tx and rx slot default masks for DAI.
\index{snd\_soc\_dai\_set\_tdm\_slot (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dai_set_tdm_slot}\pysiglinewithargsret{int \bfcode{snd\_soc\_dai\_set\_tdm\_slot}}{struct snd\_soc\_dai *\emph{ dai}, unsigned int\emph{ tx\_mask}, unsigned int\emph{ rx\_mask}, int\emph{ slots}, int\emph{ slot\_width}}{}
Configures a DAI for TDM operation

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dai * dai}}] \leavevmode
The DAI to configure

\item[{\code{unsigned int tx\_mask}}] \leavevmode
bitmask representing active TX slots.

\item[{\code{unsigned int rx\_mask}}] \leavevmode
bitmask representing active RX slots.

\item[{\code{int slots}}] \leavevmode
Number of slots in use.

\item[{\code{int slot\_width}}] \leavevmode
Width in bits for each slot.

\end{description}

\textbf{Description}

This function configures the specified DAI for TDM operation. \textbf{slot} contains
the total number of slots of the TDM stream and \textbf{slot\_with} the width of each
slot in bit clock cycles. \textbf{tx\_mask} and \textbf{rx\_mask} are bitmasks specifying the
active slots of the TDM stream for the specified DAI, i.e. which slots the
DAI should write to or read from. If a bit is set the corresponding slot is
active, if a bit is cleared the corresponding slot is inactive. Bit 0 maps to
the first slot, bit 1 to the second slot and so on. The first active slot
maps to the first channel of the DAI, the second active slot to the second
channel and so on.

TDM mode can be disabled by passing 0 for \textbf{slots}. In this case \textbf{tx\_mask},
\textbf{rx\_mask} and \textbf{slot\_width} will be ignored.

Returns 0 on success, a negative error code otherwise.
\index{snd\_soc\_dai\_set\_channel\_map (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dai_set_channel_map}\pysiglinewithargsret{int \bfcode{snd\_soc\_dai\_set\_channel\_map}}{struct snd\_soc\_dai *\emph{ dai}, unsigned int\emph{ tx\_num}, unsigned int *\emph{ tx\_slot}, unsigned int\emph{ rx\_num}, unsigned int *\emph{ rx\_slot}}{}
configure DAI audio channel map

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dai * dai}}] \leavevmode
DAI

\item[{\code{unsigned int tx\_num}}] \leavevmode
how many TX channels

\item[{\code{unsigned int * tx\_slot}}] \leavevmode
pointer to an array which imply the TX slot number channel
0\textasciitilde{}num-1 uses

\item[{\code{unsigned int rx\_num}}] \leavevmode
how many RX channels

\item[{\code{unsigned int * rx\_slot}}] \leavevmode
pointer to an array which imply the RX slot number channel
0\textasciitilde{}num-1 uses

\end{description}

\textbf{Description}

configure the relationship between channel number and TDM slot number.
\index{snd\_soc\_dai\_set\_tristate (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dai_set_tristate}\pysiglinewithargsret{int \bfcode{snd\_soc\_dai\_set\_tristate}}{struct snd\_soc\_dai *\emph{ dai}, int\emph{ tristate}}{}
configure DAI system or master clock.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dai * dai}}] \leavevmode
DAI

\item[{\code{int tristate}}] \leavevmode
tristate enable

\end{description}

\textbf{Description}

Tristates the DAI so that others can use it.
\index{snd\_soc\_dai\_digital\_mute (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dai_digital_mute}\pysiglinewithargsret{int \bfcode{snd\_soc\_dai\_digital\_mute}}{struct snd\_soc\_dai *\emph{ dai}, int\emph{ mute}, int\emph{ direction}}{}
configure DAI system or master clock.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dai * dai}}] \leavevmode
DAI

\item[{\code{int mute}}] \leavevmode
mute enable

\item[{\code{int direction}}] \leavevmode
stream to mute

\end{description}

\textbf{Description}

Mutes the DAI DAC.
\index{snd\_soc\_register\_card (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_register_card}\pysiglinewithargsret{int \bfcode{snd\_soc\_register\_card}}{struct snd\_soc\_card *\emph{ card}}{}
Register a card with the ASoC core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_card * card}}] \leavevmode
Card to register

\end{description}
\index{snd\_soc\_unregister\_card (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_unregister_card}\pysiglinewithargsret{int \bfcode{snd\_soc\_unregister\_card}}{struct snd\_soc\_card *\emph{ card}}{}
Unregister a card with the ASoC core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_card * card}}] \leavevmode
Card to unregister

\end{description}
\index{snd\_soc\_unregister\_dais (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_unregister_dais}\pysiglinewithargsret{void \bfcode{snd\_soc\_unregister\_dais}}{struct snd\_soc\_component *\emph{ component}}{}
Unregister DAIs from the ASoC core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
The component for which the DAIs should be unregistered

\end{description}
\index{snd\_soc\_register\_dais (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_register_dais}\pysiglinewithargsret{int \bfcode{snd\_soc\_register\_dais}}{struct snd\_soc\_component *\emph{ component}, struct snd\_soc\_dai\_driver *\emph{ dai\_drv}, size\_t\emph{ count}, bool\emph{ legacy\_dai\_naming}}{}
Register a DAI with the ASoC core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
The component the DAIs are registered for

\item[{\code{struct snd\_soc\_dai\_driver * dai\_drv}}] \leavevmode
DAI driver to use for the DAIs

\item[{\code{size\_t count}}] \leavevmode
Number of DAIs

\item[{\code{bool legacy\_dai\_naming}}] \leavevmode
Use the legacy naming scheme and let the DAI inherit the
parent's name.

\end{description}
\index{snd\_soc\_register\_dai (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_register_dai}\pysiglinewithargsret{int \bfcode{snd\_soc\_register\_dai}}{struct snd\_soc\_component *\emph{ component}, struct snd\_soc\_dai\_driver *\emph{ dai\_drv}}{}
Register a DAI dynamically \& create its widgets

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
The component the DAIs are registered for

\item[{\code{struct snd\_soc\_dai\_driver * dai\_drv}}] \leavevmode
DAI driver to use for the DAI

\end{description}

\textbf{Description}

Topology can use this API to register DAIs when probing a component.
These DAIs's widgets will be freed in the card cleanup and the DAIs
will be freed in the component cleanup.
\index{snd\_soc\_component\_init\_regmap (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_component_init_regmap}\pysiglinewithargsret{void \bfcode{snd\_soc\_component\_init\_regmap}}{struct snd\_soc\_component *\emph{ component}, struct regmap *\emph{ regmap}}{}
Initialize regmap instance for the component

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
The component for which to initialize the regmap instance

\item[{\code{struct regmap * regmap}}] \leavevmode
The regmap instance that should be used by the component

\end{description}

\textbf{Description}

This function allows deferred assignment of the regmap instance that is
associated with the component. Only use this if the regmap instance is not
yet ready when the component is registered. The function must also be called
before the first IO attempt of the component.
\index{snd\_soc\_component\_exit\_regmap (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_component_exit_regmap}\pysiglinewithargsret{void \bfcode{snd\_soc\_component\_exit\_regmap}}{struct snd\_soc\_component *\emph{ component}}{}
De-initialize regmap instance for the component

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
The component for which to de-initialize the regmap instance

\end{description}

\textbf{Description}

Calls \code{regmap\_exit()} on the regmap instance associated to the component and
removes the regmap instance from the component.

This function should only be used if {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_component_init_regmap]{\emph{\code{snd\_soc\_component\_init\_regmap()}}}} was used
to initialize the regmap instance.
\index{\_\_snd\_soc\_unregister\_component (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.__snd_soc_unregister_component}\pysiglinewithargsret{int \bfcode{\_\_snd\_soc\_unregister\_component}}{struct device *\emph{ dev}}{}
Unregister all related component from the ASoC core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
The device to unregister

\end{description}
\index{snd\_soc\_add\_platform (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_add_platform}\pysiglinewithargsret{int \bfcode{snd\_soc\_add\_platform}}{struct device *\emph{ dev}, struct snd\_soc\_platform *\emph{ platform}, const struct snd\_soc\_platform\_driver *\emph{ platform\_drv}}{}
Add a platform to the ASoC core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
The parent device for the platform

\item[{\code{struct snd\_soc\_platform * platform}}] \leavevmode
The platform to add

\item[{\code{const struct snd\_soc\_platform\_driver * platform\_drv}}] \leavevmode
The driver for the platform

\end{description}
\index{snd\_soc\_register\_platform (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_register_platform}\pysiglinewithargsret{int \bfcode{snd\_soc\_register\_platform}}{struct device *\emph{ dev}, const struct snd\_soc\_platform\_driver *\emph{ platform\_drv}}{}
Register a platform with the ASoC core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
The device for the platform

\item[{\code{const struct snd\_soc\_platform\_driver * platform\_drv}}] \leavevmode
The driver for the platform

\end{description}
\index{snd\_soc\_remove\_platform (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_remove_platform}\pysiglinewithargsret{void \bfcode{snd\_soc\_remove\_platform}}{struct snd\_soc\_platform *\emph{ platform}}{}
Remove a platform from the ASoC core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_platform * platform}}] \leavevmode
the platform to remove

\end{description}
\index{snd\_soc\_unregister\_platform (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_unregister_platform}\pysiglinewithargsret{void \bfcode{snd\_soc\_unregister\_platform}}{struct device *\emph{ dev}}{}
Unregister a platform from the ASoC core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
platform to unregister

\end{description}
\index{snd\_soc\_register\_codec (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_register_codec}\pysiglinewithargsret{int \bfcode{snd\_soc\_register\_codec}}{struct device *\emph{ dev}, const struct snd\_soc\_codec\_driver *\emph{ codec\_drv}, struct snd\_soc\_dai\_driver *\emph{ dai\_drv}, int\emph{ num\_dai}}{}
Register a codec with the ASoC core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
The parent device for this codec

\item[{\code{const struct snd\_soc\_codec\_driver * codec\_drv}}] \leavevmode
Codec driver

\item[{\code{struct snd\_soc\_dai\_driver * dai\_drv}}] \leavevmode
The associated DAI driver

\item[{\code{int num\_dai}}] \leavevmode
Number of DAIs

\end{description}
\index{snd\_soc\_unregister\_codec (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_unregister_codec}\pysiglinewithargsret{void \bfcode{snd\_soc\_unregister\_codec}}{struct device *\emph{ dev}}{}
Unregister a codec from the ASoC core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
codec to unregister

\end{description}
\index{devm\_snd\_soc\_register\_component (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.devm_snd_soc_register_component}\pysiglinewithargsret{int \bfcode{devm\_snd\_soc\_register\_component}}{struct device *\emph{ dev}, const struct snd\_soc\_component\_driver *\emph{ cmpnt\_drv}, struct snd\_soc\_dai\_driver *\emph{ dai\_drv}, int\emph{ num\_dai}}{}
resource managed component registration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device used to manage component

\item[{\code{const struct snd\_soc\_component\_driver * cmpnt\_drv}}] \leavevmode
Component driver

\item[{\code{struct snd\_soc\_dai\_driver * dai\_drv}}] \leavevmode
DAI driver

\item[{\code{int num\_dai}}] \leavevmode
Number of DAIs to register

\end{description}

\textbf{Description}

Register a component with automatic unregistration when the device is
unregistered.
\index{devm\_snd\_soc\_register\_platform (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.devm_snd_soc_register_platform}\pysiglinewithargsret{int \bfcode{devm\_snd\_soc\_register\_platform}}{struct device *\emph{ dev}, const struct snd\_soc\_platform\_driver *\emph{ platform\_drv}}{}
resource managed platform registration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device used to manage platform

\item[{\code{const struct snd\_soc\_platform\_driver * platform\_drv}}] \leavevmode
platform to register

\end{description}

\textbf{Description}

Register a platform driver with automatic unregistration when the device is
unregistered.
\index{devm\_snd\_soc\_register\_card (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.devm_snd_soc_register_card}\pysiglinewithargsret{int \bfcode{devm\_snd\_soc\_register\_card}}{struct device *\emph{ dev}, struct snd\_soc\_card *\emph{ card}}{}
resource managed card registration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Device used to manage card

\item[{\code{struct snd\_soc\_card * card}}] \leavevmode
Card to register

\end{description}

\textbf{Description}

Register a card with automatic unregistration when the device is
unregistered.
\index{devm\_snd\_dmaengine\_pcm\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.devm_snd_dmaengine_pcm_register}\pysiglinewithargsret{int \bfcode{devm\_snd\_dmaengine\_pcm\_register}}{struct device *\emph{ dev}, const struct {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_dmaengine_pcm_config]{\emph{snd\_dmaengine\_pcm\_config}}} *\emph{ config}, unsigned int\emph{ flags}}{}
resource managed dmaengine PCM registration

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
The parent device for the PCM device

\item[{\code{const struct snd\_dmaengine\_pcm\_config * config}}] \leavevmode
Platform specific PCM configuration

\item[{\code{unsigned int flags}}] \leavevmode
Platform specific quirks

\end{description}

\textbf{Description}

Register a dmaengine based PCM device with automatic unregistration when the
device is unregistered.
\index{snd\_soc\_component\_read (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_component_read}\pysiglinewithargsret{int \bfcode{snd\_soc\_component\_read}}{struct snd\_soc\_component *\emph{ component}, unsigned int\emph{ reg}, unsigned int *\emph{ val}}{}
Read register value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
Component to read from

\item[{\code{unsigned int reg}}] \leavevmode
Register to read

\item[{\code{unsigned int * val}}] \leavevmode
Pointer to where the read value is stored

\end{description}

\textbf{Return}

0 on success, a negative error code otherwise.
\index{snd\_soc\_component\_write (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_component_write}\pysiglinewithargsret{int \bfcode{snd\_soc\_component\_write}}{struct snd\_soc\_component *\emph{ component}, unsigned int\emph{ reg}, unsigned int\emph{ val}}{}
Write register value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
Component to write to

\item[{\code{unsigned int reg}}] \leavevmode
Register to write

\item[{\code{unsigned int val}}] \leavevmode
Value to write to the register

\end{description}

\textbf{Return}

0 on success, a negative error code otherwise.
\index{snd\_soc\_component\_update\_bits (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_component_update_bits}\pysiglinewithargsret{int \bfcode{snd\_soc\_component\_update\_bits}}{struct snd\_soc\_component *\emph{ component}, unsigned int\emph{ reg}, unsigned int\emph{ mask}, unsigned int\emph{ val}}{}
Perform read/modify/write cycle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
Component to update

\item[{\code{unsigned int reg}}] \leavevmode
Register to update

\item[{\code{unsigned int mask}}] \leavevmode
Mask that specifies which bits to update

\item[{\code{unsigned int val}}] \leavevmode
New value for the bits specified by mask

\end{description}

\textbf{Return}

1 if the operation was successful and the value of the register
changed, 0 if the operation was successful, but the value did not change.
Returns a negative error code otherwise.
\index{snd\_soc\_component\_update\_bits\_async (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_component_update_bits_async}\pysiglinewithargsret{int \bfcode{snd\_soc\_component\_update\_bits\_async}}{struct snd\_soc\_component *\emph{ component}, unsigned int\emph{ reg}, unsigned int\emph{ mask}, unsigned int\emph{ val}}{}
Perform asynchronous read/modify/write cycle

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
Component to update

\item[{\code{unsigned int reg}}] \leavevmode
Register to update

\item[{\code{unsigned int mask}}] \leavevmode
Mask that specifies which bits to update

\item[{\code{unsigned int val}}] \leavevmode
New value for the bits specified by mask

\end{description}

\textbf{Description}

This function is similar to {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_component_update_bits]{\emph{\code{snd\_soc\_component\_update\_bits()}}}}, but the update
operation is scheduled asynchronously. This means it may not be completed
when the function returns. To make sure that all scheduled updates have been
completed {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_component_async_complete]{\emph{\code{snd\_soc\_component\_async\_complete()}}}} must be called.

\textbf{Return}

1 if the operation was successful and the value of the register
changed, 0 if the operation was successful, but the value did not change.
Returns a negative error code otherwise.
\index{snd\_soc\_component\_async\_complete (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_component_async_complete}\pysiglinewithargsret{void \bfcode{snd\_soc\_component\_async\_complete}}{struct snd\_soc\_component *\emph{ component}}{}
Ensure asynchronous I/O has completed

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
Component for which to wait

\end{description}

\textbf{Description}

This function blocks until all asynchronous I/O which has previously been
scheduled using {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_component_update_bits_async]{\emph{\code{snd\_soc\_component\_update\_bits\_async()}}}} has completed.
\index{snd\_soc\_component\_test\_bits (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_component_test_bits}\pysiglinewithargsret{int \bfcode{snd\_soc\_component\_test\_bits}}{struct snd\_soc\_component *\emph{ component}, unsigned int\emph{ reg}, unsigned int\emph{ mask}, unsigned int\emph{ value}}{}
Test register for change

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
component

\item[{\code{unsigned int reg}}] \leavevmode
Register to test

\item[{\code{unsigned int mask}}] \leavevmode
Mask that specifies which bits to test

\item[{\code{unsigned int value}}] \leavevmode
Value to test against

\end{description}

\textbf{Description}

Tests a register with a new value and checks if the new value is
different from the old value.

\textbf{Return}

1 for change, otherwise 0.
\index{snd\_soc\_update\_bits (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_update_bits}\pysiglinewithargsret{int \bfcode{snd\_soc\_update\_bits}}{struct snd\_soc\_codec *\emph{ codec}, unsigned int\emph{ reg}, unsigned int\emph{ mask}, unsigned int\emph{ value}}{}
update codec register bits

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_codec * codec}}] \leavevmode
audio codec

\item[{\code{unsigned int reg}}] \leavevmode
codec register

\item[{\code{unsigned int mask}}] \leavevmode
register mask

\item[{\code{unsigned int value}}] \leavevmode
new value

\end{description}

\textbf{Description}

Writes new register value.

Returns 1 for change, 0 for no change, or negative error code.
\index{snd\_soc\_test\_bits (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_test_bits}\pysiglinewithargsret{int \bfcode{snd\_soc\_test\_bits}}{struct snd\_soc\_codec *\emph{ codec}, unsigned int\emph{ reg}, unsigned int\emph{ mask}, unsigned int\emph{ value}}{}
test register for change

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_codec * codec}}] \leavevmode
audio codec

\item[{\code{unsigned int reg}}] \leavevmode
codec register

\item[{\code{unsigned int mask}}] \leavevmode
register mask

\item[{\code{unsigned int value}}] \leavevmode
new value

\end{description}

\textbf{Description}

Tests a register with a new value and checks if the new value is
different from the old value.

Returns 1 for change else 0.
\index{snd\_soc\_runtime\_activate (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_runtime_activate}\pysiglinewithargsret{void \bfcode{snd\_soc\_runtime\_activate}}{struct snd\_soc\_pcm\_runtime *\emph{ rtd}, int\emph{ stream}}{}
Increment active count for PCM runtime components

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_pcm\_runtime * rtd}}] \leavevmode
ASoC PCM runtime that is activated

\item[{\code{int stream}}] \leavevmode
Direction of the PCM stream

\end{description}

\textbf{Description}

Increments the active count for all the DAIs and components attached to a PCM
runtime. Should typically be called when a stream is opened.

Must be called with the rtd-\textgreater{}pcm\_mutex being held
\index{snd\_soc\_runtime\_deactivate (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_runtime_deactivate}\pysiglinewithargsret{void \bfcode{snd\_soc\_runtime\_deactivate}}{struct snd\_soc\_pcm\_runtime *\emph{ rtd}, int\emph{ stream}}{}
Decrement active count for PCM runtime components

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_pcm\_runtime * rtd}}] \leavevmode
ASoC PCM runtime that is deactivated

\item[{\code{int stream}}] \leavevmode
Direction of the PCM stream

\end{description}

\textbf{Description}

Decrements the active count for all the DAIs and components attached to a PCM
runtime. Should typically be called when a stream is closed.

Must be called with the rtd-\textgreater{}pcm\_mutex being held
\index{snd\_soc\_runtime\_ignore\_pmdown\_time (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_runtime_ignore_pmdown_time}\pysiglinewithargsret{bool \bfcode{snd\_soc\_runtime\_ignore\_pmdown\_time}}{struct snd\_soc\_pcm\_runtime *\emph{ rtd}}{}
Check whether to ignore the power down delay

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_pcm\_runtime * rtd}}] \leavevmode
The ASoC PCM runtime that should be checked.

\end{description}

\textbf{Description}

This function checks whether the power down delay should be ignored for a
specific PCM runtime. Returns true if the delay is 0, if it the DAI link has
been configured to ignore the delay, or if none of the components benefits
from having the delay.
\index{snd\_soc\_set\_runtime\_hwparams (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_set_runtime_hwparams}\pysiglinewithargsret{int \bfcode{snd\_soc\_set\_runtime\_hwparams}}{struct snd\_pcm\_substream *\emph{ substream}, const struct snd\_pcm\_hardware *\emph{ hw}}{}
set the runtime hardware parameters

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
the pcm substream

\item[{\code{const struct snd\_pcm\_hardware * hw}}] \leavevmode
the hardware parameters

\end{description}

\textbf{Description}

Sets the substream runtime hardware parameters.
\index{snd\_soc\_info\_enum\_double (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_info_enum_double}\pysiglinewithargsret{int \bfcode{snd\_soc\_info\_enum\_double}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_info *\emph{ uinfo}}{}
enumerated double mixer info callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_info * uinfo}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to provide information about a double enumerated
mixer control.

Returns 0 for success.
\index{snd\_soc\_get\_enum\_double (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_get_enum_double}\pysiglinewithargsret{int \bfcode{snd\_soc\_get\_enum\_double}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
enumerated double mixer get callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to get the value of a double enumerated mixer.

Returns 0 for success.
\index{snd\_soc\_put\_enum\_double (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_put_enum_double}\pysiglinewithargsret{int \bfcode{snd\_soc\_put\_enum\_double}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
enumerated double mixer put callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to set the value of a double enumerated mixer.

Returns 0 for success.
\index{snd\_soc\_read\_signed (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_read_signed}\pysiglinewithargsret{int \bfcode{snd\_soc\_read\_signed}}{struct snd\_soc\_component *\emph{ component}, unsigned int\emph{ reg}, unsigned int\emph{ mask}, unsigned int\emph{ shift}, unsigned int\emph{ sign\_bit}, int *\emph{ signed\_val}}{}
Read a codec register and interpret as signed value

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
component

\item[{\code{unsigned int reg}}] \leavevmode
Register to read

\item[{\code{unsigned int mask}}] \leavevmode
Mask to use after shifting the register value

\item[{\code{unsigned int shift}}] \leavevmode
Right shift of register value

\item[{\code{unsigned int sign\_bit}}] \leavevmode
Bit that describes if a number is negative or not.

\item[{\code{int * signed\_val}}] \leavevmode
Pointer to where the read value should be stored

\end{description}

\textbf{Description}

This functions reads a codec register. The register value is shifted right
by `shift' bits and masked with the given `mask'. Afterwards it translates
the given registervalue into a signed integer if sign\_bit is non-zero.

Returns 0 on sucess, otherwise an error value
\index{snd\_soc\_info\_volsw (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_info_volsw}\pysiglinewithargsret{int \bfcode{snd\_soc\_info\_volsw}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_info *\emph{ uinfo}}{}
single mixer info callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_info * uinfo}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to provide information about a single mixer control, or a double
mixer control that spans 2 registers.

Returns 0 for success.
\index{snd\_soc\_info\_volsw\_sx (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_info_volsw_sx}\pysiglinewithargsret{int \bfcode{snd\_soc\_info\_volsw\_sx}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_info *\emph{ uinfo}}{}
Mixer info callback for SX TLV controls

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_info * uinfo}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to provide information about a single mixer control, or a double
mixer control that spans 2 registers of the SX TLV type. SX TLV controls
have a range that represents both positive and negative values either side
of zero but without a sign bit.

Returns 0 for success.
\index{snd\_soc\_get\_volsw (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_get_volsw}\pysiglinewithargsret{int \bfcode{snd\_soc\_get\_volsw}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
single mixer get callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to get the value of a single mixer control, or a double mixer
control that spans 2 registers.

Returns 0 for success.
\index{snd\_soc\_put\_volsw (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_put_volsw}\pysiglinewithargsret{int \bfcode{snd\_soc\_put\_volsw}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
single mixer put callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to set the value of a single mixer control, or a double mixer
control that spans 2 registers.

Returns 0 for success.
\index{snd\_soc\_get\_volsw\_sx (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_get_volsw_sx}\pysiglinewithargsret{int \bfcode{snd\_soc\_get\_volsw\_sx}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
single mixer get callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to get the value of a single mixer control, or a double mixer
control that spans 2 registers.

Returns 0 for success.
\index{snd\_soc\_put\_volsw\_sx (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_put_volsw_sx}\pysiglinewithargsret{int \bfcode{snd\_soc\_put\_volsw\_sx}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
double mixer set callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to set the value of a double mixer control that spans 2 registers.

Returns 0 for success.
\index{snd\_soc\_info\_volsw\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_info_volsw_range}\pysiglinewithargsret{int \bfcode{snd\_soc\_info\_volsw\_range}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_info *\emph{ uinfo}}{}
single mixer info callback with range.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_info * uinfo}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to provide information, within a range, about a single
mixer control.

returns 0 for success.
\index{snd\_soc\_put\_volsw\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_put_volsw_range}\pysiglinewithargsret{int \bfcode{snd\_soc\_put\_volsw\_range}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
single mixer put value callback with range.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to set the value, within a range, for a single mixer control.

Returns 0 for success.
\index{snd\_soc\_get\_volsw\_range (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_get_volsw_range}\pysiglinewithargsret{int \bfcode{snd\_soc\_get\_volsw\_range}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
single mixer get callback with range

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to get the value, within a range, of a single mixer control.

Returns 0 for success.
\index{snd\_soc\_limit\_volume (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_limit_volume}\pysiglinewithargsret{int \bfcode{snd\_soc\_limit\_volume}}{struct snd\_soc\_card *\emph{ card}, const char *\emph{ name}, int\emph{ max}}{}
Set new limit to an existing volume control.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_card * card}}] \leavevmode
where to look for the control

\item[{\code{const char * name}}] \leavevmode
Name of the control

\item[{\code{int max}}] \leavevmode
new maximum limit

\end{description}

\textbf{Description}

Return 0 for success, else error.
\index{snd\_soc\_info\_xr\_sx (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_info_xr_sx}\pysiglinewithargsret{int \bfcode{snd\_soc\_info\_xr\_sx}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_info *\emph{ uinfo}}{}
signed multi register info callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mreg control

\item[{\code{struct snd\_ctl\_elem\_info * uinfo}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to provide information of a control that can
span multiple codec registers which together
forms a single signed value in a MSB/LSB manner.

Returns 0 for success.
\index{snd\_soc\_get\_xr\_sx (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_get_xr_sx}\pysiglinewithargsret{int \bfcode{snd\_soc\_get\_xr\_sx}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
signed multi register get callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mreg control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to get the value of a control that can span
multiple codec registers which together forms a single
signed value in a MSB/LSB manner. The control supports
specifying total no of bits used to allow for bitfields
across the multiple codec registers.

Returns 0 for success.
\index{snd\_soc\_put\_xr\_sx (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_put_xr_sx}\pysiglinewithargsret{int \bfcode{snd\_soc\_put\_xr\_sx}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
signed multi register get callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mreg control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to set the value of a control that can span
multiple codec registers which together forms a single
signed value in a MSB/LSB manner. The control supports
specifying total no of bits used to allow for bitfields
across the multiple codec registers.

Returns 0 for success.
\index{snd\_soc\_get\_strobe (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_get_strobe}\pysiglinewithargsret{int \bfcode{snd\_soc\_get\_strobe}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
strobe get callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback get the value of a strobe mixer control.

Returns 0 for success.
\index{snd\_soc\_put\_strobe (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_put_strobe}\pysiglinewithargsret{int \bfcode{snd\_soc\_put\_strobe}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
strobe put callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback strobe a register bit to high then low (or the inverse)
in one pass of a single mixer enum control.

Returns 1 for success.
\index{snd\_soc\_new\_compress (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_new_compress}\pysiglinewithargsret{int \bfcode{snd\_soc\_new\_compress}}{struct snd\_soc\_pcm\_runtime *\emph{ rtd}, int\emph{ num}}{}
create a new compress.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_pcm\_runtime * rtd}}] \leavevmode
The runtime for which we will create compress

\item[{\code{int num}}] \leavevmode
the device index number (zero based - shared with normal PCMs)

\end{description}

\textbf{Return}

0 for success, else error.


\subsubsection{ASoC DAPM API}
\label{sound/kernel-api/alsa-driver-api:asoc-dapm-api}\index{snd\_soc\_dapm\_kcontrol\_widget (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_kcontrol_widget}\pysiglinewithargsret{struct snd\_soc\_dapm\_widget * \bfcode{snd\_soc\_dapm\_kcontrol\_widget}}{struct snd\_kcontrol *\emph{ kcontrol}}{}
Returns the widget associated to a kcontrol

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
The kcontrol

\end{description}
\index{snd\_soc\_dapm\_kcontrol\_dapm (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_kcontrol_dapm}\pysiglinewithargsret{struct snd\_soc\_dapm\_context * \bfcode{snd\_soc\_dapm\_kcontrol\_dapm}}{struct snd\_kcontrol *\emph{ kcontrol}}{}
Returns the dapm context associated to a kcontrol

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
The kcontrol

\end{description}

\textbf{Note}

This function must only be used on kcontrols that are known to have
been registered for a CODEC. Otherwise the behaviour is undefined.
\index{snd\_soc\_dapm\_force\_bias\_level (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_force_bias_level}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_force\_bias\_level}}{struct snd\_soc\_dapm\_context *\emph{ dapm}, enum snd\_soc\_bias\_level\emph{ level}}{}
Sets the DAPM bias level

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
The DAPM context for which to set the level

\item[{\code{enum snd\_soc\_bias\_level level}}] \leavevmode
The level to set

\end{description}

\textbf{Description}

Forces the DAPM bias level to a specific state. It will call the bias level
callback of DAPM context with the specified level. This will even happen if
the context is already at the same level. Furthermore it will not go through
the normal bias level sequencing, meaning any intermediate states between the
current and the target state will not be entered.

Note that the change in bias level is only temporary and the next time
{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_dapm_sync]{\emph{\code{snd\_soc\_dapm\_sync()}}}} is called the state will be set to the level as
determined by the DAPM core. The function is mainly intended to be used to
used during probe or resume from suspend to power up the device so
initialization can be done, before the DAPM core takes over.
\index{snd\_soc\_dapm\_set\_bias\_level (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_set_bias_level}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_set\_bias\_level}}{struct snd\_soc\_dapm\_context *\emph{ dapm}, enum snd\_soc\_bias\_level\emph{ level}}{}
set the bias level for the system

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\item[{\code{enum snd\_soc\_bias\_level level}}] \leavevmode
level to configure

\end{description}

\textbf{Description}

Configure the bias (power) levels for the SoC audio device.

Returns 0 for success else error.
\index{snd\_soc\_dapm\_dai\_get\_connected\_widgets (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_dai_get_connected_widgets}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_dai\_get\_connected\_widgets}}{struct snd\_soc\_dai *\emph{ dai}, int\emph{ stream}, struct snd\_soc\_dapm\_widget\_list **\emph{ list}, bool (*custom\_stop\_condition) (struct snd\_soc\_dapm\_widget\emph{ *}, enum\emph{ snd\_soc\_dapm\_direction}}{}
query audio path and it's widgets.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dai * dai}}] \leavevmode
the soc DAI.

\item[{\code{int stream}}] \leavevmode
stream direction.

\item[{\code{struct snd\_soc\_dapm\_widget\_list ** list}}] \leavevmode
list of active widgets for this stream.

\item[{\code{bool (*)(struct snd\_soc\_dapm\_widget *, enum snd\_soc\_dapm\_direction) custom\_stop\_condition}}] \leavevmode
(optional) a function meant to stop the widget graph
walk based on custom logic.

\end{description}

\textbf{Description}

Queries DAPM graph as to whether a valid audio stream path exists for
the initial stream specified by name. This takes into account
current mixer and mux kcontrol settings. Creates list of valid widgets.

Optionally, can be supplied with a function acting as a stopping condition.
This function takes the dapm widget currently being examined and the walk
direction as an arguments, it should return true if the walk should be
stopped and false otherwise.

Returns the number of valid paths or negative error.
\index{snd\_soc\_dapm\_sync\_unlocked (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_sync_unlocked}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_sync\_unlocked}}{struct snd\_soc\_dapm\_context *\emph{ dapm}}{}
scan and power dapm paths

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\end{description}

\textbf{Description}

Walks all dapm audio paths and powers widgets according to their
stream or path usage.

Requires external locking.

Returns 0 for success.
\index{snd\_soc\_dapm\_sync (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_sync}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_sync}}{struct snd\_soc\_dapm\_context *\emph{ dapm}}{}
scan and power dapm paths

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\end{description}

\textbf{Description}

Walks all dapm audio paths and powers widgets according to their
stream or path usage.

Returns 0 for success.
\index{snd\_soc\_dapm\_add\_routes (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_add_routes}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_add\_routes}}{struct snd\_soc\_dapm\_context *\emph{ dapm}, const struct snd\_soc\_dapm\_route *\emph{ route}, int\emph{ num}}{}
Add routes between DAPM widgets

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\item[{\code{const struct snd\_soc\_dapm\_route * route}}] \leavevmode
audio routes

\item[{\code{int num}}] \leavevmode
number of routes

\end{description}

\textbf{Description}

Connects 2 dapm widgets together via a named audio path. The sink is
the widget receiving the audio signal, whilst the source is the sender
of the audio signal.

Returns 0 for success else error. On error all resources can be freed
with a call to \code{snd\_soc\_card\_free()}.
\index{snd\_soc\_dapm\_del\_routes (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_del_routes}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_del\_routes}}{struct snd\_soc\_dapm\_context *\emph{ dapm}, const struct snd\_soc\_dapm\_route *\emph{ route}, int\emph{ num}}{}
Remove routes between DAPM widgets

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\item[{\code{const struct snd\_soc\_dapm\_route * route}}] \leavevmode
audio routes

\item[{\code{int num}}] \leavevmode
number of routes

\end{description}

\textbf{Description}

Removes routes from the DAPM context.
\index{snd\_soc\_dapm\_weak\_routes (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_weak_routes}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_weak\_routes}}{struct snd\_soc\_dapm\_context *\emph{ dapm}, const struct snd\_soc\_dapm\_route *\emph{ route}, int\emph{ num}}{}
Mark routes between DAPM widgets as weak

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\item[{\code{const struct snd\_soc\_dapm\_route * route}}] \leavevmode
audio routes

\item[{\code{int num}}] \leavevmode
number of routes

\end{description}

\textbf{Description}

Mark existing routes matching those specified in the passed array
as being weak, meaning that they are ignored for the purpose of
power decisions.  The main intended use case is for sidetone paths
which couple audio between other independent paths if they are both
active in order to make the combination work better at the user
level but which aren't intended to be ``used''.

Note that CODEC drivers should not use this as sidetone type paths
can frequently also be used as bypass paths.
\index{snd\_soc\_dapm\_new\_widgets (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_new_widgets}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_new\_widgets}}{struct snd\_soc\_card *\emph{ card}}{}
add new dapm widgets

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_card * card}}] \leavevmode
card to be checked for new dapm widgets

\end{description}

\textbf{Description}

Checks the codec for any new dapm widgets and creates them if found.

Returns 0 for success.
\index{snd\_soc\_dapm\_get\_volsw (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_get_volsw}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_get\_volsw}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
dapm mixer get callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to get the value of a dapm mixer control.

Returns 0 for success.
\index{snd\_soc\_dapm\_put\_volsw (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_put_volsw}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_put\_volsw}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
dapm mixer set callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to set the value of a dapm mixer control.

Returns 0 for success.
\index{snd\_soc\_dapm\_get\_enum\_double (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_get_enum_double}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_get\_enum\_double}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
dapm enumerated double mixer get callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to get the value of a dapm enumerated double mixer control.

Returns 0 for success.
\index{snd\_soc\_dapm\_put\_enum\_double (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_put_enum_double}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_put\_enum\_double}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
dapm enumerated double mixer set callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to set the value of a dapm enumerated double mixer control.

Returns 0 for success.
\index{snd\_soc\_dapm\_info\_pin\_switch (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_info_pin_switch}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_info\_pin\_switch}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_info *\emph{ uinfo}}{}
Info for a pin switch

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_info * uinfo}}] \leavevmode
control element information

\end{description}

\textbf{Description}

Callback to provide information about a pin switch control.
\index{snd\_soc\_dapm\_get\_pin\_switch (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_get_pin_switch}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_get\_pin\_switch}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
Get information for a pin switch

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
Value

\end{description}
\index{snd\_soc\_dapm\_put\_pin\_switch (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_put_pin_switch}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_put\_pin\_switch}}{struct snd\_kcontrol *\emph{ kcontrol}, struct snd\_ctl\_elem\_value *\emph{ ucontrol}}{}
Set information for a pin switch

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_kcontrol * kcontrol}}] \leavevmode
mixer control

\item[{\code{struct snd\_ctl\_elem\_value * ucontrol}}] \leavevmode
Value

\end{description}
\index{snd\_soc\_dapm\_new\_controls (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_new_controls}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_new\_controls}}{struct snd\_soc\_dapm\_context *\emph{ dapm}, const struct snd\_soc\_dapm\_widget *\emph{ widget}, int\emph{ num}}{}
create new dapm controls

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\item[{\code{const struct snd\_soc\_dapm\_widget * widget}}] \leavevmode
widget array

\item[{\code{int num}}] \leavevmode
number of widgets

\end{description}

\textbf{Description}

Creates new DAPM controls based upon the templates.

Returns 0 for success else error.
\index{snd\_soc\_dapm\_stream\_event (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_stream_event}\pysiglinewithargsret{void \bfcode{snd\_soc\_dapm\_stream\_event}}{struct snd\_soc\_pcm\_runtime *\emph{ rtd}, int\emph{ stream}, int\emph{ event}}{}
send a stream event to the dapm core

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_pcm\_runtime * rtd}}] \leavevmode
PCM runtime data

\item[{\code{int stream}}] \leavevmode
stream name

\item[{\code{int event}}] \leavevmode
stream event

\end{description}

\textbf{Description}

Sends a stream event to the dapm core. The core then makes any
necessary widget power changes.

Returns 0 for success else error.
\index{snd\_soc\_dapm\_enable\_pin\_unlocked (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_enable_pin_unlocked}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_enable\_pin\_unlocked}}{struct snd\_soc\_dapm\_context *\emph{ dapm}, const char *\emph{ pin}}{}
enable pin.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\item[{\code{const char * pin}}] \leavevmode
pin name

\end{description}

\textbf{Description}

Enables input/output pin and its parents or children widgets iff there is
a valid audio route and active audio stream.

Requires external locking.

\textbf{NOTE}

{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_dapm_sync]{\emph{\code{snd\_soc\_dapm\_sync()}}}} needs to be called after this for DAPM to
do any widget power switching.
\index{snd\_soc\_dapm\_enable\_pin (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_enable_pin}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_enable\_pin}}{struct snd\_soc\_dapm\_context *\emph{ dapm}, const char *\emph{ pin}}{}
enable pin.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\item[{\code{const char * pin}}] \leavevmode
pin name

\end{description}

\textbf{Description}

Enables input/output pin and its parents or children widgets iff there is
a valid audio route and active audio stream.

\textbf{NOTE}

{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_dapm_sync]{\emph{\code{snd\_soc\_dapm\_sync()}}}} needs to be called after this for DAPM to
do any widget power switching.
\index{snd\_soc\_dapm\_force\_enable\_pin\_unlocked (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_force_enable_pin_unlocked}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_force\_enable\_pin\_unlocked}}{struct snd\_soc\_dapm\_context *\emph{ dapm}, const char *\emph{ pin}}{}
force a pin to be enabled

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\item[{\code{const char * pin}}] \leavevmode
pin name

\end{description}

\textbf{Description}

Enables input/output pin regardless of any other state.  This is
intended for use with microphone bias supplies used in microphone
jack detection.

Requires external locking.

\textbf{NOTE}

{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_dapm_sync]{\emph{\code{snd\_soc\_dapm\_sync()}}}} needs to be called after this for DAPM to
do any widget power switching.
\index{snd\_soc\_dapm\_force\_enable\_pin (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_force_enable_pin}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_force\_enable\_pin}}{struct snd\_soc\_dapm\_context *\emph{ dapm}, const char *\emph{ pin}}{}
force a pin to be enabled

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\item[{\code{const char * pin}}] \leavevmode
pin name

\end{description}

\textbf{Description}

Enables input/output pin regardless of any other state.  This is
intended for use with microphone bias supplies used in microphone
jack detection.

\textbf{NOTE}

{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_dapm_sync]{\emph{\code{snd\_soc\_dapm\_sync()}}}} needs to be called after this for DAPM to
do any widget power switching.
\index{snd\_soc\_dapm\_disable\_pin\_unlocked (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_disable_pin_unlocked}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_disable\_pin\_unlocked}}{struct snd\_soc\_dapm\_context *\emph{ dapm}, const char *\emph{ pin}}{}
disable pin.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\item[{\code{const char * pin}}] \leavevmode
pin name

\end{description}

\textbf{Description}

Disables input/output pin and its parents or children widgets.

Requires external locking.

\textbf{NOTE}

{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_dapm_sync]{\emph{\code{snd\_soc\_dapm\_sync()}}}} needs to be called after this for DAPM to
do any widget power switching.
\index{snd\_soc\_dapm\_disable\_pin (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_disable_pin}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_disable\_pin}}{struct snd\_soc\_dapm\_context *\emph{ dapm}, const char *\emph{ pin}}{}
disable pin.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\item[{\code{const char * pin}}] \leavevmode
pin name

\end{description}

\textbf{Description}

Disables input/output pin and its parents or children widgets.

\textbf{NOTE}

{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_dapm_sync]{\emph{\code{snd\_soc\_dapm\_sync()}}}} needs to be called after this for DAPM to
do any widget power switching.
\index{snd\_soc\_dapm\_nc\_pin\_unlocked (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_nc_pin_unlocked}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_nc\_pin\_unlocked}}{struct snd\_soc\_dapm\_context *\emph{ dapm}, const char *\emph{ pin}}{}
permanently disable pin.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\item[{\code{const char * pin}}] \leavevmode
pin name

\end{description}

\textbf{Description}

Marks the specified pin as being not connected, disabling it along
any parent or child widgets.  At present this is identical to
{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_dapm_disable_pin]{\emph{\code{snd\_soc\_dapm\_disable\_pin()}}}} but in future it will be extended to do
additional things such as disabling controls which only affect
paths through the pin.

Requires external locking.

\textbf{NOTE}

{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_dapm_sync]{\emph{\code{snd\_soc\_dapm\_sync()}}}} needs to be called after this for DAPM to
do any widget power switching.
\index{snd\_soc\_dapm\_nc\_pin (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_nc_pin}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_nc\_pin}}{struct snd\_soc\_dapm\_context *\emph{ dapm}, const char *\emph{ pin}}{}
permanently disable pin.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\item[{\code{const char * pin}}] \leavevmode
pin name

\end{description}

\textbf{Description}

Marks the specified pin as being not connected, disabling it along
any parent or child widgets.  At present this is identical to
{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_dapm_disable_pin]{\emph{\code{snd\_soc\_dapm\_disable\_pin()}}}} but in future it will be extended to do
additional things such as disabling controls which only affect
paths through the pin.

\textbf{NOTE}

{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_dapm_sync]{\emph{\code{snd\_soc\_dapm\_sync()}}}} needs to be called after this for DAPM to
do any widget power switching.
\index{snd\_soc\_dapm\_get\_pin\_status (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_get_pin_status}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_get\_pin\_status}}{struct snd\_soc\_dapm\_context *\emph{ dapm}, const char *\emph{ pin}}{}
get audio pin status

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\item[{\code{const char * pin}}] \leavevmode
audio signal pin endpoint (or start point)

\end{description}

\textbf{Description}

Get audio pin status - connected or disconnected.

Returns 1 for connected otherwise 0.
\index{snd\_soc\_dapm\_ignore\_suspend (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_ignore_suspend}\pysiglinewithargsret{int \bfcode{snd\_soc\_dapm\_ignore\_suspend}}{struct snd\_soc\_dapm\_context *\emph{ dapm}, const char *\emph{ pin}}{}
ignore suspend status for DAPM endpoint

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\item[{\code{const char * pin}}] \leavevmode
audio signal pin endpoint (or start point)

\end{description}

\textbf{Description}

Mark the given endpoint or pin as ignoring suspend.  When the
system is disabled a path between two endpoints flagged as ignoring
suspend will not be disabled.  The path must already be enabled via
normal means at suspend time, it will not be turned on if it was not
already enabled.
\index{snd\_soc\_dapm\_free (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_dapm_free}\pysiglinewithargsret{void \bfcode{snd\_soc\_dapm\_free}}{struct snd\_soc\_dapm\_context *\emph{ dapm}}{}
free dapm resources

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_dapm\_context * dapm}}] \leavevmode
DAPM context

\end{description}

\textbf{Description}

Free all dapm widgets and resources.


\subsubsection{ASoC DMA Engine API}
\label{sound/kernel-api/alsa-driver-api:asoc-dma-engine-api}\index{snd\_dmaengine\_pcm\_prepare\_slave\_config (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dmaengine_pcm_prepare_slave_config}\pysiglinewithargsret{int \bfcode{snd\_dmaengine\_pcm\_prepare\_slave\_config}}{struct snd\_pcm\_substream *\emph{ substream}, struct snd\_pcm\_hw\_params *\emph{ params}, struct dma\_slave\_config *\emph{ slave\_config}}{}
Generic prepare\_slave\_config callback

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_pcm\_substream * substream}}] \leavevmode
PCM substream

\item[{\code{struct snd\_pcm\_hw\_params * params}}] \leavevmode
hw\_params

\item[{\code{struct dma\_slave\_config * slave\_config}}] \leavevmode
DMA slave config to prepare

\end{description}

\textbf{Description}

This function can be used as a generic prepare\_slave\_config callback for
platforms which make use of the snd\_dmaengine\_dai\_dma\_data struct for their
DAI DMA data. Internally the function will first call
snd\_hwparams\_to\_dma\_slave\_config to fill in the slave config based on the
hw\_params, followed by snd\_dmaengine\_set\_config\_from\_dai\_data to fill in the
remaining fields based on the DAI DMA data.
\index{snd\_dmaengine\_pcm\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dmaengine_pcm_register}\pysiglinewithargsret{int \bfcode{snd\_dmaengine\_pcm\_register}}{struct device *\emph{ dev}, const struct {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_dmaengine_pcm_config]{\emph{snd\_dmaengine\_pcm\_config}}} *\emph{ config}, unsigned int\emph{ flags}}{}
Register a dmaengine based PCM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
The parent device for the PCM device

\item[{\code{const struct snd\_dmaengine\_pcm\_config * config}}] \leavevmode
Platform specific PCM configuration

\item[{\code{unsigned int flags}}] \leavevmode
Platform specific quirks

\end{description}
\index{snd\_dmaengine\_pcm\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dmaengine_pcm_unregister}\pysiglinewithargsret{void \bfcode{snd\_dmaengine\_pcm\_unregister}}{struct device *\emph{ dev}}{}
Removes a dmaengine based PCM device

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * dev}}] \leavevmode
Parent device the PCM was register with

\end{description}

\textbf{Description}

Removes a dmaengine based PCM device previously registered with
snd\_dmaengine\_pcm\_register.


\subsection{Miscellaneous Functions}
\label{sound/kernel-api/alsa-driver-api:miscellaneous-functions}

\subsubsection{Hardware-Dependent Devices API}
\label{sound/kernel-api/alsa-driver-api:hardware-dependent-devices-api}\index{snd\_hwdep\_new (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_hwdep_new}\pysiglinewithargsret{int \bfcode{snd\_hwdep\_new}}{struct snd\_card *\emph{ card}, char *\emph{ id}, int\emph{ device}, struct snd\_hwdep **\emph{ rhwdep}}{}
create a new hwdep instance

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{char * id}}] \leavevmode
the id string

\item[{\code{int device}}] \leavevmode
the device index (zero-based)

\item[{\code{struct snd\_hwdep ** rhwdep}}] \leavevmode
the pointer to store the new hwdep instance

\end{description}

\textbf{Description}

Creates a new hwdep instance with the given index on the card.
The callbacks (hwdep-\textgreater{}ops) must be set on the returned instance
after this call manually by the caller.

\textbf{Return}

Zero if successful, or a negative error code on failure.


\subsubsection{Jack Abstraction Layer API}
\label{sound/kernel-api/alsa-driver-api:jack-abstraction-layer-api}\index{snd\_jack\_types (C type)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_jack_types}\pysigline{enum \bfcode{snd\_jack\_types}}
Jack types which can be reported

\end{fulllineitems}


\textbf{Constants}
\begin{description}
\item[{\code{SND\_JACK\_HEADPHONE}}] \leavevmode
Headphone

\item[{\code{SND\_JACK\_MICROPHONE}}] \leavevmode
Microphone

\item[{\code{SND\_JACK\_HEADSET}}] \leavevmode
Headset

\item[{\code{SND\_JACK\_LINEOUT}}] \leavevmode
Line out

\item[{\code{SND\_JACK\_MECHANICAL}}] \leavevmode
Mechanical switch

\item[{\code{SND\_JACK\_VIDEOOUT}}] \leavevmode
Video out

\item[{\code{SND\_JACK\_AVOUT}}] \leavevmode
AV (Audio Video) out

\item[{\code{SND\_JACK\_LINEIN}}] \leavevmode
Line in

\item[{\code{SND\_JACK\_BTN\_0}}] \leavevmode
Button 0

\item[{\code{SND\_JACK\_BTN\_1}}] \leavevmode
Button 1

\item[{\code{SND\_JACK\_BTN\_2}}] \leavevmode
Button 2

\item[{\code{SND\_JACK\_BTN\_3}}] \leavevmode
Button 3

\item[{\code{SND\_JACK\_BTN\_4}}] \leavevmode
Button 4

\item[{\code{SND\_JACK\_BTN\_5}}] \leavevmode
Button 5

\end{description}

\textbf{Description}

These values are used as a bitmask.

Note that this must be kept in sync with the lookup table in
sound/core/jack.c.
\index{snd\_jack\_add\_new\_kctl (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_jack_add_new_kctl}\pysiglinewithargsret{int \bfcode{snd\_jack\_add\_new\_kctl}}{struct snd\_jack *\emph{ jack}, const char *\emph{ name}, int\emph{ mask}}{}
Create a new snd\_jack\_kctl and add it to jack

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_jack * jack}}] \leavevmode
the jack instance which the kctl will attaching to

\item[{\code{const char * name}}] \leavevmode
the name for the snd\_kcontrol object

\item[{\code{int mask}}] \leavevmode
a bitmask of enum snd\_jack\_type values that can be detected
by this snd\_jack\_kctl object.

\end{description}

\textbf{Description}

Creates a new snd\_kcontrol object and adds it to the jack kctl\_list.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_jack\_new (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_jack_new}\pysiglinewithargsret{int \bfcode{snd\_jack\_new}}{struct snd\_card *\emph{ card}, const char *\emph{ id}, int\emph{ type}, struct snd\_jack **\emph{ jjack}, bool\emph{ initial\_kctl}, bool\emph{ phantom\_jack}}{}
Create a new jack

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_card * card}}] \leavevmode
the card instance

\item[{\code{const char * id}}] \leavevmode
an identifying string for this jack

\item[{\code{int type}}] \leavevmode
a bitmask of enum snd\_jack\_type values that can be detected by
this jack

\item[{\code{struct snd\_jack ** jjack}}] \leavevmode
Used to provide the allocated jack object to the caller.

\item[{\code{bool initial\_kctl}}] \leavevmode
if true, create a kcontrol and add it to the jack list.

\item[{\code{bool phantom\_jack}}] \leavevmode
Don't create a input device for phantom jacks.

\end{description}

\textbf{Description}

Creates a new jack object.

\textbf{Return}

Zero if successful, or a negative error code on failure.
On success \textbf{jjack} will be initialised.
\index{snd\_jack\_set\_parent (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_jack_set_parent}\pysiglinewithargsret{void \bfcode{snd\_jack\_set\_parent}}{struct snd\_jack *\emph{ jack}, struct device *\emph{ parent}}{}
Set the parent device for a jack

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_jack * jack}}] \leavevmode
The jack to configure

\item[{\code{struct device * parent}}] \leavevmode
The device to set as parent for the jack.

\end{description}

\textbf{Description}

Set the parent for the jack devices in the device tree.  This
function is only valid prior to registration of the jack.  If no
parent is configured then the parent device will be the sound card.
\index{snd\_jack\_set\_key (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_jack_set_key}\pysiglinewithargsret{int \bfcode{snd\_jack\_set\_key}}{struct snd\_jack *\emph{ jack}, enum {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_jack_types]{\emph{snd\_jack\_types}}}\emph{ type}, int\emph{ keytype}}{}
Set a key mapping on a jack

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_jack * jack}}] \leavevmode
The jack to configure

\item[{\code{enum snd\_jack\_types type}}] \leavevmode
Jack report type for this key

\item[{\code{int keytype}}] \leavevmode
Input layer key type to be reported

\end{description}

\textbf{Description}

Map a SND\_JACK\_BTN\_* button type to an input layer key, allowing
reporting of keys on accessories via the jack abstraction.  If no
mapping is provided but keys are enabled in the jack type then
BTN\_n numeric buttons will be reported.

If jacks are not reporting via the input API this call will have no
effect.

Note that this is intended to be use by simple devices with small
numbers of keys that can be reported.  It is also possible to
access the input device directly - devices with complex input
capabilities on accessories should consider doing this rather than
using this abstraction.

This function may only be called prior to registration of the jack.

\textbf{Return}

Zero if successful, or a negative error code on failure.
\index{snd\_jack\_report (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_jack_report}\pysiglinewithargsret{void \bfcode{snd\_jack\_report}}{struct snd\_jack *\emph{ jack}, int\emph{ status}}{}
Report the current status of a jack

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_jack * jack}}] \leavevmode
The jack to report status for

\item[{\code{int status}}] \leavevmode
The current status of the jack

\end{description}
\index{snd\_soc\_codec\_set\_jack (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_codec_set_jack}\pysiglinewithargsret{int \bfcode{snd\_soc\_codec\_set\_jack}}{struct snd\_soc\_codec *\emph{ codec}, struct snd\_soc\_jack *\emph{ jack}, void *\emph{ data}}{}
configure codec jack.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_codec * codec}}] \leavevmode
CODEC

\item[{\code{struct snd\_soc\_jack * jack}}] \leavevmode
structure to use for the jack

\item[{\code{void * data}}] \leavevmode
can be used if codec driver need extra data for configuring jack

\end{description}

\textbf{Description}

Configures and enables jack detection function.
\index{snd\_soc\_component\_set\_jack (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_component_set_jack}\pysiglinewithargsret{int \bfcode{snd\_soc\_component\_set\_jack}}{struct snd\_soc\_component *\emph{ component}, struct snd\_soc\_jack *\emph{ jack}, void *\emph{ data}}{}
configure component jack.

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_component * component}}] \leavevmode
COMPONENTs

\item[{\code{struct snd\_soc\_jack * jack}}] \leavevmode
structure to use for the jack

\item[{\code{void * data}}] \leavevmode
can be used if codec driver need extra data for configuring jack

\end{description}

\textbf{Description}

Configures and enables jack detection function.
\index{snd\_soc\_card\_jack\_new (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_card_jack_new}\pysiglinewithargsret{int \bfcode{snd\_soc\_card\_jack\_new}}{struct snd\_soc\_card *\emph{ card}, const char *\emph{ id}, int\emph{ type}, struct snd\_soc\_jack *\emph{ jack}, struct {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_jack_pin]{\emph{snd\_soc\_jack\_pin}}} *\emph{ pins}, unsigned int\emph{ num\_pins}}{}
Create a new jack

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_card * card}}] \leavevmode
ASoC card

\item[{\code{const char * id}}] \leavevmode
an identifying string for this jack

\item[{\code{int type}}] \leavevmode
a bitmask of enum snd\_jack\_type values that can be detected by
this jack

\item[{\code{struct snd\_soc\_jack * jack}}] \leavevmode
structure to use for the jack

\item[{\code{struct snd\_soc\_jack\_pin * pins}}] \leavevmode
Array of jack pins to be added to the jack or NULL

\item[{\code{unsigned int num\_pins}}] \leavevmode
Number of elements in the \textbf{pins} array

\end{description}

\textbf{Description}

Creates a new jack object.

Returns zero if successful, or a negative error code on failure.
On success jack will be initialised.
\index{snd\_soc\_jack\_report (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_jack_report}\pysiglinewithargsret{void \bfcode{snd\_soc\_jack\_report}}{struct snd\_soc\_jack *\emph{ jack}, int\emph{ status}, int\emph{ mask}}{}
Report the current status for a jack

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_jack * jack}}] \leavevmode
the jack

\item[{\code{int status}}] \leavevmode
a bitmask of enum snd\_jack\_type values that are currently detected.

\item[{\code{int mask}}] \leavevmode
a bitmask of enum snd\_jack\_type values that being reported.

\end{description}

\textbf{Description}

If configured using {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_jack_add_pins]{\emph{\code{snd\_soc\_jack\_add\_pins()}}}} then the associated
DAPM pins will be enabled or disabled as appropriate and DAPM
synchronised.

\textbf{Note}

This function uses mutexes and should be called from a
context which can sleep (such as a workqueue).
\index{snd\_soc\_jack\_add\_zones (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_jack_add_zones}\pysiglinewithargsret{int \bfcode{snd\_soc\_jack\_add\_zones}}{struct snd\_soc\_jack *\emph{ jack}, int\emph{ count}, struct {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_jack_zone]{\emph{snd\_soc\_jack\_zone}}} *\emph{ zones}}{}
Associate voltage zones with jack

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_jack * jack}}] \leavevmode
ASoC jack

\item[{\code{int count}}] \leavevmode
Number of zones

\item[{\code{struct snd\_soc\_jack\_zone * zones}}] \leavevmode
Array of zones

\end{description}

\textbf{Description}

After this function has been called the zones specified in the
array will be associated with the jack.
\index{snd\_soc\_jack\_get\_type (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_jack_get_type}\pysiglinewithargsret{int \bfcode{snd\_soc\_jack\_get\_type}}{struct snd\_soc\_jack *\emph{ jack}, int\emph{ micbias\_voltage}}{}
Based on the mic bias value, this function returns the type of jack from the zones declared in the jack type

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_jack * jack}}] \leavevmode
ASoC jack

\item[{\code{int micbias\_voltage}}] \leavevmode
mic bias voltage at adc channel when jack is plugged in

\end{description}

\textbf{Description}

Based on the mic bias value passed, this function helps identify
the type of jack from the already declared jack zones
\index{snd\_soc\_jack\_add\_pins (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_jack_add_pins}\pysiglinewithargsret{int \bfcode{snd\_soc\_jack\_add\_pins}}{struct snd\_soc\_jack *\emph{ jack}, int\emph{ count}, struct {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_jack_pin]{\emph{snd\_soc\_jack\_pin}}} *\emph{ pins}}{}
Associate DAPM pins with an ASoC jack

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_jack * jack}}] \leavevmode
ASoC jack

\item[{\code{int count}}] \leavevmode
Number of pins

\item[{\code{struct snd\_soc\_jack\_pin * pins}}] \leavevmode
Array of pins

\end{description}

\textbf{Description}

After this function has been called the DAPM pins specified in the
pins array will have their status updated to reflect the current
state of the jack whenever the jack status is updated.
\index{snd\_soc\_jack\_notifier\_register (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_jack_notifier_register}\pysiglinewithargsret{void \bfcode{snd\_soc\_jack\_notifier\_register}}{struct snd\_soc\_jack *\emph{ jack}, struct notifier\_block *\emph{ nb}}{}
Register a notifier for jack status

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_jack * jack}}] \leavevmode
ASoC jack

\item[{\code{struct notifier\_block * nb}}] \leavevmode
Notifier block to register

\end{description}

\textbf{Description}

Register for notification of the current status of the jack.  Note
that it is not possible to report additional jack events in the
callback from the notifier, this is intended to support
applications such as enabling electrical detection only when a
mechanical detection event has occurred.
\index{snd\_soc\_jack\_notifier\_unregister (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_jack_notifier_unregister}\pysiglinewithargsret{void \bfcode{snd\_soc\_jack\_notifier\_unregister}}{struct snd\_soc\_jack *\emph{ jack}, struct notifier\_block *\emph{ nb}}{}
Unregister a notifier for jack status

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_jack * jack}}] \leavevmode
ASoC jack

\item[{\code{struct notifier\_block * nb}}] \leavevmode
Notifier block to unregister

\end{description}

\textbf{Description}

Stop notifying for status changes.
\index{snd\_soc\_jack\_add\_gpios (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_jack_add_gpios}\pysiglinewithargsret{int \bfcode{snd\_soc\_jack\_add\_gpios}}{struct snd\_soc\_jack *\emph{ jack}, int\emph{ count}, struct {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_jack_gpio]{\emph{snd\_soc\_jack\_gpio}}} *\emph{ gpios}}{}
Associate GPIO pins with an ASoC jack

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_jack * jack}}] \leavevmode
ASoC jack

\item[{\code{int count}}] \leavevmode
number of pins

\item[{\code{struct snd\_soc\_jack\_gpio * gpios}}] \leavevmode
array of gpio pins

\end{description}

\textbf{Description}

This function will request gpio, set data direction and request irq
for each gpio in the array.
\index{snd\_soc\_jack\_add\_gpiods (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_jack_add_gpiods}\pysiglinewithargsret{int \bfcode{snd\_soc\_jack\_add\_gpiods}}{struct device *\emph{ gpiod\_dev}, struct snd\_soc\_jack *\emph{ jack}, int\emph{ count}, struct {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_jack_gpio]{\emph{snd\_soc\_jack\_gpio}}} *\emph{ gpios}}{}
Associate GPIO descriptor pins with an ASoC jack

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct device * gpiod\_dev}}] \leavevmode
GPIO consumer device

\item[{\code{struct snd\_soc\_jack * jack}}] \leavevmode
ASoC jack

\item[{\code{int count}}] \leavevmode
number of pins

\item[{\code{struct snd\_soc\_jack\_gpio * gpios}}] \leavevmode
array of gpio pins

\end{description}

\textbf{Description}

This function will request gpio, set data direction and request irq
for each gpio in the array.
\index{snd\_soc\_jack\_free\_gpios (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_soc_jack_free_gpios}\pysiglinewithargsret{void \bfcode{snd\_soc\_jack\_free\_gpios}}{struct snd\_soc\_jack *\emph{ jack}, int\emph{ count}, struct {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_soc_jack_gpio]{\emph{snd\_soc\_jack\_gpio}}} *\emph{ gpios}}{}
Release GPIO pins' resources of an ASoC jack

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{struct snd\_soc\_jack * jack}}] \leavevmode
ASoC jack

\item[{\code{int count}}] \leavevmode
number of pins

\item[{\code{struct snd\_soc\_jack\_gpio * gpios}}] \leavevmode
array of gpio pins

\end{description}

\textbf{Description}

Release gpio and irq resources for gpio pins associated with an ASoC jack.


\subsubsection{ISA DMA Helpers}
\label{sound/kernel-api/alsa-driver-api:isa-dma-helpers}\index{snd\_dma\_program (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dma_program}\pysiglinewithargsret{void \bfcode{snd\_dma\_program}}{unsigned long\emph{ dma}, unsigned long\emph{ addr}, unsigned int\emph{ size}, unsigned short\emph{ mode}}{}
program an ISA DMA transfer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long dma}}] \leavevmode
the dma number

\item[{\code{unsigned long addr}}] \leavevmode
the physical address of the buffer

\item[{\code{unsigned int size}}] \leavevmode
the DMA transfer size

\item[{\code{unsigned short mode}}] \leavevmode
the DMA transfer mode, DMA\_MODE\_XXX

\end{description}

\textbf{Description}

Programs an ISA DMA transfer for the given buffer.
\index{snd\_dma\_disable (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dma_disable}\pysiglinewithargsret{void \bfcode{snd\_dma\_disable}}{unsigned long\emph{ dma}}{}
stop the ISA DMA transfer

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long dma}}] \leavevmode
the dma number

\end{description}

\textbf{Description}

Stops the ISA DMA transfer.
\index{snd\_dma\_pointer (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_dma_pointer}\pysiglinewithargsret{unsigned int \bfcode{snd\_dma\_pointer}}{unsigned long\emph{ dma}, unsigned int\emph{ size}}{}
return the current pointer to DMA transfer buffer in bytes

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{unsigned long dma}}] \leavevmode
the dma number

\item[{\code{unsigned int size}}] \leavevmode
the dma transfer size

\end{description}

\textbf{Return}

The current pointer in DMA transfer buffer in bytes.


\subsubsection{Other Helper Macros}
\label{sound/kernel-api/alsa-driver-api:other-helper-macros}\index{snd\_printk (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_printk}\pysiglinewithargsret{\bfcode{snd\_printk}}{\emph{fmt}, \emph{...}}{}
printk wrapper

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{fmt}}] \leavevmode
format string

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

Works like \code{printk()} but prints the file and the line of the caller
when configured with CONFIG\_SND\_VERBOSE\_PRINTK.
\index{snd\_printd (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_printd}\pysiglinewithargsret{\bfcode{snd\_printd}}{\emph{fmt}, \emph{...}}{}
debug printk

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{fmt}}] \leavevmode
format string

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

Works like \code{snd\_printk()} for debugging purposes.
Ignored when CONFIG\_SND\_DEBUG is not set.
\index{snd\_BUG (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_BUG}\pysiglinewithargsret{\bfcode{snd\_BUG}}{}{}
give a BUG warning message and stack trace

\end{fulllineitems}


\textbf{Parameters}

\textbf{Description}

Calls \code{WARN()} if CONFIG\_SND\_DEBUG is set.
Ignored when CONFIG\_SND\_DEBUG is not set.
\index{snd\_printd\_ratelimit (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_printd_ratelimit}\pysiglinewithargsret{\bfcode{snd\_printd\_ratelimit}}{}{}
\end{fulllineitems}


\textbf{Parameters}
\index{snd\_BUG\_ON (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_BUG_ON}\pysiglinewithargsret{\bfcode{snd\_BUG\_ON}}{\emph{cond}}{}
debugging check macro

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{cond}}] \leavevmode
condition to evaluate

\end{description}

\textbf{Description}

Has the same behavior as WARN\_ON when CONFIG\_SND\_DEBUG is set,
otherwise just evaluates the conditional and returns the value.
\index{snd\_printdd (C function)}

\begin{fulllineitems}
\phantomsection\label{sound/kernel-api/alsa-driver-api:c.snd_printdd}\pysiglinewithargsret{\bfcode{snd\_printdd}}{\emph{format}, \emph{...}}{}
debug printk

\end{fulllineitems}


\textbf{Parameters}
\begin{description}
\item[{\code{format}}] \leavevmode
format string

\item[{\code{...}}] \leavevmode
variable arguments

\end{description}

\textbf{Description}

Works like \code{snd\_printk()} for debugging purposes.
Ignored when CONFIG\_SND\_DEBUG\_VERBOSE is not set.


\section{Writing an ALSA Driver}
\label{sound/kernel-api/writing-an-alsa-driver:writing-an-alsa-driver}\label{sound/kernel-api/writing-an-alsa-driver::doc}\begin{quote}\begin{description}
\item[{Author}] \leavevmode
Takashi Iwai \textless{}\href{mailto:tiwai@suse.de}{tiwai@suse.de}\textgreater{}

\item[{Date}] \leavevmode
Oct 15, 2007

\item[{Edition}] \leavevmode
0.3.7

\end{description}\end{quote}


\subsection{Preface}
\label{sound/kernel-api/writing-an-alsa-driver:preface}
This document describes how to write an \href{http://www.alsa-project.org/}{ALSA (Advanced Linux Sound
Architecture)} driver. The document
focuses mainly on PCI soundcards. In the case of other device types, the
API might be different, too. However, at least the ALSA kernel API is
consistent, and therefore it would be still a bit help for writing them.

This document targets people who already have enough C language skills
and have basic linux kernel programming knowledge. This document doesn't
explain the general topic of linux kernel coding and doesn't cover
low-level driver implementation details. It only describes the standard
way to write a PCI sound driver on ALSA.

If you are already familiar with the older ALSA ver.0.5.x API, you can
check the drivers such as \code{sound/pci/es1938.c} or
\code{sound/pci/maestro3.c} which have also almost the same code-base in
the ALSA 0.5.x tree, so you can compare the differences.

This document is still a draft version. Any feedback and corrections,
please!!


\subsection{File Tree Structure}
\label{sound/kernel-api/writing-an-alsa-driver:file-tree-structure}

\subsubsection{General}
\label{sound/kernel-api/writing-an-alsa-driver:general}
The ALSA drivers are provided in two ways.

One is the trees provided as a tarball or via cvs from the ALSA's ftp
site, and another is the 2.6 (or later) Linux kernel tree. To
synchronize both, the ALSA driver tree is split into two different
trees: alsa-kernel and alsa-driver. The former contains purely the
source code for the Linux 2.6 (or later) tree. This tree is designed
only for compilation on 2.6 or later environment. The latter,
alsa-driver, contains many subtle files for compiling ALSA drivers
outside of the Linux kernel tree, wrapper functions for older 2.2 and
2.4 kernels, to adapt the latest kernel API, and additional drivers
which are still in development or in tests. The drivers in alsa-driver
tree will be moved to alsa-kernel (and eventually to the 2.6 kernel
tree) when they are finished and confirmed to work fine.

The file tree structure of ALSA driver is depicted below. Both
alsa-kernel and alsa-driver have almost the same file structure, except
for “core” directory. It's named as “acore” in alsa-driver tree.

\begin{Verbatim}[commandchars=\\\{\}]
sound
        /core
                /oss
                /seq
                        /oss
                        /instr
        /ioctl32
        /include
        /drivers
                /mpu401
                /opl3
        /i2c
                /l3
        /synth
                /emux
        /pci
                /(cards)
        /isa
                /(cards)
        /arm
        /ppc
        /sparc
        /usb
        /pcmcia /(cards)
        /oss
\end{Verbatim}


\subsubsection{core directory}
\label{sound/kernel-api/writing-an-alsa-driver:core-directory}
This directory contains the middle layer which is the heart of ALSA
drivers. In this directory, the native ALSA modules are stored. The
sub-directories contain different modules and are dependent upon the
kernel config.


\paragraph{core/oss}
\label{sound/kernel-api/writing-an-alsa-driver:core-oss}
The codes for PCM and mixer OSS emulation modules are stored in this
directory. The rawmidi OSS emulation is included in the ALSA rawmidi
code since it's quite small. The sequencer code is stored in
\code{core/seq/oss} directory (see {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:core\string-seq\string-oss]{\emph{below}}}).


\paragraph{core/ioctl32}
\label{sound/kernel-api/writing-an-alsa-driver:core-ioctl32}
This directory contains the 32bit-ioctl wrappers for 64bit architectures
such like x86-64, ppc64 and sparc64. For 32bit and alpha architectures,
these are not compiled.


\paragraph{core/seq}
\label{sound/kernel-api/writing-an-alsa-driver:core-seq}
This directory and its sub-directories are for the ALSA sequencer. This
directory contains the sequencer core and primary sequencer modules such
like snd-seq-midi, snd-seq-virmidi, etc. They are compiled only when
\code{CONFIG\_SND\_SEQUENCER} is set in the kernel config.


\paragraph{core/seq/oss}
\label{sound/kernel-api/writing-an-alsa-driver:core-seq-oss}
This contains the OSS sequencer emulation codes.


\paragraph{core/seq/instr}
\label{sound/kernel-api/writing-an-alsa-driver:core-seq-instr}
This directory contains the modules for the sequencer instrument layer.


\subsubsection{include directory}
\label{sound/kernel-api/writing-an-alsa-driver:include-directory}
This is the place for the public header files of ALSA drivers, which are
to be exported to user-space, or included by several files at different
directories. Basically, the private header files should not be placed in
this directory, but you may still find files there, due to historical
reasons :)


\subsubsection{drivers directory}
\label{sound/kernel-api/writing-an-alsa-driver:drivers-directory}
This directory contains code shared among different drivers on different
architectures. They are hence supposed not to be architecture-specific.
For example, the dummy pcm driver and the serial MIDI driver are found
in this directory. In the sub-directories, there is code for components
which are independent from bus and cpu architectures.


\paragraph{drivers/mpu401}
\label{sound/kernel-api/writing-an-alsa-driver:drivers-mpu401}
The MPU401 and MPU401-UART modules are stored here.


\paragraph{drivers/opl3 and opl4}
\label{sound/kernel-api/writing-an-alsa-driver:drivers-opl3-and-opl4}
The OPL3 and OPL4 FM-synth stuff is found here.


\subsubsection{i2c directory}
\label{sound/kernel-api/writing-an-alsa-driver:i2c-directory}
This contains the ALSA i2c components.

Although there is a standard i2c layer on Linux, ALSA has its own i2c
code for some cards, because the soundcard needs only a simple operation
and the standard i2c API is too complicated for such a purpose.


\paragraph{i2c/l3}
\label{sound/kernel-api/writing-an-alsa-driver:i2c-l3}
This is a sub-directory for ARM L3 i2c.


\subsubsection{synth directory}
\label{sound/kernel-api/writing-an-alsa-driver:synth-directory}
This contains the synth middle-level modules.

So far, there is only Emu8000/Emu10k1 synth driver under the
\code{synth/emux} sub-directory.


\subsubsection{pci directory}
\label{sound/kernel-api/writing-an-alsa-driver:pci-directory}
This directory and its sub-directories hold the top-level card modules
for PCI soundcards and the code specific to the PCI BUS.

The drivers compiled from a single file are stored directly in the pci
directory, while the drivers with several source files are stored on
their own sub-directory (e.g. emu10k1, ice1712).


\subsubsection{isa directory}
\label{sound/kernel-api/writing-an-alsa-driver:isa-directory}
This directory and its sub-directories hold the top-level card modules
for ISA soundcards.


\subsubsection{arm, ppc, and sparc directories}
\label{sound/kernel-api/writing-an-alsa-driver:arm-ppc-and-sparc-directories}
They are used for top-level card modules which are specific to one of
these architectures.


\subsubsection{usb directory}
\label{sound/kernel-api/writing-an-alsa-driver:usb-directory}
This directory contains the USB-audio driver. In the latest version, the
USB MIDI driver is integrated in the usb-audio driver.


\subsubsection{pcmcia directory}
\label{sound/kernel-api/writing-an-alsa-driver:pcmcia-directory}
The PCMCIA, especially PCCard drivers will go here. CardBus drivers will
be in the pci directory, because their API is identical to that of
standard PCI cards.


\subsubsection{oss directory}
\label{sound/kernel-api/writing-an-alsa-driver:oss-directory}
The OSS/Lite source files are stored here in Linux 2.6 (or later) tree.
In the ALSA driver tarball, this directory is empty, of course :)


\subsection{Basic Flow for PCI Drivers}
\label{sound/kernel-api/writing-an-alsa-driver:basic-flow-for-pci-drivers}

\subsubsection{Outline}
\label{sound/kernel-api/writing-an-alsa-driver:outline}
The minimum flow for PCI soundcards is as follows:
\begin{itemize}
\item {} 
define the PCI ID table (see the section {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:pci\string-entries]{\emph{PCI Entries}}}).

\item {} 
create \code{probe} callback.

\item {} 
create \code{remove} callback.

\item {} 
create a \code{struct pci\_driver} structure
containing the three pointers above.

\item {} 
create an \code{init} function just calling the
\code{pci\_register\_driver()} to register the pci\_driver
table defined above.

\item {} 
create an \code{exit} function to call the
\code{pci\_unregister\_driver()} function.

\end{itemize}


\subsubsection{Full Code Example}
\label{sound/kernel-api/writing-an-alsa-driver:full-code-example}
The code example is shown below. Some parts are kept unimplemented at
this moment but will be filled in the next sections. The numbers in the
comment lines of the \code{snd\_mychip\_probe()} function refer
to details explained in the following section.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}linux/init.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}linux/pci.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}linux/slab.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}sound/core.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}sound/initval.h\PYGZgt{}

/* module parameters (see \PYGZdq{}Module Parameters\PYGZdq{}) */
/* SNDRV\PYGZus{}CARDS: maximum number of cards supported by this module */
static int index[SNDRV\PYGZus{}CARDS] = SNDRV\PYGZus{}DEFAULT\PYGZus{}IDX;
static char *id[SNDRV\PYGZus{}CARDS] = SNDRV\PYGZus{}DEFAULT\PYGZus{}STR;
static bool enable[SNDRV\PYGZus{}CARDS] = SNDRV\PYGZus{}DEFAULT\PYGZus{}ENABLE\PYGZus{}PNP;

/* definition of the chip\PYGZhy{}specific record */
struct mychip \PYGZob{}
        struct snd\PYGZus{}card *card;
        /* the rest of the implementation will be in section
         * \PYGZdq{}PCI Resource Management\PYGZdq{}
         */
\PYGZcb{};

/* chip\PYGZhy{}specific destructor
 * (see \PYGZdq{}PCI Resource Management\PYGZdq{})
 */
static int snd\PYGZus{}mychip\PYGZus{}free(struct mychip *chip)
\PYGZob{}
        .... /* will be implemented later... */
\PYGZcb{}

/* component\PYGZhy{}destructor
 * (see \PYGZdq{}Management of Cards and Components\PYGZdq{})
 */
static int snd\PYGZus{}mychip\PYGZus{}dev\PYGZus{}free(struct snd\PYGZus{}device *device)
\PYGZob{}
        return snd\PYGZus{}mychip\PYGZus{}free(device\PYGZhy{}\PYGZgt{}device\PYGZus{}data);
\PYGZcb{}

/* chip\PYGZhy{}specific constructor
 * (see \PYGZdq{}Management of Cards and Components\PYGZdq{})
 */
static int snd\PYGZus{}mychip\PYGZus{}create(struct snd\PYGZus{}card *card,
                             struct pci\PYGZus{}dev *pci,
                             struct mychip **rchip)
\PYGZob{}
        struct mychip *chip;
        int err;
        static struct snd\PYGZus{}device\PYGZus{}ops ops = \PYGZob{}
               .dev\PYGZus{}free = snd\PYGZus{}mychip\PYGZus{}dev\PYGZus{}free,
        \PYGZcb{};

        *rchip = NULL;

        /* check PCI availability here
         * (see \PYGZdq{}PCI Resource Management\PYGZdq{})
         */
        ....

        /* allocate a chip\PYGZhy{}specific data with zero filled */
        chip = kzalloc(sizeof(*chip), GFP\PYGZus{}KERNEL);
        if (chip == NULL)
                return \PYGZhy{}ENOMEM;

        chip\PYGZhy{}\PYGZgt{}card = card;

        /* rest of initialization here; will be implemented
         * later, see \PYGZdq{}PCI Resource Management\PYGZdq{}
         */
        ....

        err = snd\PYGZus{}device\PYGZus{}new(card, SNDRV\PYGZus{}DEV\PYGZus{}LOWLEVEL, chip, \PYGZam{}ops);
        if (err \PYGZlt{} 0) \PYGZob{}
                snd\PYGZus{}mychip\PYGZus{}free(chip);
                return err;
        \PYGZcb{}

        *rchip = chip;
        return 0;
\PYGZcb{}

/* constructor \PYGZhy{}\PYGZhy{} see \PYGZdq{}Driver Constructor\PYGZdq{} sub\PYGZhy{}section */
static int snd\PYGZus{}mychip\PYGZus{}probe(struct pci\PYGZus{}dev *pci,
                            const struct pci\PYGZus{}device\PYGZus{}id *pci\PYGZus{}id)
\PYGZob{}
        static int dev;
        struct snd\PYGZus{}card *card;
        struct mychip *chip;
        int err;

        /* (1) */
        if (dev \PYGZgt{}= SNDRV\PYGZus{}CARDS)
                return \PYGZhy{}ENODEV;
        if (!enable[dev]) \PYGZob{}
                dev++;
                return \PYGZhy{}ENOENT;
        \PYGZcb{}

        /* (2) */
        err = snd\PYGZus{}card\PYGZus{}new(\PYGZam{}pci\PYGZhy{}\PYGZgt{}dev, index[dev], id[dev], THIS\PYGZus{}MODULE,
                           0, \PYGZam{}card);
        if (err \PYGZlt{} 0)
                return err;

        /* (3) */
        err = snd\PYGZus{}mychip\PYGZus{}create(card, pci, \PYGZam{}chip);
        if (err \PYGZlt{} 0) \PYGZob{}
                snd\PYGZus{}card\PYGZus{}free(card);
                return err;
        \PYGZcb{}

        /* (4) */
        strcpy(card\PYGZhy{}\PYGZgt{}driver, \PYGZdq{}My Chip\PYGZdq{});
        strcpy(card\PYGZhy{}\PYGZgt{}shortname, \PYGZdq{}My Own Chip 123\PYGZdq{});
        sprintf(card\PYGZhy{}\PYGZgt{}longname, \PYGZdq{}\PYGZpc{}s at 0x\PYGZpc{}lx irq \PYGZpc{}i\PYGZdq{},
                card\PYGZhy{}\PYGZgt{}shortname, chip\PYGZhy{}\PYGZgt{}ioport, chip\PYGZhy{}\PYGZgt{}irq);

        /* (5) */
        .... /* implemented later */

        /* (6) */
        err = snd\PYGZus{}card\PYGZus{}register(card);
        if (err \PYGZlt{} 0) \PYGZob{}
                snd\PYGZus{}card\PYGZus{}free(card);
                return err;
        \PYGZcb{}

        /* (7) */
        pci\PYGZus{}set\PYGZus{}drvdata(pci, card);
        dev++;
        return 0;
\PYGZcb{}

/* destructor \PYGZhy{}\PYGZhy{} see the \PYGZdq{}Destructor\PYGZdq{} sub\PYGZhy{}section */
static void snd\PYGZus{}mychip\PYGZus{}remove(struct pci\PYGZus{}dev *pci)
\PYGZob{}
        snd\PYGZus{}card\PYGZus{}free(pci\PYGZus{}get\PYGZus{}drvdata(pci));
        pci\PYGZus{}set\PYGZus{}drvdata(pci, NULL);
\PYGZcb{}
\end{Verbatim}


\subsubsection{Driver Constructor}
\label{sound/kernel-api/writing-an-alsa-driver:driver-constructor}
The real constructor of PCI drivers is the \code{probe} callback. The
\code{probe} callback and other component-constructors which are called
from the \code{probe} callback cannot be used with the \code{\_\_init} prefix
because any PCI device could be a hotplug device.

In the \code{probe} callback, the following scheme is often used.


\paragraph{1) Check and increment the device index.}
\label{sound/kernel-api/writing-an-alsa-driver:check-and-increment-the-device-index}
\begin{Verbatim}[commandchars=\\\{\}]
static int dev;
....
if (dev \PYGZgt{}= SNDRV\PYGZus{}CARDS)
        return \PYGZhy{}ENODEV;
if (!enable[dev]) \PYGZob{}
        dev++;
        return \PYGZhy{}ENOENT;
\PYGZcb{}
\end{Verbatim}

where \code{enable{[}dev{]}} is the module option.

Each time the \code{probe} callback is called, check the availability of
the device. If not available, simply increment the device index and
returns. dev will be incremented also later ({\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:set\string-the\string-pci\string-driver\string-data\string-and\string-return\string-zero]{\emph{step 7}}}).


\paragraph{2) Create a card instance}
\label{sound/kernel-api/writing-an-alsa-driver:create-a-card-instance}
\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}card *card;
int err;
....
err = snd\PYGZus{}card\PYGZus{}new(\PYGZam{}pci\PYGZhy{}\PYGZgt{}dev, index[dev], id[dev], THIS\PYGZus{}MODULE,
                   0, \PYGZam{}card);
\end{Verbatim}

The details will be explained in the section {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:management\string-of\string-cards\string-and\string-components]{\emph{Management of Cards and
Components}}}.


\paragraph{3) Create a main component}
\label{sound/kernel-api/writing-an-alsa-driver:create-a-main-component}
In this part, the PCI resources are allocated.

\begin{Verbatim}[commandchars=\\\{\}]
struct mychip *chip;
....
err = snd\PYGZus{}mychip\PYGZus{}create(card, pci, \PYGZam{}chip);
if (err \PYGZlt{} 0) \PYGZob{}
        snd\PYGZus{}card\PYGZus{}free(card);
        return err;
\PYGZcb{}
\end{Verbatim}

The details will be explained in the section {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:pci\string-resource\string-management]{\emph{PCI Resource
Management}}}.


\paragraph{4) Set the driver ID and name strings.}
\label{sound/kernel-api/writing-an-alsa-driver:set-the-driver-id-and-name-strings}
\begin{Verbatim}[commandchars=\\\{\}]
strcpy(card\PYGZhy{}\PYGZgt{}driver, \PYGZdq{}My Chip\PYGZdq{});
strcpy(card\PYGZhy{}\PYGZgt{}shortname, \PYGZdq{}My Own Chip 123\PYGZdq{});
sprintf(card\PYGZhy{}\PYGZgt{}longname, \PYGZdq{}\PYGZpc{}s at 0x\PYGZpc{}lx irq \PYGZpc{}i\PYGZdq{},
        card\PYGZhy{}\PYGZgt{}shortname, chip\PYGZhy{}\PYGZgt{}ioport, chip\PYGZhy{}\PYGZgt{}irq);
\end{Verbatim}

The driver field holds the minimal ID string of the chip. This is used
by alsa-lib's configurator, so keep it simple but unique. Even the
same driver can have different driver IDs to distinguish the
functionality of each chip type.

The shortname field is a string shown as more verbose name. The longname
field contains the information shown in \code{/proc/asound/cards}.


\paragraph{5) Create other components, such as mixer, MIDI, etc.}
\label{sound/kernel-api/writing-an-alsa-driver:create-other-components-such-as-mixer-midi-etc}
Here you define the basic components such as {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:PCM\string-Interface]{\emph{PCM}}},
mixer (e.g. {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:API\string-for\string-AC97\string-Codec]{\emph{AC97}}}), MIDI (e.g.
{\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:MIDI\string-MPU401\string-UART\string-Interface]{\emph{MPU-401}}}), and other interfaces.
Also, if you want a {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:Proc\string-Interface]{\emph{proc file}}}, define it here,
too.


\paragraph{6) Register the card instance.}
\label{sound/kernel-api/writing-an-alsa-driver:register-the-card-instance}
\begin{Verbatim}[commandchars=\\\{\}]
err = snd\PYGZus{}card\PYGZus{}register(card);
if (err \PYGZlt{} 0) \PYGZob{}
        snd\PYGZus{}card\PYGZus{}free(card);
        return err;
\PYGZcb{}
\end{Verbatim}

Will be explained in the section {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:management\string-of\string-cards\string-and\string-components]{\emph{Management of Cards and
Components}}}, too.


\paragraph{7) Set the PCI driver data and return zero.}
\label{sound/kernel-api/writing-an-alsa-driver:set-the-pci-driver-data-and-return-zero}
\begin{Verbatim}[commandchars=\\\{\}]
pci\PYGZus{}set\PYGZus{}drvdata(pci, card);
dev++;
return 0;
\end{Verbatim}

In the above, the card record is stored. This pointer is used in the
remove callback and power-management callbacks, too.


\subsubsection{Destructor}
\label{sound/kernel-api/writing-an-alsa-driver:destructor}
The destructor, remove callback, simply releases the card instance. Then
the ALSA middle layer will release all the attached components
automatically.

It would be typically like the following:

\begin{Verbatim}[commandchars=\\\{\}]
static void snd\PYGZus{}mychip\PYGZus{}remove(struct pci\PYGZus{}dev *pci)
\PYGZob{}
        snd\PYGZus{}card\PYGZus{}free(pci\PYGZus{}get\PYGZus{}drvdata(pci));
        pci\PYGZus{}set\PYGZus{}drvdata(pci, NULL);
\PYGZcb{}
\end{Verbatim}

The above code assumes that the card pointer is set to the PCI driver
data.


\subsubsection{Header Files}
\label{sound/kernel-api/writing-an-alsa-driver:header-files}
For the above example, at least the following include files are
necessary.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}linux/init.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}linux/pci.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}linux/slab.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}sound/core.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}sound/initval.h\PYGZgt{}
\end{Verbatim}

where the last one is necessary only when module options are defined
in the source file. If the code is split into several files, the files
without module options don't need them.

In addition to these headers, you'll need \code{\textless{}linux/interrupt.h\textgreater{}} for
interrupt handling, and \code{\textless{}asm/io.h\textgreater{}} for I/O access. If you use the
\code{mdelay()} or \code{udelay()} functions, you'll need
to include \code{\textless{}linux/delay.h\textgreater{}} too.

The ALSA interfaces like the PCM and control APIs are defined in other
\code{\textless{}sound/xxx.h\textgreater{}} header files. They have to be included after
\code{\textless{}sound/core.h\textgreater{}}.


\subsection{Management of Cards and Components}
\label{sound/kernel-api/writing-an-alsa-driver:management-of-cards-and-components}

\subsubsection{Card Instance}
\label{sound/kernel-api/writing-an-alsa-driver:card-instance}
For each soundcard, a “card” record must be allocated.

A card record is the headquarters of the soundcard. It manages the whole
list of devices (components) on the soundcard, such as PCM, mixers,
MIDI, synthesizer, and so on. Also, the card record holds the ID and the
name strings of the card, manages the root of proc files, and controls
the power-management states and hotplug disconnections. The component
list on the card record is used to manage the correct release of
resources at destruction.

As mentioned above, to create a card instance, call
\code{snd\_card\_new()}.

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}card *card;
int err;
err = snd\PYGZus{}card\PYGZus{}new(\PYGZam{}pci\PYGZhy{}\PYGZgt{}dev, index, id, module, extra\PYGZus{}size, \PYGZam{}card);
\end{Verbatim}

The function takes six arguments: the parent device pointer, the
card-index number, the id string, the module pointer (usually
\code{THIS\_MODULE}), the size of extra-data space, and the pointer to
return the card instance. The extra\_size argument is used to allocate
card-\textgreater{}private\_data for the chip-specific data. Note that these data are
allocated by \code{snd\_card\_new()}.

The first argument, the pointer of struct \code{struct device}, specifies the parent device. For PCI devices, typically
\code{\&pci-\textgreater{}} is passed there.


\subsubsection{Components}
\label{sound/kernel-api/writing-an-alsa-driver:components}
After the card is created, you can attach the components (devices) to
the card instance. In an ALSA driver, a component is represented as a
\code{struct snd\_device} object. A component
can be a PCM instance, a control interface, a raw MIDI interface, etc.
Each such instance has one component entry.

A component can be created via \code{snd\_device\_new()}
function.

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}device\PYGZus{}new(card, SNDRV\PYGZus{}DEV\PYGZus{}XXX, chip, \PYGZam{}ops);
\end{Verbatim}

This takes the card pointer, the device-level (\code{SNDRV\_DEV\_XXX}), the
data pointer, and the callback pointers (\code{\&ops}). The device-level
defines the type of components and the order of registration and
de-registration. For most components, the device-level is already
defined. For a user-defined component, you can use
\code{SNDRV\_DEV\_LOWLEVEL}.

This function itself doesn't allocate the data space. The data must be
allocated manually beforehand, and its pointer is passed as the
argument. This pointer (\code{chip} in the above example) is used as the
identifier for the instance.

Each pre-defined ALSA component such as ac97 and pcm calls
\code{snd\_device\_new()} inside its constructor. The destructor
for each component is defined in the callback pointers. Hence, you don't
need to take care of calling a destructor for such a component.

If you wish to create your own component, you need to set the destructor
function to the dev\_free callback in the \code{ops}, so that it can be
released automatically via \code{snd\_card\_free()}. The next
example will show an implementation of chip-specific data.


\subsubsection{Chip-Specific Data}
\label{sound/kernel-api/writing-an-alsa-driver:chip-specific-data}
Chip-specific information, e.g. the I/O port address, its resource
pointer, or the irq number, is stored in the chip-specific record.

\begin{Verbatim}[commandchars=\\\{\}]
struct mychip \PYGZob{}
        ....
\PYGZcb{};
\end{Verbatim}

In general, there are two ways of allocating the chip record.


\paragraph{1. Allocating via \texttt{snd\_card\_new()}.}
\label{sound/kernel-api/writing-an-alsa-driver:allocating-via-snd-card-new}
As mentioned above, you can pass the extra-data-length to the 5th
argument of \code{snd\_card\_new()}, i.e.

\begin{Verbatim}[commandchars=\\\{\}]
err = snd\PYGZus{}card\PYGZus{}new(\PYGZam{}pci\PYGZhy{}\PYGZgt{}dev, index[dev], id[dev], THIS\PYGZus{}MODULE,
                   sizeof(struct mychip), \PYGZam{}card);
\end{Verbatim}

\code{struct mychip} is the type of the chip record.

In return, the allocated record can be accessed as

\begin{Verbatim}[commandchars=\\\{\}]
struct mychip *chip = card\PYGZhy{}\PYGZgt{}private\PYGZus{}data;
\end{Verbatim}

With this method, you don't have to allocate twice. The record is
released together with the card instance.


\paragraph{2. Allocating an extra device.}
\label{sound/kernel-api/writing-an-alsa-driver:allocating-an-extra-device}
After allocating a card instance via \code{snd\_card\_new()}
(with \code{0} on the 4th arg), call \code{kzalloc()}.

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}card *card;
struct mychip *chip;
err = snd\PYGZus{}card\PYGZus{}new(\PYGZam{}pci\PYGZhy{}\PYGZgt{}dev, index[dev], id[dev], THIS\PYGZus{}MODULE,
                   0, \PYGZam{}card);
.....
chip = kzalloc(sizeof(*chip), GFP\PYGZus{}KERNEL);
\end{Verbatim}

The chip record should have the field to hold the card pointer at least,

\begin{Verbatim}[commandchars=\\\{\}]
struct mychip \PYGZob{}
        struct snd\PYGZus{}card *card;
        ....
\PYGZcb{};
\end{Verbatim}

Then, set the card pointer in the returned chip instance.

\begin{Verbatim}[commandchars=\\\{\}]
chip\PYGZhy{}\PYGZgt{}card = card;
\end{Verbatim}

Next, initialize the fields, and register this chip record as a
low-level device with a specified \code{ops},

\begin{Verbatim}[commandchars=\\\{\}]
static struct snd\PYGZus{}device\PYGZus{}ops ops = \PYGZob{}
        .dev\PYGZus{}free =        snd\PYGZus{}mychip\PYGZus{}dev\PYGZus{}free,
\PYGZcb{};
....
snd\PYGZus{}device\PYGZus{}new(card, SNDRV\PYGZus{}DEV\PYGZus{}LOWLEVEL, chip, \PYGZam{}ops);
\end{Verbatim}

\code{snd\_mychip\_dev\_free()} is the device-destructor
function, which will call the real destructor.

\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}mychip\PYGZus{}dev\PYGZus{}free(struct snd\PYGZus{}device *device)
\PYGZob{}
        return snd\PYGZus{}mychip\PYGZus{}free(device\PYGZhy{}\PYGZgt{}device\PYGZus{}data);
\PYGZcb{}
\end{Verbatim}

where \code{snd\_mychip\_free()} is the real destructor.


\subsubsection{Registration and Release}
\label{sound/kernel-api/writing-an-alsa-driver:registration-and-release}
After all components are assigned, register the card instance by calling
\code{snd\_card\_register()}. Access to the device files is
enabled at this point. That is, before
\code{snd\_card\_register()} is called, the components are safely
inaccessible from external side. If this call fails, exit the probe
function after releasing the card via \code{snd\_card\_free()}.

For releasing the card instance, you can call simply
\code{snd\_card\_free()}. As mentioned earlier, all components
are released automatically by this call.

For a device which allows hotplugging, you can use
\code{snd\_card\_free\_when\_closed()}. This one will postpone
the destruction until all devices are closed.


\subsection{PCI Resource Management}
\label{sound/kernel-api/writing-an-alsa-driver:pci-resource-management}

\subsubsection{Full Code Example}
\label{sound/kernel-api/writing-an-alsa-driver:id1}
In this section, we'll complete the chip-specific constructor,
destructor and PCI entries. Example code is shown first, below.

\begin{Verbatim}[commandchars=\\\{\}]
struct mychip \PYGZob{}
        struct snd\PYGZus{}card *card;
        struct pci\PYGZus{}dev *pci;

        unsigned long port;
        int irq;
\PYGZcb{};

static int snd\PYGZus{}mychip\PYGZus{}free(struct mychip *chip)
\PYGZob{}
        /* disable hardware here if any */
        .... /* (not implemented in this document) */

        /* release the irq */
        if (chip\PYGZhy{}\PYGZgt{}irq \PYGZgt{}= 0)
                free\PYGZus{}irq(chip\PYGZhy{}\PYGZgt{}irq, chip);
        /* release the I/O ports \PYGZam{} memory */
        pci\PYGZus{}release\PYGZus{}regions(chip\PYGZhy{}\PYGZgt{}pci);
        /* disable the PCI entry */
        pci\PYGZus{}disable\PYGZus{}device(chip\PYGZhy{}\PYGZgt{}pci);
        /* release the data */
        kfree(chip);
        return 0;
\PYGZcb{}

/* chip\PYGZhy{}specific constructor */
static int snd\PYGZus{}mychip\PYGZus{}create(struct snd\PYGZus{}card *card,
                             struct pci\PYGZus{}dev *pci,
                             struct mychip **rchip)
\PYGZob{}
        struct mychip *chip;
        int err;
        static struct snd\PYGZus{}device\PYGZus{}ops ops = \PYGZob{}
               .dev\PYGZus{}free = snd\PYGZus{}mychip\PYGZus{}dev\PYGZus{}free,
        \PYGZcb{};

        *rchip = NULL;

        /* initialize the PCI entry */
        err = pci\PYGZus{}enable\PYGZus{}device(pci);
        if (err \PYGZlt{} 0)
                return err;
        /* check PCI availability (28bit DMA) */
        if (pci\PYGZus{}set\PYGZus{}dma\PYGZus{}mask(pci, DMA\PYGZus{}BIT\PYGZus{}MASK(28)) \PYGZlt{} 0 \textbar{}\textbar{}
            pci\PYGZus{}set\PYGZus{}consistent\PYGZus{}dma\PYGZus{}mask(pci, DMA\PYGZus{}BIT\PYGZus{}MASK(28)) \PYGZlt{} 0) \PYGZob{}
                printk(KERN\PYGZus{}ERR \PYGZdq{}error to set 28bit mask DMA\PYGZbs{}n\PYGZdq{});
                pci\PYGZus{}disable\PYGZus{}device(pci);
                return \PYGZhy{}ENXIO;
        \PYGZcb{}

        chip = kzalloc(sizeof(*chip), GFP\PYGZus{}KERNEL);
        if (chip == NULL) \PYGZob{}
                pci\PYGZus{}disable\PYGZus{}device(pci);
                return \PYGZhy{}ENOMEM;
        \PYGZcb{}

        /* initialize the stuff */
        chip\PYGZhy{}\PYGZgt{}card = card;
        chip\PYGZhy{}\PYGZgt{}pci = pci;
        chip\PYGZhy{}\PYGZgt{}irq = \PYGZhy{}1;

        /* (1) PCI resource allocation */
        err = pci\PYGZus{}request\PYGZus{}regions(pci, \PYGZdq{}My Chip\PYGZdq{});
        if (err \PYGZlt{} 0) \PYGZob{}
                kfree(chip);
                pci\PYGZus{}disable\PYGZus{}device(pci);
                return err;
        \PYGZcb{}
        chip\PYGZhy{}\PYGZgt{}port = pci\PYGZus{}resource\PYGZus{}start(pci, 0);
        if (request\PYGZus{}irq(pci\PYGZhy{}\PYGZgt{}irq, snd\PYGZus{}mychip\PYGZus{}interrupt,
                        IRQF\PYGZus{}SHARED, KBUILD\PYGZus{}MODNAME, chip)) \PYGZob{}
                printk(KERN\PYGZus{}ERR \PYGZdq{}cannot grab irq \PYGZpc{}d\PYGZbs{}n\PYGZdq{}, pci\PYGZhy{}\PYGZgt{}irq);
                snd\PYGZus{}mychip\PYGZus{}free(chip);
                return \PYGZhy{}EBUSY;
        \PYGZcb{}
        chip\PYGZhy{}\PYGZgt{}irq = pci\PYGZhy{}\PYGZgt{}irq;

        /* (2) initialization of the chip hardware */
        .... /*   (not implemented in this document) */

        err = snd\PYGZus{}device\PYGZus{}new(card, SNDRV\PYGZus{}DEV\PYGZus{}LOWLEVEL, chip, \PYGZam{}ops);
        if (err \PYGZlt{} 0) \PYGZob{}
                snd\PYGZus{}mychip\PYGZus{}free(chip);
                return err;
        \PYGZcb{}

        *rchip = chip;
        return 0;
\PYGZcb{}

/* PCI IDs */
static struct pci\PYGZus{}device\PYGZus{}id snd\PYGZus{}mychip\PYGZus{}ids[] = \PYGZob{}
        \PYGZob{} PCI\PYGZus{}VENDOR\PYGZus{}ID\PYGZus{}FOO, PCI\PYGZus{}DEVICE\PYGZus{}ID\PYGZus{}BAR,
          PCI\PYGZus{}ANY\PYGZus{}ID, PCI\PYGZus{}ANY\PYGZus{}ID, 0, 0, 0, \PYGZcb{},
        ....
        \PYGZob{} 0, \PYGZcb{}
\PYGZcb{};
MODULE\PYGZus{}DEVICE\PYGZus{}TABLE(pci, snd\PYGZus{}mychip\PYGZus{}ids);

/* pci\PYGZus{}driver definition */
static struct pci\PYGZus{}driver driver = \PYGZob{}
        .name = KBUILD\PYGZus{}MODNAME,
        .id\PYGZus{}table = snd\PYGZus{}mychip\PYGZus{}ids,
        .probe = snd\PYGZus{}mychip\PYGZus{}probe,
        .remove = snd\PYGZus{}mychip\PYGZus{}remove,
\PYGZcb{};

/* module initialization */
static int \PYGZus{}\PYGZus{}init alsa\PYGZus{}card\PYGZus{}mychip\PYGZus{}init(void)
\PYGZob{}
        return pci\PYGZus{}register\PYGZus{}driver(\PYGZam{}driver);
\PYGZcb{}

/* module clean up */
static void \PYGZus{}\PYGZus{}exit alsa\PYGZus{}card\PYGZus{}mychip\PYGZus{}exit(void)
\PYGZob{}
        pci\PYGZus{}unregister\PYGZus{}driver(\PYGZam{}driver);
\PYGZcb{}

module\PYGZus{}init(alsa\PYGZus{}card\PYGZus{}mychip\PYGZus{}init)
module\PYGZus{}exit(alsa\PYGZus{}card\PYGZus{}mychip\PYGZus{}exit)

EXPORT\PYGZus{}NO\PYGZus{}SYMBOLS; /* for old kernels only */
\end{Verbatim}


\subsubsection{Some Hafta's}
\label{sound/kernel-api/writing-an-alsa-driver:some-hafta-s}
The allocation of PCI resources is done in the \code{probe} function, and
usually an extra \code{xxx\_create()} function is written for this
purpose.

In the case of PCI devices, you first have to call the
\code{pci\_enable\_device()} function before allocating
resources. Also, you need to set the proper PCI DMA mask to limit the
accessed I/O range. In some cases, you might need to call
\code{pci\_set\_master()} function, too.

Suppose the 28bit mask, and the code to be added would be like:

\begin{Verbatim}[commandchars=\\\{\}]
err = pci\PYGZus{}enable\PYGZus{}device(pci);
if (err \PYGZlt{} 0)
        return err;
if (pci\PYGZus{}set\PYGZus{}dma\PYGZus{}mask(pci, DMA\PYGZus{}BIT\PYGZus{}MASK(28)) \PYGZlt{} 0 \textbar{}\textbar{}
    pci\PYGZus{}set\PYGZus{}consistent\PYGZus{}dma\PYGZus{}mask(pci, DMA\PYGZus{}BIT\PYGZus{}MASK(28)) \PYGZlt{} 0) \PYGZob{}
        printk(KERN\PYGZus{}ERR \PYGZdq{}error to set 28bit mask DMA\PYGZbs{}n\PYGZdq{});
        pci\PYGZus{}disable\PYGZus{}device(pci);
        return \PYGZhy{}ENXIO;
\PYGZcb{}
\end{Verbatim}


\subsubsection{Resource Allocation}
\label{sound/kernel-api/writing-an-alsa-driver:resource-allocation}
The allocation of I/O ports and irqs is done via standard kernel
functions. Unlike ALSA ver.0.5.x., there are no helpers for that. And
these resources must be released in the destructor function (see below).
Also, on ALSA 0.9.x, you don't need to allocate (pseudo-)DMA for PCI
like in ALSA 0.5.x.

Now assume that the PCI device has an I/O port with 8 bytes and an
interrupt. Then \code{struct mychip} will have the
following fields:

\begin{Verbatim}[commandchars=\\\{\}]
struct mychip \PYGZob{}
        struct snd\PYGZus{}card *card;

        unsigned long port;
        int irq;
\PYGZcb{};
\end{Verbatim}

For an I/O port (and also a memory region), you need to have the
resource pointer for the standard resource management. For an irq, you
have to keep only the irq number (integer). But you need to initialize
this number as -1 before actual allocation, since irq 0 is valid. The
port address and its resource pointer can be initialized as null by
\code{kzalloc()} automatically, so you don't have to take care of
resetting them.

The allocation of an I/O port is done like this:

\begin{Verbatim}[commandchars=\\\{\}]
err = pci\PYGZus{}request\PYGZus{}regions(pci, \PYGZdq{}My Chip\PYGZdq{});
if (err \PYGZlt{} 0) \PYGZob{}
        kfree(chip);
        pci\PYGZus{}disable\PYGZus{}device(pci);
        return err;
\PYGZcb{}
chip\PYGZhy{}\PYGZgt{}port = pci\PYGZus{}resource\PYGZus{}start(pci, 0);
\end{Verbatim}

It will reserve the I/O port region of 8 bytes of the given PCI device.
The returned value, \code{chip-\textgreater{}res\_port}, is allocated via
\code{kmalloc()} by \code{request\_region()}. The pointer
must be released via \code{kfree()}, but there is a problem with
this. This issue will be explained later.

The allocation of an interrupt source is done like this:

\begin{Verbatim}[commandchars=\\\{\}]
if (request\PYGZus{}irq(pci\PYGZhy{}\PYGZgt{}irq, snd\PYGZus{}mychip\PYGZus{}interrupt,
                IRQF\PYGZus{}SHARED, KBUILD\PYGZus{}MODNAME, chip)) \PYGZob{}
        printk(KERN\PYGZus{}ERR \PYGZdq{}cannot grab irq \PYGZpc{}d\PYGZbs{}n\PYGZdq{}, pci\PYGZhy{}\PYGZgt{}irq);
        snd\PYGZus{}mychip\PYGZus{}free(chip);
        return \PYGZhy{}EBUSY;
\PYGZcb{}
chip\PYGZhy{}\PYGZgt{}irq = pci\PYGZhy{}\PYGZgt{}irq;
\end{Verbatim}

where \code{snd\_mychip\_interrupt()} is the interrupt handler
defined {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:pcm\string-interface\string-interrupt\string-handler]{\emph{later}}}. Note that
\code{chip-\textgreater{}irq} should be defined only when \code{request\_irq()}
succeeded.

On the PCI bus, interrupts can be shared. Thus, \code{IRQF\_SHARED} is used
as the interrupt flag of \code{request\_irq()}.

The last argument of \code{request\_irq()} is the data pointer
passed to the interrupt handler. Usually, the chip-specific record is
used for that, but you can use what you like, too.

I won't give details about the interrupt handler at this point, but at
least its appearance can be explained now. The interrupt handler looks
usually like the following:

\begin{Verbatim}[commandchars=\\\{\}]
static irqreturn\PYGZus{}t snd\PYGZus{}mychip\PYGZus{}interrupt(int irq, void *dev\PYGZus{}id)
\PYGZob{}
        struct mychip *chip = dev\PYGZus{}id;
        ....
        return IRQ\PYGZus{}HANDLED;
\PYGZcb{}
\end{Verbatim}

Now let's write the corresponding destructor for the resources above.
The role of destructor is simple: disable the hardware (if already
activated) and release the resources. So far, we have no hardware part,
so the disabling code is not written here.

To release the resources, the “check-and-release” method is a safer way.
For the interrupt, do like this:

\begin{Verbatim}[commandchars=\\\{\}]
if (chip\PYGZhy{}\PYGZgt{}irq \PYGZgt{}= 0)
        free\PYGZus{}irq(chip\PYGZhy{}\PYGZgt{}irq, chip);
\end{Verbatim}

Since the irq number can start from 0, you should initialize
\code{chip-\textgreater{}irq} with a negative value (e.g. -1), so that you can check
the validity of the irq number as above.

When you requested I/O ports or memory regions via
\code{pci\_request\_region()} or
\code{pci\_request\_regions()} like in this example, release the
resource(s) using the corresponding function,
\code{pci\_release\_region()} or
\code{pci\_release\_regions()}.

\begin{Verbatim}[commandchars=\\\{\}]
pci\PYGZus{}release\PYGZus{}regions(chip\PYGZhy{}\PYGZgt{}pci);
\end{Verbatim}

When you requested manually via \code{request\_region()} or
\code{request\_mem\_region()}, you can release it via
\code{release\_resource()}. Suppose that you keep the resource
pointer returned from \code{request\_region()} in
chip-\textgreater{}res\_port, the release procedure looks like:

\begin{Verbatim}[commandchars=\\\{\}]
release\PYGZus{}and\PYGZus{}free\PYGZus{}resource(chip\PYGZhy{}\PYGZgt{}res\PYGZus{}port);
\end{Verbatim}

Don't forget to call \code{pci\_disable\_device()} before the
end.

And finally, release the chip-specific record.

\begin{Verbatim}[commandchars=\\\{\}]
kfree(chip);
\end{Verbatim}

We didn't implement the hardware disabling part in the above. If you
need to do this, please note that the destructor may be called even
before the initialization of the chip is completed. It would be better
to have a flag to skip hardware disabling if the hardware was not
initialized yet.

When the chip-data is assigned to the card using
\code{snd\_device\_new()} with \code{SNDRV\_DEV\_LOWLELVEL} , its
destructor is called at the last. That is, it is assured that all other
components like PCMs and controls have already been released. You don't
have to stop PCMs, etc. explicitly, but just call low-level hardware
stopping.

The management of a memory-mapped region is almost as same as the
management of an I/O port. You'll need three fields like the
following:

\begin{Verbatim}[commandchars=\\\{\}]
struct mychip \PYGZob{}
        ....
        unsigned long iobase\PYGZus{}phys;
        void \PYGZus{}\PYGZus{}iomem *iobase\PYGZus{}virt;
\PYGZcb{};
\end{Verbatim}

and the allocation would be like below:

\begin{Verbatim}[commandchars=\\\{\}]
if ((err = pci\PYGZus{}request\PYGZus{}regions(pci, \PYGZdq{}My Chip\PYGZdq{})) \PYGZlt{} 0) \PYGZob{}
        kfree(chip);
        return err;
\PYGZcb{}
chip\PYGZhy{}\PYGZgt{}iobase\PYGZus{}phys = pci\PYGZus{}resource\PYGZus{}start(pci, 0);
chip\PYGZhy{}\PYGZgt{}iobase\PYGZus{}virt = ioremap\PYGZus{}nocache(chip\PYGZhy{}\PYGZgt{}iobase\PYGZus{}phys,
                                    pci\PYGZus{}resource\PYGZus{}len(pci, 0));
\end{Verbatim}

and the corresponding destructor would be:

\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}mychip\PYGZus{}free(struct mychip *chip)
\PYGZob{}
        ....
        if (chip\PYGZhy{}\PYGZgt{}iobase\PYGZus{}virt)
                iounmap(chip\PYGZhy{}\PYGZgt{}iobase\PYGZus{}virt);
        ....
        pci\PYGZus{}release\PYGZus{}regions(chip\PYGZhy{}\PYGZgt{}pci);
        ....
\PYGZcb{}
\end{Verbatim}


\subsubsection{PCI Entries}
\label{sound/kernel-api/writing-an-alsa-driver:pci-entries}
So far, so good. Let's finish the missing PCI stuff. At first, we need a
\code{struct pci\_device\_id} table for
this chipset. It's a table of PCI vendor/device ID number, and some
masks.

For example,

\begin{Verbatim}[commandchars=\\\{\}]
static struct pci\PYGZus{}device\PYGZus{}id snd\PYGZus{}mychip\PYGZus{}ids[] = \PYGZob{}
        \PYGZob{} PCI\PYGZus{}VENDOR\PYGZus{}ID\PYGZus{}FOO, PCI\PYGZus{}DEVICE\PYGZus{}ID\PYGZus{}BAR,
          PCI\PYGZus{}ANY\PYGZus{}ID, PCI\PYGZus{}ANY\PYGZus{}ID, 0, 0, 0, \PYGZcb{},
        ....
        \PYGZob{} 0, \PYGZcb{}
\PYGZcb{};
MODULE\PYGZus{}DEVICE\PYGZus{}TABLE(pci, snd\PYGZus{}mychip\PYGZus{}ids);
\end{Verbatim}

The first and second fields of the \code{struct pci\_device\_id} structure are the vendor and device IDs. If you
have no reason to filter the matching devices, you can leave the
remaining fields as above. The last field of the \code{struct
pci\_device\_id} struct contains private data
for this entry. You can specify any value here, for example, to define
specific operations for supported device IDs. Such an example is found
in the intel8x0 driver.

The last entry of this list is the terminator. You must specify this
all-zero entry.

Then, prepare the \code{struct pci\_driver}
record:

\begin{Verbatim}[commandchars=\\\{\}]
static struct pci\PYGZus{}driver driver = \PYGZob{}
        .name = KBUILD\PYGZus{}MODNAME,
        .id\PYGZus{}table = snd\PYGZus{}mychip\PYGZus{}ids,
        .probe = snd\PYGZus{}mychip\PYGZus{}probe,
        .remove = snd\PYGZus{}mychip\PYGZus{}remove,
\PYGZcb{};
\end{Verbatim}

The \code{probe} and \code{remove} functions have already been defined in
the previous sections. The \code{name} field is the name string of this
device. Note that you must not use a slash “/” in this string.

And at last, the module entries:

\begin{Verbatim}[commandchars=\\\{\}]
static int \PYGZus{}\PYGZus{}init alsa\PYGZus{}card\PYGZus{}mychip\PYGZus{}init(void)
\PYGZob{}
        return pci\PYGZus{}register\PYGZus{}driver(\PYGZam{}driver);
\PYGZcb{}

static void \PYGZus{}\PYGZus{}exit alsa\PYGZus{}card\PYGZus{}mychip\PYGZus{}exit(void)
\PYGZob{}
        pci\PYGZus{}unregister\PYGZus{}driver(\PYGZam{}driver);
\PYGZcb{}

module\PYGZus{}init(alsa\PYGZus{}card\PYGZus{}mychip\PYGZus{}init)
module\PYGZus{}exit(alsa\PYGZus{}card\PYGZus{}mychip\PYGZus{}exit)
\end{Verbatim}

Note that these module entries are tagged with \code{\_\_init} and \code{\_\_exit}
prefixes.

Oh, one thing was forgotten. If you have no exported symbols, you need
to declare it in 2.2 or 2.4 kernels (it's not necessary in 2.6 kernels).

\begin{Verbatim}[commandchars=\\\{\}]
EXPORT\PYGZus{}NO\PYGZus{}SYMBOLS;
\end{Verbatim}

That's all!


\subsection{PCM Interface}
\label{sound/kernel-api/writing-an-alsa-driver:pcm-interface}

\subsubsection{General}
\label{sound/kernel-api/writing-an-alsa-driver:id2}
The PCM middle layer of ALSA is quite powerful and it is only necessary
for each driver to implement the low-level functions to access its
hardware.

For accessing to the PCM layer, you need to include \code{\textless{}sound/pcm.h\textgreater{}}
first. In addition, \code{\textless{}sound/pcm\_params.h\textgreater{}} might be needed if you
access to some functions related with hw\_param.

Each card device can have up to four pcm instances. A pcm instance
corresponds to a pcm device file. The limitation of number of instances
comes only from the available bit size of the Linux's device numbers.
Once when 64bit device number is used, we'll have more pcm instances
available.

A pcm instance consists of pcm playback and capture streams, and each
pcm stream consists of one or more pcm substreams. Some soundcards
support multiple playback functions. For example, emu10k1 has a PCM
playback of 32 stereo substreams. In this case, at each open, a free
substream is (usually) automatically chosen and opened. Meanwhile, when
only one substream exists and it was already opened, the successful open
will either block or error with \code{EAGAIN} according to the file open
mode. But you don't have to care about such details in your driver. The
PCM middle layer will take care of such work.


\subsubsection{Full Code Example}
\label{sound/kernel-api/writing-an-alsa-driver:id3}
The example code below does not include any hardware access routines but
shows only the skeleton, how to build up the PCM interfaces.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}sound/pcm.h\PYGZgt{}
....

/* hardware definition */
static struct snd\PYGZus{}pcm\PYGZus{}hardware snd\PYGZus{}mychip\PYGZus{}playback\PYGZus{}hw = \PYGZob{}
        .info = (SNDRV\PYGZus{}PCM\PYGZus{}INFO\PYGZus{}MMAP \textbar{}
                 SNDRV\PYGZus{}PCM\PYGZus{}INFO\PYGZus{}INTERLEAVED \textbar{}
                 SNDRV\PYGZus{}PCM\PYGZus{}INFO\PYGZus{}BLOCK\PYGZus{}TRANSFER \textbar{}
                 SNDRV\PYGZus{}PCM\PYGZus{}INFO\PYGZus{}MMAP\PYGZus{}VALID),
        .formats =          SNDRV\PYGZus{}PCM\PYGZus{}FMTBIT\PYGZus{}S16\PYGZus{}LE,
        .rates =            SNDRV\PYGZus{}PCM\PYGZus{}RATE\PYGZus{}8000\PYGZus{}48000,
        .rate\PYGZus{}min =         8000,
        .rate\PYGZus{}max =         48000,
        .channels\PYGZus{}min =     2,
        .channels\PYGZus{}max =     2,
        .buffer\PYGZus{}bytes\PYGZus{}max = 32768,
        .period\PYGZus{}bytes\PYGZus{}min = 4096,
        .period\PYGZus{}bytes\PYGZus{}max = 32768,
        .periods\PYGZus{}min =      1,
        .periods\PYGZus{}max =      1024,
\PYGZcb{};

/* hardware definition */
static struct snd\PYGZus{}pcm\PYGZus{}hardware snd\PYGZus{}mychip\PYGZus{}capture\PYGZus{}hw = \PYGZob{}
        .info = (SNDRV\PYGZus{}PCM\PYGZus{}INFO\PYGZus{}MMAP \textbar{}
                 SNDRV\PYGZus{}PCM\PYGZus{}INFO\PYGZus{}INTERLEAVED \textbar{}
                 SNDRV\PYGZus{}PCM\PYGZus{}INFO\PYGZus{}BLOCK\PYGZus{}TRANSFER \textbar{}
                 SNDRV\PYGZus{}PCM\PYGZus{}INFO\PYGZus{}MMAP\PYGZus{}VALID),
        .formats =          SNDRV\PYGZus{}PCM\PYGZus{}FMTBIT\PYGZus{}S16\PYGZus{}LE,
        .rates =            SNDRV\PYGZus{}PCM\PYGZus{}RATE\PYGZus{}8000\PYGZus{}48000,
        .rate\PYGZus{}min =         8000,
        .rate\PYGZus{}max =         48000,
        .channels\PYGZus{}min =     2,
        .channels\PYGZus{}max =     2,
        .buffer\PYGZus{}bytes\PYGZus{}max = 32768,
        .period\PYGZus{}bytes\PYGZus{}min = 4096,
        .period\PYGZus{}bytes\PYGZus{}max = 32768,
        .periods\PYGZus{}min =      1,
        .periods\PYGZus{}max =      1024,
\PYGZcb{};

/* open callback */
static int snd\PYGZus{}mychip\PYGZus{}playback\PYGZus{}open(struct snd\PYGZus{}pcm\PYGZus{}substream *substream)
\PYGZob{}
        struct mychip *chip = snd\PYGZus{}pcm\PYGZus{}substream\PYGZus{}chip(substream);
        struct snd\PYGZus{}pcm\PYGZus{}runtime *runtime = substream\PYGZhy{}\PYGZgt{}runtime;

        runtime\PYGZhy{}\PYGZgt{}hw = snd\PYGZus{}mychip\PYGZus{}playback\PYGZus{}hw;
        /* more hardware\PYGZhy{}initialization will be done here */
        ....
        return 0;
\PYGZcb{}

/* close callback */
static int snd\PYGZus{}mychip\PYGZus{}playback\PYGZus{}close(struct snd\PYGZus{}pcm\PYGZus{}substream *substream)
\PYGZob{}
        struct mychip *chip = snd\PYGZus{}pcm\PYGZus{}substream\PYGZus{}chip(substream);
        /* the hardware\PYGZhy{}specific codes will be here */
        ....
        return 0;

\PYGZcb{}

/* open callback */
static int snd\PYGZus{}mychip\PYGZus{}capture\PYGZus{}open(struct snd\PYGZus{}pcm\PYGZus{}substream *substream)
\PYGZob{}
        struct mychip *chip = snd\PYGZus{}pcm\PYGZus{}substream\PYGZus{}chip(substream);
        struct snd\PYGZus{}pcm\PYGZus{}runtime *runtime = substream\PYGZhy{}\PYGZgt{}runtime;

        runtime\PYGZhy{}\PYGZgt{}hw = snd\PYGZus{}mychip\PYGZus{}capture\PYGZus{}hw;
        /* more hardware\PYGZhy{}initialization will be done here */
        ....
        return 0;
\PYGZcb{}

/* close callback */
static int snd\PYGZus{}mychip\PYGZus{}capture\PYGZus{}close(struct snd\PYGZus{}pcm\PYGZus{}substream *substream)
\PYGZob{}
        struct mychip *chip = snd\PYGZus{}pcm\PYGZus{}substream\PYGZus{}chip(substream);
        /* the hardware\PYGZhy{}specific codes will be here */
        ....
        return 0;

\PYGZcb{}

/* hw\PYGZus{}params callback */
static int snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}hw\PYGZus{}params(struct snd\PYGZus{}pcm\PYGZus{}substream *substream,
                             struct snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}params *hw\PYGZus{}params)
\PYGZob{}
        return snd\PYGZus{}pcm\PYGZus{}lib\PYGZus{}malloc\PYGZus{}pages(substream,
                                   params\PYGZus{}buffer\PYGZus{}bytes(hw\PYGZus{}params));
\PYGZcb{}

/* hw\PYGZus{}free callback */
static int snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}hw\PYGZus{}free(struct snd\PYGZus{}pcm\PYGZus{}substream *substream)
\PYGZob{}
        return snd\PYGZus{}pcm\PYGZus{}lib\PYGZus{}free\PYGZus{}pages(substream);
\PYGZcb{}

/* prepare callback */
static int snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}prepare(struct snd\PYGZus{}pcm\PYGZus{}substream *substream)
\PYGZob{}
        struct mychip *chip = snd\PYGZus{}pcm\PYGZus{}substream\PYGZus{}chip(substream);
        struct snd\PYGZus{}pcm\PYGZus{}runtime *runtime = substream\PYGZhy{}\PYGZgt{}runtime;

        /* set up the hardware with the current configuration
         * for example...
         */
        mychip\PYGZus{}set\PYGZus{}sample\PYGZus{}format(chip, runtime\PYGZhy{}\PYGZgt{}format);
        mychip\PYGZus{}set\PYGZus{}sample\PYGZus{}rate(chip, runtime\PYGZhy{}\PYGZgt{}rate);
        mychip\PYGZus{}set\PYGZus{}channels(chip, runtime\PYGZhy{}\PYGZgt{}channels);
        mychip\PYGZus{}set\PYGZus{}dma\PYGZus{}setup(chip, runtime\PYGZhy{}\PYGZgt{}dma\PYGZus{}addr,
                             chip\PYGZhy{}\PYGZgt{}buffer\PYGZus{}size,
                             chip\PYGZhy{}\PYGZgt{}period\PYGZus{}size);
        return 0;
\PYGZcb{}

/* trigger callback */
static int snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}trigger(struct snd\PYGZus{}pcm\PYGZus{}substream *substream,
                                  int cmd)
\PYGZob{}
        switch (cmd) \PYGZob{}
        case SNDRV\PYGZus{}PCM\PYGZus{}TRIGGER\PYGZus{}START:
                /* do something to start the PCM engine */
                ....
                break;
        case SNDRV\PYGZus{}PCM\PYGZus{}TRIGGER\PYGZus{}STOP:
                /* do something to stop the PCM engine */
                ....
                break;
        default:
                return \PYGZhy{}EINVAL;
        \PYGZcb{}
\PYGZcb{}

/* pointer callback */
static snd\PYGZus{}pcm\PYGZus{}uframes\PYGZus{}t
snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}pointer(struct snd\PYGZus{}pcm\PYGZus{}substream *substream)
\PYGZob{}
        struct mychip *chip = snd\PYGZus{}pcm\PYGZus{}substream\PYGZus{}chip(substream);
        unsigned int current\PYGZus{}ptr;

        /* get the current hardware pointer */
        current\PYGZus{}ptr = mychip\PYGZus{}get\PYGZus{}hw\PYGZus{}pointer(chip);
        return current\PYGZus{}ptr;
\PYGZcb{}

/* operators */
static struct snd\PYGZus{}pcm\PYGZus{}ops snd\PYGZus{}mychip\PYGZus{}playback\PYGZus{}ops = \PYGZob{}
        .open =        snd\PYGZus{}mychip\PYGZus{}playback\PYGZus{}open,
        .close =       snd\PYGZus{}mychip\PYGZus{}playback\PYGZus{}close,
        .ioctl =       snd\PYGZus{}pcm\PYGZus{}lib\PYGZus{}ioctl,
        .hw\PYGZus{}params =   snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}hw\PYGZus{}params,
        .hw\PYGZus{}free =     snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}hw\PYGZus{}free,
        .prepare =     snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}prepare,
        .trigger =     snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}trigger,
        .pointer =     snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}pointer,
\PYGZcb{};

/* operators */
static struct snd\PYGZus{}pcm\PYGZus{}ops snd\PYGZus{}mychip\PYGZus{}capture\PYGZus{}ops = \PYGZob{}
        .open =        snd\PYGZus{}mychip\PYGZus{}capture\PYGZus{}open,
        .close =       snd\PYGZus{}mychip\PYGZus{}capture\PYGZus{}close,
        .ioctl =       snd\PYGZus{}pcm\PYGZus{}lib\PYGZus{}ioctl,
        .hw\PYGZus{}params =   snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}hw\PYGZus{}params,
        .hw\PYGZus{}free =     snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}hw\PYGZus{}free,
        .prepare =     snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}prepare,
        .trigger =     snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}trigger,
        .pointer =     snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}pointer,
\PYGZcb{};

/*
 *  definitions of capture are omitted here...
 */

/* create a pcm device */
static int snd\PYGZus{}mychip\PYGZus{}new\PYGZus{}pcm(struct mychip *chip)
\PYGZob{}
        struct snd\PYGZus{}pcm *pcm;
        int err;

        err = snd\PYGZus{}pcm\PYGZus{}new(chip\PYGZhy{}\PYGZgt{}card, \PYGZdq{}My Chip\PYGZdq{}, 0, 1, 1, \PYGZam{}pcm);
        if (err \PYGZlt{} 0)
                return err;
        pcm\PYGZhy{}\PYGZgt{}private\PYGZus{}data = chip;
        strcpy(pcm\PYGZhy{}\PYGZgt{}name, \PYGZdq{}My Chip\PYGZdq{});
        chip\PYGZhy{}\PYGZgt{}pcm = pcm;
        /* set operators */
        snd\PYGZus{}pcm\PYGZus{}set\PYGZus{}ops(pcm, SNDRV\PYGZus{}PCM\PYGZus{}STREAM\PYGZus{}PLAYBACK,
                        \PYGZam{}snd\PYGZus{}mychip\PYGZus{}playback\PYGZus{}ops);
        snd\PYGZus{}pcm\PYGZus{}set\PYGZus{}ops(pcm, SNDRV\PYGZus{}PCM\PYGZus{}STREAM\PYGZus{}CAPTURE,
                        \PYGZam{}snd\PYGZus{}mychip\PYGZus{}capture\PYGZus{}ops);
        /* pre\PYGZhy{}allocation of buffers */
        /* NOTE: this may fail */
        snd\PYGZus{}pcm\PYGZus{}lib\PYGZus{}preallocate\PYGZus{}pages\PYGZus{}for\PYGZus{}all(pcm, SNDRV\PYGZus{}DMA\PYGZus{}TYPE\PYGZus{}DEV,
                                              snd\PYGZus{}dma\PYGZus{}pci\PYGZus{}data(chip\PYGZhy{}\PYGZgt{}pci),
                                              64*1024, 64*1024);
        return 0;
\PYGZcb{}
\end{Verbatim}


\subsubsection{PCM Constructor}
\label{sound/kernel-api/writing-an-alsa-driver:pcm-constructor}
A pcm instance is allocated by the \code{snd\_pcm\_new()}
function. It would be better to create a constructor for pcm, namely,

\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}mychip\PYGZus{}new\PYGZus{}pcm(struct mychip *chip)
\PYGZob{}
        struct snd\PYGZus{}pcm *pcm;
        int err;

        err = snd\PYGZus{}pcm\PYGZus{}new(chip\PYGZhy{}\PYGZgt{}card, \PYGZdq{}My Chip\PYGZdq{}, 0, 1, 1, \PYGZam{}pcm);
        if (err \PYGZlt{} 0)
                return err;
        pcm\PYGZhy{}\PYGZgt{}private\PYGZus{}data = chip;
        strcpy(pcm\PYGZhy{}\PYGZgt{}name, \PYGZdq{}My Chip\PYGZdq{});
        chip\PYGZhy{}\PYGZgt{}pcm = pcm;
        ....
        return 0;
\PYGZcb{}
\end{Verbatim}

The \code{snd\_pcm\_new()} function takes four arguments. The
first argument is the card pointer to which this pcm is assigned, and
the second is the ID string.

The third argument (\code{index}, 0 in the above) is the index of this new
pcm. It begins from zero. If you create more than one pcm instances,
specify the different numbers in this argument. For example, \code{index =
1} for the second PCM device.

The fourth and fifth arguments are the number of substreams for playback
and capture, respectively. Here 1 is used for both arguments. When no
playback or capture substreams are available, pass 0 to the
corresponding argument.

If a chip supports multiple playbacks or captures, you can specify more
numbers, but they must be handled properly in open/close, etc.
callbacks. When you need to know which substream you are referring to,
then it can be obtained from \code{struct snd\_pcm\_substream} data passed to each callback as follows:

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}pcm\PYGZus{}substream *substream;
int index = substream\PYGZhy{}\PYGZgt{}number;
\end{Verbatim}

After the pcm is created, you need to set operators for each pcm stream.

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}pcm\PYGZus{}set\PYGZus{}ops(pcm, SNDRV\PYGZus{}PCM\PYGZus{}STREAM\PYGZus{}PLAYBACK,
                \PYGZam{}snd\PYGZus{}mychip\PYGZus{}playback\PYGZus{}ops);
snd\PYGZus{}pcm\PYGZus{}set\PYGZus{}ops(pcm, SNDRV\PYGZus{}PCM\PYGZus{}STREAM\PYGZus{}CAPTURE,
                \PYGZam{}snd\PYGZus{}mychip\PYGZus{}capture\PYGZus{}ops);
\end{Verbatim}

The operators are defined typically like this:

\begin{Verbatim}[commandchars=\\\{\}]
static struct snd\PYGZus{}pcm\PYGZus{}ops snd\PYGZus{}mychip\PYGZus{}playback\PYGZus{}ops = \PYGZob{}
        .open =        snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}open,
        .close =       snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}close,
        .ioctl =       snd\PYGZus{}pcm\PYGZus{}lib\PYGZus{}ioctl,
        .hw\PYGZus{}params =   snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}hw\PYGZus{}params,
        .hw\PYGZus{}free =     snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}hw\PYGZus{}free,
        .prepare =     snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}prepare,
        .trigger =     snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}trigger,
        .pointer =     snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}pointer,
\PYGZcb{};
\end{Verbatim}

All the callbacks are described in the {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:operators]{\emph{Operators}}} subsection.

After setting the operators, you probably will want to pre-allocate the
buffer. For the pre-allocation, simply call the following:

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}pcm\PYGZus{}lib\PYGZus{}preallocate\PYGZus{}pages\PYGZus{}for\PYGZus{}all(pcm, SNDRV\PYGZus{}DMA\PYGZus{}TYPE\PYGZus{}DEV,
                                      snd\PYGZus{}dma\PYGZus{}pci\PYGZus{}data(chip\PYGZhy{}\PYGZgt{}pci),
                                      64*1024, 64*1024);
\end{Verbatim}

It will allocate a buffer up to 64kB as default. Buffer management
details will be described in the later section {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:buffer\string-and\string-memory\string-management]{\emph{Buffer and Memory
Management}}}.

Additionally, you can set some extra information for this pcm in
\code{pcm-\textgreater{}info\_flags}. The available values are defined as
\code{SNDRV\_PCM\_INFO\_XXX} in \code{\textless{}sound/asound.h\textgreater{}}, which is used for the
hardware definition (described later). When your soundchip supports only
half-duplex, specify like this:

\begin{Verbatim}[commandchars=\\\{\}]
pcm\PYGZhy{}\PYGZgt{}info\PYGZus{}flags = SNDRV\PYGZus{}PCM\PYGZus{}INFO\PYGZus{}HALF\PYGZus{}DUPLEX;
\end{Verbatim}


\subsubsection{... And the Destructor?}
\label{sound/kernel-api/writing-an-alsa-driver:and-the-destructor}
The destructor for a pcm instance is not always necessary. Since the pcm
device will be released by the middle layer code automatically, you
don't have to call the destructor explicitly.

The destructor would be necessary if you created special records
internally and needed to release them. In such a case, set the
destructor function to \code{pcm-\textgreater{}private\_free}:

\begin{Verbatim}[commandchars=\\\{\}]
static void mychip\PYGZus{}pcm\PYGZus{}free(struct snd\PYGZus{}pcm *pcm)
\PYGZob{}
        struct mychip *chip = snd\PYGZus{}pcm\PYGZus{}chip(pcm);
        /* free your own data */
        kfree(chip\PYGZhy{}\PYGZgt{}my\PYGZus{}private\PYGZus{}pcm\PYGZus{}data);
        /* do what you like else */
        ....
\PYGZcb{}

static int snd\PYGZus{}mychip\PYGZus{}new\PYGZus{}pcm(struct mychip *chip)
\PYGZob{}
        struct snd\PYGZus{}pcm *pcm;
        ....
        /* allocate your own data */
        chip\PYGZhy{}\PYGZgt{}my\PYGZus{}private\PYGZus{}pcm\PYGZus{}data = kmalloc(...);
        /* set the destructor */
        pcm\PYGZhy{}\PYGZgt{}private\PYGZus{}data = chip;
        pcm\PYGZhy{}\PYGZgt{}private\PYGZus{}free = mychip\PYGZus{}pcm\PYGZus{}free;
        ....
\PYGZcb{}
\end{Verbatim}


\subsubsection{Runtime Pointer - The Chest of PCM Information}
\label{sound/kernel-api/writing-an-alsa-driver:runtime-pointer-the-chest-of-pcm-information}
When the PCM substream is opened, a PCM runtime instance is allocated
and assigned to the substream. This pointer is accessible via
\code{substream-\textgreater{}runtime}. This runtime pointer holds most information you
need to control the PCM: the copy of hw\_params and sw\_params
configurations, the buffer pointers, mmap records, spinlocks, etc.

The definition of runtime instance is found in \code{\textless{}sound/pcm.h\textgreater{}}. Here
are the contents of this file:

\begin{Verbatim}[commandchars=\\\{\}]
struct \PYGZus{}snd\PYGZus{}pcm\PYGZus{}runtime \PYGZob{}
        /* \PYGZhy{}\PYGZhy{} Status \PYGZhy{}\PYGZhy{} */
        struct snd\PYGZus{}pcm\PYGZus{}substream *trigger\PYGZus{}master;
        snd\PYGZus{}timestamp\PYGZus{}t trigger\PYGZus{}tstamp;       /* trigger timestamp */
        int overrange;
        snd\PYGZus{}pcm\PYGZus{}uframes\PYGZus{}t avail\PYGZus{}max;
        snd\PYGZus{}pcm\PYGZus{}uframes\PYGZus{}t hw\PYGZus{}ptr\PYGZus{}base;        /* Position at buffer restart */
        snd\PYGZus{}pcm\PYGZus{}uframes\PYGZus{}t hw\PYGZus{}ptr\PYGZus{}interrupt; /* Position at interrupt time*/

        /* \PYGZhy{}\PYGZhy{} HW params \PYGZhy{}\PYGZhy{} */
        snd\PYGZus{}pcm\PYGZus{}access\PYGZus{}t access;      /* access mode */
        snd\PYGZus{}pcm\PYGZus{}format\PYGZus{}t format;      /* SNDRV\PYGZus{}PCM\PYGZus{}FORMAT\PYGZus{}* */
        snd\PYGZus{}pcm\PYGZus{}subformat\PYGZus{}t subformat;        /* subformat */
        unsigned int rate;            /* rate in Hz */
        unsigned int channels;                /* channels */
        snd\PYGZus{}pcm\PYGZus{}uframes\PYGZus{}t period\PYGZus{}size;        /* period size */
        unsigned int periods;         /* periods */
        snd\PYGZus{}pcm\PYGZus{}uframes\PYGZus{}t buffer\PYGZus{}size;        /* buffer size */
        unsigned int tick\PYGZus{}time;               /* tick time */
        snd\PYGZus{}pcm\PYGZus{}uframes\PYGZus{}t min\PYGZus{}align;  /* Min alignment for the format */
        size\PYGZus{}t byte\PYGZus{}align;
        unsigned int frame\PYGZus{}bits;
        unsigned int sample\PYGZus{}bits;
        unsigned int info;
        unsigned int rate\PYGZus{}num;
        unsigned int rate\PYGZus{}den;

        /* \PYGZhy{}\PYGZhy{} SW params \PYGZhy{}\PYGZhy{} */
        struct timespec tstamp\PYGZus{}mode;  /* mmap timestamp is updated */
        unsigned int period\PYGZus{}step;
        unsigned int sleep\PYGZus{}min;               /* min ticks to sleep */
        snd\PYGZus{}pcm\PYGZus{}uframes\PYGZus{}t start\PYGZus{}threshold;
        snd\PYGZus{}pcm\PYGZus{}uframes\PYGZus{}t stop\PYGZus{}threshold;
        snd\PYGZus{}pcm\PYGZus{}uframes\PYGZus{}t silence\PYGZus{}threshold; /* Silence filling happens when
                                                noise is nearest than this */
        snd\PYGZus{}pcm\PYGZus{}uframes\PYGZus{}t silence\PYGZus{}size;       /* Silence filling size */
        snd\PYGZus{}pcm\PYGZus{}uframes\PYGZus{}t boundary;   /* pointers wrap point */

        snd\PYGZus{}pcm\PYGZus{}uframes\PYGZus{}t silenced\PYGZus{}start;
        snd\PYGZus{}pcm\PYGZus{}uframes\PYGZus{}t silenced\PYGZus{}size;

        snd\PYGZus{}pcm\PYGZus{}sync\PYGZus{}id\PYGZus{}t sync;               /* hardware synchronization ID */

        /* \PYGZhy{}\PYGZhy{} mmap \PYGZhy{}\PYGZhy{} */
        volatile struct snd\PYGZus{}pcm\PYGZus{}mmap\PYGZus{}status *status;
        volatile struct snd\PYGZus{}pcm\PYGZus{}mmap\PYGZus{}control *control;
        atomic\PYGZus{}t mmap\PYGZus{}count;

        /* \PYGZhy{}\PYGZhy{} locking / scheduling \PYGZhy{}\PYGZhy{} */
        spinlock\PYGZus{}t lock;
        wait\PYGZus{}queue\PYGZus{}head\PYGZus{}t sleep;
        struct timer\PYGZus{}list tick\PYGZus{}timer;
        struct fasync\PYGZus{}struct *fasync;

        /* \PYGZhy{}\PYGZhy{} private section \PYGZhy{}\PYGZhy{} */
        void *private\PYGZus{}data;
        void (*private\PYGZus{}free)(struct snd\PYGZus{}pcm\PYGZus{}runtime *runtime);

        /* \PYGZhy{}\PYGZhy{} hardware description \PYGZhy{}\PYGZhy{} */
        struct snd\PYGZus{}pcm\PYGZus{}hardware hw;
        struct snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}constraints hw\PYGZus{}constraints;

        /* \PYGZhy{}\PYGZhy{} timer \PYGZhy{}\PYGZhy{} */
        unsigned int timer\PYGZus{}resolution;        /* timer resolution */

        /* \PYGZhy{}\PYGZhy{} DMA \PYGZhy{}\PYGZhy{} */
        unsigned char *dma\PYGZus{}area;      /* DMA area */
        dma\PYGZus{}addr\PYGZus{}t dma\PYGZus{}addr;          /* physical bus address (not accessible from main CPU) */
        size\PYGZus{}t dma\PYGZus{}bytes;             /* size of DMA area */

        struct snd\PYGZus{}dma\PYGZus{}buffer *dma\PYGZus{}buffer\PYGZus{}p;  /* allocated buffer */

\PYGZsh{}if defined(CONFIG\PYGZus{}SND\PYGZus{}PCM\PYGZus{}OSS) \textbar{}\textbar{} defined(CONFIG\PYGZus{}SND\PYGZus{}PCM\PYGZus{}OSS\PYGZus{}MODULE)
        /* \PYGZhy{}\PYGZhy{} OSS things \PYGZhy{}\PYGZhy{} */
        struct snd\PYGZus{}pcm\PYGZus{}oss\PYGZus{}runtime oss;
\PYGZsh{}endif
\PYGZcb{};
\end{Verbatim}

For the operators (callbacks) of each sound driver, most of these
records are supposed to be read-only. Only the PCM middle-layer changes
/ updates them. The exceptions are the hardware description (hw) DMA
buffer information and the private data. Besides, if you use the
standard buffer allocation method via
\code{snd\_pcm\_lib\_malloc\_pages()}, you don't need to set the
DMA buffer information by yourself.

In the sections below, important records are explained.


\paragraph{Hardware Description}
\label{sound/kernel-api/writing-an-alsa-driver:hardware-description}
The hardware descriptor (\code{struct snd\_pcm\_hardware}) contains the definitions of the fundamental
hardware configuration. Above all, you'll need to define this in the
{\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:pcm\string-open\string-callback]{\emph{PCM open callback}}}. Note that the runtime instance holds the copy of
the descriptor, not the pointer to the existing descriptor. That is,
in the open callback, you can modify the copied descriptor
(\code{runtime-\textgreater{}hw}) as you need. For example, if the maximum number of
channels is 1 only on some chip models, you can still use the same
hardware descriptor and change the channels\_max later:

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}pcm\PYGZus{}runtime *runtime = substream\PYGZhy{}\PYGZgt{}runtime;
...
runtime\PYGZhy{}\PYGZgt{}hw = snd\PYGZus{}mychip\PYGZus{}playback\PYGZus{}hw; /* common definition */
if (chip\PYGZhy{}\PYGZgt{}model == VERY\PYGZus{}OLD\PYGZus{}ONE)
        runtime\PYGZhy{}\PYGZgt{}hw.channels\PYGZus{}max = 1;
\end{Verbatim}

Typically, you'll have a hardware descriptor as below:

\begin{Verbatim}[commandchars=\\\{\}]
static struct snd\PYGZus{}pcm\PYGZus{}hardware snd\PYGZus{}mychip\PYGZus{}playback\PYGZus{}hw = \PYGZob{}
        .info = (SNDRV\PYGZus{}PCM\PYGZus{}INFO\PYGZus{}MMAP \textbar{}
                 SNDRV\PYGZus{}PCM\PYGZus{}INFO\PYGZus{}INTERLEAVED \textbar{}
                 SNDRV\PYGZus{}PCM\PYGZus{}INFO\PYGZus{}BLOCK\PYGZus{}TRANSFER \textbar{}
                 SNDRV\PYGZus{}PCM\PYGZus{}INFO\PYGZus{}MMAP\PYGZus{}VALID),
        .formats =          SNDRV\PYGZus{}PCM\PYGZus{}FMTBIT\PYGZus{}S16\PYGZus{}LE,
        .rates =            SNDRV\PYGZus{}PCM\PYGZus{}RATE\PYGZus{}8000\PYGZus{}48000,
        .rate\PYGZus{}min =         8000,
        .rate\PYGZus{}max =         48000,
        .channels\PYGZus{}min =     2,
        .channels\PYGZus{}max =     2,
        .buffer\PYGZus{}bytes\PYGZus{}max = 32768,
        .period\PYGZus{}bytes\PYGZus{}min = 4096,
        .period\PYGZus{}bytes\PYGZus{}max = 32768,
        .periods\PYGZus{}min =      1,
        .periods\PYGZus{}max =      1024,
\PYGZcb{};
\end{Verbatim}
\begin{itemize}
\item {} 
The \code{info} field contains the type and capabilities of this
pcm. The bit flags are defined in \code{\textless{}sound/asound.h\textgreater{}} as
\code{SNDRV\_PCM\_INFO\_XXX}. Here, at least, you have to specify whether
the mmap is supported and which interleaved format is
supported. When the hardware supports mmap, add the
\code{SNDRV\_PCM\_INFO\_MMAP} flag here. When the hardware supports the
interleaved or the non-interleaved formats,
\code{SNDRV\_PCM\_INFO\_INTERLEAVED} or \code{SNDRV\_PCM\_INFO\_NONINTERLEAVED}
flag must be set, respectively. If both are supported, you can set
both, too.

In the above example, \code{MMAP\_VALID} and \code{BLOCK\_TRANSFER} are
specified for the OSS mmap mode. Usually both are set. Of course,
\code{MMAP\_VALID} is set only if the mmap is really supported.

The other possible flags are \code{SNDRV\_PCM\_INFO\_PAUSE} and
\code{SNDRV\_PCM\_INFO\_RESUME}. The \code{PAUSE} bit means that the pcm
supports the “pause” operation, while the \code{RESUME} bit means that
the pcm supports the full “suspend/resume” operation. If the
\code{PAUSE} flag is set, the \code{trigger} callback below must handle
the corresponding (pause push/release) commands. The suspend/resume
trigger commands can be defined even without the \code{RESUME}
flag. See {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:power\string-management]{\emph{Power Management}}} section for details.

When the PCM substreams can be synchronized (typically,
synchronized start/stop of a playback and a capture streams), you
can give \code{SNDRV\_PCM\_INFO\_SYNC\_START}, too. In this case, you'll
need to check the linked-list of PCM substreams in the trigger
callback. This will be described in the later section.

\item {} 
\code{formats} field contains the bit-flags of supported formats
(\code{SNDRV\_PCM\_FMTBIT\_XXX}). If the hardware supports more than one
format, give all or'ed bits. In the example above, the signed 16bit
little-endian format is specified.

\item {} 
\code{rates} field contains the bit-flags of supported rates
(\code{SNDRV\_PCM\_RATE\_XXX}). When the chip supports continuous rates,
pass \code{CONTINUOUS} bit additionally. The pre-defined rate bits are
provided only for typical rates. If your chip supports
unconventional rates, you need to add the \code{KNOT} bit and set up
the hardware constraint manually (explained later).

\item {} 
\code{rate\_min} and \code{rate\_max} define the minimum and maximum sample
rate. This should correspond somehow to \code{rates} bits.

\item {} 
\code{channel\_min} and \code{channel\_max} define, as you might already
expected, the minimum and maximum number of channels.

\item {} 
\code{buffer\_bytes\_max} defines the maximum buffer size in
bytes. There is no \code{buffer\_bytes\_min} field, since it can be
calculated from the minimum period size and the minimum number of
periods. Meanwhile, \code{period\_bytes\_min} and define the minimum and
maximum size of the period in bytes. \code{periods\_max} and
\code{periods\_min} define the maximum and minimum number of periods in
the buffer.

The “period” is a term that corresponds to a fragment in the OSS
world. The period defines the size at which a PCM interrupt is
generated. This size strongly depends on the hardware. Generally,
the smaller period size will give you more interrupts, that is,
more controls. In the case of capture, this size defines the input
latency. On the other hand, the whole buffer size defines the
output latency for the playback direction.

\item {} 
There is also a field \code{fifo\_size}. This specifies the size of the
hardware FIFO, but currently it is neither used in the driver nor
in the alsa-lib. So, you can ignore this field.

\end{itemize}


\paragraph{PCM Configurations}
\label{sound/kernel-api/writing-an-alsa-driver:pcm-configurations}
Ok, let's go back again to the PCM runtime records. The most
frequently referred records in the runtime instance are the PCM
configurations. The PCM configurations are stored in the runtime
instance after the application sends \code{hw\_params} data via
alsa-lib. There are many fields copied from hw\_params and sw\_params
structs. For example, \code{format} holds the format type chosen by the
application. This field contains the enum value
\code{SNDRV\_PCM\_FORMAT\_XXX}.

One thing to be noted is that the configured buffer and period sizes
are stored in “frames” in the runtime. In the ALSA world, \code{1 frame =
channels \textbackslash{}* samples-size}. For conversion between frames and bytes,
you can use the \code{frames\_to\_bytes()} and
\code{bytes\_to\_frames()} helper functions.

\begin{Verbatim}[commandchars=\\\{\}]
period\PYGZus{}bytes = frames\PYGZus{}to\PYGZus{}bytes(runtime, runtime\PYGZhy{}\PYGZgt{}period\PYGZus{}size);
\end{Verbatim}

Also, many software parameters (sw\_params) are stored in frames, too.
Please check the type of the field. \code{snd\_pcm\_uframes\_t} is for the
frames as unsigned integer while \code{snd\_pcm\_sframes\_t} is for the
frames as signed integer.


\paragraph{DMA Buffer Information}
\label{sound/kernel-api/writing-an-alsa-driver:dma-buffer-information}
The DMA buffer is defined by the following four fields, \code{dma\_area},
\code{dma\_addr}, \code{dma\_bytes} and \code{dma\_private}. The \code{dma\_area}
holds the buffer pointer (the logical address). You can call
\code{memcpy()} from/to this pointer. Meanwhile, \code{dma\_addr} holds
the physical address of the buffer. This field is specified only when
the buffer is a linear buffer. \code{dma\_bytes} holds the size of buffer
in bytes. \code{dma\_private} is used for the ALSA DMA allocator.

If you use a standard ALSA function,
\code{snd\_pcm\_lib\_malloc\_pages()}, for allocating the buffer,
these fields are set by the ALSA middle layer, and you should \emph{not}
change them by yourself. You can read them but not write them. On the
other hand, if you want to allocate the buffer by yourself, you'll
need to manage it in hw\_params callback. At least, \code{dma\_bytes} is
mandatory. \code{dma\_area} is necessary when the buffer is mmapped. If
your driver doesn't support mmap, this field is not
necessary. \code{dma\_addr} is also optional. You can use dma\_private as
you like, too.


\paragraph{Running Status}
\label{sound/kernel-api/writing-an-alsa-driver:running-status}
The running status can be referred via \code{runtime-\textgreater{}status}. This is
the pointer to the \code{struct snd\_pcm\_mmap\_status} record. For example, you can get the current
DMA hardware pointer via \code{runtime-\textgreater{}status-\textgreater{}hw\_ptr}.

The DMA application pointer can be referred via \code{runtime-\textgreater{}control},
which points to the \code{struct snd\_pcm\_mmap\_control} record. However, accessing directly to
this value is not recommended.


\paragraph{Private Data}
\label{sound/kernel-api/writing-an-alsa-driver:private-data}
You can allocate a record for the substream and store it in
\code{runtime-\textgreater{}private\_data}. Usually, this is done in the {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:pcm\string-open\string-callback]{\emph{PCM open
callback}}}. Don't mix this with \code{pcm-\textgreater{}private\_data}. The
\code{pcm-\textgreater{}private\_data} usually points to the chip instance assigned
statically at the creation of PCM, while the \code{runtime-\textgreater{}private\_data}
points to a dynamic data structure created at the PCM open
callback.

\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}xxx\PYGZus{}open(struct snd\PYGZus{}pcm\PYGZus{}substream *substream)
\PYGZob{}
        struct my\PYGZus{}pcm\PYGZus{}data *data;
        ....
        data = kmalloc(sizeof(*data), GFP\PYGZus{}KERNEL);
        substream\PYGZhy{}\PYGZgt{}runtime\PYGZhy{}\PYGZgt{}private\PYGZus{}data = data;
        ....
\PYGZcb{}
\end{Verbatim}

The allocated object must be released in the {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:close\string-callback]{\emph{close callback}}}.


\subsubsection{Operators}
\label{sound/kernel-api/writing-an-alsa-driver:operators}
OK, now let me give details about each pcm callback (\code{ops}). In
general, every callback must return 0 if successful, or a negative
error number such as \code{-EINVAL}. To choose an appropriate error
number, it is advised to check what value other parts of the kernel
return when the same kind of request fails.

The callback function takes at least the argument with \code{struct
snd\_pcm\_substream} pointer. To retrieve the chip
record from the given substream instance, you can use the following
macro.

\begin{Verbatim}[commandchars=\\\{\}]
int xxx() \PYGZob{}
        struct mychip *chip = snd\PYGZus{}pcm\PYGZus{}substream\PYGZus{}chip(substream);
        ....
\PYGZcb{}
\end{Verbatim}

The macro reads \code{substream-\textgreater{}private\_data}, which is a copy of
\code{pcm-\textgreater{}private\_data}. You can override the former if you need to
assign different data records per PCM substream. For example, the
cmi8330 driver assigns different \code{private\_data} for playback and
capture directions, because it uses two different codecs (SB- and
AD-compatible) for different directions.


\paragraph{PCM open callback}
\label{sound/kernel-api/writing-an-alsa-driver:pcm-open-callback}
\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}xxx\PYGZus{}open(struct snd\PYGZus{}pcm\PYGZus{}substream *substream);
\end{Verbatim}

This is called when a pcm substream is opened.

At least, here you have to initialize the \code{runtime-\textgreater{}hw}
record. Typically, this is done by like this:

\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}xxx\PYGZus{}open(struct snd\PYGZus{}pcm\PYGZus{}substream *substream)
\PYGZob{}
        struct mychip *chip = snd\PYGZus{}pcm\PYGZus{}substream\PYGZus{}chip(substream);
        struct snd\PYGZus{}pcm\PYGZus{}runtime *runtime = substream\PYGZhy{}\PYGZgt{}runtime;

        runtime\PYGZhy{}\PYGZgt{}hw = snd\PYGZus{}mychip\PYGZus{}playback\PYGZus{}hw;
        return 0;
\PYGZcb{}
\end{Verbatim}

where \code{snd\_mychip\_playback\_hw} is the pre-defined hardware
description.

You can allocate a private data in this callback, as described in
{\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:private\string-data]{\emph{Private Data}}} section.

If the hardware configuration needs more constraints, set the hardware
constraints here, too. See {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:constraints]{\emph{Constraints}}} for more details.


\paragraph{close callback}
\label{sound/kernel-api/writing-an-alsa-driver:close-callback}
\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}xxx\PYGZus{}close(struct snd\PYGZus{}pcm\PYGZus{}substream *substream);
\end{Verbatim}

Obviously, this is called when a pcm substream is closed.

Any private instance for a pcm substream allocated in the \code{open}
callback will be released here.

\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}xxx\PYGZus{}close(struct snd\PYGZus{}pcm\PYGZus{}substream *substream)
\PYGZob{}
        ....
        kfree(substream\PYGZhy{}\PYGZgt{}runtime\PYGZhy{}\PYGZgt{}private\PYGZus{}data);
        ....
\PYGZcb{}
\end{Verbatim}


\paragraph{ioctl callback}
\label{sound/kernel-api/writing-an-alsa-driver:ioctl-callback}
This is used for any special call to pcm ioctls. But usually you can
pass a generic ioctl callback, \code{snd\_pcm\_lib\_ioctl()}.


\paragraph{hw\_params callback}
\label{sound/kernel-api/writing-an-alsa-driver:hw-params-callback}
\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}xxx\PYGZus{}hw\PYGZus{}params(struct snd\PYGZus{}pcm\PYGZus{}substream *substream,
                             struct snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}params *hw\PYGZus{}params);
\end{Verbatim}

This is called when the hardware parameter (\code{hw\_params}) is set up
by the application, that is, once when the buffer size, the period
size, the format, etc. are defined for the pcm substream.

Many hardware setups should be done in this callback, including the
allocation of buffers.

Parameters to be initialized are retrieved by
\code{params\_xxx()} macros. To allocate buffer, you can call a
helper function,

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}pcm\PYGZus{}lib\PYGZus{}malloc\PYGZus{}pages(substream, params\PYGZus{}buffer\PYGZus{}bytes(hw\PYGZus{}params));
\end{Verbatim}

\code{snd\_pcm\_lib\_malloc\_pages()} is available only when the
DMA buffers have been pre-allocated. See the section {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:buffer\string-types]{\emph{Buffer Types}}}
for more details.

Note that this and \code{prepare} callbacks may be called multiple times
per initialization. For example, the OSS emulation may call these
callbacks at each change via its ioctl.

Thus, you need to be careful not to allocate the same buffers many
times, which will lead to memory leaks! Calling the helper function
above many times is OK. It will release the previous buffer
automatically when it was already allocated.

Another note is that this callback is non-atomic (schedulable) as
default, i.e. when no \code{nonatomic} flag set. This is important,
because the \code{trigger} callback is atomic (non-schedulable). That is,
mutexes or any schedule-related functions are not available in
\code{trigger} callback. Please see the subsection {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:atomicity]{\emph{Atomicity}}} for
details.


\paragraph{hw\_free callback}
\label{sound/kernel-api/writing-an-alsa-driver:hw-free-callback}
\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}xxx\PYGZus{}hw\PYGZus{}free(struct snd\PYGZus{}pcm\PYGZus{}substream *substream);
\end{Verbatim}

This is called to release the resources allocated via
\code{hw\_params}. For example, releasing the buffer via
\code{snd\_pcm\_lib\_malloc\_pages()} is done by calling the
following:

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}pcm\PYGZus{}lib\PYGZus{}free\PYGZus{}pages(substream);
\end{Verbatim}

This function is always called before the close callback is called.
Also, the callback may be called multiple times, too. Keep track
whether the resource was already released.


\paragraph{prepare callback}
\label{sound/kernel-api/writing-an-alsa-driver:prepare-callback}
\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}xxx\PYGZus{}prepare(struct snd\PYGZus{}pcm\PYGZus{}substream *substream);
\end{Verbatim}

This callback is called when the pcm is “prepared”. You can set the
format type, sample rate, etc. here. The difference from \code{hw\_params}
is that the \code{prepare} callback will be called each time
{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_pcm_prepare]{\emph{\code{snd\_pcm\_prepare()}}}} is called, i.e. when recovering after
underruns, etc.

Note that this callback is now non-atomic. You can use
schedule-related functions safely in this callback.

In this and the following callbacks, you can refer to the values via
the runtime record, \code{substream-\textgreater{}runtime}. For example, to get the
current rate, format or channels, access to \code{runtime-\textgreater{}rate},
\code{runtime-\textgreater{}format} or \code{runtime-\textgreater{}channels}, respectively. The
physical address of the allocated buffer is set to
\code{runtime-\textgreater{}dma\_area}. The buffer and period sizes are in
\code{runtime-\textgreater{}buffer\_size} and \code{runtime-\textgreater{}period\_size}, respectively.

Be careful that this callback will be called many times at each setup,
too.


\paragraph{trigger callback}
\label{sound/kernel-api/writing-an-alsa-driver:trigger-callback}
\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}xxx\PYGZus{}trigger(struct snd\PYGZus{}pcm\PYGZus{}substream *substream, int cmd);
\end{Verbatim}

This is called when the pcm is started, stopped or paused.

Which action is specified in the second argument,
\code{SNDRV\_PCM\_TRIGGER\_XXX} in \code{\textless{}sound/pcm.h\textgreater{}}. At least, the \code{START}
and \code{STOP} commands must be defined in this callback.

\begin{Verbatim}[commandchars=\\\{\}]
switch (cmd) \PYGZob{}
case SNDRV\PYGZus{}PCM\PYGZus{}TRIGGER\PYGZus{}START:
        /* do something to start the PCM engine */
        break;
case SNDRV\PYGZus{}PCM\PYGZus{}TRIGGER\PYGZus{}STOP:
        /* do something to stop the PCM engine */
        break;
default:
        return \PYGZhy{}EINVAL;
\PYGZcb{}
\end{Verbatim}

When the pcm supports the pause operation (given in the info field of
the hardware table), the \code{PAUSE\_PUSH} and \code{PAUSE\_RELEASE} commands
must be handled here, too. The former is the command to pause the pcm,
and the latter to restart the pcm again.

When the pcm supports the suspend/resume operation, regardless of full
or partial suspend/resume support, the \code{SUSPEND} and \code{RESUME}
commands must be handled, too. These commands are issued when the
power-management status is changed. Obviously, the \code{SUSPEND} and
\code{RESUME} commands suspend and resume the pcm substream, and usually,
they are identical to the \code{STOP} and \code{START} commands, respectively.
See the {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:power\string-management]{\emph{Power Management}}} section for details.

As mentioned, this callback is atomic as default unless \code{nonatomic}
flag set, and you cannot call functions which may sleep. The
\code{trigger} callback should be as minimal as possible, just really
triggering the DMA. The other stuff should be initialized
\code{hw\_params} and \code{prepare} callbacks properly beforehand.


\paragraph{pointer callback}
\label{sound/kernel-api/writing-an-alsa-driver:pointer-callback}
\begin{Verbatim}[commandchars=\\\{\}]
static snd\PYGZus{}pcm\PYGZus{}uframes\PYGZus{}t snd\PYGZus{}xxx\PYGZus{}pointer(struct snd\PYGZus{}pcm\PYGZus{}substream *substream)
\end{Verbatim}

This callback is called when the PCM middle layer inquires the current
hardware position on the buffer. The position must be returned in
frames, ranging from 0 to \code{buffer\_size - 1}.

This is called usually from the buffer-update routine in the pcm
middle layer, which is invoked when \code{snd\_pcm\_period\_elapsed()}
is called in the interrupt routine. Then the pcm middle layer updates
the position and calculates the available space, and wakes up the
sleeping poll threads, etc.

This callback is also atomic as default.


\paragraph{copy\_user, copy\_kernel and fill\_silence ops}
\label{sound/kernel-api/writing-an-alsa-driver:copy-user-copy-kernel-and-fill-silence-ops}
These callbacks are not mandatory, and can be omitted in most cases.
These callbacks are used when the hardware buffer cannot be in the
normal memory space. Some chips have their own buffer on the hardware
which is not mappable. In such a case, you have to transfer the data
manually from the memory buffer to the hardware buffer. Or, if the
buffer is non-contiguous on both physical and virtual memory spaces,
these callbacks must be defined, too.

If these two callbacks are defined, copy and set-silence operations
are done by them. The detailed will be described in the later section
{\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:buffer\string-and\string-memory\string-management]{\emph{Buffer and Memory Management}}}.


\paragraph{ack callback}
\label{sound/kernel-api/writing-an-alsa-driver:ack-callback}
This callback is also not mandatory. This callback is called when the
\code{appl\_ptr} is updated in read or write operations. Some drivers like
emu10k1-fx and cs46xx need to track the current \code{appl\_ptr} for the
internal buffer, and this callback is useful only for such a purpose.

This callback is atomic as default.


\paragraph{page callback}
\label{sound/kernel-api/writing-an-alsa-driver:page-callback}
This callback is optional too. This callback is used mainly for
non-contiguous buffers. The mmap calls this callback to get the page
address. Some examples will be explained in the later section {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:buffer\string-and\string-memory\string-management]{\emph{Buffer
and Memory Management}}}, too.


\subsubsection{PCM Interrupt Handler}
\label{sound/kernel-api/writing-an-alsa-driver:pcm-interrupt-handler}
The rest of pcm stuff is the PCM interrupt handler. The role of PCM
interrupt handler in the sound driver is to update the buffer position
and to tell the PCM middle layer when the buffer position goes across
the prescribed period size. To inform this, call the
\code{snd\_pcm\_period\_elapsed()} function.

There are several types of sound chips to generate the interrupts.


\paragraph{Interrupts at the period (fragment) boundary}
\label{sound/kernel-api/writing-an-alsa-driver:interrupts-at-the-period-fragment-boundary}
This is the most frequently found type: the hardware generates an
interrupt at each period boundary. In this case, you can call
\code{snd\_pcm\_period\_elapsed()} at each interrupt.

\code{snd\_pcm\_period\_elapsed()} takes the substream pointer as
its argument. Thus, you need to keep the substream pointer accessible
from the chip instance. For example, define \code{substream} field in the
chip record to hold the current running substream pointer, and set the
pointer value at \code{open} callback (and reset at \code{close} callback).

If you acquire a spinlock in the interrupt handler, and the lock is used
in other pcm callbacks, too, then you have to release the lock before
calling \code{snd\_pcm\_period\_elapsed()}, because
\code{snd\_pcm\_period\_elapsed()} calls other pcm callbacks
inside.

Typical code would be like:

\begin{Verbatim}[commandchars=\\\{\}]
static irqreturn\PYGZus{}t snd\PYGZus{}mychip\PYGZus{}interrupt(int irq, void *dev\PYGZus{}id)
\PYGZob{}
        struct mychip *chip = dev\PYGZus{}id;
        spin\PYGZus{}lock(\PYGZam{}chip\PYGZhy{}\PYGZgt{}lock);
        ....
        if (pcm\PYGZus{}irq\PYGZus{}invoked(chip)) \PYGZob{}
                /* call updater, unlock before it */
                spin\PYGZus{}unlock(\PYGZam{}chip\PYGZhy{}\PYGZgt{}lock);
                snd\PYGZus{}pcm\PYGZus{}period\PYGZus{}elapsed(chip\PYGZhy{}\PYGZgt{}substream);
                spin\PYGZus{}lock(\PYGZam{}chip\PYGZhy{}\PYGZgt{}lock);
                /* acknowledge the interrupt if necessary */
        \PYGZcb{}
        ....
        spin\PYGZus{}unlock(\PYGZam{}chip\PYGZhy{}\PYGZgt{}lock);
        return IRQ\PYGZus{}HANDLED;
\PYGZcb{}
\end{Verbatim}


\paragraph{High frequency timer interrupts}
\label{sound/kernel-api/writing-an-alsa-driver:high-frequency-timer-interrupts}
This happens when the hardware doesn't generate interrupts at the period
boundary but issues timer interrupts at a fixed timer rate (e.g. es1968
or ymfpci drivers). In this case, you need to check the current hardware
position and accumulate the processed sample length at each interrupt.
When the accumulated size exceeds the period size, call
\code{snd\_pcm\_period\_elapsed()} and reset the accumulator.

Typical code would be like the following.

\begin{Verbatim}[commandchars=\\\{\}]
static irqreturn\PYGZus{}t snd\PYGZus{}mychip\PYGZus{}interrupt(int irq, void *dev\PYGZus{}id)
\PYGZob{}
        struct mychip *chip = dev\PYGZus{}id;
        spin\PYGZus{}lock(\PYGZam{}chip\PYGZhy{}\PYGZgt{}lock);
        ....
        if (pcm\PYGZus{}irq\PYGZus{}invoked(chip)) \PYGZob{}
                unsigned int last\PYGZus{}ptr, size;
                /* get the current hardware pointer (in frames) */
                last\PYGZus{}ptr = get\PYGZus{}hw\PYGZus{}ptr(chip);
                /* calculate the processed frames since the
                 * last update
                 */
                if (last\PYGZus{}ptr \PYGZlt{} chip\PYGZhy{}\PYGZgt{}last\PYGZus{}ptr)
                        size = runtime\PYGZhy{}\PYGZgt{}buffer\PYGZus{}size + last\PYGZus{}ptr
                                 \PYGZhy{} chip\PYGZhy{}\PYGZgt{}last\PYGZus{}ptr;
                else
                        size = last\PYGZus{}ptr \PYGZhy{} chip\PYGZhy{}\PYGZgt{}last\PYGZus{}ptr;
                /* remember the last updated point */
                chip\PYGZhy{}\PYGZgt{}last\PYGZus{}ptr = last\PYGZus{}ptr;
                /* accumulate the size */
                chip\PYGZhy{}\PYGZgt{}size += size;
                /* over the period boundary? */
                if (chip\PYGZhy{}\PYGZgt{}size \PYGZgt{}= runtime\PYGZhy{}\PYGZgt{}period\PYGZus{}size) \PYGZob{}
                        /* reset the accumulator */
                        chip\PYGZhy{}\PYGZgt{}size \PYGZpc{}= runtime\PYGZhy{}\PYGZgt{}period\PYGZus{}size;
                        /* call updater */
                        spin\PYGZus{}unlock(\PYGZam{}chip\PYGZhy{}\PYGZgt{}lock);
                        snd\PYGZus{}pcm\PYGZus{}period\PYGZus{}elapsed(substream);
                        spin\PYGZus{}lock(\PYGZam{}chip\PYGZhy{}\PYGZgt{}lock);
                \PYGZcb{}
                /* acknowledge the interrupt if necessary */
        \PYGZcb{}
        ....
        spin\PYGZus{}unlock(\PYGZam{}chip\PYGZhy{}\PYGZgt{}lock);
        return IRQ\PYGZus{}HANDLED;
\PYGZcb{}
\end{Verbatim}


\paragraph{On calling \texttt{snd\_pcm\_period\_elapsed()}}
\label{sound/kernel-api/writing-an-alsa-driver:on-calling-snd-pcm-period-elapsed}
In both cases, even if more than one period are elapsed, you don't have
to call \code{snd\_pcm\_period\_elapsed()} many times. Call only
once. And the pcm layer will check the current hardware pointer and
update to the latest status.


\subsubsection{Atomicity}
\label{sound/kernel-api/writing-an-alsa-driver:atomicity}
One of the most important (and thus difficult to debug) problems in
kernel programming are race conditions. In the Linux kernel, they are
usually avoided via spin-locks, mutexes or semaphores. In general, if a
race condition can happen in an interrupt handler, it has to be managed
atomically, and you have to use a spinlock to protect the critical
session. If the critical section is not in interrupt handler code and if
taking a relatively long time to execute is acceptable, you should use
mutexes or semaphores instead.

As already seen, some pcm callbacks are atomic and some are not. For
example, the \code{hw\_params} callback is non-atomic, while \code{trigger}
callback is atomic. This means, the latter is called already in a
spinlock held by the PCM middle layer. Please take this atomicity into
account when you choose a locking scheme in the callbacks.

In the atomic callbacks, you cannot use functions which may call
\code{schedule()} or go to \code{sleep()}. Semaphores and
mutexes can sleep, and hence they cannot be used inside the atomic
callbacks (e.g. \code{trigger} callback). To implement some delay in such a
callback, please use \code{udelay()} or \code{mdelay()}.

All three atomic callbacks (trigger, pointer, and ack) are called with
local interrupts disabled.

The recent changes in PCM core code, however, allow all PCM operations
to be non-atomic. This assumes that the all caller sides are in
non-atomic contexts. For example, the function
\code{snd\_pcm\_period\_elapsed()} is called typically from the
interrupt handler. But, if you set up the driver to use a threaded
interrupt handler, this call can be in non-atomic context, too. In such
a case, you can set \code{nonatomic} filed of \code{struct snd\_pcm} object after creating it. When this flag is set, mutex
and rwsem are used internally in the PCM core instead of spin and
rwlocks, so that you can call all PCM functions safely in a non-atomic
context.


\subsubsection{Constraints}
\label{sound/kernel-api/writing-an-alsa-driver:constraints}
If your chip supports unconventional sample rates, or only the limited
samples, you need to set a constraint for the condition.

For example, in order to restrict the sample rates in the some supported
values, use \code{snd\_pcm\_hw\_constraint\_list()}. You need to
call this function in the open callback.

\begin{Verbatim}[commandchars=\\\{\}]
static unsigned int rates[] =
        \PYGZob{}4000, 10000, 22050, 44100\PYGZcb{};
static struct snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}constraint\PYGZus{}list constraints\PYGZus{}rates = \PYGZob{}
        .count = ARRAY\PYGZus{}SIZE(rates),
        .list = rates,
        .mask = 0,
\PYGZcb{};

static int snd\PYGZus{}mychip\PYGZus{}pcm\PYGZus{}open(struct snd\PYGZus{}pcm\PYGZus{}substream *substream)
\PYGZob{}
        int err;
        ....
        err = snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}constraint\PYGZus{}list(substream\PYGZhy{}\PYGZgt{}runtime, 0,
                                         SNDRV\PYGZus{}PCM\PYGZus{}HW\PYGZus{}PARAM\PYGZus{}RATE,
                                         \PYGZam{}constraints\PYGZus{}rates);
        if (err \PYGZlt{} 0)
                return err;
        ....
\PYGZcb{}
\end{Verbatim}

There are many different constraints. Look at \code{sound/pcm.h} for a
complete list. You can even define your own constraint rules. For
example, let's suppose my\_chip can manage a substream of 1 channel if
and only if the format is \code{S16\_LE}, otherwise it supports any format
specified in the \code{struct snd\_pcm\_hardware} structure (or in any other
constraint\_list). You can build a rule like this:

\begin{Verbatim}[commandchars=\\\{\}]
static int hw\PYGZus{}rule\PYGZus{}channels\PYGZus{}by\PYGZus{}format(struct snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}params *params,
                                      struct snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}rule *rule)
\PYGZob{}
        struct snd\PYGZus{}interval *c = hw\PYGZus{}param\PYGZus{}interval(params,
                      SNDRV\PYGZus{}PCM\PYGZus{}HW\PYGZus{}PARAM\PYGZus{}CHANNELS);
        struct snd\PYGZus{}mask *f = hw\PYGZus{}param\PYGZus{}mask(params, SNDRV\PYGZus{}PCM\PYGZus{}HW\PYGZus{}PARAM\PYGZus{}FORMAT);
        struct snd\PYGZus{}interval ch;

        snd\PYGZus{}interval\PYGZus{}any(\PYGZam{}ch);
        if (f\PYGZhy{}\PYGZgt{}bits[0] == SNDRV\PYGZus{}PCM\PYGZus{}FMTBIT\PYGZus{}S16\PYGZus{}LE) \PYGZob{}
                ch.min = ch.max = 1;
                ch.integer = 1;
                return snd\PYGZus{}interval\PYGZus{}refine(c, \PYGZam{}ch);
        \PYGZcb{}
        return 0;
\PYGZcb{}
\end{Verbatim}

Then you need to call this function to add your rule:

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}rule\PYGZus{}add(substream\PYGZhy{}\PYGZgt{}runtime, 0, SNDRV\PYGZus{}PCM\PYGZus{}HW\PYGZus{}PARAM\PYGZus{}CHANNELS,
                    hw\PYGZus{}rule\PYGZus{}channels\PYGZus{}by\PYGZus{}format, NULL,
                    SNDRV\PYGZus{}PCM\PYGZus{}HW\PYGZus{}PARAM\PYGZus{}FORMAT, \PYGZhy{}1);
\end{Verbatim}

The rule function is called when an application sets the PCM format, and
it refines the number of channels accordingly. But an application may
set the number of channels before setting the format. Thus you also need
to define the inverse rule:

\begin{Verbatim}[commandchars=\\\{\}]
static int hw\PYGZus{}rule\PYGZus{}format\PYGZus{}by\PYGZus{}channels(struct snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}params *params,
                                      struct snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}rule *rule)
\PYGZob{}
        struct snd\PYGZus{}interval *c = hw\PYGZus{}param\PYGZus{}interval(params,
              SNDRV\PYGZus{}PCM\PYGZus{}HW\PYGZus{}PARAM\PYGZus{}CHANNELS);
        struct snd\PYGZus{}mask *f = hw\PYGZus{}param\PYGZus{}mask(params, SNDRV\PYGZus{}PCM\PYGZus{}HW\PYGZus{}PARAM\PYGZus{}FORMAT);
        struct snd\PYGZus{}mask fmt;

        snd\PYGZus{}mask\PYGZus{}any(\PYGZam{}fmt);    /* Init the struct */
        if (c\PYGZhy{}\PYGZgt{}min \PYGZlt{} 2) \PYGZob{}
                fmt.bits[0] \PYGZam{}= SNDRV\PYGZus{}PCM\PYGZus{}FMTBIT\PYGZus{}S16\PYGZus{}LE;
                return snd\PYGZus{}mask\PYGZus{}refine(f, \PYGZam{}fmt);
        \PYGZcb{}
        return 0;
\PYGZcb{}
\end{Verbatim}

... and in the open callback:

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}rule\PYGZus{}add(substream\PYGZhy{}\PYGZgt{}runtime, 0, SNDRV\PYGZus{}PCM\PYGZus{}HW\PYGZus{}PARAM\PYGZus{}FORMAT,
                    hw\PYGZus{}rule\PYGZus{}format\PYGZus{}by\PYGZus{}channels, NULL,
                    SNDRV\PYGZus{}PCM\PYGZus{}HW\PYGZus{}PARAM\PYGZus{}CHANNELS, \PYGZhy{}1);
\end{Verbatim}

I won't give more details here, rather I would like to say, “Luke, use
the source.”


\subsection{Control Interface}
\label{sound/kernel-api/writing-an-alsa-driver:control-interface}

\subsubsection{General}
\label{sound/kernel-api/writing-an-alsa-driver:id4}
The control interface is used widely for many switches, sliders, etc.
which are accessed from user-space. Its most important use is the mixer
interface. In other words, since ALSA 0.9.x, all the mixer stuff is
implemented on the control kernel API.

ALSA has a well-defined AC97 control module. If your chip supports only
the AC97 and nothing else, you can skip this section.

The control API is defined in \code{\textless{}sound/control.h\textgreater{}}. Include this file
if you want to add your own controls.


\subsubsection{Definition of Controls}
\label{sound/kernel-api/writing-an-alsa-driver:definition-of-controls}
To create a new control, you need to define the following three
callbacks: \code{info}, \code{get} and \code{put}. Then, define a
\code{struct snd\_kcontrol\_new} record, such as:

\begin{Verbatim}[commandchars=\\\{\}]
static struct snd\PYGZus{}kcontrol\PYGZus{}new my\PYGZus{}control = \PYGZob{}
        .iface = SNDRV\PYGZus{}CTL\PYGZus{}ELEM\PYGZus{}IFACE\PYGZus{}MIXER,
        .name = \PYGZdq{}PCM Playback Switch\PYGZdq{},
        .index = 0,
        .access = SNDRV\PYGZus{}CTL\PYGZus{}ELEM\PYGZus{}ACCESS\PYGZus{}READWRITE,
        .private\PYGZus{}value = 0xffff,
        .info = my\PYGZus{}control\PYGZus{}info,
        .get = my\PYGZus{}control\PYGZus{}get,
        .put = my\PYGZus{}control\PYGZus{}put
\PYGZcb{};
\end{Verbatim}

The \code{iface} field specifies the control type,
\code{SNDRV\_CTL\_ELEM\_IFACE\_XXX}, which is usually \code{MIXER}. Use \code{CARD}
for global controls that are not logically part of the mixer. If the
control is closely associated with some specific device on the sound
card, use \code{HWDEP}, \code{PCM}, \code{RAWMIDI}, \code{TIMER}, or \code{SEQUENCER},
and specify the device number with the \code{device} and \code{subdevice}
fields.

The \code{name} is the name identifier string. Since ALSA 0.9.x, the
control name is very important, because its role is classified from
its name. There are pre-defined standard control names. The details
are described in the {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:control\string-names]{\emph{Control Names}}} subsection.

The \code{index} field holds the index number of this control. If there
are several different controls with the same name, they can be
distinguished by the index number. This is the case when several
codecs exist on the card. If the index is zero, you can omit the
definition above.

The \code{access} field contains the access type of this control. Give
the combination of bit masks, \code{SNDRV\_CTL\_ELEM\_ACCESS\_XXX},
there. The details will be explained in the {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:access\string-flags]{\emph{Access Flags}}}
subsection.

The \code{private\_value} field contains an arbitrary long integer value
for this record. When using the generic \code{info}, \code{get} and \code{put}
callbacks, you can pass a value through this field. If several small
numbers are necessary, you can combine them in bitwise. Or, it's
possible to give a pointer (casted to unsigned long) of some record to
this field, too.

The \code{tlv} field can be used to provide metadata about the control;
see the {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:metadata]{\emph{Metadata}}} subsection.

The other three are {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:control\string-callbacks]{\emph{Control Callbacks}}}.


\subsubsection{Control Names}
\label{sound/kernel-api/writing-an-alsa-driver:control-names}
There are some standards to define the control names. A control is
usually defined from the three parts as “SOURCE DIRECTION FUNCTION”.

The first, \code{SOURCE}, specifies the source of the control, and is a
string such as “Master”, “PCM”, “CD” and “Line”. There are many
pre-defined sources.

The second, \code{DIRECTION}, is one of the following strings according to
the direction of the control: “Playback”, “Capture”, “Bypass Playback”
and “Bypass Capture”. Or, it can be omitted, meaning both playback and
capture directions.

The third, \code{FUNCTION}, is one of the following strings according to
the function of the control: “Switch”, “Volume” and “Route”.

The example of control names are, thus, “Master Capture Switch” or “PCM
Playback Volume”.

There are some exceptions:


\paragraph{Global capture and playback}
\label{sound/kernel-api/writing-an-alsa-driver:global-capture-and-playback}
“Capture Source”, “Capture Switch” and “Capture Volume” are used for the
global capture (input) source, switch and volume. Similarly, “Playback
Switch” and “Playback Volume” are used for the global output gain switch
and volume.


\paragraph{Tone-controls}
\label{sound/kernel-api/writing-an-alsa-driver:tone-controls}
tone-control switch and volumes are specified like “Tone Control - XXX”,
e.g. “Tone Control - Switch”, “Tone Control - Bass”, “Tone Control -
Center”.


\paragraph{3D controls}
\label{sound/kernel-api/writing-an-alsa-driver:d-controls}
3D-control switches and volumes are specified like “3D Control - XXX”,
e.g. “3D Control - Switch”, “3D Control - Center”, “3D Control - Space”.


\paragraph{Mic boost}
\label{sound/kernel-api/writing-an-alsa-driver:mic-boost}
Mic-boost switch is set as “Mic Boost” or “Mic Boost (6dB)”.

More precise information can be found in
\code{Documentation/sound/designs/control-names.rst}.


\subsubsection{Access Flags}
\label{sound/kernel-api/writing-an-alsa-driver:access-flags}
The access flag is the bitmask which specifies the access type of the
given control. The default access type is
\code{SNDRV\_CTL\_ELEM\_ACCESS\_READWRITE}, which means both read and write are
allowed to this control. When the access flag is omitted (i.e. = 0), it
is considered as \code{READWRITE} access as default.

When the control is read-only, pass \code{SNDRV\_CTL\_ELEM\_ACCESS\_READ}
instead. In this case, you don't have to define the \code{put} callback.
Similarly, when the control is write-only (although it's a rare case),
you can use the \code{WRITE} flag instead, and you don't need the \code{get}
callback.

If the control value changes frequently (e.g. the VU meter),
\code{VOLATILE} flag should be given. This means that the control may be
changed without {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:change\string-notification]{\emph{Change notification}}}. Applications should poll such
a control constantly.

When the control is inactive, set the \code{INACTIVE} flag, too. There are
\code{LOCK} and \code{OWNER} flags to change the write permissions.


\subsubsection{Control Callbacks}
\label{sound/kernel-api/writing-an-alsa-driver:control-callbacks}

\paragraph{info callback}
\label{sound/kernel-api/writing-an-alsa-driver:info-callback}
The \code{info} callback is used to get detailed information on this
control. This must store the values of the given \code{struct
snd\_ctl\_elem\_info} object. For example,
for a boolean control with a single element:

\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}myctl\PYGZus{}mono\PYGZus{}info(struct snd\PYGZus{}kcontrol *kcontrol,
                        struct snd\PYGZus{}ctl\PYGZus{}elem\PYGZus{}info *uinfo)
\PYGZob{}
        uinfo\PYGZhy{}\PYGZgt{}type = SNDRV\PYGZus{}CTL\PYGZus{}ELEM\PYGZus{}TYPE\PYGZus{}BOOLEAN;
        uinfo\PYGZhy{}\PYGZgt{}count = 1;
        uinfo\PYGZhy{}\PYGZgt{}value.integer.min = 0;
        uinfo\PYGZhy{}\PYGZgt{}value.integer.max = 1;
        return 0;
\PYGZcb{}
\end{Verbatim}

The \code{type} field specifies the type of the control. There are
\code{BOOLEAN}, \code{INTEGER}, \code{ENUMERATED}, \code{BYTES}, \code{IEC958} and
\code{INTEGER64}. The \code{count} field specifies the number of elements in
this control. For example, a stereo volume would have count = 2. The
\code{value} field is a union, and the values stored are depending on the
type. The boolean and integer types are identical.

The enumerated type is a bit different from others. You'll need to set
the string for the currently given item index.

\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}myctl\PYGZus{}enum\PYGZus{}info(struct snd\PYGZus{}kcontrol *kcontrol,
                        struct snd\PYGZus{}ctl\PYGZus{}elem\PYGZus{}info *uinfo)
\PYGZob{}
        static char *texts[4] = \PYGZob{}
                \PYGZdq{}First\PYGZdq{}, \PYGZdq{}Second\PYGZdq{}, \PYGZdq{}Third\PYGZdq{}, \PYGZdq{}Fourth\PYGZdq{}
        \PYGZcb{};
        uinfo\PYGZhy{}\PYGZgt{}type = SNDRV\PYGZus{}CTL\PYGZus{}ELEM\PYGZus{}TYPE\PYGZus{}ENUMERATED;
        uinfo\PYGZhy{}\PYGZgt{}count = 1;
        uinfo\PYGZhy{}\PYGZgt{}value.enumerated.items = 4;
        if (uinfo\PYGZhy{}\PYGZgt{}value.enumerated.item \PYGZgt{} 3)
                uinfo\PYGZhy{}\PYGZgt{}value.enumerated.item = 3;
        strcpy(uinfo\PYGZhy{}\PYGZgt{}value.enumerated.name,
               texts[uinfo\PYGZhy{}\PYGZgt{}value.enumerated.item]);
        return 0;
\PYGZcb{}
\end{Verbatim}

The above callback can be simplified with a helper function,
\code{snd\_ctl\_enum\_info()}. The final code looks like below.
(You can pass \code{ARRAY\_SIZE(texts)} instead of 4 in the third argument;
it's a matter of taste.)

\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}myctl\PYGZus{}enum\PYGZus{}info(struct snd\PYGZus{}kcontrol *kcontrol,
                        struct snd\PYGZus{}ctl\PYGZus{}elem\PYGZus{}info *uinfo)
\PYGZob{}
        static char *texts[4] = \PYGZob{}
                \PYGZdq{}First\PYGZdq{}, \PYGZdq{}Second\PYGZdq{}, \PYGZdq{}Third\PYGZdq{}, \PYGZdq{}Fourth\PYGZdq{}
        \PYGZcb{};
        return snd\PYGZus{}ctl\PYGZus{}enum\PYGZus{}info(uinfo, 1, 4, texts);
\PYGZcb{}
\end{Verbatim}

Some common info callbacks are available for your convenience:
\code{snd\_ctl\_boolean\_mono\_info()} and
\code{snd\_ctl\_boolean\_stereo\_info()}. Obviously, the former
is an info callback for a mono channel boolean item, just like
\code{snd\_myctl\_mono\_info()} above, and the latter is for a
stereo channel boolean item.


\paragraph{get callback}
\label{sound/kernel-api/writing-an-alsa-driver:get-callback}
This callback is used to read the current value of the control and to
return to user-space.

For example,

\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}myctl\PYGZus{}get(struct snd\PYGZus{}kcontrol *kcontrol,
                         struct snd\PYGZus{}ctl\PYGZus{}elem\PYGZus{}value *ucontrol)
\PYGZob{}
        struct mychip *chip = snd\PYGZus{}kcontrol\PYGZus{}chip(kcontrol);
        ucontrol\PYGZhy{}\PYGZgt{}value.integer.value[0] = get\PYGZus{}some\PYGZus{}value(chip);
        return 0;
\PYGZcb{}
\end{Verbatim}

The \code{value} field depends on the type of control as well as on the
info callback. For example, the sb driver uses this field to store the
register offset, the bit-shift and the bit-mask. The \code{private\_value}
field is set as follows:

\begin{Verbatim}[commandchars=\\\{\}]
.private\PYGZus{}value = reg \textbar{} (shift \PYGZlt{}\PYGZlt{} 16) \textbar{} (mask \PYGZlt{}\PYGZlt{} 24)
\end{Verbatim}

and is retrieved in callbacks like

\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}sbmixer\PYGZus{}get\PYGZus{}single(struct snd\PYGZus{}kcontrol *kcontrol,
                                  struct snd\PYGZus{}ctl\PYGZus{}elem\PYGZus{}value *ucontrol)
\PYGZob{}
        int reg = kcontrol\PYGZhy{}\PYGZgt{}private\PYGZus{}value \PYGZam{} 0xff;
        int shift = (kcontrol\PYGZhy{}\PYGZgt{}private\PYGZus{}value \PYGZgt{}\PYGZgt{} 16) \PYGZam{} 0xff;
        int mask = (kcontrol\PYGZhy{}\PYGZgt{}private\PYGZus{}value \PYGZgt{}\PYGZgt{} 24) \PYGZam{} 0xff;
        ....
\PYGZcb{}
\end{Verbatim}

In the \code{get} callback, you have to fill all the elements if the
control has more than one elements, i.e. \code{count \textgreater{} 1}. In the example
above, we filled only one element (\code{value.integer.value{[}0{]}}) since
it's assumed as \code{count = 1}.


\paragraph{put callback}
\label{sound/kernel-api/writing-an-alsa-driver:put-callback}
This callback is used to write a value from user-space.

For example,

\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}myctl\PYGZus{}put(struct snd\PYGZus{}kcontrol *kcontrol,
                         struct snd\PYGZus{}ctl\PYGZus{}elem\PYGZus{}value *ucontrol)
\PYGZob{}
        struct mychip *chip = snd\PYGZus{}kcontrol\PYGZus{}chip(kcontrol);
        int changed = 0;
        if (chip\PYGZhy{}\PYGZgt{}current\PYGZus{}value !=
             ucontrol\PYGZhy{}\PYGZgt{}value.integer.value[0]) \PYGZob{}
                change\PYGZus{}current\PYGZus{}value(chip,
                            ucontrol\PYGZhy{}\PYGZgt{}value.integer.value[0]);
                changed = 1;
        \PYGZcb{}
        return changed;
\PYGZcb{}
\end{Verbatim}

As seen above, you have to return 1 if the value is changed. If the
value is not changed, return 0 instead. If any fatal error happens,
return a negative error code as usual.

As in the \code{get} callback, when the control has more than one
elements, all elements must be evaluated in this callback, too.


\paragraph{Callbacks are not atomic}
\label{sound/kernel-api/writing-an-alsa-driver:callbacks-are-not-atomic}
All these three callbacks are basically not atomic.


\subsubsection{Control Constructor}
\label{sound/kernel-api/writing-an-alsa-driver:control-constructor}
When everything is ready, finally we can create a new control. To create
a control, there are two functions to be called,
\code{snd\_ctl\_new1()} and \code{snd\_ctl\_add()}.

In the simplest way, you can do like this:

\begin{Verbatim}[commandchars=\\\{\}]
err = snd\PYGZus{}ctl\PYGZus{}add(card, snd\PYGZus{}ctl\PYGZus{}new1(\PYGZam{}my\PYGZus{}control, chip));
if (err \PYGZlt{} 0)
        return err;
\end{Verbatim}

where \code{my\_control} is the \code{struct snd\_kcontrol\_new} object defined above, and chip is the object
pointer to be passed to kcontrol-\textgreater{}private\_data which can be referred
to in callbacks.

\code{snd\_ctl\_new1()} allocates a new \code{struct
snd\_kcontrol} instance, and
\code{snd\_ctl\_add()} assigns the given control component to the
card.


\subsubsection{Change Notification}
\label{sound/kernel-api/writing-an-alsa-driver:change-notification}
If you need to change and update a control in the interrupt routine, you
can call \code{snd\_ctl\_notify()}. For example,

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}ctl\PYGZus{}notify(card, SNDRV\PYGZus{}CTL\PYGZus{}EVENT\PYGZus{}MASK\PYGZus{}VALUE, id\PYGZus{}pointer);
\end{Verbatim}

This function takes the card pointer, the event-mask, and the control id
pointer for the notification. The event-mask specifies the types of
notification, for example, in the above example, the change of control
values is notified. The id pointer is the pointer of \code{struct
snd\_ctl\_elem\_id} to be notified. You can
find some examples in \code{es1938.c} or \code{es1968.c} for hardware volume
interrupts.


\subsubsection{Metadata}
\label{sound/kernel-api/writing-an-alsa-driver:metadata}
To provide information about the dB values of a mixer control, use on of
the \code{DECLARE\_TLV\_xxx} macros from \code{\textless{}sound/tlv.h\textgreater{}} to define a
variable containing this information, set the \code{tlv.p} field to point to
this variable, and include the \code{SNDRV\_CTL\_ELEM\_ACCESS\_TLV\_READ} flag
in the \code{access} field; like this:

\begin{Verbatim}[commandchars=\\\{\}]
static DECLARE\PYGZus{}TLV\PYGZus{}DB\PYGZus{}SCALE(db\PYGZus{}scale\PYGZus{}my\PYGZus{}control, \PYGZhy{}4050, 150, 0);

static struct snd\PYGZus{}kcontrol\PYGZus{}new my\PYGZus{}control = \PYGZob{}
        ...
        .access = SNDRV\PYGZus{}CTL\PYGZus{}ELEM\PYGZus{}ACCESS\PYGZus{}READWRITE \textbar{}
                  SNDRV\PYGZus{}CTL\PYGZus{}ELEM\PYGZus{}ACCESS\PYGZus{}TLV\PYGZus{}READ,
        ...
        .tlv.p = db\PYGZus{}scale\PYGZus{}my\PYGZus{}control,
\PYGZcb{};
\end{Verbatim}

The \code{DECLARE\_TLV\_DB\_SCALE()} macro defines information
about a mixer control where each step in the control's value changes the
dB value by a constant dB amount. The first parameter is the name of the
variable to be defined. The second parameter is the minimum value, in
units of 0.01 dB. The third parameter is the step size, in units of 0.01
dB. Set the fourth parameter to 1 if the minimum value actually mutes
the control.

The \code{DECLARE\_TLV\_DB\_LINEAR()} macro defines information
about a mixer control where the control's value affects the output
linearly. The first parameter is the name of the variable to be defined.
The second parameter is the minimum value, in units of 0.01 dB. The
third parameter is the maximum value, in units of 0.01 dB. If the
minimum value mutes the control, set the second parameter to
\code{TLV\_DB\_GAIN\_MUTE}.


\subsection{API for AC97 Codec}
\label{sound/kernel-api/writing-an-alsa-driver:api-for-ac97-codec}

\subsubsection{General}
\label{sound/kernel-api/writing-an-alsa-driver:id5}
The ALSA AC97 codec layer is a well-defined one, and you don't have to
write much code to control it. Only low-level control routines are
necessary. The AC97 codec API is defined in \code{\textless{}sound/ac97\_codec.h\textgreater{}}.


\subsubsection{Full Code Example}
\label{sound/kernel-api/writing-an-alsa-driver:id6}
\begin{Verbatim}[commandchars=\\\{\}]
struct mychip \PYGZob{}
        ....
        struct snd\PYGZus{}ac97 *ac97;
        ....
\PYGZcb{};

static unsigned short snd\PYGZus{}mychip\PYGZus{}ac97\PYGZus{}read(struct snd\PYGZus{}ac97 *ac97,
                                           unsigned short reg)
\PYGZob{}
        struct mychip *chip = ac97\PYGZhy{}\PYGZgt{}private\PYGZus{}data;
        ....
        /* read a register value here from the codec */
        return the\PYGZus{}register\PYGZus{}value;
\PYGZcb{}

static void snd\PYGZus{}mychip\PYGZus{}ac97\PYGZus{}write(struct snd\PYGZus{}ac97 *ac97,
                                 unsigned short reg, unsigned short val)
\PYGZob{}
        struct mychip *chip = ac97\PYGZhy{}\PYGZgt{}private\PYGZus{}data;
        ....
        /* write the given register value to the codec */
\PYGZcb{}

static int snd\PYGZus{}mychip\PYGZus{}ac97(struct mychip *chip)
\PYGZob{}
        struct snd\PYGZus{}ac97\PYGZus{}bus *bus;
        struct snd\PYGZus{}ac97\PYGZus{}template ac97;
        int err;
        static struct snd\PYGZus{}ac97\PYGZus{}bus\PYGZus{}ops ops = \PYGZob{}
                .write = snd\PYGZus{}mychip\PYGZus{}ac97\PYGZus{}write,
                .read = snd\PYGZus{}mychip\PYGZus{}ac97\PYGZus{}read,
        \PYGZcb{};

        err = snd\PYGZus{}ac97\PYGZus{}bus(chip\PYGZhy{}\PYGZgt{}card, 0, \PYGZam{}ops, NULL, \PYGZam{}bus);
        if (err \PYGZlt{} 0)
                return err;
        memset(\PYGZam{}ac97, 0, sizeof(ac97));
        ac97.private\PYGZus{}data = chip;
        return snd\PYGZus{}ac97\PYGZus{}mixer(bus, \PYGZam{}ac97, \PYGZam{}chip\PYGZhy{}\PYGZgt{}ac97);
\PYGZcb{}
\end{Verbatim}


\subsubsection{AC97 Constructor}
\label{sound/kernel-api/writing-an-alsa-driver:ac97-constructor}
To create an ac97 instance, first call {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_bus]{\emph{\code{snd\_ac97\_bus()}}}}
with an \code{ac97\_bus\_ops\_t} record with callback functions.

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}ac97\PYGZus{}bus *bus;
static struct snd\PYGZus{}ac97\PYGZus{}bus\PYGZus{}ops ops = \PYGZob{}
      .write = snd\PYGZus{}mychip\PYGZus{}ac97\PYGZus{}write,
      .read = snd\PYGZus{}mychip\PYGZus{}ac97\PYGZus{}read,
\PYGZcb{};

snd\PYGZus{}ac97\PYGZus{}bus(card, 0, \PYGZam{}ops, NULL, \PYGZam{}pbus);
\end{Verbatim}

The bus record is shared among all belonging ac97 instances.

And then call {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_mixer]{\emph{\code{snd\_ac97\_mixer()}}}} with an \code{struct
snd\_ac97\_template} record together with
the bus pointer created above.

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}ac97\PYGZus{}template ac97;
int err;

memset(\PYGZam{}ac97, 0, sizeof(ac97));
ac97.private\PYGZus{}data = chip;
snd\PYGZus{}ac97\PYGZus{}mixer(bus, \PYGZam{}ac97, \PYGZam{}chip\PYGZhy{}\PYGZgt{}ac97);
\end{Verbatim}

where chip-\textgreater{}ac97 is a pointer to a newly created \code{ac97\_t}
instance. In this case, the chip pointer is set as the private data,
so that the read/write callback functions can refer to this chip
instance. This instance is not necessarily stored in the chip
record. If you need to change the register values from the driver, or
need the suspend/resume of ac97 codecs, keep this pointer to pass to
the corresponding functions.


\subsubsection{AC97 Callbacks}
\label{sound/kernel-api/writing-an-alsa-driver:ac97-callbacks}
The standard callbacks are \code{read} and \code{write}. Obviously they
correspond to the functions for read and write accesses to the
hardware low-level codes.

The \code{read} callback returns the register value specified in the
argument.

\begin{Verbatim}[commandchars=\\\{\}]
static unsigned short snd\PYGZus{}mychip\PYGZus{}ac97\PYGZus{}read(struct snd\PYGZus{}ac97 *ac97,
                                           unsigned short reg)
\PYGZob{}
        struct mychip *chip = ac97\PYGZhy{}\PYGZgt{}private\PYGZus{}data;
        ....
        return the\PYGZus{}register\PYGZus{}value;
\PYGZcb{}
\end{Verbatim}

Here, the chip can be cast from \code{ac97-\textgreater{}private\_data}.

Meanwhile, the \code{write} callback is used to set the register
value

\begin{Verbatim}[commandchars=\\\{\}]
static void snd\PYGZus{}mychip\PYGZus{}ac97\PYGZus{}write(struct snd\PYGZus{}ac97 *ac97,
                     unsigned short reg, unsigned short val)
\end{Verbatim}

These callbacks are non-atomic like the control API callbacks.

There are also other callbacks: \code{reset}, \code{wait} and \code{init}.

The \code{reset} callback is used to reset the codec. If the chip
requires a special kind of reset, you can define this callback.

The \code{wait} callback is used to add some waiting time in the standard
initialization of the codec. If the chip requires the extra waiting
time, define this callback.

The \code{init} callback is used for additional initialization of the
codec.


\subsubsection{Updating Registers in The Driver}
\label{sound/kernel-api/writing-an-alsa-driver:updating-registers-in-the-driver}
If you need to access to the codec from the driver, you can call the
following functions: {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_write]{\emph{\code{snd\_ac97\_write()}}}},
{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_read]{\emph{\code{snd\_ac97\_read()}}}}, {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_update]{\emph{\code{snd\_ac97\_update()}}}} and
{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_update_bits]{\emph{\code{snd\_ac97\_update\_bits()}}}}.

Both {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_write]{\emph{\code{snd\_ac97\_write()}}}} and
{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_update]{\emph{\code{snd\_ac97\_update()}}}} functions are used to set a value to
the given register (\code{AC97\_XXX}). The difference between them is that
{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_update]{\emph{\code{snd\_ac97\_update()}}}} doesn't write a value if the given
value has been already set, while {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_write]{\emph{\code{snd\_ac97\_write()}}}}
always rewrites the value.

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}ac97\PYGZus{}write(ac97, AC97\PYGZus{}MASTER, 0x8080);
snd\PYGZus{}ac97\PYGZus{}update(ac97, AC97\PYGZus{}MASTER, 0x8080);
\end{Verbatim}

{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_read]{\emph{\code{snd\_ac97\_read()}}}} is used to read the value of the given
register. For example,

\begin{Verbatim}[commandchars=\\\{\}]
value = snd\PYGZus{}ac97\PYGZus{}read(ac97, AC97\PYGZus{}MASTER);
\end{Verbatim}

{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_update_bits]{\emph{\code{snd\_ac97\_update\_bits()}}}} is used to update some bits in
the given register.

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}ac97\PYGZus{}update\PYGZus{}bits(ac97, reg, mask, value);
\end{Verbatim}

Also, there is a function to change the sample rate (of a given register
such as \code{AC97\_PCM\_FRONT\_DAC\_RATE}) when VRA or DRA is supported by the
codec: {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_set_rate]{\emph{\code{snd\_ac97\_set\_rate()}}}}.

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}ac97\PYGZus{}set\PYGZus{}rate(ac97, AC97\PYGZus{}PCM\PYGZus{}FRONT\PYGZus{}DAC\PYGZus{}RATE, 44100);
\end{Verbatim}

The following registers are available to set the rate:
\code{AC97\_PCM\_MIC\_ADC\_RATE}, \code{AC97\_PCM\_FRONT\_DAC\_RATE},
\code{AC97\_PCM\_LR\_ADC\_RATE}, \code{AC97\_SPDIF}. When \code{AC97\_SPDIF} is
specified, the register is not really changed but the corresponding
IEC958 status bits will be updated.


\subsubsection{Clock Adjustment}
\label{sound/kernel-api/writing-an-alsa-driver:clock-adjustment}
In some chips, the clock of the codec isn't 48000 but using a PCI clock
(to save a quartz!). In this case, change the field \code{bus-\textgreater{}clock} to
the corresponding value. For example, intel8x0 and es1968 drivers have
their own function to read from the clock.


\subsubsection{Proc Files}
\label{sound/kernel-api/writing-an-alsa-driver:proc-files}
The ALSA AC97 interface will create a proc file such as
\code{/proc/asound/card0/codec97\#0/ac97\#0-0} and \code{ac97\#0-0+regs}. You
can refer to these files to see the current status and registers of
the codec.


\subsubsection{Multiple Codecs}
\label{sound/kernel-api/writing-an-alsa-driver:multiple-codecs}
When there are several codecs on the same card, you need to call
{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_mixer]{\emph{\code{snd\_ac97\_mixer()}}}} multiple times with \code{ac97.num=1} or
greater. The \code{num} field specifies the codec number.

If you set up multiple codecs, you either need to write different
callbacks for each codec or check \code{ac97-\textgreater{}num} in the callback
routines.


\subsection{MIDI (MPU401-UART) Interface}
\label{sound/kernel-api/writing-an-alsa-driver:midi-mpu401-uart-interface}

\subsubsection{General}
\label{sound/kernel-api/writing-an-alsa-driver:id7}
Many soundcards have built-in MIDI (MPU401-UART) interfaces. When the
soundcard supports the standard MPU401-UART interface, most likely you
can use the ALSA MPU401-UART API. The MPU401-UART API is defined in
\code{\textless{}sound/mpu401.h\textgreater{}}.

Some soundchips have a similar but slightly different implementation of
mpu401 stuff. For example, emu10k1 has its own mpu401 routines.


\subsubsection{MIDI Constructor}
\label{sound/kernel-api/writing-an-alsa-driver:midi-constructor}
To create a rawmidi object, call {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_mpu401_uart_new]{\emph{\code{snd\_mpu401\_uart\_new()}}}}.

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}rawmidi *rmidi;
snd\PYGZus{}mpu401\PYGZus{}uart\PYGZus{}new(card, 0, MPU401\PYGZus{}HW\PYGZus{}MPU401, port, info\PYGZus{}flags,
                    irq, \PYGZam{}rmidi);
\end{Verbatim}

The first argument is the card pointer, and the second is the index of
this component. You can create up to 8 rawmidi devices.

The third argument is the type of the hardware, \code{MPU401\_HW\_XXX}. If
it's not a special one, you can use \code{MPU401\_HW\_MPU401}.

The 4th argument is the I/O port address. Many backward-compatible
MPU401 have an I/O port such as 0x330. Or, it might be a part of its own
PCI I/O region. It depends on the chip design.

The 5th argument is a bitflag for additional information. When the I/O
port address above is part of the PCI I/O region, the MPU401 I/O port
might have been already allocated (reserved) by the driver itself. In
such a case, pass a bit flag \code{MPU401\_INFO\_INTEGRATED}, and the
mpu401-uart layer will allocate the I/O ports by itself.

When the controller supports only the input or output MIDI stream, pass
the \code{MPU401\_INFO\_INPUT} or \code{MPU401\_INFO\_OUTPUT} bitflag,
respectively. Then the rawmidi instance is created as a single stream.

\code{MPU401\_INFO\_MMIO} bitflag is used to change the access method to MMIO
(via readb and writeb) instead of iob and outb. In this case, you have
to pass the iomapped address to {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_mpu401_uart_new]{\emph{\code{snd\_mpu401\_uart\_new()}}}}.

When \code{MPU401\_INFO\_TX\_IRQ} is set, the output stream isn't checked in
the default interrupt handler. The driver needs to call
{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_mpu401_uart_interrupt_tx]{\emph{\code{snd\_mpu401\_uart\_interrupt\_tx()}}}} by itself to start
processing the output stream in the irq handler.

If the MPU-401 interface shares its interrupt with the other logical
devices on the card, set \code{MPU401\_INFO\_IRQ\_HOOK} (see
{\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:MIDI\string-Interrupt\string-Handler]{\emph{below}}}).

Usually, the port address corresponds to the command port and port + 1
corresponds to the data port. If not, you may change the \code{cport}
field of \code{struct snd\_mpu401} manually afterward.
However, \code{struct snd\_mpu401} pointer is
not returned explicitly by {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_mpu401_uart_new]{\emph{\code{snd\_mpu401\_uart\_new()}}}}. You
need to cast \code{rmidi-\textgreater{}private\_data} to \code{struct snd\_mpu401} explicitly,

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}mpu401 *mpu;
mpu = rmidi\PYGZhy{}\PYGZgt{}private\PYGZus{}data;
\end{Verbatim}

and reset the \code{cport} as you like:

\begin{Verbatim}[commandchars=\\\{\}]
mpu\PYGZhy{}\PYGZgt{}cport = my\PYGZus{}own\PYGZus{}control\PYGZus{}port;
\end{Verbatim}

The 6th argument specifies the ISA irq number that will be allocated. If
no interrupt is to be allocated (because your code is already allocating
a shared interrupt, or because the device does not use interrupts), pass
-1 instead. For a MPU-401 device without an interrupt, a polling timer
will be used instead.


\subsubsection{MIDI Interrupt Handler}
\label{sound/kernel-api/writing-an-alsa-driver:midi-interrupt-handler}
When the interrupt is allocated in
{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_mpu401_uart_new]{\emph{\code{snd\_mpu401\_uart\_new()}}}}, an exclusive ISA interrupt
handler is automatically used, hence you don't have anything else to do
than creating the mpu401 stuff. Otherwise, you have to set
\code{MPU401\_INFO\_IRQ\_HOOK}, and call
{\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_mpu401_uart_interrupt]{\emph{\code{snd\_mpu401\_uart\_interrupt()}}}} explicitly from your own
interrupt handler when it has determined that a UART interrupt has
occurred.

In this case, you need to pass the private\_data of the returned rawmidi
object from {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_mpu401_uart_new]{\emph{\code{snd\_mpu401\_uart\_new()}}}} as the second
argument of {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_mpu401_uart_interrupt]{\emph{\code{snd\_mpu401\_uart\_interrupt()}}}}.

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}mpu401\PYGZus{}uart\PYGZus{}interrupt(irq, rmidi\PYGZhy{}\PYGZgt{}private\PYGZus{}data, regs);
\end{Verbatim}


\subsection{RawMIDI Interface}
\label{sound/kernel-api/writing-an-alsa-driver:rawmidi-interface}

\subsubsection{Overview}
\label{sound/kernel-api/writing-an-alsa-driver:overview}
The raw MIDI interface is used for hardware MIDI ports that can be
accessed as a byte stream. It is not used for synthesizer chips that do
not directly understand MIDI.

ALSA handles file and buffer management. All you have to do is to write
some code to move data between the buffer and the hardware.

The rawmidi API is defined in \code{\textless{}sound/rawmidi.h\textgreater{}}.


\subsubsection{RawMIDI Constructor}
\label{sound/kernel-api/writing-an-alsa-driver:rawmidi-constructor}
To create a rawmidi device, call the \code{snd\_rawmidi\_new()}
function:

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}rawmidi *rmidi;
err = snd\PYGZus{}rawmidi\PYGZus{}new(chip\PYGZhy{}\PYGZgt{}card, \PYGZdq{}MyMIDI\PYGZdq{}, 0, outs, ins, \PYGZam{}rmidi);
if (err \PYGZlt{} 0)
        return err;
rmidi\PYGZhy{}\PYGZgt{}private\PYGZus{}data = chip;
strcpy(rmidi\PYGZhy{}\PYGZgt{}name, \PYGZdq{}My MIDI\PYGZdq{});
rmidi\PYGZhy{}\PYGZgt{}info\PYGZus{}flags = SNDRV\PYGZus{}RAWMIDI\PYGZus{}INFO\PYGZus{}OUTPUT \textbar{}
                    SNDRV\PYGZus{}RAWMIDI\PYGZus{}INFO\PYGZus{}INPUT \textbar{}
                    SNDRV\PYGZus{}RAWMIDI\PYGZus{}INFO\PYGZus{}DUPLEX;
\end{Verbatim}

The first argument is the card pointer, the second argument is the ID
string.

The third argument is the index of this component. You can create up to
8 rawmidi devices.

The fourth and fifth arguments are the number of output and input
substreams, respectively, of this device (a substream is the equivalent
of a MIDI port).

Set the \code{info\_flags} field to specify the capabilities of the
device. Set \code{SNDRV\_RAWMIDI\_INFO\_OUTPUT} if there is at least one
output port, \code{SNDRV\_RAWMIDI\_INFO\_INPUT} if there is at least one
input port, and \code{SNDRV\_RAWMIDI\_INFO\_DUPLEX} if the device can handle
output and input at the same time.

After the rawmidi device is created, you need to set the operators
(callbacks) for each substream. There are helper functions to set the
operators for all the substreams of a device:

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}rawmidi\PYGZus{}set\PYGZus{}ops(rmidi, SNDRV\PYGZus{}RAWMIDI\PYGZus{}STREAM\PYGZus{}OUTPUT, \PYGZam{}snd\PYGZus{}mymidi\PYGZus{}output\PYGZus{}ops);
snd\PYGZus{}rawmidi\PYGZus{}set\PYGZus{}ops(rmidi, SNDRV\PYGZus{}RAWMIDI\PYGZus{}STREAM\PYGZus{}INPUT, \PYGZam{}snd\PYGZus{}mymidi\PYGZus{}input\PYGZus{}ops);
\end{Verbatim}

The operators are usually defined like this:

\begin{Verbatim}[commandchars=\\\{\}]
static struct snd\PYGZus{}rawmidi\PYGZus{}ops snd\PYGZus{}mymidi\PYGZus{}output\PYGZus{}ops = \PYGZob{}
        .open =    snd\PYGZus{}mymidi\PYGZus{}output\PYGZus{}open,
        .close =   snd\PYGZus{}mymidi\PYGZus{}output\PYGZus{}close,
        .trigger = snd\PYGZus{}mymidi\PYGZus{}output\PYGZus{}trigger,
\PYGZcb{};
\end{Verbatim}

These callbacks are explained in the {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:rawmidi\string-callbacks]{\emph{RawMIDI Callbacks}}} section.

If there are more than one substream, you should give a unique name to
each of them:

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}rawmidi\PYGZus{}substream *substream;
list\PYGZus{}for\PYGZus{}each\PYGZus{}entry(substream,
                    \PYGZam{}rmidi\PYGZhy{}\PYGZgt{}streams[SNDRV\PYGZus{}RAWMIDI\PYGZus{}STREAM\PYGZus{}OUTPUT].substreams,
                    list \PYGZob{}
        sprintf(substream\PYGZhy{}\PYGZgt{}name, \PYGZdq{}My MIDI Port \PYGZpc{}d\PYGZdq{}, substream\PYGZhy{}\PYGZgt{}number + 1);
\PYGZcb{}
/* same for SNDRV\PYGZus{}RAWMIDI\PYGZus{}STREAM\PYGZus{}INPUT */
\end{Verbatim}


\subsubsection{RawMIDI Callbacks}
\label{sound/kernel-api/writing-an-alsa-driver:rawmidi-callbacks}
In all the callbacks, the private data that you've set for the rawmidi
device can be accessed as \code{substream-\textgreater{}rmidi-\textgreater{}private\_data}.

If there is more than one port, your callbacks can determine the port
index from the struct snd\_rawmidi\_substream data passed to each
callback:

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}rawmidi\PYGZus{}substream *substream;
int index = substream\PYGZhy{}\PYGZgt{}number;
\end{Verbatim}


\paragraph{RawMIDI open callback}
\label{sound/kernel-api/writing-an-alsa-driver:rawmidi-open-callback}
\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}xxx\PYGZus{}open(struct snd\PYGZus{}rawmidi\PYGZus{}substream *substream);
\end{Verbatim}

This is called when a substream is opened. You can initialize the
hardware here, but you shouldn't start transmitting/receiving data yet.


\paragraph{RawMIDI close callback}
\label{sound/kernel-api/writing-an-alsa-driver:rawmidi-close-callback}
\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}xxx\PYGZus{}close(struct snd\PYGZus{}rawmidi\PYGZus{}substream *substream);
\end{Verbatim}

Guess what.

The \code{open} and \code{close} callbacks of a rawmidi device are
serialized with a mutex, and can sleep.


\paragraph{Rawmidi trigger callback for output substreams}
\label{sound/kernel-api/writing-an-alsa-driver:rawmidi-trigger-callback-for-output-substreams}
\begin{Verbatim}[commandchars=\\\{\}]
static void snd\PYGZus{}xxx\PYGZus{}output\PYGZus{}trigger(struct snd\PYGZus{}rawmidi\PYGZus{}substream *substream, int up);
\end{Verbatim}

This is called with a nonzero \code{up} parameter when there is some data
in the substream buffer that must be transmitted.

To read data from the buffer, call
\code{snd\_rawmidi\_transmit\_peek()}. It will return the number
of bytes that have been read; this will be less than the number of bytes
requested when there are no more data in the buffer. After the data have
been transmitted successfully, call
\code{snd\_rawmidi\_transmit\_ack()} to remove the data from the
substream buffer:

\begin{Verbatim}[commandchars=\\\{\}]
unsigned char data;
while (snd\PYGZus{}rawmidi\PYGZus{}transmit\PYGZus{}peek(substream, \PYGZam{}data, 1) == 1) \PYGZob{}
        if (snd\PYGZus{}mychip\PYGZus{}try\PYGZus{}to\PYGZus{}transmit(data))
                snd\PYGZus{}rawmidi\PYGZus{}transmit\PYGZus{}ack(substream, 1);
        else
                break; /* hardware FIFO full */
\PYGZcb{}
\end{Verbatim}

If you know beforehand that the hardware will accept data, you can use
the \code{snd\_rawmidi\_transmit()} function which reads some
data and removes them from the buffer at once:

\begin{Verbatim}[commandchars=\\\{\}]
while (snd\PYGZus{}mychip\PYGZus{}transmit\PYGZus{}possible()) \PYGZob{}
        unsigned char data;
        if (snd\PYGZus{}rawmidi\PYGZus{}transmit(substream, \PYGZam{}data, 1) != 1)
                break; /* no more data */
        snd\PYGZus{}mychip\PYGZus{}transmit(data);
\PYGZcb{}
\end{Verbatim}

If you know beforehand how many bytes you can accept, you can use a
buffer size greater than one with the
\code{snd\_rawmidi\_transmit*()} functions.

The \code{trigger} callback must not sleep. If the hardware FIFO is full
before the substream buffer has been emptied, you have to continue
transmitting data later, either in an interrupt handler, or with a
timer if the hardware doesn't have a MIDI transmit interrupt.

The \code{trigger} callback is called with a zero \code{up} parameter when
the transmission of data should be aborted.


\paragraph{RawMIDI trigger callback for input substreams}
\label{sound/kernel-api/writing-an-alsa-driver:rawmidi-trigger-callback-for-input-substreams}
\begin{Verbatim}[commandchars=\\\{\}]
static void snd\PYGZus{}xxx\PYGZus{}input\PYGZus{}trigger(struct snd\PYGZus{}rawmidi\PYGZus{}substream *substream, int up);
\end{Verbatim}

This is called with a nonzero \code{up} parameter to enable receiving data,
or with a zero \code{up} parameter do disable receiving data.

The \code{trigger} callback must not sleep; the actual reading of data
from the device is usually done in an interrupt handler.

When data reception is enabled, your interrupt handler should call
\code{snd\_rawmidi\_receive()} for all received data:

\begin{Verbatim}[commandchars=\\\{\}]
void snd\PYGZus{}mychip\PYGZus{}midi\PYGZus{}interrupt(...)
\PYGZob{}
        while (mychip\PYGZus{}midi\PYGZus{}available()) \PYGZob{}
                unsigned char data;
                data = mychip\PYGZus{}midi\PYGZus{}read();
                snd\PYGZus{}rawmidi\PYGZus{}receive(substream, \PYGZam{}data, 1);
        \PYGZcb{}
\PYGZcb{}
\end{Verbatim}


\paragraph{drain callback}
\label{sound/kernel-api/writing-an-alsa-driver:drain-callback}
\begin{Verbatim}[commandchars=\\\{\}]
static void snd\PYGZus{}xxx\PYGZus{}drain(struct snd\PYGZus{}rawmidi\PYGZus{}substream *substream);
\end{Verbatim}

This is only used with output substreams. This function should wait
until all data read from the substream buffer have been transmitted.
This ensures that the device can be closed and the driver unloaded
without losing data.

This callback is optional. If you do not set \code{drain} in the struct
snd\_rawmidi\_ops structure, ALSA will simply wait for 50 milliseconds
instead.


\subsection{Miscellaneous Devices}
\label{sound/kernel-api/writing-an-alsa-driver:miscellaneous-devices}

\subsubsection{FM OPL3}
\label{sound/kernel-api/writing-an-alsa-driver:fm-opl3}
The FM OPL3 is still used in many chips (mainly for backward
compatibility). ALSA has a nice OPL3 FM control layer, too. The OPL3 API
is defined in \code{\textless{}sound/opl3.h\textgreater{}}.

FM registers can be directly accessed through the direct-FM API, defined
in \code{\textless{}sound/asound\_fm.h\textgreater{}}. In ALSA native mode, FM registers are
accessed through the Hardware-Dependent Device direct-FM extension API,
whereas in OSS compatible mode, FM registers can be accessed with the
OSS direct-FM compatible API in \code{/dev/dmfmX} device.

To create the OPL3 component, you have two functions to call. The first
one is a constructor for the \code{opl3\_t} instance.

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}opl3 *opl3;
snd\PYGZus{}opl3\PYGZus{}create(card, lport, rport, OPL3\PYGZus{}HW\PYGZus{}OPL3\PYGZus{}XXX,
                integrated, \PYGZam{}opl3);
\end{Verbatim}

The first argument is the card pointer, the second one is the left port
address, and the third is the right port address. In most cases, the
right port is placed at the left port + 2.

The fourth argument is the hardware type.

When the left and right ports have been already allocated by the card
driver, pass non-zero to the fifth argument (\code{integrated}). Otherwise,
the opl3 module will allocate the specified ports by itself.

When the accessing the hardware requires special method instead of the
standard I/O access, you can create opl3 instance separately with
\code{snd\_opl3\_new()}.

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}opl3 *opl3;
snd\PYGZus{}opl3\PYGZus{}new(card, OPL3\PYGZus{}HW\PYGZus{}OPL3\PYGZus{}XXX, \PYGZam{}opl3);
\end{Verbatim}

Then set \code{command}, \code{private\_data} and \code{private\_free} for the
private access function, the private data and the destructor. The
\code{l\_port} and \code{r\_port} are not necessarily set. Only the command
must be set properly. You can retrieve the data from the
\code{opl3-\textgreater{}private\_data} field.

After creating the opl3 instance via \code{snd\_opl3\_new()},
call \code{snd\_opl3\_init()} to initialize the chip to the
proper state. Note that \code{snd\_opl3\_create()} always calls
it internally.

If the opl3 instance is created successfully, then create a hwdep device
for this opl3.

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}hwdep *opl3hwdep;
snd\PYGZus{}opl3\PYGZus{}hwdep\PYGZus{}new(opl3, 0, 1, \PYGZam{}opl3hwdep);
\end{Verbatim}

The first argument is the \code{opl3\_t} instance you created, and the
second is the index number, usually 0.

The third argument is the index-offset for the sequencer client assigned
to the OPL3 port. When there is an MPU401-UART, give 1 for here (UART
always takes 0).


\subsubsection{Hardware-Dependent Devices}
\label{sound/kernel-api/writing-an-alsa-driver:hardware-dependent-devices}
Some chips need user-space access for special controls or for loading
the micro code. In such a case, you can create a hwdep
(hardware-dependent) device. The hwdep API is defined in
\code{\textless{}sound/hwdep.h\textgreater{}}. You can find examples in opl3 driver or
\code{isa/sb/sb16\_csp.c}.

The creation of the \code{hwdep} instance is done via
\code{snd\_hwdep\_new()}.

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}hwdep *hw;
snd\PYGZus{}hwdep\PYGZus{}new(card, \PYGZdq{}My HWDEP\PYGZdq{}, 0, \PYGZam{}hw);
\end{Verbatim}

where the third argument is the index number.

You can then pass any pointer value to the \code{private\_data}. If you
assign a private data, you should define the destructor, too. The
destructor function is set in the \code{private\_free} field.

\begin{Verbatim}[commandchars=\\\{\}]
struct mydata *p = kmalloc(sizeof(*p), GFP\PYGZus{}KERNEL);
hw\PYGZhy{}\PYGZgt{}private\PYGZus{}data = p;
hw\PYGZhy{}\PYGZgt{}private\PYGZus{}free = mydata\PYGZus{}free;
\end{Verbatim}

and the implementation of the destructor would be:

\begin{Verbatim}[commandchars=\\\{\}]
static void mydata\PYGZus{}free(struct snd\PYGZus{}hwdep *hw)
\PYGZob{}
        struct mydata *p = hw\PYGZhy{}\PYGZgt{}private\PYGZus{}data;
        kfree(p);
\PYGZcb{}
\end{Verbatim}

The arbitrary file operations can be defined for this instance. The file
operators are defined in the \code{ops} table. For example, assume that
this chip needs an ioctl.

\begin{Verbatim}[commandchars=\\\{\}]
hw\PYGZhy{}\PYGZgt{}ops.open = mydata\PYGZus{}open;
hw\PYGZhy{}\PYGZgt{}ops.ioctl = mydata\PYGZus{}ioctl;
hw\PYGZhy{}\PYGZgt{}ops.release = mydata\PYGZus{}release;
\end{Verbatim}

And implement the callback functions as you like.


\subsubsection{IEC958 (S/PDIF)}
\label{sound/kernel-api/writing-an-alsa-driver:iec958-s-pdif}
Usually the controls for IEC958 devices are implemented via the control
interface. There is a macro to compose a name string for IEC958
controls, \code{SNDRV\_CTL\_NAME\_IEC958()} defined in
\code{\textless{}include/asound.h\textgreater{}}.

There are some standard controls for IEC958 status bits. These controls
use the type \code{SNDRV\_CTL\_ELEM\_TYPE\_IEC958}, and the size of element is
fixed as 4 bytes array (value.iec958.status{[}x{]}). For the \code{info}
callback, you don't specify the value field for this type (the count
field must be set, though).

“IEC958 Playback Con Mask” is used to return the bit-mask for the IEC958
status bits of consumer mode. Similarly, “IEC958 Playback Pro Mask”
returns the bitmask for professional mode. They are read-only controls,
and are defined as MIXER controls (iface =
\code{SNDRV\_CTL\_ELEM\_IFACE\_MIXER}).

Meanwhile, “IEC958 Playback Default” control is defined for getting and
setting the current default IEC958 bits. Note that this one is usually
defined as a PCM control (iface = \code{SNDRV\_CTL\_ELEM\_IFACE\_PCM}),
although in some places it's defined as a MIXER control.

In addition, you can define the control switches to enable/disable or to
set the raw bit mode. The implementation will depend on the chip, but
the control should be named as “IEC958 xxx”, preferably using the
\code{SNDRV\_CTL\_NAME\_IEC958()} macro.

You can find several cases, for example, \code{pci/emu10k1},
\code{pci/ice1712}, or \code{pci/cmipci.c}.


\subsection{Buffer and Memory Management}
\label{sound/kernel-api/writing-an-alsa-driver:buffer-and-memory-management}

\subsubsection{Buffer Types}
\label{sound/kernel-api/writing-an-alsa-driver:buffer-types}
ALSA provides several different buffer allocation functions depending on
the bus and the architecture. All these have a consistent API. The
allocation of physically-contiguous pages is done via
\code{snd\_malloc\_xxx\_pages()} function, where xxx is the bus
type.

The allocation of pages with fallback is
\code{snd\_malloc\_xxx\_pages\_fallback()}. This function tries
to allocate the specified pages but if the pages are not available, it
tries to reduce the page sizes until enough space is found.

The release the pages, call \code{snd\_free\_xxx\_pages()}
function.

Usually, ALSA drivers try to allocate and reserve a large contiguous
physical space at the time the module is loaded for the later use. This
is called “pre-allocation”. As already written, you can call the
following function at pcm instance construction time (in the case of PCI
bus).

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}pcm\PYGZus{}lib\PYGZus{}preallocate\PYGZus{}pages\PYGZus{}for\PYGZus{}all(pcm, SNDRV\PYGZus{}DMA\PYGZus{}TYPE\PYGZus{}DEV,
                                      snd\PYGZus{}dma\PYGZus{}pci\PYGZus{}data(pci), size, max);
\end{Verbatim}

where \code{size} is the byte size to be pre-allocated and the \code{max} is
the maximum size to be changed via the \code{prealloc} proc file. The
allocator will try to get an area as large as possible within the
given size.

The second argument (type) and the third argument (device pointer) are
dependent on the bus. In the case of the ISA bus, pass
\code{snd\_dma\_isa\_data()} as the third argument with
\code{SNDRV\_DMA\_TYPE\_DEV} type. For the continuous buffer unrelated to the
bus can be pre-allocated with \code{SNDRV\_DMA\_TYPE\_CONTINUOUS} type and the
\code{snd\_dma\_continuous\_data(GFP\_KERNEL)} device pointer, where
\code{GFP\_KERNEL} is the kernel allocation flag to use. For the PCI
scatter-gather buffers, use \code{SNDRV\_DMA\_TYPE\_DEV\_SG} with
\code{snd\_dma\_pci\_data(pci)} (see the {\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:non\string-contiguous\string-buffers]{\emph{Non-Contiguous Buffers}}}
section).

Once the buffer is pre-allocated, you can use the allocator in the
\code{hw\_params} callback:

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}pcm\PYGZus{}lib\PYGZus{}malloc\PYGZus{}pages(substream, size);
\end{Verbatim}

Note that you have to pre-allocate to use this function.


\subsubsection{External Hardware Buffers}
\label{sound/kernel-api/writing-an-alsa-driver:external-hardware-buffers}
Some chips have their own hardware buffers and the DMA transfer from the
host memory is not available. In such a case, you need to either 1)
copy/set the audio data directly to the external hardware buffer, or 2)
make an intermediate buffer and copy/set the data from it to the
external hardware buffer in interrupts (or in tasklets, preferably).

The first case works fine if the external hardware buffer is large
enough. This method doesn't need any extra buffers and thus is more
effective. You need to define the \code{copy\_user} and \code{copy\_kernel}
callbacks for the data transfer, in addition to \code{fill\_silence}
callback for playback. However, there is a drawback: it cannot be
mmapped. The examples are GUS's GF1 PCM or emu8000's wavetable PCM.

The second case allows for mmap on the buffer, although you have to
handle an interrupt or a tasklet to transfer the data from the
intermediate buffer to the hardware buffer. You can find an example in
the vxpocket driver.

Another case is when the chip uses a PCI memory-map region for the
buffer instead of the host memory. In this case, mmap is available only
on certain architectures like the Intel one. In non-mmap mode, the data
cannot be transferred as in the normal way. Thus you need to define the
\code{copy\_user}, \code{copy\_kernel} and \code{fill\_silence} callbacks as well,
as in the cases above. The examples are found in \code{rme32.c} and
\code{rme96.c}.

The implementation of the \code{copy\_user}, \code{copy\_kernel} and
\code{silence} callbacks depends upon whether the hardware supports
interleaved or non-interleaved samples. The \code{copy\_user} callback is
defined like below, a bit differently depending whether the direction
is playback or capture:

\begin{Verbatim}[commandchars=\\\{\}]
static int playback\PYGZus{}copy\PYGZus{}user(struct snd\PYGZus{}pcm\PYGZus{}substream *substream,
             int channel, unsigned long pos,
             void \PYGZus{}\PYGZus{}user *src, unsigned long count);
static int capture\PYGZus{}copy\PYGZus{}user(struct snd\PYGZus{}pcm\PYGZus{}substream *substream,
             int channel, unsigned long pos,
             void \PYGZus{}\PYGZus{}user *dst, unsigned long count);
\end{Verbatim}

In the case of interleaved samples, the second argument (\code{channel}) is
not used. The third argument (\code{pos}) points the current position
offset in bytes.

The meaning of the fourth argument is different between playback and
capture. For playback, it holds the source data pointer, and for
capture, it's the destination data pointer.

The last argument is the number of bytes to be copied.

What you have to do in this callback is again different between playback
and capture directions. In the playback case, you copy the given amount
of data (\code{count}) at the specified pointer (\code{src}) to the specified
offset (\code{pos}) on the hardware buffer. When coded like memcpy-like
way, the copy would be like:

\begin{Verbatim}[commandchars=\\\{\}]
my\PYGZus{}memcpy\PYGZus{}from\PYGZus{}user(my\PYGZus{}buffer + pos, src, count);
\end{Verbatim}

For the capture direction, you copy the given amount of data (\code{count})
at the specified offset (\code{pos}) on the hardware buffer to the
specified pointer (\code{dst}).

\begin{Verbatim}[commandchars=\\\{\}]
my\PYGZus{}memcpy\PYGZus{}to\PYGZus{}user(dst, my\PYGZus{}buffer + pos, count);
\end{Verbatim}

Here the functions are named as \code{from\_user} and \code{to\_user} because
it's the user-space buffer that is passed to these callbacks.  That
is, the callback is supposed to copy from/to the user-space data
directly to/from the hardware buffer.

Careful readers might notice that these callbacks receive the
arguments in bytes, not in frames like other callbacks.  It's because
it would make coding easier like the examples above, and also it makes
easier to unify both the interleaved and non-interleaved cases, as
explained in the following.

In the case of non-interleaved samples, the implementation will be a bit
more complicated.  The callback is called for each channel, passed by
the second argument, so totally it's called for N-channels times per
transfer.

The meaning of other arguments are almost same as the interleaved
case.  The callback is supposed to copy the data from/to the given
user-space buffer, but only for the given channel.  For the detailed
implementations, please check \code{isa/gus/gus\_pcm.c} or
``pci/rme9652/rme9652.c'' as examples.

The above callbacks are the copy from/to the user-space buffer.  There
are some cases where we want copy from/to the kernel-space buffer
instead.  In such a case, \code{copy\_kernel} callback is called.  It'd
look like:

\begin{Verbatim}[commandchars=\\\{\}]
static int playback\PYGZus{}copy\PYGZus{}kernel(struct snd\PYGZus{}pcm\PYGZus{}substream *substream,
             int channel, unsigned long pos,
             void *src, unsigned long count);
static int capture\PYGZus{}copy\PYGZus{}kernel(struct snd\PYGZus{}pcm\PYGZus{}substream *substream,
             int channel, unsigned long pos,
             void *dst, unsigned long count);
\end{Verbatim}

As found easily, the only difference is that the buffer pointer is
without \code{\_\_user} prefix; that is, a kernel-buffer pointer is passed
in the fourth argument.  Correspondingly, the implementation would be
a version without the user-copy, such as:

\begin{Verbatim}[commandchars=\\\{\}]
my\PYGZus{}memcpy(my\PYGZus{}buffer + pos, src, count);
\end{Verbatim}

Usually for the playback, another callback \code{fill\_silence} is
defined.  It's implemented in a similar way as the copy callbacks
above:

\begin{Verbatim}[commandchars=\\\{\}]
static int silence(struct snd\PYGZus{}pcm\PYGZus{}substream *substream, int channel,
                   unsigned long pos, unsigned long count);
\end{Verbatim}

The meanings of arguments are the same as in the \code{copy\_user} and
\code{copy\_kernel} callbacks, although there is no buffer pointer
argument. In the case of interleaved samples, the channel argument has
no meaning, as well as on \code{copy\_*} callbacks.

The role of \code{fill\_silence} callback is to set the given amount
(\code{count}) of silence data at the specified offset (\code{pos}) on the
hardware buffer. Suppose that the data format is signed (that is, the
silent-data is 0), and the implementation using a memset-like function
would be like:

\begin{Verbatim}[commandchars=\\\{\}]
my\PYGZus{}memset(my\PYGZus{}buffer + pos, 0, count);
\end{Verbatim}

In the case of non-interleaved samples, again, the implementation
becomes a bit more complicated, as it's called N-times per transfer
for each channel. See, for example, \code{isa/gus/gus\_pcm.c}.


\subsubsection{Non-Contiguous Buffers}
\label{sound/kernel-api/writing-an-alsa-driver:non-contiguous-buffers}
If your hardware supports the page table as in emu10k1 or the buffer
descriptors as in via82xx, you can use the scatter-gather (SG) DMA. ALSA
provides an interface for handling SG-buffers. The API is provided in
\code{\textless{}sound/pcm.h\textgreater{}}.

For creating the SG-buffer handler, call
\code{snd\_pcm\_lib\_preallocate\_pages()} or
\code{snd\_pcm\_lib\_preallocate\_pages\_for\_all()} with
\code{SNDRV\_DMA\_TYPE\_DEV\_SG} in the PCM constructor like other PCI
pre-allocator. You need to pass \code{snd\_dma\_pci\_data(pci)}, where pci is
the \code{struct pci\_dev} pointer of the chip as
well. The \code{struct snd\_sg\_buf} instance is created as
\code{substream-\textgreater{}dma\_private}. You can cast the pointer like:

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}sg\PYGZus{}buf *sgbuf = (struct snd\PYGZus{}sg\PYGZus{}buf *)substream\PYGZhy{}\PYGZgt{}dma\PYGZus{}private;
\end{Verbatim}

Then call \code{snd\_pcm\_lib\_malloc\_pages()} in the \code{hw\_params}
callback as well as in the case of normal PCI buffer. The SG-buffer
handler will allocate the non-contiguous kernel pages of the given size
and map them onto the virtually contiguous memory. The virtual pointer
is addressed in runtime-\textgreater{}dma\_area. The physical address
(\code{runtime-\textgreater{}dma\_addr}) is set to zero, because the buffer is
physically non-contiguous. The physical address table is set up in
\code{sgbuf-\textgreater{}table}. You can get the physical address at a certain offset
via \code{snd\_pcm\_sgbuf\_get\_addr()}.

When a SG-handler is used, you need to set
\code{snd\_pcm\_sgbuf\_ops\_page()} as the \code{page} callback. (See
{\hyperref[sound/kernel\string-api/writing\string-an\string-alsa\string-driver:page\string-callback]{\emph{page callback}}} section.)

To release the data, call \code{snd\_pcm\_lib\_free\_pages()} in
the \code{hw\_free} callback as usual.


\subsubsection{Vmalloc'ed Buffers}
\label{sound/kernel-api/writing-an-alsa-driver:vmalloc-ed-buffers}
It's possible to use a buffer allocated via \code{vmalloc()}, for
example, for an intermediate buffer. Since the allocated pages are not
contiguous, you need to set the \code{page} callback to obtain the physical
address at every offset.

The implementation of \code{page} callback would be like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZlt{}linux/vmalloc.h\PYGZgt{}

/* get the physical page pointer on the given offset */
static struct page *mychip\PYGZus{}page(struct snd\PYGZus{}pcm\PYGZus{}substream *substream,
                                unsigned long offset)
\PYGZob{}
        void *pageptr = substream\PYGZhy{}\PYGZgt{}runtime\PYGZhy{}\PYGZgt{}dma\PYGZus{}area + offset;
        return vmalloc\PYGZus{}to\PYGZus{}page(pageptr);
\PYGZcb{}
\end{Verbatim}


\subsection{Proc Interface}
\label{sound/kernel-api/writing-an-alsa-driver:proc-interface}
ALSA provides an easy interface for procfs. The proc files are very
useful for debugging. I recommend you set up proc files if you write a
driver and want to get a running status or register dumps. The API is
found in \code{\textless{}sound/info.h\textgreater{}}.

To create a proc file, call \code{snd\_card\_proc\_new()}.

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}info\PYGZus{}entry *entry;
int err = snd\PYGZus{}card\PYGZus{}proc\PYGZus{}new(card, \PYGZdq{}my\PYGZhy{}file\PYGZdq{}, \PYGZam{}entry);
\end{Verbatim}

where the second argument specifies the name of the proc file to be
created. The above example will create a file \code{my-file} under the
card directory, e.g. \code{/proc/asound/card0/my-file}.

Like other components, the proc entry created via
\code{snd\_card\_proc\_new()} will be registered and released
automatically in the card registration and release functions.

When the creation is successful, the function stores a new instance in
the pointer given in the third argument. It is initialized as a text
proc file for read only. To use this proc file as a read-only text file
as it is, set the read callback with a private data via
\code{snd\_info\_set\_text\_ops()}.

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}info\PYGZus{}set\PYGZus{}text\PYGZus{}ops(entry, chip, my\PYGZus{}proc\PYGZus{}read);
\end{Verbatim}

where the second argument (\code{chip}) is the private data to be used in
the callbacks. The third parameter specifies the read buffer size and
the fourth (\code{my\_proc\_read}) is the callback function, which is
defined like

\begin{Verbatim}[commandchars=\\\{\}]
static void my\PYGZus{}proc\PYGZus{}read(struct snd\PYGZus{}info\PYGZus{}entry *entry,
                         struct snd\PYGZus{}info\PYGZus{}buffer *buffer);
\end{Verbatim}

In the read callback, use \code{snd\_iprintf()} for output
strings, which works just like normal \code{printf()}. For
example,

\begin{Verbatim}[commandchars=\\\{\}]
static void my\PYGZus{}proc\PYGZus{}read(struct snd\PYGZus{}info\PYGZus{}entry *entry,
                         struct snd\PYGZus{}info\PYGZus{}buffer *buffer)
\PYGZob{}
        struct my\PYGZus{}chip *chip = entry\PYGZhy{}\PYGZgt{}private\PYGZus{}data;

        snd\PYGZus{}iprintf(buffer, \PYGZdq{}This is my chip!\PYGZbs{}n\PYGZdq{});
        snd\PYGZus{}iprintf(buffer, \PYGZdq{}Port = \PYGZpc{}ld\PYGZbs{}n\PYGZdq{}, chip\PYGZhy{}\PYGZgt{}port);
\PYGZcb{}
\end{Verbatim}

The file permissions can be changed afterwards. As default, it's set as
read only for all users. If you want to add write permission for the
user (root as default), do as follows:

\begin{Verbatim}[commandchars=\\\{\}]
entry\PYGZhy{}\PYGZgt{}mode = S\PYGZus{}IFREG \textbar{} S\PYGZus{}IRUGO \textbar{} S\PYGZus{}IWUSR;
\end{Verbatim}

and set the write buffer size and the callback

\begin{Verbatim}[commandchars=\\\{\}]
entry\PYGZhy{}\PYGZgt{}c.text.write = my\PYGZus{}proc\PYGZus{}write;
\end{Verbatim}

For the write callback, you can use \code{snd\_info\_get\_line()}
to get a text line, and \code{snd\_info\_get\_str()} to retrieve
a string from the line. Some examples are found in
\code{core/oss/mixer\_oss.c}, core/oss/and \code{pcm\_oss.c}.

For a raw-data proc-file, set the attributes as follows:

\begin{Verbatim}[commandchars=\\\{\}]
static struct snd\PYGZus{}info\PYGZus{}entry\PYGZus{}ops my\PYGZus{}file\PYGZus{}io\PYGZus{}ops = \PYGZob{}
        .read = my\PYGZus{}file\PYGZus{}io\PYGZus{}read,
\PYGZcb{};

entry\PYGZhy{}\PYGZgt{}content = SNDRV\PYGZus{}INFO\PYGZus{}CONTENT\PYGZus{}DATA;
entry\PYGZhy{}\PYGZgt{}private\PYGZus{}data = chip;
entry\PYGZhy{}\PYGZgt{}c.ops = \PYGZam{}my\PYGZus{}file\PYGZus{}io\PYGZus{}ops;
entry\PYGZhy{}\PYGZgt{}size = 4096;
entry\PYGZhy{}\PYGZgt{}mode = S\PYGZus{}IFREG \textbar{} S\PYGZus{}IRUGO;
\end{Verbatim}

For the raw data, \code{size} field must be set properly. This specifies
the maximum size of the proc file access.

The read/write callbacks of raw mode are more direct than the text mode.
You need to use a low-level I/O functions such as
\code{copy\_from/to\_user()} to transfer the data.

\begin{Verbatim}[commandchars=\\\{\}]
static ssize\PYGZus{}t my\PYGZus{}file\PYGZus{}io\PYGZus{}read(struct snd\PYGZus{}info\PYGZus{}entry *entry,
                            void *file\PYGZus{}private\PYGZus{}data,
                            struct file *file,
                            char *buf,
                            size\PYGZus{}t count,
                            loff\PYGZus{}t pos)
\PYGZob{}
        if (copy\PYGZus{}to\PYGZus{}user(buf, local\PYGZus{}data + pos, count))
                return \PYGZhy{}EFAULT;
        return count;
\PYGZcb{}
\end{Verbatim}

If the size of the info entry has been set up properly, \code{count} and
\code{pos} are guaranteed to fit within 0 and the given size. You don't
have to check the range in the callbacks unless any other condition is
required.


\subsection{Power Management}
\label{sound/kernel-api/writing-an-alsa-driver:power-management}
If the chip is supposed to work with suspend/resume functions, you need
to add power-management code to the driver. The additional code for
power-management should be ifdef-ed with \code{CONFIG\_PM}.

If the driver \emph{fully} supports suspend/resume that is, the device can be
properly resumed to its state when suspend was called, you can set the
\code{SNDRV\_PCM\_INFO\_RESUME} flag in the pcm info field. Usually, this is
possible when the registers of the chip can be safely saved and restored
to RAM. If this is set, the trigger callback is called with
\code{SNDRV\_PCM\_TRIGGER\_RESUME} after the resume callback completes.

Even if the driver doesn't support PM fully but partial suspend/resume
is still possible, it's still worthy to implement suspend/resume
callbacks. In such a case, applications would reset the status by
calling {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_pcm_prepare]{\emph{\code{snd\_pcm\_prepare()}}}} and restart the stream
appropriately. Hence, you can define suspend/resume callbacks below but
don't set \code{SNDRV\_PCM\_INFO\_RESUME} info flag to the PCM.

Note that the trigger with SUSPEND can always be called when
\code{snd\_pcm\_suspend\_all()} is called, regardless of the
\code{SNDRV\_PCM\_INFO\_RESUME} flag. The \code{RESUME} flag affects only the
behavior of \code{snd\_pcm\_resume()}. (Thus, in theory,
\code{SNDRV\_PCM\_TRIGGER\_RESUME} isn't needed to be handled in the trigger
callback when no \code{SNDRV\_PCM\_INFO\_RESUME} flag is set. But, it's better
to keep it for compatibility reasons.)

In the earlier version of ALSA drivers, a common power-management layer
was provided, but it has been removed. The driver needs to define the
suspend/resume hooks according to the bus the device is connected to. In
the case of PCI drivers, the callbacks look like below:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}ifdef CONFIG\PYGZus{}PM
static int snd\PYGZus{}my\PYGZus{}suspend(struct pci\PYGZus{}dev *pci, pm\PYGZus{}message\PYGZus{}t state)
\PYGZob{}
        .... /* do things for suspend */
        return 0;
\PYGZcb{}
static int snd\PYGZus{}my\PYGZus{}resume(struct pci\PYGZus{}dev *pci)
\PYGZob{}
        .... /* do things for suspend */
        return 0;
\PYGZcb{}
\PYGZsh{}endif
\end{Verbatim}

The scheme of the real suspend job is as follows.
\begin{enumerate}
\item {} 
Retrieve the card and the chip data.

\item {} 
Call \code{snd\_power\_change\_state()} with
\code{SNDRV\_CTL\_POWER\_D3hot} to change the power status.

\item {} 
Call \code{snd\_pcm\_suspend\_all()} to suspend the running
PCM streams.

\item {} 
If AC97 codecs are used, call {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_suspend]{\emph{\code{snd\_ac97\_suspend()}}}} for
each codec.

\item {} 
Save the register values if necessary.

\item {} 
Stop the hardware if necessary.

\item {} 
Disable the PCI device by calling
\code{pci\_disable\_device()}. Then, call
\code{pci\_save\_state()} at last.

\end{enumerate}

A typical code would be like:

\begin{Verbatim}[commandchars=\\\{\}]
static int mychip\PYGZus{}suspend(struct pci\PYGZus{}dev *pci, pm\PYGZus{}message\PYGZus{}t state)
\PYGZob{}
        /* (1) */
        struct snd\PYGZus{}card *card = pci\PYGZus{}get\PYGZus{}drvdata(pci);
        struct mychip *chip = card\PYGZhy{}\PYGZgt{}private\PYGZus{}data;
        /* (2) */
        snd\PYGZus{}power\PYGZus{}change\PYGZus{}state(card, SNDRV\PYGZus{}CTL\PYGZus{}POWER\PYGZus{}D3hot);
        /* (3) */
        snd\PYGZus{}pcm\PYGZus{}suspend\PYGZus{}all(chip\PYGZhy{}\PYGZgt{}pcm);
        /* (4) */
        snd\PYGZus{}ac97\PYGZus{}suspend(chip\PYGZhy{}\PYGZgt{}ac97);
        /* (5) */
        snd\PYGZus{}mychip\PYGZus{}save\PYGZus{}registers(chip);
        /* (6) */
        snd\PYGZus{}mychip\PYGZus{}stop\PYGZus{}hardware(chip);
        /* (7) */
        pci\PYGZus{}disable\PYGZus{}device(pci);
        pci\PYGZus{}save\PYGZus{}state(pci);
        return 0;
\PYGZcb{}
\end{Verbatim}

The scheme of the real resume job is as follows.
\begin{enumerate}
\item {} 
Retrieve the card and the chip data.

\item {} 
Set up PCI. First, call \code{pci\_restore\_state()}. Then
enable the pci device again by calling
\code{pci\_enable\_device()}. Call
\code{pci\_set\_master()} if necessary, too.

\item {} 
Re-initialize the chip.

\item {} 
Restore the saved registers if necessary.

\item {} 
Resume the mixer, e.g. calling {\hyperref[sound/kernel\string-api/alsa\string-driver\string-api:c.snd_ac97_resume]{\emph{\code{snd\_ac97\_resume()}}}}.

\item {} 
Restart the hardware (if any).

\item {} 
Call \code{snd\_power\_change\_state()} with
\code{SNDRV\_CTL\_POWER\_D0} to notify the processes.

\end{enumerate}

A typical code would be like:

\begin{Verbatim}[commandchars=\\\{\}]
static int mychip\PYGZus{}resume(struct pci\PYGZus{}dev *pci)
\PYGZob{}
        /* (1) */
        struct snd\PYGZus{}card *card = pci\PYGZus{}get\PYGZus{}drvdata(pci);
        struct mychip *chip = card\PYGZhy{}\PYGZgt{}private\PYGZus{}data;
        /* (2) */
        pci\PYGZus{}restore\PYGZus{}state(pci);
        pci\PYGZus{}enable\PYGZus{}device(pci);
        pci\PYGZus{}set\PYGZus{}master(pci);
        /* (3) */
        snd\PYGZus{}mychip\PYGZus{}reinit\PYGZus{}chip(chip);
        /* (4) */
        snd\PYGZus{}mychip\PYGZus{}restore\PYGZus{}registers(chip);
        /* (5) */
        snd\PYGZus{}ac97\PYGZus{}resume(chip\PYGZhy{}\PYGZgt{}ac97);
        /* (6) */
        snd\PYGZus{}mychip\PYGZus{}restart\PYGZus{}chip(chip);
        /* (7) */
        snd\PYGZus{}power\PYGZus{}change\PYGZus{}state(card, SNDRV\PYGZus{}CTL\PYGZus{}POWER\PYGZus{}D0);
        return 0;
\PYGZcb{}
\end{Verbatim}

As shown in the above, it's better to save registers after suspending
the PCM operations via \code{snd\_pcm\_suspend\_all()} or
\code{snd\_pcm\_suspend()}. It means that the PCM streams are
already stopped when the register snapshot is taken. But, remember that
you don't have to restart the PCM stream in the resume callback. It'll
be restarted via trigger call with \code{SNDRV\_PCM\_TRIGGER\_RESUME} when
necessary.

OK, we have all callbacks now. Let's set them up. In the initialization
of the card, make sure that you can get the chip data from the card
instance, typically via \code{private\_data} field, in case you created the
chip data individually.

\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}mychip\PYGZus{}probe(struct pci\PYGZus{}dev *pci,
                            const struct pci\PYGZus{}device\PYGZus{}id *pci\PYGZus{}id)
\PYGZob{}
        ....
        struct snd\PYGZus{}card *card;
        struct mychip *chip;
        int err;
        ....
        err = snd\PYGZus{}card\PYGZus{}new(\PYGZam{}pci\PYGZhy{}\PYGZgt{}dev, index[dev], id[dev], THIS\PYGZus{}MODULE,
                           0, \PYGZam{}card);
        ....
        chip = kzalloc(sizeof(*chip), GFP\PYGZus{}KERNEL);
        ....
        card\PYGZhy{}\PYGZgt{}private\PYGZus{}data = chip;
        ....
\PYGZcb{}
\end{Verbatim}

When you created the chip data with \code{snd\_card\_new()}, it's
anyway accessible via \code{private\_data} field.

\begin{Verbatim}[commandchars=\\\{\}]
static int snd\PYGZus{}mychip\PYGZus{}probe(struct pci\PYGZus{}dev *pci,
                            const struct pci\PYGZus{}device\PYGZus{}id *pci\PYGZus{}id)
\PYGZob{}
        ....
        struct snd\PYGZus{}card *card;
        struct mychip *chip;
        int err;
        ....
        err = snd\PYGZus{}card\PYGZus{}new(\PYGZam{}pci\PYGZhy{}\PYGZgt{}dev, index[dev], id[dev], THIS\PYGZus{}MODULE,
                           sizeof(struct mychip), \PYGZam{}card);
        ....
        chip = card\PYGZhy{}\PYGZgt{}private\PYGZus{}data;
        ....
\PYGZcb{}
\end{Verbatim}

If you need a space to save the registers, allocate the buffer for it
here, too, since it would be fatal if you cannot allocate a memory in
the suspend phase. The allocated buffer should be released in the
corresponding destructor.

And next, set suspend/resume callbacks to the pci\_driver.

\begin{Verbatim}[commandchars=\\\{\}]
static struct pci\PYGZus{}driver driver = \PYGZob{}
        .name = KBUILD\PYGZus{}MODNAME,
        .id\PYGZus{}table = snd\PYGZus{}my\PYGZus{}ids,
        .probe = snd\PYGZus{}my\PYGZus{}probe,
        .remove = snd\PYGZus{}my\PYGZus{}remove,
\PYGZsh{}ifdef CONFIG\PYGZus{}PM
        .suspend = snd\PYGZus{}my\PYGZus{}suspend,
        .resume = snd\PYGZus{}my\PYGZus{}resume,
\PYGZsh{}endif
\PYGZcb{};
\end{Verbatim}


\subsection{Module Parameters}
\label{sound/kernel-api/writing-an-alsa-driver:module-parameters}
There are standard module options for ALSA. At least, each module should
have the \code{index}, \code{id} and \code{enable} options.

If the module supports multiple cards (usually up to 8 = \code{SNDRV\_CARDS}
cards), they should be arrays. The default initial values are defined
already as constants for easier programming:

\begin{Verbatim}[commandchars=\\\{\}]
static int index[SNDRV\PYGZus{}CARDS] = SNDRV\PYGZus{}DEFAULT\PYGZus{}IDX;
static char *id[SNDRV\PYGZus{}CARDS] = SNDRV\PYGZus{}DEFAULT\PYGZus{}STR;
static int enable[SNDRV\PYGZus{}CARDS] = SNDRV\PYGZus{}DEFAULT\PYGZus{}ENABLE\PYGZus{}PNP;
\end{Verbatim}

If the module supports only a single card, they could be single
variables, instead. \code{enable} option is not always necessary in this
case, but it would be better to have a dummy option for compatibility.

The module parameters must be declared with the standard
\code{module\_param()()}, \code{module\_param\_array()()} and
\code{MODULE\_PARM\_DESC()} macros.

The typical coding would be like below:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}define CARD\PYGZus{}NAME \PYGZdq{}My Chip\PYGZdq{}

module\PYGZus{}param\PYGZus{}array(index, int, NULL, 0444);
MODULE\PYGZus{}PARM\PYGZus{}DESC(index, \PYGZdq{}Index value for \PYGZdq{} CARD\PYGZus{}NAME \PYGZdq{} soundcard.\PYGZdq{});
module\PYGZus{}param\PYGZus{}array(id, charp, NULL, 0444);
MODULE\PYGZus{}PARM\PYGZus{}DESC(id, \PYGZdq{}ID string for \PYGZdq{} CARD\PYGZus{}NAME \PYGZdq{} soundcard.\PYGZdq{});
module\PYGZus{}param\PYGZus{}array(enable, bool, NULL, 0444);
MODULE\PYGZus{}PARM\PYGZus{}DESC(enable, \PYGZdq{}Enable \PYGZdq{} CARD\PYGZus{}NAME \PYGZdq{} soundcard.\PYGZdq{});
\end{Verbatim}

Also, don't forget to define the module description, classes, license
and devices. Especially, the recent modprobe requires to define the
module license as GPL, etc., otherwise the system is shown as “tainted”.

\begin{Verbatim}[commandchars=\\\{\}]
MODULE\PYGZus{}DESCRIPTION(\PYGZdq{}My Chip\PYGZdq{});
MODULE\PYGZus{}LICENSE(\PYGZdq{}GPL\PYGZdq{});
MODULE\PYGZus{}SUPPORTED\PYGZus{}DEVICE(\PYGZdq{}\PYGZob{}\PYGZob{}Vendor,My Chip Name\PYGZcb{}\PYGZcb{}\PYGZdq{});
\end{Verbatim}


\subsection{How To Put Your Driver Into ALSA Tree}
\label{sound/kernel-api/writing-an-alsa-driver:how-to-put-your-driver-into-alsa-tree}

\subsubsection{General}
\label{sound/kernel-api/writing-an-alsa-driver:id8}
So far, you've learned how to write the driver codes. And you might have
a question now: how to put my own driver into the ALSA driver tree? Here
(finally :) the standard procedure is described briefly.

Suppose that you create a new PCI driver for the card “xyz”. The card
module name would be snd-xyz. The new driver is usually put into the
alsa-driver tree, \code{alsa-driver/pci} directory in the case of PCI
cards. Then the driver is evaluated, audited and tested by developers
and users. After a certain time, the driver will go to the alsa-kernel
tree (to the corresponding directory, such as \code{alsa-kernel/pci}) and
eventually will be integrated into the Linux 2.6 tree (the directory
would be \code{linux/sound/pci}).

In the following sections, the driver code is supposed to be put into
alsa-driver tree. The two cases are covered: a driver consisting of a
single source file and one consisting of several source files.


\subsubsection{Driver with A Single Source File}
\label{sound/kernel-api/writing-an-alsa-driver:driver-with-a-single-source-file}\begin{enumerate}
\item {} 
Modify alsa-driver/pci/Makefile

Suppose you have a file xyz.c. Add the following two lines

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZhy{}xyz\PYGZhy{}objs := xyz.o
obj\PYGZhy{}\PYGZdl{}(CONFIG\PYGZus{}SND\PYGZus{}XYZ) += snd\PYGZhy{}xyz.o
\end{Verbatim}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Create the Kconfig entry

Add the new entry of Kconfig for your xyz driver. config SND\_XYZ
tristate ``Foobar XYZ'' depends on SND select SND\_PCM help Say Y here
to include support for Foobar XYZ soundcard. To compile this driver
as a module, choose M here: the module will be called snd-xyz. the
line, select SND\_PCM, specifies that the driver xyz supports PCM. In
addition to SND\_PCM, the following components are supported for
select command: SND\_RAWMIDI, SND\_TIMER, SND\_HWDEP,
SND\_MPU401\_UART, SND\_OPL3\_LIB, SND\_OPL4\_LIB, SND\_VX\_LIB,
SND\_AC97\_CODEC. Add the select command for each supported
component.

Note that some selections imply the lowlevel selections. For example,
PCM includes TIMER, MPU401\_UART includes RAWMIDI, AC97\_CODEC
includes PCM, and OPL3\_LIB includes HWDEP. You don't need to give
the lowlevel selections again.

For the details of Kconfig script, refer to the kbuild documentation.

\item {} 
Run cvscompile script to re-generate the configure script and build
the whole stuff again.

\end{enumerate}


\subsubsection{Drivers with Several Source Files}
\label{sound/kernel-api/writing-an-alsa-driver:drivers-with-several-source-files}
Suppose that the driver snd-xyz have several source files. They are
located in the new subdirectory, pci/xyz.
\begin{enumerate}
\item {} 
Add a new directory (\code{xyz}) in \code{alsa-driver/pci/Makefile} as
below

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
obj\PYGZhy{}\PYGZdl{}(CONFIG\PYGZus{}SND) += xyz/
\end{Verbatim}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Under the directory \code{xyz}, create a Makefile

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
ifndef SND\PYGZus{}TOPDIR
SND\PYGZus{}TOPDIR=../..
endif

include \PYGZdl{}(SND\PYGZus{}TOPDIR)/toplevel.config
include \PYGZdl{}(SND\PYGZus{}TOPDIR)/Makefile.conf

snd\PYGZhy{}xyz\PYGZhy{}objs := xyz.o abc.o def.o

obj\PYGZhy{}\PYGZdl{}(CONFIG\PYGZus{}SND\PYGZus{}XYZ) += snd\PYGZhy{}xyz.o

include \PYGZdl{}(SND\PYGZus{}TOPDIR)/Rules.make
\end{Verbatim}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Create the Kconfig entry

This procedure is as same as in the last section.

\item {} 
Run cvscompile script to re-generate the configure script and build
the whole stuff again.

\end{enumerate}


\subsection{Useful Functions}
\label{sound/kernel-api/writing-an-alsa-driver:useful-functions}

\subsubsection{\texttt{snd\_printk()} and friends}
\label{sound/kernel-api/writing-an-alsa-driver:snd-printk-and-friends}
ALSA provides a verbose version of the \code{printk()} function.
If a kernel config \code{CONFIG\_SND\_VERBOSE\_PRINTK} is set, this function
prints the given message together with the file name and the line of the
caller. The \code{KERN\_XXX} prefix is processed as well as the original
\code{printk()} does, so it's recommended to add this prefix,
e.g. snd\_printk(KERN\_ERR ``Oh my, sorry, it's extremely bad!\textbackslash{}n'');

There are also \code{printk()}`s for debugging.
\code{snd\_printd()} can be used for general debugging purposes.
If \code{CONFIG\_SND\_DEBUG} is set, this function is compiled, and works
just like \code{snd\_printk()}. If the ALSA is compiled without
the debugging flag, it's ignored.

\code{snd\_printdd()} is compiled in only when
\code{CONFIG\_SND\_DEBUG\_VERBOSE} is set. Please note that
\code{CONFIG\_SND\_DEBUG\_VERBOSE} is not set as default even if you configure
the alsa-driver with \code{-{-}with-debug=full} option. You need to give
explicitly \code{-{-}with-debug=detect} option instead.


\subsubsection{\texttt{snd\_BUG()}}
\label{sound/kernel-api/writing-an-alsa-driver:snd-bug}
It shows the \code{BUG?} message and stack trace as well as
\code{snd\_BUG\_ON()} at the point. It's useful to show that a
fatal error happens there.

When no debug flag is set, this macro is ignored.


\subsubsection{\texttt{snd\_BUG\_ON()}}
\label{sound/kernel-api/writing-an-alsa-driver:snd-bug-on}
\code{snd\_BUG\_ON()} macro is similar with
\code{WARN\_ON()} macro. For example, snd\_BUG\_ON(!pointer); or
it can be used as the condition, if (snd\_BUG\_ON(non\_zero\_is\_bug))
return -EINVAL;

The macro takes an conditional expression to evaluate. When
\code{CONFIG\_SND\_DEBUG}, is set, if the expression is non-zero, it shows
the warning message such as \code{BUG? (xxx)} normally followed by stack
trace. In both cases it returns the evaluated value.


\subsection{Acknowledgments}
\label{sound/kernel-api/writing-an-alsa-driver:acknowledgments}
I would like to thank Phil Kerr for his help for improvement and
corrections of this document.

Kevin Conder reformatted the original plain-text to the DocBook format.

Giuliano Pochini corrected typos and contributed the example codes in
the hardware constraints section.


\chapter{Designs and Implementations}
\label{sound/designs/index:designs-and-implementations}\label{sound/designs/index::doc}

\section{Standard ALSA Control Names}
\label{sound/designs/control-names::doc}\label{sound/designs/control-names:standard-alsa-control-names}
This document describes standard names of mixer controls.


\subsection{Standard Syntax}
\label{sound/designs/control-names:standard-syntax}
Syntax: {[}LOCATION{]} SOURCE {[}CHANNEL{]} {[}DIRECTION{]} FUNCTION


\subsubsection{DIRECTION}
\label{sound/designs/control-names:direction}
\begin{tabulary}{\linewidth}{|L|L|}
\hline

\textless{}nothing\textgreater{}
 & 
both directions
\\
\hline
Playback
 & 
one direction
\\
\hline
Capture
 & 
one direction
\\
\hline
Bypass Playback
 & 
one direction
\\
\hline
Bypass Capture
 & 
one direction
\\
\hline\end{tabulary}



\subsubsection{FUNCTION}
\label{sound/designs/control-names:function}
\begin{tabulary}{\linewidth}{|L|L|}
\hline

Switch
 & 
on/off switch
\\
\hline
Volume
 & 
amplifier
\\
\hline
Route
 & 
route control, hardware specific
\\
\hline\end{tabulary}



\subsubsection{CHANNEL}
\label{sound/designs/control-names:channel}
\begin{tabulary}{\linewidth}{|L|L|}
\hline

\textless{}nothing\textgreater{}
 & 
channel independent, or applies to all channels
\\
\hline
Front
 & 
front left/right channels
\\
\hline
Surround
 & 
rear left/right in 4.0/5.1 surround
\\
\hline
CLFE
 & 
C/LFE channels
\\
\hline
Center
 & 
center cannel
\\
\hline
LFE
 & 
LFE channel
\\
\hline
Side
 & 
side left/right for 7.1 surround
\\
\hline\end{tabulary}



\subsubsection{LOCATION (Physical location of source)}
\label{sound/designs/control-names:location-physical-location-of-source}
\begin{tabulary}{\linewidth}{|L|L|}
\hline

Front
 & 
front position
\\
\hline
Rear
 & 
rear position
\\
\hline
Dock
 & 
on docking station
\\
\hline
Internal
 & 
internal
\\
\hline\end{tabulary}



\subsubsection{SOURCE}
\label{sound/designs/control-names:source}
\begin{longtable}{|l|l|}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


Master
 & \\
\hline
Master Mono
 & \\
\hline
Hardware Master
 & \\
\hline
Speaker
 & 
internal speaker
\\
\hline
Bass Speaker
 & 
internal LFE speaker
\\
\hline
Headphone
 & \\
\hline
Line Out
 & \\
\hline
Beep
 & 
beep generator
\\
\hline
Phone
 & \\
\hline
Phone Input
 & \\
\hline
Phone Output
 & \\
\hline
Synth
 & \\
\hline
FM
 & \\
\hline
Mic
 & \\
\hline
Headset Mic
 & 
mic part of combined headset jack - 4-pin
headphone + mic
\\
\hline
Headphone Mic
 & 
mic part of either/or - 3-pin headphone or mic
\\
\hline
Line
 & 
input only, use ``Line Out'' for output
\\
\hline
CD
 & \\
\hline
Video
 & \\
\hline
Zoom Video
 & \\
\hline
Aux
 & \\
\hline
PCM
 & \\
\hline
PCM Pan
 & \\
\hline
Loopback
 & \\
\hline
Analog Loopback
 & 
D/A -\textgreater{} A/D loopback
\\
\hline
Digital Loopback
 & 
playback -\textgreater{} capture loopback -
without analog path
\\
\hline
Mono
 & \\
\hline
Mono Output
 & \\
\hline
Multi
 & \\
\hline
ADC
 & \\
\hline
Wave
 & \\
\hline
Music
 & \\
\hline
I2S
 & \\
\hline
IEC958
 & \\
\hline
HDMI
 & \\
\hline
SPDIF
 & 
output only
\\
\hline
SPDIF In
 & \\
\hline
Digital In
 & \\
\hline
HDMI/DP
 & 
either HDMI or DisplayPort
\\
\hline\end{longtable}



\subsection{Exceptions (deprecated)}
\label{sound/designs/control-names:exceptions-deprecated}
\begin{tabulary}{\linewidth}{|L|L|}
\hline

{[}Analogue\textbar{}Digital{]} Capture Source
 & \\
\hline
{[}Analogue\textbar{}Digital{]} Capture Switch
 & 
aka input gain switch
\\
\hline
{[}Analogue\textbar{}Digital{]} Capture Volume
 & 
aka input gain volume
\\
\hline
{[}Analogue\textbar{}Digital{]} Playback Switch
 & 
aka output gain switch
\\
\hline
{[}Analogue\textbar{}Digital{]} Playback Volume
 & 
aka output gain volume
\\
\hline
Tone Control - Switch
 & \\
\hline
Tone Control - Bass
 & \\
\hline
Tone Control - Treble
 & \\
\hline
3D Control - Switch
 & \\
\hline
3D Control - Center
 & \\
\hline
3D Control - Depth
 & \\
\hline
3D Control - Wide
 & \\
\hline
3D Control - Space
 & \\
\hline
3D Control - Level
 & \\
\hline
Mic Boost {[}(?dB){]}
 & \\
\hline\end{tabulary}



\subsection{PCM interface}
\label{sound/designs/control-names:pcm-interface}
\begin{tabulary}{\linewidth}{|L|L|}
\hline

Sample Clock Source
 & 
\{ ``Word'', ``Internal'', ``AutoSync'' \}
\\
\hline
Clock Sync Status
 & 
\{ ``Lock'', ``Sync'', ``No Lock'' \}
\\
\hline
External Rate
 & 
external capture rate
\\
\hline
Capture Rate
 & 
capture rate taken from external source
\\
\hline\end{tabulary}



\subsection{IEC958 (S/PDIF) interface}
\label{sound/designs/control-names:iec958-s-pdif-interface}
\begin{tabulary}{\linewidth}{|L|L|}
\hline

IEC958 {[}...{]} {[}Playback\textbar{}Capture{]} Switch
 & 
turn on/off the IEC958 interface
\\
\hline
IEC958 {[}...{]} {[}Playback\textbar{}Capture{]} Volume
 & 
digital volume control
\\
\hline
IEC958 {[}...{]} {[}Playback\textbar{}Capture{]} Default
 & 
default or global value - read/write
\\
\hline
IEC958 {[}...{]} {[}Playback\textbar{}Capture{]} Mask
 & 
consumer and professional mask
\\
\hline
IEC958 {[}...{]} {[}Playback\textbar{}Capture{]} Con Mask
 & 
consumer mask
\\
\hline
IEC958 {[}...{]} {[}Playback\textbar{}Capture{]} Pro Mask
 & 
professional mask
\\
\hline
IEC958 {[}...{]} {[}Playback\textbar{}Capture{]} PCM Stream
 & 
the settings assigned to a PCM stream
\\
\hline
IEC958 Q-subcode {[}Playback\textbar{}Capture{]} Default
 & 
Q-subcode bits
\\
\hline
IEC958 Preamble {[}Playback\textbar{}Capture{]} Default
 & 
burst preamble words (4*16bits)
\\
\hline\end{tabulary}



\section{ALSA PCM channel-mapping API}
\label{sound/designs/channel-mapping-api:alsa-pcm-channel-mapping-api}\label{sound/designs/channel-mapping-api::doc}
Takashi Iwai \textless{}\href{mailto:tiwai@suse.de}{tiwai@suse.de}\textgreater{}


\subsection{General}
\label{sound/designs/channel-mapping-api:general}
The channel mapping API allows user to query the possible channel maps
and the current channel map, also optionally to modify the channel map
of the current stream.

A channel map is an array of position for each PCM channel.
Typically, a stereo PCM stream has a channel map of
\code{\{ front\_left, front\_right \}}
while a 4.0 surround PCM stream has a channel map of
\code{\{ front left, front right, rear left, rear right \}.}

The problem, so far, was that we had no standard channel map
explicitly, and applications had no way to know which channel
corresponds to which (speaker) position.  Thus, applications applied
wrong channels for 5.1 outputs, and you hear suddenly strange sound
from rear.  Or, some devices secretly assume that center/LFE is the
third/fourth channels while others that C/LFE as 5th/6th channels.

Also, some devices such as HDMI are configurable for different speaker
positions even with the same number of total channels.  However, there
was no way to specify this because of lack of channel map
specification.  These are the main motivations for the new channel
mapping API.


\subsection{Design}
\label{sound/designs/channel-mapping-api:design}
Actually, ``the channel mapping API'' doesn't introduce anything new in
the kernel/user-space ABI perspective.  It uses only the existing
control element features.

As a ground design, each PCM substream may contain a control element
providing the channel mapping information and configuration.  This
element is specified by:
\begin{itemize}
\item {} 
iface = SNDRV\_CTL\_ELEM\_IFACE\_PCM

\item {} 
name = ``Playback Channel Map'' or ``Capture Channel Map''

\item {} 
device = the same device number for the assigned PCM substream

\item {} 
index = the same index number for the assigned PCM substream

\end{itemize}

Note the name is different depending on the PCM substream direction.

Each control element provides at least the TLV read operation and the
read operation.  Optionally, the write operation can be provided to
allow user to change the channel map dynamically.


\subsubsection{TLV}
\label{sound/designs/channel-mapping-api:tlv}
The TLV operation gives the list of available channel
maps.  A list item of a channel map is usually a TLV of
\code{type data-bytes ch0 ch1 ch2...}
where type is the TLV type value, the second argument is the total
bytes (not the numbers) of channel values, and the rest are the
position value for each channel.

As a TLV type, either \code{SNDRV\_CTL\_TLVT\_CHMAP\_FIXED},
\code{SNDRV\_CTL\_TLV\_CHMAP\_VAR} or \code{SNDRV\_CTL\_TLVT\_CHMAP\_PAIRED} can be used.
The \code{\_FIXED} type is for a channel map with the fixed channel position
while the latter two are for flexible channel positions. \code{\_VAR} type is
for a channel map where all channels are freely swappable and \code{\_PAIRED}
type is where pair-wise channels are swappable.  For example, when you
have \{FL/FR/RL/RR\} channel map, \code{\_PAIRED} type would allow you to swap
only \{RL/RR/FL/FR\} while \code{\_VAR} type would allow even swapping FL and
RR.

These new TLV types are defined in \code{sound/tlv.h}.

The available channel position values are defined in \code{sound/asound.h},
here is a cut:

\begin{Verbatim}[commandchars=\\\{\}]
/* channel positions */
enum \PYGZob{}
      SNDRV\PYGZus{}CHMAP\PYGZus{}UNKNOWN = 0,
      SNDRV\PYGZus{}CHMAP\PYGZus{}NA,         /* N/A, silent */
      SNDRV\PYGZus{}CHMAP\PYGZus{}MONO,       /* mono stream */
      /* this follows the alsa\PYGZhy{}lib mixer channel value + 3 */
      SNDRV\PYGZus{}CHMAP\PYGZus{}FL,         /* front left */
      SNDRV\PYGZus{}CHMAP\PYGZus{}FR,         /* front right */
      SNDRV\PYGZus{}CHMAP\PYGZus{}RL,         /* rear left */
      SNDRV\PYGZus{}CHMAP\PYGZus{}RR,         /* rear right */
      SNDRV\PYGZus{}CHMAP\PYGZus{}FC,         /* front center */
      SNDRV\PYGZus{}CHMAP\PYGZus{}LFE,        /* LFE */
      SNDRV\PYGZus{}CHMAP\PYGZus{}SL,         /* side left */
      SNDRV\PYGZus{}CHMAP\PYGZus{}SR,         /* side right */
      SNDRV\PYGZus{}CHMAP\PYGZus{}RC,         /* rear center */
      /* new definitions */
      SNDRV\PYGZus{}CHMAP\PYGZus{}FLC,        /* front left center */
      SNDRV\PYGZus{}CHMAP\PYGZus{}FRC,        /* front right center */
      SNDRV\PYGZus{}CHMAP\PYGZus{}RLC,        /* rear left center */
      SNDRV\PYGZus{}CHMAP\PYGZus{}RRC,        /* rear right center */
      SNDRV\PYGZus{}CHMAP\PYGZus{}FLW,        /* front left wide */
      SNDRV\PYGZus{}CHMAP\PYGZus{}FRW,        /* front right wide */
      SNDRV\PYGZus{}CHMAP\PYGZus{}FLH,        /* front left high */
      SNDRV\PYGZus{}CHMAP\PYGZus{}FCH,        /* front center high */
      SNDRV\PYGZus{}CHMAP\PYGZus{}FRH,        /* front right high */
      SNDRV\PYGZus{}CHMAP\PYGZus{}TC,         /* top center */
      SNDRV\PYGZus{}CHMAP\PYGZus{}TFL,        /* top front left */
      SNDRV\PYGZus{}CHMAP\PYGZus{}TFR,        /* top front right */
      SNDRV\PYGZus{}CHMAP\PYGZus{}TFC,        /* top front center */
      SNDRV\PYGZus{}CHMAP\PYGZus{}TRL,        /* top rear left */
      SNDRV\PYGZus{}CHMAP\PYGZus{}TRR,        /* top rear right */
      SNDRV\PYGZus{}CHMAP\PYGZus{}TRC,        /* top rear center */
      SNDRV\PYGZus{}CHMAP\PYGZus{}LAST = SNDRV\PYGZus{}CHMAP\PYGZus{}TRC,
\PYGZcb{};
\end{Verbatim}

When a PCM stream can provide more than one channel map, you can
provide multiple channel maps in a TLV container type.  The TLV data
to be returned will contain such as:

\begin{Verbatim}[commandchars=\\\{\}]
SNDRV\PYGZus{}CTL\PYGZus{}TLVT\PYGZus{}CONTAINER 96
    SNDRV\PYGZus{}CTL\PYGZus{}TLVT\PYGZus{}CHMAP\PYGZus{}FIXED 4 SNDRV\PYGZus{}CHMAP\PYGZus{}FC
    SNDRV\PYGZus{}CTL\PYGZus{}TLVT\PYGZus{}CHMAP\PYGZus{}FIXED 8 SNDRV\PYGZus{}CHMAP\PYGZus{}FL SNDRV\PYGZus{}CHMAP\PYGZus{}FR
    SNDRV\PYGZus{}CTL\PYGZus{}TLVT\PYGZus{}CHMAP\PYGZus{}FIXED 16 NDRV\PYGZus{}CHMAP\PYGZus{}FL SNDRV\PYGZus{}CHMAP\PYGZus{}FR \PYGZbs{}
        SNDRV\PYGZus{}CHMAP\PYGZus{}RL SNDRV\PYGZus{}CHMAP\PYGZus{}RR
\end{Verbatim}

The channel position is provided in LSB 16bits.  The upper bits are
used for bit flags.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}define SNDRV\PYGZus{}CHMAP\PYGZus{}POSITION\PYGZus{}MASK       0xffff
\PYGZsh{}define SNDRV\PYGZus{}CHMAP\PYGZus{}PHASE\PYGZus{}INVERSE       (0x01 \PYGZlt{}\PYGZlt{} 16)
\PYGZsh{}define SNDRV\PYGZus{}CHMAP\PYGZus{}DRIVER\PYGZus{}SPEC         (0x02 \PYGZlt{}\PYGZlt{} 16)
\end{Verbatim}

\code{SNDRV\_CHMAP\_PHASE\_INVERSE} indicates the channel is phase inverted,
(thus summing left and right channels would result in almost silence).
Some digital mic devices have this.

When \code{SNDRV\_CHMAP\_DRIVER\_SPEC} is set, all the channel position values
don't follow the standard definition above but driver-specific.


\subsubsection{Read Operation}
\label{sound/designs/channel-mapping-api:read-operation}
The control read operation is for providing the current channel map of
the given stream.  The control element returns an integer array
containing the position of each channel.

When this is performed before the number of the channel is specified
(i.e. hw\_params is set), it should return all channels set to
\code{UNKNOWN}.


\subsubsection{Write Operation}
\label{sound/designs/channel-mapping-api:write-operation}
The control write operation is optional, and only for devices that can
change the channel configuration on the fly, such as HDMI.  User needs
to pass an integer value containing the valid channel positions for
all channels of the assigned PCM substream.

This operation is allowed only at PCM PREPARED state.  When called in
other states, it shall return an error.


\section{ALSA Compress-Offload API}
\label{sound/designs/compress-offload::doc}\label{sound/designs/compress-offload:alsa-compress-offload-api}
Pierre-Louis.Bossart \textless{}\href{mailto:pierre-louis.bossart@linux.intel.com}{pierre-louis.bossart@linux.intel.com}\textgreater{}

Vinod Koul \textless{}\href{mailto:vinod.koul@linux.intel.com}{vinod.koul@linux.intel.com}\textgreater{}


\subsection{Overview}
\label{sound/designs/compress-offload:overview}
Since its early days, the ALSA API was defined with PCM support or
constant bitrates payloads such as IEC61937 in mind. Arguments and
returned values in frames are the norm, making it a challenge to
extend the existing API to compressed data streams.

In recent years, audio digital signal processors (DSP) were integrated
in system-on-chip designs, and DSPs are also integrated in audio
codecs. Processing compressed data on such DSPs results in a dramatic
reduction of power consumption compared to host-based
processing. Support for such hardware has not been very good in Linux,
mostly because of a lack of a generic API available in the mainline
kernel.

Rather than requiring a compatibility break with an API change of the
ALSA PCM interface, a new `Compressed Data' API is introduced to
provide a control and data-streaming interface for audio DSPs.

The design of this API was inspired by the 2-year experience with the
Intel Moorestown SOC, with many corrections required to upstream the
API in the mainline kernel instead of the staging tree and make it
usable by others.


\subsection{Requirements}
\label{sound/designs/compress-offload:requirements}
The main requirements are:
\begin{itemize}
\item {} 
separation between byte counts and time. Compressed formats may have
a header per file, per frame, or no header at all. The payload size
may vary from frame-to-frame. As a result, it is not possible to
estimate reliably the duration of audio buffers when handling
compressed data. Dedicated mechanisms are required to allow for
reliable audio-video synchronization, which requires precise
reporting of the number of samples rendered at any given time.

\item {} 
Handling of multiple formats. PCM data only requires a specification
of the sampling rate, number of channels and bits per sample. In
contrast, compressed data comes in a variety of formats. Audio DSPs
may also provide support for a limited number of audio encoders and
decoders embedded in firmware, or may support more choices through
dynamic download of libraries.

\item {} 
Focus on main formats. This API provides support for the most
popular formats used for audio and video capture and playback. It is
likely that as audio compression technology advances, new formats
will be added.

\item {} 
Handling of multiple configurations. Even for a given format like
AAC, some implementations may support AAC multichannel but HE-AAC
stereo. Likewise WMA10 level M3 may require too much memory and cpu
cycles. The new API needs to provide a generic way of listing these
formats.

\item {} 
Rendering/Grabbing only. This API does not provide any means of
hardware acceleration, where PCM samples are provided back to
user-space for additional processing. This API focuses instead on
streaming compressed data to a DSP, with the assumption that the
decoded samples are routed to a physical output or logical back-end.

\item {} 
Complexity hiding. Existing user-space multimedia frameworks all
have existing enums/structures for each compressed format. This new
API assumes the existence of a platform-specific compatibility layer
to expose, translate and make use of the capabilities of the audio
DSP, eg. Android HAL or PulseAudio sinks. By construction, regular
applications are not supposed to make use of this API.

\end{itemize}


\subsection{Design}
\label{sound/designs/compress-offload:design}
The new API shares a number of concepts with the PCM API for flow
control. Start, pause, resume, drain and stop commands have the same
semantics no matter what the content is.

The concept of memory ring buffer divided in a set of fragments is
borrowed from the ALSA PCM API. However, only sizes in bytes can be
specified.

Seeks/trick modes are assumed to be handled by the host.

The notion of rewinds/forwards is not supported. Data committed to the
ring buffer cannot be invalidated, except when dropping all buffers.

The Compressed Data API does not make any assumptions on how the data
is transmitted to the audio DSP. DMA transfers from main memory to an
embedded audio cluster or to a SPI interface for external DSPs are
possible. As in the ALSA PCM case, a core set of routines is exposed;
each driver implementer will have to write support for a set of
mandatory routines and possibly make use of optional ones.

The main additions are
\begin{description}
\item[{get\_caps}] \leavevmode
This routine returns the list of audio formats supported. Querying the
codecs on a capture stream will return encoders, decoders will be
listed for playback streams.

\item[{get\_codec\_caps}] \leavevmode
For each codec, this routine returns a list of
capabilities. The intent is to make sure all the capabilities
correspond to valid settings, and to minimize the risks of
configuration failures. For example, for a complex codec such as AAC,
the number of channels supported may depend on a specific profile. If
the capabilities were exposed with a single descriptor, it may happen
that a specific combination of profiles/channels/formats may not be
supported. Likewise, embedded DSPs have limited memory and cpu cycles,
it is likely that some implementations make the list of capabilities
dynamic and dependent on existing workloads. In addition to codec
settings, this routine returns the minimum buffer size handled by the
implementation. This information can be a function of the DMA buffer
sizes, the number of bytes required to synchronize, etc, and can be
used by userspace to define how much needs to be written in the ring
buffer before playback can start.

\item[{set\_params}] \leavevmode
This routine sets the configuration chosen for a specific codec. The
most important field in the parameters is the codec type; in most
cases decoders will ignore other fields, while encoders will strictly
comply to the settings

\item[{get\_params}] \leavevmode
This routines returns the actual settings used by the DSP. Changes to
the settings should remain the exception.

\item[{get\_timestamp}] \leavevmode
The timestamp becomes a multiple field structure. It lists the number
of bytes transferred, the number of samples processed and the number
of samples rendered/grabbed. All these values can be used to determine
the average bitrate, figure out if the ring buffer needs to be
refilled or the delay due to decoding/encoding/io on the DSP.

\end{description}

Note that the list of codecs/profiles/modes was derived from the
OpenMAX AL specification instead of reinventing the wheel.
Modifications include:
- Addition of FLAC and IEC formats
- Merge of encoder/decoder capabilities
- Profiles/modes listed as bitmasks to make descriptors more compact
- Addition of set\_params for decoders (missing in OpenMAX AL)
- Addition of AMR/AMR-WB encoding modes (missing in OpenMAX AL)
- Addition of format information for WMA
- Addition of encoding options when required (derived from OpenMAX IL)
- Addition of rateControlSupported (missing in OpenMAX AL)


\subsection{Gapless Playback}
\label{sound/designs/compress-offload:gapless-playback}
When playing thru an album, the decoders have the ability to skip the encoder
delay and padding and directly move from one track content to another. The end
user can perceive this as gapless playback as we don't have silence while
switching from one track to another

Also, there might be low-intensity noises due to encoding. Perfect gapless is
difficult to reach with all types of compressed data, but works fine with most
music content. The decoder needs to know the encoder delay and encoder padding.
So we need to pass this to DSP. This metadata is extracted from ID3/MP4 headers
and are not present by default in the bitstream, hence the need for a new
interface to pass this information to the DSP. Also DSP and userspace needs to
switch from one track to another and start using data for second track.

The main additions are:
\begin{description}
\item[{set\_metadata}] \leavevmode
This routine sets the encoder delay and encoder padding. This can be used by
decoder to strip the silence. This needs to be set before the data in the track
is written.

\item[{set\_next\_track}] \leavevmode
This routine tells DSP that metadata and write operation sent after this would
correspond to subsequent track

\item[{partial drain}] \leavevmode
This is called when end of file is reached. The userspace can inform DSP that
EOF is reached and now DSP can start skipping padding delay. Also next write
data would belong to next track

\end{description}

Sequence flow for gapless would be:
- Open
- Get caps / codec caps
- Set params
- Set metadata of the first track
- Fill data of the first track
- Trigger start
- User-space finished sending all,
- Indicate next track data by sending set\_next\_track
- Set metadata of the next track
- then call partial\_drain to flush most of buffer in DSP
- Fill data of the next track
- DSP switches to second track

(note: order for partial\_drain and write for next track can be reversed as well)


\subsection{Not supported}
\label{sound/designs/compress-offload:not-supported}\begin{itemize}
\item {} 
Support for VoIP/circuit-switched calls is not the target of this
API. Support for dynamic bit-rate changes would require a tight
coupling between the DSP and the host stack, limiting power savings.

\item {} 
Packet-loss concealment is not supported. This would require an
additional interface to let the decoder synthesize data when frames
are lost during transmission. This may be added in the future.

\item {} 
Volume control/routing is not handled by this API. Devices exposing a
compressed data interface will be considered as regular ALSA devices;
volume changes and routing information will be provided with regular
ALSA kcontrols.

\item {} 
Embedded audio effects. Such effects should be enabled in the same
manner, no matter if the input was PCM or compressed.

\item {} 
multichannel IEC encoding. Unclear if this is required.

\item {} 
Encoding/decoding acceleration is not supported as mentioned
above. It is possible to route the output of a decoder to a capture
stream, or even implement transcoding capabilities. This routing
would be enabled with ALSA kcontrols.

\item {} 
Audio policy/resource management. This API does not provide any
hooks to query the utilization of the audio DSP, nor any preemption
mechanisms.

\item {} 
No notion of underrun/overrun. Since the bytes written are compressed
in nature and data written/read doesn't translate directly to
rendered output in time, this does not deal with underrun/overrun and
maybe dealt in user-library

\end{itemize}


\subsection{Credits}
\label{sound/designs/compress-offload:credits}\begin{itemize}
\item {} 
Mark Brown and Liam Girdwood for discussions on the need for this API

\item {} 
Harsha Priya for her work on intel\_sst compressed API

\item {} 
Rakesh Ughreja for valuable feedback

\item {} 
Sing Nallasellan, Sikkandar Madar and Prasanna Samaga for
demonstrating and quantifying the benefits of audio offload on a
real platform.

\end{itemize}


\section{ALSA PCM Timestamping}
\label{sound/designs/timestamping:alsa-pcm-timestamping}\label{sound/designs/timestamping::doc}
The ALSA API can provide two different system timestamps:
\begin{itemize}
\item {} 
Trigger\_tstamp is the system time snapshot taken when the .trigger
callback is invoked. This snapshot is taken by the ALSA core in the
general case, but specific hardware may have synchronization
capabilities or conversely may only be able to provide a correct
estimate with a delay. In the latter two cases, the low-level driver
is responsible for updating the trigger\_tstamp at the most appropriate
and precise moment. Applications should not rely solely on the first
trigger\_tstamp but update their internal calculations if the driver
provides a refined estimate with a delay.

\item {} 
tstamp is the current system timestamp updated during the last
event or application query.
The difference (tstamp - trigger\_tstamp) defines the elapsed time.

\end{itemize}

The ALSA API provides two basic pieces of information, avail
and delay, which combined with the trigger and current system
timestamps allow for applications to keep track of the `fullness' of
the ring buffer and the amount of queued samples.

The use of these different pointers and time information depends on
the application needs:
\begin{itemize}
\item {} 
\code{avail} reports how much can be written in the ring buffer

\item {} 
\code{delay} reports the time it will take to hear a new sample after all
queued samples have been played out.

\end{itemize}

When timestamps are enabled, the avail/delay information is reported
along with a snapshot of system time. Applications can select from
\code{CLOCK\_REALTIME} (NTP corrections including going backwards),
\code{CLOCK\_MONOTONIC} (NTP corrections but never going backwards),
\code{CLOCK\_MONOTIC\_RAW} (without NTP corrections) and change the mode
dynamically with sw\_params

The ALSA API also provide an audio\_tstamp which reflects the passage
of time as measured by different components of audio hardware.  In
ascii-art, this could be represented as follows (for the playback
case):

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} time
  \PYGZca{}               \PYGZca{}              \PYGZca{}                \PYGZca{}           \PYGZca{}
  \textbar{}               \textbar{}              \textbar{}                \textbar{}           \textbar{}
 analog         link            dma              app       FullBuffer
 time           time           time              time        time
  \textbar{}               \textbar{}              \textbar{}                \textbar{}           \textbar{}
  \textbar{}\PYGZlt{} codec delay \PYGZgt{}\textbar{}\PYGZlt{}\PYGZhy{}\PYGZhy{}hw delay\PYGZhy{}\PYGZhy{}\PYGZgt{}\textbar{}\PYGZlt{}queued samples\PYGZgt{}\textbar{}\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}avail\PYGZhy{}\PYGZgt{}\textbar{}
  \textbar{}\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} delay\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}\textbar{}           \textbar{}
                                 \textbar{}\PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}ring buffer length\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}\textbar{}
\end{Verbatim}

The analog time is taken at the last stage of the playback, as close
as possible to the actual transducer

The link time is taken at the output of the SoC/chipset as the samples
are pushed on a link. The link time can be directly measured if
supported in hardware by sample counters or wallclocks (e.g. with
HDAudio 24MHz or PTP clock for networked solutions) or indirectly
estimated (e.g. with the frame counter in USB).

The DMA time is measured using counters - typically the least reliable
of all measurements due to the bursty nature of DMA transfers.

The app time corresponds to the time tracked by an application after
writing in the ring buffer.

The application can query the hardware capabilities, define which
audio time it wants reported by selecting the relevant settings in
audio\_tstamp\_config fields, thus get an estimate of the timestamp
accuracy. It can also request the delay-to-analog be included in the
measurement. Direct access to the link time is very interesting on
platforms that provide an embedded DSP; measuring directly the link
time with dedicated hardware, possibly synchronized with system time,
removes the need to keep track of internal DSP processing times and
latency.

In case the application requests an audio tstamp that is not supported
in hardware/low-level driver, the type is overridden as DEFAULT and the
timestamp will report the DMA time based on the hw\_pointer value.

For backwards compatibility with previous implementations that did not
provide timestamp selection, with a zero-valued COMPAT timestamp type
the results will default to the HDAudio wall clock for playback
streams and to the DMA time (hw\_ptr) in all other cases.

The audio timestamp accuracy can be returned to user-space, so that
appropriate decisions are made:
\begin{itemize}
\item {} 
for dma time (default), the granularity of the transfers can be
inferred from the steps between updates and in turn provide
information on how much the application pointer can be rewound
safely.

\item {} 
the link time can be used to track long-term drifts between audio
and system time using the (tstamp-trigger\_tstamp)/audio\_tstamp
ratio, the precision helps define how much smoothing/low-pass
filtering is required. The link time can be either reset on startup
or reported as is (the latter being useful to compare progress of
different streams - but may require the wallclock to be always
running and not wrap-around during idle periods). If supported in
hardware, the absolute link time could also be used to define a
precise start time (patches WIP)

\item {} 
including the delay in the audio timestamp may
counter-intuitively not increase the precision of timestamps, e.g. if a
codec includes variable-latency DSP processing or a chain of
hardware components the delay is typically not known with precision.

\end{itemize}

The accuracy is reported in nanosecond units (using an unsigned 32-bit
word), which gives a max precision of 4.29s, more than enough for
audio applications...

Due to the varied nature of timestamping needs, even for a single
application, the audio\_tstamp\_config can be changed dynamically. In
the \code{STATUS} ioctl, the parameters are read-only and do not allow for
any application selection. To work around this limitation without
impacting legacy applications, a new \code{STATUS\_EXT} ioctl is introduced
with read/write parameters. ALSA-lib will be modified to make use of
\code{STATUS\_EXT} and effectively deprecate \code{STATUS}.

The ALSA API only allows for a single audio timestamp to be reported
at a time. This is a conscious design decision, reading the audio
timestamps from hardware registers or from IPC takes time, the more
timestamps are read the more imprecise the combined measurements
are. To avoid any interpretation issues, a single (system, audio)
timestamp is reported. Applications that need different timestamps
will be required to issue multiple queries and perform an
interpolation of the results

In some hardware-specific configuration, the system timestamp is
latched by a low-level audio subsystem, and the information provided
back to the driver. Due to potential delays in the communication with
the hardware, there is a risk of misalignment with the avail and delay
information. To make sure applications are not confused, a
driver\_timestamp field is added in the snd\_pcm\_status structure; this
timestamp shows when the information is put together by the driver
before returning from the \code{STATUS} and \code{STATUS\_EXT} ioctl. in most cases
this driver\_timestamp will be identical to the regular system tstamp.

Examples of typestamping with HDaudio:

1. DMA timestamp, no compensation for DMA+analog delay

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ./audio\PYGZus{}time  \PYGZhy{}p \PYGZhy{}\PYGZhy{}ts\PYGZus{}type=1
playback: systime: 341121338 nsec, audio time 342000000 nsec,         systime delta \PYGZhy{}878662
playback: systime: 426236663 nsec, audio time 427187500 nsec,         systime delta \PYGZhy{}950837
playback: systime: 597080580 nsec, audio time 598000000 nsec,         systime delta \PYGZhy{}919420
playback: systime: 682059782 nsec, audio time 683020833 nsec,         systime delta \PYGZhy{}961051
playback: systime: 852896415 nsec, audio time 853854166 nsec,         systime delta \PYGZhy{}957751
playback: systime: 937903344 nsec, audio time 938854166 nsec,         systime delta \PYGZhy{}950822
\end{Verbatim}

2. DMA timestamp, compensation for DMA+analog delay

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ./audio\PYGZus{}time  \PYGZhy{}p \PYGZhy{}\PYGZhy{}ts\PYGZus{}type=1 \PYGZhy{}d
playback: systime: 341053347 nsec, audio time 341062500 nsec,         systime delta \PYGZhy{}9153
playback: systime: 426072447 nsec, audio time 426062500 nsec,         systime delta 9947
playback: systime: 596899518 nsec, audio time 596895833 nsec,         systime delta 3685
playback: systime: 681915317 nsec, audio time 681916666 nsec,         systime delta \PYGZhy{}1349
playback: systime: 852741306 nsec, audio time 852750000 nsec,         systime delta \PYGZhy{}8694
\end{Verbatim}

3. link timestamp, compensation for DMA+analog delay

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ./audio\PYGZus{}time  \PYGZhy{}p \PYGZhy{}\PYGZhy{}ts\PYGZus{}type=2 \PYGZhy{}d
playback: systime: 341060004 nsec, audio time 341062791 nsec,         systime delta \PYGZhy{}2787
playback: systime: 426242074 nsec, audio time 426244875 nsec,         systime delta \PYGZhy{}2801
playback: systime: 597080992 nsec, audio time 597084583 nsec,         systime delta \PYGZhy{}3591
playback: systime: 682084512 nsec, audio time 682088291 nsec,         systime delta \PYGZhy{}3779
playback: systime: 852936229 nsec, audio time 852940916 nsec,         systime delta \PYGZhy{}4687
playback: systime: 938107562 nsec, audio time 938112708 nsec,         systime delta \PYGZhy{}5146
\end{Verbatim}

Example 1 shows that the timestamp at the DMA level is close to 1ms
ahead of the actual playback time (as a side time this sort of
measurement can help define rewind safeguards). Compensating for the
DMA-link delay in example 2 helps remove the hardware buffering but
the information is still very jittery, with up to one sample of
error. In example 3 where the timestamps are measured with the link
wallclock, the timestamps show a monotonic behavior and a lower
dispersion.

Example 3 and 4 are with USB audio class. Example 3 shows a high
offset between audio time and system time due to buffering. Example 4
shows how compensating for the delay exposes a 1ms accuracy (due to
the use of the frame counter by the driver)

Example 3: DMA timestamp, no compensation for delay, delta of \textasciitilde{}5ms

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ./audio\PYGZus{}time \PYGZhy{}p \PYGZhy{}Dhw:1 \PYGZhy{}t1
playback: systime: 120174019 nsec, audio time 125000000 nsec,         systime delta \PYGZhy{}4825981
playback: systime: 245041136 nsec, audio time 250000000 nsec,         systime delta \PYGZhy{}4958864
playback: systime: 370106088 nsec, audio time 375000000 nsec,         systime delta \PYGZhy{}4893912
playback: systime: 495040065 nsec, audio time 500000000 nsec,         systime delta \PYGZhy{}4959935
playback: systime: 620038179 nsec, audio time 625000000 nsec,         systime delta \PYGZhy{}4961821
playback: systime: 745087741 nsec, audio time 750000000 nsec,         systime delta \PYGZhy{}4912259
playback: systime: 870037336 nsec, audio time 875000000 nsec,         systime delta \PYGZhy{}4962664
\end{Verbatim}

Example 4: DMA timestamp, compensation for delay, delay of \textasciitilde{}1ms

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} ./audio\PYGZus{}time \PYGZhy{}p \PYGZhy{}Dhw:1 \PYGZhy{}t1 \PYGZhy{}d
playback: systime: 120190520 nsec, audio time 120000000 nsec,         systime delta 190520
playback: systime: 245036740 nsec, audio time 244000000 nsec,         systime delta 1036740
playback: systime: 370034081 nsec, audio time 369000000 nsec,         systime delta 1034081
playback: systime: 495159907 nsec, audio time 494000000 nsec,         systime delta 1159907
playback: systime: 620098824 nsec, audio time 619000000 nsec,         systime delta 1098824
playback: systime: 745031847 nsec, audio time 744000000 nsec,         systime delta 1031847
\end{Verbatim}


\section{ALSA Jack Controls}
\label{sound/designs/jack-controls:alsa-jack-controls}\label{sound/designs/jack-controls::doc}

\subsection{Why we need Jack kcontrols}
\label{sound/designs/jack-controls:why-we-need-jack-kcontrols}
ALSA uses kcontrols to export audio controls(switch, volume, Mux, ...)
to user space. This means userspace applications like pulseaudio can
switch off headphones and switch on speakers when no headphones are
pluged in.

The old ALSA jack code only created input devices for each registered
jack. These jack input devices are not readable by userspace devices
that run as non root.

The new jack code creates embedded jack kcontrols for each jack that
can be read by any process.

This can be combined with UCM to allow userspace to route audio more
intelligently based on jack insertion or removal events.


\subsection{Jack Kcontrol Internals}
\label{sound/designs/jack-controls:jack-kcontrol-internals}
Each jack will have a kcontrol list, so that we can create a kcontrol
and attach it to the jack, at jack creation stage. We can also add a
kcontrol to an existing jack, at anytime when required.

Those kcontrols will be freed automatically when the Jack is freed.


\subsection{How to use jack kcontrols}
\label{sound/designs/jack-controls:how-to-use-jack-kcontrols}
In order to keep compatibility, snd\_jack\_new() has been modified by
adding two params:
\begin{description}
\item[{initial\_kctl}] \leavevmode
if true, create a kcontrol and add it to the jack list.

\item[{phantom\_jack}] \leavevmode
Don't create a input device for phantom jacks.

\end{description}

HDA jacks can set phantom\_jack to true in order to create a phantom
jack and set initial\_kctl to true to create an initial kcontrol with
the correct id.

ASoC jacks should set initial\_kctl as false. The pin name will be
assigned as the jack kcontrol name.


\section{Tracepoints in ALSA}
\label{sound/designs/tracepoints::doc}\label{sound/designs/tracepoints:tracepoints-in-alsa}
2017/07/02
Takasahi Sakamoto


\subsection{Tracepoints in ALSA PCM core}
\label{sound/designs/tracepoints:tracepoints-in-alsa-pcm-core}
ALSA PCM core registers \code{snd\_pcm} subsystem to kernel tracepoint system.
This subsystem includes two categories of tracepoints; for state of PCM buffer
and for processing of PCM hardware parameters. These tracepoints are available
when corresponding kernel configurations are enabled. When \code{CONFIG\_SND\_DEBUG}
is enabled, the latter tracepoints are available. When additional
\code{SND\_PCM\_XRUN\_DEBUG} is enabled too, the former trace points are enabled.


\subsubsection{Tracepoints for state of PCM buffer}
\label{sound/designs/tracepoints:tracepoints-for-state-of-pcm-buffer}
This category includes four tracepoints; \code{hwptr}, \code{applptr}, \code{xrun} and
\code{hw\_ptr\_error}.


\subsubsection{Tracepoints for processing of PCM hardware parameters}
\label{sound/designs/tracepoints:tracepoints-for-processing-of-pcm-hardware-parameters}
This category includes two tracepoints; \code{hw\_mask\_param} and
\code{hw\_interval\_param}.

In a design of ALSA PCM core, data transmission is abstracted as PCM substream.
Applications manage PCM substream to maintain data transmission for PCM frames.
Before starting the data transmission, applications need to configure PCM
substream. In this procedure, PCM hardware parameters are decided by
interaction between applications and ALSA PCM core. Once decided, runtime of
the PCM substream keeps the parameters.

The parameters are described in \code{struct snd\_pcm\_hw\_params}. This
structure includes several types of parameters. Applications set preferable
value to these parameters, then execute ioctl(2) with SNDRV\_PCM\_IOCTL\_HW\_REFINE
or SNDRV\_PCM\_IOCTL\_HW\_PARAMS. The former is used just for refining available
set of parameters. The latter is used for an actual decision of the parameters.

The \code{struct snd\_pcm\_hw\_params} structure has below members:
\begin{description}
\item[{\code{flags}}] \leavevmode
Configurable. ALSA PCM core and some drivers handle this flag to select
convenient parameters or change their behaviour.

\item[{\code{masks}}] \leavevmode
Configurable. This type of parameter is described in
\code{struct snd\_mask} and represent mask values. As of PCM protocol
v2.0.13, three types are defined.
\begin{itemize}
\item {} 
SNDRV\_PCM\_HW\_PARAM\_ACCESS

\item {} 
SNDRV\_PCM\_HW\_PARAM\_FORMAT

\item {} 
SNDRV\_PCM\_HW\_PARAM\_SUBFORMAT

\end{itemize}

\item[{\code{intervals}}] \leavevmode
Configurable. This type of parameter is described in
\code{struct snd\_interval} and represent values with a range. As of
PCM protocol v2.0.13, twelve types are defined.
\begin{itemize}
\item {} 
SNDRV\_PCM\_HW\_PARAM\_SAMPLE\_BITS

\item {} 
SNDRV\_PCM\_HW\_PARAM\_FRAME\_BITS

\item {} 
SNDRV\_PCM\_HW\_PARAM\_CHANNELS

\item {} 
SNDRV\_PCM\_HW\_PARAM\_RATE

\item {} 
SNDRV\_PCM\_HW\_PARAM\_PERIOD\_TIME

\item {} 
SNDRV\_PCM\_HW\_PARAM\_PERIOD\_SIZE

\item {} 
SNDRV\_PCM\_HW\_PARAM\_PERIOD\_BYTES

\item {} 
SNDRV\_PCM\_HW\_PARAM\_PERIODS

\item {} 
SNDRV\_PCM\_HW\_PARAM\_BUFFER\_TIME

\item {} 
SNDRV\_PCM\_HW\_PARAM\_BUFFER\_SIZE

\item {} 
SNDRV\_PCM\_HW\_PARAM\_BUFFER\_BYTES

\item {} 
SNDRV\_PCM\_HW\_PARAM\_TICK\_TIME

\end{itemize}

\item[{\code{rmask}}] \leavevmode
Configurable. This is evaluated at ioctl(2) with
SNDRV\_PCM\_IOCTL\_HW\_REFINE only. Applications can select which
mask/interval parameter can be changed by ALSA PCM core. For
SNDRV\_PCM\_IOCTL\_HW\_PARAMS, this mask is ignored and all of parameters
are going to be changed.

\item[{\code{cmask}}] \leavevmode
Read-only. After returning from ioctl(2), buffer in user space for
\code{struct snd\_pcm\_hw\_params} includes result of each operation.
This mask represents which mask/interval parameter is actually changed.

\item[{\code{info}}] \leavevmode
Read-only. This represents hardware/driver capabilities as bit flags
with SNDRV\_PCM\_INFO\_XXX. Typically, applications execute ioctl(2) with
SNDRV\_PCM\_IOCTL\_HW\_REFINE to retrieve this flag, then decide candidates
of parameters and execute ioctl(2) with SNDRV\_PCM\_IOCTL\_HW\_PARAMS to
configure PCM substream.

\item[{\code{msbits}}] \leavevmode
Read-only. This value represents available bit width in MSB side of
a PCM sample. When a parameter of SNDRV\_PCM\_HW\_PARAM\_SAMPLE\_BITS was
decided as a fixed number, this value is also calculated according to
it. Else, zero. But this behaviour depends on implementations in driver
side.

\item[{\code{rate\_num}}] \leavevmode
Read-only. This value represents numerator of sampling rate in fraction
notation. Basically, when a parameter of SNDRV\_PCM\_HW\_PARAM\_RATE was
decided as a single value, this value is also calculated according to
it. Else, zero. But this behaviour depends on implementations in driver
side.

\item[{\code{rate\_den}}] \leavevmode
Read-only. This value represents denominator of sampling rate in
fraction notation. Basically, when a parameter of
SNDRV\_PCM\_HW\_PARAM\_RATE was decided as a single value, this value is
also calculated according to it. Else, zero. But this behaviour depends
on implementations in driver side.

\item[{\code{fifo\_size}}] \leavevmode
Read-only. This value represents the size of FIFO in serial sound
interface of hardware. Basically, each driver can assigns a proper
value to this parameter but some drivers intentionally set zero with
a care of hardware design or data transmission protocol.

\end{description}

ALSA PCM core handles buffer of \code{struct snd\_pcm\_hw\_params} when
applications execute ioctl(2) with SNDRV\_PCM\_HW\_REFINE or SNDRV\_PCM\_HW\_PARAMS.
Parameters in the buffer are changed according to
\code{struct snd\_pcm\_hardware} and rules of constraints in the runtime. The
structure describes capabilities of handled hardware. The rules describes
dependencies on which a parameter is decided according to several parameters.
A rule has a callback function, and drivers can register arbitrary functions
to compute the target parameter. ALSA PCM core registers some rules to the
runtime as a default.

Each driver can join in the interaction as long as it prepared for two stuffs
in a callback of \code{struct snd\_pcm\_ops.open}.
\begin{enumerate}
\item {} 
In the callback, drivers are expected to change a member of
\code{struct snd\_pcm\_hardware} type in the runtime, according to
capacities of corresponding hardware.

\item {} 
In the same callback, drivers are also expected to register additional rules
of constraints into the runtime when several parameters have dependencies
due to hardware design.

\end{enumerate}

The driver can refers to result of the interaction in a callback of
\code{struct snd\_pcm\_ops.hw\_params}, however it should not change the
content.

Tracepoints in this category are designed to trace changes of the
mask/interval parameters. When ALSA PCM core changes them, \code{hw\_mask\_param} or
\code{hw\_interval\_param} event is probed according to type of the changed parameter.

ALSA PCM core also has a pretty print format for each of the tracepoints. Below
is an example for \code{hw\_mask\_param}.

\begin{Verbatim}[commandchars=\\\{\}]
hw\PYGZus{}mask\PYGZus{}param: pcmC0D0p 001/023 FORMAT 00000000000000000000001000000044 00000000000000000000001000000044
\end{Verbatim}

Below is an example for \code{hw\_interval\_param}.

\begin{Verbatim}[commandchars=\\\{\}]
hw\PYGZus{}interval\PYGZus{}param: pcmC0D0p 000/023 BUFFER\PYGZus{}SIZE 0 0 [0 4294967295] 0 1 [0 4294967295]
\end{Verbatim}

The first three fields are common. They represent name of ALSA PCM character
device, rules of constraint and name of the changed parameter, in order. The
field for rules of constraint consists of two sub-fields; index of applied rule
and total number of rules added to the runtime. As an exception, the index 000
means that the parameter is changed by ALSA PCM core, regardless of the rules.

The rest of field represent state of the parameter before/after changing. These
fields are different according to type of the parameter. For parameters of mask
type, the fields represent hexadecimal dump of content of the parameter. For
parameters of interval type, the fields represent values of each member of
\code{empty}, \code{integer}, \code{openmin}, \code{min}, \code{max}, \code{openmax} in
\code{struct snd\_interval} in this order.


\subsection{Tracepoints in drivers}
\label{sound/designs/tracepoints:tracepoints-in-drivers}
Some drivers have tracepoints for developers' convenience. For them, please
refer to each documentation or implementation.


\section{Proc Files of ALSA Drivers}
\label{sound/designs/procfile::doc}\label{sound/designs/procfile:proc-files-of-alsa-drivers}
Takashi Iwai \textless{}\href{mailto:tiwai@suse.de}{tiwai@suse.de}\textgreater{}


\subsection{General}
\label{sound/designs/procfile:general}
ALSA has its own proc tree, /proc/asound.  Many useful information are
found in this tree.  When you encounter a problem and need debugging,
check the files listed in the following sections.

Each card has its subtree cardX, where X is from 0 to 7. The
card-specific files are stored in the \code{card*} subdirectories.


\subsection{Global Information}
\label{sound/designs/procfile:global-information}\begin{description}
\item[{cards}] \leavevmode
Shows the list of currently configured ALSA drivers,
index, the id string, short and long descriptions.

\item[{version}] \leavevmode
Shows the version string and compile date.

\item[{modules}] \leavevmode
Lists the module of each card

\item[{devices}] \leavevmode
Lists the ALSA native device mappings.

\item[{meminfo}] \leavevmode
Shows the status of allocated pages via ALSA drivers.
Appears only when \code{CONFIG\_SND\_DEBUG=y}.

\item[{hwdep}] \leavevmode
Lists the currently available hwdep devices in format of
\code{\textless{}card\textgreater{}-\textless{}device\textgreater{}: \textless{}name\textgreater{}}

\item[{pcm}] \leavevmode
Lists the currently available PCM devices in format of
\code{\textless{}card\textgreater{}-\textless{}device\textgreater{}: \textless{}id\textgreater{}: \textless{}name\textgreater{} : \textless{}sub-streams\textgreater{}}

\item[{timer}] \leavevmode
Lists the currently available timer devices

\item[{oss/devices}] \leavevmode
Lists the OSS device mappings.

\item[{oss/sndstat}] \leavevmode
Provides the output compatible with /dev/sndstat.
You can symlink this to /dev/sndstat.

\end{description}


\subsection{Card Specific Files}
\label{sound/designs/procfile:card-specific-files}
The card-specific files are found in \code{/proc/asound/card*} directories.
Some drivers (e.g. cmipci) have their own proc entries for the
register dump, etc (e.g. \code{/proc/asound/card*/cmipci} shows the register
dump).  These files would be really helpful for debugging.

When PCM devices are available on this card, you can see directories
like pcm0p or pcm1c.  They hold the PCM information for each PCM
stream.  The number after \code{pcm} is the PCM device number from 0, and
the last \code{p} or \code{c} means playback or capture direction.  The files in
this subtree is described later.

The status of MIDI I/O is found in \code{midi*} files.  It shows the device
name and the received/transmitted bytes through the MIDI device.

When the card is equipped with AC97 codecs, there are \code{codec97\#*}
subdirectories (described later).

When the OSS mixer emulation is enabled (and the module is loaded),
oss\_mixer file appears here, too.  This shows the current mapping of
OSS mixer elements to the ALSA control elements.  You can change the
mapping by writing to this device.  Read OSS-Emulation.txt for
details.


\subsection{PCM Proc Files}
\label{sound/designs/procfile:pcm-proc-files}\begin{description}
\item[{\code{card*/pcm*/info}}] \leavevmode
The general information of this PCM device: card \#, device \#,
substreams, etc.

\item[{\code{card*/pcm*/xrun\_debug}}] \leavevmode
This file appears when \code{CONFIG\_SND\_DEBUG=y} and
\code{CONFIG\_PCM\_XRUN\_DEBUG=y}.
This shows the status of xrun (= buffer overrun/xrun) and
invalid PCM position debug/check of ALSA PCM middle layer.
It takes an integer value, can be changed by writing to this
file, such as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} echo 5 \PYGZgt{} /proc/asound/card0/pcm0p/xrun\PYGZus{}debug
\end{Verbatim}

The value consists of the following bit flags:
\begin{itemize}
\item {} 
bit 0 = Enable XRUN/jiffies debug messages

\item {} 
bit 1 = Show stack trace at XRUN / jiffies check

\item {} 
bit 2 = Enable additional jiffies check

\end{itemize}

When the bit 0 is set, the driver will show the messages to
kernel log when an xrun is detected.  The debug message is
shown also when the invalid H/W pointer is detected at the
update of periods (usually called from the interrupt
handler).

When the bit 1 is set, the driver will show the stack trace
additionally.  This may help the debugging.

Since 2.6.30, this option can enable the hwptr check using
jiffies.  This detects spontaneous invalid pointer callback
values, but can be lead to too much corrections for a (mostly
buggy) hardware that doesn't give smooth pointer updates.
This feature is enabled via the bit 2.

\item[{\code{card*/pcm*/sub*/info}}] \leavevmode
The general information of this PCM sub-stream.

\item[{\code{card*/pcm*/sub*/status}}] \leavevmode
The current status of this PCM sub-stream, elapsed time,
H/W position, etc.

\item[{\code{card*/pcm*/sub*/hw\_params}}] \leavevmode
The hardware parameters set for this sub-stream.

\item[{\code{card*/pcm*/sub*/sw\_params}}] \leavevmode
The soft parameters set for this sub-stream.

\item[{\code{card*/pcm*/sub*/prealloc}}] \leavevmode
The buffer pre-allocation information.

\item[{\code{card*/pcm*/sub*/xrun\_injection}}] \leavevmode
Triggers an XRUN to the running stream when any value is
written to this proc file.  Used for fault injection.
This entry is write-only.

\end{description}


\subsection{AC97 Codec Information}
\label{sound/designs/procfile:ac97-codec-information}\begin{description}
\item[{\code{card*/codec97\#*/ac97\#?-?}}] \leavevmode
Shows the general information of this AC97 codec chip, such as
name, capabilities, set up.

\item[{\code{card*/codec97\#0/ac97\#?-?+regs}}] \leavevmode
Shows the AC97 register dump.  Useful for debugging.

When CONFIG\_SND\_DEBUG is enabled, you can write to this file for
changing an AC97 register directly.  Pass two hex numbers.
For example,

\end{description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} echo 02 9f1f \PYGZgt{} /proc/asound/card0/codec97\PYGZsh{}0/ac97\PYGZsh{}0\PYGZhy{}0+regs
\end{Verbatim}


\subsection{USB Audio Streams}
\label{sound/designs/procfile:usb-audio-streams}\begin{description}
\item[{\code{card*/stream*}}] \leavevmode
Shows the assignment and the current status of each audio stream
of the given card.  This information is very useful for debugging.

\end{description}


\subsection{HD-Audio Codecs}
\label{sound/designs/procfile:hd-audio-codecs}\begin{description}
\item[{\code{card*/codec\#*}}] \leavevmode
Shows the general codec information and the attribute of each
widget node.

\item[{\code{card*/eld\#*}}] \leavevmode
Available for HDMI or DisplayPort interfaces.
Shows ELD(EDID Like Data) info retrieved from the attached HDMI sink,
and describes its audio capabilities and configurations.

Some ELD fields may be modified by doing \code{echo name hex\_value \textgreater{} eld\#*}.
Only do this if you are sure the HDMI sink provided value is wrong.
And if that makes your HDMI audio work, please report to us so that we
can fix it in future kernel releases.

\end{description}


\subsection{Sequencer Information}
\label{sound/designs/procfile:sequencer-information}\begin{description}
\item[{seq/drivers}] \leavevmode
Lists the currently available ALSA sequencer drivers.

\item[{seq/clients}] \leavevmode
Shows the list of currently available sequencer clients and
ports.  The connection status and the running status are shown
in this file, too.

\item[{seq/queues}] \leavevmode
Lists the currently allocated/running sequencer queues.

\item[{seq/timer}] \leavevmode
Lists the currently allocated/running sequencer timers.

\item[{seq/oss}] \leavevmode
Lists the OSS-compatible sequencer stuffs.

\end{description}


\subsection{Help For Debugging?}
\label{sound/designs/procfile:help-for-debugging}
When the problem is related with PCM, first try to turn on xrun\_debug
mode.  This will give you the kernel messages when and where xrun
happened.

If it's really a bug, report it with the following information:
\begin{itemize}
\item {} 
the name of the driver/card, show in \code{/proc/asound/cards}

\item {} 
the register dump, if available (e.g. \code{card*/cmipci})

\end{itemize}

when it's a PCM problem,
\begin{itemize}
\item {} 
set-up of PCM, shown in hw\_parms, sw\_params, and status in the PCM
sub-stream directory

\end{itemize}

when it's a mixer problem,
\begin{itemize}
\item {} 
AC97 proc files, \code{codec97\#*/*} files

\end{itemize}

for USB audio/midi,
\begin{itemize}
\item {} 
output of \code{lsusb -v}

\item {} 
\code{stream*} files in card directory

\end{itemize}

The ALSA bug-tracking system is found at:
\href{https://bugtrack.alsa-project.org/alsa-bug/}{https://bugtrack.alsa-project.org/alsa-bug/}


\section{Notes on Power-Saving Mode}
\label{sound/designs/powersave:notes-on-power-saving-mode}\label{sound/designs/powersave::doc}
AC97 and HD-audio drivers have the automatic power-saving mode.
This feature is enabled via Kconfig \code{CONFIG\_SND\_AC97\_POWER\_SAVE}
and \code{CONFIG\_SND\_HDA\_POWER\_SAVE} options, respectively.

With the automatic power-saving, the driver turns off the codec power
appropriately when no operation is required.  When no applications use
the device and/or no analog loopback is set, the power disablement is
done fully or partially.  It'll save a certain power consumption, thus
good for laptops (even for desktops).

The time-out for automatic power-off can be specified via \code{power\_save}
module option of snd-ac97-codec and snd-hda-intel modules.  Specify
the time-out value in seconds.  0 means to disable the automatic
power-saving.  The default value of timeout is given via
\code{CONFIG\_SND\_AC97\_POWER\_SAVE\_DEFAULT} and
\code{CONFIG\_SND\_HDA\_POWER\_SAVE\_DEFAULT} Kconfig options.  Setting this to 1
(the minimum value) isn't recommended because many applications try to
reopen the device frequently.  10 would be a good choice for normal
operations.

The \code{power\_save} option is exported as writable.  This means you can
adjust the value via sysfs on the fly.  For example, to turn on the
automatic power-save mode with 10 seconds, write to
\code{/sys/modules/snd\_ac97\_codec/parameters/power\_save} (usually as root):

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} echo 10 \PYGZgt{} /sys/modules/snd\PYGZus{}ac97\PYGZus{}codec/parameters/power\PYGZus{}save
\end{Verbatim}

Note that you might hear click noise/pop when changing the power
state.  Also, it often takes certain time to wake up from the
power-down to the active state.  These are often hardly to fix, so
don't report extra bug reports unless you have a fix patch ;-)

For HD-audio interface, there is another module option,
power\_save\_controller.  This enables/disables the power-save mode of
the controller side.  Setting this on may reduce a bit more power
consumption, but might result in longer wake-up time and click noise.
Try to turn it off when you experience such a thing too often.


\section{Notes on Kernel OSS-Emulation}
\label{sound/designs/oss-emulation::doc}\label{sound/designs/oss-emulation:notes-on-kernel-oss-emulation}
Jan. 22, 2004  Takashi Iwai \textless{}\href{mailto:tiwai@suse.de}{tiwai@suse.de}\textgreater{}


\subsection{Modules}
\label{sound/designs/oss-emulation:modules}
ALSA provides a powerful OSS emulation on the kernel.
The OSS emulation for PCM, mixer and sequencer devices is implemented
as add-on kernel modules, snd-pcm-oss, snd-mixer-oss and snd-seq-oss.
When you need to access the OSS PCM, mixer or sequencer devices, the
corresponding module has to be loaded.

These modules are loaded automatically when the corresponding service
is called.  The alias is defined \code{sound-service-x-y}, where x and y are
the card number and the minor unit number.  Usually you don't have to
define these aliases by yourself.

Only necessary step for auto-loading of OSS modules is to define the
card alias in \code{/etc/modprobe.d/alsa.conf}, such as:

\begin{Verbatim}[commandchars=\\\{\}]
alias sound\PYGZhy{}slot\PYGZhy{}0 snd\PYGZhy{}emu10k1
\end{Verbatim}

As the second card, define \code{sound-slot-1} as well.
Note that you can't use the aliased name as the target name (i.e.
\code{alias sound-slot-0 snd-card-0} doesn't work any more like the old
modutils).

The currently available OSS configuration is shown in
/proc/asound/oss/sndstat.  This shows in the same syntax of
/dev/sndstat, which is available on the commercial OSS driver.
On ALSA, you can symlink /dev/sndstat to this proc file.

Please note that the devices listed in this proc file appear only
after the corresponding OSS-emulation module is loaded.  Don't worry
even if ``NOT ENABLED IN CONFIG'' is shown in it.


\subsection{Device Mapping}
\label{sound/designs/oss-emulation:device-mapping}
ALSA supports the following OSS device files:

\begin{Verbatim}[commandchars=\\\{\}]
PCM:
        /dev/dspX
        /dev/adspX

Mixer:
        /dev/mixerX

MIDI:
        /dev/midi0X
        /dev/amidi0X

Sequencer:
        /dev/sequencer
        /dev/sequencer2 (aka /dev/music)
\end{Verbatim}

where X is the card number from 0 to 7.

(NOTE: Some distributions have the device files like /dev/midi0 and
/dev/midi1.  They are NOT for OSS but for tclmidi, which is
a totally different thing.)

Unlike the real OSS, ALSA cannot use the device files more than the
assigned ones.  For example, the first card cannot use /dev/dsp1 or
/dev/dsp2, but only /dev/dsp0 and /dev/adsp0.

As seen above, PCM and MIDI may have two devices.  Usually, the first
PCM device (\code{hw:0,0} in ALSA) is mapped to /dev/dsp and the secondary
device (\code{hw:0,1}) to /dev/adsp (if available).  For MIDI, /dev/midi and
/dev/amidi, respectively.

You can change this device mapping via the module options of
snd-pcm-oss and snd-rawmidi.  In the case of PCM, the following
options are available for snd-pcm-oss:
\begin{description}
\item[{dsp\_map}] \leavevmode
PCM device number assigned to /dev/dspX
(default = 0)

\item[{adsp\_map}] \leavevmode
PCM device number assigned to /dev/adspX
(default = 1)

\end{description}

For example, to map the third PCM device (\code{hw:0,2}) to /dev/adsp0,
define like this:

\begin{Verbatim}[commandchars=\\\{\}]
options snd\PYGZhy{}pcm\PYGZhy{}oss adsp\PYGZus{}map=2
\end{Verbatim}

The options take arrays.  For configuring the second card, specify
two entries separated by comma.  For example, to map the third PCM
device on the second card to /dev/adsp1, define like below:

\begin{Verbatim}[commandchars=\\\{\}]
options snd\PYGZhy{}pcm\PYGZhy{}oss adsp\PYGZus{}map=0,2
\end{Verbatim}

To change the mapping of MIDI devices, the following options are
available for snd-rawmidi:
\begin{description}
\item[{midi\_map}] \leavevmode
MIDI device number assigned to /dev/midi0X
(default = 0)

\item[{amidi\_map}] \leavevmode
MIDI device number assigned to /dev/amidi0X
(default = 1)

\end{description}

For example, to assign the third MIDI device on the first card to
/dev/midi00, define as follows:

\begin{Verbatim}[commandchars=\\\{\}]
options snd\PYGZhy{}rawmidi midi\PYGZus{}map=2
\end{Verbatim}


\subsection{PCM Mode}
\label{sound/designs/oss-emulation:pcm-mode}
As default, ALSA emulates the OSS PCM with so-called plugin layer,
i.e. tries to convert the sample format, rate or channels
automatically when the card doesn't support it natively.
This will lead to some problems for some applications like quake or
wine, especially if they use the card only in the MMAP mode.

In such a case, you can change the behavior of PCM per application by
writing a command to the proc file.  There is a proc file for each PCM
stream, \code{/proc/asound/cardX/pcmY{[}cp{]}/oss}, where X is the card number
(zero-based), Y the PCM device number (zero-based), and \code{p} is for
playback and \code{c} for capture, respectively.  Note that this proc file
exists only after snd-pcm-oss module is loaded.

The command sequence has the following syntax:

\begin{Verbatim}[commandchars=\\\{\}]
app\PYGZus{}name fragments fragment\PYGZus{}size [options]
\end{Verbatim}

\code{app\_name} is the name of application with (higher priority) or without
path.
\code{fragments} specifies the number of fragments or zero if no specific
number is given.
\code{fragment\_size} is the size of fragment in bytes or zero if not given.
\code{options} is the optional parameters.  The following options are
available:
\begin{description}
\item[{disable}] \leavevmode
the application tries to open a pcm device for
this channel but does not want to use it.

\item[{direct}] \leavevmode
don't use plugins

\item[{block}] \leavevmode
force block open mode

\item[{non-block}] \leavevmode
force non-block open mode

\item[{partial-frag}] \leavevmode
write also partial fragments (affects playback only)

\item[{no-silence}] \leavevmode
do not fill silence ahead to avoid clicks

\end{description}

The \code{disable} option is useful when one stream direction (playback or
capture) is not handled correctly by the application although the
hardware itself does support both directions.
The \code{direct} option is used, as mentioned above, to bypass the automatic
conversion and useful for MMAP-applications.
For example, to playback the first PCM device without plugins for
quake, send a command via echo like the following:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} echo \PYGZdq{}quake 0 0 direct\PYGZdq{} \PYGZgt{} /proc/asound/card0/pcm0p/oss
\end{Verbatim}

While quake wants only playback, you may append the second command
to notify driver that only this direction is about to be allocated:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} echo \PYGZdq{}quake 0 0 disable\PYGZdq{} \PYGZgt{} /proc/asound/card0/pcm0c/oss
\end{Verbatim}

The permission of proc files depend on the module options of snd.
As default it's set as root, so you'll likely need to be superuser for
sending the command above.

The block and non-block options are used to change the behavior of
opening the device file.

As default, ALSA behaves as original OSS drivers, i.e. does not block
the file when it's busy. The -EBUSY error is returned in this case.

This blocking behavior can be changed globally via nonblock\_open
module option of snd-pcm-oss.  For using the blocking mode as default
for OSS devices, define like the following:

\begin{Verbatim}[commandchars=\\\{\}]
options snd\PYGZhy{}pcm\PYGZhy{}oss nonblock\PYGZus{}open=0
\end{Verbatim}

The \code{partial-frag} and \code{no-silence} commands have been added recently.
Both commands are for optimization use only.  The former command
specifies to invoke the write transfer only when the whole fragment is
filled.  The latter stops writing the silence data ahead
automatically.  Both are disabled as default.

You can check the currently defined configuration by reading the proc
file.  The read image can be sent to the proc file again, hence you
can save the current configuration

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} cat /proc/asound/card0/pcm0p/oss \PYGZgt{} /somewhere/oss\PYGZhy{}cfg
\end{Verbatim}

and restore it like

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} cat /somewhere/oss\PYGZhy{}cfg \PYGZgt{} /proc/asound/card0/pcm0p/oss
\end{Verbatim}

Also, for clearing all the current configuration, send \code{erase} command
as below:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} echo \PYGZdq{}erase\PYGZdq{} \PYGZgt{} /proc/asound/card0/pcm0p/oss
\end{Verbatim}


\subsection{Mixer Elements}
\label{sound/designs/oss-emulation:mixer-elements}
Since ALSA has completely different mixer interface, the emulation of
OSS mixer is relatively complicated.  ALSA builds up a mixer element
from several different ALSA (mixer) controls based on the name
string.  For example, the volume element SOUND\_MIXER\_PCM is composed
from ``PCM Playback Volume'' and ``PCM Playback Switch'' controls for the
playback direction and from ``PCM Capture Volume'' and ``PCM Capture
Switch'' for the capture directory (if exists).  When the PCM volume of
OSS is changed, all the volume and switch controls above are adjusted
automatically.

As default, ALSA uses the following control for OSS volumes:

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
OSS volume
} & \textsf{\relax 
ALSA control
} & \textsf{\relax 
Index
}\\
\hline
SOUND\_MIXER\_VOLUME
 & 
Master
 & 
0
\\
\hline
SOUND\_MIXER\_BASS
 & 
Tone Control - Bass
 & 
0
\\
\hline
SOUND\_MIXER\_TREBLE
 & 
Tone Control - Treble
 & 
0
\\
\hline
SOUND\_MIXER\_SYNTH
 & 
Synth
 & 
0
\\
\hline
SOUND\_MIXER\_PCM
 & 
PCM
 & 
0
\\
\hline
SOUND\_MIXER\_SPEAKER
 & 
PC Speaker
 & 
0
\\
\hline
SOUND\_MIXER\_LINE
 & 
Line
 & 
0
\\
\hline
SOUND\_MIXER\_MIC
 & 
Mic
 & 
0
\\
\hline
SOUND\_MIXER\_CD
 & 
CD
 & 
0
\\
\hline
SOUND\_MIXER\_IMIX
 & 
Monitor Mix
 & 
0
\\
\hline
SOUND\_MIXER\_ALTPCM
 & 
PCM
 & 
1
\\
\hline
SOUND\_MIXER\_RECLEV
 & 
(not assigned)
 & \\
\hline
SOUND\_MIXER\_IGAIN
 & 
Capture
 & 
0
\\
\hline
SOUND\_MIXER\_OGAIN
 & 
Playback
 & 
0
\\
\hline
SOUND\_MIXER\_LINE1
 & 
Aux
 & 
0
\\
\hline
SOUND\_MIXER\_LINE2
 & 
Aux
 & 
1
\\
\hline
SOUND\_MIXER\_LINE3
 & 
Aux
 & 
2
\\
\hline
SOUND\_MIXER\_DIGITAL1
 & 
Digital
 & 
0
\\
\hline
SOUND\_MIXER\_DIGITAL2
 & 
Digital
 & 
1
\\
\hline
SOUND\_MIXER\_DIGITAL3
 & 
Digital
 & 
2
\\
\hline
SOUND\_MIXER\_PHONEIN
 & 
Phone
 & 
0
\\
\hline
SOUND\_MIXER\_PHONEOUT
 & 
Phone
 & 
1
\\
\hline
SOUND\_MIXER\_VIDEO
 & 
Video
 & 
0
\\
\hline
SOUND\_MIXER\_RADIO
 & 
Radio
 & 
0
\\
\hline
SOUND\_MIXER\_MONITOR
 & 
Monitor
 & 
0
\\
\hline\end{tabulary}


The second column is the base-string of the corresponding ALSA
control.  In fact, the controls with \code{XXX {[}Playback\textbar{}Capture{]}
{[}Volume\textbar{}Switch{]}} will be checked in addition.

The current assignment of these mixer elements is listed in the proc
file, /proc/asound/cardX/oss\_mixer, which will be like the following

\begin{Verbatim}[commandchars=\\\{\}]
VOLUME \PYGZdq{}Master\PYGZdq{} 0
BASS \PYGZdq{}\PYGZdq{} 0
TREBLE \PYGZdq{}\PYGZdq{} 0
SYNTH \PYGZdq{}\PYGZdq{} 0
PCM \PYGZdq{}PCM\PYGZdq{} 0
...
\end{Verbatim}

where the first column is the OSS volume element, the second column
the base-string of the corresponding ALSA control, and the third the
control index.  When the string is empty, it means that the
corresponding OSS control is not available.

For changing the assignment, you can write the configuration to this
proc file.  For example, to map ``Wave Playback'' to the PCM volume,
send the command like the following:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} echo \PYGZsq{}VOLUME \PYGZdq{}Wave Playback\PYGZdq{} 0\PYGZsq{} \PYGZgt{} /proc/asound/card0/oss\PYGZus{}mixer
\end{Verbatim}

The command is exactly as same as listed in the proc file.  You can
change one or more elements, one volume per line.  In the last
example, both ``Wave Playback Volume'' and ``Wave Playback Switch'' will
be affected when PCM volume is changed.

Like the case of PCM proc file, the permission of proc files depend on
the module options of snd.  you'll likely need to be superuser for
sending the command above.

As well as in the case of PCM proc file, you can save and restore the
current mixer configuration by reading and writing the whole file
image.


\subsection{Duplex Streams}
\label{sound/designs/oss-emulation:duplex-streams}
Note that when attempting to use a single device file for playback and
capture, the OSS API provides no way to set the format, sample rate or
number of channels different in each direction.  Thus

\begin{Verbatim}[commandchars=\\\{\}]
io\PYGZus{}handle = open(\PYGZdq{}device\PYGZdq{}, O\PYGZus{}RDWR)
\end{Verbatim}

will only function correctly if the values are the same in each direction.

To use different values in the two directions, use both

\begin{Verbatim}[commandchars=\\\{\}]
input\PYGZus{}handle = open(\PYGZdq{}device\PYGZdq{}, O\PYGZus{}RDONLY)
output\PYGZus{}handle = open(\PYGZdq{}device\PYGZdq{}, O\PYGZus{}WRONLY)
\end{Verbatim}

and set the values for the corresponding handle.


\subsection{Unsupported Features}
\label{sound/designs/oss-emulation:unsupported-features}

\subsubsection{MMAP on ICE1712 driver}
\label{sound/designs/oss-emulation:mmap-on-ice1712-driver}
ICE1712 supports only the unconventional format, interleaved
10-channels 24bit (packed in 32bit) format.  Therefore you cannot mmap
the buffer as the conventional (mono or 2-channels, 8 or 16bit) format
on OSS.


\section{OSS Sequencer Emulation on ALSA}
\label{sound/designs/seq-oss::doc}\label{sound/designs/seq-oss:oss-sequencer-emulation-on-alsa}
Copyright (c) 1998,1999 by Takashi Iwai

ver.0.1.8; Nov. 16, 1999


\subsection{Description}
\label{sound/designs/seq-oss:description}
This directory contains the OSS sequencer emulation driver on ALSA. Note
that this program is still in the development state.

What this does - it provides the emulation of the OSS sequencer, access
via \code{/dev/sequencer} and \code{/dev/music} devices.
The most of applications using OSS can run if the appropriate ALSA
sequencer is prepared.

The following features are emulated by this driver:
\begin{itemize}
\item {} 
Normal sequencer and MIDI events:
\begin{quote}

They are converted to the ALSA sequencer events, and sent to the
corresponding port.
\end{quote}

\item {} 
Timer events:
\begin{quote}

The timer is not selectable by ioctl. The control rate is fixed to
100 regardless of HZ. That is, even on Alpha system, a tick is always
1/100 second. The base rate and tempo can be changed in \code{/dev/music}.
\end{quote}

\item {} 
Patch loading:
\begin{quote}

It purely depends on the synth drivers whether it's supported since
the patch loading is realized by callback to the synth driver.
\end{quote}

\item {} 
I/O controls:
\begin{quote}

Most of controls are accepted. Some controls
are dependent on the synth driver, as well as even on original OSS.
\end{quote}

\end{itemize}

Furthermore, you can find the following advanced features:
\begin{itemize}
\item {} 
Better queue mechanism:
\begin{quote}

The events are queued before processing them.
\end{quote}

\item {} 
Multiple applications:
\begin{quote}

You can run two or more applications simultaneously (even for OSS
sequencer)!
However, each MIDI device is exclusive - that is, if a MIDI device
is opened once by some application, other applications can't use
it. No such a restriction in synth devices.
\end{quote}

\item {} 
Real-time event processing:
\begin{quote}

The events can be processed in real time without using out of bound
ioctl. To switch to real-time mode, send ABSTIME 0 event. The followed
events will be processed in real-time without queued. To switch off the
real-time mode, send RELTIME 0 event.
\end{quote}

\item {} 
\code{/proc} interface:
\begin{quote}

The status of applications and devices can be shown via
\code{/proc/asound/seq/oss} at any time. In the later version,
configuration will be changed via \code{/proc} interface, too.
\end{quote}

\end{itemize}


\subsection{Installation}
\label{sound/designs/seq-oss:installation}
Run configure script with both sequencer support (\code{-{-}with-sequencer=yes})
and OSS emulation (\code{-{-}with-oss=yes}) options. A module \code{snd-seq-oss.o}
will be created. If the synth module of your sound card supports for OSS
emulation (so far, only Emu8000 driver), this module will be loaded
automatically.
Otherwise, you need to load this module manually.

At beginning, this module probes all the MIDI ports which have been
already connected to the sequencer. Once after that, the creation and deletion
of ports are watched by announcement mechanism of ALSA sequencer.

The available synth and MIDI devices can be found in proc interface.
Run \code{cat /proc/asound/seq/oss}, and check the devices. For example,
if you use an AWE64 card, you'll see like the following:

\begin{Verbatim}[commandchars=\\\{\}]
OSS sequencer emulation version 0.1.8
ALSA client number 63
ALSA receiver port 0

Number of applications: 0

Number of synth devices: 1
synth 0: [EMU8000]
  type 0x1 : subtype 0x20 : voices 32
  capabilties : ioctl enabled / load\PYGZus{}patch enabled

Number of MIDI devices: 3
midi 0: [Emu8000 Port\PYGZhy{}0] ALSA port 65:0
  capability write / opened none

midi 1: [Emu8000 Port\PYGZhy{}1] ALSA port 65:1
  capability write / opened none

midi 2: [0: MPU\PYGZhy{}401 (UART)] ALSA port 64:0
  capability read/write / opened none
\end{Verbatim}

Note that the device number may be different from the information of
\code{/proc/asound/oss-devices} or ones of the original OSS driver.
Use the device number listed in \code{/proc/asound/seq/oss}
to play via OSS sequencer emulation.


\subsection{Using Synthesizer Devices}
\label{sound/designs/seq-oss:using-synthesizer-devices}
Run your favorite program. I've tested playmidi-2.4, awemidi-0.4.3, gmod-3.1
and xmp-1.1.5. You can load samples via \code{/dev/sequencer} like sfxload,
too.

If the lowlevel driver supports multiple access to synth devices (like
Emu8000 driver), two or more applications are allowed to run at the same
time.


\subsection{Using MIDI Devices}
\label{sound/designs/seq-oss:using-midi-devices}
So far, only MIDI output was tested. MIDI input was not checked at all,
but hopefully it will work. Use the device number listed in
\code{/proc/asound/seq/oss}.
Be aware that these numbers are mostly different from the list in
\code{/proc/asound/oss-devices}.


\subsection{Module Options}
\label{sound/designs/seq-oss:module-options}
The following module options are available:
\begin{description}
\item[{maxqlen}] \leavevmode
specifies the maximum read/write queue length. This queue is private
for OSS sequencer, so that it is independent from the queue length of ALSA
sequencer. Default value is 1024.

\item[{seq\_oss\_debug}] \leavevmode
specifies the debug level and accepts zero (= no debug message) or
positive integer. Default value is 0.

\end{description}


\subsection{Queue Mechanism}
\label{sound/designs/seq-oss:queue-mechanism}
OSS sequencer emulation uses an ALSA priority queue. The
events from \code{/dev/sequencer} are processed and put onto the queue
specified by module option.

All the events from \code{/dev/sequencer} are parsed at beginning.
The timing events are also parsed at this moment, so that the events may
be processed in real-time. Sending an event ABSTIME 0 switches the operation
mode to real-time mode, and sending an event RELTIME 0 switches it off.
In the real-time mode, all events are dispatched immediately.

The queued events are dispatched to the corresponding ALSA sequencer
ports after scheduled time by ALSA sequencer dispatcher.

If the write-queue is full, the application sleeps until a certain amount
(as default one half) becomes empty in blocking mode. The synchronization
to write timing was implemented, too.

The input from MIDI devices or echo-back events are stored on read FIFO
queue. If application reads \code{/dev/sequencer} in blocking mode, the
process will be awaked.


\subsection{Interface to Synthesizer Device}
\label{sound/designs/seq-oss:interface-to-synthesizer-device}

\subsubsection{Registration}
\label{sound/designs/seq-oss:registration}
To register an OSS synthesizer device, use snd\_seq\_oss\_synth\_register()
function:

\begin{Verbatim}[commandchars=\\\{\}]
int snd\PYGZus{}seq\PYGZus{}oss\PYGZus{}synth\PYGZus{}register(char *name, int type, int subtype, int nvoices,
        snd\PYGZus{}seq\PYGZus{}oss\PYGZus{}callback\PYGZus{}t *oper, void *private\PYGZus{}data)
\end{Verbatim}

The arguments \code{name}, \code{type}, \code{subtype} and \code{nvoices}
are used for making the appropriate synth\_info structure for ioctl. The
return value is an index number of this device. This index must be remembered
for unregister. If registration is failed, -errno will be returned.

To release this device, call snd\_seq\_oss\_synth\_unregister() function:

\begin{Verbatim}[commandchars=\\\{\}]
int snd\PYGZus{}seq\PYGZus{}oss\PYGZus{}synth\PYGZus{}unregister(int index)
\end{Verbatim}

where the \code{index} is the index number returned by register function.


\subsubsection{Callbacks}
\label{sound/designs/seq-oss:callbacks}
OSS synthesizer devices have capability for sample downloading and ioctls
like sample reset. In OSS emulation, these special features are realized
by using callbacks. The registration argument oper is used to specify these
callbacks. The following callback functions must be defined:

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}seq\PYGZus{}oss\PYGZus{}callback\PYGZus{}t:
 int (*open)(snd\PYGZus{}seq\PYGZus{}oss\PYGZus{}arg\PYGZus{}t *p, void *closure);
 int (*close)(snd\PYGZus{}seq\PYGZus{}oss\PYGZus{}arg\PYGZus{}t *p);
 int (*ioctl)(snd\PYGZus{}seq\PYGZus{}oss\PYGZus{}arg\PYGZus{}t *p, unsigned int cmd, unsigned long arg);
 int (*load\PYGZus{}patch)(snd\PYGZus{}seq\PYGZus{}oss\PYGZus{}arg\PYGZus{}t *p, int format, const char *buf, int offs, int count);
 int (*reset)(snd\PYGZus{}seq\PYGZus{}oss\PYGZus{}arg\PYGZus{}t *p);
\end{Verbatim}

Except for \code{open} and \code{close} callbacks, they are allowed to be NULL.

Each callback function takes the argument type \code{snd\_seq\_oss\_arg\_t} as the
first argument.

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}seq\PYGZus{}oss\PYGZus{}arg\PYGZus{}t \PYGZob{}
    int app\PYGZus{}index;
    int file\PYGZus{}mode;
    int seq\PYGZus{}mode;
    snd\PYGZus{}seq\PYGZus{}addr\PYGZus{}t addr;
    void *private\PYGZus{}data;
    int event\PYGZus{}passing;
\PYGZcb{};
\end{Verbatim}

The first three fields, \code{app\_index}, \code{file\_mode} and \code{seq\_mode}
are initialized by OSS sequencer. The \code{app\_index} is the application
index which is unique to each application opening OSS sequencer. The
\code{file\_mode} is bit-flags indicating the file operation mode. See
\code{seq\_oss.h} for its meaning. The \code{seq\_mode} is sequencer operation
mode. In the current version, only \code{SND\_OSSSEQ\_MODE\_SYNTH} is used.

The next two fields, \code{addr} and \code{private\_data}, must be
filled by the synth driver at open callback. The \code{addr} contains
the address of ALSA sequencer port which is assigned to this device. If
the driver allocates memory for \code{private\_data}, it must be released
in close callback by itself.

The last field, \code{event\_passing}, indicates how to translate note-on
/ off events. In \code{PROCESS\_EVENTS} mode, the note 255 is regarded
as velocity change, and key pressure event is passed to the port. In
\code{PASS\_EVENTS} mode, all note on/off events are passed to the port
without modified. \code{PROCESS\_KEYPRESS} mode checks the note above 128
and regards it as key pressure event (mainly for Emu8000 driver).


\subsubsection{Open Callback}
\label{sound/designs/seq-oss:open-callback}
The \code{open} is called at each time this device is opened by an application
using OSS sequencer. This must not be NULL. Typically, the open callback
does the following procedure:
\begin{enumerate}
\item {} 
Allocate private data record.

\item {} 
Create an ALSA sequencer port.

\item {} 
Set the new port address on \code{arg-\textgreater{}addr}.

\item {} 
Set the private data record pointer on \code{arg-\textgreater{}private\_data}.

\end{enumerate}

Note that the type bit-flags in port\_info of this synth port must NOT contain
\code{TYPE\_MIDI\_GENERIC}
bit. Instead, \code{TYPE\_SPECIFIC} should be used. Also, \code{CAP\_SUBSCRIPTION}
bit should NOT be included, too. This is necessary to tell it from other
normal MIDI devices. If the open procedure succeeded, return zero. Otherwise,
return -errno.


\subsubsection{Ioctl Callback}
\label{sound/designs/seq-oss:ioctl-callback}
The \code{ioctl} callback is called when the sequencer receives device-specific
ioctls. The following two ioctls should be processed by this callback:
\begin{description}
\item[{IOCTL\_SEQ\_RESET\_SAMPLES}] \leavevmode
reset all samples on memory -- return 0

\item[{IOCTL\_SYNTH\_MEMAVL}] \leavevmode
return the available memory size

\item[{FM\_4OP\_ENABLE}] \leavevmode
can be ignored usually

\end{description}

The other ioctls are processed inside the sequencer without passing to
the lowlevel driver.


\subsubsection{Load\_Patch Callback}
\label{sound/designs/seq-oss:load-patch-callback}
The \code{load\_patch} callback is used for sample-downloading. This callback
must read the data on user-space and transfer to each device. Return 0
if succeeded, and -errno if failed. The format argument is the patch key
in patch\_info record. The buf is user-space pointer where patch\_info record
is stored. The offs can be ignored. The count is total data size of this
sample data.


\subsubsection{Close Callback}
\label{sound/designs/seq-oss:close-callback}
The \code{close} callback is called when this device is closed by the
application. If any private data was allocated in open callback, it must
be released in the close callback. The deletion of ALSA port should be
done here, too. This callback must not be NULL.


\subsubsection{Reset Callback}
\label{sound/designs/seq-oss:reset-callback}
The \code{reset} callback is called when sequencer device is reset or
closed by applications. The callback should turn off the sounds on the
relevant port immediately, and initialize the status of the port. If this
callback is undefined, OSS seq sends a \code{HEARTBEAT} event to the
port.


\subsection{Events}
\label{sound/designs/seq-oss:events}
Most of the events are processed by sequencer and translated to the adequate
ALSA sequencer events, so that each synth device can receive by input\_event
callback of ALSA sequencer port. The following ALSA events should be
implemented by the driver:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
ALSA event
} & \textsf{\relax 
Original OSS events
}\\
\hline
NOTEON
 & 
SEQ\_NOTEON, MIDI\_NOTEON
\\
\hline
NOTE
 & 
SEQ\_NOTEOFF, MIDI\_NOTEOFF
\\
\hline
KEYPRESS
 & 
MIDI\_KEY\_PRESSURE
\\
\hline
CHANPRESS
 & 
SEQ\_AFTERTOUCH, MIDI\_CHN\_PRESSURE
\\
\hline
PGMCHANGE
 & 
SEQ\_PGMCHANGE, MIDI\_PGM\_CHANGE
\\
\hline
PITCHBEND
 & 
SEQ\_CONTROLLER(CTRL\_PITCH\_BENDER),
MIDI\_PITCH\_BEND
\\
\hline
CONTROLLER
 & 
MIDI\_CTL\_CHANGE,
SEQ\_BALANCE (with CTL\_PAN)
\\
\hline
CONTROL14
 & 
SEQ\_CONTROLLER
\\
\hline
REGPARAM
 & 
SEQ\_CONTROLLER(CTRL\_PITCH\_BENDER\_RANGE)
\\
\hline
SYSEX
 & 
SEQ\_SYSEX
\\
\hline\end{tabulary}


The most of these behavior can be realized by MIDI emulation driver
included in the Emu8000 lowlevel driver. In the future release, this module
will be independent.

Some OSS events (\code{SEQ\_PRIVATE} and \code{SEQ\_VOLUME} events) are passed as event
type SND\_SEQ\_OSS\_PRIVATE.  The OSS sequencer passes these event 8 byte
packets without any modification. The lowlevel driver should process these
events appropriately.


\subsection{Interface to MIDI Device}
\label{sound/designs/seq-oss:interface-to-midi-device}
Since the OSS emulation probes the creation and deletion of ALSA MIDI
sequencer ports automatically by receiving announcement from ALSA
sequencer, the MIDI devices don't need to be registered explicitly
like synth devices.
However, the MIDI port\_info registered to ALSA sequencer must include
a group name \code{SND\_SEQ\_GROUP\_DEVICE} and a capability-bit
\code{CAP\_READ} or \code{CAP\_WRITE}. Also, subscription capabilities,
\code{CAP\_SUBS\_READ} or \code{CAP\_SUBS\_WRITE}, must be defined, too. If
these conditions are not satisfied, the port is not registered as OSS
sequencer MIDI device.

The events via MIDI devices are parsed in OSS sequencer and converted
to the corresponding ALSA sequencer events. The input from MIDI sequencer
is also converted to MIDI byte events by OSS sequencer. This works just
a reverse way of seq\_midi module.


\subsection{Known Problems / TODO's}
\label{sound/designs/seq-oss:known-problems-todo-s}\begin{itemize}
\item {} 
Patch loading via ALSA instrument layer is not implemented yet.

\end{itemize}


\chapter{ALSA SoC Layer}
\label{sound/soc/index::doc}\label{sound/soc/index:alsa-soc-layer}
The documentation is spilt into the following sections:-


\section{ALSA SoC Layer Overview}
\label{sound/soc/overview:alsa-soc-layer-overview}\label{sound/soc/overview::doc}
The overall project goal of the ALSA System on Chip (ASoC) layer is to
provide better ALSA support for embedded system-on-chip processors (e.g.
pxa2xx, au1x00, iMX, etc) and portable audio codecs.  Prior to the ASoC
subsystem there was some support in the kernel for SoC audio, however it
had some limitations:-
\begin{itemize}
\item {} 
Codec drivers were often tightly coupled to the underlying SoC
CPU. This is not ideal and leads to code duplication - for example,
Linux had different wm8731 drivers for 4 different SoC platforms.

\item {} 
There was no standard method to signal user initiated audio events (e.g.
Headphone/Mic insertion, Headphone/Mic detection after an insertion
event). These are quite common events on portable devices and often require
machine specific code to re-route audio, enable amps, etc., after such an
event.

\item {} 
Drivers tended to power up the entire codec when playing (or
recording) audio. This is fine for a PC, but tends to waste a lot of
power on portable devices. There was also no support for saving
power via changing codec oversampling rates, bias currents, etc.

\end{itemize}


\subsection{ASoC Design}
\label{sound/soc/overview:asoc-design}
The ASoC layer is designed to address these issues and provide the following
features :-
\begin{itemize}
\item {} 
Codec independence. Allows reuse of codec drivers on other platforms
and machines.

\item {} 
Easy I2S/PCM audio interface setup between codec and SoC. Each SoC
interface and codec registers its audio interface capabilities with the
core and are subsequently matched and configured when the application
hardware parameters are known.

\item {} 
Dynamic Audio Power Management (DAPM). DAPM automatically sets the codec to
its minimum power state at all times. This includes powering up/down
internal power blocks depending on the internal codec audio routing and any
active streams.

\item {} 
Pop and click reduction. Pops and clicks can be reduced by powering the
codec up/down in the correct sequence (including using digital mute). ASoC
signals the codec when to change power states.

\item {} 
Machine specific controls: Allow machines to add controls to the sound card
(e.g. volume control for speaker amplifier).

\end{itemize}

To achieve all this, ASoC basically splits an embedded audio system into
multiple re-usable component drivers :-
\begin{itemize}
\item {} 
Codec class drivers: The codec class driver is platform independent and
contains audio controls, audio interface capabilities, codec DAPM
definition and codec IO functions. This class extends to BT, FM and MODEM
ICs if required. Codec class drivers should be generic code that can run
on any architecture and machine.

\item {} 
Platform class drivers: The platform class driver includes the audio DMA
engine driver, digital audio interface (DAI) drivers (e.g. I2S, AC97, PCM)
and any audio DSP drivers for that platform.

\item {} 
Machine class driver: The machine driver class acts as the glue that
describes and binds the other component drivers together to form an ALSA
``sound card device''. It handles any machine specific controls and
machine level audio events (e.g. turning on an amp at start of playback).

\end{itemize}


\section{ASoC Codec Class Driver}
\label{sound/soc/codec:asoc-codec-class-driver}\label{sound/soc/codec::doc}
The codec class driver is generic and hardware independent code that configures
the codec, FM, MODEM, BT or external DSP to provide audio capture and playback.
It should contain no code that is specific to the target platform or machine.
All platform and machine specific code should be added to the platform and
machine drivers respectively.

Each codec class driver \emph{must} provide the following features:-
\begin{enumerate}
\item {} 
Codec DAI and PCM configuration

\item {} 
Codec control IO - using RegMap API

\item {} 
Mixers and audio controls

\item {} 
Codec audio operations

\item {} 
DAPM description.

\item {} 
DAPM event handler.

\end{enumerate}

Optionally, codec drivers can also provide:-
\begin{enumerate}
\setcounter{enumi}{6}
\item {} 
DAC Digital mute control.

\end{enumerate}

Its probably best to use this guide in conjunction with the existing codec
driver code in sound/soc/codecs/


\subsection{ASoC Codec driver breakdown}
\label{sound/soc/codec:asoc-codec-driver-breakdown}

\subsubsection{Codec DAI and PCM configuration}
\label{sound/soc/codec:codec-dai-and-pcm-configuration}
Each codec driver must have a struct snd\_soc\_dai\_driver to define its DAI and
PCM capabilities and operations. This struct is exported so that it can be
registered with the core by your machine driver.

e.g.

\begin{Verbatim}[commandchars=\\\{\}]
static struct snd\PYGZus{}soc\PYGZus{}dai\PYGZus{}ops wm8731\PYGZus{}dai\PYGZus{}ops = \PYGZob{}
      .prepare        = wm8731\PYGZus{}pcm\PYGZus{}prepare,
      .hw\PYGZus{}params      = wm8731\PYGZus{}hw\PYGZus{}params,
      .shutdown       = wm8731\PYGZus{}shutdown,
      .digital\PYGZus{}mute   = wm8731\PYGZus{}mute,
      .set\PYGZus{}sysclk     = wm8731\PYGZus{}set\PYGZus{}dai\PYGZus{}sysclk,
      .set\PYGZus{}fmt        = wm8731\PYGZus{}set\PYGZus{}dai\PYGZus{}fmt,
\PYGZcb{};

struct snd\PYGZus{}soc\PYGZus{}dai\PYGZus{}driver wm8731\PYGZus{}dai = \PYGZob{}
      .name = \PYGZdq{}wm8731\PYGZhy{}hifi\PYGZdq{},
      .playback = \PYGZob{}
              .stream\PYGZus{}name = \PYGZdq{}Playback\PYGZdq{},
              .channels\PYGZus{}min = 1,
              .channels\PYGZus{}max = 2,
              .rates = WM8731\PYGZus{}RATES,
              .formats = WM8731\PYGZus{}FORMATS,\PYGZcb{},
      .capture = \PYGZob{}
              .stream\PYGZus{}name = \PYGZdq{}Capture\PYGZdq{},
              .channels\PYGZus{}min = 1,
              .channels\PYGZus{}max = 2,
              .rates = WM8731\PYGZus{}RATES,
              .formats = WM8731\PYGZus{}FORMATS,\PYGZcb{},
      .ops = \PYGZam{}wm8731\PYGZus{}dai\PYGZus{}ops,
      .symmetric\PYGZus{}rates = 1,
\PYGZcb{};
\end{Verbatim}


\subsubsection{Codec control IO}
\label{sound/soc/codec:codec-control-io}
The codec can usually be controlled via an I2C or SPI style interface
(AC97 combines control with data in the DAI). The codec driver should use the
Regmap API for all codec IO. Please see include/linux/regmap.h and existing
codec drivers for example regmap usage.


\subsubsection{Mixers and audio controls}
\label{sound/soc/codec:mixers-and-audio-controls}
All the codec mixers and audio controls can be defined using the convenience
macros defined in soc.h.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}define SOC\PYGZus{}SINGLE(xname, reg, shift, mask, invert)
\end{Verbatim}

Defines a single control as follows:-

\begin{Verbatim}[commandchars=\\\{\}]
xname = Control name e.g. \PYGZdq{}Playback Volume\PYGZdq{}
reg = codec register
shift = control bit(s) offset in register
mask = control bit size(s) e.g. mask of 7 = 3 bits
invert = the control is inverted
\end{Verbatim}

Other macros include:-

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}define SOC\PYGZus{}DOUBLE(xname, reg, shift\PYGZus{}left, shift\PYGZus{}right, mask, invert)
\end{Verbatim}

A stereo control

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}define SOC\PYGZus{}DOUBLE\PYGZus{}R(xname, reg\PYGZus{}left, reg\PYGZus{}right, shift, mask, invert)
\end{Verbatim}

A stereo control spanning 2 registers

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{}define SOC\PYGZus{}ENUM\PYGZus{}SINGLE(xreg, xshift, xmask, xtexts)
\end{Verbatim}

Defines an single enumerated control as follows:-

\begin{Verbatim}[commandchars=\\\{\}]
xreg = register
xshift = control bit(s) offset in register
xmask = control bit(s) size
xtexts = pointer to array of strings that describe each setting

\PYGZsh{}define SOC\PYGZus{}ENUM\PYGZus{}DOUBLE(xreg, xshift\PYGZus{}l, xshift\PYGZus{}r, xmask, xtexts)
\end{Verbatim}

Defines a stereo enumerated control


\subsubsection{Codec Audio Operations}
\label{sound/soc/codec:codec-audio-operations}
The codec driver also supports the following ALSA PCM operations:-

\begin{Verbatim}[commandchars=\\\{\}]
/* SoC audio ops */
struct snd\PYGZus{}soc\PYGZus{}ops \PYGZob{}
      int (*startup)(struct snd\PYGZus{}pcm\PYGZus{}substream *);
      void (*shutdown)(struct snd\PYGZus{}pcm\PYGZus{}substream *);
      int (*hw\PYGZus{}params)(struct snd\PYGZus{}pcm\PYGZus{}substream *, struct snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}params *);
      int (*hw\PYGZus{}free)(struct snd\PYGZus{}pcm\PYGZus{}substream *);
      int (*prepare)(struct snd\PYGZus{}pcm\PYGZus{}substream *);
\PYGZcb{};
\end{Verbatim}

Please refer to the ALSA driver PCM documentation for details.
\href{http://www.alsa-project.org/~iwai/writing-an-alsa-driver/}{http://www.alsa-project.org/\textasciitilde{}iwai/writing-an-alsa-driver/}


\subsubsection{DAPM description}
\label{sound/soc/codec:dapm-description}
The Dynamic Audio Power Management description describes the codec power
components and their relationships and registers to the ASoC core.
Please read dapm.txt for details of building the description.

Please also see the examples in other codec drivers.


\subsubsection{DAPM event handler}
\label{sound/soc/codec:dapm-event-handler}
This function is a callback that handles codec domain PM calls and system
domain PM calls (e.g. suspend and resume). It is used to put the codec
to sleep when not in use.

Power states:-

\begin{Verbatim}[commandchars=\\\{\}]
SNDRV\PYGZus{}CTL\PYGZus{}POWER\PYGZus{}D0: /* full On */
/* vref/mid, clk and osc on, active */

SNDRV\PYGZus{}CTL\PYGZus{}POWER\PYGZus{}D1: /* partial On */
SNDRV\PYGZus{}CTL\PYGZus{}POWER\PYGZus{}D2: /* partial On */

SNDRV\PYGZus{}CTL\PYGZus{}POWER\PYGZus{}D3hot: /* Off, with power */
/* everything off except vref/vmid, inactive */

SNDRV\PYGZus{}CTL\PYGZus{}POWER\PYGZus{}D3cold: /* Everything Off, without power */
\end{Verbatim}


\subsubsection{Codec DAC digital mute control}
\label{sound/soc/codec:codec-dac-digital-mute-control}
Most codecs have a digital mute before the DACs that can be used to
minimise any system noise.  The mute stops any digital data from
entering the DAC.

A callback can be created that is called by the core for each codec DAI
when the mute is applied or freed.

i.e.

\begin{Verbatim}[commandchars=\\\{\}]
static int wm8974\PYGZus{}mute(struct snd\PYGZus{}soc\PYGZus{}dai *dai, int mute)
\PYGZob{}
      struct snd\PYGZus{}soc\PYGZus{}codec *codec = dai\PYGZhy{}\PYGZgt{}codec;
      u16 mute\PYGZus{}reg = snd\PYGZus{}soc\PYGZus{}read(codec, WM8974\PYGZus{}DAC) \PYGZam{} 0xffbf;

      if (mute)
              snd\PYGZus{}soc\PYGZus{}write(codec, WM8974\PYGZus{}DAC, mute\PYGZus{}reg \textbar{} 0x40);
      else
              snd\PYGZus{}soc\PYGZus{}write(codec, WM8974\PYGZus{}DAC, mute\PYGZus{}reg);
      return 0;
\PYGZcb{}
\end{Verbatim}


\section{ASoC Digital Audio Interface (DAI)}
\label{sound/soc/dai::doc}\label{sound/soc/dai:asoc-digital-audio-interface-dai}
ASoC currently supports the three main Digital Audio Interfaces (DAI) found on
SoC controllers and portable audio CODECs today, namely AC97, I2S and PCM.


\subsection{AC97}
\label{sound/soc/dai:ac97}
AC97 is a five wire interface commonly found on many PC sound cards. It is
now also popular in many portable devices. This DAI has a reset line and time
multiplexes its data on its SDATA\_OUT (playback) and SDATA\_IN (capture) lines.
The bit clock (BCLK) is always driven by the CODEC (usually 12.288MHz) and the
frame (FRAME) (usually 48kHz) is always driven by the controller. Each AC97
frame is 21uS long and is divided into 13 time slots.

The AC97 specification can be found at :
\href{http://www.intel.com/p/en\_US/business/design}{http://www.intel.com/p/en\_US/business/design}


\subsection{I2S}
\label{sound/soc/dai:i2s}
I2S is a common 4 wire DAI used in HiFi, STB and portable devices. The Tx and
Rx lines are used for audio transmission, whilst the bit clock (BCLK) and
left/right clock (LRC) synchronise the link. I2S is flexible in that either the
controller or CODEC can drive (master) the BCLK and LRC clock lines. Bit clock
usually varies depending on the sample rate and the master system clock
(SYSCLK). LRCLK is the same as the sample rate. A few devices support separate
ADC and DAC LRCLKs, this allows for simultaneous capture and playback at
different sample rates.

I2S has several different operating modes:-
\begin{description}
\item[{I2S}] \leavevmode
MSB is transmitted on the falling edge of the first BCLK after LRC
transition.

\item[{Left Justified}] \leavevmode
MSB is transmitted on transition of LRC.

\item[{Right Justified}] \leavevmode
MSB is transmitted sample size BCLKs before LRC transition.

\end{description}


\subsection{PCM}
\label{sound/soc/dai:pcm}
PCM is another 4 wire interface, very similar to I2S, which can support a more
flexible protocol. It has bit clock (BCLK) and sync (SYNC) lines that are used
to synchronise the link whilst the Tx and Rx lines are used to transmit and
receive the audio data. Bit clock usually varies depending on sample rate
whilst sync runs at the sample rate. PCM also supports Time Division
Multiplexing (TDM) in that several devices can use the bus simultaneously (this
is sometimes referred to as network mode).

Common PCM operating modes:-
\begin{description}
\item[{Mode A}] \leavevmode
MSB is transmitted on falling edge of first BCLK after FRAME/SYNC.

\item[{Mode B}] \leavevmode
MSB is transmitted on rising edge of FRAME/SYNC.

\end{description}


\section{Dynamic Audio Power Management for Portable Devices}
\label{sound/soc/dapm:dynamic-audio-power-management-for-portable-devices}\label{sound/soc/dapm::doc}

\subsection{Description}
\label{sound/soc/dapm:description}
Dynamic Audio Power Management (DAPM) is designed to allow portable
Linux devices to use the minimum amount of power within the audio
subsystem at all times. It is independent of other kernel PM and as
such, can easily co-exist with the other PM systems.

DAPM is also completely transparent to all user space applications as
all power switching is done within the ASoC core. No code changes or
recompiling are required for user space applications. DAPM makes power
switching decisions based upon any audio stream (capture/playback)
activity and audio mixer settings within the device.

DAPM spans the whole machine. It covers power control within the entire
audio subsystem, this includes internal codec power blocks and machine
level power systems.

There are 4 power domains within DAPM
\begin{description}
\item[{Codec bias domain}] \leavevmode
VREF, VMID (core codec and audio power)

Usually controlled at codec probe/remove and suspend/resume, although
can be set at stream time if power is not needed for sidetone, etc.

\item[{Platform/Machine domain}] \leavevmode
physically connected inputs and outputs

Is platform/machine and user action specific, is configured by the
machine driver and responds to asynchronous events e.g when HP
are inserted

\item[{Path domain}] \leavevmode
audio subsystem signal paths

Automatically set when mixer and mux settings are changed by the user.
e.g. alsamixer, amixer.

\item[{Stream domain}] \leavevmode
DACs and ADCs.

Enabled and disabled when stream playback/capture is started and
stopped respectively. e.g. aplay, arecord.

\end{description}

All DAPM power switching decisions are made automatically by consulting an audio
routing map of the whole machine. This map is specific to each machine and
consists of the interconnections between every audio component (including
internal codec components). All audio components that effect power are called
widgets hereafter.


\subsection{DAPM Widgets}
\label{sound/soc/dapm:dapm-widgets}
Audio DAPM widgets fall into a number of types:-
\begin{description}
\item[{Mixer}] \leavevmode
Mixes several analog signals into a single analog signal.

\item[{Mux}] \leavevmode
An analog switch that outputs only one of many inputs.

\item[{PGA}] \leavevmode
A programmable gain amplifier or attenuation widget.

\item[{ADC}] \leavevmode
Analog to Digital Converter

\item[{DAC}] \leavevmode
Digital to Analog Converter

\item[{Switch}] \leavevmode
An analog switch

\item[{Input}] \leavevmode
A codec input pin

\item[{Output}] \leavevmode
A codec output pin

\item[{Headphone}] \leavevmode
Headphone (and optional Jack)

\item[{Mic}] \leavevmode
Mic (and optional Jack)

\item[{Line}] \leavevmode
Line Input/Output (and optional Jack)

\item[{Speaker}] \leavevmode
Speaker

\item[{Supply}] \leavevmode
Power or clock supply widget used by other widgets.

\item[{Regulator}] \leavevmode
External regulator that supplies power to audio components.

\item[{Clock}] \leavevmode
External clock that supplies clock to audio components.

\item[{AIF IN}] \leavevmode
Audio Interface Input (with TDM slot mask).

\item[{AIF OUT}] \leavevmode
Audio Interface Output (with TDM slot mask).

\item[{Siggen}] \leavevmode
Signal Generator.

\item[{DAI IN}] \leavevmode
Digital Audio Interface Input.

\item[{DAI OUT}] \leavevmode
Digital Audio Interface Output.

\item[{DAI Link}] \leavevmode
DAI Link between two DAI structures

\item[{Pre}] \leavevmode
Special PRE widget (exec before all others)

\item[{Post}] \leavevmode
Special POST widget (exec after all others)

\item[{Buffer}] \leavevmode
Inter widget audio data buffer within a DSP.

\item[{Scheduler}] \leavevmode
DSP internal scheduler that schedules component/pipeline processing
work.

\item[{Effect}] \leavevmode
Widget that performs an audio processing effect.

\item[{SRC}] \leavevmode
Sample Rate Converter within DSP or CODEC

\item[{ASRC}] \leavevmode
Asynchronous Sample Rate Converter within DSP or CODEC

\item[{Encoder}] \leavevmode
Widget that encodes audio data from one format (usually PCM) to another
usually more compressed format.

\item[{Decoder}] \leavevmode
Widget that decodes audio data from a compressed format to an
uncompressed format like PCM.

\end{description}

(Widgets are defined in include/sound/soc-dapm.h)

Widgets can be added to the sound card by any of the component driver types.
There are convenience macros defined in soc-dapm.h that can be used to quickly
build a list of widgets of the codecs and machines DAPM widgets.

Most widgets have a name, register, shift and invert. Some widgets have extra
parameters for stream name and kcontrols.


\subsubsection{Stream Domain Widgets}
\label{sound/soc/dapm:stream-domain-widgets}
Stream Widgets relate to the stream power domain and only consist of ADCs
(analog to digital converters), DACs (digital to analog converters),
AIF IN and AIF OUT.

Stream widgets have the following format:-

\begin{Verbatim}[commandchars=\\\{\}]
SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}DAC(name, stream name, reg, shift, invert),
SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}AIF\PYGZus{}IN(name, stream, slot, reg, shift, invert)
\end{Verbatim}

NOTE: the stream name must match the corresponding stream name in your codec
snd\_soc\_codec\_dai.

e.g. stream widgets for HiFi playback and capture

\begin{Verbatim}[commandchars=\\\{\}]
SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}DAC(\PYGZdq{}HiFi DAC\PYGZdq{}, \PYGZdq{}HiFi Playback\PYGZdq{}, REG, 3, 1),
SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}ADC(\PYGZdq{}HiFi ADC\PYGZdq{}, \PYGZdq{}HiFi Capture\PYGZdq{}, REG, 2, 1),
\end{Verbatim}

e.g. stream widgets for AIF

\begin{Verbatim}[commandchars=\\\{\}]
SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}AIF\PYGZus{}IN(\PYGZdq{}AIF1RX\PYGZdq{}, \PYGZdq{}AIF1 Playback\PYGZdq{}, 0, SND\PYGZus{}SOC\PYGZus{}NOPM, 0, 0),
SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}AIF\PYGZus{}OUT(\PYGZdq{}AIF1TX\PYGZdq{}, \PYGZdq{}AIF1 Capture\PYGZdq{}, 0, SND\PYGZus{}SOC\PYGZus{}NOPM, 0, 0),
\end{Verbatim}


\subsubsection{Path Domain Widgets}
\label{sound/soc/dapm:path-domain-widgets}
Path domain widgets have a ability to control or affect the audio signal or
audio paths within the audio subsystem. They have the following form:-

\begin{Verbatim}[commandchars=\\\{\}]
SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}PGA(name, reg, shift, invert, controls, num\PYGZus{}controls)
\end{Verbatim}

Any widget kcontrols can be set using the controls and num\_controls members.

e.g. Mixer widget (the kcontrols are declared first)

\begin{Verbatim}[commandchars=\\\{\}]
/* Output Mixer */
static const snd\PYGZus{}kcontrol\PYGZus{}new\PYGZus{}t wm8731\PYGZus{}output\PYGZus{}mixer\PYGZus{}controls[] = \PYGZob{}
SOC\PYGZus{}DAPM\PYGZus{}SINGLE(\PYGZdq{}Line Bypass Switch\PYGZdq{}, WM8731\PYGZus{}APANA, 3, 1, 0),
SOC\PYGZus{}DAPM\PYGZus{}SINGLE(\PYGZdq{}Mic Sidetone Switch\PYGZdq{}, WM8731\PYGZus{}APANA, 5, 1, 0),
SOC\PYGZus{}DAPM\PYGZus{}SINGLE(\PYGZdq{}HiFi Playback Switch\PYGZdq{}, WM8731\PYGZus{}APANA, 4, 1, 0),
\PYGZcb{};

SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}MIXER(\PYGZdq{}Output Mixer\PYGZdq{}, WM8731\PYGZus{}PWR, 4, 1, wm8731\PYGZus{}output\PYGZus{}mixer\PYGZus{}controls,
      ARRAY\PYGZus{}SIZE(wm8731\PYGZus{}output\PYGZus{}mixer\PYGZus{}controls)),
\end{Verbatim}

If you don't want the mixer elements prefixed with the name of the mixer widget,
you can use SND\_SOC\_DAPM\_MIXER\_NAMED\_CTL instead. the parameters are the same
as for SND\_SOC\_DAPM\_MIXER.


\subsubsection{Machine domain Widgets}
\label{sound/soc/dapm:machine-domain-widgets}
Machine widgets are different from codec widgets in that they don't have a
codec register bit associated with them. A machine widget is assigned to each
machine audio component (non codec or DSP) that can be independently
powered. e.g.
\begin{itemize}
\item {} 
Speaker Amp

\item {} 
Microphone Bias

\item {} 
Jack connectors

\end{itemize}

A machine widget can have an optional call back.

e.g. Jack connector widget for an external Mic that enables Mic Bias
when the Mic is inserted:-:

\begin{Verbatim}[commandchars=\\\{\}]
static int spitz\PYGZus{}mic\PYGZus{}bias(struct snd\PYGZus{}soc\PYGZus{}dapm\PYGZus{}widget* w, int event)
\PYGZob{}
      gpio\PYGZus{}set\PYGZus{}value(SPITZ\PYGZus{}GPIO\PYGZus{}MIC\PYGZus{}BIAS, SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}EVENT\PYGZus{}ON(event));
      return 0;
\PYGZcb{}

SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}MIC(\PYGZdq{}Mic Jack\PYGZdq{}, spitz\PYGZus{}mic\PYGZus{}bias),
\end{Verbatim}


\subsubsection{Codec (BIAS) Domain}
\label{sound/soc/dapm:codec-bias-domain}
The codec bias power domain has no widgets and is handled by the codecs DAPM
event handler. This handler is called when the codec powerstate is changed wrt
to any stream event or by kernel PM events.


\subsubsection{Virtual Widgets}
\label{sound/soc/dapm:virtual-widgets}
Sometimes widgets exist in the codec or machine audio map that don't have any
corresponding soft power control. In this case it is necessary to create
a virtual widget - a widget with no control bits e.g.

\begin{Verbatim}[commandchars=\\\{\}]
SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}MIXER(\PYGZdq{}AC97 Mixer\PYGZdq{}, SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}NOPM, 0, 0, NULL, 0),
\end{Verbatim}

This can be used to merge to signal paths together in software.

After all the widgets have been defined, they can then be added to the DAPM
subsystem individually with a call to snd\_soc\_dapm\_new\_control().


\subsection{Codec/DSP Widget Interconnections}
\label{sound/soc/dapm:codec-dsp-widget-interconnections}
Widgets are connected to each other within the codec, platform and machine by
audio paths (called interconnections). Each interconnection must be defined in
order to create a map of all audio paths between widgets.

This is easiest with a diagram of the codec or DSP (and schematic of the machine
audio system), as it requires joining widgets together via their audio signal
paths.

e.g., from the WM8731 output mixer (wm8731.c)

The WM8731 output mixer has 3 inputs (sources)
\begin{enumerate}
\item {} 
Line Bypass Input

\item {} 
DAC (HiFi playback)

\item {} 
Mic Sidetone Input

\end{enumerate}

Each input in this example has a kcontrol associated with it (defined in example
above) and is connected to the output mixer via its kcontrol name. We can now
connect the destination widget (wrt audio signal) with its source widgets.

\begin{Verbatim}[commandchars=\\\{\}]
/* output mixer */
\PYGZob{}\PYGZdq{}Output Mixer\PYGZdq{}, \PYGZdq{}Line Bypass Switch\PYGZdq{}, \PYGZdq{}Line Input\PYGZdq{}\PYGZcb{},
\PYGZob{}\PYGZdq{}Output Mixer\PYGZdq{}, \PYGZdq{}HiFi Playback Switch\PYGZdq{}, \PYGZdq{}DAC\PYGZdq{}\PYGZcb{},
\PYGZob{}\PYGZdq{}Output Mixer\PYGZdq{}, \PYGZdq{}Mic Sidetone Switch\PYGZdq{}, \PYGZdq{}Mic Bias\PYGZdq{}\PYGZcb{},
\end{Verbatim}

So we have :-
\begin{itemize}
\item {} 
Destination Widget  \textless{}=== Path Name \textless{}=== Source Widget, or

\item {} 
Sink, Path, Source, or

\item {} 
\code{Output Mixer} is connected to the \code{DAC} via the \code{HiFi Playback Switch}.

\end{itemize}

When there is no path name connecting widgets (e.g. a direct connection) we
pass NULL for the path name.

Interconnections are created with a call to:-

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}soc\PYGZus{}dapm\PYGZus{}connect\PYGZus{}input(codec, sink, path, source);
\end{Verbatim}

Finally, snd\_soc\_dapm\_new\_widgets(codec) must be called after all widgets and
interconnections have been registered with the core. This causes the core to
scan the codec and machine so that the internal DAPM state matches the
physical state of the machine.


\subsubsection{Machine Widget Interconnections}
\label{sound/soc/dapm:machine-widget-interconnections}
Machine widget interconnections are created in the same way as codec ones and
directly connect the codec pins to machine level widgets.

e.g. connects the speaker out codec pins to the internal speaker.

\begin{Verbatim}[commandchars=\\\{\}]
/* ext speaker connected to codec pins LOUT2, ROUT2  */
\PYGZob{}\PYGZdq{}Ext Spk\PYGZdq{}, NULL , \PYGZdq{}ROUT2\PYGZdq{}\PYGZcb{},
\PYGZob{}\PYGZdq{}Ext Spk\PYGZdq{}, NULL , \PYGZdq{}LOUT2\PYGZdq{}\PYGZcb{},
\end{Verbatim}

This allows the DAPM to power on and off pins that are connected (and in use)
and pins that are NC respectively.


\subsection{Endpoint Widgets}
\label{sound/soc/dapm:endpoint-widgets}
An endpoint is a start or end point (widget) of an audio signal within the
machine and includes the codec. e.g.
\begin{itemize}
\item {} 
Headphone Jack

\item {} 
Internal Speaker

\item {} 
Internal Mic

\item {} 
Mic Jack

\item {} 
Codec Pins

\end{itemize}

Endpoints are added to the DAPM graph so that their usage can be determined in
order to save power. e.g. NC codecs pins will be switched OFF, unconnected
jacks can also be switched OFF.


\subsection{DAPM Widget Events}
\label{sound/soc/dapm:dapm-widget-events}
Some widgets can register their interest with the DAPM core in PM events.
e.g. A Speaker with an amplifier registers a widget so the amplifier can be
powered only when the spk is in use.

\begin{Verbatim}[commandchars=\\\{\}]
/* turn speaker amplifier on/off depending on use */
static int corgi\PYGZus{}amp\PYGZus{}event(struct snd\PYGZus{}soc\PYGZus{}dapm\PYGZus{}widget *w, int event)
\PYGZob{}
      gpio\PYGZus{}set\PYGZus{}value(CORGI\PYGZus{}GPIO\PYGZus{}APM\PYGZus{}ON, SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}EVENT\PYGZus{}ON(event));
      return 0;
\PYGZcb{}

/* corgi machine dapm widgets */
static const struct snd\PYGZus{}soc\PYGZus{}dapm\PYGZus{}widget wm8731\PYGZus{}dapm\PYGZus{}widgets =
      SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}SPK(\PYGZdq{}Ext Spk\PYGZdq{}, corgi\PYGZus{}amp\PYGZus{}event);
\end{Verbatim}

Please see soc-dapm.h for all other widgets that support events.


\subsubsection{Event types}
\label{sound/soc/dapm:event-types}
The following event types are supported by event widgets.

\begin{Verbatim}[commandchars=\\\{\}]
/* dapm event types */
\PYGZsh{}define SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}PRE\PYGZus{}PMU  0x1     /* before widget power up */
\PYGZsh{}define SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}POST\PYGZus{}PMU 0x2             /* after widget power up */
\PYGZsh{}define SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}PRE\PYGZus{}PMD  0x4     /* before widget power down */
\PYGZsh{}define SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}POST\PYGZus{}PMD 0x8             /* after widget power down */
\PYGZsh{}define SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}PRE\PYGZus{}REG  0x10    /* before audio path setup */
\PYGZsh{}define SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}POST\PYGZus{}REG 0x20    /* after audio path setup */
\end{Verbatim}


\section{ASoC Platform Driver}
\label{sound/soc/platform:asoc-platform-driver}\label{sound/soc/platform::doc}
An ASoC platform driver class can be divided into audio DMA drivers, SoC DAI
drivers and DSP drivers. The platform drivers only target the SoC CPU and must
have no board specific code.


\subsection{Audio DMA}
\label{sound/soc/platform:audio-dma}
The platform DMA driver optionally supports the following ALSA operations:-

\begin{Verbatim}[commandchars=\\\{\}]
/* SoC audio ops */
struct snd\PYGZus{}soc\PYGZus{}ops \PYGZob{}
      int (*startup)(struct snd\PYGZus{}pcm\PYGZus{}substream *);
      void (*shutdown)(struct snd\PYGZus{}pcm\PYGZus{}substream *);
      int (*hw\PYGZus{}params)(struct snd\PYGZus{}pcm\PYGZus{}substream *, struct snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}params *);
      int (*hw\PYGZus{}free)(struct snd\PYGZus{}pcm\PYGZus{}substream *);
      int (*prepare)(struct snd\PYGZus{}pcm\PYGZus{}substream *);
      int (*trigger)(struct snd\PYGZus{}pcm\PYGZus{}substream *, int);
\PYGZcb{};
\end{Verbatim}

The platform driver exports its DMA functionality via struct
snd\_soc\_platform\_driver:-

\begin{Verbatim}[commandchars=\\\{\}]
struct snd\PYGZus{}soc\PYGZus{}platform\PYGZus{}driver \PYGZob{}
      char *name;

      int (*probe)(struct platform\PYGZus{}device *pdev);
      int (*remove)(struct platform\PYGZus{}device *pdev);
      int (*suspend)(struct platform\PYGZus{}device *pdev, struct snd\PYGZus{}soc\PYGZus{}cpu\PYGZus{}dai *cpu\PYGZus{}dai);
      int (*resume)(struct platform\PYGZus{}device *pdev, struct snd\PYGZus{}soc\PYGZus{}cpu\PYGZus{}dai *cpu\PYGZus{}dai);

      /* pcm creation and destruction */
      int (*pcm\PYGZus{}new)(struct snd\PYGZus{}card *, struct snd\PYGZus{}soc\PYGZus{}codec\PYGZus{}dai *, struct snd\PYGZus{}pcm *);
      void (*pcm\PYGZus{}free)(struct snd\PYGZus{}pcm *);

      /*
       * For platform caused delay reporting.
       * Optional.
       */
      snd\PYGZus{}pcm\PYGZus{}sframes\PYGZus{}t (*delay)(struct snd\PYGZus{}pcm\PYGZus{}substream *,
              struct snd\PYGZus{}soc\PYGZus{}dai *);

      /* platform stream ops */
      struct snd\PYGZus{}pcm\PYGZus{}ops *pcm\PYGZus{}ops;
\PYGZcb{};
\end{Verbatim}

Please refer to the ALSA driver documentation for details of audio DMA.
\href{http://www.alsa-project.org/~iwai/writing-an-alsa-driver/}{http://www.alsa-project.org/\textasciitilde{}iwai/writing-an-alsa-driver/}

An example DMA driver is soc/pxa/pxa2xx-pcm.c


\subsection{SoC DAI Drivers}
\label{sound/soc/platform:soc-dai-drivers}
Each SoC DAI driver must provide the following features:-
\begin{enumerate}
\item {} 
Digital audio interface (DAI) description

\item {} 
Digital audio interface configuration

\item {} 
PCM's description

\item {} 
SYSCLK configuration

\item {} 
Suspend and resume (optional)

\end{enumerate}

Please see codec.txt for a description of items 1 - 4.


\subsection{SoC DSP Drivers}
\label{sound/soc/platform:soc-dsp-drivers}
Each SoC DSP driver usually supplies the following features :-
\begin{enumerate}
\item {} 
DAPM graph

\item {} 
Mixer controls

\item {} 
DMA IO to/from DSP buffers (if applicable)

\item {} 
Definition of DSP front end (FE) PCM devices.

\end{enumerate}

Please see DPCM.txt for a description of item 4.


\section{ASoC Machine Driver}
\label{sound/soc/machine:asoc-machine-driver}\label{sound/soc/machine::doc}
The ASoC machine (or board) driver is the code that glues together all the
component drivers (e.g. codecs, platforms and DAIs). It also describes the
relationships between each component which include audio paths, GPIOs,
interrupts, clocking, jacks and voltage regulators.

The machine driver can contain codec and platform specific code. It registers
the audio subsystem with the kernel as a platform device and is represented by
the following struct:-

\begin{Verbatim}[commandchars=\\\{\}]
/* SoC machine */
struct snd\PYGZus{}soc\PYGZus{}card \PYGZob{}
      char *name;

      ...

      int (*probe)(struct platform\PYGZus{}device *pdev);
      int (*remove)(struct platform\PYGZus{}device *pdev);

      /* the pre and post PM functions are used to do any PM work before and
       * after the codec and DAIs do any PM work. */
      int (*suspend\PYGZus{}pre)(struct platform\PYGZus{}device *pdev, pm\PYGZus{}message\PYGZus{}t state);
      int (*suspend\PYGZus{}post)(struct platform\PYGZus{}device *pdev, pm\PYGZus{}message\PYGZus{}t state);
      int (*resume\PYGZus{}pre)(struct platform\PYGZus{}device *pdev);
      int (*resume\PYGZus{}post)(struct platform\PYGZus{}device *pdev);

      ...

      /* CPU \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Codec DAI links  */
      struct snd\PYGZus{}soc\PYGZus{}dai\PYGZus{}link *dai\PYGZus{}link;
      int num\PYGZus{}links;

      ...
\PYGZcb{};
\end{Verbatim}


\subsection{probe()/remove()}
\label{sound/soc/machine:probe-remove}
probe/remove are optional. Do any machine specific probe here.


\subsection{suspend()/resume()}
\label{sound/soc/machine:suspend-resume}
The machine driver has pre and post versions of suspend and resume to take care
of any machine audio tasks that have to be done before or after the codec, DAIs
and DMA is suspended and resumed. Optional.


\subsection{Machine DAI Configuration}
\label{sound/soc/machine:machine-dai-configuration}
The machine DAI configuration glues all the codec and CPU DAIs together. It can
also be used to set up the DAI system clock and for any machine related DAI
initialisation e.g. the machine audio map can be connected to the codec audio
map, unconnected codec pins can be set as such.

struct snd\_soc\_dai\_link is used to set up each DAI in your machine. e.g.

\begin{Verbatim}[commandchars=\\\{\}]
/* corgi digital audio interface glue \PYGZhy{} connects codec \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZgt{} CPU */
static struct snd\PYGZus{}soc\PYGZus{}dai\PYGZus{}link corgi\PYGZus{}dai = \PYGZob{}
      .name = \PYGZdq{}WM8731\PYGZdq{},
      .stream\PYGZus{}name = \PYGZdq{}WM8731\PYGZdq{},
      .cpu\PYGZus{}dai\PYGZus{}name = \PYGZdq{}pxa\PYGZhy{}is2\PYGZhy{}dai\PYGZdq{},
      .codec\PYGZus{}dai\PYGZus{}name = \PYGZdq{}wm8731\PYGZhy{}hifi\PYGZdq{},
      .platform\PYGZus{}name = \PYGZdq{}pxa\PYGZhy{}pcm\PYGZhy{}audio\PYGZdq{},
      .codec\PYGZus{}name = \PYGZdq{}wm8713\PYGZhy{}codec.0\PYGZhy{}001a\PYGZdq{},
      .init = corgi\PYGZus{}wm8731\PYGZus{}init,
      .ops = \PYGZam{}corgi\PYGZus{}ops,
\PYGZcb{};
\end{Verbatim}

struct snd\_soc\_card then sets up the machine with its DAIs. e.g.

\begin{Verbatim}[commandchars=\\\{\}]
/* corgi audio machine driver */
static struct snd\PYGZus{}soc\PYGZus{}card snd\PYGZus{}soc\PYGZus{}corgi = \PYGZob{}
      .name = \PYGZdq{}Corgi\PYGZdq{},
      .dai\PYGZus{}link = \PYGZam{}corgi\PYGZus{}dai,
      .num\PYGZus{}links = 1,
\PYGZcb{};
\end{Verbatim}


\subsection{Machine Power Map}
\label{sound/soc/machine:machine-power-map}
The machine driver can optionally extend the codec power map and to become an
audio power map of the audio subsystem. This allows for automatic power up/down
of speaker/HP amplifiers, etc. Codec pins can be connected to the machines jack
sockets in the machine init function.


\subsection{Machine Controls}
\label{sound/soc/machine:machine-controls}
Machine specific audio mixer controls can be added in the DAI init function.


\section{Audio Pops and Clicks}
\label{sound/soc/pops-clicks::doc}\label{sound/soc/pops-clicks:audio-pops-and-clicks}
Pops and clicks are unwanted audio artifacts caused by the powering up and down
of components within the audio subsystem. This is noticeable on PCs when an
audio module is either loaded or unloaded (at module load time the sound card is
powered up and causes a popping noise on the speakers).

Pops and clicks can be more frequent on portable systems with DAPM. This is
because the components within the subsystem are being dynamically powered
depending on the audio usage and this can subsequently cause a small pop or
click every time a component power state is changed.


\subsection{Minimising Playback Pops and Clicks}
\label{sound/soc/pops-clicks:minimising-playback-pops-and-clicks}
Playback pops in portable audio subsystems cannot be completely eliminated
currently, however future audio codec hardware will have better pop and click
suppression.  Pops can be reduced within playback by powering the audio
components in a specific order. This order is different for startup and
shutdown and follows some basic rules:-

\begin{Verbatim}[commandchars=\\\{\}]
Startup Order :\PYGZhy{} DAC \PYGZhy{}\PYGZhy{}\PYGZgt{} Mixers \PYGZhy{}\PYGZhy{}\PYGZgt{} Output PGA \PYGZhy{}\PYGZhy{}\PYGZgt{} Digital Unmute

Shutdown Order :\PYGZhy{} Digital Mute \PYGZhy{}\PYGZhy{}\PYGZgt{} Output PGA \PYGZhy{}\PYGZhy{}\PYGZgt{} Mixers \PYGZhy{}\PYGZhy{}\PYGZgt{} DAC
\end{Verbatim}

This assumes that the codec PCM output path from the DAC is via a mixer and then
a PGA (programmable gain amplifier) before being output to the speakers.


\subsection{Minimising Capture Pops and Clicks}
\label{sound/soc/pops-clicks:minimising-capture-pops-and-clicks}
Capture artifacts are somewhat easier to get rid as we can delay activating the
ADC until all the pops have occurred. This follows similar power rules to
playback in that components are powered in a sequence depending upon stream
startup or shutdown.

\begin{Verbatim}[commandchars=\\\{\}]
Startup Order \PYGZhy{} Input PGA \PYGZhy{}\PYGZhy{}\PYGZgt{} Mixers \PYGZhy{}\PYGZhy{}\PYGZgt{} ADC

Shutdown Order \PYGZhy{} ADC \PYGZhy{}\PYGZhy{}\PYGZgt{} Mixers \PYGZhy{}\PYGZhy{}\PYGZgt{} Input PGA
\end{Verbatim}


\subsection{Zipper Noise}
\label{sound/soc/pops-clicks:zipper-noise}
An unwanted zipper noise can occur within the audio playback or capture stream
when a volume control is changed near its maximum gain value. The zipper noise
is heard when the gain increase or decrease changes the mean audio signal
amplitude too quickly. It can be minimised by enabling the zero cross setting
for each volume control. The ZC forces the gain change to occur when the signal
crosses the zero amplitude line.


\section{Audio Clocking}
\label{sound/soc/clocking::doc}\label{sound/soc/clocking:audio-clocking}
This text describes the audio clocking terms in ASoC and digital audio in
general. Note: Audio clocking can be complex!


\subsection{Master Clock}
\label{sound/soc/clocking:master-clock}
Every audio subsystem is driven by a master clock (sometimes referred to as MCLK
or SYSCLK). This audio master clock can be derived from a number of sources
(e.g. crystal, PLL, CPU clock) and is responsible for producing the correct
audio playback and capture sample rates.

Some master clocks (e.g. PLLs and CPU based clocks) are configurable in that
their speed can be altered by software (depending on the system use and to save
power). Other master clocks are fixed at a set frequency (i.e. crystals).


\subsection{DAI Clocks}
\label{sound/soc/clocking:dai-clocks}
The Digital Audio Interface is usually driven by a Bit Clock (often referred to
as BCLK). This clock is used to drive the digital audio data across the link
between the codec and CPU.

The DAI also has a frame clock to signal the start of each audio frame. This
clock is sometimes referred to as LRC (left right clock) or FRAME. This clock
runs at exactly the sample rate (LRC = Rate).

Bit Clock can be generated as follows:-
\begin{itemize}
\item {} 
BCLK = MCLK / x, or

\item {} 
BCLK = LRC * x, or

\item {} 
BCLK = LRC * Channels * Word Size

\end{itemize}

This relationship depends on the codec or SoC CPU in particular. In general
it is best to configure BCLK to the lowest possible speed (depending on your
rate, number of channels and word size) to save on power.

It is also desirable to use the codec (if possible) to drive (or master) the
audio clocks as it usually gives more accurate sample rates than the CPU.


\section{ASoC jack detection}
\label{sound/soc/jack::doc}\label{sound/soc/jack:asoc-jack-detection}
ALSA has a standard API for representing physical jacks to user space,
the kernel side of which can be seen in include/sound/jack.h.  ASoC
provides a version of this API adding two additional features:
\begin{itemize}
\item {} 
It allows more than one jack detection method to work together on one
user visible jack.  In embedded systems it is common for multiple
to be present on a single jack but handled by separate bits of
hardware.

\item {} 
Integration with DAPM, allowing DAPM endpoints to be updated
automatically based on the detected jack status (eg, turning off the
headphone outputs if no headphones are present).

\end{itemize}

This is done by splitting the jacks up into three things working
together: the jack itself represented by a struct snd\_soc\_jack, sets of
snd\_soc\_jack\_pins representing DAPM endpoints to update and blocks of
code providing jack reporting mechanisms.

For example, a system may have a stereo headset jack with two reporting
mechanisms, one for the headphone and one for the microphone.  Some
systems won't be able to use their speaker output while a headphone is
connected and so will want to make sure to update both speaker and
headphone when the headphone jack status changes.


\subsection{The jack - struct snd\_soc\_jack}
\label{sound/soc/jack:the-jack-struct-snd-soc-jack}
This represents a physical jack on the system and is what is visible to
user space.  The jack itself is completely passive, it is set up by the
machine driver and updated by jack detection methods.

Jacks are created by the machine driver calling snd\_soc\_jack\_new().


\subsection{snd\_soc\_jack\_pin}
\label{sound/soc/jack:snd-soc-jack-pin}
These represent a DAPM pin to update depending on some of the status
bits supported by the jack.  Each snd\_soc\_jack has zero or more of these
which are updated automatically.  They are created by the machine driver
and associated with the jack using snd\_soc\_jack\_add\_pins().  The status
of the endpoint may configured to be the opposite of the jack status if
required (eg, enabling a built in microphone if a microphone is not
connected via a jack).


\subsection{Jack detection methods}
\label{sound/soc/jack:jack-detection-methods}
Actual jack detection is done by code which is able to monitor some
input to the system and update a jack by calling snd\_soc\_jack\_report(),
specifying a subset of bits to update.  The jack detection code should
be set up by the machine driver, taking configuration for the jack to
update and the set of things to report when the jack is connected.

Often this is done based on the status of a GPIO - a handler for this is
provided by the snd\_soc\_jack\_add\_gpio() function.  Other methods are
also available, for example integrated into CODECs.  One example of
CODEC integrated jack detection can be see in the WM8350 driver.

Each jack may have multiple reporting mechanisms, though it will need at
least one to be useful.


\subsection{Machine drivers}
\label{sound/soc/jack:machine-drivers}
These are all hooked together by the machine driver depending on the
system hardware.  The machine driver will set up the snd\_soc\_jack and
the list of pins to update then set up one or more jack detection
mechanisms to update that jack based on their current status.


\section{Dynamic PCM}
\label{sound/soc/dpcm:dynamic-pcm}\label{sound/soc/dpcm::doc}

\subsection{Description}
\label{sound/soc/dpcm:description}
Dynamic PCM allows an ALSA PCM device to digitally route its PCM audio to
various digital endpoints during the PCM stream runtime. e.g. PCM0 can route
digital audio to I2S DAI0, I2S DAI1 or PDM DAI2. This is useful for on SoC DSP
drivers that expose several ALSA PCMs and can route to multiple DAIs.

The DPCM runtime routing is determined by the ALSA mixer settings in the same
way as the analog signal is routed in an ASoC codec driver. DPCM uses a DAPM
graph representing the DSP internal audio paths and uses the mixer settings to
determine the patch used by each ALSA PCM.

DPCM re-uses all the existing component codec, platform and DAI drivers without
any modifications.


\subsubsection{Phone Audio System with SoC based DSP}
\label{sound/soc/dpcm:phone-audio-system-with-soc-based-dsp}
Consider the following phone audio subsystem. This will be used in this
document for all examples :-

\begin{Verbatim}[commandchars=\\\{\}]
\textbar{} Front End PCMs    \textbar{}  SoC DSP  \textbar{} Back End DAIs \textbar{} Audio devices \textbar{}

                    *************
PCM0 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI0\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Codec Headset
                    *           *
PCM1 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI1\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Codec Speakers
                    *   DSP     *
PCM2 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI2\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} MODEM
                    *           *
PCM3 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI3\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} BT
                    *           *
                    *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI4\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} DMIC
                    *           *
                    *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI5\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} FM
                    *************
\end{Verbatim}

This diagram shows a simple smart phone audio subsystem. It supports Bluetooth,
FM digital radio, Speakers, Headset Jack, digital microphones and cellular
modem. This sound card exposes 4 DSP front end (FE) ALSA PCM devices and
supports 6 back end (BE) DAIs. Each FE PCM can digitally route audio data to any
of the BE DAIs. The FE PCM devices can also route audio to more than 1 BE DAI.


\subsubsection{Example - DPCM Switching playback from DAI0 to DAI1}
\label{sound/soc/dpcm:example-dpcm-switching-playback-from-dai0-to-dai1}
Audio is being played to the Headset. After a while the user removes the headset
and audio continues playing on the speakers.

Playback on PCM0 to Headset would look like :-

\begin{Verbatim}[commandchars=\\\{\}]
                    *************
PCM0 \PYGZlt{}============\PYGZgt{} *           * \PYGZlt{}====DAI0=====\PYGZgt{} Codec Headset
                    *           *
PCM1 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI1\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Codec Speakers
                    *   DSP     *
PCM2 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI2\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} MODEM
                    *           *
PCM3 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI3\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} BT
                    *           *
                    *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI4\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} DMIC
                    *           *
                    *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI5\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} FM
                    *************
\end{Verbatim}

The headset is removed from the jack by user so the speakers must now be used :-

\begin{Verbatim}[commandchars=\\\{\}]
                    *************
PCM0 \PYGZlt{}============\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI0\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Codec Headset
                    *           *
PCM1 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}====DAI1=====\PYGZgt{} Codec Speakers
                    *   DSP     *
PCM2 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI2\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} MODEM
                    *           *
PCM3 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI3\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} BT
                    *           *
                    *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI4\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} DMIC
                    *           *
                    *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI5\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} FM
                    *************
\end{Verbatim}

The audio driver processes this as follows :-
\begin{enumerate}
\item {} 
Machine driver receives Jack removal event.

\item {} 
Machine driver OR audio HAL disables the Headset path.

\item {} 
DPCM runs the PCM trigger(stop), hw\_free(), shutdown() operations on DAI0
for headset since the path is now disabled.

\item {} 
Machine driver or audio HAL enables the speaker path.

\item {} 
DPCM runs the PCM ops for startup(), hw\_params(), prepapre() and
trigger(start) for DAI1 Speakers since the path is enabled.

\end{enumerate}

In this example, the machine driver or userspace audio HAL can alter the routing
and then DPCM will take care of managing the DAI PCM operations to either bring
the link up or down. Audio playback does not stop during this transition.


\subsection{DPCM machine driver}
\label{sound/soc/dpcm:dpcm-machine-driver}
The DPCM enabled ASoC machine driver is similar to normal machine drivers
except that we also have to :-
\begin{enumerate}
\item {} 
Define the FE and BE DAI links.

\item {} 
Define any FE/BE PCM operations.

\item {} 
Define widget graph connections.

\end{enumerate}


\subsubsection{FE and BE DAI links}
\label{sound/soc/dpcm:fe-and-be-dai-links}
\begin{Verbatim}[commandchars=\\\{\}]
\textbar{} Front End PCMs    \textbar{}  SoC DSP  \textbar{} Back End DAIs \textbar{} Audio devices \textbar{}

                    *************
PCM0 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI0\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Codec Headset
                    *           *
PCM1 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI1\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Codec Speakers
                    *   DSP     *
PCM2 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI2\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} MODEM
                    *           *
PCM3 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI3\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} BT
                    *           *
                    *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI4\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} DMIC
                    *           *
                    *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI5\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} FM
                    *************
\end{Verbatim}

For the example above we have to define 4 FE DAI links and 6 BE DAI links. The
FE DAI links are defined as follows :-

\begin{Verbatim}[commandchars=\\\{\}]
static struct snd\PYGZus{}soc\PYGZus{}dai\PYGZus{}link machine\PYGZus{}dais[] = \PYGZob{}
      \PYGZob{}
              .name = \PYGZdq{}PCM0 System\PYGZdq{},
              .stream\PYGZus{}name = \PYGZdq{}System Playback\PYGZdq{},
              .cpu\PYGZus{}dai\PYGZus{}name = \PYGZdq{}System Pin\PYGZdq{},
              .platform\PYGZus{}name = \PYGZdq{}dsp\PYGZhy{}audio\PYGZdq{},
              .codec\PYGZus{}name = \PYGZdq{}snd\PYGZhy{}soc\PYGZhy{}dummy\PYGZdq{},
              .codec\PYGZus{}dai\PYGZus{}name = \PYGZdq{}snd\PYGZhy{}soc\PYGZhy{}dummy\PYGZhy{}dai\PYGZdq{},
              .dynamic = 1,
              .trigger = \PYGZob{}SND\PYGZus{}SOC\PYGZus{}DPCM\PYGZus{}TRIGGER\PYGZus{}POST, SND\PYGZus{}SOC\PYGZus{}DPCM\PYGZus{}TRIGGER\PYGZus{}POST\PYGZcb{},
              .dpcm\PYGZus{}playback = 1,
      \PYGZcb{},
      .....\PYGZlt{} other FE and BE DAI links here \PYGZgt{}
\PYGZcb{};
\end{Verbatim}

This FE DAI link is pretty similar to a regular DAI link except that we also
set the DAI link to a DPCM FE with the \code{dynamic = 1}. The supported FE stream
directions should also be set with the \code{dpcm\_playback} and \code{dpcm\_capture}
flags. There is also an option to specify the ordering of the trigger call for
each FE. This allows the ASoC core to trigger the DSP before or after the other
components (as some DSPs have strong requirements for the ordering DAI/DSP
start and stop sequences).

The FE DAI above sets the codec and code DAIs to dummy devices since the BE is
dynamic and will change depending on runtime config.

The BE DAIs are configured as follows :-

\begin{Verbatim}[commandchars=\\\{\}]
static struct snd\PYGZus{}soc\PYGZus{}dai\PYGZus{}link machine\PYGZus{}dais[] = \PYGZob{}
      .....\PYGZlt{} FE DAI links here \PYGZgt{}
      \PYGZob{}
              .name = \PYGZdq{}Codec Headset\PYGZdq{},
              .cpu\PYGZus{}dai\PYGZus{}name = \PYGZdq{}ssp\PYGZhy{}dai.0\PYGZdq{},
              .platform\PYGZus{}name = \PYGZdq{}snd\PYGZhy{}soc\PYGZhy{}dummy\PYGZdq{},
              .no\PYGZus{}pcm = 1,
              .codec\PYGZus{}name = \PYGZdq{}rt5640.0\PYGZhy{}001c\PYGZdq{},
              .codec\PYGZus{}dai\PYGZus{}name = \PYGZdq{}rt5640\PYGZhy{}aif1\PYGZdq{},
              .ignore\PYGZus{}suspend = 1,
              .ignore\PYGZus{}pmdown\PYGZus{}time = 1,
              .be\PYGZus{}hw\PYGZus{}params\PYGZus{}fixup = hswult\PYGZus{}ssp0\PYGZus{}fixup,
              .ops = \PYGZam{}haswell\PYGZus{}ops,
              .dpcm\PYGZus{}playback = 1,
              .dpcm\PYGZus{}capture = 1,
      \PYGZcb{},
      .....\PYGZlt{} other BE DAI links here \PYGZgt{}
\PYGZcb{};
\end{Verbatim}

This BE DAI link connects DAI0 to the codec (in this case RT5460 AIF1). It sets
the \code{no\_pcm} flag to mark it has a BE and sets flags for supported stream
directions using \code{dpcm\_playback} and \code{dpcm\_capture} above.

The BE has also flags set for ignoring suspend and PM down time. This allows
the BE to work in a hostless mode where the host CPU is not transferring data
like a BT phone call :-

\begin{Verbatim}[commandchars=\\\{\}]
                    *************
PCM0 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI0\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Codec Headset
                    *           *
PCM1 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI1\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Codec Speakers
                    *   DSP     *
PCM2 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}====DAI2=====\PYGZgt{} MODEM
                    *           *
PCM3 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}====DAI3=====\PYGZgt{} BT
                    *           *
                    *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI4\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} DMIC
                    *           *
                    *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI5\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} FM
                    *************
\end{Verbatim}

This allows the host CPU to sleep whilst the DSP, MODEM DAI and the BT DAI are
still in operation.

A BE DAI link can also set the codec to a dummy device if the code is a device
that is managed externally.

Likewise a BE DAI can also set a dummy cpu DAI if the CPU DAI is managed by the
DSP firmware.


\subsubsection{FE/BE PCM operations}
\label{sound/soc/dpcm:fe-be-pcm-operations}
The BE above also exports some PCM operations and a \code{fixup} callback. The fixup
callback is used by the machine driver to (re)configure the DAI based upon the
FE hw params. i.e. the DSP may perform SRC or ASRC from the FE to BE.

e.g. DSP converts all FE hw params to run at fixed rate of 48k, 16bit, stereo for
DAI0. This means all FE hw\_params have to be fixed in the machine driver for
DAI0 so that the DAI is running at desired configuration regardless of the FE
configuration.

\begin{Verbatim}[commandchars=\\\{\}]
static int dai0\PYGZus{}fixup(struct snd\PYGZus{}soc\PYGZus{}pcm\PYGZus{}runtime *rtd,
                      struct snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}params *params)
\PYGZob{}
      struct snd\PYGZus{}interval *rate = hw\PYGZus{}param\PYGZus{}interval(params,
                      SNDRV\PYGZus{}PCM\PYGZus{}HW\PYGZus{}PARAM\PYGZus{}RATE);
      struct snd\PYGZus{}interval *channels = hw\PYGZus{}param\PYGZus{}interval(params,
                                              SNDRV\PYGZus{}PCM\PYGZus{}HW\PYGZus{}PARAM\PYGZus{}CHANNELS);

      /* The DSP will covert the FE rate to 48k, stereo */
      rate\PYGZhy{}\PYGZgt{}min = rate\PYGZhy{}\PYGZgt{}max = 48000;
      channels\PYGZhy{}\PYGZgt{}min = channels\PYGZhy{}\PYGZgt{}max = 2;

      /* set DAI0 to 16 bit */
      snd\PYGZus{}mask\PYGZus{}set(\PYGZam{}params\PYGZhy{}\PYGZgt{}masks[SNDRV\PYGZus{}PCM\PYGZus{}HW\PYGZus{}PARAM\PYGZus{}FORMAT \PYGZhy{}
                                  SNDRV\PYGZus{}PCM\PYGZus{}HW\PYGZus{}PARAM\PYGZus{}FIRST\PYGZus{}MASK],
                                  SNDRV\PYGZus{}PCM\PYGZus{}FORMAT\PYGZus{}S16\PYGZus{}LE);
      return 0;
\PYGZcb{}
\end{Verbatim}

The other PCM operation are the same as for regular DAI links. Use as necessary.


\subsubsection{Widget graph connections}
\label{sound/soc/dpcm:widget-graph-connections}
The BE DAI links will normally be connected to the graph at initialisation time
by the ASoC DAPM core. However, if the BE codec or BE DAI is a dummy then this
has to be set explicitly in the driver :-

\begin{Verbatim}[commandchars=\\\{\}]
/* BE for codec Headset \PYGZhy{}  DAI0 is dummy and managed by DSP FW */
\PYGZob{}\PYGZdq{}DAI0 CODEC IN\PYGZdq{}, NULL, \PYGZdq{}AIF1 Capture\PYGZdq{}\PYGZcb{},
\PYGZob{}\PYGZdq{}AIF1 Playback\PYGZdq{}, NULL, \PYGZdq{}DAI0 CODEC OUT\PYGZdq{}\PYGZcb{},
\end{Verbatim}


\subsection{Writing a DPCM DSP driver}
\label{sound/soc/dpcm:writing-a-dpcm-dsp-driver}
The DPCM DSP driver looks much like a standard platform class ASoC driver
combined with elements from a codec class driver. A DSP platform driver must
implement :-
\begin{enumerate}
\item {} 
Front End PCM DAIs - i.e. struct snd\_soc\_dai\_driver.

\item {} 
DAPM graph showing DSP audio routing from FE DAIs to BEs.

\item {} 
DAPM widgets from DSP graph.

\item {} 
Mixers for gains, routing, etc.

\item {} 
DMA configuration.

\item {} 
BE AIF widgets.

\end{enumerate}

Items 6 is important for routing the audio outside of the DSP. AIF need to be
defined for each BE and each stream direction. e.g for BE DAI0 above we would
have :-

\begin{Verbatim}[commandchars=\\\{\}]
SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}AIF\PYGZus{}IN(\PYGZdq{}DAI0 RX\PYGZdq{}, NULL, 0, SND\PYGZus{}SOC\PYGZus{}NOPM, 0, 0),
SND\PYGZus{}SOC\PYGZus{}DAPM\PYGZus{}AIF\PYGZus{}OUT(\PYGZdq{}DAI0 TX\PYGZdq{}, NULL, 0, SND\PYGZus{}SOC\PYGZus{}NOPM, 0, 0),
\end{Verbatim}

The BE AIF are used to connect the DSP graph to the graphs for the other
component drivers (e.g. codec graph).


\subsection{Hostless PCM streams}
\label{sound/soc/dpcm:hostless-pcm-streams}
A hostless PCM stream is a stream that is not routed through the host CPU. An
example of this would be a phone call from handset to modem.

\begin{Verbatim}[commandchars=\\\{\}]
                    *************
PCM0 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI0\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} Codec Headset
                    *           *
PCM1 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}====DAI1=====\PYGZgt{} Codec Speakers/Mic
                    *   DSP     *
PCM2 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}====DAI2=====\PYGZgt{} MODEM
                    *           *
PCM3 \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI3\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} BT
                    *           *
                    *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI4\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} DMIC
                    *           *
                    *           * \PYGZlt{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}DAI5\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} FM
                    *************
\end{Verbatim}

In this case the PCM data is routed via the DSP. The host CPU in this use case
is only used for control and can sleep during the runtime of the stream.

The host can control the hostless link either by :-
\begin{enumerate}
\item {} 
Configuring the link as a CODEC \textless{}-\textgreater{} CODEC style link. In this case the link
is enabled or disabled by the state of the DAPM graph. This usually means
there is a mixer control that can be used to connect or disconnect the path
between both DAIs.

\item {} 
Hostless FE. This FE has a virtual connection to the BE DAI links on the DAPM
graph. Control is then carried out by the FE as regular PCM operations.
This method gives more control over the DAI links, but requires much more
userspace code to control the link. Its recommended to use CODEC\textless{}-\textgreater{}CODEC
unless your HW needs more fine grained sequencing of the PCM ops.

\end{enumerate}


\subsubsection{CODEC \textless{}-\textgreater{} CODEC link}
\label{sound/soc/dpcm:codec-codec-link}
This DAI link is enabled when DAPM detects a valid path within the DAPM graph.
The machine driver sets some additional parameters to the DAI link i.e.

\begin{Verbatim}[commandchars=\\\{\}]
static const struct snd\PYGZus{}soc\PYGZus{}pcm\PYGZus{}stream dai\PYGZus{}params = \PYGZob{}
      .formats = SNDRV\PYGZus{}PCM\PYGZus{}FMTBIT\PYGZus{}S32\PYGZus{}LE,
      .rate\PYGZus{}min = 8000,
      .rate\PYGZus{}max = 8000,
      .channels\PYGZus{}min = 2,
      .channels\PYGZus{}max = 2,
\PYGZcb{};

static struct snd\PYGZus{}soc\PYGZus{}dai\PYGZus{}link dais[] = \PYGZob{}
      \PYGZlt{} ... more DAI links above ... \PYGZgt{}
      \PYGZob{}
              .name = \PYGZdq{}MODEM\PYGZdq{},
              .stream\PYGZus{}name = \PYGZdq{}MODEM\PYGZdq{},
              .cpu\PYGZus{}dai\PYGZus{}name = \PYGZdq{}dai2\PYGZdq{},
              .codec\PYGZus{}dai\PYGZus{}name = \PYGZdq{}modem\PYGZhy{}aif1\PYGZdq{},
              .codec\PYGZus{}name = \PYGZdq{}modem\PYGZdq{},
              .dai\PYGZus{}fmt = SND\PYGZus{}SOC\PYGZus{}DAIFMT\PYGZus{}I2S \textbar{} SND\PYGZus{}SOC\PYGZus{}DAIFMT\PYGZus{}NB\PYGZus{}NF
                              \textbar{} SND\PYGZus{}SOC\PYGZus{}DAIFMT\PYGZus{}CBM\PYGZus{}CFM,
              .params = \PYGZam{}dai\PYGZus{}params,
      \PYGZcb{}
      \PYGZlt{} ... more DAI links here ... \PYGZgt{}
\end{Verbatim}

These parameters are used to configure the DAI hw\_params() when DAPM detects a
valid path and then calls the PCM operations to start the link. DAPM will also
call the appropriate PCM operations to disable the DAI when the path is no
longer valid.


\subsubsection{Hostless FE}
\label{sound/soc/dpcm:hostless-fe}
The DAI link(s) are enabled by a FE that does not read or write any PCM data.
This means creating a new FE that is connected with a virtual path to both
DAI links. The DAI links will be started when the FE PCM is started and stopped
when the FE PCM is stopped. Note that the FE PCM cannot read or write data in
this configuration.


\section{Creating codec to codec dai link for ALSA dapm}
\label{sound/soc/codec-to-codec:creating-codec-to-codec-dai-link-for-alsa-dapm}\label{sound/soc/codec-to-codec::doc}
Mostly the flow of audio is always from CPU to codec so your system
will look as below:

\begin{Verbatim}[commandchars=\\\{\}]
 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}          \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\textbar{}         \textbar{}  dai   \textbar{}         \textbar{}
    CPU    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}    codec
\textbar{}         \textbar{}        \textbar{}         \textbar{}
 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}          \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\end{Verbatim}

In case your system looks as below:

\begin{Verbatim}[commandchars=\\\{\}]
                     \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
                    \textbar{}         \textbar{}
                      codec\PYGZhy{}2
                    \textbar{}         \textbar{}
                    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
                         \textbar{}
                       dai\PYGZhy{}2
                         \textbar{}
 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}          \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\textbar{}          \textbar{}  dai\PYGZhy{}1 \textbar{}         \textbar{}
    CPU     \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{}  codec\PYGZhy{}1
\textbar{}          \textbar{}        \textbar{}         \textbar{}
 \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}          \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
                         \textbar{}
                       dai\PYGZhy{}3
                         \textbar{}
                     \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
                    \textbar{}         \textbar{}
                      codec\PYGZhy{}3
                    \textbar{}         \textbar{}
                     \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\end{Verbatim}

Suppose codec-2 is a bluetooth chip and codec-3 is connected to
a speaker and you have a below scenario:
codec-2 will receive the audio data and the user wants to play that
audio through codec-3 without involving the CPU.This
aforementioned case is the ideal case when codec to codec
connection should be used.

Your dai\_link should appear as below in your machine
file:

\begin{Verbatim}[commandchars=\\\{\}]
/*
 * this pcm stream only supports 24 bit, 2 channel and
 * 48k sampling rate.
 */
static const struct snd\PYGZus{}soc\PYGZus{}pcm\PYGZus{}stream dsp\PYGZus{}codec\PYGZus{}params = \PYGZob{}
       .formats = SNDRV\PYGZus{}PCM\PYGZus{}FMTBIT\PYGZus{}S24\PYGZus{}LE,
       .rate\PYGZus{}min = 48000,
       .rate\PYGZus{}max = 48000,
       .channels\PYGZus{}min = 2,
       .channels\PYGZus{}max = 2,
\PYGZcb{};

\PYGZob{}
   .name = \PYGZdq{}CPU\PYGZhy{}DSP\PYGZdq{},
   .stream\PYGZus{}name = \PYGZdq{}CPU\PYGZhy{}DSP\PYGZdq{},
   .cpu\PYGZus{}dai\PYGZus{}name = \PYGZdq{}samsung\PYGZhy{}i2s.0\PYGZdq{},
   .codec\PYGZus{}name = \PYGZdq{}codec\PYGZhy{}2,
   .codec\PYGZus{}dai\PYGZus{}name = \PYGZdq{}codec\PYGZhy{}2\PYGZhy{}dai\PYGZus{}name\PYGZdq{},
   .platform\PYGZus{}name = \PYGZdq{}samsung\PYGZhy{}i2s.0\PYGZdq{},
   .dai\PYGZus{}fmt = SND\PYGZus{}SOC\PYGZus{}DAIFMT\PYGZus{}I2S \textbar{} SND\PYGZus{}SOC\PYGZus{}DAIFMT\PYGZus{}NB\PYGZus{}NF
           \textbar{} SND\PYGZus{}SOC\PYGZus{}DAIFMT\PYGZus{}CBM\PYGZus{}CFM,
   .ignore\PYGZus{}suspend = 1,
   .params = \PYGZam{}dsp\PYGZus{}codec\PYGZus{}params,
\PYGZcb{},
\PYGZob{}
   .name = \PYGZdq{}DSP\PYGZhy{}CODEC\PYGZdq{},
   .stream\PYGZus{}name = \PYGZdq{}DSP\PYGZhy{}CODEC\PYGZdq{},
   .cpu\PYGZus{}dai\PYGZus{}name = \PYGZdq{}wm0010\PYGZhy{}sdi2\PYGZdq{},
   .codec\PYGZus{}name = \PYGZdq{}codec\PYGZhy{}3,
   .codec\PYGZus{}dai\PYGZus{}name = \PYGZdq{}codec\PYGZhy{}3\PYGZhy{}dai\PYGZus{}name\PYGZdq{},
   .dai\PYGZus{}fmt = SND\PYGZus{}SOC\PYGZus{}DAIFMT\PYGZus{}I2S \textbar{} SND\PYGZus{}SOC\PYGZus{}DAIFMT\PYGZus{}NB\PYGZus{}NF
           \textbar{} SND\PYGZus{}SOC\PYGZus{}DAIFMT\PYGZus{}CBM\PYGZus{}CFM,
   .ignore\PYGZus{}suspend = 1,
   .params = \PYGZam{}dsp\PYGZus{}codec\PYGZus{}params,
\PYGZcb{},
\end{Verbatim}

Above code snippet is motivated from sound/soc/samsung/speyside.c.

Note the ``params'' callback which lets the dapm know that this
dai\_link is a codec to codec connection.

In dapm core a route is created between cpu\_dai playback widget
and codec\_dai capture widget for playback path and vice-versa is
true for capture path. In order for this aforementioned route to get
triggered, DAPM needs to find a valid endpoint which could be either
a sink or source widget corresponding to playback and capture path
respectively.

In order to trigger this dai\_link widget, a thin codec driver for
the speaker amp can be created as demonstrated in wm8727.c file, it
sets appropriate constraints for the device even if it needs no control.

Make sure to name your corresponding cpu and codec playback and capture
dai names ending with ``Playback'' and ``Capture'' respectively as dapm core
will link and power those dais based on the name.

Note that in current device tree there is no way to mark a dai\_link
as codec to codec. However, it may change in future.


\chapter{Advanced Linux Sound Architecture - Driver Configuration guide}
\label{sound/alsa-configuration:advanced-linux-sound-architecture-driver-configuration-guide}\label{sound/alsa-configuration::doc}

\section{Kernel Configuration}
\label{sound/alsa-configuration:kernel-configuration}
To enable ALSA support you need at least to build the kernel with
primary sound card support (\code{CONFIG\_SOUND}).  Since ALSA can emulate
OSS, you don't have to choose any of the OSS modules.

Enable ``OSS API emulation'' (\code{CONFIG\_SND\_OSSEMUL}) and both OSS mixer
and PCM supports if you want to run OSS applications with ALSA.

If you want to support the WaveTable functionality on cards such as
SB Live! then you need to enable ``Sequencer support''
(\code{CONFIG\_SND\_SEQUENCER}).

To make ALSA debug messages more verbose, enable the ``Verbose printk''
and ``Debug'' options.  To check for memory leaks, turn on ``Debug memory''
too.  ``Debug detection'' will add checks for the detection of cards.

Please note that all the ALSA ISA drivers support the Linux isapnp API
(if the card supports ISA PnP).  You don't need to configure the cards
using isapnptools.


\section{Module parameters}
\label{sound/alsa-configuration:module-parameters}
The user can load modules with options. If the module supports more than
one card and you have more than one card of the same type then you can
specify multiple values for the option separated by commas.


\subsection{Module snd}
\label{sound/alsa-configuration:module-snd}
The core ALSA module.  It is used by all ALSA card drivers.
It takes the following options which have global effects.
\begin{description}
\item[{major}] \leavevmode
major number for sound driver;
Default: 116

\item[{cards\_limit}] \leavevmode
limiting card index for auto-loading (1-8);
Default: 1;
For auto-loading more than one card, specify this option
together with snd-card-X aliases.

\item[{slots}] \leavevmode
Reserve the slot index for the given driver;
This option takes multiple strings.
See {\hyperref[sound/alsa\string-configuration:module\string-autoloading\string-support]{\emph{Module Autoloading Support}}} section for details.

\item[{debug}] \leavevmode
Specifies the debug message level;
(0 = disable debug prints, 1 = normal debug messages,
2 = verbose debug messages);
This option appears only when \code{CONFIG\_SND\_DEBUG=y}.
This option can be dynamically changed via sysfs
/sys/modules/snd/parameters/debug file.

\end{description}


\subsection{Module snd-pcm-oss}
\label{sound/alsa-configuration:module-snd-pcm-oss}
The PCM OSS emulation module.
This module takes options which change the mapping of devices.
\begin{description}
\item[{dsp\_map}] \leavevmode
PCM device number maps assigned to the 1st OSS device;
Default: 0

\item[{adsp\_map}] \leavevmode
PCM device number maps assigned to the 2st OSS device;
Default: 1

\item[{nonblock\_open}] \leavevmode
Don't block opening busy PCM devices;
Default: 1

\end{description}

For example, when \code{dsp\_map=2}, /dev/dsp will be mapped to PCM \#2 of
the card \#0.  Similarly, when \code{adsp\_map=0}, /dev/adsp will be mapped
to PCM \#0 of the card \#0.
For changing the second or later card, specify the option with
commas, such like \code{dsp\_map=0,1}.

\code{nonblock\_open} option is used to change the behavior of the PCM
regarding opening the device.  When this option is non-zero,
opening a busy OSS PCM device won't be blocked but return
immediately with EAGAIN (just like O\_NONBLOCK flag).


\subsection{Module snd-rawmidi}
\label{sound/alsa-configuration:module-snd-rawmidi}
This module takes options which change the mapping of devices.
similar to those of the snd-pcm-oss module.
\begin{description}
\item[{midi\_map}] \leavevmode
MIDI device number maps assigned to the 1st OSS device;
Default: 0

\item[{amidi\_map}] \leavevmode
MIDI device number maps assigned to the 2st OSS device;
Default: 1

\end{description}


\subsection{Common parameters for top sound card modules}
\label{sound/alsa-configuration:common-parameters-for-top-sound-card-modules}
Each of top level sound card module takes the following options.
\begin{description}
\item[{index}] \leavevmode
index (slot \#) of sound card;
Values: 0 through 31 or negative;
If nonnegative, assign that index number;
if negative, interpret as a bitmask of permissible indices;
the first free permitted index is assigned;
Default: -1

\item[{id}] \leavevmode
card ID (identifier or name);
Can be up to 15 characters long;
Default: the card type;
A directory by this name is created under /proc/asound/
containing information about the card;
This ID can be used instead of the index number in
identifying the card

\item[{enable}] \leavevmode
enable card;
Default: enabled, for PCI and ISA PnP cards

\end{description}


\subsection{Module snd-adlib}
\label{sound/alsa-configuration:module-snd-adlib}
Module for AdLib FM cards.
\begin{description}
\item[{port}] \leavevmode
port \# for OPL chip

\end{description}

This module supports multiple cards. It does not support autoprobe, so
the port must be specified. For actual AdLib FM cards it will be 0x388.
Note that this card does not have PCM support and no mixer; only FM
synthesis.

Make sure you have \code{sbiload} from the alsa-tools package available and,
after loading the module, find out the assigned ALSA sequencer port
number through \code{sbiload -l}.

Example output:

\begin{Verbatim}[commandchars=\\\{\}]
Port     Client name                       Port name
64:0     OPL2 FM synth                     OPL2 FM Port
\end{Verbatim}

Load the \code{std.sb} and \code{drums.sb} patches also supplied by \code{sbiload}:

\begin{Verbatim}[commandchars=\\\{\}]
sbiload \PYGZhy{}p 64:0 std.sb drums.sb
\end{Verbatim}

If you use this driver to drive an OPL3, you can use \code{std.o3} and \code{drums.o3}
instead. To have the card produce sound, use \code{aplaymidi} from alsa-utils:

\begin{Verbatim}[commandchars=\\\{\}]
aplaymidi \PYGZhy{}p 64:0 foo.mid
\end{Verbatim}


\subsection{Module snd-ad1816a}
\label{sound/alsa-configuration:module-snd-ad1816a}
Module for sound cards based on Analog Devices AD1816A/AD1815 ISA chips.
\begin{description}
\item[{clockfreq}] \leavevmode
Clock frequency for AD1816A chip (default = 0, 33000Hz)

\end{description}

This module supports multiple cards, autoprobe and PnP.


\subsection{Module snd-ad1848}
\label{sound/alsa-configuration:module-snd-ad1848}
Module for sound cards based on AD1848/AD1847/CS4248 ISA chips.
\begin{description}
\item[{port}] \leavevmode
port \# for AD1848 chip

\item[{irq}] \leavevmode
IRQ \# for AD1848  chip

\item[{dma1}] \leavevmode
DMA \# for AD1848 chip (0,1,3)

\end{description}

This module supports multiple cards.  It does not support autoprobe
thus main port must be specified!!! Other ports are optional.

The power-management is supported.


\subsection{Module snd-ad1889}
\label{sound/alsa-configuration:module-snd-ad1889}
Module for Analog Devices AD1889 chips.
\begin{description}
\item[{ac97\_quirk}] \leavevmode
AC`97 workaround for strange hardware;
See the description of intel8x0 module for details.

\end{description}

This module supports multiple cards.


\subsection{Module snd-ali5451}
\label{sound/alsa-configuration:module-snd-ali5451}
Module for ALi M5451 PCI chip.
\begin{description}
\item[{pcm\_channels}] \leavevmode
Number of hardware channels assigned for PCM

\item[{spdif}] \leavevmode
Support SPDIF I/O;
Default: disabled

\end{description}

This module supports one chip and autoprobe.

The power-management is supported.


\subsection{Module snd-als100}
\label{sound/alsa-configuration:module-snd-als100}
Module for sound cards based on Avance Logic ALS100/ALS120 ISA chips.

This module supports multiple cards, autoprobe and PnP.

The power-management is supported.


\subsection{Module snd-als300}
\label{sound/alsa-configuration:module-snd-als300}
Module for Avance Logic ALS300 and ALS300+

This module supports multiple cards.

The power-management is supported.


\subsection{Module snd-als4000}
\label{sound/alsa-configuration:module-snd-als4000}
Module for sound cards based on Avance Logic ALS4000 PCI chip.
\begin{description}
\item[{joystick\_port}] \leavevmode
port \# for legacy joystick support;
0 = disabled (default), 1 = auto-detect

\end{description}

This module supports multiple cards, autoprobe and PnP.

The power-management is supported.


\subsection{Module snd-asihpi}
\label{sound/alsa-configuration:module-snd-asihpi}
Module for AudioScience ASI soundcards
\begin{description}
\item[{enable\_hpi\_hwdep}] \leavevmode
enable HPI hwdep for AudioScience soundcard

\end{description}

This module supports multiple cards.
The driver requires the firmware loader support on kernel.


\subsection{Module snd-atiixp}
\label{sound/alsa-configuration:module-snd-atiixp}
Module for ATI IXP 150/200/250/400 AC97 controllers.
\begin{description}
\item[{ac97\_clock}] \leavevmode
AC`97 clock (default = 48000)

\item[{ac97\_quirk}] \leavevmode
AC`97 workaround for strange hardware;
See {\hyperref[sound/alsa\string-configuration:ac97\string-quirk\string-option]{\emph{AC97 Quirk Option}}} section below.

\item[{ac97\_codec}] \leavevmode
Workaround to specify which AC`97 codec instead of probing.
If this works for you file a bug with your \emph{lspci -vn} output.
(-2 = Force probing, -1 = Default behavior, 0-2 = Use the
specified codec.)

\item[{spdif\_aclink}] \leavevmode
S/PDIF transfer over AC-link (default = 1)

\end{description}

This module supports one card and autoprobe.

ATI IXP has two different methods to control SPDIF output.  One is
over AC-link and another is over the ``direct'' SPDIF output.  The
implementation depends on the motherboard, and you'll need to
choose the correct one via spdif\_aclink module option.

The power-management is supported.


\subsection{Module snd-atiixp-modem}
\label{sound/alsa-configuration:module-snd-atiixp-modem}
Module for ATI IXP 150/200/250 AC97 modem controllers.

This module supports one card and autoprobe.

Note: The default index value of this module is -2, i.e. the first
slot is excluded.

The power-management is supported.


\subsection{Module snd-au8810, snd-au8820, snd-au8830}
\label{sound/alsa-configuration:module-snd-au8810-snd-au8820-snd-au8830}
Module for Aureal Vortex, Vortex2 and Advantage device.
\begin{description}
\item[{pcifix}] \leavevmode
Control PCI workarounds;
0 = Disable all workarounds,
1 = Force the PCI latency of the Aureal card to 0xff,
2 = Force the Extend PCI\#2 Internal Master for Efficient
Handling of Dummy Requests on the VIA KT133 AGP Bridge,
3 = Force both settings,
255 = Autodetect what is required (default)

\end{description}

This module supports all ADB PCM channels, ac97 mixer, SPDIF, hardware
EQ, mpu401, gameport. A3D and wavetable support are still in development.
Development and reverse engineering work is being coordinated at
\href{http://savannah.nongnu.org/projects/openvortex/}{http://savannah.nongnu.org/projects/openvortex/}
SPDIF output has a copy of the AC97 codec output, unless you use the
\code{spdif} pcm device, which allows raw data passthru.
The hardware EQ hardware and SPDIF is only present in the Vortex2 and
Advantage.

Note: Some ALSA mixer applications don't handle the SPDIF sample rate
control correctly. If you have problems regarding this, try
another ALSA compliant mixer (alsamixer works).


\subsection{Module snd-azt1605}
\label{sound/alsa-configuration:module-snd-azt1605}
Module for Aztech Sound Galaxy soundcards based on the Aztech AZT1605
chipset.
\begin{description}
\item[{port}] \leavevmode
port \# for BASE (0x220,0x240,0x260,0x280)

\item[{wss\_port}] \leavevmode
port \# for WSS (0x530,0x604,0xe80,0xf40)

\item[{irq}] \leavevmode
IRQ \# for WSS (7,9,10,11)

\item[{dma1}] \leavevmode
DMA \# for WSS playback (0,1,3)

\item[{dma2}] \leavevmode
DMA \# for WSS capture (0,1), -1 = disabled (default)

\item[{mpu\_port}] \leavevmode
port \# for MPU-401 UART (0x300,0x330), -1 = disabled (default)

\item[{mpu\_irq}] \leavevmode
IRQ \# for MPU-401 UART (3,5,7,9), -1 = disabled (default)

\item[{fm\_port}] \leavevmode
port \# for OPL3 (0x388), -1 = disabled (default)

\end{description}

This module supports multiple cards. It does not support autoprobe:
\code{port}, \code{wss\_port}, \code{irq} and \code{dma1} have to be specified.
The other values are optional.

\code{port} needs to match the BASE ADDRESS jumper on the card (0x220 or 0x240)
or the value stored in the card's EEPROM for cards that have an EEPROM and
their ``CONFIG MODE'' jumper set to ``EEPROM SETTING''. The other values can
be chosen freely from the options enumerated above.

If \code{dma2} is specified and different from \code{dma1}, the card will operate in
full-duplex mode. When \code{dma1=3}, only \code{dma2=0} is valid and the only way to
enable capture since only channels 0 and 1 are available for capture.

Generic settings are \code{port=0x220 wss\_port=0x530 irq=10 dma1=1 dma2=0
mpu\_port=0x330 mpu\_irq=9 fm\_port=0x388}.

Whatever IRQ and DMA channels you pick, be sure to reserve them for
legacy ISA in your BIOS.


\subsection{Module snd-azt2316}
\label{sound/alsa-configuration:module-snd-azt2316}
Module for Aztech Sound Galaxy soundcards based on the Aztech AZT2316
chipset.
\begin{description}
\item[{port}] \leavevmode
port \# for BASE (0x220,0x240,0x260,0x280)

\item[{wss\_port}] \leavevmode
port \# for WSS (0x530,0x604,0xe80,0xf40)

\item[{irq}] \leavevmode
IRQ \# for WSS (7,9,10,11)

\item[{dma1}] \leavevmode
DMA \# for WSS playback (0,1,3)

\item[{dma2}] \leavevmode
DMA \# for WSS capture (0,1), -1 = disabled (default)

\item[{mpu\_port}] \leavevmode
port \# for MPU-401 UART (0x300,0x330), -1 = disabled (default)

\item[{mpu\_irq}] \leavevmode
IRQ \# for MPU-401 UART (5,7,9,10), -1 = disabled (default)

\item[{fm\_port}] \leavevmode
port \# for OPL3 (0x388), -1 = disabled (default)

\end{description}

This module supports multiple cards. It does not support autoprobe:
\code{port}, \code{wss\_port}, \code{irq} and \code{dma1} have to be specified.
The other values are optional.

\code{port} needs to match the BASE ADDRESS jumper on the card (0x220 or 0x240)
or the value stored in the card's EEPROM for cards that have an EEPROM and
their ``CONFIG MODE'' jumper set to ``EEPROM SETTING''. The other values can
be chosen freely from the options enumerated above.

If \code{dma2} is specified and different from \code{dma1}, the card will operate in
full-duplex mode. When \code{dma1=3}, only \code{dma2=0} is valid and the only way to
enable capture since only channels 0 and 1 are available for capture.

Generic settings are \code{port=0x220 wss\_port=0x530 irq=10 dma1=1 dma2=0
mpu\_port=0x330 mpu\_irq=9 fm\_port=0x388}.

Whatever IRQ and DMA channels you pick, be sure to reserve them for
legacy ISA in your BIOS.


\subsection{Module snd-aw2}
\label{sound/alsa-configuration:module-snd-aw2}
Module for Audiowerk2 sound card

This module supports multiple cards.


\subsection{Module snd-azt2320}
\label{sound/alsa-configuration:module-snd-azt2320}
Module for sound cards based on Aztech System AZT2320 ISA chip (PnP only).

This module supports multiple cards, PnP and autoprobe.

The power-management is supported.


\subsection{Module snd-azt3328}
\label{sound/alsa-configuration:module-snd-azt3328}
Module for sound cards based on Aztech AZF3328 PCI chip.
\begin{description}
\item[{joystick}] \leavevmode
Enable joystick (default off)

\end{description}

This module supports multiple cards.


\subsection{Module snd-bt87x}
\label{sound/alsa-configuration:module-snd-bt87x}
Module for video cards based on Bt87x chips.
\begin{description}
\item[{digital\_rate}] \leavevmode
Override the default digital rate (Hz)

\item[{load\_all}] \leavevmode
Load the driver even if the card model isn't known

\end{description}

This module supports multiple cards.

Note: The default index value of this module is -2, i.e. the first
slot is excluded.


\subsection{Module snd-ca0106}
\label{sound/alsa-configuration:module-snd-ca0106}
Module for Creative Audigy LS and SB Live 24bit

This module supports multiple cards.


\subsection{Module snd-cmi8330}
\label{sound/alsa-configuration:module-snd-cmi8330}
Module for sound cards based on C-Media CMI8330 ISA chips.
\begin{description}
\item[{isapnp}] \leavevmode
ISA PnP detection - 0 = disable, 1 = enable (default)

\end{description}

with \code{isapnp=0}, the following options are available:
\begin{description}
\item[{wssport}] \leavevmode
port \# for CMI8330 chip (WSS)

\item[{wssirq}] \leavevmode
IRQ \# for CMI8330 chip (WSS)

\item[{wssdma}] \leavevmode
first DMA \# for CMI8330 chip (WSS)

\item[{sbport}] \leavevmode
port \# for CMI8330 chip (SB16)

\item[{sbirq}] \leavevmode
IRQ \# for CMI8330 chip (SB16)

\item[{sbdma8}] \leavevmode
8bit DMA \# for CMI8330 chip (SB16)

\item[{sbdma16}] \leavevmode
16bit DMA \# for CMI8330 chip (SB16)

\item[{fmport}] \leavevmode
(optional) OPL3 I/O port

\item[{mpuport}] \leavevmode
(optional) MPU401 I/O port

\item[{mpuirq}] \leavevmode
(optional) MPU401 irq \#

\end{description}

This module supports multiple cards and autoprobe.

The power-management is supported.


\subsection{Module snd-cmipci}
\label{sound/alsa-configuration:module-snd-cmipci}
Module for C-Media CMI8338/8738/8768/8770 PCI sound cards.
\begin{description}
\item[{mpu\_port}] \leavevmode
port address of MIDI interface (8338 only):
0x300,0x310,0x320,0x330 = legacy port,
0 = disable (default)

\item[{fm\_port}] \leavevmode
port address of OPL-3 FM synthesizer (8x38 only):
0x388 = legacy port,
1 = integrated PCI port (default on 8738),
0 = disable

\item[{soft\_ac3}] \leavevmode
Software-conversion of raw SPDIF packets (model 033 only) (default = 1)

\item[{joystick\_port}] \leavevmode
Joystick port address (0 = disable, 1 = auto-detect)

\end{description}

This module supports autoprobe and multiple cards.

The power-management is supported.


\subsection{Module snd-cs4231}
\label{sound/alsa-configuration:module-snd-cs4231}
Module for sound cards based on CS4231 ISA chips.
\begin{description}
\item[{port}] \leavevmode
port \# for CS4231 chip

\item[{mpu\_port}] \leavevmode
port \# for MPU-401 UART (optional), -1 = disable

\item[{irq}] \leavevmode
IRQ \# for CS4231 chip

\item[{mpu\_irq}] \leavevmode
IRQ \# for MPU-401 UART

\item[{dma1}] \leavevmode
first DMA \# for CS4231 chip

\item[{dma2}] \leavevmode
second DMA \# for CS4231 chip

\end{description}

This module supports multiple cards. This module does not support autoprobe
thus main port must be specified!!! Other ports are optional.

The power-management is supported.


\subsection{Module snd-cs4236}
\label{sound/alsa-configuration:module-snd-cs4236}
Module for sound cards based on CS4232/CS4232A,
CS4235/CS4236/CS4236B/CS4237B/CS4238B/CS4239 ISA chips.
\begin{description}
\item[{isapnp}] \leavevmode
ISA PnP detection - 0 = disable, 1 = enable (default)

\end{description}

with \code{isapnp=0}, the following options are available:
\begin{description}
\item[{port}] \leavevmode
port \# for CS4236 chip (PnP setup - 0x534)

\item[{cport}] \leavevmode
control port \# for CS4236 chip (PnP setup - 0x120,0x210,0xf00)

\item[{mpu\_port}] \leavevmode
port \# for MPU-401 UART (PnP setup - 0x300), -1 = disable

\item[{fm\_port}] \leavevmode
FM port \# for CS4236 chip (PnP setup - 0x388), -1 = disable

\item[{irq}] \leavevmode
IRQ \# for CS4236 chip (5,7,9,11,12,15)

\item[{mpu\_irq}] \leavevmode
IRQ \# for MPU-401 UART (9,11,12,15)

\item[{dma1}] \leavevmode
first DMA \# for CS4236 chip (0,1,3)

\item[{dma2}] \leavevmode
second DMA \# for CS4236 chip (0,1,3), -1 = disable

\end{description}

This module supports multiple cards. This module does not support autoprobe
(if ISA PnP is not used) thus main port and control port must be
specified!!! Other ports are optional.

The power-management is supported.

This module is aliased as snd-cs4232 since it provides the old
snd-cs4232 functionality, too.


\subsection{Module snd-cs4281}
\label{sound/alsa-configuration:module-snd-cs4281}
Module for Cirrus Logic CS4281 soundchip.
\begin{description}
\item[{dual\_codec}] \leavevmode
Secondary codec ID (0 = disable, default)

\end{description}

This module supports multiple cards.

The power-management is supported.


\subsection{Module snd-cs46xx}
\label{sound/alsa-configuration:module-snd-cs46xx}
Module for PCI sound cards based on CS4610/CS4612/CS4614/CS4615/CS4622/
CS4624/CS4630/CS4280 PCI chips.
\begin{description}
\item[{external\_amp}] \leavevmode
Force to enable external amplifier.

\item[{thinkpad}] \leavevmode
Force to enable Thinkpad's CLKRUN control.

\item[{mmap\_valid}] \leavevmode
Support OSS mmap mode (default = 0).

\end{description}

This module supports multiple cards and autoprobe.
Usually external amp and CLKRUN controls are detected automatically
from PCI sub vendor/device ids.  If they don't work, give the options
above explicitly.

The power-management is supported.


\subsection{Module snd-cs5530}
\label{sound/alsa-configuration:module-snd-cs5530}
Module for Cyrix/NatSemi Geode 5530 chip.


\subsection{Module snd-cs5535audio}
\label{sound/alsa-configuration:module-snd-cs5535audio}
Module for multifunction CS5535 companion PCI device

The power-management is supported.


\subsection{Module snd-ctxfi}
\label{sound/alsa-configuration:module-snd-ctxfi}
Module for Creative Sound Blaster X-Fi boards (20k1 / 20k2 chips)
\begin{itemize}
\item {} 
Creative Sound Blaster X-Fi Titanium Fatal1ty Champion Series

\item {} 
Creative Sound Blaster X-Fi Titanium Fatal1ty Professional Series

\item {} 
Creative Sound Blaster X-Fi Titanium Professional Audio

\item {} 
Creative Sound Blaster X-Fi Titanium

\item {} 
Creative Sound Blaster X-Fi Elite Pro

\item {} 
Creative Sound Blaster X-Fi Platinum

\item {} 
Creative Sound Blaster X-Fi Fatal1ty

\item {} 
Creative Sound Blaster X-Fi XtremeGamer

\item {} 
Creative Sound Blaster X-Fi XtremeMusic

\end{itemize}
\begin{description}
\item[{reference\_rate}] \leavevmode
reference sample rate, 44100 or 48000 (default)

\item[{multiple}] \leavevmode
multiple to ref. sample rate, 1 or 2 (default)

\item[{subsystem}] \leavevmode
override the PCI SSID for probing;
the value consists of SSVID \textless{}\textless{} 16 \textbar{} SSDID.
The default is zero, which means no override.

\end{description}

This module supports multiple cards.


\subsection{Module snd-darla20}
\label{sound/alsa-configuration:module-snd-darla20}
Module for Echoaudio Darla20

This module supports multiple cards.
The driver requires the firmware loader support on kernel.


\subsection{Module snd-darla24}
\label{sound/alsa-configuration:module-snd-darla24}
Module for Echoaudio Darla24

This module supports multiple cards.
The driver requires the firmware loader support on kernel.


\subsection{Module snd-dt019x}
\label{sound/alsa-configuration:module-snd-dt019x}
Module for Diamond Technologies DT-019X / Avance Logic ALS-007 (PnP
only)

This module supports multiple cards.  This module is enabled only with
ISA PnP support.

The power-management is supported.


\subsection{Module snd-dummy}
\label{sound/alsa-configuration:module-snd-dummy}
Module for the dummy sound card. This ``card'' doesn't do any output
or input, but you may use this module for any application which
requires a sound card (like RealPlayer).
\begin{description}
\item[{pcm\_devs}] \leavevmode
Number of PCM devices assigned to each card (default = 1, up to 4)

\item[{pcm\_substreams}] \leavevmode
Number of PCM substreams assigned to each PCM (default = 8, up to 128)

\item[{hrtimer}] \leavevmode
Use hrtimer (=1, default) or system timer (=0)

\item[{fake\_buffer}] \leavevmode
Fake buffer allocations (default = 1)

\end{description}

When multiple PCM devices are created, snd-dummy gives different
behavior to each PCM device:
* 0 = interleaved with mmap support
* 1 = non-interleaved with mmap support
* 2 = interleaved without mmap
* 3 = non-interleaved without mmap

As default, snd-dummy drivers doesn't allocate the real buffers
but either ignores read/write or mmap a single dummy page to all
buffer pages, in order to save the resources.  If your apps need
the read/ written buffer data to be consistent, pass fake\_buffer=0
option.

The power-management is supported.


\subsection{Module snd-echo3g}
\label{sound/alsa-configuration:module-snd-echo3g}
Module for Echoaudio 3G cards (Gina3G/Layla3G)

This module supports multiple cards.
The driver requires the firmware loader support on kernel.


\subsection{Module snd-emu10k1}
\label{sound/alsa-configuration:module-snd-emu10k1}
Module for EMU10K1/EMU10k2 based PCI sound cards.
\begin{itemize}
\item {} 
Sound Blaster Live!

\item {} 
Sound Blaster PCI 512

\item {} 
Emu APS (partially supported)

\item {} 
Sound Blaster Audigy

\end{itemize}
\begin{description}
\item[{extin}] \leavevmode
bitmap of available external inputs for FX8010 (see bellow)

\item[{extout}] \leavevmode
bitmap of available external outputs for FX8010 (see bellow)

\item[{seq\_ports}] \leavevmode
allocated sequencer ports (4 by default)

\item[{max\_synth\_voices}] \leavevmode
limit of voices used for wavetable (64 by default)

\item[{max\_buffer\_size}] \leavevmode
specifies the maximum size of wavetable/pcm buffers given in MB
unit.  Default value is 128.

\item[{enable\_ir}] \leavevmode
enable IR

\end{description}

This module supports multiple cards and autoprobe.

Input \& Output configurations                   {[}extin/extout{]}
* Creative Card wo/Digital out                  {[}0x0003/0x1f03{]}
* Creative Card w/Digital out                   {[}0x0003/0x1f0f{]}
* Creative Card w/Digital CD in                 {[}0x000f/0x1f0f{]}
* Creative Card wo/Digital out + LiveDrive      {[}0x3fc3/0x1fc3{]}
* Creative Card w/Digital out + LiveDrive       {[}0x3fc3/0x1fcf{]}
* Creative Card w/Digital CD in + LiveDrive     {[}0x3fcf/0x1fcf{]}
* Creative Card wo/Digital out + Digital I/O 2  {[}0x0fc3/0x1f0f{]}
* Creative Card w/Digital out + Digital I/O 2   {[}0x0fc3/0x1f0f{]}
* Creative Card w/Digital CD in + Digital I/O 2 {[}0x0fcf/0x1f0f{]}
* Creative Card 5.1/w Digital out + LiveDrive   {[}0x3fc3/0x1fff{]}
* Creative Card 5.1 (c) 2003                    {[}0x3fc3/0x7cff{]}
* Creative Card all ins and outs                {[}0x3fff/0x7fff{]}

The power-management is supported.


\subsection{Module snd-emu10k1x}
\label{sound/alsa-configuration:module-snd-emu10k1x}
Module for Creative Emu10k1X (SB Live Dell OEM version)

This module supports multiple cards.


\subsection{Module snd-ens1370}
\label{sound/alsa-configuration:module-snd-ens1370}
Module for Ensoniq AudioPCI ES1370 PCI sound cards.
\begin{itemize}
\item {} 
SoundBlaster PCI 64

\item {} 
SoundBlaster PCI 128

\end{itemize}
\begin{description}
\item[{joystick}] \leavevmode
Enable joystick (default off)

\end{description}

This module supports multiple cards and autoprobe.

The power-management is supported.


\subsection{Module snd-ens1371}
\label{sound/alsa-configuration:module-snd-ens1371}
Module for Ensoniq AudioPCI ES1371 PCI sound cards.
\begin{itemize}
\item {} 
SoundBlaster PCI 64

\item {} 
SoundBlaster PCI 128

\item {} 
SoundBlaster Vibra PCI

\end{itemize}
\begin{description}
\item[{joystick\_port}] \leavevmode
port \# for joystick (0x200,0x208,0x210,0x218), 0 = disable
(default), 1 = auto-detect

\end{description}

This module supports multiple cards and autoprobe.

The power-management is supported.


\subsection{Module snd-es1688}
\label{sound/alsa-configuration:module-snd-es1688}
Module for ESS AudioDrive ES-1688 and ES-688 sound cards.
\begin{description}
\item[{isapnp}] \leavevmode
ISA PnP detection - 0 = disable, 1 = enable (default)

\item[{mpu\_port}] \leavevmode
port \# for MPU-401 port (0x300,0x310,0x320,0x330), -1 = disable (default)

\item[{mpu\_irq}] \leavevmode
IRQ \# for MPU-401 port (5,7,9,10)

\item[{fm\_port}] \leavevmode
port \# for OPL3 (option; share the same port as default)

\end{description}

with \code{isapnp=0}, the following additional options are available:
\begin{description}
\item[{port}] \leavevmode
port \# for ES-1688 chip (0x220,0x240,0x260)

\item[{irq}] \leavevmode
IRQ \# for ES-1688 chip (5,7,9,10)

\item[{dma8}] \leavevmode
DMA \# for ES-1688 chip (0,1,3)

\end{description}

This module supports multiple cards and autoprobe (without MPU-401 port)
and PnP with the ES968 chip.


\subsection{Module snd-es18xx}
\label{sound/alsa-configuration:module-snd-es18xx}
Module for ESS AudioDrive ES-18xx sound cards.
\begin{description}
\item[{isapnp}] \leavevmode
ISA PnP detection - 0 = disable, 1 = enable (default)

\end{description}

with \code{isapnp=0}, the following options are available:
\begin{description}
\item[{port}] \leavevmode
port \# for ES-18xx chip (0x220,0x240,0x260)

\item[{mpu\_port}] \leavevmode
port \# for MPU-401 port (0x300,0x310,0x320,0x330), -1 = disable (default)

\item[{fm\_port}] \leavevmode
port \# for FM (optional, not used)

\item[{irq}] \leavevmode
IRQ \# for ES-18xx chip (5,7,9,10)

\item[{dma1}] \leavevmode
first DMA \# for ES-18xx chip (0,1,3)

\item[{dma2}] \leavevmode
first DMA \# for ES-18xx chip (0,1,3)

\end{description}

This module supports multiple cards, ISA PnP and autoprobe (without MPU-401
port if native ISA PnP routines are not used).
When \code{dma2} is equal with \code{dma1}, the driver works as half-duplex.

The power-management is supported.


\subsection{Module snd-es1938}
\label{sound/alsa-configuration:module-snd-es1938}
Module for sound cards based on ESS Solo-1 (ES1938,ES1946) chips.

This module supports multiple cards and autoprobe.

The power-management is supported.


\subsection{Module snd-es1968}
\label{sound/alsa-configuration:module-snd-es1968}
Module for sound cards based on ESS Maestro-1/2/2E (ES1968/ES1978) chips.
\begin{description}
\item[{total\_bufsize}] \leavevmode
total buffer size in kB (1-4096kB)

\item[{pcm\_substreams\_p}] \leavevmode
playback channels (1-8, default=2)

\item[{pcm\_substreams\_c}] \leavevmode
capture channels (1-8, default=0)

\item[{clock}] \leavevmode
clock (0 = auto-detection)

\item[{use\_pm}] \leavevmode
support the power-management (0 = off, 1 = on, 2 = auto (default))

\item[{enable\_mpu}] \leavevmode
enable MPU401 (0 = off, 1 = on, 2 = auto (default))

\item[{joystick}] \leavevmode
enable joystick (default off)

\end{description}

This module supports multiple cards and autoprobe.

The power-management is supported.


\subsection{Module snd-fm801}
\label{sound/alsa-configuration:module-snd-fm801}
Module for ForteMedia FM801 based PCI sound cards.
\begin{description}
\item[{tea575x\_tuner}] \leavevmode
Enable TEA575x tuner;
1 = MediaForte 256-PCS,
2 = MediaForte 256-PCPR,
3 = MediaForte 64-PCR
High 16-bits are video (radio) device number + 1;
example: 0x10002 (MediaForte 256-PCPR, device 1)

\end{description}

This module supports multiple cards and autoprobe.

The power-management is supported.


\subsection{Module snd-gina20}
\label{sound/alsa-configuration:module-snd-gina20}
Module for Echoaudio Gina20

This module supports multiple cards.
The driver requires the firmware loader support on kernel.


\subsection{Module snd-gina24}
\label{sound/alsa-configuration:module-snd-gina24}
Module for Echoaudio Gina24

This module supports multiple cards.
The driver requires the firmware loader support on kernel.


\subsection{Module snd-gusclassic}
\label{sound/alsa-configuration:module-snd-gusclassic}
Module for Gravis UltraSound Classic sound card.
\begin{description}
\item[{port}] \leavevmode
port \# for GF1 chip (0x220,0x230,0x240,0x250,0x260)

\item[{irq}] \leavevmode
IRQ \# for GF1 chip (3,5,9,11,12,15)

\item[{dma1}] \leavevmode
DMA \# for GF1 chip (1,3,5,6,7)

\item[{dma2}] \leavevmode
DMA \# for GF1 chip (1,3,5,6,7,-1=disable)

\item[{joystick\_dac}] \leavevmode
0 to 31, (0.59V-4.52V or 0.389V-2.98V)

\item[{voices}] \leavevmode
GF1 voices limit (14-32)

\item[{pcm\_voices}] \leavevmode
reserved PCM voices

\end{description}

This module supports multiple cards and autoprobe.


\subsection{Module snd-gusextreme}
\label{sound/alsa-configuration:module-snd-gusextreme}
Module for Gravis UltraSound Extreme (Synergy ViperMax) sound card.
\begin{description}
\item[{port}] \leavevmode
port \# for ES-1688 chip (0x220,0x230,0x240,0x250,0x260)

\item[{gf1\_port}] \leavevmode
port \# for GF1 chip (0x210,0x220,0x230,0x240,0x250,0x260,0x270)

\item[{mpu\_port}] \leavevmode
port \# for MPU-401 port (0x300,0x310,0x320,0x330), -1 = disable

\item[{irq}] \leavevmode
IRQ \# for ES-1688 chip (5,7,9,10)

\item[{gf1\_irq}] \leavevmode
IRQ \# for GF1 chip (3,5,9,11,12,15)

\item[{mpu\_irq}] \leavevmode
IRQ \# for MPU-401 port (5,7,9,10)

\item[{dma8}] \leavevmode
DMA \# for ES-1688 chip (0,1,3)

\item[{dma1}] \leavevmode
DMA \# for GF1 chip (1,3,5,6,7)

\item[{joystick\_dac}] \leavevmode
0 to 31, (0.59V-4.52V or 0.389V-2.98V)

\item[{voices}] \leavevmode
GF1 voices limit (14-32)

\item[{pcm\_voices}] \leavevmode
reserved PCM voices

\end{description}

This module supports multiple cards and autoprobe (without MPU-401 port).


\subsection{Module snd-gusmax}
\label{sound/alsa-configuration:module-snd-gusmax}
Module for Gravis UltraSound MAX sound card.
\begin{description}
\item[{port}] \leavevmode
port \# for GF1 chip (0x220,0x230,0x240,0x250,0x260)

\item[{irq}] \leavevmode
IRQ \# for GF1 chip (3,5,9,11,12,15)

\item[{dma1}] \leavevmode
DMA \# for GF1 chip (1,3,5,6,7)

\item[{dma2}] \leavevmode
DMA \# for GF1 chip (1,3,5,6,7,-1=disable)

\item[{joystick\_dac}] \leavevmode
0 to 31, (0.59V-4.52V or 0.389V-2.98V)

\item[{voices}] \leavevmode
GF1 voices limit (14-32)

\item[{pcm\_voices}] \leavevmode
reserved PCM voices

\end{description}

This module supports multiple cards and autoprobe.


\subsection{Module snd-hda-intel}
\label{sound/alsa-configuration:module-snd-hda-intel}
Module for Intel HD Audio (ICH6, ICH6M, ESB2, ICH7, ICH8, ICH9, ICH10,
PCH, SCH), ATI SB450, SB600, R600, RS600, RS690, RS780, RV610, RV620,
RV630, RV635, RV670, RV770, VIA VT8251/VT8237A, SIS966, ULI M5461

{[}Multiple options for each card instance{]}
\begin{description}
\item[{model}] \leavevmode
force the model name

\item[{position\_fix}] \leavevmode
Fix DMA pointer;
-1 = system default: choose appropriate one per controller hardware,
0 = auto: falls back to LPIB when POSBUF doesn't work,
1 = use LPIB,
2 = POSBUF: use position buffer,
3 = VIACOMBO: VIA-specific workaround for capture,
4 = COMBO: use LPIB for playback, auto for capture stream

\item[{probe\_mask}] \leavevmode
Bitmask to probe codecs (default = -1, meaning all slots);
When the bit 8 (0x100) is set, the lower 8 bits are used
as the ``fixed'' codec slots; i.e. the driver probes the
slots regardless what hardware reports back

\item[{probe\_only}] \leavevmode
Only probing and no codec initialization (default=off);
Useful to check the initial codec status for debugging

\item[{bdl\_pos\_adj}] \leavevmode
Specifies the DMA IRQ timing delay in samples.
Passing -1 will make the driver to choose the appropriate
value based on the controller chip.

\item[{patch}] \leavevmode
Specifies the early ``patch'' files to modify the HD-audio setup
before initializing the codecs.
This option is available only when \code{CONFIG\_SND\_HDA\_PATCH\_LOADER=y}
is set.  See hd-audio/notes.rst for details.

\item[{beep\_mode}] \leavevmode
Selects the beep registration mode (0=off, 1=on);
default value is set via \code{CONFIG\_SND\_HDA\_INPUT\_BEEP\_MODE} kconfig.

\end{description}

{[}Single (global) options{]}
\begin{description}
\item[{single\_cmd}] \leavevmode
Use single immediate commands to communicate with codecs
(for debugging only)

\item[{enable\_msi}] \leavevmode
Enable Message Signaled Interrupt (MSI) (default = off)

\item[{power\_save}] \leavevmode
Automatic power-saving timeout (in second, 0 = disable)

\item[{power\_save\_controller}] \leavevmode
Reset HD-audio controller in power-saving mode (default = on)

\item[{align\_buffer\_size}] \leavevmode
Force rounding of buffer/period sizes to multiples of 128 bytes.
This is more efficient in terms of memory access but isn't
required by the HDA spec and prevents users from specifying
exact period/buffer sizes. (default = on)

\item[{snoop}] \leavevmode
Enable/disable snooping (default = on)

\end{description}

This module supports multiple cards and autoprobe.

See hd-audio/notes.rst for more details about HD-audio driver.

Each codec may have a model table for different configurations.
If your machine isn't listed there, the default (usually minimal)
configuration is set up.  You can pass \code{model=\textless{}name\textgreater{}} option to
specify a certain model in such a case.  There are different
models depending on the codec chip.  The list of available models
is found in hd-audio/models.rst.

The model name \code{generic} is treated as a special case.  When this
model is given, the driver uses the generic codec parser without
``codec-patch''.  It's sometimes good for testing and debugging.

If the default configuration doesn't work and one of the above
matches with your device, report it together with alsa-info.sh
output (with \code{-{-}no-upload} option) to kernel bugzilla or alsa-devel
ML (see the section {\hyperref[sound/alsa\string-configuration:links\string-and\string-addresses]{\emph{Links and Addresses}}}).

\code{power\_save} and \code{power\_save\_controller} options are for power-saving
mode.  See powersave.txt for details.

Note 2: If you get click noises on output, try the module option
\code{position\_fix=1} or \code{2}.  \code{position\_fix=1} will use the SD\_LPIB
register value without FIFO size correction as the current
DMA pointer.  \code{position\_fix=2} will make the driver to use
the position buffer instead of reading SD\_LPIB register.
(Usually SD\_LPIB register is more accurate than the
position buffer.)

\code{position\_fix=3} is specific to VIA devices.  The position
of the capture stream is checked from both LPIB and POSBUF
values.  \code{position\_fix=4} is a combination mode, using LPIB
for playback and POSBUF for capture.

NB: If you get many \code{azx\_get\_response timeout} messages at
loading, it's likely a problem of interrupts (e.g. ACPI irq
routing).  Try to boot with options like \code{pci=noacpi}.  Also, you
can try \code{single\_cmd=1} module option.  This will switch the
communication method between HDA controller and codecs to the
single immediate commands instead of CORB/RIRB.  Basically, the
single command mode is provided only for BIOS, and you won't get
unsolicited events, too.  But, at least, this works independently
from the irq.  Remember this is a last resort, and should be
avoided as much as possible...

MORE NOTES ON \code{azx\_get\_response timeout} PROBLEMS:
On some hardware, you may need to add a proper probe\_mask option
to avoid the \code{azx\_get\_response timeout} problem above, instead.
This occurs when the access to non-existing or non-working codec slot
(likely a modem one) causes a stall of the communication via HD-audio
bus.  You can see which codec slots are probed by enabling
\code{CONFIG\_SND\_DEBUG\_VERBOSE}, or simply from the file name of the codec
proc files.  Then limit the slots to probe by probe\_mask option.
For example, \code{probe\_mask=1} means to probe only the first slot, and
\code{probe\_mask=4} means only the third slot.

The power-management is supported.


\subsection{Module snd-hdsp}
\label{sound/alsa-configuration:module-snd-hdsp}
Module for RME Hammerfall DSP audio interface(s)

This module supports multiple cards.

Note: The firmware data can be automatically loaded via hotplug
when \code{CONFIG\_FW\_LOADER} is set.  Otherwise, you need to load
the firmware via hdsploader utility included in alsa-tools
package.
The firmware data is found in alsa-firmware package.

Note: snd-page-alloc module does the job which snd-hammerfall-mem
module did formerly.  It will allocate the buffers in advance
when any HDSP cards are found.  To make the buffer
allocation sure, load snd-page-alloc module in the early
stage of boot sequence.  See {\hyperref[sound/alsa\string-configuration:early\string-buffer\string-allocation]{\emph{Early Buffer Allocation}}}
section.


\subsection{Module snd-hdspm}
\label{sound/alsa-configuration:module-snd-hdspm}
Module for RME HDSP MADI board.
\begin{description}
\item[{precise\_ptr}] \leavevmode
Enable precise pointer, or disable.

\item[{line\_outs\_monitor}] \leavevmode
Send playback streams to analog outs by default.

\item[{enable\_monitor}] \leavevmode
Enable Analog Out on Channel 63/64 by default.

\end{description}

See hdspm.txt for details.


\subsection{Module snd-ice1712}
\label{sound/alsa-configuration:module-snd-ice1712}
Module for Envy24 (ICE1712) based PCI sound cards.
\begin{itemize}
\item {} 
MidiMan M Audio Delta 1010

\item {} 
MidiMan M Audio Delta 1010LT

\item {} 
MidiMan M Audio Delta DiO 2496

\item {} 
MidiMan M Audio Delta 66

\item {} 
MidiMan M Audio Delta 44

\item {} 
MidiMan M Audio Delta 410

\item {} 
MidiMan M Audio Audiophile 2496

\item {} 
TerraTec EWS 88MT

\item {} 
TerraTec EWS 88D

\item {} 
TerraTec EWX 24/96

\item {} 
TerraTec DMX 6Fire

\item {} 
TerraTec Phase 88

\item {} 
Hoontech SoundTrack DSP 24

\item {} 
Hoontech SoundTrack DSP 24 Value

\item {} 
Hoontech SoundTrack DSP 24 Media 7.1

\item {} 
Event Electronics, EZ8

\item {} 
Digigram VX442

\item {} 
Lionstracs, Mediastaton

\item {} 
Terrasoniq TS 88

\end{itemize}
\begin{description}
\item[{model}] \leavevmode
Use the given board model, one of the following:
delta1010, dio2496, delta66, delta44, audiophile, delta410,
delta1010lt, vx442, ewx2496, ews88mt, ews88mt\_new, ews88d,
dmx6fire, dsp24, dsp24\_value, dsp24\_71, ez8,
phase88, mediastation

\item[{omni}] \leavevmode
Omni I/O support for MidiMan M-Audio Delta44/66

\item[{cs8427\_timeout}] \leavevmode
reset timeout for the CS8427 chip (S/PDIF transceiver) in msec
resolution, default value is 500 (0.5 sec)

\end{description}

This module supports multiple cards and autoprobe.
Note: The consumer part is not used with all Envy24 based cards (for
example in the MidiMan Delta siree).

Note: The supported board is detected by reading EEPROM or PCI
SSID (if EEPROM isn't available).  You can override the
model by passing \code{model} module option in case that the
driver isn't configured properly or you want to try another
type for testing.


\subsection{Module snd-ice1724}
\label{sound/alsa-configuration:module-snd-ice1724}
Module for Envy24HT (VT/ICE1724), Envy24PT (VT1720) based PCI sound cards.
\begin{itemize}
\item {} 
MidiMan M Audio Revolution 5.1

\item {} 
MidiMan M Audio Revolution 7.1

\item {} 
MidiMan M Audio Audiophile 192

\item {} 
AMP Ltd AUDIO2000

\item {} 
TerraTec Aureon 5.1 Sky

\item {} 
TerraTec Aureon 7.1 Space

\item {} 
TerraTec Aureon 7.1 Universe

\item {} 
TerraTec Phase 22

\item {} 
TerraTec Phase 28

\item {} 
AudioTrak Prodigy 7.1

\item {} 
AudioTrak Prodigy 7.1 LT

\item {} 
AudioTrak Prodigy 7.1 XT

\item {} 
AudioTrak Prodigy 7.1 HIFI

\item {} 
AudioTrak Prodigy 7.1 HD2

\item {} 
AudioTrak Prodigy 192

\item {} 
Pontis MS300

\item {} 
Albatron K8X800 Pro II

\item {} 
Chaintech ZNF3-150

\item {} 
Chaintech ZNF3-250

\item {} 
Chaintech 9CJS

\item {} 
Chaintech AV-710

\item {} 
Shuttle SN25P

\item {} 
Onkyo SE-90PCI

\item {} 
Onkyo SE-200PCI

\item {} 
ESI Juli@

\item {} 
ESI Maya44

\item {} 
Hercules Fortissimo IV

\item {} 
EGO-SYS WaveTerminal 192M

\end{itemize}
\begin{description}
\item[{model}] \leavevmode
Use the given board model, one of the following:
revo51, revo71, amp2000, prodigy71, prodigy71lt,
prodigy71xt, prodigy71hifi, prodigyhd2, prodigy192,
juli, aureon51, aureon71, universe, ap192, k8x800,
phase22, phase28, ms300, av710, se200pci, se90pci,
fortissimo4, sn25p, WT192M, maya44

\end{description}

This module supports multiple cards and autoprobe.

Note: The supported board is detected by reading EEPROM or PCI
SSID (if EEPROM isn't available).  You can override the
model by passing \code{model} module option in case that the
driver isn't configured properly or you want to try another
type for testing.


\subsection{Module snd-indigo}
\label{sound/alsa-configuration:module-snd-indigo}
Module for Echoaudio Indigo

This module supports multiple cards.
The driver requires the firmware loader support on kernel.


\subsection{Module snd-indigodj}
\label{sound/alsa-configuration:module-snd-indigodj}
Module for Echoaudio Indigo DJ

This module supports multiple cards.
The driver requires the firmware loader support on kernel.


\subsection{Module snd-indigoio}
\label{sound/alsa-configuration:module-snd-indigoio}
Module for Echoaudio Indigo IO

This module supports multiple cards.
The driver requires the firmware loader support on kernel.


\subsection{Module snd-intel8x0}
\label{sound/alsa-configuration:module-snd-intel8x0}
Module for AC`97 motherboards from Intel and compatibles.
\begin{itemize}
\item {} 
Intel i810/810E, i815, i820, i830, i84x, MX440 ICH5, ICH6, ICH7,
6300ESB, ESB2

\item {} 
SiS 7012 (SiS 735)

\item {} 
NVidia NForce, NForce2, NForce3, MCP04, CK804 CK8, CK8S, MCP501

\item {} 
AMD AMD768, AMD8111

\item {} 
ALi m5455

\end{itemize}
\begin{description}
\item[{ac97\_clock}] \leavevmode
AC`97 codec clock base (0 = auto-detect)

\item[{ac97\_quirk}] \leavevmode
AC`97 workaround for strange hardware;
See {\hyperref[sound/alsa\string-configuration:ac97\string-quirk\string-option]{\emph{AC97 Quirk Option}}} section below.

\item[{buggy\_irq}] \leavevmode
Enable workaround for buggy interrupts on some motherboards
(default yes on nForce chips, otherwise off)

\item[{buggy\_semaphore}] \leavevmode
Enable workaround for hardware with buggy semaphores (e.g. on some
ASUS laptops) (default off)

\item[{spdif\_aclink}] \leavevmode
Use S/PDIF over AC-link instead of direct connection from the
controller chip (0 = off, 1 = on, -1 = default)

\end{description}

This module supports one chip and autoprobe.

Note: the latest driver supports auto-detection of chip clock.
if you still encounter too fast playback, specify the clock
explicitly via the module option \code{ac97\_clock=41194}.

Joystick/MIDI ports are not supported by this driver.  If your
motherboard has these devices, use the ns558 or snd-mpu401
modules, respectively.

The power-management is supported.


\subsection{Module snd-intel8x0m}
\label{sound/alsa-configuration:module-snd-intel8x0m}
Module for Intel ICH (i8x0) chipset MC97 modems.
\begin{itemize}
\item {} 
Intel i810/810E, i815, i820, i830, i84x, MX440 ICH5, ICH6, ICH7

\item {} 
SiS 7013 (SiS 735)

\item {} 
NVidia NForce, NForce2, NForce2s, NForce3

\item {} 
AMD AMD8111

\item {} 
ALi m5455

\end{itemize}
\begin{description}
\item[{ac97\_clock}] \leavevmode
AC`97 codec clock base (0 = auto-detect)

\end{description}

This module supports one card and autoprobe.

Note: The default index value of this module is -2, i.e. the first
slot is excluded.

The power-management is supported.


\subsection{Module snd-interwave}
\label{sound/alsa-configuration:module-snd-interwave}
Module for Gravis UltraSound PnP, Dynasonic 3-D/Pro, STB Sound Rage 32
and other sound cards based on AMD InterWave (tm) chip.
\begin{description}
\item[{joystick\_dac}] \leavevmode
0 to 31, (0.59V-4.52V or 0.389V-2.98V)

\item[{midi}] \leavevmode
1 = MIDI UART enable, 0 = MIDI UART disable (default)

\item[{pcm\_voices}] \leavevmode
reserved PCM voices for the synthesizer (default 2)

\item[{effect}] \leavevmode
1 = InterWave effects enable (default 0); requires 8 voices

\item[{isapnp}] \leavevmode
ISA PnP detection - 0 = disable, 1 = enable (default)

\end{description}

with \code{isapnp=0}, the following options are available:
\begin{description}
\item[{port}] \leavevmode
port \# for InterWave chip (0x210,0x220,0x230,0x240,0x250,0x260)

\item[{irq}] \leavevmode
IRQ \# for InterWave chip (3,5,9,11,12,15)

\item[{dma1}] \leavevmode
DMA \# for InterWave chip (0,1,3,5,6,7)

\item[{dma2}] \leavevmode
DMA \# for InterWave chip (0,1,3,5,6,7,-1=disable)

\end{description}

This module supports multiple cards, autoprobe and ISA PnP.


\subsection{Module snd-interwave-stb}
\label{sound/alsa-configuration:module-snd-interwave-stb}
Module for UltraSound 32-Pro (sound card from STB used by Compaq)
and other sound cards based on AMD InterWave (tm) chip with TEA6330T
circuit for extended control of bass, treble and master volume.
\begin{description}
\item[{joystick\_dac}] \leavevmode
0 to 31, (0.59V-4.52V or 0.389V-2.98V)

\item[{midi}] \leavevmode
1 = MIDI UART enable, 0 = MIDI UART disable (default)

\item[{pcm\_voices}] \leavevmode
reserved PCM voices for the synthesizer (default 2)

\item[{effect}] \leavevmode
1 = InterWave effects enable (default 0); requires 8 voices

\item[{isapnp}] \leavevmode
ISA PnP detection - 0 = disable, 1 = enable (default)

\end{description}

with \code{isapnp=0}, the following options are available:
\begin{description}
\item[{port}] \leavevmode
port \# for InterWave chip (0x210,0x220,0x230,0x240,0x250,0x260)

\item[{port\_tc}] \leavevmode
tone control (i2c bus) port \# for TEA6330T chip (0x350,0x360,0x370,0x380)

\item[{irq}] \leavevmode
IRQ \# for InterWave chip (3,5,9,11,12,15)

\item[{dma1}] \leavevmode
DMA \# for InterWave chip (0,1,3,5,6,7)

\item[{dma2}] \leavevmode
DMA \# for InterWave chip (0,1,3,5,6,7,-1=disable)

\end{description}

This module supports multiple cards, autoprobe and ISA PnP.


\subsection{Module snd-jazz16}
\label{sound/alsa-configuration:module-snd-jazz16}
Module for Media Vision Jazz16 chipset. The chipset consists of 3 chips:
MVD1216 + MVA416 + MVA514.
\begin{description}
\item[{port}] \leavevmode
port \# for SB DSP chip (0x210,0x220,0x230,0x240,0x250,0x260)

\item[{irq}] \leavevmode
IRQ \# for SB DSP chip (3,5,7,9,10,15)

\item[{dma8}] \leavevmode
DMA \# for SB DSP chip (1,3)

\item[{dma16}] \leavevmode
DMA \# for SB DSP chip (5,7)

\item[{mpu\_port}] \leavevmode
MPU-401 port \# (0x300,0x310,0x320,0x330)

\item[{mpu\_irq}] \leavevmode
MPU-401 irq \# (2,3,5,7)

\end{description}

This module supports multiple cards.


\subsection{Module snd-korg1212}
\label{sound/alsa-configuration:module-snd-korg1212}
Module for Korg 1212 IO PCI card

This module supports multiple cards.


\subsection{Module snd-layla20}
\label{sound/alsa-configuration:module-snd-layla20}
Module for Echoaudio Layla20

This module supports multiple cards.
The driver requires the firmware loader support on kernel.


\subsection{Module snd-layla24}
\label{sound/alsa-configuration:module-snd-layla24}
Module for Echoaudio Layla24

This module supports multiple cards.
The driver requires the firmware loader support on kernel.


\subsection{Module snd-lola}
\label{sound/alsa-configuration:module-snd-lola}
Module for Digigram Lola PCI-e boards

This module supports multiple cards.


\subsection{Module snd-lx6464es}
\label{sound/alsa-configuration:module-snd-lx6464es}
Module for Digigram LX6464ES boards

This module supports multiple cards.


\subsection{Module snd-maestro3}
\label{sound/alsa-configuration:module-snd-maestro3}
Module for Allegro/Maestro3 chips
\begin{description}
\item[{external\_amp}] \leavevmode
enable external amp (enabled by default)

\item[{amp\_gpio}] \leavevmode
GPIO pin number for external amp (0-15) or -1 for default pin (8
for allegro, 1 for others)

\end{description}

This module supports autoprobe and multiple chips.

Note: the binding of amplifier is dependent on hardware.
If there is no sound even though all channels are unmuted, try to
specify other gpio connection via amp\_gpio option.
For example, a Panasonic notebook might need \code{amp\_gpio=0x0d}
option.

The power-management is supported.


\subsection{Module snd-mia}
\label{sound/alsa-configuration:module-snd-mia}
Module for Echoaudio Mia

This module supports multiple cards.
The driver requires the firmware loader support on kernel.


\subsection{Module snd-miro}
\label{sound/alsa-configuration:module-snd-miro}
Module for Miro soundcards: miroSOUND PCM 1 pro, miroSOUND PCM 12,
miroSOUND PCM 20 Radio.
\begin{description}
\item[{port}] \leavevmode
Port \# (0x530,0x604,0xe80,0xf40)

\item[{irq}] \leavevmode
IRQ \# (5,7,9,10,11)

\item[{dma1}] \leavevmode
1st dma \# (0,1,3)

\item[{dma2}] \leavevmode
2nd dma \# (0,1)

\item[{mpu\_port}] \leavevmode
MPU-401 port \# (0x300,0x310,0x320,0x330)

\item[{mpu\_irq}] \leavevmode
MPU-401 irq \# (5,7,9,10)

\item[{fm\_port}] \leavevmode
FM Port \# (0x388)

\item[{wss}] \leavevmode
enable WSS mode

\item[{ide}] \leavevmode
enable onboard ide support

\end{description}


\subsection{Module snd-mixart}
\label{sound/alsa-configuration:module-snd-mixart}
Module for Digigram miXart8 sound cards.

This module supports multiple cards.
Note: One miXart8 board will be represented as 4 alsa cards.
See MIXART.txt for details.

When the driver is compiled as a module and the hotplug firmware
is supported, the firmware data is loaded via hotplug automatically.
Install the necessary firmware files in alsa-firmware package.
When no hotplug fw loader is available, you need to load the
firmware via mixartloader utility in alsa-tools package.


\subsection{Module snd-mona}
\label{sound/alsa-configuration:module-snd-mona}
Module for Echoaudio Mona

This module supports multiple cards.
The driver requires the firmware loader support on kernel.


\subsection{Module snd-mpu401}
\label{sound/alsa-configuration:module-snd-mpu401}
Module for MPU-401 UART devices.
\begin{description}
\item[{port}] \leavevmode
port number or -1 (disable)

\item[{irq}] \leavevmode
IRQ number or -1 (disable)

\item[{pnp}] \leavevmode
PnP detection - 0 = disable, 1 = enable (default)

\end{description}

This module supports multiple devices and PnP.


\subsection{Module snd-msnd-classic}
\label{sound/alsa-configuration:module-snd-msnd-classic}
Module for Turtle Beach MultiSound Classic, Tahiti or Monterey
soundcards.
\begin{description}
\item[{io}] \leavevmode
Port \# for msnd-classic card

\item[{irq}] \leavevmode
IRQ \# for msnd-classic card

\item[{mem}] \leavevmode
Memory address (0xb0000, 0xc8000, 0xd0000, 0xd8000, 0xe0000 or 0xe8000)

\item[{write\_ndelay}] \leavevmode
enable write ndelay (default = 1)

\item[{calibrate\_signal}] \leavevmode
calibrate signal (default = 0)

\item[{isapnp}] \leavevmode
ISA PnP detection - 0 = disable, 1 = enable (default)

\item[{digital}] \leavevmode
Digital daughterboard present (default = 0)

\item[{cfg}] \leavevmode
Config port (0x250, 0x260 or 0x270) default = PnP

\item[{reset}] \leavevmode
Reset all devices

\item[{mpu\_io}] \leavevmode
MPU401 I/O port

\item[{mpu\_irq}] \leavevmode
MPU401 irq\#

\item[{ide\_io0}] \leavevmode
IDE port \#0

\item[{ide\_io1}] \leavevmode
IDE port \#1

\item[{ide\_irq}] \leavevmode
IDE irq\#

\item[{joystick\_io}] \leavevmode
Joystick I/O port

\end{description}

The driver requires firmware files \code{turtlebeach/msndinit.bin} and
\code{turtlebeach/msndperm.bin} in the proper firmware directory.

See Documentation/sound/oss/MultiSound for important information
about this driver.  Note that it has been discontinued, but the
Voyetra Turtle Beach knowledge base entry for it is still available
at
\href{http://www.turtlebeach.com}{http://www.turtlebeach.com}


\subsection{Module snd-msnd-pinnacle}
\label{sound/alsa-configuration:module-snd-msnd-pinnacle}
Module for Turtle Beach MultiSound Pinnacle/Fiji soundcards.
\begin{description}
\item[{io}] \leavevmode
Port \# for pinnacle/fiji card

\item[{irq}] \leavevmode
IRQ \# for pinnalce/fiji card

\item[{mem}] \leavevmode
Memory address (0xb0000, 0xc8000, 0xd0000, 0xd8000, 0xe0000 or 0xe8000)

\item[{write\_ndelay}] \leavevmode
enable write ndelay (default = 1)

\item[{calibrate\_signal}] \leavevmode
calibrate signal (default = 0)

\item[{isapnp}] \leavevmode
ISA PnP detection - 0 = disable, 1 = enable (default)

\end{description}

The driver requires firmware files \code{turtlebeach/pndspini.bin} and
\code{turtlebeach/pndsperm.bin} in the proper firmware directory.


\subsection{Module snd-mtpav}
\label{sound/alsa-configuration:module-snd-mtpav}
Module for MOTU MidiTimePiece AV multiport MIDI (on the parallel
port).
\begin{description}
\item[{port}] \leavevmode
I/O port \# for MTPAV (0x378,0x278, default=0x378)

\item[{irq}] \leavevmode
IRQ \# for MTPAV (7,5, default=7)

\item[{hwports}] \leavevmode
number of supported hardware ports, default=8.

\end{description}

Module supports only 1 card.  This module has no enable option.


\subsection{Module snd-mts64}
\label{sound/alsa-configuration:module-snd-mts64}
Module for Ego Systems (ESI) Miditerminal 4140

This module supports multiple devices.
Requires parport (\code{CONFIG\_PARPORT}).


\subsection{Module snd-nm256}
\label{sound/alsa-configuration:module-snd-nm256}
Module for NeoMagic NM256AV/ZX chips
\begin{description}
\item[{playback\_bufsize}] \leavevmode
max playback frame size in kB (4-128kB)

\item[{capture\_bufsize}] \leavevmode
max capture frame size in kB (4-128kB)

\item[{force\_ac97}] \leavevmode
0 or 1 (disabled by default)

\item[{buffer\_top}] \leavevmode
specify buffer top address

\item[{use\_cache}] \leavevmode
0 or 1 (disabled by default)

\item[{vaio\_hack}] \leavevmode
alias buffer\_top=0x25a800

\item[{reset\_workaround}] \leavevmode
enable AC97 RESET workaround for some laptops

\item[{reset\_workaround2}] \leavevmode
enable extended AC97 RESET workaround for some other laptops

\end{description}

This module supports one chip and autoprobe.

The power-management is supported.

Note: on some notebooks the buffer address cannot be detected
automatically, or causes hang-up during initialization.
In such a case, specify the buffer top address explicitly via
the buffer\_top option.
For example,
Sony F250: buffer\_top=0x25a800
Sony F270: buffer\_top=0x272800
The driver supports only ac97 codec.  It's possible to force
to initialize/use ac97 although it's not detected.  In such a
case, use \code{force\_ac97=1} option - but \emph{NO} guarantee whether it
works!

Note: The NM256 chip can be linked internally with non-AC97
codecs.  This driver supports only the AC97 codec, and won't work
with machines with other (most likely CS423x or OPL3SAx) chips,
even though the device is detected in lspci.  In such a case, try
other drivers, e.g. snd-cs4232 or snd-opl3sa2.  Some has ISA-PnP
but some doesn't have ISA PnP.  You'll need to specify \code{isapnp=0}
and proper hardware parameters in the case without ISA PnP.

Note: some laptops need a workaround for AC97 RESET.  For the
known hardware like Dell Latitude LS and Sony PCG-F305, this
workaround is enabled automatically.  For other laptops with a
hard freeze, you can try \code{reset\_workaround=1} option.

Note: Dell Latitude CSx laptops have another problem regarding
AC97 RESET.  On these laptops, reset\_workaround2 option is
turned on as default.  This option is worth to try if the
previous reset\_workaround option doesn't help.

Note: This driver is really crappy.  It's a porting from the
OSS driver, which is a result of black-magic reverse engineering.
The detection of codec will fail if the driver is loaded \emph{after}
X-server as described above.  You might be able to force to load
the module, but it may result in hang-up.   Hence, make sure that
you load this module \emph{before} X if you encounter this kind of
problem.


\subsection{Module snd-opl3sa2}
\label{sound/alsa-configuration:module-snd-opl3sa2}
Module for Yamaha OPL3-SA2/SA3 sound cards.
\begin{description}
\item[{isapnp}] \leavevmode
ISA PnP detection - 0 = disable, 1 = enable (default)

\end{description}

with \code{isapnp=0}, the following options are available:
\begin{description}
\item[{port}] \leavevmode
control port \# for OPL3-SA chip (0x370)

\item[{sb\_port}] \leavevmode
SB port \# for OPL3-SA chip (0x220,0x240)

\item[{wss\_port}] \leavevmode
WSS port \# for OPL3-SA chip (0x530,0xe80,0xf40,0x604)

\item[{midi\_port}] \leavevmode
port \# for MPU-401 UART (0x300,0x330), -1 = disable

\item[{fm\_port}] \leavevmode
FM port \# for OPL3-SA chip (0x388), -1 = disable

\item[{irq}] \leavevmode
IRQ \# for OPL3-SA chip (5,7,9,10)

\item[{dma1}] \leavevmode
first DMA \# for Yamaha OPL3-SA chip (0,1,3)

\item[{dma2}] \leavevmode
second DMA \# for Yamaha OPL3-SA chip (0,1,3), -1 = disable

\end{description}

This module supports multiple cards and ISA PnP.  It does not support
autoprobe (if ISA PnP is not used) thus all ports must be specified!!!

The power-management is supported.


\subsection{Module snd-opti92x-ad1848}
\label{sound/alsa-configuration:module-snd-opti92x-ad1848}
Module for sound cards based on OPTi 82c92x and Analog Devices AD1848 chips.
Module works with OAK Mozart cards as well.
\begin{description}
\item[{isapnp}] \leavevmode
ISA PnP detection - 0 = disable, 1 = enable (default)

\end{description}

with \code{isapnp=0}, the following options are available:
\begin{description}
\item[{port}] \leavevmode
port \# for WSS chip (0x530,0xe80,0xf40,0x604)

\item[{mpu\_port}] \leavevmode
port \# for MPU-401 UART (0x300,0x310,0x320,0x330)

\item[{fm\_port}] \leavevmode
port \# for OPL3 device (0x388)

\item[{irq}] \leavevmode
IRQ \# for WSS chip (5,7,9,10,11)

\item[{mpu\_irq}] \leavevmode
IRQ \# for MPU-401 UART (5,7,9,10)

\item[{dma1}] \leavevmode
first DMA \# for WSS chip (0,1,3)

\end{description}

This module supports only one card, autoprobe and PnP.


\subsection{Module snd-opti92x-cs4231}
\label{sound/alsa-configuration:module-snd-opti92x-cs4231}
Module for sound cards based on OPTi 82c92x and Crystal CS4231 chips.
\begin{description}
\item[{isapnp}] \leavevmode
ISA PnP detection - 0 = disable, 1 = enable (default)

\end{description}

with \code{isapnp=0}, the following options are available:
\begin{description}
\item[{port}] \leavevmode
port \# for WSS chip (0x530,0xe80,0xf40,0x604)

\item[{mpu\_port}] \leavevmode
port \# for MPU-401 UART (0x300,0x310,0x320,0x330)

\item[{fm\_port}] \leavevmode
port \# for OPL3 device (0x388)

\item[{irq}] \leavevmode
IRQ \# for WSS chip (5,7,9,10,11)

\item[{mpu\_irq}] \leavevmode
IRQ \# for MPU-401 UART (5,7,9,10)

\item[{dma1}] \leavevmode
first DMA \# for WSS chip (0,1,3)

\item[{dma2}] \leavevmode
second DMA \# for WSS chip (0,1,3)

\end{description}

This module supports only one card, autoprobe and PnP.


\subsection{Module snd-opti93x}
\label{sound/alsa-configuration:module-snd-opti93x}
Module for sound cards based on OPTi 82c93x chips.
\begin{description}
\item[{isapnp}] \leavevmode
ISA PnP detection - 0 = disable, 1 = enable (default)

\end{description}

with \code{isapnp=0}, the following options are available:
\begin{description}
\item[{port}] \leavevmode
port \# for WSS chip (0x530,0xe80,0xf40,0x604)

\item[{mpu\_port}] \leavevmode
port \# for MPU-401 UART (0x300,0x310,0x320,0x330)

\item[{fm\_port}] \leavevmode
port \# for OPL3 device (0x388)

\item[{irq}] \leavevmode
IRQ \# for WSS chip (5,7,9,10,11)

\item[{mpu\_irq}] \leavevmode
IRQ \# for MPU-401 UART (5,7,9,10)

\item[{dma1}] \leavevmode
first DMA \# for WSS chip (0,1,3)

\item[{dma2}] \leavevmode
second DMA \# for WSS chip (0,1,3)

\end{description}

This module supports only one card, autoprobe and PnP.


\subsection{Module snd-oxygen}
\label{sound/alsa-configuration:module-snd-oxygen}
Module for sound cards based on the C-Media CMI8786/8787/8788 chip:
\begin{itemize}
\item {} 
Asound A-8788

\item {} 
Asus Xonar DG/DGX

\item {} 
AuzenTech X-Meridian

\item {} 
AuzenTech X-Meridian 2G

\item {} 
Bgears b-Enspirer

\item {} 
Club3D Theatron DTS

\item {} 
HT-Omega Claro (plus)

\item {} 
HT-Omega Claro halo (XT)

\item {} 
Kuroutoshikou CMI8787-HG2PCI

\item {} 
Razer Barracuda AC-1

\item {} 
Sondigo Inferno

\item {} 
TempoTec HiFier Fantasia

\item {} 
TempoTec HiFier Serenade

\end{itemize}

This module supports autoprobe and multiple cards.


\subsection{Module snd-pcsp}
\label{sound/alsa-configuration:module-snd-pcsp}
Module for internal PC-Speaker.
\begin{description}
\item[{nopcm}] \leavevmode
Disable PC-Speaker PCM sound. Only beeps remain.

\item[{nforce\_wa}] \leavevmode
enable NForce chipset workaround. Expect bad sound.

\end{description}

This module supports system beeps, some kind of PCM playback and
even a few mixer controls.


\subsection{Module snd-pcxhr}
\label{sound/alsa-configuration:module-snd-pcxhr}
Module for Digigram PCXHR boards

This module supports multiple cards.


\subsection{Module snd-portman2x4}
\label{sound/alsa-configuration:module-snd-portman2x4}
Module for Midiman Portman 2x4 parallel port MIDI interface

This module supports multiple cards.


\subsection{Module snd-powermac (on ppc only)}
\label{sound/alsa-configuration:module-snd-powermac-on-ppc-only}
Module for PowerMac, iMac and iBook on-board soundchips
\begin{description}
\item[{enable\_beep}] \leavevmode
enable beep using PCM (enabled as default)

\end{description}

Module supports autoprobe a chip.

Note: the driver may have problems regarding endianness.

The power-management is supported.


\subsection{Module snd-pxa2xx-ac97 (on arm only)}
\label{sound/alsa-configuration:module-snd-pxa2xx-ac97-on-arm-only}
Module for AC97 driver for the Intel PXA2xx chip

For ARM architecture only.

The power-management is supported.


\subsection{Module snd-riptide}
\label{sound/alsa-configuration:module-snd-riptide}
Module for Conexant Riptide chip
\begin{description}
\item[{joystick\_port}] \leavevmode
Joystick port \# (default: 0x200)

\item[{mpu\_port}] \leavevmode
MPU401 port \# (default: 0x330)

\item[{opl3\_port}] \leavevmode
OPL3 port \# (default: 0x388)

\end{description}

This module supports multiple cards.
The driver requires the firmware loader support on kernel.
You need to install the firmware file \code{riptide.hex} to the standard
firmware path (e.g. /lib/firmware).


\subsection{Module snd-rme32}
\label{sound/alsa-configuration:module-snd-rme32}
Module for RME Digi32, Digi32 Pro and Digi32/8 (Sek'd Prodif32,
Prodif96 and Prodif Gold) sound cards.

This module supports multiple cards.


\subsection{Module snd-rme96}
\label{sound/alsa-configuration:module-snd-rme96}
Module for RME Digi96, Digi96/8 and Digi96/8 PRO/PAD/PST sound cards.

This module supports multiple cards.


\subsection{Module snd-rme9652}
\label{sound/alsa-configuration:module-snd-rme9652}
Module for RME Digi9652 (Hammerfall, Hammerfall-Light) sound cards.
\begin{description}
\item[{precise\_ptr}] \leavevmode
Enable precise pointer (doesn't work reliably). (default = 0)

\end{description}

This module supports multiple cards.

Note: snd-page-alloc module does the job which snd-hammerfall-mem
module did formerly.  It will allocate the buffers in advance
when any RME9652 cards are found.  To make the buffer
allocation sure, load snd-page-alloc module in the early
stage of boot sequence.  See {\hyperref[sound/alsa\string-configuration:early\string-buffer\string-allocation]{\emph{Early Buffer Allocation}}}
section.


\subsection{Module snd-sa11xx-uda1341 (on arm only)}
\label{sound/alsa-configuration:module-snd-sa11xx-uda1341-on-arm-only}
Module for Philips UDA1341TS on Compaq iPAQ H3600 sound card.

Module supports only one card.
Module has no enable and index options.

The power-management is supported.


\subsection{Module snd-sb8}
\label{sound/alsa-configuration:module-snd-sb8}
Module for 8-bit SoundBlaster cards: SoundBlaster 1.0, SoundBlaster 2.0,
SoundBlaster Pro
\begin{description}
\item[{port}] \leavevmode
port \# for SB DSP chip (0x220,0x240,0x260)

\item[{irq}] \leavevmode
IRQ \# for SB DSP chip (5,7,9,10)

\item[{dma8}] \leavevmode
DMA \# for SB DSP chip (1,3)

\end{description}

This module supports multiple cards and autoprobe.

The power-management is supported.


\subsection{Module snd-sb16 and snd-sbawe}
\label{sound/alsa-configuration:module-snd-sb16-and-snd-sbawe}
Module for 16-bit SoundBlaster cards: SoundBlaster 16 (PnP),
SoundBlaster AWE 32 (PnP), SoundBlaster AWE 64 PnP
\begin{description}
\item[{mic\_agc}] \leavevmode
Mic Auto-Gain-Control - 0 = disable, 1 = enable (default)

\item[{csp}] \leavevmode
ASP/CSP chip support - 0 = disable (default), 1 = enable

\item[{isapnp}] \leavevmode
ISA PnP detection - 0 = disable, 1 = enable (default)

\end{description}

with isapnp=0, the following options are available:
\begin{description}
\item[{port}] \leavevmode
port \# for SB DSP 4.x chip (0x220,0x240,0x260)

\item[{mpu\_port}] \leavevmode
port \# for MPU-401 UART (0x300,0x330), -1 = disable

\item[{awe\_port}] \leavevmode
base port \# for EMU8000 synthesizer (0x620,0x640,0x660) (snd-sbawe
module only)

\item[{irq}] \leavevmode
IRQ \# for SB DSP 4.x chip (5,7,9,10)

\item[{dma8}] \leavevmode
8-bit DMA \# for SB DSP 4.x chip (0,1,3)

\item[{dma16}] \leavevmode
16-bit DMA \# for SB DSP 4.x chip (5,6,7)

\end{description}

This module supports multiple cards, autoprobe and ISA PnP.

Note: To use Vibra16X cards in 16-bit half duplex mode, you must
disable 16bit DMA with dma16 = -1 module parameter.
Also, all Sound Blaster 16 type cards can operate in 16-bit
half duplex mode through 8-bit DMA channel by disabling their
16-bit DMA channel.

The power-management is supported.


\subsection{Module snd-sc6000}
\label{sound/alsa-configuration:module-snd-sc6000}
Module for Gallant SC-6000 soundcard and later models: SC-6600 and
SC-7000.
\begin{description}
\item[{port}] \leavevmode
Port \# (0x220 or 0x240)

\item[{mss\_port}] \leavevmode
MSS Port \# (0x530 or 0xe80)

\item[{irq}] \leavevmode
IRQ \# (5,7,9,10,11)

\item[{mpu\_irq}] \leavevmode
MPU-401 IRQ \# (5,7,9,10) ,0 - no MPU-401 irq

\item[{dma}] \leavevmode
DMA \# (1,3,0)

\item[{joystick}] \leavevmode
Enable gameport - 0 = disable (default), 1 = enable

\end{description}

This module supports multiple cards.

This card is also known as Audio Excel DSP 16 or Zoltrix AV302.


\subsection{Module snd-sscape}
\label{sound/alsa-configuration:module-snd-sscape}
Module for ENSONIQ SoundScape cards.
\begin{description}
\item[{port}] \leavevmode
Port \# (PnP setup)

\item[{wss\_port}] \leavevmode
WSS Port \# (PnP setup)

\item[{irq}] \leavevmode
IRQ \# (PnP setup)

\item[{mpu\_irq}] \leavevmode
MPU-401 IRQ \# (PnP setup)

\item[{dma}] \leavevmode
DMA \# (PnP setup)

\item[{dma2}] \leavevmode
2nd DMA \# (PnP setup, -1 to disable)

\item[{joystick}] \leavevmode
Enable gameport - 0 = disable (default), 1 = enable

\end{description}

This module supports multiple cards.

The driver requires the firmware loader support on kernel.


\subsection{Module snd-sun-amd7930 (on sparc only)}
\label{sound/alsa-configuration:module-snd-sun-amd7930-on-sparc-only}
Module for AMD7930 sound chips found on Sparcs.

This module supports multiple cards.


\subsection{Module snd-sun-cs4231 (on sparc only)}
\label{sound/alsa-configuration:module-snd-sun-cs4231-on-sparc-only}
Module for CS4231 sound chips found on Sparcs.

This module supports multiple cards.


\subsection{Module snd-sun-dbri (on sparc only)}
\label{sound/alsa-configuration:module-snd-sun-dbri-on-sparc-only}
Module for DBRI sound chips found on Sparcs.

This module supports multiple cards.


\subsection{Module snd-wavefront}
\label{sound/alsa-configuration:module-snd-wavefront}
Module for Turtle Beach Maui, Tropez and Tropez+ sound cards.
\begin{description}
\item[{use\_cs4232\_midi}] \leavevmode
Use CS4232 MPU-401 interface
(inaccessibly located inside your computer)

\item[{isapnp}] \leavevmode
ISA PnP detection - 0 = disable, 1 = enable (default)

\end{description}

with isapnp=0, the following options are available:
\begin{description}
\item[{cs4232\_pcm\_port}] \leavevmode
Port \# for CS4232 PCM interface.

\item[{cs4232\_pcm\_irq}] \leavevmode
IRQ \# for CS4232 PCM interface (5,7,9,11,12,15).

\item[{cs4232\_mpu\_port}] \leavevmode
Port \# for CS4232 MPU-401 interface.

\item[{cs4232\_mpu\_irq}] \leavevmode
IRQ \# for CS4232 MPU-401 interface (9,11,12,15).

\item[{ics2115\_port}] \leavevmode
Port \# for ICS2115

\item[{ics2115\_irq}] \leavevmode
IRQ \# for ICS2115

\item[{fm\_port}] \leavevmode
FM OPL-3 Port \#

\item[{dma1}] \leavevmode
DMA1 \# for CS4232 PCM interface.

\item[{dma2}] \leavevmode
DMA2 \# for CS4232 PCM interface.

\end{description}

The below are options for wavefront\_synth features:
\begin{description}
\item[{wf\_raw}] \leavevmode
Assume that we need to boot the OS (default:no);
If yes, then during driver loading, the state of the board is
ignored, and we reset the board and load the firmware anyway.

\item[{fx\_raw}] \leavevmode
Assume that the FX process needs help (default:yes);
If false, we'll leave the FX processor in whatever state it is
when the driver is loaded.  The default is to download the
microprogram and associated coefficients to set it up for
``default'' operation, whatever that means.

\item[{debug\_default}] \leavevmode
Debug parameters for card initialization

\item[{wait\_usecs}] \leavevmode
How long to wait without sleeping, usecs (default:150);
This magic number seems to give pretty optimal throughput
based on my limited experimentation.
If you want to play around with it and find a better value, be
my guest. Remember, the idea is to get a number that causes us
to just busy wait for as many WaveFront commands as possible,
without coming up with a number so large that we hog the whole
CPU.
Specifically, with this number, out of about 134,000 status
waits, only about 250 result in a sleep.

\item[{sleep\_interval}] \leavevmode
How long to sleep when waiting for reply (default: 100)

\item[{sleep\_tries}] \leavevmode
How many times to try sleeping during a wait (default: 50)

\item[{ospath}] \leavevmode
Pathname to processed ICS2115 OS firmware (default:wavefront.os);
The path name of the ISC2115 OS firmware.  In the recent
version, it's handled via firmware loader framework, so it
must be installed in the proper path, typically,
/lib/firmware.

\item[{reset\_time}] \leavevmode
How long to wait for a reset to take effect (default:2)

\item[{ramcheck\_time}] \leavevmode
How many seconds to wait for the RAM test (default:20)

\item[{osrun\_time}] \leavevmode
How many seconds to wait for the ICS2115 OS (default:10)

\end{description}

This module supports multiple cards and ISA PnP.

Note: the firmware file \code{wavefront.os} was located in the earlier
version in /etc.  Now it's loaded via firmware loader, and
must be in the proper firmware path, such as /lib/firmware.
Copy (or symlink) the file appropriately if you get an error
regarding firmware downloading after upgrading the kernel.


\subsection{Module snd-sonicvibes}
\label{sound/alsa-configuration:module-snd-sonicvibes}
Module for S3 SonicVibes PCI sound cards.
* PINE Schubert 32 PCI
\begin{description}
\item[{reverb}] \leavevmode
Reverb Enable - 1 = enable, 0 = disable (default);
SoundCard must have onboard SRAM for this.

\item[{mge}] \leavevmode
Mic Gain Enable - 1 = enable, 0 = disable (default)

\end{description}

This module supports multiple cards and autoprobe.


\subsection{Module snd-serial-u16550}
\label{sound/alsa-configuration:module-snd-serial-u16550}
Module for UART16550A serial MIDI ports.
\begin{description}
\item[{port}] \leavevmode
port \# for UART16550A chip

\item[{irq}] \leavevmode
IRQ \# for UART16550A chip, -1 = poll mode

\item[{speed}] \leavevmode
speed in bauds (9600,19200,38400,57600,115200)
38400 = default

\item[{base}] \leavevmode
base for divisor in bauds (57600,115200,230400,460800)
115200 = default

\item[{outs}] \leavevmode
number of MIDI ports in a serial port (1-4)
1 = default

\item[{adaptor}] \leavevmode\begin{description}
\item[{Type of adaptor.}] \leavevmode
0 = Soundcanvas, 1 = MS-124T, 2 = MS-124W S/A,
3 = MS-124W M/B, 4 = Generic

\end{description}

\end{description}

This module supports multiple cards. This module does not support autoprobe
thus the main port must be specified!!! Other options are optional.


\subsection{Module snd-trident}
\label{sound/alsa-configuration:module-snd-trident}
Module for Trident 4DWave DX/NX sound cards.
* Best Union  Miss Melody 4DWave PCI
* HIS  4DWave PCI
* Warpspeed  ONSpeed 4DWave PCI
* AzTech  PCI 64-Q3D
* Addonics  SV 750
* CHIC  True Sound 4Dwave
* Shark  Predator4D-PCI
* Jaton  SonicWave 4D
* SiS SI7018 PCI Audio
* Hoontech SoundTrack Digital 4DWave NX
\begin{description}
\item[{pcm\_channels}] \leavevmode
max channels (voices) reserved for PCM

\item[{wavetable\_size}] \leavevmode
max wavetable size in kB (4-?kb)

\end{description}

This module supports multiple cards and autoprobe.

The power-management is supported.


\subsection{Module snd-ua101}
\label{sound/alsa-configuration:module-snd-ua101}
Module for the Edirol UA-101/UA-1000 audio/MIDI interfaces.

This module supports multiple devices, autoprobe and hotplugging.


\subsection{Module snd-usb-audio}
\label{sound/alsa-configuration:module-snd-usb-audio}
Module for USB audio and USB MIDI devices.
\begin{description}
\item[{vid}] \leavevmode
Vendor ID for the device (optional)

\item[{pid}] \leavevmode
Product ID for the device (optional)

\item[{nrpacks}] \leavevmode
Max. number of packets per URB (default: 8)

\item[{device\_setup}] \leavevmode
Device specific magic number (optional);
Influence depends on the device
Default: 0x0000

\item[{ignore\_ctl\_error}] \leavevmode
Ignore any USB-controller regarding mixer interface (default: no)

\item[{autoclock}] \leavevmode
Enable auto-clock selection for UAC2 devices (default: yes)

\item[{quirk\_alias}] \leavevmode
Quirk alias list, pass strings like \code{0123abcd:5678beef}, which
applies the existing quirk for the device 5678:beef to a new
device 0123:abcd.

\end{description}

This module supports multiple devices, autoprobe and hotplugging.

NB: \code{nrpacks} parameter can be modified dynamically via sysfs.
Don't put the value over 20.  Changing via sysfs has no sanity
check.

NB: \code{ignore\_ctl\_error=1} may help when you get an error at accessing
the mixer element such as URB error -22.  This happens on some
buggy USB device or the controller.

NB: quirk\_alias option is provided only for testing / development.
If you want to have a proper support, contact to upstream for
adding the matching quirk in the driver code statically.


\subsection{Module snd-usb-caiaq}
\label{sound/alsa-configuration:module-snd-usb-caiaq}
Module for caiaq UB audio interfaces,
\begin{itemize}
\item {} 
Native Instruments RigKontrol2

\item {} 
Native Instruments Kore Controller

\item {} 
Native Instruments Audio Kontrol 1

\item {} 
Native Instruments Audio 8 DJ

\end{itemize}

This module supports multiple devices, autoprobe and hotplugging.


\subsection{Module snd-usb-usx2y}
\label{sound/alsa-configuration:module-snd-usb-usx2y}
Module for Tascam USB US-122, US-224 and US-428 devices.

This module supports multiple devices, autoprobe and hotplugging.

Note: you need to load the firmware via \code{usx2yloader} utility included
in alsa-tools and alsa-firmware packages.


\subsection{Module snd-via82xx}
\label{sound/alsa-configuration:module-snd-via82xx}
Module for AC`97 motherboards based on VIA 82C686A/686B, 8233, 8233A,
8233C, 8235, 8237 (south) bridge.
\begin{description}
\item[{mpu\_port}] \leavevmode
0x300,0x310,0x320,0x330, otherwise obtain BIOS setup
{[}VIA686A/686B only{]}

\item[{joystick}] \leavevmode
Enable joystick (default off) {[}VIA686A/686B only{]}

\item[{ac97\_clock}] \leavevmode
AC`97 codec clock base (default 48000Hz)

\item[{dxs\_support}] \leavevmode
support DXS channels, 0 = auto (default), 1 = enable, 2 = disable,
3 = 48k only, 4 = no VRA, 5 = enable any sample rate and different
sample rates on different channels {[}VIA8233/C, 8235, 8237 only{]}

\item[{ac97\_quirk}] \leavevmode
AC`97 workaround for strange hardware;
See {\hyperref[sound/alsa\string-configuration:ac97\string-quirk\string-option]{\emph{AC97 Quirk Option}}} section below.

\end{description}

This module supports one chip and autoprobe.

Note: on some SMP motherboards like MSI 694D the interrupts might
not be generated properly.  In such a case, please try to
set the SMP (or MPS) version on BIOS to 1.1 instead of
default value 1.4.  Then the interrupt number will be
assigned under 15. You might also upgrade your BIOS.

Note: VIA8233/5/7 (not VIA8233A) can support DXS (direct sound)
channels as the first PCM.  On these channels, up to 4
streams can be played at the same time, and the controller
can perform sample rate conversion with separate rates for
each channel.
As default (\code{dxs\_support = 0}), 48k fixed rate is chosen
except for the known devices since the output is often
noisy except for 48k on some mother boards due to the
bug of BIOS.
Please try once \code{dxs\_support=5} and if it works on other
sample rates (e.g. 44.1kHz of mp3 playback), please let us
know the PCI subsystem vendor/device id's (output of
\code{lspci -nv}).
If \code{dxs\_support=5} does not work, try \code{dxs\_support=4}; if it
doesn't work too, try dxs\_support=1.  (dxs\_support=1 is
usually for old motherboards.  The correct implemented
board should work with 4 or 5.)  If it still doesn't
work and the default setting is ok, \code{dxs\_support=3} is the
right choice.  If the default setting doesn't work at all,
try \code{dxs\_support=2} to disable the DXS channels.
In any cases, please let us know the result and the
subsystem vendor/device ids.  See {\hyperref[sound/alsa\string-configuration:links\string-and\string-addresses]{\emph{Links and Addresses}}}
below.

Note: for the MPU401 on VIA823x, use snd-mpu401 driver
additionally.  The mpu\_port option is for VIA686 chips only.

The power-management is supported.


\subsection{Module snd-via82xx-modem}
\label{sound/alsa-configuration:module-snd-via82xx-modem}
Module for VIA82xx AC97 modem
\begin{description}
\item[{ac97\_clock}] \leavevmode
AC`97 codec clock base (default 48000Hz)

\end{description}

This module supports one card and autoprobe.

Note: The default index value of this module is -2, i.e. the first
slot is excluded.

The power-management is supported.


\subsection{Module snd-virmidi}
\label{sound/alsa-configuration:module-snd-virmidi}
Module for virtual rawmidi devices.
This module creates virtual rawmidi devices which communicate
to the corresponding ALSA sequencer ports.
\begin{description}
\item[{midi\_devs}] \leavevmode
MIDI devices \# (1-4, default=4)

\end{description}

This module supports multiple cards.


\subsection{Module snd-virtuoso}
\label{sound/alsa-configuration:module-snd-virtuoso}
Module for sound cards based on the Asus AV66/AV100/AV200 chips,
i.e., Xonar D1, DX, D2, D2X, DS, DSX, Essence ST (Deluxe),
Essence STX (II), HDAV1.3 (Deluxe), and HDAV1.3 Slim.

This module supports autoprobe and multiple cards.


\subsection{Module snd-vx222}
\label{sound/alsa-configuration:module-snd-vx222}
Module for Digigram VX-Pocket VX222, V222 v2 and Mic cards.
\begin{description}
\item[{mic}] \leavevmode
Enable Microphone on V222 Mic (NYI)

\item[{ibl}] \leavevmode
Capture IBL size. (default = 0, minimum size)

\end{description}

This module supports multiple cards.

When the driver is compiled as a module and the hotplug firmware
is supported, the firmware data is loaded via hotplug automatically.
Install the necessary firmware files in alsa-firmware package.
When no hotplug fw loader is available, you need to load the
firmware via vxloader utility in alsa-tools package.  To invoke
vxloader automatically, add the following to /etc/modprobe.d/alsa.conf

\begin{Verbatim}[commandchars=\\\{\}]
install snd\PYGZhy{}vx222 /sbin/modprobe \PYGZhy{}\PYGZhy{}first\PYGZhy{}time \PYGZhy{}i snd\PYGZhy{}vx222\PYGZbs{}
  \PYGZam{}\PYGZam{} /usr/bin/vxloader
\end{Verbatim}

(for 2.2/2.4 kernels, add \code{post-install /usr/bin/vxloader} to
/etc/modules.conf, instead.)
IBL size defines the interrupts period for PCM.  The smaller size
gives smaller latency but leads to more CPU consumption, too.
The size is usually aligned to 126.  As default (=0), the smallest
size is chosen.  The possible IBL values can be found in
/proc/asound/cardX/vx-status proc file.

The power-management is supported.


\subsection{Module snd-vxpocket}
\label{sound/alsa-configuration:module-snd-vxpocket}
Module for Digigram VX-Pocket VX2 and 440 PCMCIA cards.
\begin{description}
\item[{ibl}] \leavevmode
Capture IBL size. (default = 0, minimum size)

\end{description}

This module supports multiple cards.  The module is compiled only when
PCMCIA is supported on kernel.

With the older 2.6.x kernel, to activate the driver via the card
manager, you'll need to set up /etc/pcmcia/vxpocket.conf.  See the
sound/pcmcia/vx/vxpocket.c.  2.6.13 or later kernel requires no
longer require a config file.

When the driver is compiled as a module and the hotplug firmware
is supported, the firmware data is loaded via hotplug automatically.
Install the necessary firmware files in alsa-firmware package.
When no hotplug fw loader is available, you need to load the
firmware via vxloader utility in alsa-tools package.

About capture IBL, see the description of snd-vx222 module.

Note: snd-vxp440 driver is merged to snd-vxpocket driver since
ALSA 1.0.10.

The power-management is supported.


\subsection{Module snd-ymfpci}
\label{sound/alsa-configuration:module-snd-ymfpci}
Module for Yamaha PCI chips (YMF72x, YMF74x \& YMF75x).
\begin{description}
\item[{mpu\_port}] \leavevmode
0x300,0x330,0x332,0x334, 0 (disable) by default,
1 (auto-detect for YMF744/754 only)

\item[{fm\_port}] \leavevmode
0x388,0x398,0x3a0,0x3a8, 0 (disable) by default
1 (auto-detect for YMF744/754 only)

\item[{joystick\_port}] \leavevmode
0x201,0x202,0x204,0x205, 0 (disable) by default,
1 (auto-detect)

\item[{rear\_switch}] \leavevmode
enable shared rear/line-in switch (bool)

\end{description}

This module supports autoprobe and multiple chips.

The power-management is supported.


\subsection{Module snd-pdaudiocf}
\label{sound/alsa-configuration:module-snd-pdaudiocf}
Module for Sound Core PDAudioCF sound card.

The power-management is supported.


\section{AC97 Quirk Option}
\label{sound/alsa-configuration:ac97-quirk-option}
The ac97\_quirk option is used to enable/override the workaround for
specific devices on drivers for on-board AC`97 controllers like
snd-intel8x0.  Some hardware have swapped output pins between Master
and Headphone, or Surround (thanks to confusion of AC`97
specifications from version to version :-)

The driver provides the auto-detection of known problematic devices,
but some might be unknown or wrongly detected.  In such a case, pass
the proper value with this option.

The following strings are accepted:
\begin{description}
\item[{default}] \leavevmode
Don't override the default setting

\item[{none}] \leavevmode
Disable the quirk

\item[{hp\_only}] \leavevmode
Bind Master and Headphone controls as a single control

\item[{swap\_hp}] \leavevmode
Swap headphone and master controls

\item[{swap\_surround}] \leavevmode
Swap master and surround controls

\item[{ad\_sharing}] \leavevmode
For AD1985, turn on OMS bit and use headphone

\item[{alc\_jack}] \leavevmode
For ALC65x, turn on the jack sense mode

\item[{inv\_eapd}] \leavevmode
Inverted EAPD implementation

\item[{mute\_led}] \leavevmode
Bind EAPD bit for turning on/off mute LED

\end{description}

For backward compatibility, the corresponding integer value -1, 0, ...
are  accepted, too.

For example, if \code{Master} volume control has no effect on your device
but only \code{Headphone} does, pass ac97\_quirk=hp\_only module option.


\section{Configuring Non-ISAPNP Cards}
\label{sound/alsa-configuration:configuring-non-isapnp-cards}
When the kernel is configured with ISA-PnP support, the modules
supporting the isapnp cards will have module options \code{isapnp}.
If this option is set, \emph{only} the ISA-PnP devices will be probed.
For probing the non ISA-PnP cards, you have to pass \code{isapnp=0} option
together with the proper i/o and irq configuration.

When the kernel is configured without ISA-PnP support, isapnp option
will be not built in.


\section{Module Autoloading Support}
\label{sound/alsa-configuration:module-autoloading-support}
The ALSA drivers can be loaded automatically on demand by defining
module aliases.  The string \code{snd-card-\%1} is requested for ALSA native
devices where \code{\%i} is sound card number from zero to seven.

To auto-load an ALSA driver for OSS services, define the string
\code{sound-slot-\%i} where \code{\%i} means the slot number for OSS, which
corresponds to the card index of ALSA.  Usually, define this
as the same card module.

An example configuration for a single emu10k1 card is like below:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} /etc/modprobe.d/alsa.conf
alias snd\PYGZhy{}card\PYGZhy{}0 snd\PYGZhy{}emu10k1
alias sound\PYGZhy{}slot\PYGZhy{}0 snd\PYGZhy{}emu10k1
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} /etc/modprobe.d/alsa.conf
\end{Verbatim}

The available number of auto-loaded sound cards depends on the module
option \code{cards\_limit} of snd module.  As default it's set to 1.
To enable the auto-loading of multiple cards, specify the number of
sound cards in that option.

When multiple cards are available, it'd better to specify the index
number for each card via module option, too, so that the order of
cards is kept consistent.

An example configuration for two sound cards is like below:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} /etc/modprobe.d/alsa.conf
\PYGZsh{} ALSA portion
options snd cards\PYGZus{}limit=2
alias snd\PYGZhy{}card\PYGZhy{}0 snd\PYGZhy{}interwave
alias snd\PYGZhy{}card\PYGZhy{}1 snd\PYGZhy{}ens1371
options snd\PYGZhy{}interwave index=0
options snd\PYGZhy{}ens1371 index=1
\PYGZsh{} OSS/Free portion
alias sound\PYGZhy{}slot\PYGZhy{}0 snd\PYGZhy{}interwave
alias sound\PYGZhy{}slot\PYGZhy{}1 snd\PYGZhy{}ens1371
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} /etc/modprobe.d/alsa.conf
\end{Verbatim}

In this example, the interwave card is always loaded as the first card
(index 0) and ens1371 as the second (index 1).

Alternative (and new) way to fixate the slot assignment is to use
\code{slots} option of snd module.  In the case above, specify like the
following:

\begin{Verbatim}[commandchars=\\\{\}]
options snd slots=snd\PYGZhy{}interwave,snd\PYGZhy{}ens1371
\end{Verbatim}

Then, the first slot (\#0) is reserved for snd-interwave driver, and
the second (\#1) for snd-ens1371.  You can omit index option in each
driver if slots option is used (although you can still have them at
the same time as long as they don't conflict).

The slots option is especially useful for avoiding the possible
hot-plugging and the resultant slot conflict.  For example, in the
case above again, the first two slots are already reserved.  If any
other driver (e.g. snd-usb-audio) is loaded before snd-interwave or
snd-ens1371, it will be assigned to the third or later slot.

When a module name is given with `!', the slot will be given for any
modules but that name.  For example, \code{slots=!snd-pcsp} will reserve
the first slot for any modules but snd-pcsp.


\section{ALSA PCM devices to OSS devices mapping}
\label{sound/alsa-configuration:alsa-pcm-devices-to-oss-devices-mapping}
\begin{Verbatim}[commandchars=\\\{\}]
/dev/snd/pcmC0D0[c\textbar{}p]  \PYGZhy{}\PYGZgt{} /dev/audio0 (/dev/audio) \PYGZhy{}\PYGZgt{} minor 4
/dev/snd/pcmC0D0[c\textbar{}p]  \PYGZhy{}\PYGZgt{} /dev/dsp0 (/dev/dsp)     \PYGZhy{}\PYGZgt{} minor 3
/dev/snd/pcmC0D1[c\textbar{}p]  \PYGZhy{}\PYGZgt{} /dev/adsp0 (/dev/adsp)   \PYGZhy{}\PYGZgt{} minor 12
/dev/snd/pcmC1D0[c\textbar{}p]  \PYGZhy{}\PYGZgt{} /dev/audio1              \PYGZhy{}\PYGZgt{} minor 4+16 = 20
/dev/snd/pcmC1D0[c\textbar{}p]  \PYGZhy{}\PYGZgt{} /dev/dsp1                \PYGZhy{}\PYGZgt{} minor 3+16 = 19
/dev/snd/pcmC1D1[c\textbar{}p]  \PYGZhy{}\PYGZgt{} /dev/adsp1               \PYGZhy{}\PYGZgt{} minor 12+16 = 28
/dev/snd/pcmC2D0[c\textbar{}p]  \PYGZhy{}\PYGZgt{} /dev/audio2              \PYGZhy{}\PYGZgt{} minor 4+32 = 36
/dev/snd/pcmC2D0[c\textbar{}p]  \PYGZhy{}\PYGZgt{} /dev/dsp2                \PYGZhy{}\PYGZgt{} minor 3+32 = 39
/dev/snd/pcmC2D1[c\textbar{}p]  \PYGZhy{}\PYGZgt{} /dev/adsp2               \PYGZhy{}\PYGZgt{} minor 12+32 = 44
\end{Verbatim}

The first number from \code{/dev/snd/pcmC\{X\}D\{Y\}{[}c\textbar{}p{]}} expression means
sound card number and second means device number.  The ALSA devices
have either \code{c} or \code{p} suffix indicating the direction, capture and
playback, respectively.

Please note that the device mapping above may be varied via the module
options of snd-pcm-oss module.


\section{Proc interfaces (/proc/asound)}
\label{sound/alsa-configuration:proc-interfaces-proc-asound}

\subsection{/proc/asound/card\#/pcm\#{[}cp{]}/oss}
\label{sound/alsa-configuration:proc-asound-card-pcm-cp-oss}\begin{description}
\item[{erase}] \leavevmode
erase all additional information about OSS applications

\item[{\textless{}app\_name\textgreater{} \textless{}fragments\textgreater{} \textless{}fragment\_size\textgreater{} {[}\textless{}options\textgreater{}{]}}] \leavevmode\begin{description}
\item[{\textless{}app\_name\textgreater{}}] \leavevmode
name of application with (higher priority) or without path

\item[{\textless{}fragments\textgreater{}}] \leavevmode
number of fragments or zero if auto

\item[{\textless{}fragment\_size\textgreater{}}] \leavevmode
size of fragment in bytes or zero if auto

\item[{\textless{}options\textgreater{}}] \leavevmode
optional parameters
\begin{description}
\item[{disable}] \leavevmode
the application tries to open a pcm device for
this channel but does not want to use it.
(Cause a bug or mmap needs)
It's good for Quake etc...

\item[{direct}] \leavevmode
don't use plugins

\item[{block}] \leavevmode
force block mode (rvplayer)

\item[{non-block}] \leavevmode
force non-block mode

\item[{whole-frag}] \leavevmode
write only whole fragments (optimization affecting
playback only)

\item[{no-silence}] \leavevmode
do not fill silence ahead to avoid clicks

\item[{buggy-ptr}] \leavevmode
Returns the whitespace blocks in GETOPTR ioctl
instead of filled blocks

\end{description}

\end{description}

\end{description}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
echo \PYGZdq{}x11amp 128 16384\PYGZdq{} \PYGZgt{} /proc/asound/card0/pcm0p/oss
echo \PYGZdq{}squake 0 0 disable\PYGZdq{} \PYGZgt{} /proc/asound/card0/pcm0c/oss
echo \PYGZdq{}rvplayer 0 0 block\PYGZdq{} \PYGZgt{} /proc/asound/card0/pcm0p/oss
\end{Verbatim}


\section{Early Buffer Allocation}
\label{sound/alsa-configuration:early-buffer-allocation}
Some drivers (e.g. hdsp) require the large contiguous buffers, and
sometimes it's too late to find such spaces when the driver module is
actually loaded due to memory fragmentation.  You can pre-allocate the
PCM buffers by loading snd-page-alloc module and write commands to its
proc file in prior, for example, in the early boot stage like
\code{/etc/init.d/*.local} scripts.

Reading the proc file /proc/drivers/snd-page-alloc shows the current
usage of page allocation.  In writing, you can send the following
commands to the snd-page-alloc driver:
\begin{itemize}
\item {} 
add VENDOR DEVICE MASK SIZE BUFFERS

\end{itemize}

VENDOR and DEVICE are PCI vendor and device IDs.  They take
integer numbers (0x prefix is needed for the hex).
MASK is the PCI DMA mask.  Pass 0 if not restricted.
SIZE is the size of each buffer to allocate.  You can pass
k and m suffix for KB and MB.  The max number is 16MB.
BUFFERS is the number of buffers to allocate.  It must be greater
than 0.  The max number is 4.
\begin{itemize}
\item {} 
erase

\end{itemize}

This will erase the all pre-allocated buffers which are not in
use.


\section{Links and Addresses}
\label{sound/alsa-configuration:links-and-addresses}\begin{description}
\item[{ALSA project homepage}] \leavevmode
\href{http://www.alsa-project.org}{http://www.alsa-project.org}

\item[{Kernel Bugzilla}] \leavevmode
\href{http://bugzilla.kernel.org/}{http://bugzilla.kernel.org/}

\item[{ALSA Developers ML}] \leavevmode
\href{mailto:alsa-devel@alsa-project.org}{mailto:alsa-devel@alsa-project.org}

\item[{alsa-info.sh script}] \leavevmode
\href{http://www.alsa-project.org/alsa-info.sh}{http://www.alsa-project.org/alsa-info.sh}

\end{description}


\chapter{HD-Audio}
\label{sound/hd-audio/index::doc}\label{sound/hd-audio/index:hd-audio}

\section{More Notes on HD-Audio Driver}
\label{sound/hd-audio/notes::doc}\label{sound/hd-audio/notes:more-notes-on-hd-audio-driver}
Takashi Iwai \textless{}\href{mailto:tiwai@suse.de}{tiwai@suse.de}\textgreater{}


\subsection{General}
\label{sound/hd-audio/notes:general}
HD-audio is the new standard on-board audio component on modern PCs
after AC97.  Although Linux has been supporting HD-audio since long
time ago, there are often problems with new machines.  A part of the
problem is broken BIOS, and the rest is the driver implementation.
This document explains the brief trouble-shooting and debugging
methods for the HD-audio hardware.

The HD-audio component consists of two parts: the controller chip and
the codec chips on the HD-audio bus.  Linux provides a single driver
for all controllers, snd-hda-intel.  Although the driver name contains
a word of a well-known hardware vendor, it's not specific to it but for
all controller chips by other companies.  Since the HD-audio
controllers are supposed to be compatible, the single snd-hda-driver
should work in most cases.  But, not surprisingly, there are known
bugs and issues specific to each controller type.  The snd-hda-intel
driver has a bunch of workarounds for these as described below.

A controller may have multiple codecs.  Usually you have one audio
codec and optionally one modem codec.  In theory, there might be
multiple audio codecs, e.g. for analog and digital outputs, and the
driver might not work properly because of conflict of mixer elements.
This should be fixed in future if such hardware really exists.

The snd-hda-intel driver has several different codec parsers depending
on the codec.  It has a generic parser as a fallback, but this
functionality is fairly limited until now.  Instead of the generic
parser, usually the codec-specific parser (coded in patch\_*.c) is used
for the codec-specific implementations.  The details about the
codec-specific problems are explained in the later sections.

If you are interested in the deep debugging of HD-audio, read the
HD-audio specification at first.  The specification is found on
Intel's web page, for example:
\begin{itemize}
\item {} 
\href{http://www.intel.com/standards/hdaudio/}{http://www.intel.com/standards/hdaudio/}

\end{itemize}


\subsection{HD-Audio Controller}
\label{sound/hd-audio/notes:hd-audio-controller}

\subsubsection{DMA-Position Problem}
\label{sound/hd-audio/notes:dma-position-problem}
The most common problem of the controller is the inaccurate DMA
pointer reporting.  The DMA pointer for playback and capture can be
read in two ways, either via a LPIB register or via a position-buffer
map.  As default the driver tries to read from the io-mapped
position-buffer, and falls back to LPIB if the position-buffer appears
dead.  However, this detection isn't perfect on some devices.  In such
a case, you can change the default method via \code{position\_fix} option.

\code{position\_fix=1} means to use LPIB method explicitly.
\code{position\_fix=2} means to use the position-buffer.
\code{position\_fix=3} means to use a combination of both methods, needed
for some VIA controllers.  The capture stream position is corrected
by comparing both LPIB and position-buffer values.
\code{position\_fix=4} is another combination available for all controllers,
and uses LPIB for the playback and the position-buffer for the capture
streams.
0 is the default value for all other
controllers, the automatic check and fallback to LPIB as described in
the above.  If you get a problem of repeated sounds, this option might
help.

In addition to that, every controller is known to be broken regarding
the wake-up timing.  It wakes up a few samples before actually
processing the data on the buffer.  This caused a lot of problems, for
example, with ALSA dmix or JACK.  Since 2.6.27 kernel, the driver puts
an artificial delay to the wake up timing.  This delay is controlled
via \code{bdl\_pos\_adj} option.

When \code{bdl\_pos\_adj} is a negative value (as default), it's assigned to
an appropriate value depending on the controller chip.  For Intel
chips, it'd be 1 while it'd be 32 for others.  Usually this works.
Only in case it doesn't work and you get warning messages, you should
change this parameter to other values.


\subsubsection{Codec-Probing Problem}
\label{sound/hd-audio/notes:codec-probing-problem}
A less often but a more severe problem is the codec probing.  When
BIOS reports the available codec slots wrongly, the driver gets
confused and tries to access the non-existing codec slot.  This often
results in the total screw-up, and destructs the further communication
with the codec chips.  The symptom appears usually as error messages
like:

\begin{Verbatim}[commandchars=\\\{\}]
hda\PYGZus{}intel: azx\PYGZus{}get\PYGZus{}response timeout, switching to polling mode:
      last cmd=0x12345678
hda\PYGZus{}intel: azx\PYGZus{}get\PYGZus{}response timeout, switching to single\PYGZus{}cmd mode:
      last cmd=0x12345678
\end{Verbatim}

The first line is a warning, and this is usually relatively harmless.
It means that the codec response isn't notified via an IRQ.  The
driver uses explicit polling method to read the response.  It gives
very slight CPU overhead, but you'd unlikely notice it.

The second line is, however, a fatal error.  If this happens, usually
it means that something is really wrong.  Most likely you are
accessing a non-existing codec slot.

Thus, if the second error message appears, try to narrow the probed
codec slots via \code{probe\_mask} option.  It's a bitmask, and each bit
corresponds to the codec slot.  For example, to probe only the first
slot, pass \code{probe\_mask=1}.  For the first and the third slots, pass
\code{probe\_mask=5} (where 5 = 1 \textbar{} 4), and so on.

Since 2.6.29 kernel, the driver has a more robust probing method, so
this error might happen rarely, though.

On a machine with a broken BIOS, sometimes you need to force the
driver to probe the codec slots the hardware doesn't report for use.
In such a case, turn the bit 8 (0x100) of \code{probe\_mask} option on.
Then the rest 8 bits are passed as the codec slots to probe
unconditionally.  For example, \code{probe\_mask=0x103} will force to probe
the codec slots 0 and 1 no matter what the hardware reports.


\subsubsection{Interrupt Handling}
\label{sound/hd-audio/notes:interrupt-handling}
HD-audio driver uses MSI as default (if available) since 2.6.33
kernel as MSI works better on some machines, and in general, it's
better for performance.  However, Nvidia controllers showed bad
regressions with MSI (especially in a combination with AMD chipset),
thus we disabled MSI for them.

There seem also still other devices that don't work with MSI.  If you
see a regression wrt the sound quality (stuttering, etc) or a lock-up
in the recent kernel, try to pass \code{enable\_msi=0} option to disable
MSI.  If it works, you can add the known bad device to the blacklist
defined in hda\_intel.c.  In such a case, please report and give the
patch back to the upstream developer.


\subsection{HD-Audio Codec}
\label{sound/hd-audio/notes:hd-audio-codec}

\subsubsection{Model Option}
\label{sound/hd-audio/notes:model-option}
The most common problem regarding the HD-audio driver is the
unsupported codec features or the mismatched device configuration.
Most of codec-specific code has several preset models, either to
override the BIOS setup or to provide more comprehensive features.

The driver checks PCI SSID and looks through the static configuration
table until any matching entry is found.  If you have a new machine,
you may see a message like below:

\begin{Verbatim}[commandchars=\\\{\}]
hda\PYGZus{}codec: ALC880: BIOS auto\PYGZhy{}probing.
\end{Verbatim}

Meanwhile, in the earlier versions, you would see a message like:

\begin{Verbatim}[commandchars=\\\{\}]
hda\PYGZus{}codec: Unknown model for ALC880, trying auto\PYGZhy{}probe from BIOS...
\end{Verbatim}

Even if you see such a message, DON'T PANIC.  Take a deep breath and
keep your towel.  First of all, it's an informational message, no
warning, no error.  This means that the PCI SSID of your device isn't
listed in the known preset model (white-)list.  But, this doesn't mean
that the driver is broken.  Many codec-drivers provide the automatic
configuration mechanism based on the BIOS setup.

The HD-audio codec has usually ``pin'' widgets, and BIOS sets the default
configuration of each pin, which indicates the location, the
connection type, the jack color, etc.  The HD-audio driver can guess
the right connection judging from these default configuration values.
However -- some codec-support codes, such as patch\_analog.c, don't
support the automatic probing (yet as of 2.6.28).  And, BIOS is often,
yes, pretty often broken.  It sets up wrong values and screws up the
driver.

The preset model (or recently called as ``fix-up'') is provided
basically to overcome such a situation.  When the matching preset
model is found in the white-list, the driver assumes the static
configuration of that preset with the correct pin setup, etc.
Thus, if you have a newer machine with a slightly different PCI SSID
(or codec SSID) from the existing one, you may have a good chance to
re-use the same model.  You can pass the \code{model} option to specify the
preset model instead of PCI (and codec-) SSID look-up.

What \code{model} option values are available depends on the codec chip.
Check your codec chip from the codec proc file (see ``Codec Proc-File''
section below).  It will show the vendor/product name of your codec
chip.  Then, see Documentation/sound/hd-audio/models.rst file,
the section of HD-audio driver.  You can find a list of codecs
and \code{model} options belonging to each codec.  For example, for Realtek
ALC262 codec chip, pass \code{model=ultra} for devices that are compatible
with Samsung Q1 Ultra.

Thus, the first thing you can do for any brand-new, unsupported and
non-working HD-audio hardware is to check HD-audio codec and several
different \code{model} option values.  If you have any luck, some of them
might suit with your device well.

There are a few special model option values:
\begin{itemize}
\item {} 
when `nofixup' is passed, the device-specific fixups in the codec
parser are skipped.

\item {} 
when \code{generic} is passed, the codec-specific parser is skipped and
only the generic parser is used.

\end{itemize}


\subsubsection{Speaker and Headphone Output}
\label{sound/hd-audio/notes:speaker-and-headphone-output}
One of the most frequent (and obvious) bugs with HD-audio is the
silent output from either or both of a built-in speaker and a
headphone jack.  In general, you should try a headphone output at
first.  A speaker output often requires more additional controls like
the external amplifier bits.  Thus a headphone output has a slightly
better chance.

Before making a bug report, double-check whether the mixer is set up
correctly.  The recent version of snd-hda-intel driver provides mostly
``Master'' volume control as well as ``Front'' volume (where Front
indicates the front-channels).  In addition, there can be individual
``Headphone'' and ``Speaker'' controls.

Ditto for the speaker output.  There can be ``External Amplifier''
switch on some codecs.  Turn on this if present.

Another related problem is the automatic mute of speaker output by
headphone plugging.  This feature is implemented in most cases, but
not on every preset model or codec-support code.

In anyway, try a different model option if you have such a problem.
Some other models may match better and give you more matching
functionality.  If none of the available models works, send a bug
report.  See the bug report section for details.

If you are masochistic enough to debug the driver problem, note the
following:
\begin{itemize}
\item {} 
The speaker (and the headphone, too) output often requires the
external amplifier.  This can be set usually via EAPD verb or a
certain GPIO.  If the codec pin supports EAPD, you have a better
chance via SET\_EAPD\_BTL verb (0x70c).  On others, GPIO pin (mostly
it's either GPIO0 or GPIO1) may turn on/off EAPD.

\item {} 
Some Realtek codecs require special vendor-specific coefficients to
turn on the amplifier.  See patch\_realtek.c.

\item {} 
IDT codecs may have extra power-enable/disable controls on each
analog pin.  See patch\_sigmatel.c.

\item {} 
Very rare but some devices don't accept the pin-detection verb until
triggered.  Issuing GET\_PIN\_SENSE verb (0xf09) may result in the
codec-communication stall.  Some examples are found in
patch\_realtek.c.

\end{itemize}


\subsubsection{Capture Problems}
\label{sound/hd-audio/notes:capture-problems}
The capture problems are often because of missing setups of mixers.
Thus, before submitting a bug report, make sure that you set up the
mixer correctly.  For example, both ``Capture Volume'' and ``Capture
Switch'' have to be set properly in addition to the right ``Capture
Source'' or ``Input Source'' selection.  Some devices have ``Mic Boost''
volume or switch.

When the PCM device is opened via ``default'' PCM (without pulse-audio
plugin), you'll likely have ``Digital Capture Volume'' control as well.
This is provided for the extra gain/attenuation of the signal in
software, especially for the inputs without the hardware volume
control such as digital microphones.  Unless really needed, this
should be set to exactly 50\%, corresponding to 0dB -- neither extra
gain nor attenuation.  When you use ``hw'' PCM, i.e., a raw access PCM,
this control will have no influence, though.

It's known that some codecs / devices have fairly bad analog circuits,
and the recorded sound contains a certain DC-offset.  This is no bug
of the driver.

Most of modern laptops have no analog CD-input connection.  Thus, the
recording from CD input won't work in many cases although the driver
provides it as the capture source.  Use CDDA instead.

The automatic switching of the built-in and external mic per plugging
is implemented on some codec models but not on every model.  Partly
because of my laziness but mostly lack of testers.  Feel free to
submit the improvement patch to the author.


\subsubsection{Direct Debugging}
\label{sound/hd-audio/notes:direct-debugging}
If no model option gives you a better result, and you are a tough guy
to fight against evil, try debugging via hitting the raw HD-audio
codec verbs to the device.  Some tools are available: hda-emu and
hda-analyzer.  The detailed description is found in the sections
below.  You'd need to enable hwdep for using these tools.  See ``Kernel
Configuration'' section.


\subsection{Other Issues}
\label{sound/hd-audio/notes:other-issues}

\subsubsection{Kernel Configuration}
\label{sound/hd-audio/notes:kernel-configuration}
In general, I recommend you to enable the sound debug option,
\code{CONFIG\_SND\_DEBUG=y}, no matter whether you are debugging or not.
This enables snd\_printd() macro and others, and you'll get additional
kernel messages at probing.

In addition, you can enable \code{CONFIG\_SND\_DEBUG\_VERBOSE=y}.  But this
will give you far more messages.  Thus turn this on only when you are
sure to want it.

Don't forget to turn on the appropriate \code{CONFIG\_SND\_HDA\_CODEC\_*}
options.  Note that each of them corresponds to the codec chip, not
the controller chip.  Thus, even if lspci shows the Nvidia controller,
you may need to choose the option for other vendors.  If you are
unsure, just select all yes.

\code{CONFIG\_SND\_HDA\_HWDEP} is a useful option for debugging the driver.
When this is enabled, the driver creates hardware-dependent devices
(one per each codec), and you have a raw access to the device via
these device files.  For example, \code{hwC0D2} will be created for the
codec slot \#2 of the first card (\#0).  For debug-tools such as
hda-verb and hda-analyzer, the hwdep device has to be enabled.
Thus, it'd be better to turn this on always.

\code{CONFIG\_SND\_HDA\_RECONFIG} is a new option, and this depends on the
hwdep option above.  When enabled, you'll have some sysfs files under
the corresponding hwdep directory.  See ``HD-audio reconfiguration''
section below.

\code{CONFIG\_SND\_HDA\_POWER\_SAVE} option enables the power-saving feature.
See ``Power-saving'' section below.


\subsubsection{Codec Proc-File}
\label{sound/hd-audio/notes:codec-proc-file}
The codec proc-file is a treasure-chest for debugging HD-audio.
It shows most of useful information of each codec widget.

The proc file is located in /proc/asound/card*/codec\#*, one file per
each codec slot.  You can know the codec vendor, product id and
names, the type of each widget, capabilities and so on.
This file, however, doesn't show the jack sensing state, so far.  This
is because the jack-sensing might be depending on the trigger state.

This file will be picked up by the debug tools, and also it can be fed
to the emulator as the primary codec information.  See the debug tools
section below.

This proc file can be also used to check whether the generic parser is
used.  When the generic parser is used, the vendor/product ID name
will appear as ``Realtek ID 0262'', instead of ``Realtek ALC262''.


\subsubsection{HD-Audio Reconfiguration}
\label{sound/hd-audio/notes:hd-audio-reconfiguration}
This is an experimental feature to allow you re-configure the HD-audio
codec dynamically without reloading the driver.  The following sysfs
files are available under each codec-hwdep device directory (e.g.
/sys/class/sound/hwC0D0):
\begin{description}
\item[{vendor\_id}] \leavevmode
Shows the 32bit codec vendor-id hex number.  You can change the
vendor-id value by writing to this file.

\item[{subsystem\_id}] \leavevmode
Shows the 32bit codec subsystem-id hex number.  You can change the
subsystem-id value by writing to this file.

\item[{revision\_id}] \leavevmode
Shows the 32bit codec revision-id hex number.  You can change the
revision-id value by writing to this file.

\item[{afg}] \leavevmode
Shows the AFG ID.  This is read-only.

\item[{mfg}] \leavevmode
Shows the MFG ID.  This is read-only.

\item[{name}] \leavevmode
Shows the codec name string.  Can be changed by writing to this
file.

\item[{modelname}] \leavevmode
Shows the currently set \code{model} option.  Can be changed by writing
to this file.

\item[{init\_verbs}] \leavevmode
The extra verbs to execute at initialization.  You can add a verb by
writing to this file.  Pass three numbers: nid, verb and parameter
(separated with a space).

\item[{hints}] \leavevmode
Shows / stores hint strings for codec parsers for any use.
Its format is \code{key = value}.  For example, passing \code{jack\_detect = no}
will disable the jack detection of the machine completely.

\item[{init\_pin\_configs}] \leavevmode
Shows the initial pin default config values set by BIOS.

\item[{driver\_pin\_configs}] \leavevmode
Shows the pin default values set by the codec parser explicitly.
This doesn't show all pin values but only the changed values by
the parser.  That is, if the parser doesn't change the pin default
config values by itself, this will contain nothing.

\item[{user\_pin\_configs}] \leavevmode
Shows the pin default config values to override the BIOS setup.
Writing this (with two numbers, NID and value) appends the new
value.  The given will be used instead of the initial BIOS value at
the next reconfiguration time.  Note that this config will override
even the driver pin configs, too.

\item[{reconfig}] \leavevmode
Triggers the codec re-configuration.  When any value is written to
this file, the driver re-initialize and parses the codec tree
again.  All the changes done by the sysfs entries above are taken
into account.

\item[{clear}] \leavevmode
Resets the codec, removes the mixer elements and PCM stuff of the
specified codec, and clear all init verbs and hints.

\end{description}

For example, when you want to change the pin default configuration
value of the pin widget 0x14 to 0x9993013f, and let the driver
re-configure based on that state, run like below:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} echo 0x14 0x9993013f \PYGZgt{} /sys/class/sound/hwC0D0/user\PYGZus{}pin\PYGZus{}configs
\PYGZsh{} echo 1 \PYGZgt{} /sys/class/sound/hwC0D0/reconfig
\end{Verbatim}


\subsubsection{Hint Strings}
\label{sound/hd-audio/notes:hint-strings}
The codec parser have several switches and adjustment knobs for
matching better with the actual codec or device behavior.  Many of
them can be adjusted dynamically via ``hints'' strings as mentioned in
the section above.  For example, by passing \code{jack\_detect = no} string
via sysfs or a patch file, you can disable the jack detection, thus
the codec parser will skip the features like auto-mute or mic
auto-switch.  As a boolean value, either \code{yes}, \code{no}, \code{true}, \code{false},
\code{1} or \code{0} can be passed.

The generic parser supports the following hints:
\begin{description}
\item[{jack\_detect (bool)}] \leavevmode
specify whether the jack detection is available at all on this
machine; default true

\item[{inv\_jack\_detect (bool)}] \leavevmode
indicates that the jack detection logic is inverted

\item[{trigger\_sense (bool)}] \leavevmode
indicates that the jack detection needs the explicit call of
AC\_VERB\_SET\_PIN\_SENSE verb

\item[{inv\_eapd (bool)}] \leavevmode
indicates that the EAPD is implemented in the inverted logic

\item[{pcm\_format\_first (bool)}] \leavevmode
sets the PCM format before the stream tag and channel ID

\item[{sticky\_stream (bool)}] \leavevmode
keep the PCM format, stream tag and ID as long as possible;
default true

\item[{spdif\_status\_reset (bool)}] \leavevmode
reset the SPDIF status bits at each time the SPDIF stream is set
up

\item[{pin\_amp\_workaround (bool)}] \leavevmode
the output pin may have multiple amp values

\item[{single\_adc\_amp (bool)}] \leavevmode
ADCs can have only single input amps

\item[{auto\_mute (bool)}] \leavevmode
enable/disable the headphone auto-mute feature; default true

\item[{auto\_mic (bool)}] \leavevmode
enable/disable the mic auto-switch feature; default true

\item[{line\_in\_auto\_switch (bool)}] \leavevmode
enable/disable the line-in auto-switch feature; default false

\item[{need\_dac\_fix (bool)}] \leavevmode
limits the DACs depending on the channel count

\item[{primary\_hp (bool)}] \leavevmode
probe headphone jacks as the primary outputs; default true

\item[{multi\_io (bool)}] \leavevmode
try probing multi-I/O config (e.g. shared line-in/surround,
mic/clfe jacks)

\item[{multi\_cap\_vol (bool)}] \leavevmode
provide multiple capture volumes

\item[{inv\_dmic\_split (bool)}] \leavevmode
provide split internal mic volume/switch for phase-inverted
digital mics

\item[{indep\_hp (bool)}] \leavevmode
provide the independent headphone PCM stream and the corresponding
mixer control, if available

\item[{add\_stereo\_mix\_input (bool)}] \leavevmode
add the stereo mix (analog-loopback mix) to the input mux if
available

\item[{add\_jack\_modes (bool)}] \leavevmode
add ``xxx Jack Mode'' enum controls to each I/O jack for allowing to
change the headphone amp and mic bias VREF capabilities

\item[{power\_save\_node (bool)}] \leavevmode
advanced power management for each widget, controlling the power
sate (D0/D3) of each widget node depending on the actual pin and
stream states

\item[{power\_down\_unused (bool)}] \leavevmode
power down the unused widgets, a subset of power\_save\_node, and
will be dropped in future

\item[{add\_hp\_mic (bool)}] \leavevmode
add the headphone to capture source if possible

\item[{hp\_mic\_detect (bool)}] \leavevmode
enable/disable the hp/mic shared input for a single built-in mic
case; default true

\item[{vmaster (bool)}] \leavevmode
enable/disable the virtual Master control; default true

\item[{mixer\_nid (int)}] \leavevmode
specifies the widget NID of the analog-loopback mixer

\end{description}


\subsubsection{Early Patching}
\label{sound/hd-audio/notes:early-patching}
When \code{CONFIG\_SND\_HDA\_PATCH\_LOADER=y} is set, you can pass a ``patch''
as a firmware file for modifying the HD-audio setup before
initializing the codec.  This can work basically like the
reconfiguration via sysfs in the above, but it does it before the
first codec configuration.

A patch file is a plain text file which looks like below:

\begin{Verbatim}[commandchars=\\\{\}]
[codec]
0x12345678 0xabcd1234 2

[model]
auto

[pincfg]
0x12 0x411111f0

[verb]
0x20 0x500 0x03
0x20 0x400 0xff

[hint]
jack\PYGZus{}detect = no
\end{Verbatim}

The file needs to have a line \code{{[}codec{]}}.  The next line should contain
three numbers indicating the codec vendor-id (0x12345678 in the
example), the codec subsystem-id (0xabcd1234) and the address (2) of
the codec.  The rest patch entries are applied to this specified codec
until another codec entry is given.  Passing 0 or a negative number to
the first or the second value will make the check of the corresponding
field be skipped.  It'll be useful for really broken devices that don't
initialize SSID properly.

The \code{{[}model{]}} line allows to change the model name of the each codec.
In the example above, it will be changed to model=auto.
Note that this overrides the module option.

After the \code{{[}pincfg{]}} line, the contents are parsed as the initial
default pin-configurations just like \code{user\_pin\_configs} sysfs above.
The values can be shown in user\_pin\_configs sysfs file, too.

Similarly, the lines after \code{{[}verb{]}} are parsed as \code{init\_verbs}
sysfs entries, and the lines after \code{{[}hint{]}} are parsed as \code{hints}
sysfs entries, respectively.

Another example to override the codec vendor id from 0x12345678 to
0xdeadbeef is like below:

\begin{Verbatim}[commandchars=\\\{\}]
[codec]
0x12345678 0xabcd1234 2

[vendor\PYGZus{}id]
0xdeadbeef
\end{Verbatim}

In the similar way, you can override the codec subsystem\_id via
\code{{[}subsystem\_id{]}}, the revision id via \code{{[}revision\_id{]}} line.
Also, the codec chip name can be rewritten via \code{{[}chip\_name{]}} line.

\begin{Verbatim}[commandchars=\\\{\}]
[codec]
0x12345678 0xabcd1234 2

[subsystem\PYGZus{}id]
0xffff1111

[revision\PYGZus{}id]
0x10

[chip\PYGZus{}name]
My\PYGZhy{}own NEWS\PYGZhy{}0002
\end{Verbatim}

The hd-audio driver reads the file via request\_firmware().  Thus,
a patch file has to be located on the appropriate firmware path,
typically, /lib/firmware.  For example, when you pass the option
\code{patch=hda-init.fw}, the file /lib/firmware/hda-init.fw must be
present.

The patch module option is specific to each card instance, and you
need to give one file name for each instance, separated by commas.
For example, if you have two cards, one for an on-board analog and one
for an HDMI video board, you may pass patch option like below:

\begin{Verbatim}[commandchars=\\\{\}]
options snd\PYGZhy{}hda\PYGZhy{}intel patch=on\PYGZhy{}board\PYGZhy{}patch,hdmi\PYGZhy{}patch
\end{Verbatim}


\subsubsection{Power-Saving}
\label{sound/hd-audio/notes:power-saving}
The power-saving is a kind of auto-suspend of the device.  When the
device is inactive for a certain time, the device is automatically
turned off to save the power.  The time to go down is specified via
\code{power\_save} module option, and this option can be changed dynamically
via sysfs.

The power-saving won't work when the analog loopback is enabled on
some codecs.  Make sure that you mute all unneeded signal routes when
you want the power-saving.

The power-saving feature might cause audible click noises at each
power-down/up depending on the device.  Some of them might be
solvable, but some are hard, I'm afraid.  Some distros such as
openSUSE enables the power-saving feature automatically when the power
cable is unplugged.  Thus, if you hear noises, suspect first the
power-saving.  See /sys/module/snd\_hda\_intel/parameters/power\_save to
check the current value.  If it's non-zero, the feature is turned on.

The recent kernel supports the runtime PM for the HD-audio controller
chip, too.  It means that the HD-audio controller is also powered up /
down dynamically.  The feature is enabled only for certain controller
chips like Intel LynxPoint.  You can enable/disable this feature
forcibly by setting \code{power\_save\_controller} option, which is also
available at /sys/module/snd\_hda\_intel/parameters directory.


\subsubsection{Tracepoints}
\label{sound/hd-audio/notes:tracepoints}
The hd-audio driver gives a few basic tracepoints.
\code{hda:hda\_send\_cmd} traces each CORB write while \code{hda:hda\_get\_response}
traces the response from RIRB (only when read from the codec driver).
\code{hda:hda\_bus\_reset} traces the bus-reset due to fatal error, etc,
\code{hda:hda\_unsol\_event} traces the unsolicited events, and
\code{hda:hda\_power\_down} and \code{hda:hda\_power\_up} trace the power down/up
via power-saving behavior.

Enabling all tracepoints can be done like

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} echo 1 \PYGZgt{} /sys/kernel/debug/tracing/events/hda/enable
\end{Verbatim}

then after some commands, you can traces from
/sys/kernel/debug/tracing/trace file.  For example, when you want to
trace what codec command is sent, enable the tracepoint like:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} cat /sys/kernel/debug/tracing/trace
\PYGZsh{} tracer: nop
\PYGZsh{}
\PYGZsh{}       TASK\PYGZhy{}PID    CPU\PYGZsh{}    TIMESTAMP  FUNCTION
\PYGZsh{}          \textbar{} \textbar{}       \textbar{}          \textbar{}         \textbar{}
       \PYGZlt{}...\PYGZgt{}\PYGZhy{}7807  [002] 105147.774889: hda\PYGZus{}send\PYGZus{}cmd: [0:0] val=e3a019
       \PYGZlt{}...\PYGZgt{}\PYGZhy{}7807  [002] 105147.774893: hda\PYGZus{}send\PYGZus{}cmd: [0:0] val=e39019
       \PYGZlt{}...\PYGZgt{}\PYGZhy{}7807  [002] 105147.999542: hda\PYGZus{}send\PYGZus{}cmd: [0:0] val=e3a01a
       \PYGZlt{}...\PYGZgt{}\PYGZhy{}7807  [002] 105147.999543: hda\PYGZus{}send\PYGZus{}cmd: [0:0] val=e3901a
       \PYGZlt{}...\PYGZgt{}\PYGZhy{}26764 [001] 349222.837143: hda\PYGZus{}send\PYGZus{}cmd: [0:0] val=e3a019
       \PYGZlt{}...\PYGZgt{}\PYGZhy{}26764 [001] 349222.837148: hda\PYGZus{}send\PYGZus{}cmd: [0:0] val=e39019
       \PYGZlt{}...\PYGZgt{}\PYGZhy{}26764 [001] 349223.058539: hda\PYGZus{}send\PYGZus{}cmd: [0:0] val=e3a01a
       \PYGZlt{}...\PYGZgt{}\PYGZhy{}26764 [001] 349223.058541: hda\PYGZus{}send\PYGZus{}cmd: [0:0] val=e3901a
\end{Verbatim}

Here \code{{[}0:0{]}} indicates the card number and the codec address, and
\code{val} shows the value sent to the codec, respectively.  The value is
a packed value, and you can decode it via hda-decode-verb program
included in hda-emu package below.  For example, the value e3a019 is
to set the left output-amp value to 25.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} hda\PYGZhy{}decode\PYGZhy{}verb 0xe3a019
raw value = 0x00e3a019
cid = 0, nid = 0x0e, verb = 0x3a0, parm = 0x19
raw value: verb = 0x3a0, parm = 0x19
verbname = set\PYGZus{}amp\PYGZus{}gain\PYGZus{}mute
amp raw val = 0xa019
output, left, idx=0, mute=0, val=25
\end{Verbatim}


\subsubsection{Development Tree}
\label{sound/hd-audio/notes:development-tree}
The latest development codes for HD-audio are found on sound git tree:
\begin{itemize}
\item {} 
git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound.git

\end{itemize}

The master branch or for-next branches can be used as the main
development branches in general while the development for the current
and next kernels are found in for-linus and for-next branches,
respectively.


\subsubsection{Sending a Bug Report}
\label{sound/hd-audio/notes:sending-a-bug-report}
If any model or module options don't work for your device, it's time
to send a bug report to the developers.  Give the following in your
bug report:
\begin{itemize}
\item {} 
Hardware vendor, product and model names

\item {} 
Kernel version (and ALSA-driver version if you built externally)

\item {} 
\code{alsa-info.sh} output; run with \code{-{-}no-upload} option.  See the
section below about alsa-info

\end{itemize}

If it's a regression, at best, send alsa-info outputs of both working
and non-working kernels.  This is really helpful because we can
compare the codec registers directly.

Send a bug report either the following:
\begin{description}
\item[{kernel-bugzilla}] \leavevmode
\href{https://bugzilla.kernel.org/}{https://bugzilla.kernel.org/}

\item[{alsa-devel ML}] \leavevmode
\href{mailto:alsa-devel@alsa-project.org}{alsa-devel@alsa-project.org}

\end{description}


\subsection{Debug Tools}
\label{sound/hd-audio/notes:debug-tools}
This section describes some tools available for debugging HD-audio
problems.


\subsubsection{alsa-info}
\label{sound/hd-audio/notes:alsa-info}
The script \code{alsa-info.sh} is a very useful tool to gather the audio
device information.  It's included in alsa-utils package.  The latest
version can be found on git repository:
\begin{itemize}
\item {} 
git://git.alsa-project.org/alsa-utils.git

\end{itemize}

The script can be fetched directly from the following URL, too:
\begin{itemize}
\item {} 
\href{http://www.alsa-project.org/alsa-info.sh}{http://www.alsa-project.org/alsa-info.sh}

\end{itemize}

Run this script as root, and it will gather the important information
such as the module lists, module parameters, proc file contents
including the codec proc files, mixer outputs and the control
elements.  As default, it will store the information onto a web server
on alsa-project.org.  But, if you send a bug report, it'd be better to
run with \code{-{-}no-upload} option, and attach the generated file.

There are some other useful options.  See \code{-{-}help} option output for
details.

When a probe error occurs or when the driver obviously assigns a
mismatched model, it'd be helpful to load the driver with
\code{probe\_only=1} option (at best after the cold reboot) and run
alsa-info at this state.  With this option, the driver won't configure
the mixer and PCM but just tries to probe the codec slot.  After
probing, the proc file is available, so you can get the raw codec
information before modified by the driver.  Of course, the driver
isn't usable with \code{probe\_only=1}.  But you can continue the
configuration via hwdep sysfs file if hda-reconfig option is enabled.
Using \code{probe\_only} mask 2 skips the reset of HDA codecs (use
\code{probe\_only=3} as module option). The hwdep interface can be used
to determine the BIOS codec initialization.


\subsubsection{hda-verb}
\label{sound/hd-audio/notes:hda-verb}
hda-verb is a tiny program that allows you to access the HD-audio
codec directly.  You can execute a raw HD-audio codec verb with this.
This program accesses the hwdep device, thus you need to enable the
kernel config \code{CONFIG\_SND\_HDA\_HWDEP=y} beforehand.

The hda-verb program takes four arguments: the hwdep device file, the
widget NID, the verb and the parameter.  When you access to the codec
on the slot 2 of the card 0, pass /dev/snd/hwC0D2 to the first
argument, typically.  (However, the real path name depends on the
system.)

The second parameter is the widget number-id to access.  The third
parameter can be either a hex/digit number or a string corresponding
to a verb.  Similarly, the last parameter is the value to write, or
can be a string for the parameter type.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} hda\PYGZhy{}verb /dev/snd/hwC0D0 0x12 0x701 2
nid = 0x12, verb = 0x701, param = 0x2
value = 0x0

\PYGZpc{} hda\PYGZhy{}verb /dev/snd/hwC0D0 0x0 PARAMETERS VENDOR\PYGZus{}ID
nid = 0x0, verb = 0xf00, param = 0x0
value = 0x10ec0262

\PYGZpc{} hda\PYGZhy{}verb /dev/snd/hwC0D0 2 set\PYGZus{}a 0xb080
nid = 0x2, verb = 0x300, param = 0xb080
value = 0x0
\end{Verbatim}

Although you can issue any verbs with this program, the driver state
won't be always updated.  For example, the volume values are usually
cached in the driver, and thus changing the widget amp value directly
via hda-verb won't change the mixer value.

The hda-verb program is included now in alsa-tools:
\begin{itemize}
\item {} 
git://git.alsa-project.org/alsa-tools.git

\end{itemize}

Also, the old stand-alone package is found in the ftp directory:
\begin{itemize}
\item {} 
\href{ftp://ftp.suse.com/pub/people/tiwai/misc/}{ftp://ftp.suse.com/pub/people/tiwai/misc/}

\end{itemize}

Also a git repository is available:
\begin{itemize}
\item {} 
git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/hda-verb.git

\end{itemize}

See README file in the tarball for more details about hda-verb
program.


\subsubsection{hda-analyzer}
\label{sound/hd-audio/notes:hda-analyzer}
hda-analyzer provides a graphical interface to access the raw HD-audio
control, based on pyGTK2 binding.  It's a more powerful version of
hda-verb.  The program gives you an easy-to-use GUI stuff for showing
the widget information and adjusting the amp values, as well as the
proc-compatible output.

The hda-analyzer:
\begin{itemize}
\item {} 
\href{http://git.alsa-project.org/?p=alsa.git;a=tree;f=hda-analyzer}{http://git.alsa-project.org/?p=alsa.git;a=tree;f=hda-analyzer}

\end{itemize}

is a part of alsa.git repository in alsa-project.org:
\begin{itemize}
\item {} 
git://git.alsa-project.org/alsa.git

\end{itemize}


\subsubsection{Codecgraph}
\label{sound/hd-audio/notes:codecgraph}
Codecgraph is a utility program to generate a graph and visualizes the
codec-node connection of a codec chip.  It's especially useful when
you analyze or debug a codec without a proper datasheet.  The program
parses the given codec proc file and converts to SVG via graphiz
program.

The tarball and GIT trees are found in the web page at:
\begin{itemize}
\item {} 
\href{http://helllabs.org/codecgraph/}{http://helllabs.org/codecgraph/}

\end{itemize}


\subsubsection{hda-emu}
\label{sound/hd-audio/notes:hda-emu}
hda-emu is an HD-audio emulator.  The main purpose of this program is
to debug an HD-audio codec without the real hardware.  Thus, it
doesn't emulate the behavior with the real audio I/O, but it just
dumps the codec register changes and the ALSA-driver internal changes
at probing and operating the HD-audio driver.

The program requires a codec proc-file to simulate.  Get a proc file
for the target codec beforehand, or pick up an example codec from the
codec proc collections in the tarball.  Then, run the program with the
proc file, and the hda-emu program will start parsing the codec file
and simulates the HD-audio driver:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} hda\PYGZhy{}emu codecs/stac9200\PYGZhy{}dell\PYGZhy{}d820\PYGZhy{}laptop
\PYGZsh{} Parsing..
hda\PYGZus{}codec: Unknown model for STAC9200, using BIOS defaults
hda\PYGZus{}codec: pin nid 08 bios pin config 40c003fa
....
\end{Verbatim}

The program gives you only a very dumb command-line interface.  You
can get a proc-file dump at the current state, get a list of control
(mixer) elements, set/get the control element value, simulate the PCM
operation, the jack plugging simulation, etc.

The program is found in the git repository below:
\begin{itemize}
\item {} 
git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/hda-emu.git

\end{itemize}

See README file in the repository for more details about hda-emu
program.


\subsubsection{hda-jack-retask}
\label{sound/hd-audio/notes:hda-jack-retask}
hda-jack-retask is a user-friendly GUI program to manipulate the
HD-audio pin control for jack retasking.  If you have a problem about
the jack assignment, try this program and check whether you can get
useful results.  Once when you figure out the proper pin assignment,
it can be fixed either in the driver code statically or via passing a
firmware patch file (see ``Early Patching'' section).

The program is included in alsa-tools now:
\begin{itemize}
\item {} 
git://git.alsa-project.org/alsa-tools.git

\end{itemize}


\section{HD-Audio Codec-Specific Models}
\label{sound/hd-audio/models:hd-audio-codec-specific-models}\label{sound/hd-audio/models::doc}

\subsection{ALC880}
\label{sound/hd-audio/models:alc880}\begin{description}
\item[{3stack}] \leavevmode
3-jack in back and a headphone out

\item[{3stack-digout}] \leavevmode
3-jack in back, a HP out and a SPDIF out

\item[{5stack}] \leavevmode
5-jack in back, 2-jack in front

\item[{5stack-digout}] \leavevmode
5-jack in back, 2-jack in front, a SPDIF out

\item[{6stack}] \leavevmode
6-jack in back, 2-jack in front

\item[{6stack-digout}] \leavevmode
6-jack with a SPDIF out

\item[{6stack-automute}] \leavevmode
6-jack with headphone jack detection

\end{description}


\subsection{ALC260}
\label{sound/hd-audio/models:alc260}\begin{description}
\item[{gpio1}] \leavevmode
Enable GPIO1

\item[{coef}] \leavevmode
Enable EAPD via COEF table

\item[{fujitsu}] \leavevmode
Quirk for FSC S7020

\item[{fujitsu-jwse}] \leavevmode
Quirk for FSC S7020 with jack modes and HP mic support

\end{description}


\subsection{ALC262}
\label{sound/hd-audio/models:alc262}\begin{description}
\item[{inv-dmic}] \leavevmode
Inverted internal mic workaround

\end{description}


\subsection{ALC267/268}
\label{sound/hd-audio/models:alc267-268}\begin{description}
\item[{inv-dmic}] \leavevmode
Inverted internal mic workaround

\item[{hp-eapd}] \leavevmode
Disable HP EAPD on NID 0x15

\end{description}


\subsection{ALC22x/23x/25x/269/27x/28x/29x (and vendor-specific ALC3xxx models)}
\label{sound/hd-audio/models:alc22x-23x-25x-269-27x-28x-29x-and-vendor-specific-alc3xxx-models}\begin{description}
\item[{laptop-amic}] \leavevmode
Laptops with analog-mic input

\item[{laptop-dmic}] \leavevmode
Laptops with digital-mic input

\item[{alc269-dmic}] \leavevmode
Enable ALC269(VA) digital mic workaround

\item[{alc271-dmic}] \leavevmode
Enable ALC271X digital mic workaround

\item[{inv-dmic}] \leavevmode
Inverted internal mic workaround

\item[{headset-mic}] \leavevmode
Indicates a combined headset (headphone+mic) jack

\item[{headset-mode}] \leavevmode
More comprehensive headset support for ALC269 \& co

\item[{headset-mode-no-hp-mic}] \leavevmode
Headset mode support without headphone mic

\item[{lenovo-dock}] \leavevmode
Enables docking station I/O for some Lenovos

\item[{hp-gpio-led}] \leavevmode
GPIO LED support on HP laptops

\item[{hp-dock-gpio-mic1-led}] \leavevmode
HP dock with mic LED support

\item[{dell-headset-multi}] \leavevmode
Headset jack, which can also be used as mic-in

\item[{dell-headset-dock}] \leavevmode
Headset jack (without mic-in), and also dock I/O

\item[{alc283-dac-wcaps}] \leavevmode
Fixups for Chromebook with ALC283

\item[{alc283-sense-combo}] \leavevmode
Combo jack sensing on ALC283

\item[{tpt440-dock}] \leavevmode
Pin configs for Lenovo Thinkpad Dock support

\item[{tpt440}] \leavevmode
Lenovo Thinkpad T440s setup

\item[{tpt460}] \leavevmode
Lenovo Thinkpad T460/560 setup

\item[{dual-codecs}] \leavevmode
Lenovo laptops with dual codecs

\item[{alc700-ref}] \leavevmode
Intel reference board with ALC700 codec

\end{description}


\subsection{ALC66x/67x/892}
\label{sound/hd-audio/models:alc66x-67x-892}\begin{description}
\item[{mario}] \leavevmode
Chromebook mario model fixup

\item[{asus-mode1}] \leavevmode
ASUS

\item[{asus-mode2}] \leavevmode
ASUS

\item[{asus-mode3}] \leavevmode
ASUS

\item[{asus-mode4}] \leavevmode
ASUS

\item[{asus-mode5}] \leavevmode
ASUS

\item[{asus-mode6}] \leavevmode
ASUS

\item[{asus-mode7}] \leavevmode
ASUS

\item[{asus-mode8}] \leavevmode
ASUS

\item[{inv-dmic}] \leavevmode
Inverted internal mic workaround

\item[{dell-headset-multi}] \leavevmode
Headset jack, which can also be used as mic-in

\item[{dual-codecs}] \leavevmode
Lenovo laptops with dual codecs

\end{description}


\subsection{ALC680}
\label{sound/hd-audio/models:alc680}
N/A


\subsection{ALC88x/898/1150}
\label{sound/hd-audio/models:alc88x-898-1150}\begin{description}
\item[{acer-aspire-4930g}] \leavevmode
Acer Aspire 4930G/5930G/6530G/6930G/7730G

\item[{acer-aspire-8930g}] \leavevmode
Acer Aspire 8330G/6935G

\item[{acer-aspire}] \leavevmode
Acer Aspire others

\item[{inv-dmic}] \leavevmode
Inverted internal mic workaround

\item[{no-primary-hp}] \leavevmode
VAIO Z/VGC-LN51JGB workaround (for fixed speaker DAC)

\item[{dual-codecs}] \leavevmode
ALC1220 dual codecs for Gaming mobos

\end{description}


\subsection{ALC861/660}
\label{sound/hd-audio/models:alc861-660}
N/A


\subsection{ALC861VD/660VD}
\label{sound/hd-audio/models:alc861vd-660vd}
N/A


\subsection{CMI9880}
\label{sound/hd-audio/models:cmi9880}\begin{description}
\item[{minimal}] \leavevmode
3-jack in back

\item[{min\_fp}] \leavevmode
3-jack in back, 2-jack in front

\item[{full}] \leavevmode
6-jack in back, 2-jack in front

\item[{full\_dig}] \leavevmode
6-jack in back, 2-jack in front, SPDIF I/O

\item[{allout}] \leavevmode
5-jack in back, 2-jack in front, SPDIF out

\item[{auto}] \leavevmode
auto-config reading BIOS (default)

\end{description}


\subsection{AD1882 / AD1882A}
\label{sound/hd-audio/models:ad1882-ad1882a}\begin{description}
\item[{3stack}] \leavevmode
3-stack mode

\item[{3stack-automute}] \leavevmode
3-stack with automute front HP (default)

\item[{6stack}] \leavevmode
6-stack mode

\end{description}


\subsection{AD1884A / AD1883 / AD1984A / AD1984B}
\label{sound/hd-audio/models:ad1884a-ad1883-ad1984a-ad1984b}
desktop 3-stack desktop (default)
laptop  laptop with HP jack sensing
mobile  mobile devices with HP jack sensing
thinkpad        Lenovo Thinkpad X300
touchsmart      HP Touchsmart


\subsection{AD1884}
\label{sound/hd-audio/models:ad1884}
N/A


\subsection{AD1981}
\label{sound/hd-audio/models:ad1981}
basic           3-jack (default)
hp              HP nx6320
thinkpad        Lenovo Thinkpad T60/X60/Z60
toshiba Toshiba U205


\subsection{AD1983}
\label{sound/hd-audio/models:ad1983}
N/A


\subsection{AD1984}
\label{sound/hd-audio/models:ad1984}
basic           default configuration
thinkpad        Lenovo Thinkpad T61/X61
dell\_desktop    Dell T3400


\subsection{AD1986A}
\label{sound/hd-audio/models:ad1986a}\begin{description}
\item[{3stack}] \leavevmode
3-stack, shared surrounds

\item[{laptop}] \leavevmode
2-channel only (FSC V2060, Samsung M50)

\item[{laptop-imic}] \leavevmode
2-channel with built-in mic

\item[{eapd}] \leavevmode
Turn on EAPD constantly

\end{description}


\subsection{AD1988/AD1988B/AD1989A/AD1989B}
\label{sound/hd-audio/models:ad1988-ad1988b-ad1989a-ad1989b}\begin{description}
\item[{6stack}] \leavevmode
6-jack

\item[{6stack-dig}] \leavevmode
ditto with SPDIF

\item[{3stack}] \leavevmode
3-jack

\item[{3stack-dig}] \leavevmode
ditto with SPDIF

\item[{laptop}] \leavevmode
3-jack with hp-jack automute

\item[{laptop-dig}] \leavevmode
ditto with SPDIF

\item[{auto}] \leavevmode
auto-config reading BIOS (default)

\end{description}


\subsection{Conexant 5045}
\label{sound/hd-audio/models:conexant-5045}\begin{description}
\item[{cap-mix-amp}] \leavevmode
Fix max input level on mixer widget

\item[{toshiba-p105}] \leavevmode
Toshiba P105 quirk

\item[{hp-530}] \leavevmode
HP 530 quirk

\end{description}


\subsection{Conexant 5047}
\label{sound/hd-audio/models:conexant-5047}\begin{description}
\item[{cap-mix-amp}] \leavevmode
Fix max input level on mixer widget

\end{description}


\subsection{Conexant 5051}
\label{sound/hd-audio/models:conexant-5051}\begin{description}
\item[{lenovo-x200}] \leavevmode
Lenovo X200 quirk

\end{description}


\subsection{Conexant 5066}
\label{sound/hd-audio/models:conexant-5066}\begin{description}
\item[{stereo-dmic}] \leavevmode
Workaround for inverted stereo digital mic

\item[{gpio1}] \leavevmode
Enable GPIO1 pin

\item[{headphone-mic-pin}] \leavevmode
Enable headphone mic NID 0x18 without detection

\item[{tp410}] \leavevmode
Thinkpad T400 \& co quirks

\item[{thinkpad}] \leavevmode
Thinkpad mute/mic LED quirk

\item[{lemote-a1004}] \leavevmode
Lemote A1004 quirk

\item[{lemote-a1205}] \leavevmode
Lemote A1205 quirk

\item[{olpc-xo}] \leavevmode
OLPC XO quirk

\item[{mute-led-eapd}] \leavevmode
Mute LED control via EAPD

\item[{hp-dock}] \leavevmode
HP dock support

\item[{mute-led-gpio}] \leavevmode
Mute LED control via GPIO

\end{description}


\subsection{STAC9200}
\label{sound/hd-audio/models:stac9200}\begin{description}
\item[{ref}] \leavevmode
Reference board

\item[{oqo}] \leavevmode
OQO Model 2

\item[{dell-d21}] \leavevmode
Dell (unknown)

\item[{dell-d22}] \leavevmode
Dell (unknown)

\item[{dell-d23}] \leavevmode
Dell (unknown)

\item[{dell-m21}] \leavevmode
Dell Inspiron 630m, Dell Inspiron 640m

\item[{dell-m22}] \leavevmode
Dell Latitude D620, Dell Latitude D820

\item[{dell-m23}] \leavevmode
Dell XPS M1710, Dell Precision M90

\item[{dell-m24}] \leavevmode
Dell Latitude 120L

\item[{dell-m25}] \leavevmode
Dell Inspiron E1505n

\item[{dell-m26}] \leavevmode
Dell Inspiron 1501

\item[{dell-m27}] \leavevmode
Dell Inspiron E1705/9400

\item[{gateway-m4}] \leavevmode
Gateway laptops with EAPD control

\item[{gateway-m4-2}] \leavevmode
Gateway laptops with EAPD control

\item[{panasonic}] \leavevmode
Panasonic CF-74

\item[{auto}] \leavevmode
BIOS setup (default)

\end{description}


\subsection{STAC9205/9254}
\label{sound/hd-audio/models:stac9205-9254}\begin{description}
\item[{ref}] \leavevmode
Reference board

\item[{dell-m42}] \leavevmode
Dell (unknown)

\item[{dell-m43}] \leavevmode
Dell Precision

\item[{dell-m44}] \leavevmode
Dell Inspiron

\item[{eapd}] \leavevmode
Keep EAPD on (e.g. Gateway T1616)

\item[{auto}] \leavevmode
BIOS setup (default)

\end{description}


\subsection{STAC9220/9221}
\label{sound/hd-audio/models:stac9220-9221}\begin{description}
\item[{ref}] \leavevmode
Reference board

\item[{3stack}] \leavevmode
D945 3stack

\item[{5stack}] \leavevmode
D945 5stack + SPDIF

\item[{intel-mac-v1}] \leavevmode
Intel Mac Type 1

\item[{intel-mac-v2}] \leavevmode
Intel Mac Type 2

\item[{intel-mac-v3}] \leavevmode
Intel Mac Type 3

\item[{intel-mac-v4}] \leavevmode
Intel Mac Type 4

\item[{intel-mac-v5}] \leavevmode
Intel Mac Type 5

\item[{intel-mac-auto}] \leavevmode
Intel Mac (detect type according to subsystem id)

\item[{macmini}] \leavevmode
Intel Mac Mini (equivalent with type 3)

\item[{macbook}] \leavevmode
Intel Mac Book (eq. type 5)

\item[{macbook-pro-v1}] \leavevmode
Intel Mac Book Pro 1st generation (eq. type 3)

\item[{macbook-pro}] \leavevmode
Intel Mac Book Pro 2nd generation (eq. type 3)

\item[{imac-intel}] \leavevmode
Intel iMac (eq. type 2)

\item[{imac-intel-20}] \leavevmode
Intel iMac (newer version) (eq. type 3)

\item[{ecs202}] \leavevmode
ECS/PC chips

\item[{dell-d81}] \leavevmode
Dell (unknown)

\item[{dell-d82}] \leavevmode
Dell (unknown)

\item[{dell-m81}] \leavevmode
Dell (unknown)

\item[{dell-m82}] \leavevmode
Dell XPS M1210

\item[{auto}] \leavevmode
BIOS setup (default)

\end{description}


\subsection{STAC9202/9250/9251}
\label{sound/hd-audio/models:stac9202-9250-9251}\begin{description}
\item[{ref}] \leavevmode
Reference board, base config

\item[{m1}] \leavevmode
Some Gateway MX series laptops (NX560XL)

\item[{m1-2}] \leavevmode
Some Gateway MX series laptops (MX6453)

\item[{m2}] \leavevmode
Some Gateway MX series laptops (M255)

\item[{m2-2}] \leavevmode
Some Gateway MX series laptops

\item[{m3}] \leavevmode
Some Gateway MX series laptops

\item[{m5}] \leavevmode
Some Gateway MX series laptops (MP6954)

\item[{m6}] \leavevmode
Some Gateway NX series laptops

\item[{auto}] \leavevmode
BIOS setup (default)

\end{description}


\subsection{STAC9227/9228/9229/927x}
\label{sound/hd-audio/models:stac9227-9228-9229-927x}\begin{description}
\item[{ref}] \leavevmode
Reference board

\item[{ref-no-jd}] \leavevmode
Reference board without HP/Mic jack detection

\item[{3stack}] \leavevmode
D965 3stack

\item[{5stack}] \leavevmode
D965 5stack + SPDIF

\item[{5stack-no-fp}] \leavevmode
D965 5stack without front panel

\item[{dell-3stack}] \leavevmode
Dell Dimension E520

\item[{dell-bios}] \leavevmode
Fixes with Dell BIOS setup

\item[{dell-bios-amic}] \leavevmode
Fixes with Dell BIOS setup including analog mic

\item[{volknob}] \leavevmode
Fixes with volume-knob widget 0x24

\item[{auto}] \leavevmode
BIOS setup (default)

\end{description}


\subsection{STAC92HD71B*}
\label{sound/hd-audio/models:stac92hd71b}\begin{description}
\item[{ref}] \leavevmode
Reference board

\item[{dell-m4-1}] \leavevmode
Dell desktops

\item[{dell-m4-2}] \leavevmode
Dell desktops

\item[{dell-m4-3}] \leavevmode
Dell desktops

\item[{hp-m4}] \leavevmode
HP mini 1000

\item[{hp-dv5}] \leavevmode
HP dv series

\item[{hp-hdx}] \leavevmode
HP HDX series

\item[{hp-dv4-1222nr}] \leavevmode
HP dv4-1222nr (with LED support)

\item[{auto}] \leavevmode
BIOS setup (default)

\end{description}


\subsection{STAC92HD73*}
\label{sound/hd-audio/models:stac92hd73}\begin{description}
\item[{ref}] \leavevmode
Reference board

\item[{no-jd}] \leavevmode
BIOS setup but without jack-detection

\item[{intel}] \leavevmode
Intel DG45* mobos

\item[{dell-m6-amic}] \leavevmode
Dell desktops/laptops with analog mics

\item[{dell-m6-dmic}] \leavevmode
Dell desktops/laptops with digital mics

\item[{dell-m6}] \leavevmode
Dell desktops/laptops with both type of mics

\item[{dell-eq}] \leavevmode
Dell desktops/laptops

\item[{alienware}] \leavevmode
Alienware M17x

\item[{asus-mobo}] \leavevmode
Pin configs for ASUS mobo with 5.1/SPDIF out

\item[{auto}] \leavevmode
BIOS setup (default)

\end{description}


\subsection{STAC92HD83*}
\label{sound/hd-audio/models:stac92hd83}\begin{description}
\item[{ref}] \leavevmode
Reference board

\item[{mic-ref}] \leavevmode
Reference board with power management for ports

\item[{dell-s14}] \leavevmode
Dell laptop

\item[{dell-vostro-3500}] \leavevmode
Dell Vostro 3500 laptop

\item[{hp-dv7-4000}] \leavevmode
HP dv-7 4000

\item[{hp\_cNB11\_intquad}] \leavevmode
HP CNB models with 4 speakers

\item[{hp-zephyr}] \leavevmode
HP Zephyr

\item[{hp-led}] \leavevmode
HP with broken BIOS for mute LED

\item[{hp-inv-led}] \leavevmode
HP with broken BIOS for inverted mute LED

\item[{hp-mic-led}] \leavevmode
HP with mic-mute LED

\item[{headset-jack}] \leavevmode
Dell Latitude with a 4-pin headset jack

\item[{hp-envy-bass}] \leavevmode
Pin fixup for HP Envy bass speaker (NID 0x0f)

\item[{hp-envy-ts-bass}] \leavevmode
Pin fixup for HP Envy TS bass speaker (NID 0x10)

\item[{hp-bnb13-eq}] \leavevmode
Hardware equalizer setup for HP laptops

\item[{hp-envy-ts-bass}] \leavevmode
HP Envy TS bass support

\item[{auto}] \leavevmode
BIOS setup (default)

\end{description}


\subsection{STAC92HD95}
\label{sound/hd-audio/models:stac92hd95}\begin{description}
\item[{hp-led}] \leavevmode
LED support for HP laptops

\item[{hp-bass}] \leavevmode
Bass HPF setup for HP Spectre 13

\end{description}


\subsection{STAC9872}
\label{sound/hd-audio/models:stac9872}\begin{description}
\item[{vaio}] \leavevmode
VAIO laptop without SPDIF

\item[{auto}] \leavevmode
BIOS setup (default)

\end{description}


\subsection{Cirrus Logic CS4206/4207}
\label{sound/hd-audio/models:cirrus-logic-cs4206-4207}\begin{description}
\item[{mbp53}] \leavevmode
MacBook Pro 5,3

\item[{mbp55}] \leavevmode
MacBook Pro 5,5

\item[{imac27}] \leavevmode
IMac 27 Inch

\item[{imac27\_122}] \leavevmode
iMac 12,2

\item[{apple}] \leavevmode
Generic Apple quirk

\item[{mbp101}] \leavevmode
MacBookPro 10,1

\item[{mbp81}] \leavevmode
MacBookPro 8,1

\item[{mba42}] \leavevmode
MacBookAir 4,2

\item[{auto}] \leavevmode
BIOS setup (default)

\end{description}


\subsection{Cirrus Logic CS4208}
\label{sound/hd-audio/models:cirrus-logic-cs4208}\begin{description}
\item[{mba6}] \leavevmode
MacBook Air 6,1 and 6,2

\item[{gpio0}] \leavevmode
Enable GPIO 0 amp

\item[{mbp11}] \leavevmode
MacBookPro 11,2

\item[{macmini}] \leavevmode
MacMini 7,1

\item[{auto}] \leavevmode
BIOS setup (default)

\end{description}


\subsection{VIA VT17xx/VT18xx/VT20xx}
\label{sound/hd-audio/models:via-vt17xx-vt18xx-vt20xx}\begin{description}
\item[{auto}] \leavevmode
BIOS setup (default)

\end{description}


\section{HD-Audio Codec-Specific Mixer Controls}
\label{sound/hd-audio/controls:hd-audio-codec-specific-mixer-controls}\label{sound/hd-audio/controls::doc}
This file explains the codec-specific mixer controls.


\subsection{Realtek codecs}
\label{sound/hd-audio/controls:realtek-codecs}\begin{description}
\item[{Channel Mode}] \leavevmode
This is an enum control to change the surround-channel setup,
appears only when the surround channels are available.
It gives the number of channels to be used, ``2ch'', ``4ch'', ``6ch'',
and ``8ch''.  According to the configuration, this also controls the
jack-retasking of multi-I/O jacks.

\item[{Auto-Mute Mode}] \leavevmode
This is an enum control to change the auto-mute behavior of the
headphone and line-out jacks.  If built-in speakers and headphone
and/or line-out jacks are available on a machine, this controls
appears.
When there are only either headphones or line-out jacks, it gives
``Disabled'' and ``Enabled'' state.  When enabled, the speaker is muted
automatically when a jack is plugged.

When both headphone and line-out jacks are present, it gives
``Disabled'', ``Speaker Only'' and ``Line-Out+Speaker''.  When
speaker-only is chosen, plugging into a headphone or a line-out jack
mutes the speakers, but not line-outs.  When line-out+speaker is
selected, plugging to a headphone jack mutes both speakers and
line-outs.

\end{description}


\subsection{IDT/Sigmatel codecs}
\label{sound/hd-audio/controls:idt-sigmatel-codecs}\begin{description}
\item[{Analog Loopback}] \leavevmode
This control enables/disables the analog-loopback circuit.  This
appears only when ``loopback'' is set to true in a codec hint
(see HD-Audio.txt).  Note that on some codecs the analog-loopback
and the normal PCM playback are exclusive, i.e. when this is on, you
won't hear any PCM stream.

\item[{Swap Center/LFE}] \leavevmode
Swaps the center and LFE channel order.  Normally, the left
corresponds to the center and the right to the LFE.  When this is
ON, the left to the LFE and the right to the center.

\item[{Headphone as Line Out}] \leavevmode
When this control is ON, treat the headphone jacks as line-out
jacks.  That is, the headphone won't auto-mute the other line-outs,
and no HP-amp is set to the pins.

\item[{Mic Jack Mode, Line Jack Mode, etc}] \leavevmode
These enum controls the direction and the bias of the input jack
pins.  Depending on the jack type, it can set as ``Mic In'' and ``Line
In'', for determining the input bias, or it can be set to ``Line Out''
when the pin is a multi-I/O jack for surround channels.

\end{description}


\subsection{VIA codecs}
\label{sound/hd-audio/controls:via-codecs}\begin{description}
\item[{Smart 5.1}] \leavevmode
An enum control to re-task the multi-I/O jacks for surround outputs.
When it's ON, the corresponding input jacks (usually a line-in and a
mic-in) are switched as the surround and the CLFE output jacks.

\item[{Independent HP}] \leavevmode
When this enum control is enabled, the headphone output is routed
from an individual stream (the third PCM such as hw:0,2) instead of
the primary stream.  In the case the headphone DAC is shared with a
side or a CLFE-channel DAC, the DAC is switched to the headphone
automatically.

\item[{Loopback Mixing}] \leavevmode
An enum control to determine whether the analog-loopback route is
enabled or not.  When it's enabled, the analog-loopback is mixed to
the front-channel.  Also, the same route is used for the headphone
and speaker outputs.  As a side-effect, when this mode is set, the
individual volume controls will be no longer available for
headphones and speakers because there is only one DAC connected to a
mixer widget.

\item[{Dynamic Power-Control}] \leavevmode
This control determines whether the dynamic power-control per jack
detection is enabled or not.  When enabled, the widgets power state
(D0/D3) are changed dynamically depending on the jack plugging
state for saving power consumptions.  However, if your system
doesn't provide a proper jack-detection, this won't work; in such a
case, turn this control OFF.

\item[{Jack Detect}] \leavevmode
This control is provided only for VT1708 codec which gives no proper
unsolicited event per jack plug.  When this is on, the driver polls
the jack detection so that the headphone auto-mute can work, while
turning this off would reduce the power consumption.

\end{description}


\subsection{Conexant codecs}
\label{sound/hd-audio/controls:conexant-codecs}\begin{description}
\item[{Auto-Mute Mode}] \leavevmode
See Reatek codecs.

\end{description}


\subsection{Analog codecs}
\label{sound/hd-audio/controls:analog-codecs}\begin{description}
\item[{Channel Mode}] \leavevmode
This is an enum control to change the surround-channel setup,
appears only when the surround channels are available.
It gives the number of channels to be used, ``2ch'', ``4ch'' and ``6ch''.
According to the configuration, this also controls the
jack-retasking of multi-I/O jacks.

\item[{Independent HP}] \leavevmode
When this enum control is enabled, the headphone output is routed
from an individual stream (the third PCM such as hw:0,2) instead of
the primary stream.

\end{description}


\section{HD-Audio DP-MST Support}
\label{sound/hd-audio/dp-mst:hd-audio-dp-mst-support}\label{sound/hd-audio/dp-mst::doc}
To support DP MST audio, HD Audio hdmi codec driver introduces virtual pin
and dynamic pcm assignment.

Virtual pin is an extension of per\_pin. The most difference of DP MST
from legacy is that DP MST introduces device entry. Each pin can contain
several device entries. Each device entry behaves as a pin.

As each pin may contain several device entries and each codec may contain
several pins, if we use one pcm per per\_pin, there will be many PCMs.
The new solution is to create a few PCMs and to dynamically bind pcm to
per\_pin. Driver uses spec-\textgreater{}dyn\_pcm\_assign flag to indicate whether to use
the new solution.


\subsection{PCM}
\label{sound/hd-audio/dp-mst:pcm}
To be added


\subsection{Pin Initialization}
\label{sound/hd-audio/dp-mst:pin-initialization}
Each pin may have several device entries (virtual pins). On Intel platform,
the device entries number is dynamically changed. If DP MST hub is connected,
it is in DP MST mode, and the device entries number is 3. Otherwise, the
device entries number is 1.

To simplify the implementation, all the device entries will be initialized
when bootup no matter whether it is in DP MST mode or not.


\subsection{Connection list}
\label{sound/hd-audio/dp-mst:connection-list}
DP MST reuses connection list code. The code can be reused because
device entries on the same pin have the same connection list.

This means DP MST gets the device entry connection list without the
device entry setting.


\subsection{Jack}
\label{sound/hd-audio/dp-mst:jack}\begin{description}
\item[{Presume:}] \leavevmode\begin{itemize}
\item {} 
MST must be dyn\_pcm\_assign, and it is acomp (for Intel scenario);

\item {} 
NON-MST may or may not be dyn\_pcm\_assign, it can be acomp or !acomp;

\end{itemize}

\item[{So there are the following scenarios:}] \leavevmode\begin{enumerate}
\item {} 
MST (\&\& dyn\_pcm\_assign \&\& acomp)

\item {} 
NON-MST \&\& dyn\_pcm\_assign \&\& acomp

\item {} 
NON-MST \&\& !dyn\_pcm\_assign \&\& !acomp

\end{enumerate}

\end{description}

Below discussion will ignore MST and NON-MST difference as it doesn't
impact on jack handling too much.

Driver uses struct hdmi\_pcm pcm{[}{]} array in hdmi\_spec and snd\_jack is
a member of hdmi\_pcm. Each pin has one struct hdmi\_pcm * pcm pointer.

For !dyn\_pcm\_assign, per\_pin-\textgreater{}pcm will assigned to spec-\textgreater{}pcm{[}n{]} statically.

For dyn\_pcm\_assign, per\_pin-\textgreater{}pcm will assigned to spec-\textgreater{}pcm{[}n{]}
when monitor is hotplugged.


\subsubsection{Build Jack}
\label{sound/hd-audio/dp-mst:build-jack}\begin{itemize}
\item {} 
dyn\_pcm\_assign

Will not use hda\_jack but use snd\_jack in spec-\textgreater{}pcm\_rec{[}pcm\_idx{]}.jack directly.

\item {} 
!dyn\_pcm\_assign

Use hda\_jack and assign spec-\textgreater{}pcm\_rec{[}pcm\_idx{]}.jack = jack-\textgreater{}jack statically.

\end{itemize}


\subsubsection{Unsolicited Event Enabling}
\label{sound/hd-audio/dp-mst:unsolicited-event-enabling}
Enable unsolicited event if !acomp.


\subsubsection{Monitor Hotplug Event Handling}
\label{sound/hd-audio/dp-mst:monitor-hotplug-event-handling}\begin{itemize}
\item {} 
acomp

pin\_eld\_notify() -\textgreater{} check\_presence\_and\_report() -\textgreater{} hdmi\_present\_sense() -\textgreater{}
sync\_eld\_via\_acomp().

Use directly snd\_jack\_report() on spec-\textgreater{}pcm\_rec{[}pcm\_idx{]}.jack for
both dyn\_pcm\_assign and !dyn\_pcm\_assign

\item {} 
!acomp

hdmi\_unsol\_event() -\textgreater{} hdmi\_intrinsic\_event() -\textgreater{} check\_presence\_and\_report() -\textgreater{}
hdmi\_present\_sense() -\textgreater{} hdmi\_prepsent\_sense\_via\_verbs()

Use directly snd\_jack\_report() on spec-\textgreater{}pcm\_rec{[}pcm\_idx{]}.jack for dyn\_pcm\_assign.
Use hda\_jack mechanism to handle jack events.

\end{itemize}


\subsection{Others to be added later}
\label{sound/hd-audio/dp-mst:others-to-be-added-later}

\chapter{Card-Specific Information}
\label{sound/cards/index:card-specific-information}\label{sound/cards/index::doc}

\section{Analog Joystick Support on ALSA Drivers}
\label{sound/cards/joystick:analog-joystick-support-on-alsa-drivers}\label{sound/cards/joystick::doc}
Oct. 14, 2003

Takashi Iwai \textless{}\href{mailto:tiwai@suse.de}{tiwai@suse.de}\textgreater{}


\subsection{General}
\label{sound/cards/joystick:general}
First of all, you need to enable GAMEPORT support on Linux kernel for
using a joystick with the ALSA driver.  For the details of gameport
support, refer to Documentation/input/joydev/joystick.rst.

The joystick support of ALSA drivers is different between ISA and PCI
cards.  In the case of ISA (PnP) cards, it's usually handled by the
independent module (ns558).  Meanwhile, the ALSA PCI drivers have the
built-in gameport support.  Hence, when the ALSA PCI driver is built
in the kernel, CONFIG\_GAMEPORT must be `y', too.  Otherwise, the
gameport support on that card will be (silently) disabled.

Some adapter modules probe the physical connection of the device at
the load time.  It'd be safer to plug in the joystick device before
loading the module.


\subsection{PCI Cards}
\label{sound/cards/joystick:pci-cards}
For PCI cards, the joystick is enabled when the appropriate module
option is specified.  Some drivers don't need options, and the
joystick support is always enabled.  In the former ALSA version, there
was a dynamic control API for the joystick activation.  It was
changed, however, to the static module options because of the system
stability and the resource management.

The following PCI drivers support the joystick natively.

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Driver
} & \textsf{\relax 
Module Option
} & \textsf{\relax 
Available Values
}\\
\hline
als4000
 & 
joystick\_port
 & 
0 = disable (default), 1 = auto-detect,
manual: any address (e.g. 0x200)
\\
\hline
au88x0
 & 
N/A
 & 
N/A
\\
\hline
azf3328
 & 
joystick
 & 
0 = disable, 1 = enable, -1 = auto (default)
\\
\hline
ens1370
 & 
joystick
 & 
0 = disable (default), 1 = enable
\\
\hline
ens1371
 & 
joystick\_port
 & 
0 = disable (default), 1 = auto-detect,
manual: 0x200, 0x208, 0x210, 0x218
\\
\hline
cmipci
 & 
joystick\_port
 & 
0 = disable (default), 1 = auto-detect,
manual: any address (e.g. 0x200)
\\
\hline
cs4281
 & 
N/A
 & 
N/A
\\
\hline
cs46xx
 & 
N/A
 & 
N/A
\\
\hline
es1938
 & 
N/A
 & 
N/A
\\
\hline
es1968
 & 
joystick
 & 
0 = disable (default), 1 = enable
\\
\hline
sonicvibes
 & 
N/A
 & 
N/A
\\
\hline
trident
 & 
N/A
 & 
N/A
\\
\hline
via82xx \protect\footnotemark[1]
 & 
joystick
 & 
0 = disable (default), 1 = enable
\\
\hline
ymfpci
 & 
joystick\_port
 & 
0 = disable (default), 1 = auto-detect,
manual: 0x201, 0x202, 0x204, 0x205 \protect\footnotemark[2]
\\
\hline\end{tabulary}

\footnotetext[1]{
VIA686A/B only
}\footnotetext[2]{
With YMF744/754 chips, the port address can be chosen arbitrarily
}
The following drivers don't support gameport natively, but there are
additional modules.  Load the corresponding module to add the gameport
support.

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Driver
} & \textsf{\relax 
Additional Module
}\\
\hline
emu10k1
 & 
emu10k1-gp
\\
\hline
fm801
 & 
fm801-gp
\\
\hline\end{tabulary}


Note: the ``pcigame'' and ``cs461x'' modules are for the OSS drivers only.
These ALSA drivers (cs46xx, trident and au88x0) have the
built-in gameport support.

As mentioned above, ALSA PCI drivers have the built-in gameport
support, so you don't have to load ns558 module.  Just load ``joydev''
and the appropriate adapter module (e.g. ``analog'').


\subsection{ISA Cards}
\label{sound/cards/joystick:isa-cards}
ALSA ISA drivers don't have the built-in gameport support.
Instead, you need to load ``ns558'' module in addition to ``joydev'' and
the adapter module (e.g. ``analog'').


\section{Brief Notes on C-Media 8338/8738/8768/8770 Driver}
\label{sound/cards/cmipci:brief-notes-on-c-media-8338-8738-8768-8770-driver}\label{sound/cards/cmipci::doc}
Takashi Iwai \textless{}\href{mailto:tiwai@suse.de}{tiwai@suse.de}\textgreater{}


\subsection{Front/Rear Multi-channel Playback}
\label{sound/cards/cmipci:front-rear-multi-channel-playback}
CM8x38 chip can use ADC as the second DAC so that two different stereo
channels can be used for front/rear playbacks.  Since there are two
DACs, both streams are handled independently unlike the 4/6ch multi-
channel playbacks in the section below.

As default, ALSA driver assigns the first PCM device (i.e. hw:0,0 for
card\#0) for front and 4/6ch playbacks, while the second PCM device
(hw:0,1) is assigned to the second DAC for rear playback.

There are slight differences between the two DACs:
\begin{itemize}
\item {} 
The first DAC supports U8 and S16LE formats, while the second DAC
supports only S16LE.

\item {} 
The second DAC supports only two channel stereo.

\end{itemize}

Please note that the CM8x38 DAC doesn't support continuous playback
rate but only fixed rates: 5512, 8000, 11025, 16000, 22050, 32000,
44100 and 48000 Hz.

The rear output can be heard only when ``Four Channel Mode'' switch is
disabled.  Otherwise no signal will be routed to the rear speakers.
As default it's turned on.

\begin{notice}{warning}{Warning:}
When ``Four Channel Mode'' switch is off, the output from rear speakers
will be FULL VOLUME regardless of Master and PCM volumes \footnote[1]{
Well.. I once got the output with correct volume (i.e. same with the
front one) and was so excited.  It was even with ``Four Channel'' bit
on and ``double DAC'' mode.  Actually I could hear separate 4 channels
from front and rear speakers!  But.. after reboot, all was gone.
It's a very pity that I didn't save the register dump at that
time..  Maybe there is an unknown register to achieve this...
}.
This might damage your audio equipment.  Please disconnect speakers
before your turn off this switch.
\end{notice}

If your card has an extra output jack for the rear output, the rear
playback should be routed there as default.  If not, there is a
control switch in the driver ``Line-In As Rear'', which you can change
via alsamixer or somewhat else.  When this switch is on, line-in jack
is used as rear output.

There are two more controls regarding to the rear output.
The ``Exchange DAC'' switch is used to exchange front and rear playback
routes, i.e. the 2nd DAC is output from front output.


\subsection{4/6 Multi-Channel Playback}
\label{sound/cards/cmipci:multi-channel-playback}
The recent CM8738 chips support for the 4/6 multi-channel playback
function.  This is useful especially for AC3 decoding.

When the multi-channel is supported, the driver name has a suffix
``-MC'' such like ``CMI8738-MC6''.  You can check this name from
/proc/asound/cards.

When the 4/6-ch output is enabled, the second DAC accepts up to 6 (or
4) channels.  While the dual DAC supports two different rates or
formats, the 4/6-ch playback supports only the same condition for all
channels.  Since the multi-channel playback mode uses both DACs, you
cannot operate with full-duplex.

The 4.0 and 5.1 modes are defined as the pcm ``surround40'' and ``surround51''
in alsa-lib.  For example, you can play a WAV file with 6 channels like

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} aplay \PYGZhy{}Dsurround51 sixchannels.wav
\end{Verbatim}

For programming the 4/6 channel playback, you need to specify the PCM
channels as you like and set the format S16LE.  For example, for playback
with 4 channels,

\begin{Verbatim}[commandchars=\\\{\}]
snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}params\PYGZus{}set\PYGZus{}access(pcm, hw, SND\PYGZus{}PCM\PYGZus{}ACCESS\PYGZus{}RW\PYGZus{}INTERLEAVED);
    // or mmap if you like
snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}params\PYGZus{}set\PYGZus{}format(pcm, hw, SND\PYGZus{}PCM\PYGZus{}FORMAT\PYGZus{}S16\PYGZus{}LE);
snd\PYGZus{}pcm\PYGZus{}hw\PYGZus{}params\PYGZus{}set\PYGZus{}channels(pcm, hw, 4);
\end{Verbatim}

and use the interleaved 4 channel data.

There are some control switches affecting to the speaker connections:
\begin{description}
\item[{Line-In Mode}] \leavevmode
an enum control to change the behavior of line-in
jack.  Either ``Line-In'', ``Rear Output'' or ``Bass Output'' can
be selected.  The last item is available only with model 039
or newer.
When ``Rear Output'' is chosen, the surround channels 3 and 4
are output to line-in jack.

\item[{Mic-In Mode}] \leavevmode
an enum control to change the behavior of mic-in
jack.  Either ``Mic-In'' or ``Center/LFE Output'' can be
selected.
When ``Center/LFE Output'' is chosen, the center and bass
channels (channels 5 and 6) are output to mic-in jack.

\end{description}


\subsection{Digital I/O}
\label{sound/cards/cmipci:digital-i-o}
The CM8x38 provides the excellent SPDIF capability with very cheap
price (yes, that's the reason I bought the card :)

The SPDIF playback and capture are done via the third PCM device
(hw:0,2).  Usually this is assigned to the PCM device ``spdif''.
The available rates are 44100 and 48000 Hz.
For playback with aplay, you can run like below:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} aplay \PYGZhy{}Dhw:0,2 foo.wav
\end{Verbatim}

or

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} aplay \PYGZhy{}Dspdif foo.wav
\end{Verbatim}

24bit format is also supported experimentally.

The playback and capture over SPDIF use normal DAC and ADC,
respectively, so you cannot playback both analog and digital streams
simultaneously.

To enable SPDIF output, you need to turn on ``IEC958 Output Switch''
control via mixer or alsactl (``IEC958'' is the official name of
so-called S/PDIF).  Then you'll see the red light on from the card so
you know that's working obviously :)
The SPDIF input is always enabled, so you can hear SPDIF input data
from line-out with ``IEC958 In Monitor'' switch at any time (see
below).

You can play via SPDIF even with the first device (hw:0,0),
but SPDIF is enabled only when the proper format (S16LE), sample rate
(441100 or 48000) and channels (2) are used.  Otherwise it's turned
off.  (Also don't forget to turn on ``IEC958 Output Switch'', too.)

Additionally there are relevant control switches:
\begin{description}
\item[{IEC958 Mix Analog}] \leavevmode
Mix analog PCM playback and FM-OPL/3 streams and
output through SPDIF.  This switch appears only on old chip
models (CM8738 033 and 037).

Note: without this control you can output PCM to SPDIF.
This is ``mixing'' of streams, so e.g. it's not for AC3 output
(see the next section).

\item[{IEC958 In Select}] \leavevmode
Select SPDIF input, the internal CD-in (false)
and the external input (true).

\item[{IEC958 Loop}] \leavevmode
SPDIF input data is loop back into SPDIF
output (aka bypass)

\item[{IEC958 Copyright}] \leavevmode
Set the copyright bit.

\item[{IEC958 5V}] \leavevmode
Select 0.5V (coax) or 5V (optical) interface.
On some cards this doesn't work and you need to change the
configuration with hardware dip-switch.

\item[{IEC958 In Monitor}] \leavevmode
SPDIF input is routed to DAC.

\item[{IEC958 In Phase Inverse}] \leavevmode
Set SPDIF input format as inverse.
{[}FIXME: this doesn't work on all chips..{]}

\item[{IEC958 In Valid}] \leavevmode
Set input validity flag detection.

\end{description}

Note: When ``PCM Playback Switch'' is on, you'll hear the digital output
stream through analog line-out.


\subsection{The AC3 (RAW DIGITAL) OUTPUT}
\label{sound/cards/cmipci:the-ac3-raw-digital-output}
The driver supports raw digital (typically AC3) i/o over SPDIF.  This
can be toggled via IEC958 playback control, but usually you need to
access it via alsa-lib.  See alsa-lib documents for more details.

On the raw digital mode, the ``PCM Playback Switch'' is automatically
turned off so that non-audio data is heard from the analog line-out.
Similarly the following switches are off: ``IEC958 Mix Analog'' and
``IEC958 Loop''.  The switches are resumed after closing the SPDIF PCM
device automatically to the previous state.

On the model 033, AC3 is implemented by the software conversion in
the alsa-lib.  If you need to bypass the software conversion of IEC958
subframes, pass the ``soft\_ac3=0'' module option.  This doesn't matter
on the newer models.


\subsection{ANALOG MIXER INTERFACE}
\label{sound/cards/cmipci:analog-mixer-interface}
The mixer interface on CM8x38 is similar to SB16.
There are Master, PCM, Synth, CD, Line, Mic and PC Speaker playback
volumes.  Synth, CD, Line and Mic have playback and capture switches,
too, as well as SB16.

In addition to the standard SB mixer, CM8x38 provides more functions.
- PCM playback switch
- PCM capture switch (to capture the data sent to DAC)
- Mic Boost switch
- Mic capture volume
- Aux playback volume/switch and capture switch
- 3D control switch


\subsection{MIDI CONTROLLER}
\label{sound/cards/cmipci:midi-controller}
With CMI8338 chips, the MPU401-UART interface is disabled as default.
You need to set the module option ``mpu\_port'' to a valid I/O port address
to enable MIDI support.  Valid I/O ports are 0x300, 0x310, 0x320 and
0x330.  Choose a value that doesn't conflict with other cards.

With CMI8738 and newer chips, the MIDI interface is enabled by default
and the driver automatically chooses a port address.

There is \emph{no} hardware wavetable function on this chip (except for
OPL3 synth below).
What's said as MIDI synth on Windows is a software synthesizer
emulation.  On Linux use TiMidity or other softsynth program for
playing MIDI music.


\subsection{FM OPL/3 Synth}
\label{sound/cards/cmipci:fm-opl-3-synth}
The FM OPL/3 is also enabled as default only for the first card.
Set ``fm\_port'' module option for more cards.

The output quality of FM OPL/3 is, however, very weird.
I don't know why..

CMI8768 and newer chips do not have the FM synth.


\subsection{Joystick and Modem}
\label{sound/cards/cmipci:joystick-and-modem}
The legacy joystick is supported.  To enable the joystick support, pass
joystick\_port=1 module option.  The value 1 means the auto-detection.
If the auto-detection fails, try to pass the exact I/O address.

The modem is enabled dynamically via a card control switch ``Modem''.


\subsection{Debugging Information}
\label{sound/cards/cmipci:debugging-information}
The registers are shown in /proc/asound/cardX/cmipci.  If you have any
problem (especially unexpected behavior of mixer), please attach the
output of this proc file together with the bug report.


\section{Sound Blaster Live mixer / default DSP code}
\label{sound/cards/sb-live-mixer:sound-blaster-live-mixer-default-dsp-code}\label{sound/cards/sb-live-mixer::doc}
The EMU10K1 chips have a DSP part which can be programmed to support
various ways of sample processing, which is described here.
(This article does not deal with the overall functionality of the
EMU10K1 chips. See the manuals section for further details.)

The ALSA driver programs this portion of chip by default code
(can be altered later) which offers the following functionality:


\subsection{IEC958 (S/PDIF) raw PCM}
\label{sound/cards/sb-live-mixer:iec958-s-pdif-raw-pcm}
This PCM device (it's the 4th PCM device (index 3!) and first subdevice
(index 0) for a given card) allows to forward 48kHz, stereo, 16-bit
little endian streams without any modifications to the digital output
(coaxial or optical). The universal interface allows the creation of up
to 8 raw PCM devices operating at 48kHz, 16-bit little endian. It would
be easy to add support for multichannel devices to the current code,
but the conversion routines exist only for stereo (2-channel streams)
at the time.

Look to tram\_poke routines in lowlevel/emu10k1/emufx.c for more details.


\subsection{Digital mixer controls}
\label{sound/cards/sb-live-mixer:digital-mixer-controls}
These controls are built using the DSP instructions. They offer extended
functionality. Only the default build-in code in the ALSA driver is described
here. Note that the controls work as attenuators: the maximum value is the
neutral position leaving the signal unchanged. Note that if the  same destination
is mentioned in multiple controls, the signal is accumulated and can be wrapped
(set to maximal or minimal value without checking of overflow).

Explanation of used abbreviations:
\begin{description}
\item[{DAC}] \leavevmode
digital to analog converter

\item[{ADC}] \leavevmode
analog to digital converter

\item[{I2S}] \leavevmode
one-way three wire serial bus for digital sound by Philips Semiconductors
(this standard is used for connecting standalone DAC and ADC converters)

\item[{LFE}] \leavevmode
low frequency effects (subwoofer signal)

\item[{AC97}] \leavevmode
a chip containing an analog mixer, DAC and ADC converters

\item[{IEC958}] \leavevmode
S/PDIF

\item[{FX-bus}] \leavevmode
the EMU10K1 chip has an effect bus containing 16 accumulators.
Each of the synthesizer voices can feed its output to these accumulators
and the DSP microcontroller can operate with the resulting sum.

\end{description}


\subsubsection{\texttt{name='Wave Playback Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-wave-playback-volume-index-0}
This control is used to attenuate samples for left and right PCM FX-bus
accumulators. ALSA uses accumulators 0 and 1 for left and right PCM samples.
The result samples are forwarded to the front DAC PCM slots of the AC97 codec.


\subsubsection{\texttt{name='Wave Surround Playback Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-wave-surround-playback-volume-index-0}
This control is used to attenuate samples for left and right PCM FX-bus
accumulators. ALSA uses accumulators 0 and 1 for left and right PCM samples.
The result samples are forwarded to the rear I2S DACs. These DACs operates
separately (they are not inside the AC97 codec).


\subsubsection{\texttt{name='Wave Center Playback Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-wave-center-playback-volume-index-0}
This control is used to attenuate samples for left and right PCM FX-bus
accumulators. ALSA uses accumulators 0 and 1 for left and right PCM samples.
The result is mixed to mono signal (single channel) and forwarded to
the ??rear?? right DAC PCM slot of the AC97 codec.


\subsubsection{\texttt{name='Wave LFE Playback Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-wave-lfe-playback-volume-index-0}
This control is used to attenuate samples for left and right PCM FX-bus
accumulators. ALSA uses accumulators 0 and 1 for left and right PCM.
The result is mixed to mono signal (single channel) and forwarded to
the ??rear?? left DAC PCM slot of the AC97 codec.


\subsubsection{\texttt{name='Wave Capture Volume',index=0}, \texttt{name='Wave Capture Switch',index=0}}
\label{sound/cards/sb-live-mixer:name-wave-capture-volume-index-0-name-wave-capture-switch-index-0}
These controls are used to attenuate samples for left and right PCM FX-bus
accumulator. ALSA uses accumulators 0 and 1 for left and right PCM.
The result is forwarded to the ADC capture FIFO (thus to the standard capture
PCM device).


\subsubsection{\texttt{name='Synth Playback Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-synth-playback-volume-index-0}
This control is used to attenuate samples for left and right MIDI FX-bus
accumulators. ALSA uses accumulators 4 and 5 for left and right MIDI samples.
The result samples are forwarded to the front DAC PCM slots of the AC97 codec.


\subsubsection{\texttt{name='Synth Capture Volume',index=0}, \texttt{name='Synth Capture Switch',index=0}}
\label{sound/cards/sb-live-mixer:name-synth-capture-volume-index-0-name-synth-capture-switch-index-0}
These controls are used to attenuate samples for left and right MIDI FX-bus
accumulator. ALSA uses accumulators 4 and 5 for left and right PCM.
The result is forwarded to the ADC capture FIFO (thus to the standard capture
PCM device).


\subsubsection{\texttt{name='Surround Playback Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-surround-playback-volume-index-0}
This control is used to attenuate samples for left and right rear PCM FX-bus
accumulators. ALSA uses accumulators 2 and 3 for left and right rear PCM samples.
The result samples are forwarded to the rear I2S DACs. These DACs operate
separately (they are not inside the AC97 codec).


\subsubsection{\texttt{name='Surround Capture Volume',index=0}, \texttt{name='Surround Capture Switch',index=0}}
\label{sound/cards/sb-live-mixer:name-surround-capture-volume-index-0-name-surround-capture-switch-index-0}
These controls are used to attenuate samples for left and right rear PCM FX-bus
accumulators. ALSA uses accumulators 2 and 3 for left and right rear PCM samples.
The result is forwarded to the ADC capture FIFO (thus to the standard capture
PCM device).


\subsubsection{\texttt{name='Center Playback Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-center-playback-volume-index-0}
This control is used to attenuate sample for center PCM FX-bus accumulator.
ALSA uses accumulator 6 for center PCM sample. The result sample is forwarded
to the ??rear?? right DAC PCM slot of the AC97 codec.


\subsubsection{\texttt{name='LFE Playback Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-lfe-playback-volume-index-0}
This control is used to attenuate sample for center PCM FX-bus accumulator.
ALSA uses accumulator 6 for center PCM sample. The result sample is forwarded
to the ??rear?? left DAC PCM slot of the AC97 codec.


\subsubsection{\texttt{name='AC97 Playback Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-ac97-playback-volume-index-0}
This control is used to attenuate samples for left and right front ADC PCM slots
of the AC97 codec. The result samples are forwarded to the front DAC PCM
slots of the AC97 codec.

\begin{notice}{note}{Note:}
This control should be zero for the standard operations, otherwise
a digital loopback is activated.
\end{notice}


\subsubsection{\texttt{name='AC97 Capture Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-ac97-capture-volume-index-0}
This control is used to attenuate samples for left and right front ADC PCM slots
of the AC97 codec. The result is forwarded to the ADC capture FIFO (thus to
the standard capture PCM device).

\begin{notice}{note}{Note:}
This control should be 100 (maximal value), otherwise no analog
inputs of the AC97 codec can be captured (recorded).
\end{notice}


\subsubsection{\texttt{name='IEC958 TTL Playback Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-iec958-ttl-playback-volume-index-0}
This control is used to attenuate samples from left and right IEC958 TTL
digital inputs (usually used by a CDROM drive). The result samples are
forwarded to the front DAC PCM slots of the AC97 codec.


\subsubsection{\texttt{name='IEC958 TTL Capture Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-iec958-ttl-capture-volume-index-0}
This control is used to attenuate samples from left and right IEC958 TTL
digital inputs (usually used by a CDROM drive). The result samples are
forwarded to the ADC capture FIFO (thus to the standard capture PCM device).


\subsubsection{\texttt{name='Zoom Video Playback Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-zoom-video-playback-volume-index-0}
This control is used to attenuate samples from left and right zoom video
digital inputs (usually used by a CDROM drive). The result samples are
forwarded to the front DAC PCM slots of the AC97 codec.


\subsubsection{\texttt{name='Zoom Video Capture Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-zoom-video-capture-volume-index-0}
This control is used to attenuate samples from left and right zoom video
digital inputs (usually used by a CDROM drive). The result samples are
forwarded to the ADC capture FIFO (thus to the standard capture PCM device).


\subsubsection{\texttt{name='IEC958 LiveDrive Playback Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-iec958-livedrive-playback-volume-index-0}
This control is used to attenuate samples from left and right IEC958 optical
digital input. The result samples are forwarded to the front DAC PCM slots
of the AC97 codec.


\subsubsection{\texttt{name='IEC958 LiveDrive Capture Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-iec958-livedrive-capture-volume-index-0}
This control is used to attenuate samples from left and right IEC958 optical
digital inputs. The result samples are forwarded to the ADC capture FIFO
(thus to the standard capture PCM device).


\subsubsection{\texttt{name='IEC958 Coaxial Playback Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-iec958-coaxial-playback-volume-index-0}
This control is used to attenuate samples from left and right IEC958 coaxial
digital inputs. The result samples are forwarded to the front DAC PCM slots
of the AC97 codec.


\subsubsection{\texttt{name='IEC958 Coaxial Capture Volume',index=0}}
\label{sound/cards/sb-live-mixer:name-iec958-coaxial-capture-volume-index-0}
This control is used to attenuate samples from left and right IEC958 coaxial
digital inputs. The result samples are forwarded to the ADC capture FIFO
(thus to the standard capture PCM device).


\subsubsection{\texttt{name='Line LiveDrive Playback Volume',index=0}, \texttt{name='Line LiveDrive Playback Volume',index=1}}
\label{sound/cards/sb-live-mixer:name-line-livedrive-playback-volume-index-0-name-line-livedrive-playback-volume-index-1}
This control is used to attenuate samples from left and right I2S ADC
inputs (on the LiveDrive). The result samples are forwarded to the front
DAC PCM slots of the AC97 codec.


\subsubsection{\texttt{name='Line LiveDrive Capture Volume',index=1}, \texttt{name='Line LiveDrive Capture Volume',index=1}}
\label{sound/cards/sb-live-mixer:name-line-livedrive-capture-volume-index-1-name-line-livedrive-capture-volume-index-1}
This control is used to attenuate samples from left and right I2S ADC
inputs (on the LiveDrive). The result samples are forwarded to the ADC
capture FIFO (thus to the standard capture PCM device).


\subsubsection{\texttt{name='Tone Control - Switch',index=0}}
\label{sound/cards/sb-live-mixer:name-tone-control-switch-index-0}
This control turns the tone control on or off. The samples for front, rear
and center / LFE outputs are affected.


\subsubsection{\texttt{name='Tone Control - Bass',index=0}}
\label{sound/cards/sb-live-mixer:name-tone-control-bass-index-0}
This control sets the bass intensity. There is no neutral value!!
When the tone control code is activated, the samples are always modified.
The closest value to pure signal is 20.


\subsubsection{\texttt{name='Tone Control - Treble',index=0}}
\label{sound/cards/sb-live-mixer:name-tone-control-treble-index-0}
This control sets the treble intensity. There is no neutral value!!
When the tone control code is activated, the samples are always modified.
The closest value to pure signal is 20.


\subsubsection{\texttt{name='IEC958 Optical Raw Playback Switch',index=0}}
\label{sound/cards/sb-live-mixer:name-iec958-optical-raw-playback-switch-index-0}
If this switch is on, then the samples for the IEC958 (S/PDIF) digital
output are taken only from the raw FX8010 PCM, otherwise standard front
PCM samples are taken.


\subsubsection{\texttt{name='Headphone Playback Volume',index=1}}
\label{sound/cards/sb-live-mixer:name-headphone-playback-volume-index-1}
This control attenuates the samples for the headphone output.


\subsubsection{\texttt{name='Headphone Center Playback Switch',index=1}}
\label{sound/cards/sb-live-mixer:name-headphone-center-playback-switch-index-1}
If this switch is on, then the sample for the center PCM is put to the
left headphone output (useful for SB Live cards without separate center/LFE
output).


\subsubsection{\texttt{name='Headphone LFE Playback Switch',index=1}}
\label{sound/cards/sb-live-mixer:name-headphone-lfe-playback-switch-index-1}
If this switch is on, then the sample for the center PCM is put to the
right headphone output (useful for SB Live cards without separate center/LFE
output).


\subsection{PCM stream related controls}
\label{sound/cards/sb-live-mixer:pcm-stream-related-controls}

\subsubsection{\texttt{name='EMU10K1 PCM Volume',index 0-31}}
\label{sound/cards/sb-live-mixer:name-emu10k1-pcm-volume-index-0-31}
Channel volume attenuation in range 0-0xffff. The maximum value (no
attenuation) is default. The channel mapping for three values is
as follows:
\begin{itemize}
\item {} 
0 - mono, default 0xffff (no attenuation)

\item {} 
1 - left, default 0xffff (no attenuation)

\item {} 
2 - right, default 0xffff (no attenuation)

\end{itemize}


\subsubsection{\texttt{name='EMU10K1 PCM Send Routing',index 0-31}}
\label{sound/cards/sb-live-mixer:name-emu10k1-pcm-send-routing-index-0-31}
This control specifies the destination - FX-bus accumulators. There are
twelve values with this mapping:
\begin{itemize}
\item {} 
0 -  mono, A destination (FX-bus 0-15), default 0

\item {} 
1 -  mono, B destination (FX-bus 0-15), default 1

\item {} 
2 -  mono, C destination (FX-bus 0-15), default 2

\item {} 
3 -  mono, D destination (FX-bus 0-15), default 3

\item {} 
4 -  left, A destination (FX-bus 0-15), default 0

\item {} 
5 -  left, B destination (FX-bus 0-15), default 1

\item {} 
6 -  left, C destination (FX-bus 0-15), default 2

\item {} 
7 -  left, D destination (FX-bus 0-15), default 3

\item {} 
8 - right, A destination (FX-bus 0-15), default 0

\item {} 
9 - right, B destination (FX-bus 0-15), default 1

\item {} 
10 - right, C destination (FX-bus 0-15), default 2

\item {} 
11 - right, D destination (FX-bus 0-15), default 3

\end{itemize}

Don't forget that it's illegal to assign a channel to the same FX-bus accumulator
more than once (it means 0=0 \&\& 1=0 is an invalid combination).


\subsubsection{\texttt{name='EMU10K1 PCM Send Volume',index 0-31}}
\label{sound/cards/sb-live-mixer:name-emu10k1-pcm-send-volume-index-0-31}
It specifies the attenuation (amount) for given destination in range 0-255.
The channel mapping is following:
\begin{itemize}
\item {} 
0 -  mono, A destination attn, default 255 (no attenuation)

\item {} 
1 -  mono, B destination attn, default 255 (no attenuation)

\item {} 
2 -  mono, C destination attn, default 0 (mute)

\item {} 
3 -  mono, D destination attn, default 0 (mute)

\item {} 
4 -  left, A destination attn, default 255 (no attenuation)

\item {} 
5 -  left, B destination attn, default 0 (mute)

\item {} 
6 -  left, C destination attn, default 0 (mute)

\item {} 
7 -  left, D destination attn, default 0 (mute)

\item {} 
8 - right, A destination attn, default 0 (mute)

\item {} 
9 - right, B destination attn, default 255 (no attenuation)

\item {} 
10 - right, C destination attn, default 0 (mute)

\item {} 
11 - right, D destination attn, default 0 (mute)

\end{itemize}


\subsection{MANUALS/PATENTS}
\label{sound/cards/sb-live-mixer:manuals-patents}

\subsubsection{ftp://opensource.creative.com/pub/doc}
\label{sound/cards/sb-live-mixer:ftp-opensource-creative-com-pub-doc}\begin{description}
\item[{LM4545.pdf}] \leavevmode
AC97 Codec

\item[{m2049.pdf}] \leavevmode
The EMU10K1 Digital Audio Processor

\item[{hog63.ps}] \leavevmode
FX8010 - A DSP Chip Architecture for Audio Effects

\end{description}


\subsubsection{WIPO Patents}
\label{sound/cards/sb-live-mixer:wipo-patents}\begin{description}
\item[{WO 9901813 (A1)}] \leavevmode
Audio Effects Processor with multiple asynchronous streams
(Jan. 14, 1999)

\item[{WO 9901814 (A1)}] \leavevmode
Processor with Instruction Set for Audio Effects (Jan. 14, 1999)

\item[{WO 9901953 (A1)}] \leavevmode
Audio Effects Processor having Decoupled Instruction
Execution and Audio Data Sequencing (Jan. 14, 1999)

\end{description}


\subsubsection{US Patents (http://www.uspto.gov/)}
\label{sound/cards/sb-live-mixer:us-patents-http-www-uspto-gov}\begin{description}
\item[{US 5925841}] \leavevmode
Digital Sampling Instrument employing cache memory (Jul. 20, 1999)

\item[{US 5928342}] \leavevmode
Audio Effects Processor integrated on a single chip
with a multiport memory onto which multiple asynchronous
digital sound samples can be concurrently loaded
(Jul. 27, 1999)

\item[{US 5930158}] \leavevmode
Processor with Instruction Set for Audio Effects (Jul. 27, 1999)

\item[{US 6032235}] \leavevmode
Memory initialization circuit (Tram) (Feb. 29, 2000)

\item[{US 6138207}] \leavevmode
Interpolation looping of audio samples in cache connected to
system bus with prioritization and modification of bus transfers
in accordance with loop ends and minimum block sizes
(Oct. 24, 2000)

\item[{US 6151670}] \leavevmode
Method for conserving memory storage using a
pool of  short term memory registers
(Nov. 21, 2000)

\item[{US 6195715}] \leavevmode
Interrupt control for multiple programs communicating with
a common interrupt by associating programs to GP registers,
defining interrupt register, polling GP registers, and invoking
callback routine associated with defined interrupt register
(Feb. 27, 2001)

\end{description}


\section{Sound Blaster Audigy mixer / default DSP code}
\label{sound/cards/audigy-mixer:sound-blaster-audigy-mixer-default-dsp-code}\label{sound/cards/audigy-mixer::doc}
This is based on sb-live-mixer.rst.

The EMU10K2 chips have a DSP part which can be programmed to support
various ways of sample processing, which is described here.
(This article does not deal with the overall functionality of the
EMU10K2 chips. See the manuals section for further details.)

The ALSA driver programs this portion of chip by default code
(can be altered later) which offers the following functionality:


\subsection{Digital mixer controls}
\label{sound/cards/audigy-mixer:digital-mixer-controls}
These controls are built using the DSP instructions. They offer extended
functionality. Only the default build-in code in the ALSA driver is described
here. Note that the controls work as attenuators: the maximum value is the
neutral position leaving the signal unchanged. Note that if the  same destination
is mentioned in multiple controls, the signal is accumulated and can be wrapped
(set to maximal or minimal value without checking of overflow).

Explanation of used abbreviations:
\begin{description}
\item[{DAC}] \leavevmode
digital to analog converter

\item[{ADC}] \leavevmode
analog to digital converter

\item[{I2S}] \leavevmode
one-way three wire serial bus for digital sound by Philips Semiconductors
(this standard is used for connecting standalone DAC and ADC converters)

\item[{LFE}] \leavevmode
low frequency effects (subwoofer signal)

\item[{AC97}] \leavevmode
a chip containing an analog mixer, DAC and ADC converters

\item[{IEC958}] \leavevmode
S/PDIF

\item[{FX-bus}] \leavevmode
the EMU10K2 chip has an effect bus containing 64 accumulators.
Each of the synthesizer voices can feed its output to these accumulators
and the DSP microcontroller can operate with the resulting sum.

\end{description}


\subsubsection{name='PCM Front Playback Volume',index=0}
\label{sound/cards/audigy-mixer:name-pcm-front-playback-volume-index-0}
This control is used to attenuate samples for left and right front PCM FX-bus
accumulators. ALSA uses accumulators 8 and 9 for left and right front PCM
samples for 5.1 playback. The result samples are forwarded to the front DAC PCM
slots of the Philips DAC.


\subsubsection{name='PCM Surround Playback Volume',index=0}
\label{sound/cards/audigy-mixer:name-pcm-surround-playback-volume-index-0}
This control is used to attenuate samples for left and right surround PCM FX-bus
accumulators. ALSA uses accumulators 2 and 3 for left and right surround PCM
samples for 5.1 playback. The result samples are forwarded to the surround DAC PCM
slots of the Philips DAC.


\subsubsection{name='PCM Center Playback Volume',index=0}
\label{sound/cards/audigy-mixer:name-pcm-center-playback-volume-index-0}
This control is used to attenuate samples for center PCM FX-bus accumulator.
ALSA uses accumulator 6 for center PCM sample for 5.1 playback. The result sample
is forwarded to the center DAC PCM slot of the Philips DAC.


\subsubsection{name='PCM LFE Playback Volume',index=0}
\label{sound/cards/audigy-mixer:name-pcm-lfe-playback-volume-index-0}
This control is used to attenuate sample for LFE PCM FX-bus accumulator.
ALSA uses accumulator 7 for LFE PCM sample for 5.1 playback. The result sample
is forwarded to the LFE DAC PCM slot of the Philips DAC.


\subsubsection{name='PCM Playback Volume',index=0}
\label{sound/cards/audigy-mixer:name-pcm-playback-volume-index-0}
This control is used to attenuate samples for left and right PCM FX-bus
accumulators. ALSA uses accumulators 0 and 1 for left and right PCM samples for
stereo playback. The result samples are forwarded to the front DAC PCM slots
of the Philips DAC.


\subsubsection{name='PCM Capture Volume',index=0}
\label{sound/cards/audigy-mixer:name-pcm-capture-volume-index-0}
This control is used to attenuate samples for left and right PCM FX-bus
accumulator. ALSA uses accumulators 0 and 1 for left and right PCM.
The result is forwarded to the ADC capture FIFO (thus to the standard capture
PCM device).


\subsubsection{name='Music Playback Volume',index=0}
\label{sound/cards/audigy-mixer:name-music-playback-volume-index-0}
This control is used to attenuate samples for left and right MIDI FX-bus
accumulators. ALSA uses accumulators 4 and 5 for left and right MIDI samples.
The result samples are forwarded to the front DAC PCM slots of the AC97 codec.


\subsubsection{name='Music Capture Volume',index=0}
\label{sound/cards/audigy-mixer:name-music-capture-volume-index-0}
These controls are used to attenuate samples for left and right MIDI FX-bus
accumulator. ALSA uses accumulators 4 and 5 for left and right PCM.
The result is forwarded to the ADC capture FIFO (thus to the standard capture
PCM device).


\subsubsection{name='Mic Playback Volume',index=0}
\label{sound/cards/audigy-mixer:name-mic-playback-volume-index-0}
This control is used to attenuate samples for left and right Mic input.
For Mic input is used AC97 codec. The result samples are forwarded to
the front DAC PCM slots of the Philips DAC. Samples are forwarded to Mic
capture FIFO (device 1 - 16bit/8KHz mono) too without volume control.


\subsubsection{name='Mic Capture Volume',index=0}
\label{sound/cards/audigy-mixer:name-mic-capture-volume-index-0}
This control is used to attenuate samples for left and right Mic input.
The result is forwarded to the ADC capture FIFO (thus to the standard capture
PCM device).


\subsubsection{name='Audigy CD Playback Volume',index=0}
\label{sound/cards/audigy-mixer:name-audigy-cd-playback-volume-index-0}
This control is used to attenuate samples from left and right IEC958 TTL
digital inputs (usually used by a CDROM drive). The result samples are
forwarded to the front DAC PCM slots of the Philips DAC.


\subsubsection{name='Audigy CD Capture Volume',index=0}
\label{sound/cards/audigy-mixer:name-audigy-cd-capture-volume-index-0}
This control is used to attenuate samples from left and right IEC958 TTL
digital inputs (usually used by a CDROM drive). The result samples are
forwarded to the ADC capture FIFO (thus to the standard capture PCM device).


\subsubsection{name='IEC958 Optical Playback Volume',index=0}
\label{sound/cards/audigy-mixer:name-iec958-optical-playback-volume-index-0}
This control is used to attenuate samples from left and right IEC958 optical
digital input. The result samples are forwarded to the front DAC PCM slots
of the Philips DAC.


\subsubsection{name='IEC958 Optical Capture Volume',index=0}
\label{sound/cards/audigy-mixer:name-iec958-optical-capture-volume-index-0}
This control is used to attenuate samples from left and right IEC958 optical
digital inputs. The result samples are forwarded to the ADC capture FIFO
(thus to the standard capture PCM device).


\subsubsection{name='Line2 Playback Volume',index=0}
\label{sound/cards/audigy-mixer:name-line2-playback-volume-index-0}
This control is used to attenuate samples from left and right I2S ADC
inputs (on the AudigyDrive). The result samples are forwarded to the front
DAC PCM slots of the Philips DAC.


\subsubsection{name='Line2 Capture Volume',index=1}
\label{sound/cards/audigy-mixer:name-line2-capture-volume-index-1}
This control is used to attenuate samples from left and right I2S ADC
inputs (on the AudigyDrive). The result samples are forwarded to the ADC
capture FIFO (thus to the standard capture PCM device).


\subsubsection{name='Analog Mix Playback Volume',index=0}
\label{sound/cards/audigy-mixer:name-analog-mix-playback-volume-index-0}
This control is used to attenuate samples from left and right I2S ADC
inputs from Philips ADC. The result samples are forwarded to the front
DAC PCM slots of the Philips DAC. This contains mix from analog sources
like CD, Line In, Aux, ....


\subsubsection{name='Analog Mix Capture Volume',index=1}
\label{sound/cards/audigy-mixer:name-analog-mix-capture-volume-index-1}
This control is used to attenuate samples from left and right I2S ADC
inputs Philips ADC. The result samples are forwarded to the ADC
capture FIFO (thus to the standard capture PCM device).


\subsubsection{name='Aux2 Playback Volume',index=0}
\label{sound/cards/audigy-mixer:name-aux2-playback-volume-index-0}
This control is used to attenuate samples from left and right I2S ADC
inputs (on the AudigyDrive). The result samples are forwarded to the front
DAC PCM slots of the Philips DAC.


\subsubsection{name='Aux2 Capture Volume',index=1}
\label{sound/cards/audigy-mixer:name-aux2-capture-volume-index-1}
This control is used to attenuate samples from left and right I2S ADC
inputs (on the AudigyDrive). The result samples are forwarded to the ADC
capture FIFO (thus to the standard capture PCM device).


\subsubsection{name='Front Playback Volume',index=0}
\label{sound/cards/audigy-mixer:name-front-playback-volume-index-0}
All stereo signals are mixed together and mirrored to surround, center and LFE.
This control is used to attenuate samples for left and right front speakers of
this mix.


\subsubsection{name='Surround Playback Volume',index=0}
\label{sound/cards/audigy-mixer:name-surround-playback-volume-index-0}
All stereo signals are mixed together and mirrored to surround, center and LFE.
This control is used to attenuate samples for left and right surround speakers of
this mix.


\subsubsection{name='Center Playback Volume',index=0}
\label{sound/cards/audigy-mixer:name-center-playback-volume-index-0}
All stereo signals are mixed together and mirrored to surround, center and LFE.
This control is used to attenuate sample for center speaker of this mix.


\subsubsection{name='LFE Playback Volume',index=0}
\label{sound/cards/audigy-mixer:name-lfe-playback-volume-index-0}
All stereo signals are mixed together and mirrored to surround, center and LFE.
This control is used to attenuate sample for LFE speaker of this mix.


\subsubsection{name='Tone Control - Switch',index=0}
\label{sound/cards/audigy-mixer:name-tone-control-switch-index-0}
This control turns the tone control on or off. The samples for front, rear
and center / LFE outputs are affected.


\subsubsection{name='Tone Control - Bass',index=0}
\label{sound/cards/audigy-mixer:name-tone-control-bass-index-0}
This control sets the bass intensity. There is no neutral value!!
When the tone control code is activated, the samples are always modified.
The closest value to pure signal is 20.


\subsubsection{name='Tone Control - Treble',index=0}
\label{sound/cards/audigy-mixer:name-tone-control-treble-index-0}
This control sets the treble intensity. There is no neutral value!!
When the tone control code is activated, the samples are always modified.
The closest value to pure signal is 20.


\subsubsection{name='Master Playback Volume',index=0}
\label{sound/cards/audigy-mixer:name-master-playback-volume-index-0}
This control is used to attenuate samples for front, surround, center and
LFE outputs.


\subsubsection{name='IEC958 Optical Raw Playback Switch',index=0}
\label{sound/cards/audigy-mixer:name-iec958-optical-raw-playback-switch-index-0}
If this switch is on, then the samples for the IEC958 (S/PDIF) digital
output are taken only from the raw FX8010 PCM, otherwise standard front
PCM samples are taken.


\subsection{PCM stream related controls}
\label{sound/cards/audigy-mixer:pcm-stream-related-controls}

\subsubsection{name='EMU10K1 PCM Volume',index 0-31}
\label{sound/cards/audigy-mixer:name-emu10k1-pcm-volume-index-0-31}
Channel volume attenuation in range 0-0xffff. The maximum value (no
attenuation) is default. The channel mapping for three values is
as follows:
\begin{itemize}
\item {} 
0 - mono, default 0xffff (no attenuation)

\item {} 
1 - left, default 0xffff (no attenuation)

\item {} 
2 - right, default 0xffff (no attenuation)

\end{itemize}


\subsubsection{name='EMU10K1 PCM Send Routing',index 0-31}
\label{sound/cards/audigy-mixer:name-emu10k1-pcm-send-routing-index-0-31}
This control specifies the destination - FX-bus accumulators. There 24
values with this mapping:
\begin{itemize}
\item {} 
0 -  mono, A destination (FX-bus 0-63), default 0

\item {} 
1 -  mono, B destination (FX-bus 0-63), default 1

\item {} 
2 -  mono, C destination (FX-bus 0-63), default 2

\item {} 
3 -  mono, D destination (FX-bus 0-63), default 3

\item {} 
4 -  mono, E destination (FX-bus 0-63), default 0

\item {} 
5 -  mono, F destination (FX-bus 0-63), default 0

\item {} 
6 -  mono, G destination (FX-bus 0-63), default 0

\item {} 
7 -  mono, H destination (FX-bus 0-63), default 0

\item {} 
8 -  left, A destination (FX-bus 0-63), default 0

\item {} 
9 -  left, B destination (FX-bus 0-63), default 1

\item {} 
10 -  left, C destination (FX-bus 0-63), default 2

\item {} 
11 -  left, D destination (FX-bus 0-63), default 3

\item {} 
12 -  left, E destination (FX-bus 0-63), default 0

\item {} 
13 -  left, F destination (FX-bus 0-63), default 0

\item {} 
14 -  left, G destination (FX-bus 0-63), default 0

\item {} 
15 -  left, H destination (FX-bus 0-63), default 0

\item {} 
16 - right, A destination (FX-bus 0-63), default 0

\item {} 
17 - right, B destination (FX-bus 0-63), default 1

\item {} 
18 - right, C destination (FX-bus 0-63), default 2

\item {} 
19 - right, D destination (FX-bus 0-63), default 3

\item {} 
20 - right, E destination (FX-bus 0-63), default 0

\item {} 
21 - right, F destination (FX-bus 0-63), default 0

\item {} 
22 - right, G destination (FX-bus 0-63), default 0

\item {} 
23 - right, H destination (FX-bus 0-63), default 0

\end{itemize}

Don't forget that it's illegal to assign a channel to the same FX-bus accumulator
more than once (it means 0=0 \&\& 1=0 is an invalid combination).


\subsubsection{name='EMU10K1 PCM Send Volume',index 0-31}
\label{sound/cards/audigy-mixer:name-emu10k1-pcm-send-volume-index-0-31}
It specifies the attenuation (amount) for given destination in range 0-255.
The channel mapping is following:
\begin{itemize}
\item {} 
0 -  mono, A destination attn, default 255 (no attenuation)

\item {} 
1 -  mono, B destination attn, default 255 (no attenuation)

\item {} 
2 -  mono, C destination attn, default 0 (mute)

\item {} 
3 -  mono, D destination attn, default 0 (mute)

\item {} 
4 -  mono, E destination attn, default 0 (mute)

\item {} 
5 -  mono, F destination attn, default 0 (mute)

\item {} 
6 -  mono, G destination attn, default 0 (mute)

\item {} 
7 -  mono, H destination attn, default 0 (mute)

\item {} 
8 -  left, A destination attn, default 255 (no attenuation)

\item {} 
9 -  left, B destination attn, default 0 (mute)

\item {} 
10 -  left, C destination attn, default 0 (mute)

\item {} 
11 -  left, D destination attn, default 0 (mute)

\item {} 
12 -  left, E destination attn, default 0 (mute)

\item {} 
13 -  left, F destination attn, default 0 (mute)

\item {} 
14 -  left, G destination attn, default 0 (mute)

\item {} 
15 -  left, H destination attn, default 0 (mute)

\item {} 
16 - right, A destination attn, default 0 (mute)

\item {} 
17 - right, B destination attn, default 255 (no attenuation)

\item {} 
18 - right, C destination attn, default 0 (mute)

\item {} 
19 - right, D destination attn, default 0 (mute)

\item {} 
20 - right, E destination attn, default 0 (mute)

\item {} 
21 - right, F destination attn, default 0 (mute)

\item {} 
22 - right, G destination attn, default 0 (mute)

\item {} 
23 - right, H destination attn, default 0 (mute)

\end{itemize}


\subsection{MANUALS/PATENTS}
\label{sound/cards/audigy-mixer:manuals-patents}

\subsubsection{ftp://opensource.creative.com/pub/doc}
\label{sound/cards/audigy-mixer:ftp-opensource-creative-com-pub-doc}\begin{description}
\item[{LM4545.pdf}] \leavevmode
AC97 Codec

\item[{m2049.pdf}] \leavevmode
The EMU10K1 Digital Audio Processor

\item[{hog63.ps}] \leavevmode
FX8010 - A DSP Chip Architecture for Audio Effects

\end{description}


\subsubsection{WIPO Patents}
\label{sound/cards/audigy-mixer:wipo-patents}\begin{description}
\item[{WO 9901813 (A1)}] \leavevmode
Audio Effects Processor with multiple asynchronous streams
(Jan. 14, 1999)

\item[{WO 9901814 (A1)}] \leavevmode
Processor with Instruction Set for Audio Effects (Jan. 14, 1999)

\item[{WO 9901953 (A1)}] \leavevmode
Audio Effects Processor having Decoupled Instruction
Execution and Audio Data Sequencing (Jan. 14, 1999)

\end{description}


\subsubsection{US Patents (http://www.uspto.gov/)}
\label{sound/cards/audigy-mixer:us-patents-http-www-uspto-gov}\begin{description}
\item[{US 5925841}] \leavevmode
Digital Sampling Instrument employing cache memory (Jul. 20, 1999)

\item[{US 5928342}] \leavevmode
Audio Effects Processor integrated on a single chip
with a multiport memory onto which multiple asynchronous
digital sound samples can be concurrently loaded
(Jul. 27, 1999)

\item[{US 5930158}] \leavevmode
Processor with Instruction Set for Audio Effects (Jul. 27, 1999)

\item[{US 6032235}] \leavevmode
Memory initialization circuit (Tram) (Feb. 29, 2000)

\item[{US 6138207}] \leavevmode
Interpolation looping of audio samples in cache connected to
system bus with prioritization and modification of bus transfers
in accordance with loop ends and minimum block sizes
(Oct. 24, 2000)

\item[{US 6151670}] \leavevmode
Method for conserving memory storage using a
pool of  short term memory registers
(Nov. 21, 2000)

\item[{US 6195715}] \leavevmode
Interrupt control for multiple programs communicating with
a common interrupt by associating programs to GP registers,
defining interrupt register, polling GP registers, and invoking
callback routine associated with defined interrupt register
(Feb. 27, 2001)

\end{description}


\section{Low latency, multichannel audio with JACK and the emu10k1/emu10k2}
\label{sound/cards/emu10k1-jack:low-latency-multichannel-audio-with-jack-and-the-emu10k1-emu10k2}\label{sound/cards/emu10k1-jack::doc}
This document is a guide to using the emu10k1 based devices with JACK for low
latency, multichannel recording functionality.  All of my recent work to allow
Linux users to use the full capabilities of their hardware has been inspired
by the kX Project.  Without their work I never would have discovered the true
power of this hardware.
\begin{quote}
\begin{description}
\item[{\href{http://www.kxproject.com}{http://www.kxproject.com}}] \leavevmode\begin{itemize}
\item {} 
Lee Revell, 2005.03.30

\end{itemize}

\end{description}
\end{quote}

Until recently, emu10k1 users on Linux did not have access to the same low
latency, multichannel features offered by the ``kX ASIO'' feature of their
Windows driver.  As of ALSA 1.0.9 this is no more!

For those unfamiliar with kX ASIO, this consists of 16 capture and 16 playback
channels.  With a post 2.6.9 Linux kernel, latencies down to 64 (1.33 ms) or
even 32 (0.66ms) frames should work well.

The configuration is slightly more involved than on Windows, as you have to
select the correct device for JACK to use.  Actually, for qjackctl users it's
fairly self explanatory - select Duplex, then for capture and playback select
the multichannel devices, set the in and out channels to 16, and the sample
rate to 48000Hz.  The command line looks like this:

\begin{Verbatim}[commandchars=\\\{\}]
/usr/local/bin/jackd \PYGZhy{}R \PYGZhy{}dalsa \PYGZhy{}r48000 \PYGZhy{}p64 \PYGZhy{}n2 \PYGZhy{}D \PYGZhy{}Chw:0,2 \PYGZhy{}Phw:0,3 \PYGZhy{}S
\end{Verbatim}

This will give you 16 input ports and 16 output ports.

The 16 output ports map onto the 16 FX buses (or the first 16 of 64, for the
Audigy).  The mapping from FX bus to physical output is described in
sb-live-mixer.rst (or audigy-mixer.rst).

The 16 input ports are connected to the 16 physical inputs.  Contrary to
popular belief, all emu10k1 cards are multichannel cards.  Which of these
input channels have physical inputs connected to them depends on the card
model.  Trial and error is highly recommended; the pinout diagrams
for the card have been reverse engineered by some enterprising kX users and are
available on the internet.  Meterbridge is helpful here, and the kX forums are
packed with useful information.

Each input port will either correspond to a digital (SPDIF) input, an analog
input, or nothing.  The one exception is the SBLive! 5.1.  On these devices,
the second and third input ports are wired to the center/LFE output.  You will
still see 16 capture channels, but only 14 are available for recording inputs.

This chart, borrowed from kxfxlib/da\_asio51.cpp, describes the mapping of JACK
ports to FXBUS2 (multitrack recording input) and EXTOUT (physical output)
channels.

JACK (\& ASIO) mappings on 10k1 5.1 SBLive cards:

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
JACK
} & \textsf{\relax 
Epilog
} & \textsf{\relax 
FXBUS2(nr)
}\\
\hline
capture\_1
 & 
asio14
 & 
FXBUS2(0xe)
\\
\hline
capture\_2
 & 
asio15
 & 
FXBUS2(0xf)
\\
\hline
capture\_3
 & 
asio0
 & 
FXBUS2(0x0)
\\
\hline
\textasciitilde{}capture\_4
 & 
Center
 & 
EXTOUT(0x11)    // mapped to by Center
\\
\hline
\textasciitilde{}capture\_5
 & 
LFE
 & 
EXTOUT(0x12)    // mapped to by LFE
\\
\hline
capture\_6
 & 
asio3
 & 
FXBUS2(0x3)
\\
\hline
capture\_7
 & 
asio4
 & 
FXBUS2(0x4)
\\
\hline
capture\_8
 & 
asio5
 & 
FXBUS2(0x5)
\\
\hline
capture\_9
 & 
asio6
 & 
FXBUS2(0x6)
\\
\hline
capture\_10
 & 
asio7
 & 
FXBUS2(0x7)
\\
\hline
capture\_11
 & 
asio8
 & 
FXBUS2(0x8)
\\
\hline
capture\_12
 & 
asio9
 & 
FXBUS2(0x9)
\\
\hline
capture\_13
 & 
asio10
 & 
FXBUS2(0xa)
\\
\hline
capture\_14
 & 
asio11
 & 
FXBUS2(0xb)
\\
\hline
capture\_15
 & 
asio12
 & 
FXBUS2(0xc)
\\
\hline
capture\_16
 & 
asio13
 & 
FXBUS2(0xd)
\\
\hline\end{tabulary}


TODO: describe use of ld10k1/qlo10k1 in conjunction with JACK


\section{VIA82xx mixer}
\label{sound/cards/via82xx-mixer::doc}\label{sound/cards/via82xx-mixer:via82xx-mixer}
On many VIA82xx boards, the \code{Input Source Select} mixer control does not work.
Setting it to \code{Input2} on such boards will cause recording to hang, or fail
with EIO (input/output error) via OSS emulation.  This control should be left
at \code{Input1} for such cards.


\section{Guide to using M-Audio Audiophile USB with ALSA and Jack}
\label{sound/cards/audiophile-usb::doc}\label{sound/cards/audiophile-usb:guide-to-using-m-audio-audiophile-usb-with-alsa-and-jack}
v1.5

Thibault Le Meur \textless{}\href{mailto:Thibault.LeMeur@supelec.fr}{Thibault.LeMeur@supelec.fr}\textgreater{}

This document is a guide to using the M-Audio Audiophile USB (tm) device with
ALSA and JACK.


\subsection{History}
\label{sound/cards/audiophile-usb:history}\begin{itemize}
\item {} 
v1.4 - Thibault Le Meur (2007-07-11)
\begin{itemize}
\item {} 
Added Low Endianness nature of 16bits-modes
found by Hakan Lennestal \textless{}\href{mailto:Hakan.Lennestal@brfsodrahamn.se}{Hakan.Lennestal@brfsodrahamn.se}\textgreater{}

\item {} 
Modifying document structure

\end{itemize}

\item {} 
v1.5 - Thibault Le Meur (2007-07-12)
- Added AC3/DTS passthru info

\end{itemize}


\subsection{Audiophile USB Specs and correct usage}
\label{sound/cards/audiophile-usb:audiophile-usb-specs-and-correct-usage}
This part is a reminder of important facts about the functions and limitations
of the device.

The device has 4 audio interfaces, and 2 MIDI ports:
\begin{itemize}
\item {} 
Analog Stereo Input (Ai)
\begin{itemize}
\item {} 
This port supports 2 pairs of line-level audio inputs (1/4'' TS and RCA)

\item {} 
When the 1/4'' TS (jack) connectors are connected, the RCA connectors
are disabled

\end{itemize}

\item {} 
Analog Stereo Output (Ao)

\item {} 
Digital Stereo Input (Di)

\item {} 
Digital Stereo Output (Do)

\item {} 
Midi In (Mi)

\item {} 
Midi Out (Mo)

\end{itemize}

The internal DAC/ADC has the following characteristics:
\begin{itemize}
\item {} 
sample depth of 16 or 24 bits

\item {} 
sample rate from 8kHz to 96kHz

\item {} 
Two interfaces can't use different sample depths at the same time.

\end{itemize}
\begin{description}
\item[{Moreover, the Audiophile USB documentation gives the following Warning:}] \leavevmode
Please exit any audio application running before switching between bit depths

\end{description}

Due to the USB 1.1 bandwidth limitation, a limited number of interfaces can be
activated at the same time depending on the audio mode selected:
\begin{itemize}
\item {} 
16-bit/48kHz ==\textgreater{} 4 channels in + 4 channels out
\begin{itemize}
\item {} 
Ai+Ao+Di+Do

\end{itemize}

\item {} 
24-bit/48kHz ==\textgreater{} 4 channels in + 2 channels out,
or 2 channels in + 4 channels out
\begin{itemize}
\item {} 
Ai+Ao+Do or Ai+Di+Ao or Ai+Di+Do or Di+Ao+Do

\end{itemize}

\item {} 
24-bit/96kHz ==\textgreater{} 2 channels in \_or\_ 2 channels out (half duplex only)
\begin{itemize}
\item {} 
Ai or Ao or Di or Do

\end{itemize}

\end{itemize}


\subsubsection{Important facts about the Digital interface:}
\label{sound/cards/audiophile-usb:important-facts-about-the-digital-interface}\begin{itemize}
\item {} 
The Do port additionally supports surround-encoded AC-3 and DTS passthrough,
though I haven't tested it under Linux
\begin{itemize}
\item {} 
Note that in this setup only the Do interface can be enabled

\end{itemize}

\item {} 
Apart from recording an audio digital stream, enabling the Di port is a way
to synchronize the device to an external sample clock
\begin{itemize}
\item {} 
As a consequence, the Di port must be enable only if an active Digital
source is connected

\item {} 
Enabling Di when no digital source is connected can result in a
synchronization error (for instance sound played at an odd sample rate)

\end{itemize}

\end{itemize}


\subsection{Audiophile USB MIDI support in ALSA}
\label{sound/cards/audiophile-usb:audiophile-usb-midi-support-in-alsa}
The Audiophile USB MIDI ports will be automatically supported once the
following modules have been loaded:
\begin{itemize}
\item {} 
snd-usb-audio

\item {} 
snd-seq-midi

\end{itemize}

No additional setting is required.


\subsection{Audiophile USB Audio support in ALSA}
\label{sound/cards/audiophile-usb:audiophile-usb-audio-support-in-alsa}
Audio functions of the Audiophile USB device are handled by the snd-usb-audio
module. This module can work in a default mode (without any device-specific
parameter), or in an ``advanced'' mode with the device-specific parameter called
\code{device\_setup}.


\subsubsection{Default Alsa driver mode}
\label{sound/cards/audiophile-usb:default-alsa-driver-mode}
The default behavior of the snd-usb-audio driver is to list the device
capabilities at startup and activate the required mode when required
by the applications: for instance if the user is recording in a
24bit-depth-mode and immediately after wants to switch to a 16bit-depth mode,
the snd-usb-audio module will reconfigure the device on the fly.

This approach has the advantage to let the driver automatically switch from sample
rates/depths automatically according to the user's needs. However, those who
are using the device under windows know that this is not how the device is meant to
work: under windows applications must be closed before using the m-audio control
panel to switch the device working mode. Thus as we'll see in next section, this
Default Alsa driver mode can lead to device misconfigurations.

Let's get back to the Default Alsa driver mode for now.  In this case the
Audiophile interfaces are mapped to alsa pcm devices in the following
way (I suppose the device's index is 1):
\begin{itemize}
\item {} 
hw:1,0 is Ao in playback and Di in capture

\item {} 
hw:1,1 is Do in playback and Ai in capture

\item {} 
hw:1,2 is Do in AC3/DTS passthrough mode

\end{itemize}

In this mode, the device uses Big Endian byte-encoding so that
supported audio format are S16\_BE for 16-bit depth modes and S24\_3BE for
24-bits depth mode.

One exception is the hw:1,2 port which was reported to be Little Endian
compliant (supposedly supporting S16\_LE) but processes in fact only S16\_BE streams.
This has been fixed in kernel 2.6.23 and above and now the hw:1,2 interface
is reported to be big endian in this default driver mode.

Examples:
\begin{itemize}
\item {} 
playing a S24\_3BE encoded raw file to the Ao port:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} aplay \PYGZhy{}D hw:1,0 \PYGZhy{}c2 \PYGZhy{}t raw \PYGZhy{}r48000 \PYGZhy{}fS24\PYGZus{}3BE test.raw
\end{Verbatim}

\item {} 
recording a  S24\_3BE encoded raw file from the Ai port:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} arecord \PYGZhy{}D hw:1,1 \PYGZhy{}c2  \PYGZhy{}t raw \PYGZhy{}r48000 \PYGZhy{}fS24\PYGZus{}3BE test.raw
\end{Verbatim}

\item {} 
playing a S16\_BE encoded raw file to the Do port:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} aplay \PYGZhy{}D hw:1,1 \PYGZhy{}c2 \PYGZhy{}t raw \PYGZhy{}r48000 \PYGZhy{}fS16\PYGZus{}BE test.raw
\end{Verbatim}

\item {} 
playing an ac3 sample file to the Do port:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} aplay \PYGZhy{}D hw:1,2 \PYGZhy{}\PYGZhy{}channels=6 ac3\PYGZus{}S16\PYGZus{}BE\PYGZus{}encoded\PYGZus{}file.raw
\end{Verbatim}

\end{itemize}

If you're happy with the default Alsa driver mode and don't experience any
issue with this mode, then you can skip the following chapter.


\subsubsection{Advanced module setup}
\label{sound/cards/audiophile-usb:advanced-module-setup}
Due to the hardware constraints described above, the device initialization made
by the Alsa driver in default mode may result in a corrupted state of the
device. For instance, a particularly annoying issue is that the sound captured
from the Ai interface sounds distorted (as if boosted with an excessive high
volume gain).

For people having this problem, the snd-usb-audio module has a new module
parameter called \code{device\_setup} (this parameter was introduced in kernel
release 2.6.17)


\paragraph{Initializing the working mode of the Audiophile USB}
\label{sound/cards/audiophile-usb:initializing-the-working-mode-of-the-audiophile-usb}
As far as the Audiophile USB device is concerned, this value let the user
specify:
\begin{itemize}
\item {} 
the sample depth

\item {} 
the sample rate

\item {} 
whether the Di port is used or not

\end{itemize}

When initialized with \code{device\_setup=0x00}, the snd-usb-audio module has
the same behaviour as when the parameter is omitted (see paragraph ``Default
Alsa driver mode'' above)

Others modes are described in the following subsections.


\paragraph{16-bit modes}
\label{sound/cards/audiophile-usb:bit-modes}
The two supported modes are:
\begin{itemize}
\item {} 
\code{device\_setup=0x01}
\begin{itemize}
\item {} 
16bits 48kHz mode with Di disabled

\item {} 
Ai,Ao,Do can be used at the same time

\item {} 
hw:1,0 is not available in capture mode

\item {} 
hw:1,2 is not available

\end{itemize}

\item {} 
\code{device\_setup=0x11}
\begin{itemize}
\item {} 
16bits 48kHz mode with Di enabled

\item {} 
Ai,Ao,Di,Do can be used at the same time

\item {} 
hw:1,0 is available in capture mode

\item {} 
hw:1,2 is not available

\end{itemize}

\end{itemize}

In this modes the device operates only at 16bits-modes. Before kernel 2.6.23,
the devices where reported to be Big-Endian when in fact they were Little-Endian
so that playing a file was a matter of using:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} aplay \PYGZhy{}D hw:1,1 \PYGZhy{}c2 \PYGZhy{}t raw \PYGZhy{}r48000 \PYGZhy{}fS16\PYGZus{}BE test\PYGZus{}S16\PYGZus{}LE.raw
\end{Verbatim}

where ``test\_S16\_LE.raw'' was in fact a little-endian sample file.

Thanks to Hakan Lennestal (who discovered the Little-Endiannes of the device in
these modes) a fix has been committed (expected in kernel 2.6.23) and
Alsa now reports Little-Endian interfaces. Thus playing a file now is as simple as
using:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} aplay \PYGZhy{}D hw:1,1 \PYGZhy{}c2 \PYGZhy{}t raw \PYGZhy{}r48000 \PYGZhy{}fS16\PYGZus{}LE test\PYGZus{}S16\PYGZus{}LE.raw
\end{Verbatim}


\paragraph{24-bit modes}
\label{sound/cards/audiophile-usb:id1}
The three supported modes are:
\begin{itemize}
\item {} 
\code{device\_setup=0x09}
\begin{itemize}
\item {} 
24bits 48kHz mode with Di disabled

\item {} 
Ai,Ao,Do can be used at the same time

\item {} 
hw:1,0 is not available in capture mode

\item {} 
hw:1,2 is not available

\end{itemize}

\item {} 
\code{device\_setup=0x19}
\begin{itemize}
\item {} 
24bits 48kHz mode with Di enabled

\item {} 
3 ports from \{Ai,Ao,Di,Do\} can be used at the same time

\item {} 
hw:1,0 is available in capture mode and an active digital source must be
connected to Di

\item {} 
hw:1,2 is not available

\end{itemize}

\item {} 
\code{device\_setup=0x0D} or \code{0x10}
\begin{itemize}
\item {} 
24bits 96kHz mode

\item {} 
Di is enabled by default for this mode but does not need to be connected
to an active source

\item {} 
Only 1 port from \{Ai,Ao,Di,Do\} can be used at the same time

\item {} 
hw:1,0 is available in captured mode

\item {} 
hw:1,2 is not available

\end{itemize}

\end{itemize}

In these modes the device is only Big-Endian compliant (see ``Default Alsa driver
mode'' above for an aplay command example)


\paragraph{AC3 w/ DTS passthru mode}
\label{sound/cards/audiophile-usb:ac3-w-dts-passthru-mode}
Thanks to Hakan Lennestal, I now have a report saying that this mode works.
\begin{itemize}
\item {} 
\code{device\_setup=0x03}
\begin{itemize}
\item {} 
16bits 48kHz mode with only the Do port enabled

\item {} 
AC3 with DTS passthru

\item {} 
Caution with this setup the Do port is mapped to the pcm device hw:1,0

\end{itemize}

\end{itemize}

The command line used to playback the AC3/DTS encoded .wav-files in this mode:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} aplay \PYGZhy{}D hw:1,0 \PYGZhy{}\PYGZhy{}channels=6 ac3\PYGZus{}S16\PYGZus{}LE\PYGZus{}encoded\PYGZus{}file.raw
\end{Verbatim}


\paragraph{How to use the \texttt{device\_setup} parameter}
\label{sound/cards/audiophile-usb:how-to-use-the-device-setup-parameter}
The parameter can be given:
\begin{itemize}
\item {} 
By manually probing the device (as root)::

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} modprobe \PYGZhy{}r snd\PYGZhy{}usb\PYGZhy{}audio
\PYGZsh{} modprobe snd\PYGZhy{}usb\PYGZhy{}audio index=1 device\PYGZus{}setup=0x09
\end{Verbatim}

\item {} 
Or while configuring the modules options in your modules configuration file
(typically a .conf file in /etc/modprobe.d/ directory::

\begin{Verbatim}[commandchars=\\\{\}]
alias snd\PYGZhy{}card\PYGZhy{}1 snd\PYGZhy{}usb\PYGZhy{}audio
options snd\PYGZhy{}usb\PYGZhy{}audio index=1 device\PYGZus{}setup=0x09
\end{Verbatim}

\end{itemize}


\subsubsection{CAUTION when initializing the device}
\label{sound/cards/audiophile-usb:caution-when-initializing-the-device}\begin{itemize}
\item {} 
Correct initialization on the device requires that device\_setup is given to
the module BEFORE the device is turned on. So, if you use the ``manual probing''
method described above, take care to power-on the device AFTER this initialization.

\item {} 
Failing to respect this will lead to a misconfiguration of the device. In this case
turn off the device, unprobe the snd-usb-audio module, then probe it again with
correct device\_setup parameter and then (and only then) turn on the device again.

\item {} 
If you've correctly initialized the device in a valid mode and then want to switch
to  another mode (possibly with another sample-depth), please use also the following
procedure:
\begin{itemize}
\item {} 
first turn off the device

\item {} 
de-register the snd-usb-audio module (modprobe -r)

\item {} 
change the device\_setup parameter by changing the device\_setup
option in \code{/etc/modprobe.d/*.conf}

\item {} 
turn on the device

\end{itemize}

\item {} 
A workaround for this last issue has been applied to kernel 2.6.23, but it may not
be enough to ensure the `stability' of the device initialization.

\end{itemize}


\subsubsection{Technical details for hackers}
\label{sound/cards/audiophile-usb:technical-details-for-hackers}
This section is for hackers, wanting to understand details about the device
internals and how Alsa supports it.


\paragraph{Audiophile USB's \texttt{device\_setup} structure}
\label{sound/cards/audiophile-usb:audiophile-usb-s-device-setup-structure}
If you want to understand the device\_setup magic numbers for the Audiophile
USB, you need some very basic understanding of binary computation. However,
this is not required to use the parameter and you may skip this section.

The device\_setup is one byte long and its structure is the following:

\begin{Verbatim}[commandchars=\\\{\}]
+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\textbar{} b7\textbar{} b6\textbar{} b5\textbar{} b4\textbar{} b3\textbar{} b2\textbar{} b1\textbar{} b0\textbar{}
+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\textbar{} 0 \textbar{} 0 \textbar{} 0 \textbar{} Di\textbar{}24B\textbar{}96K\textbar{}DTS\textbar{}SET\textbar{}
+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}+
\end{Verbatim}

Where:
\begin{itemize}
\item {} 
b0 is the \code{SET} bit
\begin{itemize}
\item {} 
it MUST be set if device\_setup is initialized

\end{itemize}

\item {} 
b1 is the \code{DTS} bit
\begin{itemize}
\item {} 
it is set only for Digital output with DTS/AC3

\item {} 
this setup is not tested

\end{itemize}

\item {} 
b2 is the Rate selection flag
\begin{itemize}
\item {} 
When set to \code{1} the rate range is 48.1-96kHz

\item {} 
Otherwise the sample rate range is 8-48kHz

\end{itemize}

\item {} 
b3 is the bit depth selection flag
\begin{itemize}
\item {} 
When set to \code{1} samples are 24bits long

\item {} 
Otherwise they are 16bits long

\item {} 
Note that b2 implies b3 as the 96kHz mode is only supported for 24 bits
samples

\end{itemize}

\item {} 
b4 is the Digital input flag
\begin{itemize}
\item {} 
When set to \code{1} the device assumes that an active digital source is
connected

\item {} 
You shouldn't enable Di if no source is seen on the port (this leads to
synchronization issues)

\item {} 
b4 is implied by b2 (since only one port is enabled at a time no synch
error can occur)

\end{itemize}

\item {} 
b5 to b7 are reserved for future uses, and must be set to \code{0}
\begin{itemize}
\item {} 
might become Ao, Do, Ai, for b7, b6, b4 respectively

\end{itemize}

\end{itemize}

Caution:
\begin{itemize}
\item {} 
there is no check on the value you will give to device\_setup
\begin{itemize}
\item {} 
for instance choosing 0x05 (16bits 96kHz) will fail back to 0x09 since
b2 implies b3. But \_there\_will\_be\_no\_warning\_ in /var/log/messages

\end{itemize}

\item {} 
Hardware constraints due to the USB bus limitation aren't checked
\begin{itemize}
\item {} 
choosing b2 will prepare all interfaces for 24bits/96kHz but you'll
only be able to use one at the same time

\end{itemize}

\end{itemize}


\paragraph{USB implementation details for this device}
\label{sound/cards/audiophile-usb:usb-implementation-details-for-this-device}
You may safely skip this section if you're not interested in driver
hacking.

This section describes some internal aspects of the device and summarizes the
data I got by usb-snooping the windows and Linux drivers.

The M-Audio Audiophile USB has 7 USB Interfaces:
a ``USB interface'':
\begin{itemize}
\item {} 
USB Interface nb.0

\item {} 
USB Interface nb.1
\begin{itemize}
\item {} 
Audio Control function

\end{itemize}

\item {} 
USB Interface nb.2
\begin{itemize}
\item {} 
Analog Output

\end{itemize}

\item {} 
USB Interface nb.3
\begin{itemize}
\item {} 
Digital Output

\end{itemize}

\item {} 
USB Interface nb.4
\begin{itemize}
\item {} 
Analog Input

\end{itemize}

\item {} 
USB Interface nb.5
\begin{itemize}
\item {} 
Digital Input

\end{itemize}

\item {} 
USB Interface nb.6
\begin{itemize}
\item {} 
MIDI interface compliant with the MIDIMAN quirk

\end{itemize}

\end{itemize}

Each interface has 5 altsettings (AltSet 1,2,3,4,5) except:
\begin{itemize}
\item {} 
Interface 3 (Digital Out) has an extra Alset nb.6

\item {} 
Interface 5 (Digital In) does not have Alset nb.3 and 5

\end{itemize}

Here is a short description of the AltSettings capabilities:
\begin{itemize}
\item {} 
AltSettings 1 corresponds to
\begin{itemize}
\item {} 
24-bit depth, 48.1-96kHz sample mode

\item {} 
Adaptive playback (Ao and Do), Synch capture (Ai), or Asynch capture (Di)

\end{itemize}

\item {} 
AltSettings 2 corresponds to
\begin{itemize}
\item {} 
24-bit depth, 8-48kHz sample mode

\item {} 
Asynch capture and playback  (Ao,Ai,Do,Di)

\end{itemize}

\item {} 
AltSettings 3 corresponds to
\begin{itemize}
\item {} 
24-bit depth, 8-48kHz sample mode

\item {} 
Synch capture (Ai) and Adaptive playback (Ao,Do)

\end{itemize}

\item {} 
AltSettings 4 corresponds to
\begin{itemize}
\item {} 
16-bit depth, 8-48kHz sample mode

\item {} 
Asynch capture and playback  (Ao,Ai,Do,Di)

\end{itemize}

\item {} 
AltSettings 5 corresponds to
\begin{itemize}
\item {} 
16-bit depth, 8-48kHz sample mode

\item {} 
Synch capture (Ai) and Adaptive playback (Ao,Do)

\end{itemize}

\item {} 
AltSettings 6 corresponds to
\begin{itemize}
\item {} 
16-bit depth, 8-48kHz sample mode

\item {} 
Synch playback (Do), audio format type III IEC1937\_AC-3

\end{itemize}

\end{itemize}

In order to ensure a correct initialization of the device, the driver
\emph{must} \emph{know} how the device will be used:
\begin{itemize}
\item {} 
if DTS is chosen, only Interface 2 with AltSet nb.6 must be
registered

\item {} 
if 96KHz only AltSets nb.1 of each interface must be selected

\item {} 
if samples are using 24bits/48KHz then AltSet 2 must me used if
Digital input is connected, and only AltSet nb.3 if Digital input
is not connected

\item {} 
if samples are using 16bits/48KHz then AltSet 4 must me used if
Digital input is connected, and only AltSet nb.5 if Digital input
is not connected

\end{itemize}

When device\_setup is given as a parameter to the snd-usb-audio module, the
parse\_audio\_endpoints function uses a quirk called
\code{audiophile\_skip\_setting\_quirk} in order to prevent AltSettings not
corresponding to device\_setup from being registered in the driver.


\subsection{Audiophile USB and Jack support}
\label{sound/cards/audiophile-usb:audiophile-usb-and-jack-support}
This section deals with support of the Audiophile USB device in Jack.

There are 2 main potential issues when using Jackd with the device:
\begin{itemize}
\item {} 
support for Big-Endian devices in 24-bit modes

\item {} 
support for 4-in / 4-out channels

\end{itemize}


\subsubsection{Direct support in Jackd}
\label{sound/cards/audiophile-usb:direct-support-in-jackd}
Jack supports big endian devices only in recent versions (thanks to
Andreas Steinmetz for his first big-endian patch). I can't remember
exactly when this support was released into jackd, let's just say that
with jackd version 0.103.0 it's almost ok (just a small bug is affecting
16bits Big-Endian devices, but since you've read carefully the above
paragraphs, you're now using kernel \textgreater{}= 2.6.23 and your 16bits devices
are now Little Endians ;-) ).

You can run jackd with the following command for playback with Ao and
record with Ai:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} jackd \PYGZhy{}R \PYGZhy{}dalsa \PYGZhy{}Phw:1,0 \PYGZhy{}r48000 \PYGZhy{}p128 \PYGZhy{}n2 \PYGZhy{}D \PYGZhy{}Chw:1,1
\end{Verbatim}


\subsubsection{Using Alsa plughw}
\label{sound/cards/audiophile-usb:using-alsa-plughw}
If you don't have a recent Jackd installed, you can downgrade to using
the Alsa \code{plug} converter.

For instance here is one way to run Jack with 2 playback channels on Ao and 2
capture channels from Ai:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} jackd \PYGZhy{}R \PYGZhy{}dalsa \PYGZhy{}dplughw:1 \PYGZhy{}r48000 \PYGZhy{}p256 \PYGZhy{}n2 \PYGZhy{}D \PYGZhy{}Cplughw:1,1
\end{Verbatim}
\begin{description}
\item[{However you may see the following warning message:}] \leavevmode
You appear to be using the ALSA software ``plug'' layer, probably a result of
using the ``default'' ALSA device. This is less efficient than it could be.
Consider using a hardware device instead rather than using the plug layer.

\end{description}


\subsubsection{Getting 2 input and/or output interfaces in Jack}
\label{sound/cards/audiophile-usb:getting-2-input-and-or-output-interfaces-in-jack}
As you can see, starting the Jack server this way will only enable 1 stereo
input (Di or Ai) and 1 stereo output (Ao or Do).

This is due to the following restrictions:
\begin{itemize}
\item {} 
Jack can only open one capture device and one playback device at a time

\item {} 
The Audiophile USB is seen as 2 (or three) Alsa devices: hw:1,0, hw:1,1
(and optionally hw:1,2)

\end{itemize}

If you want to get Ai+Di and/or Ao+Do support with Jack, you would need to
combine the Alsa devices into one logical ``complex'' device.

If you want to give it a try, I recommend reading the information from
this page: \href{http://www.sound-man.co.uk/linuxaudio/ice1712multi.html}{http://www.sound-man.co.uk/linuxaudio/ice1712multi.html}
It is related to another device (ice1712) but can be adapted to suit
the Audiophile USB.

Enabling multiple Audiophile USB interfaces for Jackd will certainly require:
\begin{itemize}
\item {} 
Making sure your Jackd version has the MMAP\_COMPLEX patch (see the ice1712 page)

\item {} 
(maybe) patching the alsa-lib/src/pcm/pcm\_multi.c file (see the ice1712 page)

\item {} 
define a multi device (combination of hw:1,0 and hw:1,1) in your .asoundrc
file

\item {} 
start jackd with this device

\end{itemize}

I had no success in testing this for now, if you have any success with this kind
of setup, please drop me an email.


\section{Alsa driver for Digigram miXart8 and miXart8AES/EBU soundcards}
\label{sound/cards/mixart:alsa-driver-for-digigram-mixart8-and-mixart8aes-ebu-soundcards}\label{sound/cards/mixart::doc}
Digigram \textless{}\href{mailto:alsa@digigram.com}{alsa@digigram.com}\textgreater{}


\subsection{GENERAL}
\label{sound/cards/mixart:general}
The miXart8 is a multichannel audio processing and mixing soundcard
that has 4 stereo audio inputs and 4 stereo audio outputs.
The miXart8AES/EBU is the same with a add-on card that offers further
4 digital stereo audio inputs and outputs.
Furthermore the add-on card offers external clock synchronisation
(AES/EBU, Word Clock, Time Code and Video Synchro)

The mainboard has a PowerPC that offers onboard mpeg encoding and
decoding, samplerate conversions and various effects.

The driver don't work properly at all until the certain firmwares
are loaded, i.e. no PCM nor mixer devices will appear.
Use the mixartloader that can be found in the alsa-tools package.


\subsection{VERSION 0.1.0}
\label{sound/cards/mixart:version-0-1-0}
One miXart8 board will be represented as 4 alsa cards, each with 1
stereo analog capture `pcm0c' and 1 stereo analog playback `pcm0p' device.
With a miXart8AES/EBU there is in addition 1 stereo digital input
`pcm1c' and 1 stereo digital output `pcm1p' per card.


\subsubsection{Formats}
\label{sound/cards/mixart:formats}
U8, S16\_LE, S16\_BE, S24\_3LE, S24\_3BE, FLOAT\_LE, FLOAT\_BE
Sample rates : 8000 - 48000 Hz continuously


\subsubsection{Playback}
\label{sound/cards/mixart:playback}
For instance the playback devices are configured to have max. 4
substreams performing hardware mixing. This could be changed to a
maximum of 24 substreams if wished.
Mono files will be played on the left and right channel. Each channel
can be muted for each stream to use 8 analog/digital outputs separately.


\subsubsection{Capture}
\label{sound/cards/mixart:capture}
There is one substream per capture device. For instance only stereo
formats are supported.


\subsubsection{Mixer}
\label{sound/cards/mixart:mixer}\begin{description}
\item[{\textless{}Master\textgreater{} and \textless{}Master Capture\textgreater{}}] \leavevmode
analog volume control of playback and capture PCM.

\item[{\textless{}PCM 0-3\textgreater{} and \textless{}PCM Capture\textgreater{}}] \leavevmode
digital volume control of each analog substream.

\item[{\textless{}AES 0-3\textgreater{} and \textless{}AES Capture\textgreater{}}] \leavevmode
digital volume control of each AES/EBU substream.

\item[{\textless{}Monitoring\textgreater{}}] \leavevmode
Loopback from `pcm0c' to `pcm0p' with digital volume
and mute control.

\end{description}

Rem : for best audio quality try to keep a 0 attenuation on the PCM
and AES volume controls which is set by 219 in the range from 0 to 255
(about 86\% with alsamixer)


\subsection{NOT YET IMPLEMENTED}
\label{sound/cards/mixart:not-yet-implemented}\begin{itemize}
\item {} 
external clock support (AES/EBU, Word Clock, Time Code, Video Sync)

\item {} 
MPEG audio formats

\item {} 
mono record

\item {} 
on-board effects and samplerate conversions

\item {} 
linked streams

\end{itemize}


\subsection{FIRMWARE}
\label{sound/cards/mixart:firmware}\begin{description}
\item[{{[}As of 2.6.11, the firmware can be loaded automatically with hotplug}] \leavevmode
when CONFIG\_FW\_LOADER is set.  The mixartloader is necessary only
for older versions or when you build the driver into kernel.{]}

\end{description}

For loading the firmware automatically after the module is loaded, use a
install command.  For example, add the following entry to
/etc/modprobe.d/mixart.conf for miXart driver:

\begin{Verbatim}[commandchars=\\\{\}]
install snd\PYGZhy{}mixart /sbin/modprobe \PYGZhy{}\PYGZhy{}first\PYGZhy{}time \PYGZhy{}i snd\PYGZhy{}mixart \PYGZam{}\PYGZam{} \PYGZbs{}
                   /usr/bin/mixartloader
\end{Verbatim}

(for 2.2/2.4 kernels, add ``post-install snd-mixart /usr/bin/vxloader'' to
/etc/modules.conf, instead.)

The firmware binaries are installed on /usr/share/alsa/firmware
(or /usr/local/share/alsa/firmware, depending to the prefix option of
configure).  There will be a miXart.conf file, which define the dsp image
files.

The firmware files are copyright by Digigram SA


\subsection{COPYRIGHT}
\label{sound/cards/mixart:copyright}
Copyright (c) 2003 Digigram SA \textless{}\href{mailto:alsa@digigram.com}{alsa@digigram.com}\textgreater{}
Distributable under GPL.


\section{ALSA BT87x Driver}
\label{sound/cards/bt87x::doc}\label{sound/cards/bt87x:alsa-bt87x-driver}

\subsection{Intro}
\label{sound/cards/bt87x:intro}
You might have noticed that the bt878 grabber cards have actually
\emph{two} PCI functions:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} lspci
[ ... ]
00:0a.0 Multimedia video controller: Brooktree Corporation Bt878 (rev 02)
00:0a.1 Multimedia controller: Brooktree Corporation Bt878 (rev 02)
[ ... ]
\end{Verbatim}

The first does video, it is backward compatible to the bt848.  The second
does audio.  snd-bt87x is a driver for the second function.  It's a sound
driver which can be used for recording sound (and \emph{only} recording, no
playback).  As most TV cards come with a short cable which can be plugged
into your sound card's line-in you probably don't need this driver if all
you want to do is just watching TV...

Some cards do not bother to connect anything to the audio input pins of
the chip, and some other cards use the audio function to transport MPEG
video data, so it's quite possible that audio recording may not work
with your card.


\subsection{Driver Status}
\label{sound/cards/bt87x:driver-status}
The driver is now stable.  However, it doesn't know about many TV cards,
and it refuses to load for cards it doesn't know.

If the driver complains (``Unknown TV card found, the audio driver will
not load''), you can specify the \code{load\_all=1} option to force the driver to
try to use the audio capture function of your card.  If the frequency of
recorded data is not right, try to specify the \code{digital\_rate} option with
other values than the default 32000 (often it's 44100 or 64000).

If you have an unknown card, please mail the ID and board name to
\textless{}\href{mailto:alsa-devel@alsa-project.org}{alsa-devel@alsa-project.org}\textgreater{}, regardless of whether audio capture works
or not, so that future versions of this driver know about your card.


\subsection{Audio modes}
\label{sound/cards/bt87x:audio-modes}
The chip knows two different modes (digital/analog).  snd-bt87x
registers two PCM devices, one for each mode.  They cannot be used at
the same time.


\subsection{Digital audio mode}
\label{sound/cards/bt87x:digital-audio-mode}
The first device (hw:X,0) gives you 16 bit stereo sound.  The sample
rate depends on the external source which feeds the Bt87x with digital
sound via I2S interface.


\subsection{Analog audio mode (A/D)}
\label{sound/cards/bt87x:analog-audio-mode-a-d}
The second device (hw:X,1) gives you 8 or 16 bit mono sound.  Supported
sample rates are between 119466 and 448000 Hz (yes, these numbers are
that high).  If you've set the CONFIG\_SND\_BT87X\_OVERCLOCK option, the
maximum sample rate is 1792000 Hz, but audio data becomes unusable
beyond 896000 Hz on my card.

The chip has three analog inputs.  Consequently you'll get a mixer
device to control these.

Have fun,
\begin{quote}

Clemens
\end{quote}

Written by Clemens Ladisch \textless{}\href{mailto:clemens@ladisch.de}{clemens@ladisch.de}\textgreater{}
big parts copied from btaudio.txt by Gerd Knorr \textless{}\href{mailto:kraxel@bytesex.org}{kraxel@bytesex.org}\textgreater{}


\section{Notes on Maya44 USB Audio Support}
\label{sound/cards/maya44:notes-on-maya44-usb-audio-support}\label{sound/cards/maya44::doc}
\begin{notice}{note}{Note:}
The following is the original document of Rainer's patch that the
current maya44 code based on.  Some contents might be obsoleted, but I
keep here as reference -- tiwai
\end{notice}

Feb 14, 2008

Rainer Zimmermann \textless{}\href{mailto:mail@lightshed.de}{mail@lightshed.de}\textgreater{}


\subsection{STATE OF DEVELOPMENT}
\label{sound/cards/maya44:state-of-development}
This driver is being developed on the initiative of Piotr Makowski (\href{mailto:oponek@gmail.com}{oponek@gmail.com}) and financed by Lars Bergmann.
Development is carried out by Rainer Zimmermann (\href{mailto:mail@lightshed.de}{mail@lightshed.de}).

ESI provided a sample Maya44 card for the development work.

However, unfortunately it has turned out difficult to get detailed programming information, so I (Rainer Zimmermann) had to find out some card-specific information by experiment and conjecture. Some information (in particular, several GPIO bits) is still missing.

This is the first testing version of the Maya44 driver released to the alsa-devel mailing list (Feb 5, 2008).

The following functions work, as tested by Rainer Zimmermann and Piotr Makowski:
\begin{itemize}
\item {} 
playback and capture at all sampling rates

\item {} 
input/output level

\item {} 
crossmixing

\item {} 
line/mic switch

\item {} 
phantom power switch

\item {} 
analogue monitor a.k.a bypass

\end{itemize}

The following functions \emph{should} work, but are not fully tested:
\begin{itemize}
\item {} 
Channel 3+4 analogue - S/PDIF input switching

\item {} 
S/PDIF output

\item {} 
all inputs/outputs on the M/IO/DIO extension card

\item {} 
internal/external clock selection

\end{itemize}

\emph{In particular, we would appreciate testing of these functions by anyone who has access to an M/IO/DIO extension card.}

Things that do not seem to work:
\begin{itemize}
\item {} 
The level meters (``multi track'') in `alsamixer' do not seem to react to signals in (if this is a bug, it would probably be in the existing ICE1724 code).

\item {} 
Ardour 2.1 seems to work only via JACK, not using ALSA directly or via OSS. This still needs to be tracked down.

\end{itemize}


\subsection{DRIVER DETAILS}
\label{sound/cards/maya44:driver-details}
the following files were added:
\begin{itemize}
\item {} 
pci/ice1724/maya44.c - Maya44 specific code

\item {} 
pci/ice1724/maya44.h

\item {} 
pci/ice1724/ice1724.patch

\item {} 
pci/ice1724/ice1724.h.patch - PROPOSED patch to ice1724.h (see SAMPLING RATES)

\item {} 
i2c/other/wm8776.c - low-level access routines for Wolfson WM8776 codecs

\item {} 
include/wm8776.h

\end{itemize}

Note that the wm8776.c code is meant to be card-independent and does not actually register the codec with the ALSA infrastructure.
This is done in maya44.c, mainly because some of the WM8776 controls are used in Maya44-specific ways, and should be named appropriately.

the following files were created in pci/ice1724, simply \#including the corresponding file from the alsa-kernel tree:
\begin{itemize}
\item {} 
wtm.h

\item {} 
vt1720\_mobo.h

\item {} 
revo.h

\item {} 
prodigy192.h

\item {} 
pontis.h

\item {} 
phase.h

\item {} 
maya44.h

\item {} 
juli.h

\item {} 
aureon.h

\item {} 
amp.h

\item {} 
envy24ht.h

\item {} 
se.h

\item {} 
prodigy\_hifi.h

\end{itemize}

\emph{I hope this is the correct way to do things.}


\subsection{SAMPLING RATES}
\label{sound/cards/maya44:sampling-rates}
The Maya44 card (or more exactly, the Wolfson WM8776 codecs) allow a maximum sampling rate of 192 kHz for playback and 92 kHz for capture.

As the ICE1724 chip only allows one global sampling rate, this is handled as follows:
\begin{itemize}
\item {} 
setting the sampling rate on any open PCM device on the maya44 card will always set the \emph{global} sampling rate for all playback and capture channels.

\item {} 
In the current state of the driver, setting rates of up to 192 kHz is permitted even for capture devices.

\end{itemize}

\emph{AVOID CAPTURING AT RATES ABOVE 96kHz}, even though it may appear to work. The codec cannot actually capture at such rates, meaning poor quality.

I propose some additional code for limiting the sampling rate when setting on a capture pcm device. However because of the global sampling rate, this logic would be somewhat problematic.

The proposed code (currently deactivated) is in ice1712.h.patch, ice1724.c and maya44.c (in pci/ice1712).


\subsection{SOUND DEVICES}
\label{sound/cards/maya44:sound-devices}
PCM devices correspond to inputs/outputs as follows (assuming Maya44 is card \#0):
\begin{itemize}
\item {} 
hw:0,0 input - stereo, analog input 1+2

\item {} 
hw:0,0 output - stereo, analog output 1+2

\item {} 
hw:0,1 input - stereo, analog input 3+4 OR S/PDIF input

\item {} 
hw:0,1 output - stereo, analog output 3+4 (and SPDIF out)

\end{itemize}


\subsection{NAMING OF MIXER CONTROLS}
\label{sound/cards/maya44:naming-of-mixer-controls}
(for more information about the signal flow, please refer to the block diagram on p.24 of the ESI Maya44 manual, or in the ESI windows software).
\begin{description}
\item[{PCM}] \leavevmode
(digital) output level for channel 1+2

\item[{PCM 1}] \leavevmode
same for channel 3+4

\item[{Mic Phantom+48V}] \leavevmode
switch for +48V phantom power for electrostatic microphones on input 1/2.

Make sure this is not turned on while any other source is connected to input 1/2.
It might damage the source and/or the maya44 card.

\item[{Mic/Line input}] \leavevmode
if switch is on, input jack 1/2 is microphone input (mono), otherwise line input (stereo).

\item[{Bypass}] \leavevmode
analogue bypass from ADC input to output for channel 1+2. Same as ``Monitor'' in the windows driver.

\item[{Bypass 1}] \leavevmode
same for channel 3+4.

\item[{Crossmix}] \leavevmode
cross-mixer from channels 1+2 to channels 3+4

\item[{Crossmix 1}] \leavevmode
cross-mixer from channels 3+4 to channels 1+2

\item[{IEC958 Output}] \leavevmode
switch for S/PDIF output.

This is not supported by the ESI windows driver.
S/PDIF should output the same signal as channel 3+4. {[}untested!{]}

\item[{Digitial output selectors}] \leavevmode
These switches allow a direct digital routing from the ADCs to the DACs.
Each switch determines where the digital input data to one of the DACs comes from.
They are not supported by the ESI windows driver.
For normal operation, they should all be set to ``PCM out''.

\item[{H/W}] \leavevmode
Output source channel 1

\item[{H/W 1}] \leavevmode
Output source channel 2

\item[{H/W 2}] \leavevmode
Output source channel 3

\item[{H/W 3}] \leavevmode
Output source channel 4

\item[{H/W 4 ... H/W 9}] \leavevmode
unknown function, left in to enable testing.

Possibly some of these control S/PDIF output(s).
If these turn out to be unused, they will go away in later driver versions.

\end{description}

Selectable values for each of the digital output selectors are:
\begin{description}
\item[{PCM out}] \leavevmode
DAC output of the corresponding channel (default setting)

\item[{Input 1 ... Input 4}] \leavevmode
direct routing from ADC output of the selected input channel

\end{description}


\section{Software Interface ALSA-DSP MADI Driver}
\label{sound/cards/hdspm:software-interface-alsa-dsp-madi-driver}\label{sound/cards/hdspm::doc}
(translated from German, so no good English ;-),

2004 - winfried ritsch

Full functionality has been added to the driver. Since some of
the Controls and startup-options  are ALSA-Standard and only the
special Controls are described and discussed below.


\subsection{Hardware functionality}
\label{sound/cards/hdspm:hardware-functionality}

\subsubsection{Audio transmission}
\label{sound/cards/hdspm:audio-transmission}\begin{itemize}
\item {} 
number of channels --  depends on transmission mode
\begin{quote}

The number of channels chosen is from 1..Nmax. The reason to
use for a lower number of channels is only resource allocation,
since unused DMA channels are disabled and less memory is
allocated. So also the throughput of the PCI system can be
scaled. (Only important for low performance boards).
\end{quote}

\item {} 
Single Speed -- 1..64 channels

\end{itemize}

\begin{notice}{note}{Note:}
(Note: Choosing the 56channel mode for transmission or as
receiver, only 56 are transmitted/received over the MADI, but
all 64 channels are available for the mixer, so channel count
for the driver)
\end{notice}
\begin{itemize}
\item {} 
Double Speed -- 1..32 channels

\end{itemize}

\begin{notice}{note}{Note:}
Note: Choosing the 56-channel mode for
transmission/receive-mode , only 28 are transmitted/received
over the MADI, but all 32 channels are available for the mixer,
so channel count for the driver
\end{notice}
\begin{itemize}
\item {} 
Quad Speed -- 1..16 channels

\end{itemize}

\begin{notice}{note}{Note:}
Choosing the 56-channel mode for
transmission/receive-mode , only 14 are transmitted/received
over the MADI, but all 16 channels are available for the mixer,
so channel count for the driver
\end{notice}
\begin{itemize}
\item {} 
Format -- signed 32 Bit Little Endian (SNDRV\_PCM\_FMTBIT\_S32\_LE)

\item {} 
Sample Rates --
\begin{quote}

Single Speed -- 32000, 44100, 48000

Double Speed -- 64000, 88200, 96000 (untested)

Quad Speed -- 128000, 176400, 192000 (untested)
\end{quote}

\item {} 
access-mode -- MMAP (memory mapped), Not interleaved (PCM\_NON-INTERLEAVED)

\item {} 
buffer-sizes -- 64,128,256,512,1024,2048,8192 Samples

\item {} 
fragments -- 2

\item {} 
Hardware-pointer -- 2 Modi
\begin{quote}

The Card supports the readout of the actual Buffer-pointer,
where DMA reads/writes. Since of the bulk mode of PCI it is only
64 Byte accurate. SO it is not really usable for the
ALSA-mid-level functions (here the buffer-ID gives a better
result), but if MMAP is used by the application. Therefore it
can be configured at load-time with the parameter
precise-pointer.
\end{quote}

\end{itemize}

\begin{notice}{hint}{Hint:}\begin{quote}

(Hint: Experimenting I found that the pointer is maximum 64 to
large never to small. So if you subtract 64 you always have a
safe pointer for writing, which is used on this mode inside
ALSA. In theory now you can get now a latency as low as 16
Samples, which is a quarter of the interrupt possibilities.)
\end{quote}
\begin{itemize}
\item {} \begin{description}
\item[{Precise Pointer -- off}] \leavevmode
interrupt used for pointer-calculation

\end{description}

\item {} \begin{description}
\item[{Precise Pointer -- on}] \leavevmode
hardware pointer used.

\end{description}

\end{itemize}
\end{notice}


\subsubsection{Controller}
\label{sound/cards/hdspm:controller}
Since DSP-MADI-Mixer has 8152 Fader, it does not make sense to
use the standard mixer-controls, since this would break most of
(especially graphic) ALSA-Mixer GUIs. So Mixer control has be
provided by a 2-dimensional controller using the
hwdep-interface.

Also all 128+256 Peak and RMS-Meter can be accessed via the
hwdep-interface. Since it could be a performance problem always
copying and converting Peak and RMS-Levels even if you just need
one, I decided to export the hardware structure, so that of
needed some driver-guru can implement a memory-mapping of mixer
or peak-meters over ioctl, or also to do only copying and no
conversion. A test-application shows the usage of the controller.
\begin{itemize}
\item {} 
Latency Controls --- not implemented !!!

\end{itemize}

\begin{notice}{note}{Note:}
Note: Within the windows-driver the latency is accessible of a
control-panel, but buffer-sizes are controlled with ALSA from
hwparams-calls and should not be changed in run-state, I did not
implement it here.
\end{notice}
\begin{itemize}
\item {} 
System Clock -- suspended !!!!
\begin{itemize}
\item {} 
Name -- ``System Clock Mode''

\item {} 
Access -- Read Write

\item {} 
Values -- ``Master'' ``Slave''

\end{itemize}

\end{itemize}

\begin{notice}{note}{Note:}
!!!! This is a hardware-function but is in conflict with the
Clock-source controller, which is a kind of ALSA-standard. I
makes sense to set the card to a special mode (master at some
frequency or slave), since even not using an Audio-application
a studio should have working synchronisations setup. So use
Clock-source-controller instead !!!!
\end{notice}
\begin{itemize}
\item {} 
Clock Source
\begin{itemize}
\item {} 
Name -- ``Sample Clock Source''

\item {} 
Access -- Read Write

\item {} 
Values -- ``AutoSync'', ``Internal 32.0 kHz'', ``Internal 44.1 kHz'',
``Internal 48.0 kHz'', ``Internal 64.0 kHz'', ``Internal 88.2 kHz'',
``Internal 96.0 kHz''
\begin{quote}

Choose between Master at a specific Frequency and so also the
Speed-mode or Slave (Autosync). Also see  ``Preferred Sync Ref''
\end{quote}

\end{itemize}

\end{itemize}

\begin{notice}{warning}{Warning:}
!!!! This is no pure hardware function but was implemented by
ALSA by some ALSA-drivers before, so I use it also. !!!
\end{notice}
\begin{itemize}
\item {} 
Preferred Sync Ref
\begin{itemize}
\item {} 
Name -- ``Preferred Sync Reference''

\item {} 
Access -- Read Write

\item {} 
Values -- ``Word'' ``MADI''
\begin{quote}

Within the Auto-sync-Mode the preferred Sync Source can be
chosen. If it is not available another is used if possible.
\end{quote}

\end{itemize}

\end{itemize}

\begin{notice}{note}{Note:}
Note: Since MADI has a much higher bit-rate than word-clock, the
card should synchronise better in MADI Mode. But since the
RME-PLL is very good, there are almost no problems with
word-clock too. I never found a difference.
\end{notice}
\begin{itemize}
\item {} 
TX 64 channel
\begin{itemize}
\item {} 
Name -- ``TX 64 channels mode''

\item {} 
Access -- Read Write

\item {} 
Values -- 0 1
\begin{quote}

Using 64-channel-modus (1) or 56-channel-modus for
MADI-transmission (0).
\end{quote}

\end{itemize}

\end{itemize}

\begin{notice}{note}{Note:}
Note: This control is for output only. Input-mode is detected
automatically from hardware sending MADI.
\end{notice}
\begin{itemize}
\item {} 
Clear TMS
\begin{itemize}
\item {} 
Name -- ``Clear Track Marker''

\item {} 
Access -- Read Write

\item {} 
Values -- 0 1
\begin{quote}

Don't use to lower 5 Audio-bits on AES as additional Bits.
\end{quote}

\end{itemize}

\item {} 
Safe Mode oder Auto Input
\begin{itemize}
\item {} 
Name -- ``Safe Mode''

\item {} 
Access -- Read Write

\item {} 
Values -- 0 1 (default on)
\begin{quote}

If on (1), then if either the optical or coaxial connection
has a failure, there is a takeover to the working one, with no
sample failure. Its only useful if you use the second as a
backup connection.
\end{quote}

\end{itemize}

\item {} 
Input
\begin{itemize}
\item {} 
Name -- ``Input Select''

\item {} 
Access -- Read Write

\item {} 
Values -- optical coaxial
\begin{quote}

Choosing the Input, optical or coaxial. If Safe-mode is active,
this is the preferred Input.
\end{quote}

\end{itemize}

\end{itemize}


\subsubsection{Mixer}
\label{sound/cards/hdspm:mixer}\begin{itemize}
\item {} 
Mixer
\begin{itemize}
\item {} 
Name -- ``Mixer''

\item {} 
Access -- Read Write

\item {} 
Values - \textless{}channel-number 0-127\textgreater{} \textless{}Value 0-65535\textgreater{}
\begin{quote}

Here as a first value the channel-index is taken to get/set the
corresponding mixer channel, where 0-63 are the input to output
fader and 64-127 the playback to outputs fader. Value 0
is channel muted 0 and 32768 an amplification of  1.
\end{quote}

\end{itemize}

\item {} 
Chn 1-64
\begin{quote}

fast mixer for the ALSA-mixer utils. The diagonal of the
mixer-matrix is implemented from playback to output.
\end{quote}

\item {} 
Line Out
\begin{itemize}
\item {} 
Name  -- ``Line Out''

\item {} 
Access -- Read Write

\item {} 
Values -- 0 1
\begin{quote}

Switching on and off the analog out, which has nothing to do
with mixing or routing. the analog outs reflects channel 63,64.
\end{quote}

\end{itemize}

\end{itemize}


\subsubsection{Information (only read access)}
\label{sound/cards/hdspm:information-only-read-access}\begin{itemize}
\item {} 
Sample Rate
\begin{itemize}
\item {} 
Name -- ``System Sample Rate''

\item {} 
Access -- Read-only
\begin{quote}

getting the sample rate.
\end{quote}

\end{itemize}

\item {} 
External Rate measured
\begin{itemize}
\item {} 
Name -- ``External Rate''

\item {} 
Access -- Read only
\begin{quote}

Should be ``Autosync Rate'', but Name used is
ALSA-Scheme. External Sample frequency liked used on Autosync is
reported.
\end{quote}

\end{itemize}

\item {} 
MADI Sync Status
\begin{itemize}
\item {} 
Name -- ``MADI Sync Lock Status''

\item {} 
Access -- Read

\item {} 
Values -- 0,1,2
\begin{quote}

MADI-Input is 0=Unlocked, 1=Locked, or 2=Synced.
\end{quote}

\end{itemize}

\item {} 
Word Clock Sync Status
\begin{itemize}
\item {} 
Name -- ``Word Clock Lock Status''

\item {} 
Access -- Read

\item {} 
Values -- 0,1,2
\begin{quote}

Word Clock Input is 0=Unlocked, 1=Locked, or 2=Synced.
\end{quote}

\end{itemize}

\item {} 
AutoSync
\begin{itemize}
\item {} 
Name -- ``AutoSync Reference''

\item {} 
Access -- Read

\item {} 
Values -- ``WordClock'', ``MADI'', ``None''
\begin{quote}

Sync-Reference is either ``WordClock'', ``MADI'' or none.
\end{quote}

\end{itemize}

\item {} 
RX 64ch --- noch nicht implementiert
\begin{quote}

MADI-Receiver is in 64 channel mode oder 56 channel mode.
\end{quote}

\item {} 
AB\_inp   --- not tested
\begin{quote}

Used input for Auto-Input.
\end{quote}

\item {} 
actual Buffer Position --- not implemented
\begin{quote}

!!! this is a ALSA internal function, so no control is used !!!
\end{quote}

\end{itemize}


\subsection{Calling Parameter}
\label{sound/cards/hdspm:calling-parameter}\begin{itemize}
\item {} 
index int array (min = 1, max = 8)
\begin{quote}

Index value for RME HDSPM interface. card-index within ALSA

note: ALSA-standard
\end{quote}

\item {} 
id string array (min = 1, max = 8)
\begin{quote}

ID string for RME HDSPM interface.

note: ALSA-standard
\end{quote}

\item {} 
enable int array (min = 1, max = 8)
\begin{quote}

Enable/disable specific HDSPM sound-cards.

note: ALSA-standard
\end{quote}

\item {} 
precise\_ptr int array (min = 1, max = 8)
\begin{quote}

Enable precise pointer, or disable.
\end{quote}

\end{itemize}

\begin{notice}{note}{Note:}
note: Use only when the application supports this (which is a special case).
\end{notice}
\begin{itemize}
\item {} 
line\_outs\_monitor int array (min = 1, max = 8)
\begin{quote}

Send playback streams to analog outs by default.
\end{quote}

\end{itemize}

\begin{notice}{note}{Note:}
note: each playback channel is mixed to the same numbered output
channel (routed). This is against the ALSA-convention, where all
channels have to be muted on after loading the driver, but was
used before on other cards, so i historically use it again)
\end{notice}
\begin{itemize}
\item {} 
enable\_monitor int array (min = 1, max = 8)
\begin{quote}

Enable Analog Out on Channel 63/64 by default.
\end{quote}

\end{itemize}

\begin{notice}{note}{Note:}
note: here the analog output is enabled (but not routed).
\end{notice}


\section{Serial UART 16450/16550 MIDI driver}
\label{sound/cards/serial-u16550::doc}\label{sound/cards/serial-u16550:serial-uart-16450-16550-midi-driver}
The adaptor module parameter allows you to select either:
\begin{itemize}
\item {} 
0 - Roland Soundcanvas support (default)

\item {} 
1 - Midiator MS-124T support (1)

\item {} 
2 - Midiator MS-124W S/A mode (2)

\item {} 
3 - MS-124W M/B mode support (3)

\item {} 
4 - Generic device with multiple input support (4)

\end{itemize}

For the Midiator MS-124W, you must set the physical M-S and A-B
switches on the Midiator to match the driver mode you select.

In Roland Soundcanvas mode, multiple ALSA raw MIDI substreams are supported
(midiCnD0-midiCnD15).  Whenever you write to a different substream, the driver
sends the nonstandard MIDI command sequence F5 NN, where NN is the substream
number plus 1.  Roland modules use this command to switch between different
``parts'', so this feature lets you treat each part as a distinct raw MIDI
substream. The driver provides no way to send F5 00 (no selection) or to not
send the F5 NN command sequence at all; perhaps it ought to.

Usage example for simple serial converter:

\begin{Verbatim}[commandchars=\\\{\}]
/sbin/setserial /dev/ttyS0 uart none
/sbin/modprobe snd\PYGZhy{}serial\PYGZhy{}u16550 port=0x3f8 irq=4 speed=115200
\end{Verbatim}

Usage example for Roland SoundCanvas with 4 MIDI ports:

\begin{Verbatim}[commandchars=\\\{\}]
/sbin/setserial /dev/ttyS0 uart none
/sbin/modprobe snd\PYGZhy{}serial\PYGZhy{}u16550 port=0x3f8 irq=4 outs=4
\end{Verbatim}

In MS-124T mode, one raw MIDI substream is supported (midiCnD0); the outs
module parameter is automatically set to 1. The driver sends the same data to
all four MIDI Out connectors.  Set the A-B switch and the speed module
parameter to match (A=19200, B=9600).

Usage example for MS-124T, with A-B switch in A position:

\begin{Verbatim}[commandchars=\\\{\}]
/sbin/setserial /dev/ttyS0 uart none
/sbin/modprobe snd\PYGZhy{}serial\PYGZhy{}u16550 port=0x3f8 irq=4 adaptor=1 \PYGZbs{}
                speed=19200
\end{Verbatim}

In MS-124W S/A mode, one raw MIDI substream is supported (midiCnD0);
the outs module parameter is automatically set to 1. The driver sends
the same data to all four MIDI Out connectors at full MIDI speed.

Usage example for S/A mode:

\begin{Verbatim}[commandchars=\\\{\}]
/sbin/setserial /dev/ttyS0 uart none
/sbin/modprobe snd\PYGZhy{}serial\PYGZhy{}u16550 port=0x3f8 irq=4 adaptor=2
\end{Verbatim}

In MS-124W M/B mode, the driver supports 16 ALSA raw MIDI substreams;
the outs module parameter is automatically set to 16.  The substream
number gives a bitmask of which MIDI Out connectors the data should be
sent to, with midiCnD1 sending to Out 1, midiCnD2 to Out 2, midiCnD4 to
Out 3, and midiCnD8 to Out 4.  Thus midiCnD15 sends the data to all 4 ports.
As a special case, midiCnD0 also sends to all ports, since it is not useful
to send the data to no ports.  M/B mode has extra overhead to select the MIDI
Out for each byte, so the aggregate data rate across all four MIDI Outs is
at most one byte every 520 us, as compared with the full MIDI data rate of
one byte every 320 us per port.

Usage example for M/B mode:

\begin{Verbatim}[commandchars=\\\{\}]
/sbin/setserial /dev/ttyS0 uart none
/sbin/modprobe snd\PYGZhy{}serial\PYGZhy{}u16550 port=0x3f8 irq=4 adaptor=3
\end{Verbatim}

The MS-124W hardware's M/A mode is currently not supported. This mode allows
the MIDI Outs to act independently at double the aggregate throughput of M/B,
but does not allow sending the same byte simultaneously to multiple MIDI Outs.
The M/A protocol requires the driver to twiddle the modem control lines under
timing constraints, so it would be a bit more complicated to implement than
the other modes.

Midiator models other than MS-124W and MS-124T are currently not supported.
Note that the suffix letter is significant; the MS-124 and MS-124B are not
compatible, nor are the other known models MS-101, MS-101B, MS-103, and MS-114.
I do have documentation (\href{mailto:tim.mann@compaq.com}{tim.mann@compaq.com}) that partially covers these models,
but no units to experiment with.  The MS-124W support is tested with a real unit.
The MS-124T support is untested, but should work.

The Generic driver supports multiple input and output substreams over a single
serial port.  Similar to Roland Soundcanvas mode, F5 NN is used to select the
appropriate input or output stream (depending on the data direction).
Additionally, the CTS signal is used to regulate the data flow.  The number of
inputs is specified by the ins parameter.


\section{Imagination Technologies SPDIF Input Controllers}
\label{sound/cards/img-spdif-in::doc}\label{sound/cards/img-spdif-in:imagination-technologies-spdif-input-controllers}
The Imagination Technologies SPDIF Input controller contains the following
controls:
\begin{itemize}
\item {} 
name='IEC958 Capture Mask',index=0

\end{itemize}

This control returns a mask that shows which of the IEC958 status bits
can be read using the `IEC958 Capture Default' control.
\begin{itemize}
\item {} 
name='IEC958 Capture Default',index=0

\end{itemize}

This control returns the status bits contained within the SPDIF stream that
is being received. The `IEC958 Capture Mask' shows which bits can be read
from this control.
\begin{itemize}
\item {} 
name='SPDIF In Multi Frequency Acquire',index=0

\item {} 
name='SPDIF In Multi Frequency Acquire',index=1

\item {} 
name='SPDIF In Multi Frequency Acquire',index=2

\item {} 
name='SPDIF In Multi Frequency Acquire',index=3

\end{itemize}

This control is used to attempt acquisition of up to four different sample
rates. The active rate can be obtained by reading the `SPDIF In Lock Frequency'
control.

When the value of this control is set to \{0,0,0,0\}, the rate given to hw\_params
will determine the single rate the block will capture. Else, the rate given to
hw\_params will be ignored, and the block will attempt capture for each of the
four sample rates set here.

If less than four rates are required, the same rate can be specified more than
once
\begin{itemize}
\item {} 
name='SPDIF In Lock Frequency',index=0

\end{itemize}

This control returns the active capture rate, or 0 if a lock has not been
acquired
\begin{itemize}
\item {} 
name='SPDIF In Lock TRK',index=0

\end{itemize}

This control is used to modify the locking/jitter rejection characteristics
of the block. Larger values increase the locking range, but reduce jitter
rejection.
\begin{itemize}
\item {} 
name='SPDIF In Lock Acquire Threshold',index=0

\end{itemize}

This control is used to change the threshold at which a lock is acquired.
\begin{itemize}
\item {} 
name='SPDIF In Lock Release Threshold',index=0

\end{itemize}

This control is used to change the threshold at which a lock is released.



\renewcommand{\indexname}{Index}
\printindex
\end{document}
